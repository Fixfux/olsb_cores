{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ChannelApplicationProvidedService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified ChannelApplicationProvidedService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ActiveBuddySubscriberCount_args where 
  arbitrary = QC.elements [ActiveBuddySubscriberCount_args]
from_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args -> T.ThriftVal
from_ActiveBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> ActiveBuddySubscriberCount_args -> P.IO ()
write_ActiveBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_args record
encode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_args -> LBS.ByteString
encode_ActiveBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_args record
to_ActiveBuddySubscriberCount_args :: T.ThriftVal -> ActiveBuddySubscriberCount_args
to_ActiveBuddySubscriberCount_args (T.TStruct fields) = ActiveBuddySubscriberCount_args{

  }
to_ActiveBuddySubscriberCount_args _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_args
read_ActiveBuddySubscriberCount_args iprot = to_ActiveBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args)
decode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_args
decode_ActiveBuddySubscriberCount_args iprot bs = to_ActiveBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args) bs
typemap_ActiveBuddySubscriberCount_args :: T.TypeMap
typemap_ActiveBuddySubscriberCount_args = Map.fromList []
default_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args
default_ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args{
}
data ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result  { activeBuddySubscriberCount_result_success :: I.Int64
  , activeBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` activeBuddySubscriberCount_result_success record   `H.hashWithSalt` activeBuddySubscriberCount_result_e record  
instance QC.Arbitrary ActiveBuddySubscriberCount_result where 
  arbitrary = M.liftM ActiveBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ActiveBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj}
    , if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj}
    ]
from_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result -> T.ThriftVal
from_ActiveBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2338 -> (1, ("e",from_TalkException _v2338))) <$> activeBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2338 -> P.Just (0, ("success",T.TI64 _v2338))) $ activeBuddySubscriberCount_result_success record
    , (\_v2338 -> (1, ("e",from_TalkException _v2338))) <$> activeBuddySubscriberCount_result_e record
    ]
    )
write_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> ActiveBuddySubscriberCount_result -> P.IO ()
write_ActiveBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_result record
encode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_result -> LBS.ByteString
encode_ActiveBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_result record
to_ActiveBuddySubscriberCount_result :: T.ThriftVal -> ActiveBuddySubscriberCount_result
to_ActiveBuddySubscriberCount_result (T.TStruct fields) = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = P.maybe (activeBuddySubscriberCount_result_success default_ActiveBuddySubscriberCount_result) (\(_,_val2340) -> (case _val2340 of {T.TI64 _val2341 -> _val2341; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  activeBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val2340) -> P.Just (case _val2340 of {T.TStruct _val2342 -> (to_TalkException (T.TStruct _val2342)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ActiveBuddySubscriberCount_result _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_result
read_ActiveBuddySubscriberCount_result iprot = to_ActiveBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result)
decode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_result
decode_ActiveBuddySubscriberCount_result iprot bs = to_ActiveBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result) bs
typemap_ActiveBuddySubscriberCount_result :: T.TypeMap
typemap_ActiveBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result
default_ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = 0,
  activeBuddySubscriberCount_result_e = P.Nothing}
data AddOperationForChannel_args = AddOperationForChannel_args  { addOperationForChannel_args_opType :: OpType
  , addOperationForChannel_args_param1 :: LT.Text
  , addOperationForChannel_args_param2 :: LT.Text
  , addOperationForChannel_args_param3 :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_args_opType record   `H.hashWithSalt` addOperationForChannel_args_param1 record   `H.hashWithSalt` addOperationForChannel_args_param2 record   `H.hashWithSalt` addOperationForChannel_args_param3 record  
instance QC.Arbitrary AddOperationForChannel_args where 
  arbitrary = M.liftM AddOperationForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj}
    ]
from_AddOperationForChannel_args :: AddOperationForChannel_args -> T.ThriftVal
from_AddOperationForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2345 -> P.Just (1, ("opType",T.TI32 $ P.fromIntegral $ P.fromEnum _v2345))) $ addOperationForChannel_args_opType record
  , (\_v2345 -> P.Just (2, ("param1",T.TString $ E.encodeUtf8 _v2345))) $ addOperationForChannel_args_param1 record
  , (\_v2345 -> P.Just (3, ("param2",T.TString $ E.encodeUtf8 _v2345))) $ addOperationForChannel_args_param2 record
  , (\_v2345 -> P.Just (4, ("param3",T.TString $ E.encodeUtf8 _v2345))) $ addOperationForChannel_args_param3 record
  ]
write_AddOperationForChannel_args :: T.Protocol p => p -> AddOperationForChannel_args -> P.IO ()
write_AddOperationForChannel_args oprot record = T.writeVal oprot $ from_AddOperationForChannel_args record
encode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> AddOperationForChannel_args -> LBS.ByteString
encode_AddOperationForChannel_args oprot record = T.serializeVal oprot $ from_AddOperationForChannel_args record
to_AddOperationForChannel_args :: T.ThriftVal -> AddOperationForChannel_args
to_AddOperationForChannel_args (T.TStruct fields) = AddOperationForChannel_args{
  addOperationForChannel_args_opType = P.maybe (addOperationForChannel_args_opType default_AddOperationForChannel_args) (\(_,_val2347) -> (case _val2347 of {T.TI32 _val2348 -> P.toEnum $ P.fromIntegral _val2348; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  addOperationForChannel_args_param1 = P.maybe (addOperationForChannel_args_param1 default_AddOperationForChannel_args) (\(_,_val2347) -> (case _val2347 of {T.TString _val2349 -> E.decodeUtf8 _val2349; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addOperationForChannel_args_param2 = P.maybe (addOperationForChannel_args_param2 default_AddOperationForChannel_args) (\(_,_val2347) -> (case _val2347 of {T.TString _val2350 -> E.decodeUtf8 _val2350; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  addOperationForChannel_args_param3 = P.maybe (addOperationForChannel_args_param3 default_AddOperationForChannel_args) (\(_,_val2347) -> (case _val2347 of {T.TString _val2351 -> E.decodeUtf8 _val2351; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_AddOperationForChannel_args _ = P.error "not a struct"
read_AddOperationForChannel_args :: T.Protocol p => p -> P.IO AddOperationForChannel_args
read_AddOperationForChannel_args iprot = to_AddOperationForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args)
decode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_args
decode_AddOperationForChannel_args iprot bs = to_AddOperationForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args) bs
typemap_AddOperationForChannel_args :: T.TypeMap
typemap_AddOperationForChannel_args = Map.fromList [(1,("opType",T.T_I32)),(2,("param1",T.T_STRING)),(3,("param2",T.T_STRING)),(4,("param3",T.T_STRING))]
default_AddOperationForChannel_args :: AddOperationForChannel_args
default_AddOperationForChannel_args = AddOperationForChannel_args{
  addOperationForChannel_args_opType = (P.toEnum 0),
  addOperationForChannel_args_param1 = "",
  addOperationForChannel_args_param2 = "",
  addOperationForChannel_args_param3 = ""}
data AddOperationForChannel_result = AddOperationForChannel_result  { addOperationForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_result_e record  
instance QC.Arbitrary AddOperationForChannel_result where 
  arbitrary = M.liftM AddOperationForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj} then P.Nothing else P.Just $ default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj}
    ]
from_AddOperationForChannel_result :: AddOperationForChannel_result -> T.ThriftVal
from_AddOperationForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2354 -> (1, ("e",from_TalkException _v2354))) <$> addOperationForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2354 -> (1, ("e",from_TalkException _v2354))) <$> addOperationForChannel_result_e record
    ]
    )
write_AddOperationForChannel_result :: T.Protocol p => p -> AddOperationForChannel_result -> P.IO ()
write_AddOperationForChannel_result oprot record = T.writeVal oprot $ from_AddOperationForChannel_result record
encode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> AddOperationForChannel_result -> LBS.ByteString
encode_AddOperationForChannel_result oprot record = T.serializeVal oprot $ from_AddOperationForChannel_result record
to_AddOperationForChannel_result :: T.ThriftVal -> AddOperationForChannel_result
to_AddOperationForChannel_result (T.TStruct fields) = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2356) -> P.Just (case _val2356 of {T.TStruct _val2357 -> (to_TalkException (T.TStruct _val2357)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddOperationForChannel_result _ = P.error "not a struct"
read_AddOperationForChannel_result :: T.Protocol p => p -> P.IO AddOperationForChannel_result
read_AddOperationForChannel_result iprot = to_AddOperationForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result)
decode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_result
decode_AddOperationForChannel_result iprot bs = to_AddOperationForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result) bs
typemap_AddOperationForChannel_result :: T.TypeMap
typemap_AddOperationForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddOperationForChannel_result :: AddOperationForChannel_result
default_AddOperationForChannel_result = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.Nothing}
data DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DisplayBuddySubscriberCount_args where 
  arbitrary = QC.elements [DisplayBuddySubscriberCount_args]
from_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args -> T.ThriftVal
from_DisplayBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> DisplayBuddySubscriberCount_args -> P.IO ()
write_DisplayBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_args record
encode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_args -> LBS.ByteString
encode_DisplayBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_args record
to_DisplayBuddySubscriberCount_args :: T.ThriftVal -> DisplayBuddySubscriberCount_args
to_DisplayBuddySubscriberCount_args (T.TStruct fields) = DisplayBuddySubscriberCount_args{

  }
to_DisplayBuddySubscriberCount_args _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_args
read_DisplayBuddySubscriberCount_args iprot = to_DisplayBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args)
decode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_args
decode_DisplayBuddySubscriberCount_args iprot bs = to_DisplayBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args) bs
typemap_DisplayBuddySubscriberCount_args :: T.TypeMap
typemap_DisplayBuddySubscriberCount_args = Map.fromList []
default_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args
default_DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args{
}
data DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result  { displayBuddySubscriberCount_result_success :: I.Int64
  , displayBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCount_result_success record   `H.hashWithSalt` displayBuddySubscriberCount_result_e record  
instance QC.Arbitrary DisplayBuddySubscriberCount_result where 
  arbitrary = M.liftM DisplayBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj}
    , if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj}
    ]
from_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result -> T.ThriftVal
from_DisplayBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2365 -> (1, ("e",from_TalkException _v2365))) <$> displayBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2365 -> P.Just (0, ("success",T.TI64 _v2365))) $ displayBuddySubscriberCount_result_success record
    , (\_v2365 -> (1, ("e",from_TalkException _v2365))) <$> displayBuddySubscriberCount_result_e record
    ]
    )
write_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> DisplayBuddySubscriberCount_result -> P.IO ()
write_DisplayBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_result record
encode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_result -> LBS.ByteString
encode_DisplayBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_result record
to_DisplayBuddySubscriberCount_result :: T.ThriftVal -> DisplayBuddySubscriberCount_result
to_DisplayBuddySubscriberCount_result (T.TStruct fields) = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = P.maybe (displayBuddySubscriberCount_result_success default_DisplayBuddySubscriberCount_result) (\(_,_val2367) -> (case _val2367 of {T.TI64 _val2368 -> _val2368; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  displayBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val2367) -> P.Just (case _val2367 of {T.TStruct _val2369 -> (to_TalkException (T.TStruct _val2369)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCount_result _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_result
read_DisplayBuddySubscriberCount_result iprot = to_DisplayBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result)
decode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_result
decode_DisplayBuddySubscriberCount_result iprot bs = to_DisplayBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result) bs
typemap_DisplayBuddySubscriberCount_result :: T.TypeMap
typemap_DisplayBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result
default_DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = 0,
  displayBuddySubscriberCount_result_e = P.Nothing}
data FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args  { findContactByUseridWithoutAbuseBlockForChannel_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_args_userid record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_args where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2372 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v2372))) $ findContactByUseridWithoutAbuseBlockForChannel_args_userid record
  ]
write_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
encode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
to_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_args
to_FindContactByUseridWithoutAbuseBlockForChannel_args (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_args_userid default_FindContactByUseridWithoutAbuseBlockForChannel_args) (\(_,_val2374) -> (case _val2374 of {T.TString _val2375 -> E.decodeUtf8 _val2375; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_args _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_args
read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args)
decode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_args
decode_FindContactByUseridWithoutAbuseBlockForChannel_args iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args = Map.fromList [(2,("userid",T.T_STRING))]
default_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args
default_FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = ""}
data FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result  { findContactByUseridWithoutAbuseBlockForChannel_result_success :: Contact
  , findContactByUseridWithoutAbuseBlockForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_success record   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_e record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_result where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj}
    , if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2378 -> (1, ("e",from_TalkException _v2378))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2378 -> P.Just (0, ("success",from_Contact _v2378))) $ findContactByUseridWithoutAbuseBlockForChannel_result_success record
    , (\_v2378 -> (1, ("e",from_TalkException _v2378))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record
    ]
    )
write_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
encode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
to_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_result
to_FindContactByUseridWithoutAbuseBlockForChannel_result (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_result_success default_FindContactByUseridWithoutAbuseBlockForChannel_result) (\(_,_val2380) -> (case _val2380 of {T.TStruct _val2381 -> (to_Contact (T.TStruct _val2381)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2380) -> P.Just (case _val2380 of {T.TStruct _val2382 -> (to_TalkException (T.TStruct _val2382)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_result _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_result
read_FindContactByUseridWithoutAbuseBlockForChannel_result iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result)
decode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_result
decode_FindContactByUseridWithoutAbuseBlockForChannel_result iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result
default_FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = default_Contact,
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Nothing}
data GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetAllContactIdsForChannel_args where 
  arbitrary = QC.elements [GetAllContactIdsForChannel_args]
from_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args -> T.ThriftVal
from_GetAllContactIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetAllContactIdsForChannel_args :: T.Protocol p => p -> GetAllContactIdsForChannel_args -> P.IO ()
write_GetAllContactIdsForChannel_args oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_args record
encode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_args -> LBS.ByteString
encode_GetAllContactIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_args record
to_GetAllContactIdsForChannel_args :: T.ThriftVal -> GetAllContactIdsForChannel_args
to_GetAllContactIdsForChannel_args (T.TStruct fields) = GetAllContactIdsForChannel_args{

  }
to_GetAllContactIdsForChannel_args _ = P.error "not a struct"
read_GetAllContactIdsForChannel_args :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_args
read_GetAllContactIdsForChannel_args iprot = to_GetAllContactIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args)
decode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_args
decode_GetAllContactIdsForChannel_args iprot bs = to_GetAllContactIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args) bs
typemap_GetAllContactIdsForChannel_args :: T.TypeMap
typemap_GetAllContactIdsForChannel_args = Map.fromList []
default_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args
default_GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args{
}
data GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result  { getAllContactIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getAllContactIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllContactIdsForChannel_result_success record   `H.hashWithSalt` getAllContactIdsForChannel_result_e record  
instance QC.Arbitrary GetAllContactIdsForChannel_result where 
  arbitrary = M.liftM GetAllContactIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllContactIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj}
    , if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj}
    ]
from_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result -> T.ThriftVal
from_GetAllContactIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2390 -> (1, ("e",from_TalkException _v2390))) <$> getAllContactIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2390 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v2392 -> T.TString $ E.encodeUtf8 _v2392) $ Vector.toList _v2390))) $ getAllContactIdsForChannel_result_success record
    , (\_v2390 -> (1, ("e",from_TalkException _v2390))) <$> getAllContactIdsForChannel_result_e record
    ]
    )
write_GetAllContactIdsForChannel_result :: T.Protocol p => p -> GetAllContactIdsForChannel_result -> P.IO ()
write_GetAllContactIdsForChannel_result oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_result record
encode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_result -> LBS.ByteString
encode_GetAllContactIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_result record
to_GetAllContactIdsForChannel_result :: T.ThriftVal -> GetAllContactIdsForChannel_result
to_GetAllContactIdsForChannel_result (T.TStruct fields) = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = P.maybe (getAllContactIdsForChannel_result_success default_GetAllContactIdsForChannel_result) (\(_,_val2394) -> (case _val2394 of {T.TList _ _val2395 -> (Vector.fromList $ P.map (\_v2396 -> (case _v2396 of {T.TString _val2397 -> E.decodeUtf8 _val2397; _ -> P.error "wrong type"})) _val2395); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllContactIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2394) -> P.Just (case _val2394 of {T.TStruct _val2398 -> (to_TalkException (T.TStruct _val2398)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllContactIdsForChannel_result _ = P.error "not a struct"
read_GetAllContactIdsForChannel_result :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_result
read_GetAllContactIdsForChannel_result iprot = to_GetAllContactIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result)
decode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_result
decode_GetAllContactIdsForChannel_result iprot bs = to_GetAllContactIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result) bs
typemap_GetAllContactIdsForChannel_result :: T.TypeMap
typemap_GetAllContactIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result
default_GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = Vector.empty,
  getAllContactIdsForChannel_result_e = P.Nothing}
data GetCompactContacts_args = GetCompactContacts_args  { getCompactContacts_args_lastModifiedTimestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_args_lastModifiedTimestamp record  
instance QC.Arbitrary GetCompactContacts_args where 
  arbitrary = M.liftM GetCompactContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj} then P.Nothing else P.Just $ default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj}
    ]
from_GetCompactContacts_args :: GetCompactContacts_args -> T.ThriftVal
from_GetCompactContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2401 -> P.Just (2, ("lastModifiedTimestamp",T.TI64 _v2401))) $ getCompactContacts_args_lastModifiedTimestamp record
  ]
write_GetCompactContacts_args :: T.Protocol p => p -> GetCompactContacts_args -> P.IO ()
write_GetCompactContacts_args oprot record = T.writeVal oprot $ from_GetCompactContacts_args record
encode_GetCompactContacts_args :: T.StatelessProtocol p => p -> GetCompactContacts_args -> LBS.ByteString
encode_GetCompactContacts_args oprot record = T.serializeVal oprot $ from_GetCompactContacts_args record
to_GetCompactContacts_args :: T.ThriftVal -> GetCompactContacts_args
to_GetCompactContacts_args (T.TStruct fields) = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = P.maybe (getCompactContacts_args_lastModifiedTimestamp default_GetCompactContacts_args) (\(_,_val2403) -> (case _val2403 of {T.TI64 _val2404 -> _val2404; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactContacts_args _ = P.error "not a struct"
read_GetCompactContacts_args :: T.Protocol p => p -> P.IO GetCompactContacts_args
read_GetCompactContacts_args iprot = to_GetCompactContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_args)
decode_GetCompactContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_args
decode_GetCompactContacts_args iprot bs = to_GetCompactContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_args) bs
typemap_GetCompactContacts_args :: T.TypeMap
typemap_GetCompactContacts_args = Map.fromList [(2,("lastModifiedTimestamp",T.T_I64))]
default_GetCompactContacts_args :: GetCompactContacts_args
default_GetCompactContacts_args = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = 0}
data GetCompactContacts_result = GetCompactContacts_result  { getCompactContacts_result_success :: (Vector.Vector CompactContact)
  , getCompactContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_result_success record   `H.hashWithSalt` getCompactContacts_result_e record  
instance QC.Arbitrary GetCompactContacts_result where 
  arbitrary = M.liftM GetCompactContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj}
    , if obj == default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj}
    ]
from_GetCompactContacts_result :: GetCompactContacts_result -> T.ThriftVal
from_GetCompactContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2407 -> (1, ("e",from_TalkException _v2407))) <$> getCompactContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2407 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CompactContact) $ P.map (\_v2409 -> from_CompactContact _v2409) $ Vector.toList _v2407))) $ getCompactContacts_result_success record
    , (\_v2407 -> (1, ("e",from_TalkException _v2407))) <$> getCompactContacts_result_e record
    ]
    )
write_GetCompactContacts_result :: T.Protocol p => p -> GetCompactContacts_result -> P.IO ()
write_GetCompactContacts_result oprot record = T.writeVal oprot $ from_GetCompactContacts_result record
encode_GetCompactContacts_result :: T.StatelessProtocol p => p -> GetCompactContacts_result -> LBS.ByteString
encode_GetCompactContacts_result oprot record = T.serializeVal oprot $ from_GetCompactContacts_result record
to_GetCompactContacts_result :: T.ThriftVal -> GetCompactContacts_result
to_GetCompactContacts_result (T.TStruct fields) = GetCompactContacts_result{
  getCompactContacts_result_success = P.maybe (getCompactContacts_result_success default_GetCompactContacts_result) (\(_,_val2411) -> (case _val2411 of {T.TList _ _val2412 -> (Vector.fromList $ P.map (\_v2413 -> (case _v2413 of {T.TStruct _val2414 -> (to_CompactContact (T.TStruct _val2414)); _ -> P.error "wrong type"})) _val2412); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactContacts_result_e = P.maybe (P.Nothing) (\(_,_val2411) -> P.Just (case _val2411 of {T.TStruct _val2415 -> (to_TalkException (T.TStruct _val2415)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactContacts_result _ = P.error "not a struct"
read_GetCompactContacts_result :: T.Protocol p => p -> P.IO GetCompactContacts_result
read_GetCompactContacts_result iprot = to_GetCompactContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_result)
decode_GetCompactContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_result
decode_GetCompactContacts_result iprot bs = to_GetCompactContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_result) bs
typemap_GetCompactContacts_result :: T.TypeMap
typemap_GetCompactContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactContacts_result :: GetCompactContacts_result
default_GetCompactContacts_result = GetCompactContacts_result{
  getCompactContacts_result_success = Vector.empty,
  getCompactContacts_result_e = P.Nothing}
data GetContactsForChannel_args = GetContactsForChannel_args  { getContactsForChannel_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_args_ids record  
instance QC.Arbitrary GetContactsForChannel_args where 
  arbitrary = M.liftM GetContactsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj} then P.Nothing else P.Just $ default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj}
    ]
from_GetContactsForChannel_args :: GetContactsForChannel_args -> T.ThriftVal
from_GetContactsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2418 -> P.Just (2, ("ids",T.TList T.T_STRING $ P.map (\_v2420 -> T.TString $ E.encodeUtf8 _v2420) $ Vector.toList _v2418))) $ getContactsForChannel_args_ids record
  ]
write_GetContactsForChannel_args :: T.Protocol p => p -> GetContactsForChannel_args -> P.IO ()
write_GetContactsForChannel_args oprot record = T.writeVal oprot $ from_GetContactsForChannel_args record
encode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> GetContactsForChannel_args -> LBS.ByteString
encode_GetContactsForChannel_args oprot record = T.serializeVal oprot $ from_GetContactsForChannel_args record
to_GetContactsForChannel_args :: T.ThriftVal -> GetContactsForChannel_args
to_GetContactsForChannel_args (T.TStruct fields) = GetContactsForChannel_args{
  getContactsForChannel_args_ids = P.maybe (getContactsForChannel_args_ids default_GetContactsForChannel_args) (\(_,_val2422) -> (case _val2422 of {T.TList _ _val2423 -> (Vector.fromList $ P.map (\_v2424 -> (case _v2424 of {T.TString _val2425 -> E.decodeUtf8 _val2425; _ -> P.error "wrong type"})) _val2423); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContactsForChannel_args _ = P.error "not a struct"
read_GetContactsForChannel_args :: T.Protocol p => p -> P.IO GetContactsForChannel_args
read_GetContactsForChannel_args iprot = to_GetContactsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args)
decode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_args
decode_GetContactsForChannel_args iprot bs = to_GetContactsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args) bs
typemap_GetContactsForChannel_args :: T.TypeMap
typemap_GetContactsForChannel_args = Map.fromList [(2,("ids",(T.T_LIST T.T_STRING)))]
default_GetContactsForChannel_args :: GetContactsForChannel_args
default_GetContactsForChannel_args = GetContactsForChannel_args{
  getContactsForChannel_args_ids = Vector.empty}
data GetContactsForChannel_result = GetContactsForChannel_result  { getContactsForChannel_result_success :: (Vector.Vector Contact)
  , getContactsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_result_success record   `H.hashWithSalt` getContactsForChannel_result_e record  
instance QC.Arbitrary GetContactsForChannel_result where 
  arbitrary = M.liftM GetContactsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj}
    , if obj == default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj}
    ]
from_GetContactsForChannel_result :: GetContactsForChannel_result -> T.ThriftVal
from_GetContactsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2428 -> (1, ("e",from_TalkException _v2428))) <$> getContactsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2428 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v2430 -> from_Contact _v2430) $ Vector.toList _v2428))) $ getContactsForChannel_result_success record
    , (\_v2428 -> (1, ("e",from_TalkException _v2428))) <$> getContactsForChannel_result_e record
    ]
    )
write_GetContactsForChannel_result :: T.Protocol p => p -> GetContactsForChannel_result -> P.IO ()
write_GetContactsForChannel_result oprot record = T.writeVal oprot $ from_GetContactsForChannel_result record
encode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> GetContactsForChannel_result -> LBS.ByteString
encode_GetContactsForChannel_result oprot record = T.serializeVal oprot $ from_GetContactsForChannel_result record
to_GetContactsForChannel_result :: T.ThriftVal -> GetContactsForChannel_result
to_GetContactsForChannel_result (T.TStruct fields) = GetContactsForChannel_result{
  getContactsForChannel_result_success = P.maybe (getContactsForChannel_result_success default_GetContactsForChannel_result) (\(_,_val2432) -> (case _val2432 of {T.TList _ _val2433 -> (Vector.fromList $ P.map (\_v2434 -> (case _v2434 of {T.TStruct _val2435 -> (to_Contact (T.TStruct _val2435)); _ -> P.error "wrong type"})) _val2433); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContactsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2432) -> P.Just (case _val2432 of {T.TStruct _val2436 -> (to_TalkException (T.TStruct _val2436)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContactsForChannel_result _ = P.error "not a struct"
read_GetContactsForChannel_result :: T.Protocol p => p -> P.IO GetContactsForChannel_result
read_GetContactsForChannel_result iprot = to_GetContactsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result)
decode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_result
decode_GetContactsForChannel_result iprot bs = to_GetContactsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result) bs
typemap_GetContactsForChannel_result :: T.TypeMap
typemap_GetContactsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContactsForChannel_result :: GetContactsForChannel_result
default_GetContactsForChannel_result = GetContactsForChannel_result{
  getContactsForChannel_result_success = Vector.empty,
  getContactsForChannel_result_e = P.Nothing}
data GetDisplayName_args = GetDisplayName_args  { getDisplayName_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_args_mid record  
instance QC.Arbitrary GetDisplayName_args where 
  arbitrary = M.liftM GetDisplayName_args (QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj} then P.Nothing else P.Just $ default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj}
    ]
from_GetDisplayName_args :: GetDisplayName_args -> T.ThriftVal
from_GetDisplayName_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2439 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v2439))) $ getDisplayName_args_mid record
  ]
write_GetDisplayName_args :: T.Protocol p => p -> GetDisplayName_args -> P.IO ()
write_GetDisplayName_args oprot record = T.writeVal oprot $ from_GetDisplayName_args record
encode_GetDisplayName_args :: T.StatelessProtocol p => p -> GetDisplayName_args -> LBS.ByteString
encode_GetDisplayName_args oprot record = T.serializeVal oprot $ from_GetDisplayName_args record
to_GetDisplayName_args :: T.ThriftVal -> GetDisplayName_args
to_GetDisplayName_args (T.TStruct fields) = GetDisplayName_args{
  getDisplayName_args_mid = P.maybe (getDisplayName_args_mid default_GetDisplayName_args) (\(_,_val2441) -> (case _val2441 of {T.TString _val2442 -> E.decodeUtf8 _val2442; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDisplayName_args _ = P.error "not a struct"
read_GetDisplayName_args :: T.Protocol p => p -> P.IO GetDisplayName_args
read_GetDisplayName_args iprot = to_GetDisplayName_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_args)
decode_GetDisplayName_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_args
decode_GetDisplayName_args iprot bs = to_GetDisplayName_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_args) bs
typemap_GetDisplayName_args :: T.TypeMap
typemap_GetDisplayName_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetDisplayName_args :: GetDisplayName_args
default_GetDisplayName_args = GetDisplayName_args{
  getDisplayName_args_mid = ""}
data GetDisplayName_result = GetDisplayName_result  { getDisplayName_result_success :: LT.Text
  , getDisplayName_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_result_success record   `H.hashWithSalt` getDisplayName_result_e record  
instance QC.Arbitrary GetDisplayName_result where 
  arbitrary = M.liftM GetDisplayName_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj}
    , if obj == default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj}
    ]
from_GetDisplayName_result :: GetDisplayName_result -> T.ThriftVal
from_GetDisplayName_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2445 -> (1, ("e",from_TalkException _v2445))) <$> getDisplayName_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2445 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2445))) $ getDisplayName_result_success record
    , (\_v2445 -> (1, ("e",from_TalkException _v2445))) <$> getDisplayName_result_e record
    ]
    )
write_GetDisplayName_result :: T.Protocol p => p -> GetDisplayName_result -> P.IO ()
write_GetDisplayName_result oprot record = T.writeVal oprot $ from_GetDisplayName_result record
encode_GetDisplayName_result :: T.StatelessProtocol p => p -> GetDisplayName_result -> LBS.ByteString
encode_GetDisplayName_result oprot record = T.serializeVal oprot $ from_GetDisplayName_result record
to_GetDisplayName_result :: T.ThriftVal -> GetDisplayName_result
to_GetDisplayName_result (T.TStruct fields) = GetDisplayName_result{
  getDisplayName_result_success = P.maybe (getDisplayName_result_success default_GetDisplayName_result) (\(_,_val2447) -> (case _val2447 of {T.TString _val2448 -> E.decodeUtf8 _val2448; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDisplayName_result_e = P.maybe (P.Nothing) (\(_,_val2447) -> P.Just (case _val2447 of {T.TStruct _val2449 -> (to_TalkException (T.TStruct _val2449)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDisplayName_result _ = P.error "not a struct"
read_GetDisplayName_result :: T.Protocol p => p -> P.IO GetDisplayName_result
read_GetDisplayName_result iprot = to_GetDisplayName_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_result)
decode_GetDisplayName_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_result
decode_GetDisplayName_result iprot bs = to_GetDisplayName_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_result) bs
typemap_GetDisplayName_result :: T.TypeMap
typemap_GetDisplayName_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetDisplayName_result :: GetDisplayName_result
default_GetDisplayName_result = GetDisplayName_result{
  getDisplayName_result_success = "",
  getDisplayName_result_e = P.Nothing}
data GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteMidsForChannel_args where 
  arbitrary = QC.elements [GetFavoriteMidsForChannel_args]
from_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args -> T.ThriftVal
from_GetFavoriteMidsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> GetFavoriteMidsForChannel_args -> P.IO ()
write_GetFavoriteMidsForChannel_args oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_args record
encode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_args -> LBS.ByteString
encode_GetFavoriteMidsForChannel_args oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_args record
to_GetFavoriteMidsForChannel_args :: T.ThriftVal -> GetFavoriteMidsForChannel_args
to_GetFavoriteMidsForChannel_args (T.TStruct fields) = GetFavoriteMidsForChannel_args{

  }
to_GetFavoriteMidsForChannel_args _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_args
read_GetFavoriteMidsForChannel_args iprot = to_GetFavoriteMidsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args)
decode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_args
decode_GetFavoriteMidsForChannel_args iprot bs = to_GetFavoriteMidsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args) bs
typemap_GetFavoriteMidsForChannel_args :: T.TypeMap
typemap_GetFavoriteMidsForChannel_args = Map.fromList []
default_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args
default_GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args{
}
data GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result  { getFavoriteMidsForChannel_result_success :: (Vector.Vector LT.Text)
  , getFavoriteMidsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteMidsForChannel_result_success record   `H.hashWithSalt` getFavoriteMidsForChannel_result_e record  
instance QC.Arbitrary GetFavoriteMidsForChannel_result where 
  arbitrary = M.liftM GetFavoriteMidsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteMidsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj}
    , if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj}
    ]
from_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result -> T.ThriftVal
from_GetFavoriteMidsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2457 -> (1, ("e",from_TalkException _v2457))) <$> getFavoriteMidsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2457 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v2459 -> T.TString $ E.encodeUtf8 _v2459) $ Vector.toList _v2457))) $ getFavoriteMidsForChannel_result_success record
    , (\_v2457 -> (1, ("e",from_TalkException _v2457))) <$> getFavoriteMidsForChannel_result_e record
    ]
    )
write_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> GetFavoriteMidsForChannel_result -> P.IO ()
write_GetFavoriteMidsForChannel_result oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_result record
encode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_result -> LBS.ByteString
encode_GetFavoriteMidsForChannel_result oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_result record
to_GetFavoriteMidsForChannel_result :: T.ThriftVal -> GetFavoriteMidsForChannel_result
to_GetFavoriteMidsForChannel_result (T.TStruct fields) = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = P.maybe (getFavoriteMidsForChannel_result_success default_GetFavoriteMidsForChannel_result) (\(_,_val2461) -> (case _val2461 of {T.TList _ _val2462 -> (Vector.fromList $ P.map (\_v2463 -> (case _v2463 of {T.TString _val2464 -> E.decodeUtf8 _val2464; _ -> P.error "wrong type"})) _val2462); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteMidsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2461) -> P.Just (case _val2461 of {T.TStruct _val2465 -> (to_TalkException (T.TStruct _val2465)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteMidsForChannel_result _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_result
read_GetFavoriteMidsForChannel_result iprot = to_GetFavoriteMidsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result)
decode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_result
decode_GetFavoriteMidsForChannel_result iprot bs = to_GetFavoriteMidsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result) bs
typemap_GetFavoriteMidsForChannel_result :: T.TypeMap
typemap_GetFavoriteMidsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result
default_GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = Vector.empty,
  getFavoriteMidsForChannel_result_e = P.Nothing}
data GetFriendMids_args = GetFriendMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFriendMids_args where 
  arbitrary = QC.elements [GetFriendMids_args]
from_GetFriendMids_args :: GetFriendMids_args -> T.ThriftVal
from_GetFriendMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFriendMids_args :: T.Protocol p => p -> GetFriendMids_args -> P.IO ()
write_GetFriendMids_args oprot record = T.writeVal oprot $ from_GetFriendMids_args record
encode_GetFriendMids_args :: T.StatelessProtocol p => p -> GetFriendMids_args -> LBS.ByteString
encode_GetFriendMids_args oprot record = T.serializeVal oprot $ from_GetFriendMids_args record
to_GetFriendMids_args :: T.ThriftVal -> GetFriendMids_args
to_GetFriendMids_args (T.TStruct fields) = GetFriendMids_args{

  }
to_GetFriendMids_args _ = P.error "not a struct"
read_GetFriendMids_args :: T.Protocol p => p -> P.IO GetFriendMids_args
read_GetFriendMids_args iprot = to_GetFriendMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_args)
decode_GetFriendMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_args
decode_GetFriendMids_args iprot bs = to_GetFriendMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_args) bs
typemap_GetFriendMids_args :: T.TypeMap
typemap_GetFriendMids_args = Map.fromList []
default_GetFriendMids_args :: GetFriendMids_args
default_GetFriendMids_args = GetFriendMids_args{
}
data GetFriendMids_result = GetFriendMids_result  { getFriendMids_result_success :: (Vector.Vector LT.Text)
  , getFriendMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendMids_result_success record   `H.hashWithSalt` getFriendMids_result_e record  
instance QC.Arbitrary GetFriendMids_result where 
  arbitrary = M.liftM GetFriendMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj}
    , if obj == default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj}
    ]
from_GetFriendMids_result :: GetFriendMids_result -> T.ThriftVal
from_GetFriendMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2473 -> (1, ("e",from_TalkException _v2473))) <$> getFriendMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2473 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v2475 -> T.TString $ E.encodeUtf8 _v2475) $ Vector.toList _v2473))) $ getFriendMids_result_success record
    , (\_v2473 -> (1, ("e",from_TalkException _v2473))) <$> getFriendMids_result_e record
    ]
    )
write_GetFriendMids_result :: T.Protocol p => p -> GetFriendMids_result -> P.IO ()
write_GetFriendMids_result oprot record = T.writeVal oprot $ from_GetFriendMids_result record
encode_GetFriendMids_result :: T.StatelessProtocol p => p -> GetFriendMids_result -> LBS.ByteString
encode_GetFriendMids_result oprot record = T.serializeVal oprot $ from_GetFriendMids_result record
to_GetFriendMids_result :: T.ThriftVal -> GetFriendMids_result
to_GetFriendMids_result (T.TStruct fields) = GetFriendMids_result{
  getFriendMids_result_success = P.maybe (getFriendMids_result_success default_GetFriendMids_result) (\(_,_val2477) -> (case _val2477 of {T.TList _ _val2478 -> (Vector.fromList $ P.map (\_v2479 -> (case _v2479 of {T.TString _val2480 -> E.decodeUtf8 _val2480; _ -> P.error "wrong type"})) _val2478); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendMids_result_e = P.maybe (P.Nothing) (\(_,_val2477) -> P.Just (case _val2477 of {T.TStruct _val2481 -> (to_TalkException (T.TStruct _val2481)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendMids_result _ = P.error "not a struct"
read_GetFriendMids_result :: T.Protocol p => p -> P.IO GetFriendMids_result
read_GetFriendMids_result iprot = to_GetFriendMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_result)
decode_GetFriendMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_result
decode_GetFriendMids_result iprot bs = to_GetFriendMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_result) bs
typemap_GetFriendMids_result :: T.TypeMap
typemap_GetFriendMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFriendMids_result :: GetFriendMids_result
default_GetFriendMids_result = GetFriendMids_result{
  getFriendMids_result_success = Vector.empty,
  getFriendMids_result_e = P.Nothing}
data GetGroupMemberMids_args = GetGroupMemberMids_args  { getGroupMemberMids_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_args_groupId record  
instance QC.Arbitrary GetGroupMemberMids_args where 
  arbitrary = M.liftM GetGroupMemberMids_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj}
    ]
from_GetGroupMemberMids_args :: GetGroupMemberMids_args -> T.ThriftVal
from_GetGroupMemberMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2484 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v2484))) $ getGroupMemberMids_args_groupId record
  ]
write_GetGroupMemberMids_args :: T.Protocol p => p -> GetGroupMemberMids_args -> P.IO ()
write_GetGroupMemberMids_args oprot record = T.writeVal oprot $ from_GetGroupMemberMids_args record
encode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> GetGroupMemberMids_args -> LBS.ByteString
encode_GetGroupMemberMids_args oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_args record
to_GetGroupMemberMids_args :: T.ThriftVal -> GetGroupMemberMids_args
to_GetGroupMemberMids_args (T.TStruct fields) = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = P.maybe (getGroupMemberMids_args_groupId default_GetGroupMemberMids_args) (\(_,_val2486) -> (case _val2486 of {T.TString _val2487 -> E.decodeUtf8 _val2487; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_args _ = P.error "not a struct"
read_GetGroupMemberMids_args :: T.Protocol p => p -> P.IO GetGroupMemberMids_args
read_GetGroupMemberMids_args iprot = to_GetGroupMemberMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args)
decode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_args
decode_GetGroupMemberMids_args iprot bs = to_GetGroupMemberMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args) bs
typemap_GetGroupMemberMids_args :: T.TypeMap
typemap_GetGroupMemberMids_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_GetGroupMemberMids_args :: GetGroupMemberMids_args
default_GetGroupMemberMids_args = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = ""}
data GetGroupMemberMids_result = GetGroupMemberMids_result  { getGroupMemberMids_result_success :: (Vector.Vector LT.Text)
  , getGroupMemberMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_result_success record   `H.hashWithSalt` getGroupMemberMids_result_e record  
instance QC.Arbitrary GetGroupMemberMids_result where 
  arbitrary = M.liftM GetGroupMemberMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj}
    , if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj}
    ]
from_GetGroupMemberMids_result :: GetGroupMemberMids_result -> T.ThriftVal
from_GetGroupMemberMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2490 -> (1, ("e",from_TalkException _v2490))) <$> getGroupMemberMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2490 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v2492 -> T.TString $ E.encodeUtf8 _v2492) $ Vector.toList _v2490))) $ getGroupMemberMids_result_success record
    , (\_v2490 -> (1, ("e",from_TalkException _v2490))) <$> getGroupMemberMids_result_e record
    ]
    )
write_GetGroupMemberMids_result :: T.Protocol p => p -> GetGroupMemberMids_result -> P.IO ()
write_GetGroupMemberMids_result oprot record = T.writeVal oprot $ from_GetGroupMemberMids_result record
encode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> GetGroupMemberMids_result -> LBS.ByteString
encode_GetGroupMemberMids_result oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_result record
to_GetGroupMemberMids_result :: T.ThriftVal -> GetGroupMemberMids_result
to_GetGroupMemberMids_result (T.TStruct fields) = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = P.maybe (getGroupMemberMids_result_success default_GetGroupMemberMids_result) (\(_,_val2494) -> (case _val2494 of {T.TList _ _val2495 -> (Vector.fromList $ P.map (\_v2496 -> (case _v2496 of {T.TString _val2497 -> E.decodeUtf8 _val2497; _ -> P.error "wrong type"})) _val2495); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupMemberMids_result_e = P.maybe (P.Nothing) (\(_,_val2494) -> P.Just (case _val2494 of {T.TStruct _val2498 -> (to_TalkException (T.TStruct _val2498)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_result _ = P.error "not a struct"
read_GetGroupMemberMids_result :: T.Protocol p => p -> P.IO GetGroupMemberMids_result
read_GetGroupMemberMids_result iprot = to_GetGroupMemberMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result)
decode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_result
decode_GetGroupMemberMids_result iprot bs = to_GetGroupMemberMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result) bs
typemap_GetGroupMemberMids_result :: T.TypeMap
typemap_GetGroupMemberMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupMemberMids_result :: GetGroupMemberMids_result
default_GetGroupMemberMids_result = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = Vector.empty,
  getGroupMemberMids_result_e = P.Nothing}
data GetGroupsForChannel_args = GetGroupsForChannel_args  { getGroupsForChannel_args_groupIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_args_groupIds record  
instance QC.Arbitrary GetGroupsForChannel_args where 
  arbitrary = M.liftM GetGroupsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj}
    ]
from_GetGroupsForChannel_args :: GetGroupsForChannel_args -> T.ThriftVal
from_GetGroupsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2501 -> P.Just (1, ("groupIds",T.TList T.T_STRING $ P.map (\_v2503 -> T.TString $ E.encodeUtf8 _v2503) $ Vector.toList _v2501))) $ getGroupsForChannel_args_groupIds record
  ]
write_GetGroupsForChannel_args :: T.Protocol p => p -> GetGroupsForChannel_args -> P.IO ()
write_GetGroupsForChannel_args oprot record = T.writeVal oprot $ from_GetGroupsForChannel_args record
encode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> GetGroupsForChannel_args -> LBS.ByteString
encode_GetGroupsForChannel_args oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_args record
to_GetGroupsForChannel_args :: T.ThriftVal -> GetGroupsForChannel_args
to_GetGroupsForChannel_args (T.TStruct fields) = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = P.maybe (getGroupsForChannel_args_groupIds default_GetGroupsForChannel_args) (\(_,_val2505) -> (case _val2505 of {T.TList _ _val2506 -> (Vector.fromList $ P.map (\_v2507 -> (case _v2507 of {T.TString _val2508 -> E.decodeUtf8 _val2508; _ -> P.error "wrong type"})) _val2506); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_args _ = P.error "not a struct"
read_GetGroupsForChannel_args :: T.Protocol p => p -> P.IO GetGroupsForChannel_args
read_GetGroupsForChannel_args iprot = to_GetGroupsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args)
decode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_args
decode_GetGroupsForChannel_args iprot bs = to_GetGroupsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args) bs
typemap_GetGroupsForChannel_args :: T.TypeMap
typemap_GetGroupsForChannel_args = Map.fromList [(1,("groupIds",(T.T_LIST T.T_STRING)))]
default_GetGroupsForChannel_args :: GetGroupsForChannel_args
default_GetGroupsForChannel_args = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = Vector.empty}
data GetGroupsForChannel_result = GetGroupsForChannel_result  { getGroupsForChannel_result_success :: (Vector.Vector Group)
  , getGroupsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_result_success record   `H.hashWithSalt` getGroupsForChannel_result_e record  
instance QC.Arbitrary GetGroupsForChannel_result where 
  arbitrary = M.liftM GetGroupsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj}
    , if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj}
    ]
from_GetGroupsForChannel_result :: GetGroupsForChannel_result -> T.ThriftVal
from_GetGroupsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2511 -> (1, ("e",from_TalkException _v2511))) <$> getGroupsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2511 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v2513 -> from_Group _v2513) $ Vector.toList _v2511))) $ getGroupsForChannel_result_success record
    , (\_v2511 -> (1, ("e",from_TalkException _v2511))) <$> getGroupsForChannel_result_e record
    ]
    )
write_GetGroupsForChannel_result :: T.Protocol p => p -> GetGroupsForChannel_result -> P.IO ()
write_GetGroupsForChannel_result oprot record = T.writeVal oprot $ from_GetGroupsForChannel_result record
encode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> GetGroupsForChannel_result -> LBS.ByteString
encode_GetGroupsForChannel_result oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_result record
to_GetGroupsForChannel_result :: T.ThriftVal -> GetGroupsForChannel_result
to_GetGroupsForChannel_result (T.TStruct fields) = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = P.maybe (getGroupsForChannel_result_success default_GetGroupsForChannel_result) (\(_,_val2515) -> (case _val2515 of {T.TList _ _val2516 -> (Vector.fromList $ P.map (\_v2517 -> (case _v2517 of {T.TStruct _val2518 -> (to_Group (T.TStruct _val2518)); _ -> P.error "wrong type"})) _val2516); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2515) -> P.Just (case _val2515 of {T.TStruct _val2519 -> (to_TalkException (T.TStruct _val2519)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_result _ = P.error "not a struct"
read_GetGroupsForChannel_result :: T.Protocol p => p -> P.IO GetGroupsForChannel_result
read_GetGroupsForChannel_result iprot = to_GetGroupsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result)
decode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_result
decode_GetGroupsForChannel_result iprot bs = to_GetGroupsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result) bs
typemap_GetGroupsForChannel_result :: T.TypeMap
typemap_GetGroupsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Group)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupsForChannel_result :: GetGroupsForChannel_result
default_GetGroupsForChannel_result = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = Vector.empty,
  getGroupsForChannel_result_e = P.Nothing}
data GetIdentityCredential_args = GetIdentityCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetIdentityCredential_args where 
  arbitrary = QC.elements [GetIdentityCredential_args]
from_GetIdentityCredential_args :: GetIdentityCredential_args -> T.ThriftVal
from_GetIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetIdentityCredential_args :: T.Protocol p => p -> GetIdentityCredential_args -> P.IO ()
write_GetIdentityCredential_args oprot record = T.writeVal oprot $ from_GetIdentityCredential_args record
encode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> GetIdentityCredential_args -> LBS.ByteString
encode_GetIdentityCredential_args oprot record = T.serializeVal oprot $ from_GetIdentityCredential_args record
to_GetIdentityCredential_args :: T.ThriftVal -> GetIdentityCredential_args
to_GetIdentityCredential_args (T.TStruct fields) = GetIdentityCredential_args{

  }
to_GetIdentityCredential_args _ = P.error "not a struct"
read_GetIdentityCredential_args :: T.Protocol p => p -> P.IO GetIdentityCredential_args
read_GetIdentityCredential_args iprot = to_GetIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args)
decode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_args
decode_GetIdentityCredential_args iprot bs = to_GetIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args) bs
typemap_GetIdentityCredential_args :: T.TypeMap
typemap_GetIdentityCredential_args = Map.fromList []
default_GetIdentityCredential_args :: GetIdentityCredential_args
default_GetIdentityCredential_args = GetIdentityCredential_args{
}
data GetIdentityCredential_result = GetIdentityCredential_result  { getIdentityCredential_result_success :: IdentityCredential
  , getIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getIdentityCredential_result_success record   `H.hashWithSalt` getIdentityCredential_result_e record  
instance QC.Arbitrary GetIdentityCredential_result where 
  arbitrary = M.liftM GetIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj}
    , if obj == default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj}
    ]
from_GetIdentityCredential_result :: GetIdentityCredential_result -> T.ThriftVal
from_GetIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2527 -> (1, ("e",from_TalkException _v2527))) <$> getIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2527 -> P.Just (0, ("success",from_IdentityCredential _v2527))) $ getIdentityCredential_result_success record
    , (\_v2527 -> (1, ("e",from_TalkException _v2527))) <$> getIdentityCredential_result_e record
    ]
    )
write_GetIdentityCredential_result :: T.Protocol p => p -> GetIdentityCredential_result -> P.IO ()
write_GetIdentityCredential_result oprot record = T.writeVal oprot $ from_GetIdentityCredential_result record
encode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> GetIdentityCredential_result -> LBS.ByteString
encode_GetIdentityCredential_result oprot record = T.serializeVal oprot $ from_GetIdentityCredential_result record
to_GetIdentityCredential_result :: T.ThriftVal -> GetIdentityCredential_result
to_GetIdentityCredential_result (T.TStruct fields) = GetIdentityCredential_result{
  getIdentityCredential_result_success = P.maybe (getIdentityCredential_result_success default_GetIdentityCredential_result) (\(_,_val2529) -> (case _val2529 of {T.TStruct _val2530 -> (to_IdentityCredential (T.TStruct _val2530)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val2529) -> P.Just (case _val2529 of {T.TStruct _val2531 -> (to_TalkException (T.TStruct _val2531)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetIdentityCredential_result _ = P.error "not a struct"
read_GetIdentityCredential_result :: T.Protocol p => p -> P.IO GetIdentityCredential_result
read_GetIdentityCredential_result iprot = to_GetIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result)
decode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_result
decode_GetIdentityCredential_result iprot bs = to_GetIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result) bs
typemap_GetIdentityCredential_result :: T.TypeMap
typemap_GetIdentityCredential_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_IdentityCredential))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetIdentityCredential_result :: GetIdentityCredential_result
default_GetIdentityCredential_result = GetIdentityCredential_result{
  getIdentityCredential_result_success = default_IdentityCredential,
  getIdentityCredential_result_e = P.Nothing}
data GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_args where 
  arbitrary = QC.elements [GetJoinedGroupIdsForChannel_args]
from_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_args -> P.IO ()
write_GetJoinedGroupIdsForChannel_args oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
encode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_args -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
to_GetJoinedGroupIdsForChannel_args :: T.ThriftVal -> GetJoinedGroupIdsForChannel_args
to_GetJoinedGroupIdsForChannel_args (T.TStruct fields) = GetJoinedGroupIdsForChannel_args{

  }
to_GetJoinedGroupIdsForChannel_args _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_args
read_GetJoinedGroupIdsForChannel_args iprot = to_GetJoinedGroupIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args)
decode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_args
decode_GetJoinedGroupIdsForChannel_args iprot bs = to_GetJoinedGroupIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args) bs
typemap_GetJoinedGroupIdsForChannel_args :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_args = Map.fromList []
default_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args
default_GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args{
}
data GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result  { getJoinedGroupIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getJoinedGroupIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_success record   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_e record  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_result where 
  arbitrary = M.liftM GetJoinedGroupIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetJoinedGroupIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj}
    , if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj}
    ]
from_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2539 -> (1, ("e",from_TalkException _v2539))) <$> getJoinedGroupIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2539 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v2541 -> T.TString $ E.encodeUtf8 _v2541) $ Vector.toList _v2539))) $ getJoinedGroupIdsForChannel_result_success record
    , (\_v2539 -> (1, ("e",from_TalkException _v2539))) <$> getJoinedGroupIdsForChannel_result_e record
    ]
    )
write_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_result -> P.IO ()
write_GetJoinedGroupIdsForChannel_result oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
encode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_result -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
to_GetJoinedGroupIdsForChannel_result :: T.ThriftVal -> GetJoinedGroupIdsForChannel_result
to_GetJoinedGroupIdsForChannel_result (T.TStruct fields) = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = P.maybe (getJoinedGroupIdsForChannel_result_success default_GetJoinedGroupIdsForChannel_result) (\(_,_val2543) -> (case _val2543 of {T.TList _ _val2544 -> (Vector.fromList $ P.map (\_v2545 -> (case _v2545 of {T.TString _val2546 -> E.decodeUtf8 _val2546; _ -> P.error "wrong type"})) _val2544); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getJoinedGroupIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2543) -> P.Just (case _val2543 of {T.TStruct _val2547 -> (to_TalkException (T.TStruct _val2547)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedGroupIdsForChannel_result _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_result
read_GetJoinedGroupIdsForChannel_result iprot = to_GetJoinedGroupIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result)
decode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_result
decode_GetJoinedGroupIdsForChannel_result iprot bs = to_GetJoinedGroupIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result) bs
typemap_GetJoinedGroupIdsForChannel_result :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result
default_GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = Vector.empty,
  getJoinedGroupIdsForChannel_result_e = P.Nothing}
data GetMetaProfile_args = GetMetaProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMetaProfile_args where 
  arbitrary = QC.elements [GetMetaProfile_args]
from_GetMetaProfile_args :: GetMetaProfile_args -> T.ThriftVal
from_GetMetaProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMetaProfile_args :: T.Protocol p => p -> GetMetaProfile_args -> P.IO ()
write_GetMetaProfile_args oprot record = T.writeVal oprot $ from_GetMetaProfile_args record
encode_GetMetaProfile_args :: T.StatelessProtocol p => p -> GetMetaProfile_args -> LBS.ByteString
encode_GetMetaProfile_args oprot record = T.serializeVal oprot $ from_GetMetaProfile_args record
to_GetMetaProfile_args :: T.ThriftVal -> GetMetaProfile_args
to_GetMetaProfile_args (T.TStruct fields) = GetMetaProfile_args{

  }
to_GetMetaProfile_args _ = P.error "not a struct"
read_GetMetaProfile_args :: T.Protocol p => p -> P.IO GetMetaProfile_args
read_GetMetaProfile_args iprot = to_GetMetaProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_args)
decode_GetMetaProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_args
decode_GetMetaProfile_args iprot bs = to_GetMetaProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_args) bs
typemap_GetMetaProfile_args :: T.TypeMap
typemap_GetMetaProfile_args = Map.fromList []
default_GetMetaProfile_args :: GetMetaProfile_args
default_GetMetaProfile_args = GetMetaProfile_args{
}
data GetMetaProfile_result = GetMetaProfile_result  { getMetaProfile_result_success :: MetaProfile
  , getMetaProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMetaProfile_result_success record   `H.hashWithSalt` getMetaProfile_result_e record  
instance QC.Arbitrary GetMetaProfile_result where 
  arbitrary = M.liftM GetMetaProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMetaProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj}
    , if obj == default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj}
    ]
from_GetMetaProfile_result :: GetMetaProfile_result -> T.ThriftVal
from_GetMetaProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2555 -> (1, ("e",from_TalkException _v2555))) <$> getMetaProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2555 -> P.Just (0, ("success",from_MetaProfile _v2555))) $ getMetaProfile_result_success record
    , (\_v2555 -> (1, ("e",from_TalkException _v2555))) <$> getMetaProfile_result_e record
    ]
    )
write_GetMetaProfile_result :: T.Protocol p => p -> GetMetaProfile_result -> P.IO ()
write_GetMetaProfile_result oprot record = T.writeVal oprot $ from_GetMetaProfile_result record
encode_GetMetaProfile_result :: T.StatelessProtocol p => p -> GetMetaProfile_result -> LBS.ByteString
encode_GetMetaProfile_result oprot record = T.serializeVal oprot $ from_GetMetaProfile_result record
to_GetMetaProfile_result :: T.ThriftVal -> GetMetaProfile_result
to_GetMetaProfile_result (T.TStruct fields) = GetMetaProfile_result{
  getMetaProfile_result_success = P.maybe (getMetaProfile_result_success default_GetMetaProfile_result) (\(_,_val2557) -> (case _val2557 of {T.TStruct _val2558 -> (to_MetaProfile (T.TStruct _val2558)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMetaProfile_result_e = P.maybe (P.Nothing) (\(_,_val2557) -> P.Just (case _val2557 of {T.TStruct _val2559 -> (to_TalkException (T.TStruct _val2559)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMetaProfile_result _ = P.error "not a struct"
read_GetMetaProfile_result :: T.Protocol p => p -> P.IO GetMetaProfile_result
read_GetMetaProfile_result iprot = to_GetMetaProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_result)
decode_GetMetaProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_result
decode_GetMetaProfile_result iprot bs = to_GetMetaProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_result) bs
typemap_GetMetaProfile_result :: T.TypeMap
typemap_GetMetaProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_MetaProfile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMetaProfile_result :: GetMetaProfile_result
default_GetMetaProfile_result = GetMetaProfile_result{
  getMetaProfile_result_success = default_MetaProfile,
  getMetaProfile_result_e = P.Nothing}
data GetMid_args = GetMid_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMid_args where 
  arbitrary = QC.elements [GetMid_args]
from_GetMid_args :: GetMid_args -> T.ThriftVal
from_GetMid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMid_args :: T.Protocol p => p -> GetMid_args -> P.IO ()
write_GetMid_args oprot record = T.writeVal oprot $ from_GetMid_args record
encode_GetMid_args :: T.StatelessProtocol p => p -> GetMid_args -> LBS.ByteString
encode_GetMid_args oprot record = T.serializeVal oprot $ from_GetMid_args record
to_GetMid_args :: T.ThriftVal -> GetMid_args
to_GetMid_args (T.TStruct fields) = GetMid_args{

  }
to_GetMid_args _ = P.error "not a struct"
read_GetMid_args :: T.Protocol p => p -> P.IO GetMid_args
read_GetMid_args iprot = to_GetMid_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_args)
decode_GetMid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_args
decode_GetMid_args iprot bs = to_GetMid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_args) bs
typemap_GetMid_args :: T.TypeMap
typemap_GetMid_args = Map.fromList []
default_GetMid_args :: GetMid_args
default_GetMid_args = GetMid_args{
}
data GetMid_result = GetMid_result  { getMid_result_success :: LT.Text
  , getMid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMid_result_success record   `H.hashWithSalt` getMid_result_e record  
instance QC.Arbitrary GetMid_result where 
  arbitrary = M.liftM GetMid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMid_result{getMid_result_success = getMid_result_success obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_success = getMid_result_success obj}
    , if obj == default_GetMid_result{getMid_result_e = getMid_result_e obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_e = getMid_result_e obj}
    ]
from_GetMid_result :: GetMid_result -> T.ThriftVal
from_GetMid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2567 -> (1, ("e",from_TalkException _v2567))) <$> getMid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2567 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2567))) $ getMid_result_success record
    , (\_v2567 -> (1, ("e",from_TalkException _v2567))) <$> getMid_result_e record
    ]
    )
write_GetMid_result :: T.Protocol p => p -> GetMid_result -> P.IO ()
write_GetMid_result oprot record = T.writeVal oprot $ from_GetMid_result record
encode_GetMid_result :: T.StatelessProtocol p => p -> GetMid_result -> LBS.ByteString
encode_GetMid_result oprot record = T.serializeVal oprot $ from_GetMid_result record
to_GetMid_result :: T.ThriftVal -> GetMid_result
to_GetMid_result (T.TStruct fields) = GetMid_result{
  getMid_result_success = P.maybe (getMid_result_success default_GetMid_result) (\(_,_val2569) -> (case _val2569 of {T.TString _val2570 -> E.decodeUtf8 _val2570; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMid_result_e = P.maybe (P.Nothing) (\(_,_val2569) -> P.Just (case _val2569 of {T.TStruct _val2571 -> (to_TalkException (T.TStruct _val2571)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMid_result _ = P.error "not a struct"
read_GetMid_result :: T.Protocol p => p -> P.IO GetMid_result
read_GetMid_result iprot = to_GetMid_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_result)
decode_GetMid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_result
decode_GetMid_result iprot bs = to_GetMid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_result) bs
typemap_GetMid_result :: T.TypeMap
typemap_GetMid_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMid_result :: GetMid_result
default_GetMid_result = GetMid_result{
  getMid_result_success = "",
  getMid_result_e = P.Nothing}
data GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetPrimaryClientForChannel_args where 
  arbitrary = QC.elements [GetPrimaryClientForChannel_args]
from_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args -> T.ThriftVal
from_GetPrimaryClientForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetPrimaryClientForChannel_args :: T.Protocol p => p -> GetPrimaryClientForChannel_args -> P.IO ()
write_GetPrimaryClientForChannel_args oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_args record
encode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_args -> LBS.ByteString
encode_GetPrimaryClientForChannel_args oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_args record
to_GetPrimaryClientForChannel_args :: T.ThriftVal -> GetPrimaryClientForChannel_args
to_GetPrimaryClientForChannel_args (T.TStruct fields) = GetPrimaryClientForChannel_args{

  }
to_GetPrimaryClientForChannel_args _ = P.error "not a struct"
read_GetPrimaryClientForChannel_args :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_args
read_GetPrimaryClientForChannel_args iprot = to_GetPrimaryClientForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args)
decode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_args
decode_GetPrimaryClientForChannel_args iprot bs = to_GetPrimaryClientForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args) bs
typemap_GetPrimaryClientForChannel_args :: T.TypeMap
typemap_GetPrimaryClientForChannel_args = Map.fromList []
default_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args
default_GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args{
}
data GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result  { getPrimaryClientForChannel_result_success :: SimpleChannelClient
  , getPrimaryClientForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientForChannel_result_success record   `H.hashWithSalt` getPrimaryClientForChannel_result_e record  
instance QC.Arbitrary GetPrimaryClientForChannel_result where 
  arbitrary = M.liftM GetPrimaryClientForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj}
    , if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj}
    ]
from_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result -> T.ThriftVal
from_GetPrimaryClientForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2579 -> (1, ("e",from_TalkException _v2579))) <$> getPrimaryClientForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2579 -> P.Just (0, ("success",from_SimpleChannelClient _v2579))) $ getPrimaryClientForChannel_result_success record
    , (\_v2579 -> (1, ("e",from_TalkException _v2579))) <$> getPrimaryClientForChannel_result_e record
    ]
    )
write_GetPrimaryClientForChannel_result :: T.Protocol p => p -> GetPrimaryClientForChannel_result -> P.IO ()
write_GetPrimaryClientForChannel_result oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_result record
encode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_result -> LBS.ByteString
encode_GetPrimaryClientForChannel_result oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_result record
to_GetPrimaryClientForChannel_result :: T.ThriftVal -> GetPrimaryClientForChannel_result
to_GetPrimaryClientForChannel_result (T.TStruct fields) = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = P.maybe (getPrimaryClientForChannel_result_success default_GetPrimaryClientForChannel_result) (\(_,_val2581) -> (case _val2581 of {T.TStruct _val2582 -> (to_SimpleChannelClient (T.TStruct _val2582)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPrimaryClientForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2581) -> P.Just (case _val2581 of {T.TStruct _val2583 -> (to_TalkException (T.TStruct _val2583)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientForChannel_result _ = P.error "not a struct"
read_GetPrimaryClientForChannel_result :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_result
read_GetPrimaryClientForChannel_result iprot = to_GetPrimaryClientForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result)
decode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_result
decode_GetPrimaryClientForChannel_result iprot bs = to_GetPrimaryClientForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result) bs
typemap_GetPrimaryClientForChannel_result :: T.TypeMap
typemap_GetPrimaryClientForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SimpleChannelClient))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result
default_GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = default_SimpleChannelClient,
  getPrimaryClientForChannel_result_e = P.Nothing}
data GetProfileForChannel_args = GetProfileForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetProfileForChannel_args where 
  arbitrary = QC.elements [GetProfileForChannel_args]
from_GetProfileForChannel_args :: GetProfileForChannel_args -> T.ThriftVal
from_GetProfileForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetProfileForChannel_args :: T.Protocol p => p -> GetProfileForChannel_args -> P.IO ()
write_GetProfileForChannel_args oprot record = T.writeVal oprot $ from_GetProfileForChannel_args record
encode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> GetProfileForChannel_args -> LBS.ByteString
encode_GetProfileForChannel_args oprot record = T.serializeVal oprot $ from_GetProfileForChannel_args record
to_GetProfileForChannel_args :: T.ThriftVal -> GetProfileForChannel_args
to_GetProfileForChannel_args (T.TStruct fields) = GetProfileForChannel_args{

  }
to_GetProfileForChannel_args _ = P.error "not a struct"
read_GetProfileForChannel_args :: T.Protocol p => p -> P.IO GetProfileForChannel_args
read_GetProfileForChannel_args iprot = to_GetProfileForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args)
decode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_args
decode_GetProfileForChannel_args iprot bs = to_GetProfileForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args) bs
typemap_GetProfileForChannel_args :: T.TypeMap
typemap_GetProfileForChannel_args = Map.fromList []
default_GetProfileForChannel_args :: GetProfileForChannel_args
default_GetProfileForChannel_args = GetProfileForChannel_args{
}
data GetProfileForChannel_result = GetProfileForChannel_result  { getProfileForChannel_result_success :: Profile
  , getProfileForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProfileForChannel_result_success record   `H.hashWithSalt` getProfileForChannel_result_e record  
instance QC.Arbitrary GetProfileForChannel_result where 
  arbitrary = M.liftM GetProfileForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProfileForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj}
    , if obj == default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj}
    ]
from_GetProfileForChannel_result :: GetProfileForChannel_result -> T.ThriftVal
from_GetProfileForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2591 -> (1, ("e",from_TalkException _v2591))) <$> getProfileForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2591 -> P.Just (0, ("success",from_Profile _v2591))) $ getProfileForChannel_result_success record
    , (\_v2591 -> (1, ("e",from_TalkException _v2591))) <$> getProfileForChannel_result_e record
    ]
    )
write_GetProfileForChannel_result :: T.Protocol p => p -> GetProfileForChannel_result -> P.IO ()
write_GetProfileForChannel_result oprot record = T.writeVal oprot $ from_GetProfileForChannel_result record
encode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> GetProfileForChannel_result -> LBS.ByteString
encode_GetProfileForChannel_result oprot record = T.serializeVal oprot $ from_GetProfileForChannel_result record
to_GetProfileForChannel_result :: T.ThriftVal -> GetProfileForChannel_result
to_GetProfileForChannel_result (T.TStruct fields) = GetProfileForChannel_result{
  getProfileForChannel_result_success = P.maybe (getProfileForChannel_result_success default_GetProfileForChannel_result) (\(_,_val2593) -> (case _val2593 of {T.TStruct _val2594 -> (to_Profile (T.TStruct _val2594)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProfileForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2593) -> P.Just (case _val2593 of {T.TStruct _val2595 -> (to_TalkException (T.TStruct _val2595)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProfileForChannel_result _ = P.error "not a struct"
read_GetProfileForChannel_result :: T.Protocol p => p -> P.IO GetProfileForChannel_result
read_GetProfileForChannel_result iprot = to_GetProfileForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result)
decode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_result
decode_GetProfileForChannel_result iprot bs = to_GetProfileForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result) bs
typemap_GetProfileForChannel_result :: T.TypeMap
typemap_GetProfileForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Profile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProfileForChannel_result :: GetProfileForChannel_result
default_GetProfileForChannel_result = GetProfileForChannel_result{
  getProfileForChannel_result_success = default_Profile,
  getProfileForChannel_result_e = P.Nothing}
data GetSimpleChannelContacts_args = GetSimpleChannelContacts_args  { getSimpleChannelContacts_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_args_ids record  
instance QC.Arbitrary GetSimpleChannelContacts_args where 
  arbitrary = M.liftM GetSimpleChannelContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj}
    ]
from_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args -> T.ThriftVal
from_GetSimpleChannelContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2598 -> P.Just (1, ("ids",T.TList T.T_STRING $ P.map (\_v2600 -> T.TString $ E.encodeUtf8 _v2600) $ Vector.toList _v2598))) $ getSimpleChannelContacts_args_ids record
  ]
write_GetSimpleChannelContacts_args :: T.Protocol p => p -> GetSimpleChannelContacts_args -> P.IO ()
write_GetSimpleChannelContacts_args oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_args record
encode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_args -> LBS.ByteString
encode_GetSimpleChannelContacts_args oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_args record
to_GetSimpleChannelContacts_args :: T.ThriftVal -> GetSimpleChannelContacts_args
to_GetSimpleChannelContacts_args (T.TStruct fields) = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = P.maybe (getSimpleChannelContacts_args_ids default_GetSimpleChannelContacts_args) (\(_,_val2602) -> (case _val2602 of {T.TList _ _val2603 -> (Vector.fromList $ P.map (\_v2604 -> (case _v2604 of {T.TString _val2605 -> E.decodeUtf8 _val2605; _ -> P.error "wrong type"})) _val2603); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSimpleChannelContacts_args _ = P.error "not a struct"
read_GetSimpleChannelContacts_args :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_args
read_GetSimpleChannelContacts_args iprot = to_GetSimpleChannelContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args)
decode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_args
decode_GetSimpleChannelContacts_args iprot bs = to_GetSimpleChannelContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args) bs
typemap_GetSimpleChannelContacts_args :: T.TypeMap
typemap_GetSimpleChannelContacts_args = Map.fromList [(1,("ids",(T.T_LIST T.T_STRING)))]
default_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args
default_GetSimpleChannelContacts_args = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = Vector.empty}
data GetSimpleChannelContacts_result = GetSimpleChannelContacts_result  { getSimpleChannelContacts_result_success :: (Vector.Vector SimpleChannelContact)
  , getSimpleChannelContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_result_success record   `H.hashWithSalt` getSimpleChannelContacts_result_e record  
instance QC.Arbitrary GetSimpleChannelContacts_result where 
  arbitrary = M.liftM GetSimpleChannelContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj}
    , if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj}
    ]
from_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result -> T.ThriftVal
from_GetSimpleChannelContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2608 -> (1, ("e",from_TalkException _v2608))) <$> getSimpleChannelContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2608 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v2610 -> from_SimpleChannelContact _v2610) $ Vector.toList _v2608))) $ getSimpleChannelContacts_result_success record
    , (\_v2608 -> (1, ("e",from_TalkException _v2608))) <$> getSimpleChannelContacts_result_e record
    ]
    )
write_GetSimpleChannelContacts_result :: T.Protocol p => p -> GetSimpleChannelContacts_result -> P.IO ()
write_GetSimpleChannelContacts_result oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_result record
encode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_result -> LBS.ByteString
encode_GetSimpleChannelContacts_result oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_result record
to_GetSimpleChannelContacts_result :: T.ThriftVal -> GetSimpleChannelContacts_result
to_GetSimpleChannelContacts_result (T.TStruct fields) = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = P.maybe (getSimpleChannelContacts_result_success default_GetSimpleChannelContacts_result) (\(_,_val2612) -> (case _val2612 of {T.TList _ _val2613 -> (Vector.fromList $ P.map (\_v2614 -> (case _v2614 of {T.TStruct _val2615 -> (to_SimpleChannelContact (T.TStruct _val2615)); _ -> P.error "wrong type"})) _val2613); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSimpleChannelContacts_result_e = P.maybe (P.Nothing) (\(_,_val2612) -> P.Just (case _val2612 of {T.TStruct _val2616 -> (to_TalkException (T.TStruct _val2616)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSimpleChannelContacts_result _ = P.error "not a struct"
read_GetSimpleChannelContacts_result :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_result
read_GetSimpleChannelContacts_result iprot = to_GetSimpleChannelContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result)
decode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_result
decode_GetSimpleChannelContacts_result iprot bs = to_GetSimpleChannelContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result) bs
typemap_GetSimpleChannelContacts_result :: T.TypeMap
typemap_GetSimpleChannelContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result
default_GetSimpleChannelContacts_result = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = Vector.empty,
  getSimpleChannelContacts_result_e = P.Nothing}
data GetUserCountryForBilling_args = GetUserCountryForBilling_args  { getUserCountryForBilling_args_country :: LT.Text
  , getUserCountryForBilling_args_remoteIp :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_args_country record   `H.hashWithSalt` getUserCountryForBilling_args_remoteIp record  
instance QC.Arbitrary GetUserCountryForBilling_args where 
  arbitrary = M.liftM GetUserCountryForBilling_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj}
    , if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj}
    ]
from_GetUserCountryForBilling_args :: GetUserCountryForBilling_args -> T.ThriftVal
from_GetUserCountryForBilling_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2619 -> P.Just (2, ("country",T.TString $ E.encodeUtf8 _v2619))) $ getUserCountryForBilling_args_country record
  , (\_v2619 -> P.Just (3, ("remoteIp",T.TString $ E.encodeUtf8 _v2619))) $ getUserCountryForBilling_args_remoteIp record
  ]
write_GetUserCountryForBilling_args :: T.Protocol p => p -> GetUserCountryForBilling_args -> P.IO ()
write_GetUserCountryForBilling_args oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_args record
encode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> GetUserCountryForBilling_args -> LBS.ByteString
encode_GetUserCountryForBilling_args oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_args record
to_GetUserCountryForBilling_args :: T.ThriftVal -> GetUserCountryForBilling_args
to_GetUserCountryForBilling_args (T.TStruct fields) = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = P.maybe (getUserCountryForBilling_args_country default_GetUserCountryForBilling_args) (\(_,_val2621) -> (case _val2621 of {T.TString _val2622 -> E.decodeUtf8 _val2622; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getUserCountryForBilling_args_remoteIp = P.maybe (getUserCountryForBilling_args_remoteIp default_GetUserCountryForBilling_args) (\(_,_val2621) -> (case _val2621 of {T.TString _val2623 -> E.decodeUtf8 _val2623; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetUserCountryForBilling_args _ = P.error "not a struct"
read_GetUserCountryForBilling_args :: T.Protocol p => p -> P.IO GetUserCountryForBilling_args
read_GetUserCountryForBilling_args iprot = to_GetUserCountryForBilling_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args)
decode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_args
decode_GetUserCountryForBilling_args iprot bs = to_GetUserCountryForBilling_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args) bs
typemap_GetUserCountryForBilling_args :: T.TypeMap
typemap_GetUserCountryForBilling_args = Map.fromList [(2,("country",T.T_STRING)),(3,("remoteIp",T.T_STRING))]
default_GetUserCountryForBilling_args :: GetUserCountryForBilling_args
default_GetUserCountryForBilling_args = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = "",
  getUserCountryForBilling_args_remoteIp = ""}
data GetUserCountryForBilling_result = GetUserCountryForBilling_result  { getUserCountryForBilling_result_success :: LT.Text
  , getUserCountryForBilling_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_result_success record   `H.hashWithSalt` getUserCountryForBilling_result_e record  
instance QC.Arbitrary GetUserCountryForBilling_result where 
  arbitrary = M.liftM GetUserCountryForBilling_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj}
    , if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj}
    ]
from_GetUserCountryForBilling_result :: GetUserCountryForBilling_result -> T.ThriftVal
from_GetUserCountryForBilling_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2626 -> (1, ("e",from_TalkException _v2626))) <$> getUserCountryForBilling_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2626 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2626))) $ getUserCountryForBilling_result_success record
    , (\_v2626 -> (1, ("e",from_TalkException _v2626))) <$> getUserCountryForBilling_result_e record
    ]
    )
write_GetUserCountryForBilling_result :: T.Protocol p => p -> GetUserCountryForBilling_result -> P.IO ()
write_GetUserCountryForBilling_result oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_result record
encode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> GetUserCountryForBilling_result -> LBS.ByteString
encode_GetUserCountryForBilling_result oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_result record
to_GetUserCountryForBilling_result :: T.ThriftVal -> GetUserCountryForBilling_result
to_GetUserCountryForBilling_result (T.TStruct fields) = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = P.maybe (getUserCountryForBilling_result_success default_GetUserCountryForBilling_result) (\(_,_val2628) -> (case _val2628 of {T.TString _val2629 -> E.decodeUtf8 _val2629; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCountryForBilling_result_e = P.maybe (P.Nothing) (\(_,_val2628) -> P.Just (case _val2628 of {T.TStruct _val2630 -> (to_TalkException (T.TStruct _val2630)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCountryForBilling_result _ = P.error "not a struct"
read_GetUserCountryForBilling_result :: T.Protocol p => p -> P.IO GetUserCountryForBilling_result
read_GetUserCountryForBilling_result iprot = to_GetUserCountryForBilling_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result)
decode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_result
decode_GetUserCountryForBilling_result iprot bs = to_GetUserCountryForBilling_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result) bs
typemap_GetUserCountryForBilling_result :: T.TypeMap
typemap_GetUserCountryForBilling_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCountryForBilling_result :: GetUserCountryForBilling_result
default_GetUserCountryForBilling_result = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = "",
  getUserCountryForBilling_result_e = P.Nothing}
data GetUserCreateTime_args = GetUserCreateTime_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserCreateTime_args where 
  arbitrary = QC.elements [GetUserCreateTime_args]
from_GetUserCreateTime_args :: GetUserCreateTime_args -> T.ThriftVal
from_GetUserCreateTime_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserCreateTime_args :: T.Protocol p => p -> GetUserCreateTime_args -> P.IO ()
write_GetUserCreateTime_args oprot record = T.writeVal oprot $ from_GetUserCreateTime_args record
encode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> GetUserCreateTime_args -> LBS.ByteString
encode_GetUserCreateTime_args oprot record = T.serializeVal oprot $ from_GetUserCreateTime_args record
to_GetUserCreateTime_args :: T.ThriftVal -> GetUserCreateTime_args
to_GetUserCreateTime_args (T.TStruct fields) = GetUserCreateTime_args{

  }
to_GetUserCreateTime_args _ = P.error "not a struct"
read_GetUserCreateTime_args :: T.Protocol p => p -> P.IO GetUserCreateTime_args
read_GetUserCreateTime_args iprot = to_GetUserCreateTime_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args)
decode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_args
decode_GetUserCreateTime_args iprot bs = to_GetUserCreateTime_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args) bs
typemap_GetUserCreateTime_args :: T.TypeMap
typemap_GetUserCreateTime_args = Map.fromList []
default_GetUserCreateTime_args :: GetUserCreateTime_args
default_GetUserCreateTime_args = GetUserCreateTime_args{
}
data GetUserCreateTime_result = GetUserCreateTime_result  { getUserCreateTime_result_success :: I.Int64
  , getUserCreateTime_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCreateTime_result_success record   `H.hashWithSalt` getUserCreateTime_result_e record  
instance QC.Arbitrary GetUserCreateTime_result where 
  arbitrary = M.liftM GetUserCreateTime_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCreateTime_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj}
    , if obj == default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj}
    ]
from_GetUserCreateTime_result :: GetUserCreateTime_result -> T.ThriftVal
from_GetUserCreateTime_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2638 -> (1, ("e",from_TalkException _v2638))) <$> getUserCreateTime_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2638 -> P.Just (0, ("success",T.TI64 _v2638))) $ getUserCreateTime_result_success record
    , (\_v2638 -> (1, ("e",from_TalkException _v2638))) <$> getUserCreateTime_result_e record
    ]
    )
write_GetUserCreateTime_result :: T.Protocol p => p -> GetUserCreateTime_result -> P.IO ()
write_GetUserCreateTime_result oprot record = T.writeVal oprot $ from_GetUserCreateTime_result record
encode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> GetUserCreateTime_result -> LBS.ByteString
encode_GetUserCreateTime_result oprot record = T.serializeVal oprot $ from_GetUserCreateTime_result record
to_GetUserCreateTime_result :: T.ThriftVal -> GetUserCreateTime_result
to_GetUserCreateTime_result (T.TStruct fields) = GetUserCreateTime_result{
  getUserCreateTime_result_success = P.maybe (getUserCreateTime_result_success default_GetUserCreateTime_result) (\(_,_val2640) -> (case _val2640 of {T.TI64 _val2641 -> _val2641; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCreateTime_result_e = P.maybe (P.Nothing) (\(_,_val2640) -> P.Just (case _val2640 of {T.TStruct _val2642 -> (to_TalkException (T.TStruct _val2642)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCreateTime_result _ = P.error "not a struct"
read_GetUserCreateTime_result :: T.Protocol p => p -> P.IO GetUserCreateTime_result
read_GetUserCreateTime_result iprot = to_GetUserCreateTime_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result)
decode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_result
decode_GetUserCreateTime_result iprot bs = to_GetUserCreateTime_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result) bs
typemap_GetUserCreateTime_result :: T.TypeMap
typemap_GetUserCreateTime_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCreateTime_result :: GetUserCreateTime_result
default_GetUserCreateTime_result = GetUserCreateTime_result{
  getUserCreateTime_result_success = 0,
  getUserCreateTime_result_e = P.Nothing}
data GetUserIdentities_args = GetUserIdentities_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserIdentities_args where 
  arbitrary = QC.elements [GetUserIdentities_args]
from_GetUserIdentities_args :: GetUserIdentities_args -> T.ThriftVal
from_GetUserIdentities_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserIdentities_args :: T.Protocol p => p -> GetUserIdentities_args -> P.IO ()
write_GetUserIdentities_args oprot record = T.writeVal oprot $ from_GetUserIdentities_args record
encode_GetUserIdentities_args :: T.StatelessProtocol p => p -> GetUserIdentities_args -> LBS.ByteString
encode_GetUserIdentities_args oprot record = T.serializeVal oprot $ from_GetUserIdentities_args record
to_GetUserIdentities_args :: T.ThriftVal -> GetUserIdentities_args
to_GetUserIdentities_args (T.TStruct fields) = GetUserIdentities_args{

  }
to_GetUserIdentities_args _ = P.error "not a struct"
read_GetUserIdentities_args :: T.Protocol p => p -> P.IO GetUserIdentities_args
read_GetUserIdentities_args iprot = to_GetUserIdentities_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_args)
decode_GetUserIdentities_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_args
decode_GetUserIdentities_args iprot bs = to_GetUserIdentities_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_args) bs
typemap_GetUserIdentities_args :: T.TypeMap
typemap_GetUserIdentities_args = Map.fromList []
default_GetUserIdentities_args :: GetUserIdentities_args
default_GetUserIdentities_args = GetUserIdentities_args{
}
data GetUserIdentities_result = GetUserIdentities_result  { getUserIdentities_result_success :: (Map.HashMap RegistrationType LT.Text)
  , getUserIdentities_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserIdentities_result_success record   `H.hashWithSalt` getUserIdentities_result_e record  
instance QC.Arbitrary GetUserIdentities_result where 
  arbitrary = M.liftM GetUserIdentities_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserIdentities_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj}
    , if obj == default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj}
    ]
from_GetUserIdentities_result :: GetUserIdentities_result -> T.ThriftVal
from_GetUserIdentities_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2650 -> (1, ("e",from_TalkException _v2650))) <$> getUserIdentities_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2650 -> P.Just (0, ("success",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k2651,_v2652) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k2651, T.TString $ E.encodeUtf8 _v2652)) $ Map.toList _v2650))) $ getUserIdentities_result_success record
    , (\_v2650 -> (1, ("e",from_TalkException _v2650))) <$> getUserIdentities_result_e record
    ]
    )
write_GetUserIdentities_result :: T.Protocol p => p -> GetUserIdentities_result -> P.IO ()
write_GetUserIdentities_result oprot record = T.writeVal oprot $ from_GetUserIdentities_result record
encode_GetUserIdentities_result :: T.StatelessProtocol p => p -> GetUserIdentities_result -> LBS.ByteString
encode_GetUserIdentities_result oprot record = T.serializeVal oprot $ from_GetUserIdentities_result record
to_GetUserIdentities_result :: T.ThriftVal -> GetUserIdentities_result
to_GetUserIdentities_result (T.TStruct fields) = GetUserIdentities_result{
  getUserIdentities_result_success = P.maybe (getUserIdentities_result_success default_GetUserIdentities_result) (\(_,_val2654) -> (case _val2654 of {T.TMap _ _ _val2655 -> (Map.fromList $ P.map (\(_k2657,_v2656) -> ((case _k2657 of {T.TI32 _val2658 -> P.toEnum $ P.fromIntegral _val2658; _ -> P.error "wrong type"}),(case _v2656 of {T.TString _val2659 -> E.decodeUtf8 _val2659; _ -> P.error "wrong type"}))) _val2655); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserIdentities_result_e = P.maybe (P.Nothing) (\(_,_val2654) -> P.Just (case _val2654 of {T.TStruct _val2660 -> (to_TalkException (T.TStruct _val2660)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserIdentities_result _ = P.error "not a struct"
read_GetUserIdentities_result :: T.Protocol p => p -> P.IO GetUserIdentities_result
read_GetUserIdentities_result iprot = to_GetUserIdentities_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_result)
decode_GetUserIdentities_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_result
decode_GetUserIdentities_result iprot bs = to_GetUserIdentities_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_result) bs
typemap_GetUserIdentities_result :: T.TypeMap
typemap_GetUserIdentities_result = Map.fromList [(0,("success",(T.T_MAP T.T_I32 T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserIdentities_result :: GetUserIdentities_result
default_GetUserIdentities_result = GetUserIdentities_result{
  getUserIdentities_result_success = Map.empty,
  getUserIdentities_result_e = P.Nothing}
data GetUserLanguage_args = GetUserLanguage_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserLanguage_args where 
  arbitrary = QC.elements [GetUserLanguage_args]
from_GetUserLanguage_args :: GetUserLanguage_args -> T.ThriftVal
from_GetUserLanguage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserLanguage_args :: T.Protocol p => p -> GetUserLanguage_args -> P.IO ()
write_GetUserLanguage_args oprot record = T.writeVal oprot $ from_GetUserLanguage_args record
encode_GetUserLanguage_args :: T.StatelessProtocol p => p -> GetUserLanguage_args -> LBS.ByteString
encode_GetUserLanguage_args oprot record = T.serializeVal oprot $ from_GetUserLanguage_args record
to_GetUserLanguage_args :: T.ThriftVal -> GetUserLanguage_args
to_GetUserLanguage_args (T.TStruct fields) = GetUserLanguage_args{

  }
to_GetUserLanguage_args _ = P.error "not a struct"
read_GetUserLanguage_args :: T.Protocol p => p -> P.IO GetUserLanguage_args
read_GetUserLanguage_args iprot = to_GetUserLanguage_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_args)
decode_GetUserLanguage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_args
decode_GetUserLanguage_args iprot bs = to_GetUserLanguage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_args) bs
typemap_GetUserLanguage_args :: T.TypeMap
typemap_GetUserLanguage_args = Map.fromList []
default_GetUserLanguage_args :: GetUserLanguage_args
default_GetUserLanguage_args = GetUserLanguage_args{
}
data GetUserLanguage_result = GetUserLanguage_result  { getUserLanguage_result_success :: LT.Text
  , getUserLanguage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLanguage_result_success record   `H.hashWithSalt` getUserLanguage_result_e record  
instance QC.Arbitrary GetUserLanguage_result where 
  arbitrary = M.liftM GetUserLanguage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserLanguage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj}
    , if obj == default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj}
    ]
from_GetUserLanguage_result :: GetUserLanguage_result -> T.ThriftVal
from_GetUserLanguage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2668 -> (1, ("e",from_TalkException _v2668))) <$> getUserLanguage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2668 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2668))) $ getUserLanguage_result_success record
    , (\_v2668 -> (1, ("e",from_TalkException _v2668))) <$> getUserLanguage_result_e record
    ]
    )
write_GetUserLanguage_result :: T.Protocol p => p -> GetUserLanguage_result -> P.IO ()
write_GetUserLanguage_result oprot record = T.writeVal oprot $ from_GetUserLanguage_result record
encode_GetUserLanguage_result :: T.StatelessProtocol p => p -> GetUserLanguage_result -> LBS.ByteString
encode_GetUserLanguage_result oprot record = T.serializeVal oprot $ from_GetUserLanguage_result record
to_GetUserLanguage_result :: T.ThriftVal -> GetUserLanguage_result
to_GetUserLanguage_result (T.TStruct fields) = GetUserLanguage_result{
  getUserLanguage_result_success = P.maybe (getUserLanguage_result_success default_GetUserLanguage_result) (\(_,_val2670) -> (case _val2670 of {T.TString _val2671 -> E.decodeUtf8 _val2671; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserLanguage_result_e = P.maybe (P.Nothing) (\(_,_val2670) -> P.Just (case _val2670 of {T.TStruct _val2672 -> (to_TalkException (T.TStruct _val2672)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLanguage_result _ = P.error "not a struct"
read_GetUserLanguage_result :: T.Protocol p => p -> P.IO GetUserLanguage_result
read_GetUserLanguage_result iprot = to_GetUserLanguage_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_result)
decode_GetUserLanguage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_result
decode_GetUserLanguage_result iprot bs = to_GetUserLanguage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_result) bs
typemap_GetUserLanguage_result :: T.TypeMap
typemap_GetUserLanguage_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserLanguage_result :: GetUserLanguage_result
default_GetUserLanguage_result = GetUserLanguage_result{
  getUserLanguage_result_success = "",
  getUserLanguage_result_e = P.Nothing}
data GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserMidsWhoAddedMe_args where 
  arbitrary = QC.elements [GetUserMidsWhoAddedMe_args]
from_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args -> T.ThriftVal
from_GetUserMidsWhoAddedMe_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> GetUserMidsWhoAddedMe_args -> P.IO ()
write_GetUserMidsWhoAddedMe_args oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_args record
encode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_args -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_args oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_args record
to_GetUserMidsWhoAddedMe_args :: T.ThriftVal -> GetUserMidsWhoAddedMe_args
to_GetUserMidsWhoAddedMe_args (T.TStruct fields) = GetUserMidsWhoAddedMe_args{

  }
to_GetUserMidsWhoAddedMe_args _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_args
read_GetUserMidsWhoAddedMe_args iprot = to_GetUserMidsWhoAddedMe_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args)
decode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_args
decode_GetUserMidsWhoAddedMe_args iprot bs = to_GetUserMidsWhoAddedMe_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args) bs
typemap_GetUserMidsWhoAddedMe_args :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_args = Map.fromList []
default_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args
default_GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args{
}
data GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result  { getUserMidsWhoAddedMe_result_success :: (Vector.Vector LT.Text)
  , getUserMidsWhoAddedMe_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserMidsWhoAddedMe_result_success record   `H.hashWithSalt` getUserMidsWhoAddedMe_result_e record  
instance QC.Arbitrary GetUserMidsWhoAddedMe_result where 
  arbitrary = M.liftM GetUserMidsWhoAddedMe_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserMidsWhoAddedMe_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj}
    , if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj}
    ]
from_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result -> T.ThriftVal
from_GetUserMidsWhoAddedMe_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2680 -> (1, ("e",from_TalkException _v2680))) <$> getUserMidsWhoAddedMe_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2680 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v2682 -> T.TString $ E.encodeUtf8 _v2682) $ Vector.toList _v2680))) $ getUserMidsWhoAddedMe_result_success record
    , (\_v2680 -> (1, ("e",from_TalkException _v2680))) <$> getUserMidsWhoAddedMe_result_e record
    ]
    )
write_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> GetUserMidsWhoAddedMe_result -> P.IO ()
write_GetUserMidsWhoAddedMe_result oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_result record
encode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_result -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_result oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_result record
to_GetUserMidsWhoAddedMe_result :: T.ThriftVal -> GetUserMidsWhoAddedMe_result
to_GetUserMidsWhoAddedMe_result (T.TStruct fields) = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = P.maybe (getUserMidsWhoAddedMe_result_success default_GetUserMidsWhoAddedMe_result) (\(_,_val2684) -> (case _val2684 of {T.TList _ _val2685 -> (Vector.fromList $ P.map (\_v2686 -> (case _v2686 of {T.TString _val2687 -> E.decodeUtf8 _val2687; _ -> P.error "wrong type"})) _val2685); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserMidsWhoAddedMe_result_e = P.maybe (P.Nothing) (\(_,_val2684) -> P.Just (case _val2684 of {T.TStruct _val2688 -> (to_TalkException (T.TStruct _val2688)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserMidsWhoAddedMe_result _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_result
read_GetUserMidsWhoAddedMe_result iprot = to_GetUserMidsWhoAddedMe_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result)
decode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_result
decode_GetUserMidsWhoAddedMe_result iprot bs = to_GetUserMidsWhoAddedMe_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result) bs
typemap_GetUserMidsWhoAddedMe_result :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result
default_GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = Vector.empty,
  getUserMidsWhoAddedMe_result_e = P.Nothing}
data IsGroupMember_args = IsGroupMember_args  { isGroupMember_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_args_groupId record  
instance QC.Arbitrary IsGroupMember_args where 
  arbitrary = M.liftM IsGroupMember_args (QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj} then P.Nothing else P.Just $ default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj}
    ]
from_IsGroupMember_args :: IsGroupMember_args -> T.ThriftVal
from_IsGroupMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2691 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v2691))) $ isGroupMember_args_groupId record
  ]
write_IsGroupMember_args :: T.Protocol p => p -> IsGroupMember_args -> P.IO ()
write_IsGroupMember_args oprot record = T.writeVal oprot $ from_IsGroupMember_args record
encode_IsGroupMember_args :: T.StatelessProtocol p => p -> IsGroupMember_args -> LBS.ByteString
encode_IsGroupMember_args oprot record = T.serializeVal oprot $ from_IsGroupMember_args record
to_IsGroupMember_args :: T.ThriftVal -> IsGroupMember_args
to_IsGroupMember_args (T.TStruct fields) = IsGroupMember_args{
  isGroupMember_args_groupId = P.maybe (isGroupMember_args_groupId default_IsGroupMember_args) (\(_,_val2693) -> (case _val2693 of {T.TString _val2694 -> E.decodeUtf8 _val2694; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_args _ = P.error "not a struct"
read_IsGroupMember_args :: T.Protocol p => p -> P.IO IsGroupMember_args
read_IsGroupMember_args iprot = to_IsGroupMember_args <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_args)
decode_IsGroupMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_args
decode_IsGroupMember_args iprot bs = to_IsGroupMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_args) bs
typemap_IsGroupMember_args :: T.TypeMap
typemap_IsGroupMember_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_IsGroupMember_args :: IsGroupMember_args
default_IsGroupMember_args = IsGroupMember_args{
  isGroupMember_args_groupId = ""}
data IsGroupMember_result = IsGroupMember_result  { isGroupMember_result_success :: P.Bool
  , isGroupMember_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_result_success record   `H.hashWithSalt` isGroupMember_result_e record  
instance QC.Arbitrary IsGroupMember_result where 
  arbitrary = M.liftM IsGroupMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj}
    , if obj == default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj}
    ]
from_IsGroupMember_result :: IsGroupMember_result -> T.ThriftVal
from_IsGroupMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2697 -> (1, ("e",from_TalkException _v2697))) <$> isGroupMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2697 -> P.Just (0, ("success",T.TBool _v2697))) $ isGroupMember_result_success record
    , (\_v2697 -> (1, ("e",from_TalkException _v2697))) <$> isGroupMember_result_e record
    ]
    )
write_IsGroupMember_result :: T.Protocol p => p -> IsGroupMember_result -> P.IO ()
write_IsGroupMember_result oprot record = T.writeVal oprot $ from_IsGroupMember_result record
encode_IsGroupMember_result :: T.StatelessProtocol p => p -> IsGroupMember_result -> LBS.ByteString
encode_IsGroupMember_result oprot record = T.serializeVal oprot $ from_IsGroupMember_result record
to_IsGroupMember_result :: T.ThriftVal -> IsGroupMember_result
to_IsGroupMember_result (T.TStruct fields) = IsGroupMember_result{
  isGroupMember_result_success = P.maybe (isGroupMember_result_success default_IsGroupMember_result) (\(_,_val2699) -> (case _val2699 of {T.TBool _val2700 -> _val2700; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isGroupMember_result_e = P.maybe (P.Nothing) (\(_,_val2699) -> P.Just (case _val2699 of {T.TStruct _val2701 -> (to_TalkException (T.TStruct _val2701)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_result _ = P.error "not a struct"
read_IsGroupMember_result :: T.Protocol p => p -> P.IO IsGroupMember_result
read_IsGroupMember_result iprot = to_IsGroupMember_result <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_result)
decode_IsGroupMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_result
decode_IsGroupMember_result iprot bs = to_IsGroupMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_result) bs
typemap_IsGroupMember_result :: T.TypeMap
typemap_IsGroupMember_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsGroupMember_result :: IsGroupMember_result
default_IsGroupMember_result = IsGroupMember_result{
  isGroupMember_result_success = P.False,
  isGroupMember_result_e = P.Nothing}
data IsInContact_args = IsInContact_args  { isInContact_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_args_mid record  
instance QC.Arbitrary IsInContact_args where 
  arbitrary = M.liftM IsInContact_args (QC.arbitrary)
  shrink obj | obj == default_IsInContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj} then P.Nothing else P.Just $ default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj}
    ]
from_IsInContact_args :: IsInContact_args -> T.ThriftVal
from_IsInContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2704 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v2704))) $ isInContact_args_mid record
  ]
write_IsInContact_args :: T.Protocol p => p -> IsInContact_args -> P.IO ()
write_IsInContact_args oprot record = T.writeVal oprot $ from_IsInContact_args record
encode_IsInContact_args :: T.StatelessProtocol p => p -> IsInContact_args -> LBS.ByteString
encode_IsInContact_args oprot record = T.serializeVal oprot $ from_IsInContact_args record
to_IsInContact_args :: T.ThriftVal -> IsInContact_args
to_IsInContact_args (T.TStruct fields) = IsInContact_args{
  isInContact_args_mid = P.maybe (isInContact_args_mid default_IsInContact_args) (\(_,_val2706) -> (case _val2706 of {T.TString _val2707 -> E.decodeUtf8 _val2707; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsInContact_args _ = P.error "not a struct"
read_IsInContact_args :: T.Protocol p => p -> P.IO IsInContact_args
read_IsInContact_args iprot = to_IsInContact_args <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_args)
decode_IsInContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_args
decode_IsInContact_args iprot bs = to_IsInContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_args) bs
typemap_IsInContact_args :: T.TypeMap
typemap_IsInContact_args = Map.fromList [(2,("mid",T.T_STRING))]
default_IsInContact_args :: IsInContact_args
default_IsInContact_args = IsInContact_args{
  isInContact_args_mid = ""}
data IsInContact_result = IsInContact_result  { isInContact_result_success :: P.Bool
  , isInContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_result_success record   `H.hashWithSalt` isInContact_result_e record  
instance QC.Arbitrary IsInContact_result where 
  arbitrary = M.liftM IsInContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsInContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_result{isInContact_result_success = isInContact_result_success obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_success = isInContact_result_success obj}
    , if obj == default_IsInContact_result{isInContact_result_e = isInContact_result_e obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_e = isInContact_result_e obj}
    ]
from_IsInContact_result :: IsInContact_result -> T.ThriftVal
from_IsInContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2710 -> (1, ("e",from_TalkException _v2710))) <$> isInContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2710 -> P.Just (0, ("success",T.TBool _v2710))) $ isInContact_result_success record
    , (\_v2710 -> (1, ("e",from_TalkException _v2710))) <$> isInContact_result_e record
    ]
    )
write_IsInContact_result :: T.Protocol p => p -> IsInContact_result -> P.IO ()
write_IsInContact_result oprot record = T.writeVal oprot $ from_IsInContact_result record
encode_IsInContact_result :: T.StatelessProtocol p => p -> IsInContact_result -> LBS.ByteString
encode_IsInContact_result oprot record = T.serializeVal oprot $ from_IsInContact_result record
to_IsInContact_result :: T.ThriftVal -> IsInContact_result
to_IsInContact_result (T.TStruct fields) = IsInContact_result{
  isInContact_result_success = P.maybe (isInContact_result_success default_IsInContact_result) (\(_,_val2712) -> (case _val2712 of {T.TBool _val2713 -> _val2713; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isInContact_result_e = P.maybe (P.Nothing) (\(_,_val2712) -> P.Just (case _val2712 of {T.TStruct _val2714 -> (to_TalkException (T.TStruct _val2714)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsInContact_result _ = P.error "not a struct"
read_IsInContact_result :: T.Protocol p => p -> P.IO IsInContact_result
read_IsInContact_result iprot = to_IsInContact_result <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_result)
decode_IsInContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_result
decode_IsInContact_result iprot bs = to_IsInContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_result) bs
typemap_IsInContact_result :: T.TypeMap
typemap_IsInContact_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsInContact_result :: IsInContact_result
default_IsInContact_result = IsInContact_result{
  isInContact_result_success = P.False,
  isInContact_result_e = P.Nothing}
data RegisterChannelCP_args = RegisterChannelCP_args  { registerChannelCP_args_cpId :: LT.Text
  , registerChannelCP_args_registerPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_args_cpId record   `H.hashWithSalt` registerChannelCP_args_registerPassword record  
instance QC.Arbitrary RegisterChannelCP_args where 
  arbitrary = M.liftM RegisterChannelCP_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj}
    , if obj == default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj}
    ]
from_RegisterChannelCP_args :: RegisterChannelCP_args -> T.ThriftVal
from_RegisterChannelCP_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2717 -> P.Just (2, ("cpId",T.TString $ E.encodeUtf8 _v2717))) $ registerChannelCP_args_cpId record
  , (\_v2717 -> P.Just (3, ("registerPassword",T.TString $ E.encodeUtf8 _v2717))) $ registerChannelCP_args_registerPassword record
  ]
write_RegisterChannelCP_args :: T.Protocol p => p -> RegisterChannelCP_args -> P.IO ()
write_RegisterChannelCP_args oprot record = T.writeVal oprot $ from_RegisterChannelCP_args record
encode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> RegisterChannelCP_args -> LBS.ByteString
encode_RegisterChannelCP_args oprot record = T.serializeVal oprot $ from_RegisterChannelCP_args record
to_RegisterChannelCP_args :: T.ThriftVal -> RegisterChannelCP_args
to_RegisterChannelCP_args (T.TStruct fields) = RegisterChannelCP_args{
  registerChannelCP_args_cpId = P.maybe (registerChannelCP_args_cpId default_RegisterChannelCP_args) (\(_,_val2719) -> (case _val2719 of {T.TString _val2720 -> E.decodeUtf8 _val2720; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerChannelCP_args_registerPassword = P.maybe (registerChannelCP_args_registerPassword default_RegisterChannelCP_args) (\(_,_val2719) -> (case _val2719 of {T.TString _val2721 -> E.decodeUtf8 _val2721; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterChannelCP_args _ = P.error "not a struct"
read_RegisterChannelCP_args :: T.Protocol p => p -> P.IO RegisterChannelCP_args
read_RegisterChannelCP_args iprot = to_RegisterChannelCP_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args)
decode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_args
decode_RegisterChannelCP_args iprot bs = to_RegisterChannelCP_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args) bs
typemap_RegisterChannelCP_args :: T.TypeMap
typemap_RegisterChannelCP_args = Map.fromList [(2,("cpId",T.T_STRING)),(3,("registerPassword",T.T_STRING))]
default_RegisterChannelCP_args :: RegisterChannelCP_args
default_RegisterChannelCP_args = RegisterChannelCP_args{
  registerChannelCP_args_cpId = "",
  registerChannelCP_args_registerPassword = ""}
data RegisterChannelCP_result = RegisterChannelCP_result  { registerChannelCP_result_success :: LT.Text
  , registerChannelCP_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_result_success record   `H.hashWithSalt` registerChannelCP_result_e record  
instance QC.Arbitrary RegisterChannelCP_result where 
  arbitrary = M.liftM RegisterChannelCP_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj}
    , if obj == default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj}
    ]
from_RegisterChannelCP_result :: RegisterChannelCP_result -> T.ThriftVal
from_RegisterChannelCP_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2724 -> (1, ("e",from_TalkException _v2724))) <$> registerChannelCP_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2724 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2724))) $ registerChannelCP_result_success record
    , (\_v2724 -> (1, ("e",from_TalkException _v2724))) <$> registerChannelCP_result_e record
    ]
    )
write_RegisterChannelCP_result :: T.Protocol p => p -> RegisterChannelCP_result -> P.IO ()
write_RegisterChannelCP_result oprot record = T.writeVal oprot $ from_RegisterChannelCP_result record
encode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> RegisterChannelCP_result -> LBS.ByteString
encode_RegisterChannelCP_result oprot record = T.serializeVal oprot $ from_RegisterChannelCP_result record
to_RegisterChannelCP_result :: T.ThriftVal -> RegisterChannelCP_result
to_RegisterChannelCP_result (T.TStruct fields) = RegisterChannelCP_result{
  registerChannelCP_result_success = P.maybe (registerChannelCP_result_success default_RegisterChannelCP_result) (\(_,_val2726) -> (case _val2726 of {T.TString _val2727 -> E.decodeUtf8 _val2727; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerChannelCP_result_e = P.maybe (P.Nothing) (\(_,_val2726) -> P.Just (case _val2726 of {T.TStruct _val2728 -> (to_TalkException (T.TStruct _val2728)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterChannelCP_result _ = P.error "not a struct"
read_RegisterChannelCP_result :: T.Protocol p => p -> P.IO RegisterChannelCP_result
read_RegisterChannelCP_result iprot = to_RegisterChannelCP_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result)
decode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_result
decode_RegisterChannelCP_result iprot bs = to_RegisterChannelCP_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result) bs
typemap_RegisterChannelCP_result :: T.TypeMap
typemap_RegisterChannelCP_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterChannelCP_result :: RegisterChannelCP_result
default_RegisterChannelCP_result = RegisterChannelCP_result{
  registerChannelCP_result_success = "",
  registerChannelCP_result_e = P.Nothing}
data RemoveNotificationStatus_args = RemoveNotificationStatus_args  { removeNotificationStatus_args_notificationStatus :: NotificationStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveNotificationStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeNotificationStatus_args_notificationStatus record  
instance QC.Arbitrary RemoveNotificationStatus_args where 
  arbitrary = M.liftM RemoveNotificationStatus_args (QC.arbitrary)
  shrink obj | obj == default_RemoveNotificationStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveNotificationStatus_args{removeNotificationStatus_args_notificationStatus = removeNotificationStatus_args_notificationStatus obj} then P.Nothing else P.Just $ default_RemoveNotificationStatus_args{removeNotificationStatus_args_notificationStatus = removeNotificationStatus_args_notificationStatus obj}
    ]
from_RemoveNotificationStatus_args :: RemoveNotificationStatus_args -> T.ThriftVal
from_RemoveNotificationStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2731 -> P.Just (2, ("notificationStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v2731))) $ removeNotificationStatus_args_notificationStatus record
  ]
write_RemoveNotificationStatus_args :: T.Protocol p => p -> RemoveNotificationStatus_args -> P.IO ()
write_RemoveNotificationStatus_args oprot record = T.writeVal oprot $ from_RemoveNotificationStatus_args record
encode_RemoveNotificationStatus_args :: T.StatelessProtocol p => p -> RemoveNotificationStatus_args -> LBS.ByteString
encode_RemoveNotificationStatus_args oprot record = T.serializeVal oprot $ from_RemoveNotificationStatus_args record
to_RemoveNotificationStatus_args :: T.ThriftVal -> RemoveNotificationStatus_args
to_RemoveNotificationStatus_args (T.TStruct fields) = RemoveNotificationStatus_args{
  removeNotificationStatus_args_notificationStatus = P.maybe (removeNotificationStatus_args_notificationStatus default_RemoveNotificationStatus_args) (\(_,_val2733) -> (case _val2733 of {T.TI32 _val2734 -> P.toEnum $ P.fromIntegral _val2734; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveNotificationStatus_args _ = P.error "not a struct"
read_RemoveNotificationStatus_args :: T.Protocol p => p -> P.IO RemoveNotificationStatus_args
read_RemoveNotificationStatus_args iprot = to_RemoveNotificationStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_args)
decode_RemoveNotificationStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveNotificationStatus_args
decode_RemoveNotificationStatus_args iprot bs = to_RemoveNotificationStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_args) bs
typemap_RemoveNotificationStatus_args :: T.TypeMap
typemap_RemoveNotificationStatus_args = Map.fromList [(2,("notificationStatus",T.T_I32))]
default_RemoveNotificationStatus_args :: RemoveNotificationStatus_args
default_RemoveNotificationStatus_args = RemoveNotificationStatus_args{
  removeNotificationStatus_args_notificationStatus = (P.toEnum 0)}
data RemoveNotificationStatus_result = RemoveNotificationStatus_result  { removeNotificationStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveNotificationStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeNotificationStatus_result_e record  
instance QC.Arbitrary RemoveNotificationStatus_result where 
  arbitrary = M.liftM RemoveNotificationStatus_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveNotificationStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveNotificationStatus_result{removeNotificationStatus_result_e = removeNotificationStatus_result_e obj} then P.Nothing else P.Just $ default_RemoveNotificationStatus_result{removeNotificationStatus_result_e = removeNotificationStatus_result_e obj}
    ]
from_RemoveNotificationStatus_result :: RemoveNotificationStatus_result -> T.ThriftVal
from_RemoveNotificationStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2737 -> (1, ("e",from_TalkException _v2737))) <$> removeNotificationStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2737 -> (1, ("e",from_TalkException _v2737))) <$> removeNotificationStatus_result_e record
    ]
    )
write_RemoveNotificationStatus_result :: T.Protocol p => p -> RemoveNotificationStatus_result -> P.IO ()
write_RemoveNotificationStatus_result oprot record = T.writeVal oprot $ from_RemoveNotificationStatus_result record
encode_RemoveNotificationStatus_result :: T.StatelessProtocol p => p -> RemoveNotificationStatus_result -> LBS.ByteString
encode_RemoveNotificationStatus_result oprot record = T.serializeVal oprot $ from_RemoveNotificationStatus_result record
to_RemoveNotificationStatus_result :: T.ThriftVal -> RemoveNotificationStatus_result
to_RemoveNotificationStatus_result (T.TStruct fields) = RemoveNotificationStatus_result{
  removeNotificationStatus_result_e = P.maybe (P.Nothing) (\(_,_val2739) -> P.Just (case _val2739 of {T.TStruct _val2740 -> (to_TalkException (T.TStruct _val2740)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveNotificationStatus_result _ = P.error "not a struct"
read_RemoveNotificationStatus_result :: T.Protocol p => p -> P.IO RemoveNotificationStatus_result
read_RemoveNotificationStatus_result iprot = to_RemoveNotificationStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_result)
decode_RemoveNotificationStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveNotificationStatus_result
decode_RemoveNotificationStatus_result iprot bs = to_RemoveNotificationStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_result) bs
typemap_RemoveNotificationStatus_result :: T.TypeMap
typemap_RemoveNotificationStatus_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveNotificationStatus_result :: RemoveNotificationStatus_result
default_RemoveNotificationStatus_result = RemoveNotificationStatus_result{
  removeNotificationStatus_result_e = P.Nothing}
data SendMessageForChannel_args = SendMessageForChannel_args  { sendMessageForChannel_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_args_message record  
instance QC.Arbitrary SendMessageForChannel_args where 
  arbitrary = M.liftM SendMessageForChannel_args (QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj} then P.Nothing else P.Just $ default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj}
    ]
from_SendMessageForChannel_args :: SendMessageForChannel_args -> T.ThriftVal
from_SendMessageForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2743 -> P.Just (2, ("message",from_Message _v2743))) $ sendMessageForChannel_args_message record
  ]
write_SendMessageForChannel_args :: T.Protocol p => p -> SendMessageForChannel_args -> P.IO ()
write_SendMessageForChannel_args oprot record = T.writeVal oprot $ from_SendMessageForChannel_args record
encode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> SendMessageForChannel_args -> LBS.ByteString
encode_SendMessageForChannel_args oprot record = T.serializeVal oprot $ from_SendMessageForChannel_args record
to_SendMessageForChannel_args :: T.ThriftVal -> SendMessageForChannel_args
to_SendMessageForChannel_args (T.TStruct fields) = SendMessageForChannel_args{
  sendMessageForChannel_args_message = P.maybe (sendMessageForChannel_args_message default_SendMessageForChannel_args) (\(_,_val2745) -> (case _val2745 of {T.TStruct _val2746 -> (to_Message (T.TStruct _val2746)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageForChannel_args _ = P.error "not a struct"
read_SendMessageForChannel_args :: T.Protocol p => p -> P.IO SendMessageForChannel_args
read_SendMessageForChannel_args iprot = to_SendMessageForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args)
decode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_args
decode_SendMessageForChannel_args iprot bs = to_SendMessageForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args) bs
typemap_SendMessageForChannel_args :: T.TypeMap
typemap_SendMessageForChannel_args = Map.fromList [(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageForChannel_args :: SendMessageForChannel_args
default_SendMessageForChannel_args = SendMessageForChannel_args{
  sendMessageForChannel_args_message = default_Message}
data SendMessageForChannel_result = SendMessageForChannel_result  { sendMessageForChannel_result_success :: Message
  , sendMessageForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_result_success record   `H.hashWithSalt` sendMessageForChannel_result_e record  
instance QC.Arbitrary SendMessageForChannel_result where 
  arbitrary = M.liftM SendMessageForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj}
    , if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj}
    ]
from_SendMessageForChannel_result :: SendMessageForChannel_result -> T.ThriftVal
from_SendMessageForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2749 -> (1, ("e",from_TalkException _v2749))) <$> sendMessageForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2749 -> P.Just (0, ("success",from_Message _v2749))) $ sendMessageForChannel_result_success record
    , (\_v2749 -> (1, ("e",from_TalkException _v2749))) <$> sendMessageForChannel_result_e record
    ]
    )
write_SendMessageForChannel_result :: T.Protocol p => p -> SendMessageForChannel_result -> P.IO ()
write_SendMessageForChannel_result oprot record = T.writeVal oprot $ from_SendMessageForChannel_result record
encode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> SendMessageForChannel_result -> LBS.ByteString
encode_SendMessageForChannel_result oprot record = T.serializeVal oprot $ from_SendMessageForChannel_result record
to_SendMessageForChannel_result :: T.ThriftVal -> SendMessageForChannel_result
to_SendMessageForChannel_result (T.TStruct fields) = SendMessageForChannel_result{
  sendMessageForChannel_result_success = P.maybe (sendMessageForChannel_result_success default_SendMessageForChannel_result) (\(_,_val2751) -> (case _val2751 of {T.TStruct _val2752 -> (to_Message (T.TStruct _val2752)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2751) -> P.Just (case _val2751 of {T.TStruct _val2753 -> (to_TalkException (T.TStruct _val2753)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageForChannel_result _ = P.error "not a struct"
read_SendMessageForChannel_result :: T.Protocol p => p -> P.IO SendMessageForChannel_result
read_SendMessageForChannel_result iprot = to_SendMessageForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result)
decode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_result
decode_SendMessageForChannel_result iprot bs = to_SendMessageForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result) bs
typemap_SendMessageForChannel_result :: T.TypeMap
typemap_SendMessageForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageForChannel_result :: SendMessageForChannel_result
default_SendMessageForChannel_result = SendMessageForChannel_result{
  sendMessageForChannel_result_success = default_Message,
  sendMessageForChannel_result_e = P.Nothing}
data SendPinCodeOperation_args = SendPinCodeOperation_args  { sendPinCodeOperation_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_args_verifier record  
instance QC.Arbitrary SendPinCodeOperation_args where 
  arbitrary = M.liftM SendPinCodeOperation_args (QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj}
    ]
from_SendPinCodeOperation_args :: SendPinCodeOperation_args -> T.ThriftVal
from_SendPinCodeOperation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2756 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v2756))) $ sendPinCodeOperation_args_verifier record
  ]
write_SendPinCodeOperation_args :: T.Protocol p => p -> SendPinCodeOperation_args -> P.IO ()
write_SendPinCodeOperation_args oprot record = T.writeVal oprot $ from_SendPinCodeOperation_args record
encode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> SendPinCodeOperation_args -> LBS.ByteString
encode_SendPinCodeOperation_args oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_args record
to_SendPinCodeOperation_args :: T.ThriftVal -> SendPinCodeOperation_args
to_SendPinCodeOperation_args (T.TStruct fields) = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = P.maybe (sendPinCodeOperation_args_verifier default_SendPinCodeOperation_args) (\(_,_val2758) -> (case _val2758 of {T.TString _val2759 -> E.decodeUtf8 _val2759; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_args _ = P.error "not a struct"
read_SendPinCodeOperation_args :: T.Protocol p => p -> P.IO SendPinCodeOperation_args
read_SendPinCodeOperation_args iprot = to_SendPinCodeOperation_args <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args)
decode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_args
decode_SendPinCodeOperation_args iprot bs = to_SendPinCodeOperation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args) bs
typemap_SendPinCodeOperation_args :: T.TypeMap
typemap_SendPinCodeOperation_args = Map.fromList [(1,("verifier",T.T_STRING))]
default_SendPinCodeOperation_args :: SendPinCodeOperation_args
default_SendPinCodeOperation_args = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = ""}
data SendPinCodeOperation_result = SendPinCodeOperation_result  { sendPinCodeOperation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_result_e record  
instance QC.Arbitrary SendPinCodeOperation_result where 
  arbitrary = M.liftM SendPinCodeOperation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj}
    ]
from_SendPinCodeOperation_result :: SendPinCodeOperation_result -> T.ThriftVal
from_SendPinCodeOperation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2762 -> (1, ("e",from_TalkException _v2762))) <$> sendPinCodeOperation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2762 -> (1, ("e",from_TalkException _v2762))) <$> sendPinCodeOperation_result_e record
    ]
    )
write_SendPinCodeOperation_result :: T.Protocol p => p -> SendPinCodeOperation_result -> P.IO ()
write_SendPinCodeOperation_result oprot record = T.writeVal oprot $ from_SendPinCodeOperation_result record
encode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> SendPinCodeOperation_result -> LBS.ByteString
encode_SendPinCodeOperation_result oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_result record
to_SendPinCodeOperation_result :: T.ThriftVal -> SendPinCodeOperation_result
to_SendPinCodeOperation_result (T.TStruct fields) = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.maybe (P.Nothing) (\(_,_val2764) -> P.Just (case _val2764 of {T.TStruct _val2765 -> (to_TalkException (T.TStruct _val2765)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_result _ = P.error "not a struct"
read_SendPinCodeOperation_result :: T.Protocol p => p -> P.IO SendPinCodeOperation_result
read_SendPinCodeOperation_result iprot = to_SendPinCodeOperation_result <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result)
decode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_result
decode_SendPinCodeOperation_result iprot bs = to_SendPinCodeOperation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result) bs
typemap_SendPinCodeOperation_result :: T.TypeMap
typemap_SendPinCodeOperation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendPinCodeOperation_result :: SendPinCodeOperation_result
default_SendPinCodeOperation_result = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.Nothing}
data UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args  { updateProfileAttributeForChannel_args_profileAttribute :: ProfileAttribute
  , updateProfileAttributeForChannel_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_args_profileAttribute record   `H.hashWithSalt` updateProfileAttributeForChannel_args_value record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_args where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj}
    , if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj}
    ]
from_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args -> T.ThriftVal
from_UpdateProfileAttributeForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2768 -> P.Just (2, ("profileAttribute",T.TI32 $ P.fromIntegral $ P.fromEnum _v2768))) $ updateProfileAttributeForChannel_args_profileAttribute record
  , (\_v2768 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v2768))) $ updateProfileAttributeForChannel_args_value record
  ]
write_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> UpdateProfileAttributeForChannel_args -> P.IO ()
write_UpdateProfileAttributeForChannel_args oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_args record
encode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_args -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_args oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_args record
to_UpdateProfileAttributeForChannel_args :: T.ThriftVal -> UpdateProfileAttributeForChannel_args
to_UpdateProfileAttributeForChannel_args (T.TStruct fields) = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = P.maybe (updateProfileAttributeForChannel_args_profileAttribute default_UpdateProfileAttributeForChannel_args) (\(_,_val2770) -> (case _val2770 of {T.TI32 _val2771 -> P.toEnum $ P.fromIntegral _val2771; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateProfileAttributeForChannel_args_value = P.maybe (updateProfileAttributeForChannel_args_value default_UpdateProfileAttributeForChannel_args) (\(_,_val2770) -> (case _val2770 of {T.TString _val2772 -> E.decodeUtf8 _val2772; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateProfileAttributeForChannel_args _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_args
read_UpdateProfileAttributeForChannel_args iprot = to_UpdateProfileAttributeForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args)
decode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_args
decode_UpdateProfileAttributeForChannel_args iprot bs = to_UpdateProfileAttributeForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args) bs
typemap_UpdateProfileAttributeForChannel_args :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_args = Map.fromList [(2,("profileAttribute",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args
default_UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = (P.toEnum 0),
  updateProfileAttributeForChannel_args_value = ""}
data UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result  { updateProfileAttributeForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_result_e record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_result where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj}
    ]
from_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result -> T.ThriftVal
from_UpdateProfileAttributeForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2775 -> (1, ("e",from_TalkException _v2775))) <$> updateProfileAttributeForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2775 -> (1, ("e",from_TalkException _v2775))) <$> updateProfileAttributeForChannel_result_e record
    ]
    )
write_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> UpdateProfileAttributeForChannel_result -> P.IO ()
write_UpdateProfileAttributeForChannel_result oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_result record
encode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_result -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_result oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_result record
to_UpdateProfileAttributeForChannel_result :: T.ThriftVal -> UpdateProfileAttributeForChannel_result
to_UpdateProfileAttributeForChannel_result (T.TStruct fields) = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.maybe (P.Nothing) (\(_,_val2777) -> P.Just (case _val2777 of {T.TStruct _val2778 -> (to_TalkException (T.TStruct _val2778)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfileAttributeForChannel_result _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_result
read_UpdateProfileAttributeForChannel_result iprot = to_UpdateProfileAttributeForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result)
decode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_result
decode_UpdateProfileAttributeForChannel_result iprot bs = to_UpdateProfileAttributeForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result) bs
typemap_UpdateProfileAttributeForChannel_result :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result
default_UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.Nothing}
process_activeBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_ActiveBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.activeBuddySubscriberCount handler
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("activeBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addOperationForChannel (seqid, iprot, oprot, handler) = do
  args <- read_AddOperationForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.addOperationForChannel handler (addOperationForChannel_args_opType args) (addOperationForChannel_args_param1 args) (addOperationForChannel_args_param2 args) (addOperationForChannel_args_param3 args)
        let res = default_AddOperationForChannel_result
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res)
      (\e  -> do
        let res = default_AddOperationForChannel_result{addOperationForChannel_result_e = P.Just e}
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addOperationForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_displayBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_DisplayBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.displayBuddySubscriberCount handler
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("displayBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUseridWithoutAbuseBlockForChannel (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUseridWithoutAbuseBlockForChannel handler (findContactByUseridWithoutAbuseBlockForChannel_args_userid args)
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = val}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res)
      (\e  -> do
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllContactIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetAllContactIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllContactIdsForChannel handler
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = val}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllContactIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactContacts handler (getCompactContacts_args_lastModifiedTimestamp args)
        let res = default_GetCompactContacts_result{getCompactContacts_result_success = val}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res)
      (\e  -> do
        let res = default_GetCompactContacts_result{getCompactContacts_result_e = P.Just e}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContactsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetContactsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContactsForChannel handler (getContactsForChannel_args_ids args)
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_success = val}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContactsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDisplayName (seqid, iprot, oprot, handler) = do
  args <- read_GetDisplayName_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDisplayName handler (getDisplayName_args_mid args)
        let res = default_GetDisplayName_result{getDisplayName_result_success = val}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res)
      (\e  -> do
        let res = default_GetDisplayName_result{getDisplayName_result_e = P.Just e}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDisplayName", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteMidsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteMidsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteMidsForChannel handler
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = val}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendMids (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendMids handler
        let res = default_GetFriendMids_result{getFriendMids_result_success = val}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res)
      (\e  -> do
        let res = default_GetFriendMids_result{getFriendMids_result_e = P.Just e}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupMemberMids (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupMemberMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupMemberMids handler (getGroupMemberMids_args_groupId args)
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_success = val}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res)
      (\e  -> do
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_e = P.Just e}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupMemberMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupsForChannel handler (getGroupsForChannel_args_groupIds args)
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_success = val}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_GetIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getIdentityCredential handler
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_success = val}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getJoinedGroupIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetJoinedGroupIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getJoinedGroupIdsForChannel handler
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = val}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMetaProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetMetaProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMetaProfile handler
        let res = default_GetMetaProfile_result{getMetaProfile_result_success = val}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res)
      (\e  -> do
        let res = default_GetMetaProfile_result{getMetaProfile_result_e = P.Just e}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMetaProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMid (seqid, iprot, oprot, handler) = do
  args <- read_GetMid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMid handler
        let res = default_GetMid_result{getMid_result_success = val}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res)
      (\e  -> do
        let res = default_GetMid_result{getMid_result_e = P.Just e}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPrimaryClientForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetPrimaryClientForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPrimaryClientForChannel handler
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = val}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res)
      (\e  -> do
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPrimaryClientForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProfileForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetProfileForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProfileForChannel handler
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_success = val}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res)
      (\e  -> do
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProfileForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSimpleChannelContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetSimpleChannelContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSimpleChannelContacts handler (getSimpleChannelContacts_args_ids args)
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = val}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res)
      (\e  -> do
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = P.Just e}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSimpleChannelContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCountryForBilling (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCountryForBilling_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCountryForBilling handler (getUserCountryForBilling_args_country args) (getUserCountryForBilling_args_remoteIp args)
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = val}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res)
      (\e  -> do
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = P.Just e}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCountryForBilling", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCreateTime (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCreateTime_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCreateTime handler
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_success = val}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res)
      (\e  -> do
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_e = P.Just e}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCreateTime", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserIdentities (seqid, iprot, oprot, handler) = do
  args <- read_GetUserIdentities_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserIdentities handler
        let res = default_GetUserIdentities_result{getUserIdentities_result_success = val}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res)
      (\e  -> do
        let res = default_GetUserIdentities_result{getUserIdentities_result_e = P.Just e}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserIdentities", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserLanguage (seqid, iprot, oprot, handler) = do
  args <- read_GetUserLanguage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserLanguage handler
        let res = default_GetUserLanguage_result{getUserLanguage_result_success = val}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res)
      (\e  -> do
        let res = default_GetUserLanguage_result{getUserLanguage_result_e = P.Just e}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserLanguage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserMidsWhoAddedMe (seqid, iprot, oprot, handler) = do
  args <- read_GetUserMidsWhoAddedMe_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserMidsWhoAddedMe handler
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = val}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res)
      (\e  -> do
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = P.Just e}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isGroupMember (seqid, iprot, oprot, handler) = do
  args <- read_IsGroupMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isGroupMember handler (isGroupMember_args_groupId args)
        let res = default_IsGroupMember_result{isGroupMember_result_success = val}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res)
      (\e  -> do
        let res = default_IsGroupMember_result{isGroupMember_result_e = P.Just e}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isGroupMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isInContact (seqid, iprot, oprot, handler) = do
  args <- read_IsInContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isInContact handler (isInContact_args_mid args)
        let res = default_IsInContact_result{isInContact_result_success = val}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res)
      (\e  -> do
        let res = default_IsInContact_result{isInContact_result_e = P.Just e}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isInContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerChannelCP (seqid, iprot, oprot, handler) = do
  args <- read_RegisterChannelCP_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerChannelCP handler (registerChannelCP_args_cpId args) (registerChannelCP_args_registerPassword args)
        let res = default_RegisterChannelCP_result{registerChannelCP_result_success = val}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res)
      (\e  -> do
        let res = default_RegisterChannelCP_result{registerChannelCP_result_e = P.Just e}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerChannelCP", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeNotificationStatus (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNotificationStatus_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeNotificationStatus handler (removeNotificationStatus_args_notificationStatus args)
        let res = default_RemoveNotificationStatus_result
        T.writeMessage oprot ("removeNotificationStatus", T.M_REPLY, seqid) $
          write_RemoveNotificationStatus_result oprot res)
      (\e  -> do
        let res = default_RemoveNotificationStatus_result{removeNotificationStatus_result_e = P.Just e}
        T.writeMessage oprot ("removeNotificationStatus", T.M_REPLY, seqid) $
          write_RemoveNotificationStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeNotificationStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageForChannel (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageForChannel handler (sendMessageForChannel_args_message args)
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_success = val}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res)
      (\e  -> do
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendPinCodeOperation (seqid, iprot, oprot, handler) = do
  args <- read_SendPinCodeOperation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendPinCodeOperation handler (sendPinCodeOperation_args_verifier args)
        let res = default_SendPinCodeOperation_result
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res)
      (\e  -> do
        let res = default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = P.Just e}
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendPinCodeOperation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfileAttributeForChannel (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfileAttributeForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfileAttributeForChannel handler (updateProfileAttributeForChannel_args_profileAttribute args) (updateProfileAttributeForChannel_args_value args)
        let res = default_UpdateProfileAttributeForChannel_result
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res)
      (\e  -> do
        let res = default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = P.Just e}
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "activeBuddySubscriberCount" -> process_activeBuddySubscriberCount (seqid,iprot,oprot,handler)
  "addOperationForChannel" -> process_addOperationForChannel (seqid,iprot,oprot,handler)
  "displayBuddySubscriberCount" -> process_displayBuddySubscriberCount (seqid,iprot,oprot,handler)
  "findContactByUseridWithoutAbuseBlockForChannel" -> process_findContactByUseridWithoutAbuseBlockForChannel (seqid,iprot,oprot,handler)
  "getAllContactIdsForChannel" -> process_getAllContactIdsForChannel (seqid,iprot,oprot,handler)
  "getCompactContacts" -> process_getCompactContacts (seqid,iprot,oprot,handler)
  "getContactsForChannel" -> process_getContactsForChannel (seqid,iprot,oprot,handler)
  "getDisplayName" -> process_getDisplayName (seqid,iprot,oprot,handler)
  "getFavoriteMidsForChannel" -> process_getFavoriteMidsForChannel (seqid,iprot,oprot,handler)
  "getFriendMids" -> process_getFriendMids (seqid,iprot,oprot,handler)
  "getGroupMemberMids" -> process_getGroupMemberMids (seqid,iprot,oprot,handler)
  "getGroupsForChannel" -> process_getGroupsForChannel (seqid,iprot,oprot,handler)
  "getIdentityCredential" -> process_getIdentityCredential (seqid,iprot,oprot,handler)
  "getJoinedGroupIdsForChannel" -> process_getJoinedGroupIdsForChannel (seqid,iprot,oprot,handler)
  "getMetaProfile" -> process_getMetaProfile (seqid,iprot,oprot,handler)
  "getMid" -> process_getMid (seqid,iprot,oprot,handler)
  "getPrimaryClientForChannel" -> process_getPrimaryClientForChannel (seqid,iprot,oprot,handler)
  "getProfileForChannel" -> process_getProfileForChannel (seqid,iprot,oprot,handler)
  "getSimpleChannelContacts" -> process_getSimpleChannelContacts (seqid,iprot,oprot,handler)
  "getUserCountryForBilling" -> process_getUserCountryForBilling (seqid,iprot,oprot,handler)
  "getUserCreateTime" -> process_getUserCreateTime (seqid,iprot,oprot,handler)
  "getUserIdentities" -> process_getUserIdentities (seqid,iprot,oprot,handler)
  "getUserLanguage" -> process_getUserLanguage (seqid,iprot,oprot,handler)
  "getUserMidsWhoAddedMe" -> process_getUserMidsWhoAddedMe (seqid,iprot,oprot,handler)
  "isGroupMember" -> process_isGroupMember (seqid,iprot,oprot,handler)
  "isInContact" -> process_isInContact (seqid,iprot,oprot,handler)
  "registerChannelCP" -> process_registerChannelCP (seqid,iprot,oprot,handler)
  "removeNotificationStatus" -> process_removeNotificationStatus (seqid,iprot,oprot,handler)
  "sendMessageForChannel" -> process_sendMessageForChannel (seqid,iprot,oprot,handler)
  "sendPinCodeOperation" -> process_sendPinCodeOperation (seqid,iprot,oprot,handler)
  "updateProfileAttributeForChannel" -> process_updateProfileAttributeForChannel (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
