{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ChannelService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified ChannelService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data ApproveChannelAndIssueChannelToken_args = ApproveChannelAndIssueChannelToken_args  { approveChannelAndIssueChannelToken_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueChannelToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueChannelToken_args_channelId record  
instance QC.Arbitrary ApproveChannelAndIssueChannelToken_args where 
  arbitrary = M.liftM ApproveChannelAndIssueChannelToken_args (QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueChannelToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueChannelToken_args{approveChannelAndIssueChannelToken_args_channelId = approveChannelAndIssueChannelToken_args_channelId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_args{approveChannelAndIssueChannelToken_args_channelId = approveChannelAndIssueChannelToken_args_channelId obj}
    ]
from_ApproveChannelAndIssueChannelToken_args :: ApproveChannelAndIssueChannelToken_args -> T.ThriftVal
from_ApproveChannelAndIssueChannelToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2781 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v2781))) $ approveChannelAndIssueChannelToken_args_channelId record
  ]
write_ApproveChannelAndIssueChannelToken_args :: T.Protocol p => p -> ApproveChannelAndIssueChannelToken_args -> P.IO ()
write_ApproveChannelAndIssueChannelToken_args oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueChannelToken_args record
encode_ApproveChannelAndIssueChannelToken_args :: T.StatelessProtocol p => p -> ApproveChannelAndIssueChannelToken_args -> LBS.ByteString
encode_ApproveChannelAndIssueChannelToken_args oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueChannelToken_args record
to_ApproveChannelAndIssueChannelToken_args :: T.ThriftVal -> ApproveChannelAndIssueChannelToken_args
to_ApproveChannelAndIssueChannelToken_args (T.TStruct fields) = ApproveChannelAndIssueChannelToken_args{
  approveChannelAndIssueChannelToken_args_channelId = P.maybe (approveChannelAndIssueChannelToken_args_channelId default_ApproveChannelAndIssueChannelToken_args) (\(_,_val2783) -> (case _val2783 of {T.TString _val2784 -> E.decodeUtf8 _val2784; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueChannelToken_args _ = P.error "not a struct"
read_ApproveChannelAndIssueChannelToken_args :: T.Protocol p => p -> P.IO ApproveChannelAndIssueChannelToken_args
read_ApproveChannelAndIssueChannelToken_args iprot = to_ApproveChannelAndIssueChannelToken_args <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_args)
decode_ApproveChannelAndIssueChannelToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueChannelToken_args
decode_ApproveChannelAndIssueChannelToken_args iprot bs = to_ApproveChannelAndIssueChannelToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_args) bs
typemap_ApproveChannelAndIssueChannelToken_args :: T.TypeMap
typemap_ApproveChannelAndIssueChannelToken_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_ApproveChannelAndIssueChannelToken_args :: ApproveChannelAndIssueChannelToken_args
default_ApproveChannelAndIssueChannelToken_args = ApproveChannelAndIssueChannelToken_args{
  approveChannelAndIssueChannelToken_args_channelId = ""}
data ApproveChannelAndIssueChannelToken_result = ApproveChannelAndIssueChannelToken_result  { approveChannelAndIssueChannelToken_result_success :: ChannelToken
  , approveChannelAndIssueChannelToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueChannelToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueChannelToken_result_success record   `H.hashWithSalt` approveChannelAndIssueChannelToken_result_e record  
instance QC.Arbitrary ApproveChannelAndIssueChannelToken_result where 
  arbitrary = M.liftM ApproveChannelAndIssueChannelToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueChannelToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = approveChannelAndIssueChannelToken_result_success obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = approveChannelAndIssueChannelToken_result_success obj}
    , if obj == default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = approveChannelAndIssueChannelToken_result_e obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = approveChannelAndIssueChannelToken_result_e obj}
    ]
from_ApproveChannelAndIssueChannelToken_result :: ApproveChannelAndIssueChannelToken_result -> T.ThriftVal
from_ApproveChannelAndIssueChannelToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2787 -> (1, ("e",from_ChannelException _v2787))) <$> approveChannelAndIssueChannelToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2787 -> P.Just (0, ("success",from_ChannelToken _v2787))) $ approveChannelAndIssueChannelToken_result_success record
    , (\_v2787 -> (1, ("e",from_ChannelException _v2787))) <$> approveChannelAndIssueChannelToken_result_e record
    ]
    )
write_ApproveChannelAndIssueChannelToken_result :: T.Protocol p => p -> ApproveChannelAndIssueChannelToken_result -> P.IO ()
write_ApproveChannelAndIssueChannelToken_result oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueChannelToken_result record
encode_ApproveChannelAndIssueChannelToken_result :: T.StatelessProtocol p => p -> ApproveChannelAndIssueChannelToken_result -> LBS.ByteString
encode_ApproveChannelAndIssueChannelToken_result oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueChannelToken_result record
to_ApproveChannelAndIssueChannelToken_result :: T.ThriftVal -> ApproveChannelAndIssueChannelToken_result
to_ApproveChannelAndIssueChannelToken_result (T.TStruct fields) = ApproveChannelAndIssueChannelToken_result{
  approveChannelAndIssueChannelToken_result_success = P.maybe (approveChannelAndIssueChannelToken_result_success default_ApproveChannelAndIssueChannelToken_result) (\(_,_val2789) -> (case _val2789 of {T.TStruct _val2790 -> (to_ChannelToken (T.TStruct _val2790)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  approveChannelAndIssueChannelToken_result_e = P.maybe (P.Nothing) (\(_,_val2789) -> P.Just (case _val2789 of {T.TStruct _val2791 -> (to_ChannelException (T.TStruct _val2791)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueChannelToken_result _ = P.error "not a struct"
read_ApproveChannelAndIssueChannelToken_result :: T.Protocol p => p -> P.IO ApproveChannelAndIssueChannelToken_result
read_ApproveChannelAndIssueChannelToken_result iprot = to_ApproveChannelAndIssueChannelToken_result <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_result)
decode_ApproveChannelAndIssueChannelToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueChannelToken_result
decode_ApproveChannelAndIssueChannelToken_result iprot bs = to_ApproveChannelAndIssueChannelToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_result) bs
typemap_ApproveChannelAndIssueChannelToken_result :: T.TypeMap
typemap_ApproveChannelAndIssueChannelToken_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelToken))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ApproveChannelAndIssueChannelToken_result :: ApproveChannelAndIssueChannelToken_result
default_ApproveChannelAndIssueChannelToken_result = ApproveChannelAndIssueChannelToken_result{
  approveChannelAndIssueChannelToken_result_success = default_ChannelToken,
  approveChannelAndIssueChannelToken_result_e = P.Nothing}
data ApproveChannelAndIssueRequestToken_args = ApproveChannelAndIssueRequestToken_args  { approveChannelAndIssueRequestToken_args_channelId :: LT.Text
  , approveChannelAndIssueRequestToken_args_otpId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueRequestToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueRequestToken_args_channelId record   `H.hashWithSalt` approveChannelAndIssueRequestToken_args_otpId record  
instance QC.Arbitrary ApproveChannelAndIssueRequestToken_args where 
  arbitrary = M.liftM ApproveChannelAndIssueRequestToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueRequestToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_channelId = approveChannelAndIssueRequestToken_args_channelId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_channelId = approveChannelAndIssueRequestToken_args_channelId obj}
    , if obj == default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_otpId = approveChannelAndIssueRequestToken_args_otpId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_otpId = approveChannelAndIssueRequestToken_args_otpId obj}
    ]
from_ApproveChannelAndIssueRequestToken_args :: ApproveChannelAndIssueRequestToken_args -> T.ThriftVal
from_ApproveChannelAndIssueRequestToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2794 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v2794))) $ approveChannelAndIssueRequestToken_args_channelId record
  , (\_v2794 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v2794))) $ approveChannelAndIssueRequestToken_args_otpId record
  ]
write_ApproveChannelAndIssueRequestToken_args :: T.Protocol p => p -> ApproveChannelAndIssueRequestToken_args -> P.IO ()
write_ApproveChannelAndIssueRequestToken_args oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueRequestToken_args record
encode_ApproveChannelAndIssueRequestToken_args :: T.StatelessProtocol p => p -> ApproveChannelAndIssueRequestToken_args -> LBS.ByteString
encode_ApproveChannelAndIssueRequestToken_args oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueRequestToken_args record
to_ApproveChannelAndIssueRequestToken_args :: T.ThriftVal -> ApproveChannelAndIssueRequestToken_args
to_ApproveChannelAndIssueRequestToken_args (T.TStruct fields) = ApproveChannelAndIssueRequestToken_args{
  approveChannelAndIssueRequestToken_args_channelId = P.maybe (approveChannelAndIssueRequestToken_args_channelId default_ApproveChannelAndIssueRequestToken_args) (\(_,_val2796) -> (case _val2796 of {T.TString _val2797 -> E.decodeUtf8 _val2797; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approveChannelAndIssueRequestToken_args_otpId = P.maybe (approveChannelAndIssueRequestToken_args_otpId default_ApproveChannelAndIssueRequestToken_args) (\(_,_val2796) -> (case _val2796 of {T.TString _val2798 -> E.decodeUtf8 _val2798; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApproveChannelAndIssueRequestToken_args _ = P.error "not a struct"
read_ApproveChannelAndIssueRequestToken_args :: T.Protocol p => p -> P.IO ApproveChannelAndIssueRequestToken_args
read_ApproveChannelAndIssueRequestToken_args iprot = to_ApproveChannelAndIssueRequestToken_args <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_args)
decode_ApproveChannelAndIssueRequestToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueRequestToken_args
decode_ApproveChannelAndIssueRequestToken_args iprot bs = to_ApproveChannelAndIssueRequestToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_args) bs
typemap_ApproveChannelAndIssueRequestToken_args :: T.TypeMap
typemap_ApproveChannelAndIssueRequestToken_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING))]
default_ApproveChannelAndIssueRequestToken_args :: ApproveChannelAndIssueRequestToken_args
default_ApproveChannelAndIssueRequestToken_args = ApproveChannelAndIssueRequestToken_args{
  approveChannelAndIssueRequestToken_args_channelId = "",
  approveChannelAndIssueRequestToken_args_otpId = ""}
data ApproveChannelAndIssueRequestToken_result = ApproveChannelAndIssueRequestToken_result  { approveChannelAndIssueRequestToken_result_success :: LT.Text
  , approveChannelAndIssueRequestToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueRequestToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueRequestToken_result_success record   `H.hashWithSalt` approveChannelAndIssueRequestToken_result_e record  
instance QC.Arbitrary ApproveChannelAndIssueRequestToken_result where 
  arbitrary = M.liftM ApproveChannelAndIssueRequestToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueRequestToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = approveChannelAndIssueRequestToken_result_success obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = approveChannelAndIssueRequestToken_result_success obj}
    , if obj == default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = approveChannelAndIssueRequestToken_result_e obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = approveChannelAndIssueRequestToken_result_e obj}
    ]
from_ApproveChannelAndIssueRequestToken_result :: ApproveChannelAndIssueRequestToken_result -> T.ThriftVal
from_ApproveChannelAndIssueRequestToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2801 -> (1, ("e",from_ChannelException _v2801))) <$> approveChannelAndIssueRequestToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2801 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2801))) $ approveChannelAndIssueRequestToken_result_success record
    , (\_v2801 -> (1, ("e",from_ChannelException _v2801))) <$> approveChannelAndIssueRequestToken_result_e record
    ]
    )
write_ApproveChannelAndIssueRequestToken_result :: T.Protocol p => p -> ApproveChannelAndIssueRequestToken_result -> P.IO ()
write_ApproveChannelAndIssueRequestToken_result oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueRequestToken_result record
encode_ApproveChannelAndIssueRequestToken_result :: T.StatelessProtocol p => p -> ApproveChannelAndIssueRequestToken_result -> LBS.ByteString
encode_ApproveChannelAndIssueRequestToken_result oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueRequestToken_result record
to_ApproveChannelAndIssueRequestToken_result :: T.ThriftVal -> ApproveChannelAndIssueRequestToken_result
to_ApproveChannelAndIssueRequestToken_result (T.TStruct fields) = ApproveChannelAndIssueRequestToken_result{
  approveChannelAndIssueRequestToken_result_success = P.maybe (approveChannelAndIssueRequestToken_result_success default_ApproveChannelAndIssueRequestToken_result) (\(_,_val2803) -> (case _val2803 of {T.TString _val2804 -> E.decodeUtf8 _val2804; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  approveChannelAndIssueRequestToken_result_e = P.maybe (P.Nothing) (\(_,_val2803) -> P.Just (case _val2803 of {T.TStruct _val2805 -> (to_ChannelException (T.TStruct _val2805)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueRequestToken_result _ = P.error "not a struct"
read_ApproveChannelAndIssueRequestToken_result :: T.Protocol p => p -> P.IO ApproveChannelAndIssueRequestToken_result
read_ApproveChannelAndIssueRequestToken_result iprot = to_ApproveChannelAndIssueRequestToken_result <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_result)
decode_ApproveChannelAndIssueRequestToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueRequestToken_result
decode_ApproveChannelAndIssueRequestToken_result iprot bs = to_ApproveChannelAndIssueRequestToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_result) bs
typemap_ApproveChannelAndIssueRequestToken_result :: T.TypeMap
typemap_ApproveChannelAndIssueRequestToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ApproveChannelAndIssueRequestToken_result :: ApproveChannelAndIssueRequestToken_result
default_ApproveChannelAndIssueRequestToken_result = ApproveChannelAndIssueRequestToken_result{
  approveChannelAndIssueRequestToken_result_success = "",
  approveChannelAndIssueRequestToken_result_e = P.Nothing}
data FetchNotificationItems_args = FetchNotificationItems_args  { fetchNotificationItems_args_localRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchNotificationItems_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchNotificationItems_args_localRev record  
instance QC.Arbitrary FetchNotificationItems_args where 
  arbitrary = M.liftM FetchNotificationItems_args (QC.arbitrary)
  shrink obj | obj == default_FetchNotificationItems_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchNotificationItems_args{fetchNotificationItems_args_localRev = fetchNotificationItems_args_localRev obj} then P.Nothing else P.Just $ default_FetchNotificationItems_args{fetchNotificationItems_args_localRev = fetchNotificationItems_args_localRev obj}
    ]
from_FetchNotificationItems_args :: FetchNotificationItems_args -> T.ThriftVal
from_FetchNotificationItems_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2808 -> P.Just (2, ("localRev",T.TI64 _v2808))) $ fetchNotificationItems_args_localRev record
  ]
write_FetchNotificationItems_args :: T.Protocol p => p -> FetchNotificationItems_args -> P.IO ()
write_FetchNotificationItems_args oprot record = T.writeVal oprot $ from_FetchNotificationItems_args record
encode_FetchNotificationItems_args :: T.StatelessProtocol p => p -> FetchNotificationItems_args -> LBS.ByteString
encode_FetchNotificationItems_args oprot record = T.serializeVal oprot $ from_FetchNotificationItems_args record
to_FetchNotificationItems_args :: T.ThriftVal -> FetchNotificationItems_args
to_FetchNotificationItems_args (T.TStruct fields) = FetchNotificationItems_args{
  fetchNotificationItems_args_localRev = P.maybe (fetchNotificationItems_args_localRev default_FetchNotificationItems_args) (\(_,_val2810) -> (case _val2810 of {T.TI64 _val2811 -> _val2811; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FetchNotificationItems_args _ = P.error "not a struct"
read_FetchNotificationItems_args :: T.Protocol p => p -> P.IO FetchNotificationItems_args
read_FetchNotificationItems_args iprot = to_FetchNotificationItems_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchNotificationItems_args)
decode_FetchNotificationItems_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchNotificationItems_args
decode_FetchNotificationItems_args iprot bs = to_FetchNotificationItems_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchNotificationItems_args) bs
typemap_FetchNotificationItems_args :: T.TypeMap
typemap_FetchNotificationItems_args = Map.fromList [(2,("localRev",T.T_I64))]
default_FetchNotificationItems_args :: FetchNotificationItems_args
default_FetchNotificationItems_args = FetchNotificationItems_args{
  fetchNotificationItems_args_localRev = 0}
data FetchNotificationItems_result = FetchNotificationItems_result  { fetchNotificationItems_result_success :: NotificationFetchResult
  , fetchNotificationItems_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchNotificationItems_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchNotificationItems_result_success record   `H.hashWithSalt` fetchNotificationItems_result_e record  
instance QC.Arbitrary FetchNotificationItems_result where 
  arbitrary = M.liftM FetchNotificationItems_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchNotificationItems_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchNotificationItems_result{fetchNotificationItems_result_success = fetchNotificationItems_result_success obj} then P.Nothing else P.Just $ default_FetchNotificationItems_result{fetchNotificationItems_result_success = fetchNotificationItems_result_success obj}
    , if obj == default_FetchNotificationItems_result{fetchNotificationItems_result_e = fetchNotificationItems_result_e obj} then P.Nothing else P.Just $ default_FetchNotificationItems_result{fetchNotificationItems_result_e = fetchNotificationItems_result_e obj}
    ]
from_FetchNotificationItems_result :: FetchNotificationItems_result -> T.ThriftVal
from_FetchNotificationItems_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2814 -> (1, ("e",from_ChannelException _v2814))) <$> fetchNotificationItems_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2814 -> P.Just (0, ("success",from_NotificationFetchResult _v2814))) $ fetchNotificationItems_result_success record
    , (\_v2814 -> (1, ("e",from_ChannelException _v2814))) <$> fetchNotificationItems_result_e record
    ]
    )
write_FetchNotificationItems_result :: T.Protocol p => p -> FetchNotificationItems_result -> P.IO ()
write_FetchNotificationItems_result oprot record = T.writeVal oprot $ from_FetchNotificationItems_result record
encode_FetchNotificationItems_result :: T.StatelessProtocol p => p -> FetchNotificationItems_result -> LBS.ByteString
encode_FetchNotificationItems_result oprot record = T.serializeVal oprot $ from_FetchNotificationItems_result record
to_FetchNotificationItems_result :: T.ThriftVal -> FetchNotificationItems_result
to_FetchNotificationItems_result (T.TStruct fields) = FetchNotificationItems_result{
  fetchNotificationItems_result_success = P.maybe (fetchNotificationItems_result_success default_FetchNotificationItems_result) (\(_,_val2816) -> (case _val2816 of {T.TStruct _val2817 -> (to_NotificationFetchResult (T.TStruct _val2817)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchNotificationItems_result_e = P.maybe (P.Nothing) (\(_,_val2816) -> P.Just (case _val2816 of {T.TStruct _val2818 -> (to_ChannelException (T.TStruct _val2818)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchNotificationItems_result _ = P.error "not a struct"
read_FetchNotificationItems_result :: T.Protocol p => p -> P.IO FetchNotificationItems_result
read_FetchNotificationItems_result iprot = to_FetchNotificationItems_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchNotificationItems_result)
decode_FetchNotificationItems_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchNotificationItems_result
decode_FetchNotificationItems_result iprot bs = to_FetchNotificationItems_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchNotificationItems_result) bs
typemap_FetchNotificationItems_result :: T.TypeMap
typemap_FetchNotificationItems_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_NotificationFetchResult))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_FetchNotificationItems_result :: FetchNotificationItems_result
default_FetchNotificationItems_result = FetchNotificationItems_result{
  fetchNotificationItems_result_success = default_NotificationFetchResult,
  fetchNotificationItems_result_e = P.Nothing}
data GetApprovedChannels_args = GetApprovedChannels_args  { getApprovedChannels_args_lastSynced :: I.Int64
  , getApprovedChannels_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetApprovedChannels_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getApprovedChannels_args_lastSynced record   `H.hashWithSalt` getApprovedChannels_args_locale record  
instance QC.Arbitrary GetApprovedChannels_args where 
  arbitrary = M.liftM GetApprovedChannels_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetApprovedChannels_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetApprovedChannels_args{getApprovedChannels_args_lastSynced = getApprovedChannels_args_lastSynced obj} then P.Nothing else P.Just $ default_GetApprovedChannels_args{getApprovedChannels_args_lastSynced = getApprovedChannels_args_lastSynced obj}
    , if obj == default_GetApprovedChannels_args{getApprovedChannels_args_locale = getApprovedChannels_args_locale obj} then P.Nothing else P.Just $ default_GetApprovedChannels_args{getApprovedChannels_args_locale = getApprovedChannels_args_locale obj}
    ]
from_GetApprovedChannels_args :: GetApprovedChannels_args -> T.ThriftVal
from_GetApprovedChannels_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2821 -> P.Just (2, ("lastSynced",T.TI64 _v2821))) $ getApprovedChannels_args_lastSynced record
  , (\_v2821 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v2821))) $ getApprovedChannels_args_locale record
  ]
write_GetApprovedChannels_args :: T.Protocol p => p -> GetApprovedChannels_args -> P.IO ()
write_GetApprovedChannels_args oprot record = T.writeVal oprot $ from_GetApprovedChannels_args record
encode_GetApprovedChannels_args :: T.StatelessProtocol p => p -> GetApprovedChannels_args -> LBS.ByteString
encode_GetApprovedChannels_args oprot record = T.serializeVal oprot $ from_GetApprovedChannels_args record
to_GetApprovedChannels_args :: T.ThriftVal -> GetApprovedChannels_args
to_GetApprovedChannels_args (T.TStruct fields) = GetApprovedChannels_args{
  getApprovedChannels_args_lastSynced = P.maybe (getApprovedChannels_args_lastSynced default_GetApprovedChannels_args) (\(_,_val2823) -> (case _val2823 of {T.TI64 _val2824 -> _val2824; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getApprovedChannels_args_locale = P.maybe (getApprovedChannels_args_locale default_GetApprovedChannels_args) (\(_,_val2823) -> (case _val2823 of {T.TString _val2825 -> E.decodeUtf8 _val2825; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetApprovedChannels_args _ = P.error "not a struct"
read_GetApprovedChannels_args :: T.Protocol p => p -> P.IO GetApprovedChannels_args
read_GetApprovedChannels_args iprot = to_GetApprovedChannels_args <$> T.readVal iprot (T.T_STRUCT typemap_GetApprovedChannels_args)
decode_GetApprovedChannels_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetApprovedChannels_args
decode_GetApprovedChannels_args iprot bs = to_GetApprovedChannels_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetApprovedChannels_args) bs
typemap_GetApprovedChannels_args :: T.TypeMap
typemap_GetApprovedChannels_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_GetApprovedChannels_args :: GetApprovedChannels_args
default_GetApprovedChannels_args = GetApprovedChannels_args{
  getApprovedChannels_args_lastSynced = 0,
  getApprovedChannels_args_locale = ""}
data GetApprovedChannels_result = GetApprovedChannels_result  { getApprovedChannels_result_success :: ApprovedChannelInfos
  , getApprovedChannels_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetApprovedChannels_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getApprovedChannels_result_success record   `H.hashWithSalt` getApprovedChannels_result_e record  
instance QC.Arbitrary GetApprovedChannels_result where 
  arbitrary = M.liftM GetApprovedChannels_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetApprovedChannels_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetApprovedChannels_result{getApprovedChannels_result_success = getApprovedChannels_result_success obj} then P.Nothing else P.Just $ default_GetApprovedChannels_result{getApprovedChannels_result_success = getApprovedChannels_result_success obj}
    , if obj == default_GetApprovedChannels_result{getApprovedChannels_result_e = getApprovedChannels_result_e obj} then P.Nothing else P.Just $ default_GetApprovedChannels_result{getApprovedChannels_result_e = getApprovedChannels_result_e obj}
    ]
from_GetApprovedChannels_result :: GetApprovedChannels_result -> T.ThriftVal
from_GetApprovedChannels_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2828 -> (1, ("e",from_ChannelException _v2828))) <$> getApprovedChannels_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2828 -> P.Just (0, ("success",from_ApprovedChannelInfos _v2828))) $ getApprovedChannels_result_success record
    , (\_v2828 -> (1, ("e",from_ChannelException _v2828))) <$> getApprovedChannels_result_e record
    ]
    )
write_GetApprovedChannels_result :: T.Protocol p => p -> GetApprovedChannels_result -> P.IO ()
write_GetApprovedChannels_result oprot record = T.writeVal oprot $ from_GetApprovedChannels_result record
encode_GetApprovedChannels_result :: T.StatelessProtocol p => p -> GetApprovedChannels_result -> LBS.ByteString
encode_GetApprovedChannels_result oprot record = T.serializeVal oprot $ from_GetApprovedChannels_result record
to_GetApprovedChannels_result :: T.ThriftVal -> GetApprovedChannels_result
to_GetApprovedChannels_result (T.TStruct fields) = GetApprovedChannels_result{
  getApprovedChannels_result_success = P.maybe (getApprovedChannels_result_success default_GetApprovedChannels_result) (\(_,_val2830) -> (case _val2830 of {T.TStruct _val2831 -> (to_ApprovedChannelInfos (T.TStruct _val2831)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getApprovedChannels_result_e = P.maybe (P.Nothing) (\(_,_val2830) -> P.Just (case _val2830 of {T.TStruct _val2832 -> (to_ChannelException (T.TStruct _val2832)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetApprovedChannels_result _ = P.error "not a struct"
read_GetApprovedChannels_result :: T.Protocol p => p -> P.IO GetApprovedChannels_result
read_GetApprovedChannels_result iprot = to_GetApprovedChannels_result <$> T.readVal iprot (T.T_STRUCT typemap_GetApprovedChannels_result)
decode_GetApprovedChannels_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetApprovedChannels_result
decode_GetApprovedChannels_result iprot bs = to_GetApprovedChannels_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetApprovedChannels_result) bs
typemap_GetApprovedChannels_result :: T.TypeMap
typemap_GetApprovedChannels_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ApprovedChannelInfos))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetApprovedChannels_result :: GetApprovedChannels_result
default_GetApprovedChannels_result = GetApprovedChannels_result{
  getApprovedChannels_result_success = default_ApprovedChannelInfos,
  getApprovedChannels_result_e = P.Nothing}
data GetChannelInfo_args = GetChannelInfo_args  { getChannelInfo_args_channelId :: LT.Text
  , getChannelInfo_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelInfo_args_channelId record   `H.hashWithSalt` getChannelInfo_args_locale record  
instance QC.Arbitrary GetChannelInfo_args where 
  arbitrary = M.liftM GetChannelInfo_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannelInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelInfo_args{getChannelInfo_args_channelId = getChannelInfo_args_channelId obj} then P.Nothing else P.Just $ default_GetChannelInfo_args{getChannelInfo_args_channelId = getChannelInfo_args_channelId obj}
    , if obj == default_GetChannelInfo_args{getChannelInfo_args_locale = getChannelInfo_args_locale obj} then P.Nothing else P.Just $ default_GetChannelInfo_args{getChannelInfo_args_locale = getChannelInfo_args_locale obj}
    ]
from_GetChannelInfo_args :: GetChannelInfo_args -> T.ThriftVal
from_GetChannelInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2835 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v2835))) $ getChannelInfo_args_channelId record
  , (\_v2835 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v2835))) $ getChannelInfo_args_locale record
  ]
write_GetChannelInfo_args :: T.Protocol p => p -> GetChannelInfo_args -> P.IO ()
write_GetChannelInfo_args oprot record = T.writeVal oprot $ from_GetChannelInfo_args record
encode_GetChannelInfo_args :: T.StatelessProtocol p => p -> GetChannelInfo_args -> LBS.ByteString
encode_GetChannelInfo_args oprot record = T.serializeVal oprot $ from_GetChannelInfo_args record
to_GetChannelInfo_args :: T.ThriftVal -> GetChannelInfo_args
to_GetChannelInfo_args (T.TStruct fields) = GetChannelInfo_args{
  getChannelInfo_args_channelId = P.maybe (getChannelInfo_args_channelId default_GetChannelInfo_args) (\(_,_val2837) -> (case _val2837 of {T.TString _val2838 -> E.decodeUtf8 _val2838; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getChannelInfo_args_locale = P.maybe (getChannelInfo_args_locale default_GetChannelInfo_args) (\(_,_val2837) -> (case _val2837 of {T.TString _val2839 -> E.decodeUtf8 _val2839; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetChannelInfo_args _ = P.error "not a struct"
read_GetChannelInfo_args :: T.Protocol p => p -> P.IO GetChannelInfo_args
read_GetChannelInfo_args iprot = to_GetChannelInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelInfo_args)
decode_GetChannelInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelInfo_args
decode_GetChannelInfo_args iprot bs = to_GetChannelInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelInfo_args) bs
typemap_GetChannelInfo_args :: T.TypeMap
typemap_GetChannelInfo_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("locale",T.T_STRING))]
default_GetChannelInfo_args :: GetChannelInfo_args
default_GetChannelInfo_args = GetChannelInfo_args{
  getChannelInfo_args_channelId = "",
  getChannelInfo_args_locale = ""}
data GetChannelInfo_result = GetChannelInfo_result  { getChannelInfo_result_success :: ChannelInfo
  , getChannelInfo_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelInfo_result_success record   `H.hashWithSalt` getChannelInfo_result_e record  
instance QC.Arbitrary GetChannelInfo_result where 
  arbitrary = M.liftM GetChannelInfo_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelInfo_result{getChannelInfo_result_success = getChannelInfo_result_success obj} then P.Nothing else P.Just $ default_GetChannelInfo_result{getChannelInfo_result_success = getChannelInfo_result_success obj}
    , if obj == default_GetChannelInfo_result{getChannelInfo_result_e = getChannelInfo_result_e obj} then P.Nothing else P.Just $ default_GetChannelInfo_result{getChannelInfo_result_e = getChannelInfo_result_e obj}
    ]
from_GetChannelInfo_result :: GetChannelInfo_result -> T.ThriftVal
from_GetChannelInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2842 -> (1, ("e",from_ChannelException _v2842))) <$> getChannelInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2842 -> P.Just (0, ("success",from_ChannelInfo _v2842))) $ getChannelInfo_result_success record
    , (\_v2842 -> (1, ("e",from_ChannelException _v2842))) <$> getChannelInfo_result_e record
    ]
    )
write_GetChannelInfo_result :: T.Protocol p => p -> GetChannelInfo_result -> P.IO ()
write_GetChannelInfo_result oprot record = T.writeVal oprot $ from_GetChannelInfo_result record
encode_GetChannelInfo_result :: T.StatelessProtocol p => p -> GetChannelInfo_result -> LBS.ByteString
encode_GetChannelInfo_result oprot record = T.serializeVal oprot $ from_GetChannelInfo_result record
to_GetChannelInfo_result :: T.ThriftVal -> GetChannelInfo_result
to_GetChannelInfo_result (T.TStruct fields) = GetChannelInfo_result{
  getChannelInfo_result_success = P.maybe (getChannelInfo_result_success default_GetChannelInfo_result) (\(_,_val2844) -> (case _val2844 of {T.TStruct _val2845 -> (to_ChannelInfo (T.TStruct _val2845)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelInfo_result_e = P.maybe (P.Nothing) (\(_,_val2844) -> P.Just (case _val2844 of {T.TStruct _val2846 -> (to_ChannelException (T.TStruct _val2846)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelInfo_result _ = P.error "not a struct"
read_GetChannelInfo_result :: T.Protocol p => p -> P.IO GetChannelInfo_result
read_GetChannelInfo_result iprot = to_GetChannelInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelInfo_result)
decode_GetChannelInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelInfo_result
decode_GetChannelInfo_result iprot bs = to_GetChannelInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelInfo_result) bs
typemap_GetChannelInfo_result :: T.TypeMap
typemap_GetChannelInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelInfo))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelInfo_result :: GetChannelInfo_result
default_GetChannelInfo_result = GetChannelInfo_result{
  getChannelInfo_result_success = default_ChannelInfo,
  getChannelInfo_result_e = P.Nothing}
data GetChannelNotificationSetting_args = GetChannelNotificationSetting_args  { getChannelNotificationSetting_args_channelId :: LT.Text
  , getChannelNotificationSetting_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSetting_args_channelId record   `H.hashWithSalt` getChannelNotificationSetting_args_locale record  
instance QC.Arbitrary GetChannelNotificationSetting_args where 
  arbitrary = M.liftM GetChannelNotificationSetting_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_channelId = getChannelNotificationSetting_args_channelId obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_channelId = getChannelNotificationSetting_args_channelId obj}
    , if obj == default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_locale = getChannelNotificationSetting_args_locale obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_locale = getChannelNotificationSetting_args_locale obj}
    ]
from_GetChannelNotificationSetting_args :: GetChannelNotificationSetting_args -> T.ThriftVal
from_GetChannelNotificationSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2849 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v2849))) $ getChannelNotificationSetting_args_channelId record
  , (\_v2849 -> P.Just (2, ("locale",T.TString $ E.encodeUtf8 _v2849))) $ getChannelNotificationSetting_args_locale record
  ]
write_GetChannelNotificationSetting_args :: T.Protocol p => p -> GetChannelNotificationSetting_args -> P.IO ()
write_GetChannelNotificationSetting_args oprot record = T.writeVal oprot $ from_GetChannelNotificationSetting_args record
encode_GetChannelNotificationSetting_args :: T.StatelessProtocol p => p -> GetChannelNotificationSetting_args -> LBS.ByteString
encode_GetChannelNotificationSetting_args oprot record = T.serializeVal oprot $ from_GetChannelNotificationSetting_args record
to_GetChannelNotificationSetting_args :: T.ThriftVal -> GetChannelNotificationSetting_args
to_GetChannelNotificationSetting_args (T.TStruct fields) = GetChannelNotificationSetting_args{
  getChannelNotificationSetting_args_channelId = P.maybe (getChannelNotificationSetting_args_channelId default_GetChannelNotificationSetting_args) (\(_,_val2851) -> (case _val2851 of {T.TString _val2852 -> E.decodeUtf8 _val2852; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getChannelNotificationSetting_args_locale = P.maybe (getChannelNotificationSetting_args_locale default_GetChannelNotificationSetting_args) (\(_,_val2851) -> (case _val2851 of {T.TString _val2853 -> E.decodeUtf8 _val2853; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetChannelNotificationSetting_args _ = P.error "not a struct"
read_GetChannelNotificationSetting_args :: T.Protocol p => p -> P.IO GetChannelNotificationSetting_args
read_GetChannelNotificationSetting_args iprot = to_GetChannelNotificationSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_args)
decode_GetChannelNotificationSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSetting_args
decode_GetChannelNotificationSetting_args iprot bs = to_GetChannelNotificationSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_args) bs
typemap_GetChannelNotificationSetting_args :: T.TypeMap
typemap_GetChannelNotificationSetting_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("locale",T.T_STRING))]
default_GetChannelNotificationSetting_args :: GetChannelNotificationSetting_args
default_GetChannelNotificationSetting_args = GetChannelNotificationSetting_args{
  getChannelNotificationSetting_args_channelId = "",
  getChannelNotificationSetting_args_locale = ""}
data GetChannelNotificationSetting_result = GetChannelNotificationSetting_result  { getChannelNotificationSetting_result_success :: ChannelNotificationSetting
  , getChannelNotificationSetting_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSetting_result_success record   `H.hashWithSalt` getChannelNotificationSetting_result_e record  
instance QC.Arbitrary GetChannelNotificationSetting_result where 
  arbitrary = M.liftM GetChannelNotificationSetting_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = getChannelNotificationSetting_result_success obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = getChannelNotificationSetting_result_success obj}
    , if obj == default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = getChannelNotificationSetting_result_e obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = getChannelNotificationSetting_result_e obj}
    ]
from_GetChannelNotificationSetting_result :: GetChannelNotificationSetting_result -> T.ThriftVal
from_GetChannelNotificationSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2856 -> (1, ("e",from_ChannelException _v2856))) <$> getChannelNotificationSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2856 -> P.Just (0, ("success",from_ChannelNotificationSetting _v2856))) $ getChannelNotificationSetting_result_success record
    , (\_v2856 -> (1, ("e",from_ChannelException _v2856))) <$> getChannelNotificationSetting_result_e record
    ]
    )
write_GetChannelNotificationSetting_result :: T.Protocol p => p -> GetChannelNotificationSetting_result -> P.IO ()
write_GetChannelNotificationSetting_result oprot record = T.writeVal oprot $ from_GetChannelNotificationSetting_result record
encode_GetChannelNotificationSetting_result :: T.StatelessProtocol p => p -> GetChannelNotificationSetting_result -> LBS.ByteString
encode_GetChannelNotificationSetting_result oprot record = T.serializeVal oprot $ from_GetChannelNotificationSetting_result record
to_GetChannelNotificationSetting_result :: T.ThriftVal -> GetChannelNotificationSetting_result
to_GetChannelNotificationSetting_result (T.TStruct fields) = GetChannelNotificationSetting_result{
  getChannelNotificationSetting_result_success = P.maybe (getChannelNotificationSetting_result_success default_GetChannelNotificationSetting_result) (\(_,_val2858) -> (case _val2858 of {T.TStruct _val2859 -> (to_ChannelNotificationSetting (T.TStruct _val2859)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelNotificationSetting_result_e = P.maybe (P.Nothing) (\(_,_val2858) -> P.Just (case _val2858 of {T.TStruct _val2860 -> (to_ChannelException (T.TStruct _val2860)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSetting_result _ = P.error "not a struct"
read_GetChannelNotificationSetting_result :: T.Protocol p => p -> P.IO GetChannelNotificationSetting_result
read_GetChannelNotificationSetting_result iprot = to_GetChannelNotificationSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_result)
decode_GetChannelNotificationSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSetting_result
decode_GetChannelNotificationSetting_result iprot bs = to_GetChannelNotificationSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_result) bs
typemap_GetChannelNotificationSetting_result :: T.TypeMap
typemap_GetChannelNotificationSetting_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelNotificationSetting))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelNotificationSetting_result :: GetChannelNotificationSetting_result
default_GetChannelNotificationSetting_result = GetChannelNotificationSetting_result{
  getChannelNotificationSetting_result_success = default_ChannelNotificationSetting,
  getChannelNotificationSetting_result_e = P.Nothing}
data GetChannelNotificationSettings_args = GetChannelNotificationSettings_args  { getChannelNotificationSettings_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSettings_args_locale record  
instance QC.Arbitrary GetChannelNotificationSettings_args where 
  arbitrary = M.liftM GetChannelNotificationSettings_args (QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSettings_args{getChannelNotificationSettings_args_locale = getChannelNotificationSettings_args_locale obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_args{getChannelNotificationSettings_args_locale = getChannelNotificationSettings_args_locale obj}
    ]
from_GetChannelNotificationSettings_args :: GetChannelNotificationSettings_args -> T.ThriftVal
from_GetChannelNotificationSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2863 -> P.Just (1, ("locale",T.TString $ E.encodeUtf8 _v2863))) $ getChannelNotificationSettings_args_locale record
  ]
write_GetChannelNotificationSettings_args :: T.Protocol p => p -> GetChannelNotificationSettings_args -> P.IO ()
write_GetChannelNotificationSettings_args oprot record = T.writeVal oprot $ from_GetChannelNotificationSettings_args record
encode_GetChannelNotificationSettings_args :: T.StatelessProtocol p => p -> GetChannelNotificationSettings_args -> LBS.ByteString
encode_GetChannelNotificationSettings_args oprot record = T.serializeVal oprot $ from_GetChannelNotificationSettings_args record
to_GetChannelNotificationSettings_args :: T.ThriftVal -> GetChannelNotificationSettings_args
to_GetChannelNotificationSettings_args (T.TStruct fields) = GetChannelNotificationSettings_args{
  getChannelNotificationSettings_args_locale = P.maybe (getChannelNotificationSettings_args_locale default_GetChannelNotificationSettings_args) (\(_,_val2865) -> (case _val2865 of {T.TString _val2866 -> E.decodeUtf8 _val2866; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSettings_args _ = P.error "not a struct"
read_GetChannelNotificationSettings_args :: T.Protocol p => p -> P.IO GetChannelNotificationSettings_args
read_GetChannelNotificationSettings_args iprot = to_GetChannelNotificationSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_args)
decode_GetChannelNotificationSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSettings_args
decode_GetChannelNotificationSettings_args iprot bs = to_GetChannelNotificationSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_args) bs
typemap_GetChannelNotificationSettings_args :: T.TypeMap
typemap_GetChannelNotificationSettings_args = Map.fromList [(1,("locale",T.T_STRING))]
default_GetChannelNotificationSettings_args :: GetChannelNotificationSettings_args
default_GetChannelNotificationSettings_args = GetChannelNotificationSettings_args{
  getChannelNotificationSettings_args_locale = ""}
data GetChannelNotificationSettings_result = GetChannelNotificationSettings_result  { getChannelNotificationSettings_result_success :: (Vector.Vector ChannelNotificationSetting)
  , getChannelNotificationSettings_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSettings_result_success record   `H.hashWithSalt` getChannelNotificationSettings_result_e record  
instance QC.Arbitrary GetChannelNotificationSettings_result where 
  arbitrary = M.liftM GetChannelNotificationSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = getChannelNotificationSettings_result_success obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = getChannelNotificationSettings_result_success obj}
    , if obj == default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = getChannelNotificationSettings_result_e obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = getChannelNotificationSettings_result_e obj}
    ]
from_GetChannelNotificationSettings_result :: GetChannelNotificationSettings_result -> T.ThriftVal
from_GetChannelNotificationSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2869 -> (1, ("e",from_ChannelException _v2869))) <$> getChannelNotificationSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2869 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_ChannelNotificationSetting) $ P.map (\_v2871 -> from_ChannelNotificationSetting _v2871) $ Vector.toList _v2869))) $ getChannelNotificationSettings_result_success record
    , (\_v2869 -> (1, ("e",from_ChannelException _v2869))) <$> getChannelNotificationSettings_result_e record
    ]
    )
write_GetChannelNotificationSettings_result :: T.Protocol p => p -> GetChannelNotificationSettings_result -> P.IO ()
write_GetChannelNotificationSettings_result oprot record = T.writeVal oprot $ from_GetChannelNotificationSettings_result record
encode_GetChannelNotificationSettings_result :: T.StatelessProtocol p => p -> GetChannelNotificationSettings_result -> LBS.ByteString
encode_GetChannelNotificationSettings_result oprot record = T.serializeVal oprot $ from_GetChannelNotificationSettings_result record
to_GetChannelNotificationSettings_result :: T.ThriftVal -> GetChannelNotificationSettings_result
to_GetChannelNotificationSettings_result (T.TStruct fields) = GetChannelNotificationSettings_result{
  getChannelNotificationSettings_result_success = P.maybe (getChannelNotificationSettings_result_success default_GetChannelNotificationSettings_result) (\(_,_val2873) -> (case _val2873 of {T.TList _ _val2874 -> (Vector.fromList $ P.map (\_v2875 -> (case _v2875 of {T.TStruct _val2876 -> (to_ChannelNotificationSetting (T.TStruct _val2876)); _ -> P.error "wrong type"})) _val2874); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelNotificationSettings_result_e = P.maybe (P.Nothing) (\(_,_val2873) -> P.Just (case _val2873 of {T.TStruct _val2877 -> (to_ChannelException (T.TStruct _val2877)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSettings_result _ = P.error "not a struct"
read_GetChannelNotificationSettings_result :: T.Protocol p => p -> P.IO GetChannelNotificationSettings_result
read_GetChannelNotificationSettings_result iprot = to_GetChannelNotificationSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_result)
decode_GetChannelNotificationSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSettings_result
decode_GetChannelNotificationSettings_result iprot bs = to_GetChannelNotificationSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_result) bs
typemap_GetChannelNotificationSettings_result :: T.TypeMap
typemap_GetChannelNotificationSettings_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_ChannelNotificationSetting)))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelNotificationSettings_result :: GetChannelNotificationSettings_result
default_GetChannelNotificationSettings_result = GetChannelNotificationSettings_result{
  getChannelNotificationSettings_result_success = Vector.empty,
  getChannelNotificationSettings_result_e = P.Nothing}
data GetChannels_args = GetChannels_args  { getChannels_args_lastSynced :: I.Int64
  , getChannels_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannels_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannels_args_lastSynced record   `H.hashWithSalt` getChannels_args_locale record  
instance QC.Arbitrary GetChannels_args where 
  arbitrary = M.liftM GetChannels_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannels_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannels_args{getChannels_args_lastSynced = getChannels_args_lastSynced obj} then P.Nothing else P.Just $ default_GetChannels_args{getChannels_args_lastSynced = getChannels_args_lastSynced obj}
    , if obj == default_GetChannels_args{getChannels_args_locale = getChannels_args_locale obj} then P.Nothing else P.Just $ default_GetChannels_args{getChannels_args_locale = getChannels_args_locale obj}
    ]
from_GetChannels_args :: GetChannels_args -> T.ThriftVal
from_GetChannels_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2880 -> P.Just (2, ("lastSynced",T.TI64 _v2880))) $ getChannels_args_lastSynced record
  , (\_v2880 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v2880))) $ getChannels_args_locale record
  ]
write_GetChannels_args :: T.Protocol p => p -> GetChannels_args -> P.IO ()
write_GetChannels_args oprot record = T.writeVal oprot $ from_GetChannels_args record
encode_GetChannels_args :: T.StatelessProtocol p => p -> GetChannels_args -> LBS.ByteString
encode_GetChannels_args oprot record = T.serializeVal oprot $ from_GetChannels_args record
to_GetChannels_args :: T.ThriftVal -> GetChannels_args
to_GetChannels_args (T.TStruct fields) = GetChannels_args{
  getChannels_args_lastSynced = P.maybe (getChannels_args_lastSynced default_GetChannels_args) (\(_,_val2882) -> (case _val2882 of {T.TI64 _val2883 -> _val2883; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getChannels_args_locale = P.maybe (getChannels_args_locale default_GetChannels_args) (\(_,_val2882) -> (case _val2882 of {T.TString _val2884 -> E.decodeUtf8 _val2884; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetChannels_args _ = P.error "not a struct"
read_GetChannels_args :: T.Protocol p => p -> P.IO GetChannels_args
read_GetChannels_args iprot = to_GetChannels_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannels_args)
decode_GetChannels_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannels_args
decode_GetChannels_args iprot bs = to_GetChannels_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannels_args) bs
typemap_GetChannels_args :: T.TypeMap
typemap_GetChannels_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_GetChannels_args :: GetChannels_args
default_GetChannels_args = GetChannels_args{
  getChannels_args_lastSynced = 0,
  getChannels_args_locale = ""}
data GetChannels_result = GetChannels_result  { getChannels_result_success :: ChannelInfos
  , getChannels_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannels_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannels_result_success record   `H.hashWithSalt` getChannels_result_e record  
instance QC.Arbitrary GetChannels_result where 
  arbitrary = M.liftM GetChannels_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannels_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannels_result{getChannels_result_success = getChannels_result_success obj} then P.Nothing else P.Just $ default_GetChannels_result{getChannels_result_success = getChannels_result_success obj}
    , if obj == default_GetChannels_result{getChannels_result_e = getChannels_result_e obj} then P.Nothing else P.Just $ default_GetChannels_result{getChannels_result_e = getChannels_result_e obj}
    ]
from_GetChannels_result :: GetChannels_result -> T.ThriftVal
from_GetChannels_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2887 -> (1, ("e",from_ChannelException _v2887))) <$> getChannels_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2887 -> P.Just (0, ("success",from_ChannelInfos _v2887))) $ getChannels_result_success record
    , (\_v2887 -> (1, ("e",from_ChannelException _v2887))) <$> getChannels_result_e record
    ]
    )
write_GetChannels_result :: T.Protocol p => p -> GetChannels_result -> P.IO ()
write_GetChannels_result oprot record = T.writeVal oprot $ from_GetChannels_result record
encode_GetChannels_result :: T.StatelessProtocol p => p -> GetChannels_result -> LBS.ByteString
encode_GetChannels_result oprot record = T.serializeVal oprot $ from_GetChannels_result record
to_GetChannels_result :: T.ThriftVal -> GetChannels_result
to_GetChannels_result (T.TStruct fields) = GetChannels_result{
  getChannels_result_success = P.maybe (getChannels_result_success default_GetChannels_result) (\(_,_val2889) -> (case _val2889 of {T.TStruct _val2890 -> (to_ChannelInfos (T.TStruct _val2890)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannels_result_e = P.maybe (P.Nothing) (\(_,_val2889) -> P.Just (case _val2889 of {T.TStruct _val2891 -> (to_ChannelException (T.TStruct _val2891)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannels_result _ = P.error "not a struct"
read_GetChannels_result :: T.Protocol p => p -> P.IO GetChannels_result
read_GetChannels_result iprot = to_GetChannels_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannels_result)
decode_GetChannels_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannels_result
decode_GetChannels_result iprot bs = to_GetChannels_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannels_result) bs
typemap_GetChannels_result :: T.TypeMap
typemap_GetChannels_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelInfos))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannels_result :: GetChannels_result
default_GetChannels_result = GetChannels_result{
  getChannels_result_success = default_ChannelInfos,
  getChannels_result_e = P.Nothing}
data GetDomains_args = GetDomains_args  { getDomains_args_lastSynced :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDomains_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDomains_args_lastSynced record  
instance QC.Arbitrary GetDomains_args where 
  arbitrary = M.liftM GetDomains_args (QC.arbitrary)
  shrink obj | obj == default_GetDomains_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDomains_args{getDomains_args_lastSynced = getDomains_args_lastSynced obj} then P.Nothing else P.Just $ default_GetDomains_args{getDomains_args_lastSynced = getDomains_args_lastSynced obj}
    ]
from_GetDomains_args :: GetDomains_args -> T.ThriftVal
from_GetDomains_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2894 -> P.Just (2, ("lastSynced",T.TI64 _v2894))) $ getDomains_args_lastSynced record
  ]
write_GetDomains_args :: T.Protocol p => p -> GetDomains_args -> P.IO ()
write_GetDomains_args oprot record = T.writeVal oprot $ from_GetDomains_args record
encode_GetDomains_args :: T.StatelessProtocol p => p -> GetDomains_args -> LBS.ByteString
encode_GetDomains_args oprot record = T.serializeVal oprot $ from_GetDomains_args record
to_GetDomains_args :: T.ThriftVal -> GetDomains_args
to_GetDomains_args (T.TStruct fields) = GetDomains_args{
  getDomains_args_lastSynced = P.maybe (getDomains_args_lastSynced default_GetDomains_args) (\(_,_val2896) -> (case _val2896 of {T.TI64 _val2897 -> _val2897; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDomains_args _ = P.error "not a struct"
read_GetDomains_args :: T.Protocol p => p -> P.IO GetDomains_args
read_GetDomains_args iprot = to_GetDomains_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDomains_args)
decode_GetDomains_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDomains_args
decode_GetDomains_args iprot bs = to_GetDomains_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDomains_args) bs
typemap_GetDomains_args :: T.TypeMap
typemap_GetDomains_args = Map.fromList [(2,("lastSynced",T.T_I64))]
default_GetDomains_args :: GetDomains_args
default_GetDomains_args = GetDomains_args{
  getDomains_args_lastSynced = 0}
data GetDomains_result = GetDomains_result  { getDomains_result_success :: ChannelDomains
  , getDomains_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDomains_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDomains_result_success record   `H.hashWithSalt` getDomains_result_e record  
instance QC.Arbitrary GetDomains_result where 
  arbitrary = M.liftM GetDomains_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDomains_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDomains_result{getDomains_result_success = getDomains_result_success obj} then P.Nothing else P.Just $ default_GetDomains_result{getDomains_result_success = getDomains_result_success obj}
    , if obj == default_GetDomains_result{getDomains_result_e = getDomains_result_e obj} then P.Nothing else P.Just $ default_GetDomains_result{getDomains_result_e = getDomains_result_e obj}
    ]
from_GetDomains_result :: GetDomains_result -> T.ThriftVal
from_GetDomains_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2900 -> (1, ("e",from_ChannelException _v2900))) <$> getDomains_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2900 -> P.Just (0, ("success",from_ChannelDomains _v2900))) $ getDomains_result_success record
    , (\_v2900 -> (1, ("e",from_ChannelException _v2900))) <$> getDomains_result_e record
    ]
    )
write_GetDomains_result :: T.Protocol p => p -> GetDomains_result -> P.IO ()
write_GetDomains_result oprot record = T.writeVal oprot $ from_GetDomains_result record
encode_GetDomains_result :: T.StatelessProtocol p => p -> GetDomains_result -> LBS.ByteString
encode_GetDomains_result oprot record = T.serializeVal oprot $ from_GetDomains_result record
to_GetDomains_result :: T.ThriftVal -> GetDomains_result
to_GetDomains_result (T.TStruct fields) = GetDomains_result{
  getDomains_result_success = P.maybe (getDomains_result_success default_GetDomains_result) (\(_,_val2902) -> (case _val2902 of {T.TStruct _val2903 -> (to_ChannelDomains (T.TStruct _val2903)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDomains_result_e = P.maybe (P.Nothing) (\(_,_val2902) -> P.Just (case _val2902 of {T.TStruct _val2904 -> (to_ChannelException (T.TStruct _val2904)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDomains_result _ = P.error "not a struct"
read_GetDomains_result :: T.Protocol p => p -> P.IO GetDomains_result
read_GetDomains_result iprot = to_GetDomains_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDomains_result)
decode_GetDomains_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDomains_result
decode_GetDomains_result iprot bs = to_GetDomains_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDomains_result) bs
typemap_GetDomains_result :: T.TypeMap
typemap_GetDomains_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelDomains))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetDomains_result :: GetDomains_result
default_GetDomains_result = GetDomains_result{
  getDomains_result_success = default_ChannelDomains,
  getDomains_result_e = P.Nothing}
data GetFriendChannelMatrices_args = GetFriendChannelMatrices_args  { getFriendChannelMatrices_args_channelIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendChannelMatrices_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendChannelMatrices_args_channelIds record  
instance QC.Arbitrary GetFriendChannelMatrices_args where 
  arbitrary = M.liftM GetFriendChannelMatrices_args (QC.arbitrary)
  shrink obj | obj == default_GetFriendChannelMatrices_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendChannelMatrices_args{getFriendChannelMatrices_args_channelIds = getFriendChannelMatrices_args_channelIds obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_args{getFriendChannelMatrices_args_channelIds = getFriendChannelMatrices_args_channelIds obj}
    ]
from_GetFriendChannelMatrices_args :: GetFriendChannelMatrices_args -> T.ThriftVal
from_GetFriendChannelMatrices_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2907 -> P.Just (1, ("channelIds",T.TList T.T_STRING $ P.map (\_v2909 -> T.TString $ E.encodeUtf8 _v2909) $ Vector.toList _v2907))) $ getFriendChannelMatrices_args_channelIds record
  ]
write_GetFriendChannelMatrices_args :: T.Protocol p => p -> GetFriendChannelMatrices_args -> P.IO ()
write_GetFriendChannelMatrices_args oprot record = T.writeVal oprot $ from_GetFriendChannelMatrices_args record
encode_GetFriendChannelMatrices_args :: T.StatelessProtocol p => p -> GetFriendChannelMatrices_args -> LBS.ByteString
encode_GetFriendChannelMatrices_args oprot record = T.serializeVal oprot $ from_GetFriendChannelMatrices_args record
to_GetFriendChannelMatrices_args :: T.ThriftVal -> GetFriendChannelMatrices_args
to_GetFriendChannelMatrices_args (T.TStruct fields) = GetFriendChannelMatrices_args{
  getFriendChannelMatrices_args_channelIds = P.maybe (getFriendChannelMatrices_args_channelIds default_GetFriendChannelMatrices_args) (\(_,_val2911) -> (case _val2911 of {T.TList _ _val2912 -> (Vector.fromList $ P.map (\_v2913 -> (case _v2913 of {T.TString _val2914 -> E.decodeUtf8 _val2914; _ -> P.error "wrong type"})) _val2912); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendChannelMatrices_args _ = P.error "not a struct"
read_GetFriendChannelMatrices_args :: T.Protocol p => p -> P.IO GetFriendChannelMatrices_args
read_GetFriendChannelMatrices_args iprot = to_GetFriendChannelMatrices_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_args)
decode_GetFriendChannelMatrices_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendChannelMatrices_args
decode_GetFriendChannelMatrices_args iprot bs = to_GetFriendChannelMatrices_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_args) bs
typemap_GetFriendChannelMatrices_args :: T.TypeMap
typemap_GetFriendChannelMatrices_args = Map.fromList [(1,("channelIds",(T.T_LIST T.T_STRING)))]
default_GetFriendChannelMatrices_args :: GetFriendChannelMatrices_args
default_GetFriendChannelMatrices_args = GetFriendChannelMatrices_args{
  getFriendChannelMatrices_args_channelIds = Vector.empty}
data GetFriendChannelMatrices_result = GetFriendChannelMatrices_result  { getFriendChannelMatrices_result_success :: FriendChannelMatricesResponse
  , getFriendChannelMatrices_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendChannelMatrices_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendChannelMatrices_result_success record   `H.hashWithSalt` getFriendChannelMatrices_result_e record  
instance QC.Arbitrary GetFriendChannelMatrices_result where 
  arbitrary = M.liftM GetFriendChannelMatrices_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendChannelMatrices_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = getFriendChannelMatrices_result_success obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = getFriendChannelMatrices_result_success obj}
    , if obj == default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = getFriendChannelMatrices_result_e obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = getFriendChannelMatrices_result_e obj}
    ]
from_GetFriendChannelMatrices_result :: GetFriendChannelMatrices_result -> T.ThriftVal
from_GetFriendChannelMatrices_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2917 -> (1, ("e",from_ChannelException _v2917))) <$> getFriendChannelMatrices_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2917 -> P.Just (0, ("success",from_FriendChannelMatricesResponse _v2917))) $ getFriendChannelMatrices_result_success record
    , (\_v2917 -> (1, ("e",from_ChannelException _v2917))) <$> getFriendChannelMatrices_result_e record
    ]
    )
write_GetFriendChannelMatrices_result :: T.Protocol p => p -> GetFriendChannelMatrices_result -> P.IO ()
write_GetFriendChannelMatrices_result oprot record = T.writeVal oprot $ from_GetFriendChannelMatrices_result record
encode_GetFriendChannelMatrices_result :: T.StatelessProtocol p => p -> GetFriendChannelMatrices_result -> LBS.ByteString
encode_GetFriendChannelMatrices_result oprot record = T.serializeVal oprot $ from_GetFriendChannelMatrices_result record
to_GetFriendChannelMatrices_result :: T.ThriftVal -> GetFriendChannelMatrices_result
to_GetFriendChannelMatrices_result (T.TStruct fields) = GetFriendChannelMatrices_result{
  getFriendChannelMatrices_result_success = P.maybe (getFriendChannelMatrices_result_success default_GetFriendChannelMatrices_result) (\(_,_val2919) -> (case _val2919 of {T.TStruct _val2920 -> (to_FriendChannelMatricesResponse (T.TStruct _val2920)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendChannelMatrices_result_e = P.maybe (P.Nothing) (\(_,_val2919) -> P.Just (case _val2919 of {T.TStruct _val2921 -> (to_ChannelException (T.TStruct _val2921)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendChannelMatrices_result _ = P.error "not a struct"
read_GetFriendChannelMatrices_result :: T.Protocol p => p -> P.IO GetFriendChannelMatrices_result
read_GetFriendChannelMatrices_result iprot = to_GetFriendChannelMatrices_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_result)
decode_GetFriendChannelMatrices_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendChannelMatrices_result
decode_GetFriendChannelMatrices_result iprot bs = to_GetFriendChannelMatrices_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_result) bs
typemap_GetFriendChannelMatrices_result :: T.TypeMap
typemap_GetFriendChannelMatrices_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_FriendChannelMatricesResponse))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetFriendChannelMatrices_result :: GetFriendChannelMatrices_result
default_GetFriendChannelMatrices_result = GetFriendChannelMatrices_result{
  getFriendChannelMatrices_result_success = default_FriendChannelMatricesResponse,
  getFriendChannelMatrices_result_e = P.Nothing}
data GetNotificationBadgeCount_args = GetNotificationBadgeCount_args  { getNotificationBadgeCount_args_localRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationBadgeCount_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationBadgeCount_args_localRev record  
instance QC.Arbitrary GetNotificationBadgeCount_args where 
  arbitrary = M.liftM GetNotificationBadgeCount_args (QC.arbitrary)
  shrink obj | obj == default_GetNotificationBadgeCount_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationBadgeCount_args{getNotificationBadgeCount_args_localRev = getNotificationBadgeCount_args_localRev obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_args{getNotificationBadgeCount_args_localRev = getNotificationBadgeCount_args_localRev obj}
    ]
from_GetNotificationBadgeCount_args :: GetNotificationBadgeCount_args -> T.ThriftVal
from_GetNotificationBadgeCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2924 -> P.Just (2, ("localRev",T.TI64 _v2924))) $ getNotificationBadgeCount_args_localRev record
  ]
write_GetNotificationBadgeCount_args :: T.Protocol p => p -> GetNotificationBadgeCount_args -> P.IO ()
write_GetNotificationBadgeCount_args oprot record = T.writeVal oprot $ from_GetNotificationBadgeCount_args record
encode_GetNotificationBadgeCount_args :: T.StatelessProtocol p => p -> GetNotificationBadgeCount_args -> LBS.ByteString
encode_GetNotificationBadgeCount_args oprot record = T.serializeVal oprot $ from_GetNotificationBadgeCount_args record
to_GetNotificationBadgeCount_args :: T.ThriftVal -> GetNotificationBadgeCount_args
to_GetNotificationBadgeCount_args (T.TStruct fields) = GetNotificationBadgeCount_args{
  getNotificationBadgeCount_args_localRev = P.maybe (getNotificationBadgeCount_args_localRev default_GetNotificationBadgeCount_args) (\(_,_val2926) -> (case _val2926 of {T.TI64 _val2927 -> _val2927; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNotificationBadgeCount_args _ = P.error "not a struct"
read_GetNotificationBadgeCount_args :: T.Protocol p => p -> P.IO GetNotificationBadgeCount_args
read_GetNotificationBadgeCount_args iprot = to_GetNotificationBadgeCount_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_args)
decode_GetNotificationBadgeCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationBadgeCount_args
decode_GetNotificationBadgeCount_args iprot bs = to_GetNotificationBadgeCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_args) bs
typemap_GetNotificationBadgeCount_args :: T.TypeMap
typemap_GetNotificationBadgeCount_args = Map.fromList [(2,("localRev",T.T_I64))]
default_GetNotificationBadgeCount_args :: GetNotificationBadgeCount_args
default_GetNotificationBadgeCount_args = GetNotificationBadgeCount_args{
  getNotificationBadgeCount_args_localRev = 0}
data GetNotificationBadgeCount_result = GetNotificationBadgeCount_result  { getNotificationBadgeCount_result_success :: I.Int32
  , getNotificationBadgeCount_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationBadgeCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationBadgeCount_result_success record   `H.hashWithSalt` getNotificationBadgeCount_result_e record  
instance QC.Arbitrary GetNotificationBadgeCount_result where 
  arbitrary = M.liftM GetNotificationBadgeCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNotificationBadgeCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = getNotificationBadgeCount_result_success obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = getNotificationBadgeCount_result_success obj}
    , if obj == default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = getNotificationBadgeCount_result_e obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = getNotificationBadgeCount_result_e obj}
    ]
from_GetNotificationBadgeCount_result :: GetNotificationBadgeCount_result -> T.ThriftVal
from_GetNotificationBadgeCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2930 -> (1, ("e",from_ChannelException _v2930))) <$> getNotificationBadgeCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2930 -> P.Just (0, ("success",T.TI32 _v2930))) $ getNotificationBadgeCount_result_success record
    , (\_v2930 -> (1, ("e",from_ChannelException _v2930))) <$> getNotificationBadgeCount_result_e record
    ]
    )
write_GetNotificationBadgeCount_result :: T.Protocol p => p -> GetNotificationBadgeCount_result -> P.IO ()
write_GetNotificationBadgeCount_result oprot record = T.writeVal oprot $ from_GetNotificationBadgeCount_result record
encode_GetNotificationBadgeCount_result :: T.StatelessProtocol p => p -> GetNotificationBadgeCount_result -> LBS.ByteString
encode_GetNotificationBadgeCount_result oprot record = T.serializeVal oprot $ from_GetNotificationBadgeCount_result record
to_GetNotificationBadgeCount_result :: T.ThriftVal -> GetNotificationBadgeCount_result
to_GetNotificationBadgeCount_result (T.TStruct fields) = GetNotificationBadgeCount_result{
  getNotificationBadgeCount_result_success = P.maybe (getNotificationBadgeCount_result_success default_GetNotificationBadgeCount_result) (\(_,_val2932) -> (case _val2932 of {T.TI32 _val2933 -> _val2933; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNotificationBadgeCount_result_e = P.maybe (P.Nothing) (\(_,_val2932) -> P.Just (case _val2932 of {T.TStruct _val2934 -> (to_ChannelException (T.TStruct _val2934)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNotificationBadgeCount_result _ = P.error "not a struct"
read_GetNotificationBadgeCount_result :: T.Protocol p => p -> P.IO GetNotificationBadgeCount_result
read_GetNotificationBadgeCount_result iprot = to_GetNotificationBadgeCount_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_result)
decode_GetNotificationBadgeCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationBadgeCount_result
decode_GetNotificationBadgeCount_result iprot bs = to_GetNotificationBadgeCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_result) bs
typemap_GetNotificationBadgeCount_result :: T.TypeMap
typemap_GetNotificationBadgeCount_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetNotificationBadgeCount_result :: GetNotificationBadgeCount_result
default_GetNotificationBadgeCount_result = GetNotificationBadgeCount_result{
  getNotificationBadgeCount_result_success = 0,
  getNotificationBadgeCount_result_e = P.Nothing}
data IssueChannelToken_args = IssueChannelToken_args  { issueChannelToken_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueChannelToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueChannelToken_args_channelId record  
instance QC.Arbitrary IssueChannelToken_args where 
  arbitrary = M.liftM IssueChannelToken_args (QC.arbitrary)
  shrink obj | obj == default_IssueChannelToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueChannelToken_args{issueChannelToken_args_channelId = issueChannelToken_args_channelId obj} then P.Nothing else P.Just $ default_IssueChannelToken_args{issueChannelToken_args_channelId = issueChannelToken_args_channelId obj}
    ]
from_IssueChannelToken_args :: IssueChannelToken_args -> T.ThriftVal
from_IssueChannelToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2937 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v2937))) $ issueChannelToken_args_channelId record
  ]
write_IssueChannelToken_args :: T.Protocol p => p -> IssueChannelToken_args -> P.IO ()
write_IssueChannelToken_args oprot record = T.writeVal oprot $ from_IssueChannelToken_args record
encode_IssueChannelToken_args :: T.StatelessProtocol p => p -> IssueChannelToken_args -> LBS.ByteString
encode_IssueChannelToken_args oprot record = T.serializeVal oprot $ from_IssueChannelToken_args record
to_IssueChannelToken_args :: T.ThriftVal -> IssueChannelToken_args
to_IssueChannelToken_args (T.TStruct fields) = IssueChannelToken_args{
  issueChannelToken_args_channelId = P.maybe (issueChannelToken_args_channelId default_IssueChannelToken_args) (\(_,_val2939) -> (case _val2939 of {T.TString _val2940 -> E.decodeUtf8 _val2940; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueChannelToken_args _ = P.error "not a struct"
read_IssueChannelToken_args :: T.Protocol p => p -> P.IO IssueChannelToken_args
read_IssueChannelToken_args iprot = to_IssueChannelToken_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueChannelToken_args)
decode_IssueChannelToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueChannelToken_args
decode_IssueChannelToken_args iprot bs = to_IssueChannelToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueChannelToken_args) bs
typemap_IssueChannelToken_args :: T.TypeMap
typemap_IssueChannelToken_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_IssueChannelToken_args :: IssueChannelToken_args
default_IssueChannelToken_args = IssueChannelToken_args{
  issueChannelToken_args_channelId = ""}
data IssueChannelToken_result = IssueChannelToken_result  { issueChannelToken_result_success :: ChannelToken
  , issueChannelToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueChannelToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueChannelToken_result_success record   `H.hashWithSalt` issueChannelToken_result_e record  
instance QC.Arbitrary IssueChannelToken_result where 
  arbitrary = M.liftM IssueChannelToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueChannelToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueChannelToken_result{issueChannelToken_result_success = issueChannelToken_result_success obj} then P.Nothing else P.Just $ default_IssueChannelToken_result{issueChannelToken_result_success = issueChannelToken_result_success obj}
    , if obj == default_IssueChannelToken_result{issueChannelToken_result_e = issueChannelToken_result_e obj} then P.Nothing else P.Just $ default_IssueChannelToken_result{issueChannelToken_result_e = issueChannelToken_result_e obj}
    ]
from_IssueChannelToken_result :: IssueChannelToken_result -> T.ThriftVal
from_IssueChannelToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2943 -> (1, ("e",from_ChannelException _v2943))) <$> issueChannelToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2943 -> P.Just (0, ("success",from_ChannelToken _v2943))) $ issueChannelToken_result_success record
    , (\_v2943 -> (1, ("e",from_ChannelException _v2943))) <$> issueChannelToken_result_e record
    ]
    )
write_IssueChannelToken_result :: T.Protocol p => p -> IssueChannelToken_result -> P.IO ()
write_IssueChannelToken_result oprot record = T.writeVal oprot $ from_IssueChannelToken_result record
encode_IssueChannelToken_result :: T.StatelessProtocol p => p -> IssueChannelToken_result -> LBS.ByteString
encode_IssueChannelToken_result oprot record = T.serializeVal oprot $ from_IssueChannelToken_result record
to_IssueChannelToken_result :: T.ThriftVal -> IssueChannelToken_result
to_IssueChannelToken_result (T.TStruct fields) = IssueChannelToken_result{
  issueChannelToken_result_success = P.maybe (issueChannelToken_result_success default_IssueChannelToken_result) (\(_,_val2945) -> (case _val2945 of {T.TStruct _val2946 -> (to_ChannelToken (T.TStruct _val2946)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueChannelToken_result_e = P.maybe (P.Nothing) (\(_,_val2945) -> P.Just (case _val2945 of {T.TStruct _val2947 -> (to_ChannelException (T.TStruct _val2947)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueChannelToken_result _ = P.error "not a struct"
read_IssueChannelToken_result :: T.Protocol p => p -> P.IO IssueChannelToken_result
read_IssueChannelToken_result iprot = to_IssueChannelToken_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueChannelToken_result)
decode_IssueChannelToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueChannelToken_result
decode_IssueChannelToken_result iprot bs = to_IssueChannelToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueChannelToken_result) bs
typemap_IssueChannelToken_result :: T.TypeMap
typemap_IssueChannelToken_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelToken))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueChannelToken_result :: IssueChannelToken_result
default_IssueChannelToken_result = IssueChannelToken_result{
  issueChannelToken_result_success = default_ChannelToken,
  issueChannelToken_result_e = P.Nothing}
data IssueRequestToken_args = IssueRequestToken_args  { issueRequestToken_args_channelId :: LT.Text
  , issueRequestToken_args_otpId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestToken_args_channelId record   `H.hashWithSalt` issueRequestToken_args_otpId record  
instance QC.Arbitrary IssueRequestToken_args where 
  arbitrary = M.liftM IssueRequestToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestToken_args{issueRequestToken_args_channelId = issueRequestToken_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestToken_args{issueRequestToken_args_channelId = issueRequestToken_args_channelId obj}
    , if obj == default_IssueRequestToken_args{issueRequestToken_args_otpId = issueRequestToken_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestToken_args{issueRequestToken_args_otpId = issueRequestToken_args_otpId obj}
    ]
from_IssueRequestToken_args :: IssueRequestToken_args -> T.ThriftVal
from_IssueRequestToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2950 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v2950))) $ issueRequestToken_args_channelId record
  , (\_v2950 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v2950))) $ issueRequestToken_args_otpId record
  ]
write_IssueRequestToken_args :: T.Protocol p => p -> IssueRequestToken_args -> P.IO ()
write_IssueRequestToken_args oprot record = T.writeVal oprot $ from_IssueRequestToken_args record
encode_IssueRequestToken_args :: T.StatelessProtocol p => p -> IssueRequestToken_args -> LBS.ByteString
encode_IssueRequestToken_args oprot record = T.serializeVal oprot $ from_IssueRequestToken_args record
to_IssueRequestToken_args :: T.ThriftVal -> IssueRequestToken_args
to_IssueRequestToken_args (T.TStruct fields) = IssueRequestToken_args{
  issueRequestToken_args_channelId = P.maybe (issueRequestToken_args_channelId default_IssueRequestToken_args) (\(_,_val2952) -> (case _val2952 of {T.TString _val2953 -> E.decodeUtf8 _val2953; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  issueRequestToken_args_otpId = P.maybe (issueRequestToken_args_otpId default_IssueRequestToken_args) (\(_,_val2952) -> (case _val2952 of {T.TString _val2954 -> E.decodeUtf8 _val2954; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueRequestToken_args _ = P.error "not a struct"
read_IssueRequestToken_args :: T.Protocol p => p -> P.IO IssueRequestToken_args
read_IssueRequestToken_args iprot = to_IssueRequestToken_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestToken_args)
decode_IssueRequestToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestToken_args
decode_IssueRequestToken_args iprot bs = to_IssueRequestToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestToken_args) bs
typemap_IssueRequestToken_args :: T.TypeMap
typemap_IssueRequestToken_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING))]
default_IssueRequestToken_args :: IssueRequestToken_args
default_IssueRequestToken_args = IssueRequestToken_args{
  issueRequestToken_args_channelId = "",
  issueRequestToken_args_otpId = ""}
data IssueRequestToken_result = IssueRequestToken_result  { issueRequestToken_result_success :: LT.Text
  , issueRequestToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestToken_result_success record   `H.hashWithSalt` issueRequestToken_result_e record  
instance QC.Arbitrary IssueRequestToken_result where 
  arbitrary = M.liftM IssueRequestToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestToken_result{issueRequestToken_result_success = issueRequestToken_result_success obj} then P.Nothing else P.Just $ default_IssueRequestToken_result{issueRequestToken_result_success = issueRequestToken_result_success obj}
    , if obj == default_IssueRequestToken_result{issueRequestToken_result_e = issueRequestToken_result_e obj} then P.Nothing else P.Just $ default_IssueRequestToken_result{issueRequestToken_result_e = issueRequestToken_result_e obj}
    ]
from_IssueRequestToken_result :: IssueRequestToken_result -> T.ThriftVal
from_IssueRequestToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2957 -> (1, ("e",from_ChannelException _v2957))) <$> issueRequestToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2957 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2957))) $ issueRequestToken_result_success record
    , (\_v2957 -> (1, ("e",from_ChannelException _v2957))) <$> issueRequestToken_result_e record
    ]
    )
write_IssueRequestToken_result :: T.Protocol p => p -> IssueRequestToken_result -> P.IO ()
write_IssueRequestToken_result oprot record = T.writeVal oprot $ from_IssueRequestToken_result record
encode_IssueRequestToken_result :: T.StatelessProtocol p => p -> IssueRequestToken_result -> LBS.ByteString
encode_IssueRequestToken_result oprot record = T.serializeVal oprot $ from_IssueRequestToken_result record
to_IssueRequestToken_result :: T.ThriftVal -> IssueRequestToken_result
to_IssueRequestToken_result (T.TStruct fields) = IssueRequestToken_result{
  issueRequestToken_result_success = P.maybe (issueRequestToken_result_success default_IssueRequestToken_result) (\(_,_val2959) -> (case _val2959 of {T.TString _val2960 -> E.decodeUtf8 _val2960; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestToken_result_e = P.maybe (P.Nothing) (\(_,_val2959) -> P.Just (case _val2959 of {T.TStruct _val2961 -> (to_ChannelException (T.TStruct _val2961)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestToken_result _ = P.error "not a struct"
read_IssueRequestToken_result :: T.Protocol p => p -> P.IO IssueRequestToken_result
read_IssueRequestToken_result iprot = to_IssueRequestToken_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestToken_result)
decode_IssueRequestToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestToken_result
decode_IssueRequestToken_result iprot bs = to_IssueRequestToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestToken_result) bs
typemap_IssueRequestToken_result :: T.TypeMap
typemap_IssueRequestToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestToken_result :: IssueRequestToken_result
default_IssueRequestToken_result = IssueRequestToken_result{
  issueRequestToken_result_success = "",
  issueRequestToken_result_e = P.Nothing}
data IssueRequestTokenWithAuthScheme_args = IssueRequestTokenWithAuthScheme_args  { issueRequestTokenWithAuthScheme_args_channelId :: LT.Text
  , issueRequestTokenWithAuthScheme_args_otpId :: LT.Text
  , issueRequestTokenWithAuthScheme_args_authScheme :: (Vector.Vector LT.Text)
  , issueRequestTokenWithAuthScheme_args_returnUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenWithAuthScheme_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_channelId record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_otpId record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_authScheme record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_returnUrl record  
instance QC.Arbitrary IssueRequestTokenWithAuthScheme_args where 
  arbitrary = M.liftM IssueRequestTokenWithAuthScheme_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenWithAuthScheme_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_channelId = issueRequestTokenWithAuthScheme_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_channelId = issueRequestTokenWithAuthScheme_args_channelId obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_otpId = issueRequestTokenWithAuthScheme_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_otpId = issueRequestTokenWithAuthScheme_args_otpId obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_authScheme = issueRequestTokenWithAuthScheme_args_authScheme obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_authScheme = issueRequestTokenWithAuthScheme_args_authScheme obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_returnUrl = issueRequestTokenWithAuthScheme_args_returnUrl obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_returnUrl = issueRequestTokenWithAuthScheme_args_returnUrl obj}
    ]
from_IssueRequestTokenWithAuthScheme_args :: IssueRequestTokenWithAuthScheme_args -> T.ThriftVal
from_IssueRequestTokenWithAuthScheme_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2964 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v2964))) $ issueRequestTokenWithAuthScheme_args_channelId record
  , (\_v2964 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v2964))) $ issueRequestTokenWithAuthScheme_args_otpId record
  , (\_v2964 -> P.Just (3, ("authScheme",T.TList T.T_STRING $ P.map (\_v2966 -> T.TString $ E.encodeUtf8 _v2966) $ Vector.toList _v2964))) $ issueRequestTokenWithAuthScheme_args_authScheme record
  , (\_v2964 -> P.Just (4, ("returnUrl",T.TString $ E.encodeUtf8 _v2964))) $ issueRequestTokenWithAuthScheme_args_returnUrl record
  ]
write_IssueRequestTokenWithAuthScheme_args :: T.Protocol p => p -> IssueRequestTokenWithAuthScheme_args -> P.IO ()
write_IssueRequestTokenWithAuthScheme_args oprot record = T.writeVal oprot $ from_IssueRequestTokenWithAuthScheme_args record
encode_IssueRequestTokenWithAuthScheme_args :: T.StatelessProtocol p => p -> IssueRequestTokenWithAuthScheme_args -> LBS.ByteString
encode_IssueRequestTokenWithAuthScheme_args oprot record = T.serializeVal oprot $ from_IssueRequestTokenWithAuthScheme_args record
to_IssueRequestTokenWithAuthScheme_args :: T.ThriftVal -> IssueRequestTokenWithAuthScheme_args
to_IssueRequestTokenWithAuthScheme_args (T.TStruct fields) = IssueRequestTokenWithAuthScheme_args{
  issueRequestTokenWithAuthScheme_args_channelId = P.maybe (issueRequestTokenWithAuthScheme_args_channelId default_IssueRequestTokenWithAuthScheme_args) (\(_,_val2968) -> (case _val2968 of {T.TString _val2969 -> E.decodeUtf8 _val2969; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  issueRequestTokenWithAuthScheme_args_otpId = P.maybe (issueRequestTokenWithAuthScheme_args_otpId default_IssueRequestTokenWithAuthScheme_args) (\(_,_val2968) -> (case _val2968 of {T.TString _val2970 -> E.decodeUtf8 _val2970; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  issueRequestTokenWithAuthScheme_args_authScheme = P.maybe (issueRequestTokenWithAuthScheme_args_authScheme default_IssueRequestTokenWithAuthScheme_args) (\(_,_val2968) -> (case _val2968 of {T.TList _ _val2971 -> (Vector.fromList $ P.map (\_v2972 -> (case _v2972 of {T.TString _val2973 -> E.decodeUtf8 _val2973; _ -> P.error "wrong type"})) _val2971); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  issueRequestTokenWithAuthScheme_args_returnUrl = P.maybe (issueRequestTokenWithAuthScheme_args_returnUrl default_IssueRequestTokenWithAuthScheme_args) (\(_,_val2968) -> (case _val2968 of {T.TString _val2974 -> E.decodeUtf8 _val2974; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_IssueRequestTokenWithAuthScheme_args _ = P.error "not a struct"
read_IssueRequestTokenWithAuthScheme_args :: T.Protocol p => p -> P.IO IssueRequestTokenWithAuthScheme_args
read_IssueRequestTokenWithAuthScheme_args iprot = to_IssueRequestTokenWithAuthScheme_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_args)
decode_IssueRequestTokenWithAuthScheme_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenWithAuthScheme_args
decode_IssueRequestTokenWithAuthScheme_args iprot bs = to_IssueRequestTokenWithAuthScheme_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_args) bs
typemap_IssueRequestTokenWithAuthScheme_args :: T.TypeMap
typemap_IssueRequestTokenWithAuthScheme_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING)),(3,("authScheme",(T.T_LIST T.T_STRING))),(4,("returnUrl",T.T_STRING))]
default_IssueRequestTokenWithAuthScheme_args :: IssueRequestTokenWithAuthScheme_args
default_IssueRequestTokenWithAuthScheme_args = IssueRequestTokenWithAuthScheme_args{
  issueRequestTokenWithAuthScheme_args_channelId = "",
  issueRequestTokenWithAuthScheme_args_otpId = "",
  issueRequestTokenWithAuthScheme_args_authScheme = Vector.empty,
  issueRequestTokenWithAuthScheme_args_returnUrl = ""}
data IssueRequestTokenWithAuthScheme_result = IssueRequestTokenWithAuthScheme_result  { issueRequestTokenWithAuthScheme_result_success :: RequestTokenResponse
  , issueRequestTokenWithAuthScheme_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenWithAuthScheme_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenWithAuthScheme_result_success record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_result_e record  
instance QC.Arbitrary IssueRequestTokenWithAuthScheme_result where 
  arbitrary = M.liftM IssueRequestTokenWithAuthScheme_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenWithAuthScheme_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = issueRequestTokenWithAuthScheme_result_success obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = issueRequestTokenWithAuthScheme_result_success obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = issueRequestTokenWithAuthScheme_result_e obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = issueRequestTokenWithAuthScheme_result_e obj}
    ]
from_IssueRequestTokenWithAuthScheme_result :: IssueRequestTokenWithAuthScheme_result -> T.ThriftVal
from_IssueRequestTokenWithAuthScheme_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2977 -> (1, ("e",from_ChannelException _v2977))) <$> issueRequestTokenWithAuthScheme_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2977 -> P.Just (0, ("success",from_RequestTokenResponse _v2977))) $ issueRequestTokenWithAuthScheme_result_success record
    , (\_v2977 -> (1, ("e",from_ChannelException _v2977))) <$> issueRequestTokenWithAuthScheme_result_e record
    ]
    )
write_IssueRequestTokenWithAuthScheme_result :: T.Protocol p => p -> IssueRequestTokenWithAuthScheme_result -> P.IO ()
write_IssueRequestTokenWithAuthScheme_result oprot record = T.writeVal oprot $ from_IssueRequestTokenWithAuthScheme_result record
encode_IssueRequestTokenWithAuthScheme_result :: T.StatelessProtocol p => p -> IssueRequestTokenWithAuthScheme_result -> LBS.ByteString
encode_IssueRequestTokenWithAuthScheme_result oprot record = T.serializeVal oprot $ from_IssueRequestTokenWithAuthScheme_result record
to_IssueRequestTokenWithAuthScheme_result :: T.ThriftVal -> IssueRequestTokenWithAuthScheme_result
to_IssueRequestTokenWithAuthScheme_result (T.TStruct fields) = IssueRequestTokenWithAuthScheme_result{
  issueRequestTokenWithAuthScheme_result_success = P.maybe (issueRequestTokenWithAuthScheme_result_success default_IssueRequestTokenWithAuthScheme_result) (\(_,_val2979) -> (case _val2979 of {T.TStruct _val2980 -> (to_RequestTokenResponse (T.TStruct _val2980)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestTokenWithAuthScheme_result_e = P.maybe (P.Nothing) (\(_,_val2979) -> P.Just (case _val2979 of {T.TStruct _val2981 -> (to_ChannelException (T.TStruct _val2981)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestTokenWithAuthScheme_result _ = P.error "not a struct"
read_IssueRequestTokenWithAuthScheme_result :: T.Protocol p => p -> P.IO IssueRequestTokenWithAuthScheme_result
read_IssueRequestTokenWithAuthScheme_result iprot = to_IssueRequestTokenWithAuthScheme_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_result)
decode_IssueRequestTokenWithAuthScheme_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenWithAuthScheme_result
decode_IssueRequestTokenWithAuthScheme_result iprot bs = to_IssueRequestTokenWithAuthScheme_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_result) bs
typemap_IssueRequestTokenWithAuthScheme_result :: T.TypeMap
typemap_IssueRequestTokenWithAuthScheme_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RequestTokenResponse))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestTokenWithAuthScheme_result :: IssueRequestTokenWithAuthScheme_result
default_IssueRequestTokenWithAuthScheme_result = IssueRequestTokenWithAuthScheme_result{
  issueRequestTokenWithAuthScheme_result_success = default_RequestTokenResponse,
  issueRequestTokenWithAuthScheme_result_e = P.Nothing}
data ReserveCoinUse_args = ReserveCoinUse_args  { reserveCoinUse_args_request :: CoinUseReservation
  , reserveCoinUse_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinUse_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinUse_args_request record   `H.hashWithSalt` reserveCoinUse_args_locale record  
instance QC.Arbitrary ReserveCoinUse_args where 
  arbitrary = M.liftM ReserveCoinUse_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReserveCoinUse_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinUse_args{reserveCoinUse_args_request = reserveCoinUse_args_request obj} then P.Nothing else P.Just $ default_ReserveCoinUse_args{reserveCoinUse_args_request = reserveCoinUse_args_request obj}
    , if obj == default_ReserveCoinUse_args{reserveCoinUse_args_locale = reserveCoinUse_args_locale obj} then P.Nothing else P.Just $ default_ReserveCoinUse_args{reserveCoinUse_args_locale = reserveCoinUse_args_locale obj}
    ]
from_ReserveCoinUse_args :: ReserveCoinUse_args -> T.ThriftVal
from_ReserveCoinUse_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2984 -> P.Just (2, ("request",from_CoinUseReservation _v2984))) $ reserveCoinUse_args_request record
  , (\_v2984 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v2984))) $ reserveCoinUse_args_locale record
  ]
write_ReserveCoinUse_args :: T.Protocol p => p -> ReserveCoinUse_args -> P.IO ()
write_ReserveCoinUse_args oprot record = T.writeVal oprot $ from_ReserveCoinUse_args record
encode_ReserveCoinUse_args :: T.StatelessProtocol p => p -> ReserveCoinUse_args -> LBS.ByteString
encode_ReserveCoinUse_args oprot record = T.serializeVal oprot $ from_ReserveCoinUse_args record
to_ReserveCoinUse_args :: T.ThriftVal -> ReserveCoinUse_args
to_ReserveCoinUse_args (T.TStruct fields) = ReserveCoinUse_args{
  reserveCoinUse_args_request = P.maybe (reserveCoinUse_args_request default_ReserveCoinUse_args) (\(_,_val2986) -> (case _val2986 of {T.TStruct _val2987 -> (to_CoinUseReservation (T.TStruct _val2987)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reserveCoinUse_args_locale = P.maybe (reserveCoinUse_args_locale default_ReserveCoinUse_args) (\(_,_val2986) -> (case _val2986 of {T.TString _val2988 -> E.decodeUtf8 _val2988; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReserveCoinUse_args _ = P.error "not a struct"
read_ReserveCoinUse_args :: T.Protocol p => p -> P.IO ReserveCoinUse_args
read_ReserveCoinUse_args iprot = to_ReserveCoinUse_args <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinUse_args)
decode_ReserveCoinUse_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinUse_args
decode_ReserveCoinUse_args iprot bs = to_ReserveCoinUse_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinUse_args) bs
typemap_ReserveCoinUse_args :: T.TypeMap
typemap_ReserveCoinUse_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinUseReservation))),(3,("locale",T.T_STRING))]
default_ReserveCoinUse_args :: ReserveCoinUse_args
default_ReserveCoinUse_args = ReserveCoinUse_args{
  reserveCoinUse_args_request = default_CoinUseReservation,
  reserveCoinUse_args_locale = ""}
data ReserveCoinUse_result = ReserveCoinUse_result  { reserveCoinUse_result_success :: LT.Text
  , reserveCoinUse_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinUse_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinUse_result_success record   `H.hashWithSalt` reserveCoinUse_result_e record  
instance QC.Arbitrary ReserveCoinUse_result where 
  arbitrary = M.liftM ReserveCoinUse_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReserveCoinUse_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinUse_result{reserveCoinUse_result_success = reserveCoinUse_result_success obj} then P.Nothing else P.Just $ default_ReserveCoinUse_result{reserveCoinUse_result_success = reserveCoinUse_result_success obj}
    , if obj == default_ReserveCoinUse_result{reserveCoinUse_result_e = reserveCoinUse_result_e obj} then P.Nothing else P.Just $ default_ReserveCoinUse_result{reserveCoinUse_result_e = reserveCoinUse_result_e obj}
    ]
from_ReserveCoinUse_result :: ReserveCoinUse_result -> T.ThriftVal
from_ReserveCoinUse_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v2991 -> (1, ("e",from_ChannelException _v2991))) <$> reserveCoinUse_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v2991 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v2991))) $ reserveCoinUse_result_success record
    , (\_v2991 -> (1, ("e",from_ChannelException _v2991))) <$> reserveCoinUse_result_e record
    ]
    )
write_ReserveCoinUse_result :: T.Protocol p => p -> ReserveCoinUse_result -> P.IO ()
write_ReserveCoinUse_result oprot record = T.writeVal oprot $ from_ReserveCoinUse_result record
encode_ReserveCoinUse_result :: T.StatelessProtocol p => p -> ReserveCoinUse_result -> LBS.ByteString
encode_ReserveCoinUse_result oprot record = T.serializeVal oprot $ from_ReserveCoinUse_result record
to_ReserveCoinUse_result :: T.ThriftVal -> ReserveCoinUse_result
to_ReserveCoinUse_result (T.TStruct fields) = ReserveCoinUse_result{
  reserveCoinUse_result_success = P.maybe (reserveCoinUse_result_success default_ReserveCoinUse_result) (\(_,_val2993) -> (case _val2993 of {T.TString _val2994 -> E.decodeUtf8 _val2994; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reserveCoinUse_result_e = P.maybe (P.Nothing) (\(_,_val2993) -> P.Just (case _val2993 of {T.TStruct _val2995 -> (to_ChannelException (T.TStruct _val2995)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReserveCoinUse_result _ = P.error "not a struct"
read_ReserveCoinUse_result :: T.Protocol p => p -> P.IO ReserveCoinUse_result
read_ReserveCoinUse_result iprot = to_ReserveCoinUse_result <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinUse_result)
decode_ReserveCoinUse_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinUse_result
decode_ReserveCoinUse_result iprot bs = to_ReserveCoinUse_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinUse_result) bs
typemap_ReserveCoinUse_result :: T.TypeMap
typemap_ReserveCoinUse_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ReserveCoinUse_result :: ReserveCoinUse_result
default_ReserveCoinUse_result = ReserveCoinUse_result{
  reserveCoinUse_result_success = "",
  reserveCoinUse_result_e = P.Nothing}
data RevokeChannel_args = RevokeChannel_args  { revokeChannel_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeChannel_args_channelId record  
instance QC.Arbitrary RevokeChannel_args where 
  arbitrary = M.liftM RevokeChannel_args (QC.arbitrary)
  shrink obj | obj == default_RevokeChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeChannel_args{revokeChannel_args_channelId = revokeChannel_args_channelId obj} then P.Nothing else P.Just $ default_RevokeChannel_args{revokeChannel_args_channelId = revokeChannel_args_channelId obj}
    ]
from_RevokeChannel_args :: RevokeChannel_args -> T.ThriftVal
from_RevokeChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2998 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v2998))) $ revokeChannel_args_channelId record
  ]
write_RevokeChannel_args :: T.Protocol p => p -> RevokeChannel_args -> P.IO ()
write_RevokeChannel_args oprot record = T.writeVal oprot $ from_RevokeChannel_args record
encode_RevokeChannel_args :: T.StatelessProtocol p => p -> RevokeChannel_args -> LBS.ByteString
encode_RevokeChannel_args oprot record = T.serializeVal oprot $ from_RevokeChannel_args record
to_RevokeChannel_args :: T.ThriftVal -> RevokeChannel_args
to_RevokeChannel_args (T.TStruct fields) = RevokeChannel_args{
  revokeChannel_args_channelId = P.maybe (revokeChannel_args_channelId default_RevokeChannel_args) (\(_,_val3000) -> (case _val3000 of {T.TString _val3001 -> E.decodeUtf8 _val3001; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RevokeChannel_args _ = P.error "not a struct"
read_RevokeChannel_args :: T.Protocol p => p -> P.IO RevokeChannel_args
read_RevokeChannel_args iprot = to_RevokeChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_RevokeChannel_args)
decode_RevokeChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeChannel_args
decode_RevokeChannel_args iprot bs = to_RevokeChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeChannel_args) bs
typemap_RevokeChannel_args :: T.TypeMap
typemap_RevokeChannel_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_RevokeChannel_args :: RevokeChannel_args
default_RevokeChannel_args = RevokeChannel_args{
  revokeChannel_args_channelId = ""}
data RevokeChannel_result = RevokeChannel_result  { revokeChannel_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeChannel_result_e record  
instance QC.Arbitrary RevokeChannel_result where 
  arbitrary = M.liftM RevokeChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RevokeChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeChannel_result{revokeChannel_result_e = revokeChannel_result_e obj} then P.Nothing else P.Just $ default_RevokeChannel_result{revokeChannel_result_e = revokeChannel_result_e obj}
    ]
from_RevokeChannel_result :: RevokeChannel_result -> T.ThriftVal
from_RevokeChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3004 -> (1, ("e",from_ChannelException _v3004))) <$> revokeChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3004 -> (1, ("e",from_ChannelException _v3004))) <$> revokeChannel_result_e record
    ]
    )
write_RevokeChannel_result :: T.Protocol p => p -> RevokeChannel_result -> P.IO ()
write_RevokeChannel_result oprot record = T.writeVal oprot $ from_RevokeChannel_result record
encode_RevokeChannel_result :: T.StatelessProtocol p => p -> RevokeChannel_result -> LBS.ByteString
encode_RevokeChannel_result oprot record = T.serializeVal oprot $ from_RevokeChannel_result record
to_RevokeChannel_result :: T.ThriftVal -> RevokeChannel_result
to_RevokeChannel_result (T.TStruct fields) = RevokeChannel_result{
  revokeChannel_result_e = P.maybe (P.Nothing) (\(_,_val3006) -> P.Just (case _val3006 of {T.TStruct _val3007 -> (to_ChannelException (T.TStruct _val3007)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RevokeChannel_result _ = P.error "not a struct"
read_RevokeChannel_result :: T.Protocol p => p -> P.IO RevokeChannel_result
read_RevokeChannel_result iprot = to_RevokeChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_RevokeChannel_result)
decode_RevokeChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeChannel_result
decode_RevokeChannel_result iprot bs = to_RevokeChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeChannel_result) bs
typemap_RevokeChannel_result :: T.TypeMap
typemap_RevokeChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_RevokeChannel_result :: RevokeChannel_result
default_RevokeChannel_result = RevokeChannel_result{
  revokeChannel_result_e = P.Nothing}
data SyncChannelData_args = SyncChannelData_args  { syncChannelData_args_lastSynced :: I.Int64
  , syncChannelData_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChannelData_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChannelData_args_lastSynced record   `H.hashWithSalt` syncChannelData_args_locale record  
instance QC.Arbitrary SyncChannelData_args where 
  arbitrary = M.liftM SyncChannelData_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncChannelData_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChannelData_args{syncChannelData_args_lastSynced = syncChannelData_args_lastSynced obj} then P.Nothing else P.Just $ default_SyncChannelData_args{syncChannelData_args_lastSynced = syncChannelData_args_lastSynced obj}
    , if obj == default_SyncChannelData_args{syncChannelData_args_locale = syncChannelData_args_locale obj} then P.Nothing else P.Just $ default_SyncChannelData_args{syncChannelData_args_locale = syncChannelData_args_locale obj}
    ]
from_SyncChannelData_args :: SyncChannelData_args -> T.ThriftVal
from_SyncChannelData_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3010 -> P.Just (2, ("lastSynced",T.TI64 _v3010))) $ syncChannelData_args_lastSynced record
  , (\_v3010 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v3010))) $ syncChannelData_args_locale record
  ]
write_SyncChannelData_args :: T.Protocol p => p -> SyncChannelData_args -> P.IO ()
write_SyncChannelData_args oprot record = T.writeVal oprot $ from_SyncChannelData_args record
encode_SyncChannelData_args :: T.StatelessProtocol p => p -> SyncChannelData_args -> LBS.ByteString
encode_SyncChannelData_args oprot record = T.serializeVal oprot $ from_SyncChannelData_args record
to_SyncChannelData_args :: T.ThriftVal -> SyncChannelData_args
to_SyncChannelData_args (T.TStruct fields) = SyncChannelData_args{
  syncChannelData_args_lastSynced = P.maybe (syncChannelData_args_lastSynced default_SyncChannelData_args) (\(_,_val3012) -> (case _val3012 of {T.TI64 _val3013 -> _val3013; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncChannelData_args_locale = P.maybe (syncChannelData_args_locale default_SyncChannelData_args) (\(_,_val3012) -> (case _val3012 of {T.TString _val3014 -> E.decodeUtf8 _val3014; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SyncChannelData_args _ = P.error "not a struct"
read_SyncChannelData_args :: T.Protocol p => p -> P.IO SyncChannelData_args
read_SyncChannelData_args iprot = to_SyncChannelData_args <$> T.readVal iprot (T.T_STRUCT typemap_SyncChannelData_args)
decode_SyncChannelData_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChannelData_args
decode_SyncChannelData_args iprot bs = to_SyncChannelData_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChannelData_args) bs
typemap_SyncChannelData_args :: T.TypeMap
typemap_SyncChannelData_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_SyncChannelData_args :: SyncChannelData_args
default_SyncChannelData_args = SyncChannelData_args{
  syncChannelData_args_lastSynced = 0,
  syncChannelData_args_locale = ""}
data SyncChannelData_result = SyncChannelData_result  { syncChannelData_result_success :: ChannelSyncDatas
  , syncChannelData_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChannelData_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChannelData_result_success record   `H.hashWithSalt` syncChannelData_result_e record  
instance QC.Arbitrary SyncChannelData_result where 
  arbitrary = M.liftM SyncChannelData_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncChannelData_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChannelData_result{syncChannelData_result_success = syncChannelData_result_success obj} then P.Nothing else P.Just $ default_SyncChannelData_result{syncChannelData_result_success = syncChannelData_result_success obj}
    , if obj == default_SyncChannelData_result{syncChannelData_result_e = syncChannelData_result_e obj} then P.Nothing else P.Just $ default_SyncChannelData_result{syncChannelData_result_e = syncChannelData_result_e obj}
    ]
from_SyncChannelData_result :: SyncChannelData_result -> T.ThriftVal
from_SyncChannelData_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3017 -> (1, ("e",from_ChannelException _v3017))) <$> syncChannelData_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3017 -> P.Just (0, ("success",from_ChannelSyncDatas _v3017))) $ syncChannelData_result_success record
    , (\_v3017 -> (1, ("e",from_ChannelException _v3017))) <$> syncChannelData_result_e record
    ]
    )
write_SyncChannelData_result :: T.Protocol p => p -> SyncChannelData_result -> P.IO ()
write_SyncChannelData_result oprot record = T.writeVal oprot $ from_SyncChannelData_result record
encode_SyncChannelData_result :: T.StatelessProtocol p => p -> SyncChannelData_result -> LBS.ByteString
encode_SyncChannelData_result oprot record = T.serializeVal oprot $ from_SyncChannelData_result record
to_SyncChannelData_result :: T.ThriftVal -> SyncChannelData_result
to_SyncChannelData_result (T.TStruct fields) = SyncChannelData_result{
  syncChannelData_result_success = P.maybe (syncChannelData_result_success default_SyncChannelData_result) (\(_,_val3019) -> (case _val3019 of {T.TStruct _val3020 -> (to_ChannelSyncDatas (T.TStruct _val3020)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  syncChannelData_result_e = P.maybe (P.Nothing) (\(_,_val3019) -> P.Just (case _val3019 of {T.TStruct _val3021 -> (to_ChannelException (T.TStruct _val3021)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SyncChannelData_result _ = P.error "not a struct"
read_SyncChannelData_result :: T.Protocol p => p -> P.IO SyncChannelData_result
read_SyncChannelData_result iprot = to_SyncChannelData_result <$> T.readVal iprot (T.T_STRUCT typemap_SyncChannelData_result)
decode_SyncChannelData_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChannelData_result
decode_SyncChannelData_result iprot bs = to_SyncChannelData_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChannelData_result) bs
typemap_SyncChannelData_result :: T.TypeMap
typemap_SyncChannelData_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelSyncDatas))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_SyncChannelData_result :: SyncChannelData_result
default_SyncChannelData_result = SyncChannelData_result{
  syncChannelData_result_success = default_ChannelSyncDatas,
  syncChannelData_result_e = P.Nothing}
data UpdateChannelNotificationSetting_args = UpdateChannelNotificationSetting_args  { updateChannelNotificationSetting_args_setting :: (Vector.Vector ChannelNotificationSetting)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelNotificationSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelNotificationSetting_args_setting record  
instance QC.Arbitrary UpdateChannelNotificationSetting_args where 
  arbitrary = M.liftM UpdateChannelNotificationSetting_args (QC.arbitrary)
  shrink obj | obj == default_UpdateChannelNotificationSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelNotificationSetting_args{updateChannelNotificationSetting_args_setting = updateChannelNotificationSetting_args_setting obj} then P.Nothing else P.Just $ default_UpdateChannelNotificationSetting_args{updateChannelNotificationSetting_args_setting = updateChannelNotificationSetting_args_setting obj}
    ]
from_UpdateChannelNotificationSetting_args :: UpdateChannelNotificationSetting_args -> T.ThriftVal
from_UpdateChannelNotificationSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3024 -> P.Just (1, ("setting",T.TList (T.T_STRUCT typemap_ChannelNotificationSetting) $ P.map (\_v3026 -> from_ChannelNotificationSetting _v3026) $ Vector.toList _v3024))) $ updateChannelNotificationSetting_args_setting record
  ]
write_UpdateChannelNotificationSetting_args :: T.Protocol p => p -> UpdateChannelNotificationSetting_args -> P.IO ()
write_UpdateChannelNotificationSetting_args oprot record = T.writeVal oprot $ from_UpdateChannelNotificationSetting_args record
encode_UpdateChannelNotificationSetting_args :: T.StatelessProtocol p => p -> UpdateChannelNotificationSetting_args -> LBS.ByteString
encode_UpdateChannelNotificationSetting_args oprot record = T.serializeVal oprot $ from_UpdateChannelNotificationSetting_args record
to_UpdateChannelNotificationSetting_args :: T.ThriftVal -> UpdateChannelNotificationSetting_args
to_UpdateChannelNotificationSetting_args (T.TStruct fields) = UpdateChannelNotificationSetting_args{
  updateChannelNotificationSetting_args_setting = P.maybe (updateChannelNotificationSetting_args_setting default_UpdateChannelNotificationSetting_args) (\(_,_val3028) -> (case _val3028 of {T.TList _ _val3029 -> (Vector.fromList $ P.map (\_v3030 -> (case _v3030 of {T.TStruct _val3031 -> (to_ChannelNotificationSetting (T.TStruct _val3031)); _ -> P.error "wrong type"})) _val3029); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelNotificationSetting_args _ = P.error "not a struct"
read_UpdateChannelNotificationSetting_args :: T.Protocol p => p -> P.IO UpdateChannelNotificationSetting_args
read_UpdateChannelNotificationSetting_args iprot = to_UpdateChannelNotificationSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_args)
decode_UpdateChannelNotificationSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelNotificationSetting_args
decode_UpdateChannelNotificationSetting_args iprot bs = to_UpdateChannelNotificationSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_args) bs
typemap_UpdateChannelNotificationSetting_args :: T.TypeMap
typemap_UpdateChannelNotificationSetting_args = Map.fromList [(1,("setting",(T.T_LIST (T.T_STRUCT typemap_ChannelNotificationSetting))))]
default_UpdateChannelNotificationSetting_args :: UpdateChannelNotificationSetting_args
default_UpdateChannelNotificationSetting_args = UpdateChannelNotificationSetting_args{
  updateChannelNotificationSetting_args_setting = Vector.empty}
data UpdateChannelNotificationSetting_result = UpdateChannelNotificationSetting_result  { updateChannelNotificationSetting_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelNotificationSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelNotificationSetting_result_e record  
instance QC.Arbitrary UpdateChannelNotificationSetting_result where 
  arbitrary = M.liftM UpdateChannelNotificationSetting_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateChannelNotificationSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = updateChannelNotificationSetting_result_e obj} then P.Nothing else P.Just $ default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = updateChannelNotificationSetting_result_e obj}
    ]
from_UpdateChannelNotificationSetting_result :: UpdateChannelNotificationSetting_result -> T.ThriftVal
from_UpdateChannelNotificationSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3034 -> (1, ("e",from_ChannelException _v3034))) <$> updateChannelNotificationSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3034 -> (1, ("e",from_ChannelException _v3034))) <$> updateChannelNotificationSetting_result_e record
    ]
    )
write_UpdateChannelNotificationSetting_result :: T.Protocol p => p -> UpdateChannelNotificationSetting_result -> P.IO ()
write_UpdateChannelNotificationSetting_result oprot record = T.writeVal oprot $ from_UpdateChannelNotificationSetting_result record
encode_UpdateChannelNotificationSetting_result :: T.StatelessProtocol p => p -> UpdateChannelNotificationSetting_result -> LBS.ByteString
encode_UpdateChannelNotificationSetting_result oprot record = T.serializeVal oprot $ from_UpdateChannelNotificationSetting_result record
to_UpdateChannelNotificationSetting_result :: T.ThriftVal -> UpdateChannelNotificationSetting_result
to_UpdateChannelNotificationSetting_result (T.TStruct fields) = UpdateChannelNotificationSetting_result{
  updateChannelNotificationSetting_result_e = P.maybe (P.Nothing) (\(_,_val3036) -> P.Just (case _val3036 of {T.TStruct _val3037 -> (to_ChannelException (T.TStruct _val3037)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelNotificationSetting_result _ = P.error "not a struct"
read_UpdateChannelNotificationSetting_result :: T.Protocol p => p -> P.IO UpdateChannelNotificationSetting_result
read_UpdateChannelNotificationSetting_result iprot = to_UpdateChannelNotificationSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_result)
decode_UpdateChannelNotificationSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelNotificationSetting_result
decode_UpdateChannelNotificationSetting_result iprot bs = to_UpdateChannelNotificationSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_result) bs
typemap_UpdateChannelNotificationSetting_result :: T.TypeMap
typemap_UpdateChannelNotificationSetting_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_UpdateChannelNotificationSetting_result :: UpdateChannelNotificationSetting_result
default_UpdateChannelNotificationSetting_result = UpdateChannelNotificationSetting_result{
  updateChannelNotificationSetting_result_e = P.Nothing}
process_approveChannelAndIssueChannelToken (seqid, iprot, oprot, handler) = do
  args <- read_ApproveChannelAndIssueChannelToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.approveChannelAndIssueChannelToken handler (approveChannelAndIssueChannelToken_args_channelId args)
        let res = default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = val}
        T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueChannelToken_result oprot res)
      (\e  -> do
        let res = default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = P.Just e}
        T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueChannelToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_approveChannelAndIssueRequestToken (seqid, iprot, oprot, handler) = do
  args <- read_ApproveChannelAndIssueRequestToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.approveChannelAndIssueRequestToken handler (approveChannelAndIssueRequestToken_args_channelId args) (approveChannelAndIssueRequestToken_args_otpId args)
        let res = default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = val}
        T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueRequestToken_result oprot res)
      (\e  -> do
        let res = default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = P.Just e}
        T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueRequestToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchNotificationItems (seqid, iprot, oprot, handler) = do
  args <- read_FetchNotificationItems_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchNotificationItems handler (fetchNotificationItems_args_localRev args)
        let res = default_FetchNotificationItems_result{fetchNotificationItems_result_success = val}
        T.writeMessage oprot ("fetchNotificationItems", T.M_REPLY, seqid) $
          write_FetchNotificationItems_result oprot res)
      (\e  -> do
        let res = default_FetchNotificationItems_result{fetchNotificationItems_result_e = P.Just e}
        T.writeMessage oprot ("fetchNotificationItems", T.M_REPLY, seqid) $
          write_FetchNotificationItems_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchNotificationItems", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getApprovedChannels (seqid, iprot, oprot, handler) = do
  args <- read_GetApprovedChannels_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getApprovedChannels handler (getApprovedChannels_args_lastSynced args) (getApprovedChannels_args_locale args)
        let res = default_GetApprovedChannels_result{getApprovedChannels_result_success = val}
        T.writeMessage oprot ("getApprovedChannels", T.M_REPLY, seqid) $
          write_GetApprovedChannels_result oprot res)
      (\e  -> do
        let res = default_GetApprovedChannels_result{getApprovedChannels_result_e = P.Just e}
        T.writeMessage oprot ("getApprovedChannels", T.M_REPLY, seqid) $
          write_GetApprovedChannels_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getApprovedChannels", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelInfo_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelInfo handler (getChannelInfo_args_channelId args) (getChannelInfo_args_locale args)
        let res = default_GetChannelInfo_result{getChannelInfo_result_success = val}
        T.writeMessage oprot ("getChannelInfo", T.M_REPLY, seqid) $
          write_GetChannelInfo_result oprot res)
      (\e  -> do
        let res = default_GetChannelInfo_result{getChannelInfo_result_e = P.Just e}
        T.writeMessage oprot ("getChannelInfo", T.M_REPLY, seqid) $
          write_GetChannelInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelNotificationSetting (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelNotificationSetting_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelNotificationSetting handler (getChannelNotificationSetting_args_channelId args) (getChannelNotificationSetting_args_locale args)
        let res = default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = val}
        T.writeMessage oprot ("getChannelNotificationSetting", T.M_REPLY, seqid) $
          write_GetChannelNotificationSetting_result oprot res)
      (\e  -> do
        let res = default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = P.Just e}
        T.writeMessage oprot ("getChannelNotificationSetting", T.M_REPLY, seqid) $
          write_GetChannelNotificationSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelNotificationSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelNotificationSettings (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelNotificationSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelNotificationSettings handler (getChannelNotificationSettings_args_locale args)
        let res = default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = val}
        T.writeMessage oprot ("getChannelNotificationSettings", T.M_REPLY, seqid) $
          write_GetChannelNotificationSettings_result oprot res)
      (\e  -> do
        let res = default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = P.Just e}
        T.writeMessage oprot ("getChannelNotificationSettings", T.M_REPLY, seqid) $
          write_GetChannelNotificationSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelNotificationSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannels (seqid, iprot, oprot, handler) = do
  args <- read_GetChannels_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannels handler (getChannels_args_lastSynced args) (getChannels_args_locale args)
        let res = default_GetChannels_result{getChannels_result_success = val}
        T.writeMessage oprot ("getChannels", T.M_REPLY, seqid) $
          write_GetChannels_result oprot res)
      (\e  -> do
        let res = default_GetChannels_result{getChannels_result_e = P.Just e}
        T.writeMessage oprot ("getChannels", T.M_REPLY, seqid) $
          write_GetChannels_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannels", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDomains (seqid, iprot, oprot, handler) = do
  args <- read_GetDomains_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDomains handler (getDomains_args_lastSynced args)
        let res = default_GetDomains_result{getDomains_result_success = val}
        T.writeMessage oprot ("getDomains", T.M_REPLY, seqid) $
          write_GetDomains_result oprot res)
      (\e  -> do
        let res = default_GetDomains_result{getDomains_result_e = P.Just e}
        T.writeMessage oprot ("getDomains", T.M_REPLY, seqid) $
          write_GetDomains_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDomains", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendChannelMatrices (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendChannelMatrices_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendChannelMatrices handler (getFriendChannelMatrices_args_channelIds args)
        let res = default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = val}
        T.writeMessage oprot ("getFriendChannelMatrices", T.M_REPLY, seqid) $
          write_GetFriendChannelMatrices_result oprot res)
      (\e  -> do
        let res = default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = P.Just e}
        T.writeMessage oprot ("getFriendChannelMatrices", T.M_REPLY, seqid) $
          write_GetFriendChannelMatrices_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendChannelMatrices", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNotificationBadgeCount (seqid, iprot, oprot, handler) = do
  args <- read_GetNotificationBadgeCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNotificationBadgeCount handler (getNotificationBadgeCount_args_localRev args)
        let res = default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = val}
        T.writeMessage oprot ("getNotificationBadgeCount", T.M_REPLY, seqid) $
          write_GetNotificationBadgeCount_result oprot res)
      (\e  -> do
        let res = default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = P.Just e}
        T.writeMessage oprot ("getNotificationBadgeCount", T.M_REPLY, seqid) $
          write_GetNotificationBadgeCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNotificationBadgeCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueChannelToken (seqid, iprot, oprot, handler) = do
  args <- read_IssueChannelToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueChannelToken handler (issueChannelToken_args_channelId args)
        let res = default_IssueChannelToken_result{issueChannelToken_result_success = val}
        T.writeMessage oprot ("issueChannelToken", T.M_REPLY, seqid) $
          write_IssueChannelToken_result oprot res)
      (\e  -> do
        let res = default_IssueChannelToken_result{issueChannelToken_result_e = P.Just e}
        T.writeMessage oprot ("issueChannelToken", T.M_REPLY, seqid) $
          write_IssueChannelToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueChannelToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestToken (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestToken handler (issueRequestToken_args_channelId args) (issueRequestToken_args_otpId args)
        let res = default_IssueRequestToken_result{issueRequestToken_result_success = val}
        T.writeMessage oprot ("issueRequestToken", T.M_REPLY, seqid) $
          write_IssueRequestToken_result oprot res)
      (\e  -> do
        let res = default_IssueRequestToken_result{issueRequestToken_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestToken", T.M_REPLY, seqid) $
          write_IssueRequestToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestTokenWithAuthScheme (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestTokenWithAuthScheme_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestTokenWithAuthScheme handler (issueRequestTokenWithAuthScheme_args_channelId args) (issueRequestTokenWithAuthScheme_args_otpId args) (issueRequestTokenWithAuthScheme_args_authScheme args) (issueRequestTokenWithAuthScheme_args_returnUrl args)
        let res = default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = val}
        T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_REPLY, seqid) $
          write_IssueRequestTokenWithAuthScheme_result oprot res)
      (\e  -> do
        let res = default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_REPLY, seqid) $
          write_IssueRequestTokenWithAuthScheme_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reserveCoinUse (seqid, iprot, oprot, handler) = do
  args <- read_ReserveCoinUse_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reserveCoinUse handler (reserveCoinUse_args_request args) (reserveCoinUse_args_locale args)
        let res = default_ReserveCoinUse_result{reserveCoinUse_result_success = val}
        T.writeMessage oprot ("reserveCoinUse", T.M_REPLY, seqid) $
          write_ReserveCoinUse_result oprot res)
      (\e  -> do
        let res = default_ReserveCoinUse_result{reserveCoinUse_result_e = P.Just e}
        T.writeMessage oprot ("reserveCoinUse", T.M_REPLY, seqid) $
          write_ReserveCoinUse_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reserveCoinUse", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_revokeChannel (seqid, iprot, oprot, handler) = do
  args <- read_RevokeChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.revokeChannel handler (revokeChannel_args_channelId args)
        let res = default_RevokeChannel_result
        T.writeMessage oprot ("revokeChannel", T.M_REPLY, seqid) $
          write_RevokeChannel_result oprot res)
      (\e  -> do
        let res = default_RevokeChannel_result{revokeChannel_result_e = P.Just e}
        T.writeMessage oprot ("revokeChannel", T.M_REPLY, seqid) $
          write_RevokeChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("revokeChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_syncChannelData (seqid, iprot, oprot, handler) = do
  args <- read_SyncChannelData_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.syncChannelData handler (syncChannelData_args_lastSynced args) (syncChannelData_args_locale args)
        let res = default_SyncChannelData_result{syncChannelData_result_success = val}
        T.writeMessage oprot ("syncChannelData", T.M_REPLY, seqid) $
          write_SyncChannelData_result oprot res)
      (\e  -> do
        let res = default_SyncChannelData_result{syncChannelData_result_e = P.Just e}
        T.writeMessage oprot ("syncChannelData", T.M_REPLY, seqid) $
          write_SyncChannelData_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("syncChannelData", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateChannelNotificationSetting (seqid, iprot, oprot, handler) = do
  args <- read_UpdateChannelNotificationSetting_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateChannelNotificationSetting handler (updateChannelNotificationSetting_args_setting args)
        let res = default_UpdateChannelNotificationSetting_result
        T.writeMessage oprot ("updateChannelNotificationSetting", T.M_REPLY, seqid) $
          write_UpdateChannelNotificationSetting_result oprot res)
      (\e  -> do
        let res = default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = P.Just e}
        T.writeMessage oprot ("updateChannelNotificationSetting", T.M_REPLY, seqid) $
          write_UpdateChannelNotificationSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateChannelNotificationSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "approveChannelAndIssueChannelToken" -> process_approveChannelAndIssueChannelToken (seqid,iprot,oprot,handler)
  "approveChannelAndIssueRequestToken" -> process_approveChannelAndIssueRequestToken (seqid,iprot,oprot,handler)
  "fetchNotificationItems" -> process_fetchNotificationItems (seqid,iprot,oprot,handler)
  "getApprovedChannels" -> process_getApprovedChannels (seqid,iprot,oprot,handler)
  "getChannelInfo" -> process_getChannelInfo (seqid,iprot,oprot,handler)
  "getChannelNotificationSetting" -> process_getChannelNotificationSetting (seqid,iprot,oprot,handler)
  "getChannelNotificationSettings" -> process_getChannelNotificationSettings (seqid,iprot,oprot,handler)
  "getChannels" -> process_getChannels (seqid,iprot,oprot,handler)
  "getDomains" -> process_getDomains (seqid,iprot,oprot,handler)
  "getFriendChannelMatrices" -> process_getFriendChannelMatrices (seqid,iprot,oprot,handler)
  "getNotificationBadgeCount" -> process_getNotificationBadgeCount (seqid,iprot,oprot,handler)
  "issueChannelToken" -> process_issueChannelToken (seqid,iprot,oprot,handler)
  "issueRequestToken" -> process_issueRequestToken (seqid,iprot,oprot,handler)
  "issueRequestTokenWithAuthScheme" -> process_issueRequestTokenWithAuthScheme (seqid,iprot,oprot,handler)
  "reserveCoinUse" -> process_reserveCoinUse (seqid,iprot,oprot,handler)
  "revokeChannel" -> process_revokeChannel (seqid,iprot,oprot,handler)
  "syncChannelData" -> process_syncChannelData (seqid,iprot,oprot,handler)
  "updateChannelNotificationSetting" -> process_updateChannelNotificationSetting (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
