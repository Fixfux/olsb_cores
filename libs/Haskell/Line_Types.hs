{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Line_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data ApplicationType = IOS|IOS_RC|IOS_BETA|IOS_ALPHA|ANDROID|ANDROID_RC|ANDROID_BETA|ANDROID_ALPHA|WAP|WAP_RC|WAP_BETA|WAP_ALPHA|BOT|BOT_RC|BOT_BETA|BOT_ALPHA|WEB|WEB_RC|WEB_BETA|WEB_ALPHA|DESKTOPWIN|DESKTOPWIN_RC|DESKTOPWIN_BETA|DESKTOPWIN_ALPHA|DESKTOPMAC|DESKTOPMAC_RC|DESKTOPMAC_BETA|DESKTOPMAC_ALPHA|CHANNELGW|CHANNELGW_RC|CHANNELGW_BETA|CHANNELGW_ALPHA|CHANNELCP|CHANNELCP_RC|CHANNELCP_BETA|CHANNELCP_ALPHA|WINPHONE|WINPHONE_RC|WINPHONE_BETA|WINPHONE_ALPHA|BLACKBERRY|BLACKBERRY_RC|BLACKBERRY_BETA|BLACKBERRY_ALPHA|WINMETRO|WINMETRO_RC|WINMETRO_BETA|WINMETRO_ALPHA|S40|S40_RC|S40_BETA|S40_ALPHA|CHRONO|CHRONO_RC|CHRONO_BETA|CHRONO_ALPHA|TIZEN|TIZEN_RC|TIZEN_BETA|TIZEN_ALPHA|VIRTUAL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ApplicationType where
  fromEnum t = case t of
    IOS -> 16
    IOS_RC -> 17
    IOS_BETA -> 18
    IOS_ALPHA -> 19
    ANDROID -> 32
    ANDROID_RC -> 33
    ANDROID_BETA -> 34
    ANDROID_ALPHA -> 35
    WAP -> 48
    WAP_RC -> 49
    WAP_BETA -> 50
    WAP_ALPHA -> 51
    BOT -> 64
    BOT_RC -> 65
    BOT_BETA -> 66
    BOT_ALPHA -> 67
    WEB -> 80
    WEB_RC -> 81
    WEB_BETA -> 82
    WEB_ALPHA -> 83
    DESKTOPWIN -> 96
    DESKTOPWIN_RC -> 97
    DESKTOPWIN_BETA -> 98
    DESKTOPWIN_ALPHA -> 99
    DESKTOPMAC -> 112
    DESKTOPMAC_RC -> 113
    DESKTOPMAC_BETA -> 114
    DESKTOPMAC_ALPHA -> 115
    CHANNELGW -> 128
    CHANNELGW_RC -> 129
    CHANNELGW_BETA -> 130
    CHANNELGW_ALPHA -> 131
    CHANNELCP -> 144
    CHANNELCP_RC -> 145
    CHANNELCP_BETA -> 146
    CHANNELCP_ALPHA -> 147
    WINPHONE -> 160
    WINPHONE_RC -> 161
    WINPHONE_BETA -> 162
    WINPHONE_ALPHA -> 163
    BLACKBERRY -> 176
    BLACKBERRY_RC -> 177
    BLACKBERRY_BETA -> 178
    BLACKBERRY_ALPHA -> 179
    WINMETRO -> 192
    WINMETRO_RC -> 193
    WINMETRO_BETA -> 194
    WINMETRO_ALPHA -> 195
    S40 -> 208
    S40_RC -> 209
    S40_BETA -> 210
    S40_ALPHA -> 211
    CHRONO -> 224
    CHRONO_RC -> 225
    CHRONO_BETA -> 226
    CHRONO_ALPHA -> 227
    TIZEN -> 256
    TIZEN_RC -> 257
    TIZEN_BETA -> 258
    TIZEN_ALPHA -> 259
    VIRTUAL -> 272
  toEnum t = case t of
    16 -> IOS
    17 -> IOS_RC
    18 -> IOS_BETA
    19 -> IOS_ALPHA
    32 -> ANDROID
    33 -> ANDROID_RC
    34 -> ANDROID_BETA
    35 -> ANDROID_ALPHA
    48 -> WAP
    49 -> WAP_RC
    50 -> WAP_BETA
    51 -> WAP_ALPHA
    64 -> BOT
    65 -> BOT_RC
    66 -> BOT_BETA
    67 -> BOT_ALPHA
    80 -> WEB
    81 -> WEB_RC
    82 -> WEB_BETA
    83 -> WEB_ALPHA
    96 -> DESKTOPWIN
    97 -> DESKTOPWIN_RC
    98 -> DESKTOPWIN_BETA
    99 -> DESKTOPWIN_ALPHA
    112 -> DESKTOPMAC
    113 -> DESKTOPMAC_RC
    114 -> DESKTOPMAC_BETA
    115 -> DESKTOPMAC_ALPHA
    128 -> CHANNELGW
    129 -> CHANNELGW_RC
    130 -> CHANNELGW_BETA
    131 -> CHANNELGW_ALPHA
    144 -> CHANNELCP
    145 -> CHANNELCP_RC
    146 -> CHANNELCP_BETA
    147 -> CHANNELCP_ALPHA
    160 -> WINPHONE
    161 -> WINPHONE_RC
    162 -> WINPHONE_BETA
    163 -> WINPHONE_ALPHA
    176 -> BLACKBERRY
    177 -> BLACKBERRY_RC
    178 -> BLACKBERRY_BETA
    179 -> BLACKBERRY_ALPHA
    192 -> WINMETRO
    193 -> WINMETRO_RC
    194 -> WINMETRO_BETA
    195 -> WINMETRO_ALPHA
    208 -> S40
    209 -> S40_RC
    210 -> S40_BETA
    211 -> S40_ALPHA
    224 -> CHRONO
    225 -> CHRONO_RC
    226 -> CHRONO_BETA
    227 -> CHRONO_ALPHA
    256 -> TIZEN
    257 -> TIZEN_RC
    258 -> TIZEN_BETA
    259 -> TIZEN_ALPHA
    272 -> VIRTUAL
    _ -> X.throw T.ThriftException
instance H.Hashable ApplicationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ApplicationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddyBannerLinkType = BUDDY_BANNER_LINK_HIDDEN|BUDDY_BANNER_LINK_MID|BUDDY_BANNER_LINK_URL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddyBannerLinkType where
  fromEnum t = case t of
    BUDDY_BANNER_LINK_HIDDEN -> 0
    BUDDY_BANNER_LINK_MID -> 1
    BUDDY_BANNER_LINK_URL -> 2
  toEnum t = case t of
    0 -> BUDDY_BANNER_LINK_HIDDEN
    1 -> BUDDY_BANNER_LINK_MID
    2 -> BUDDY_BANNER_LINK_URL
    _ -> X.throw T.ThriftException
instance H.Hashable BuddyBannerLinkType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddyBannerLinkType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddyOnAirType = NORMAL|LIVE|VOIP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddyOnAirType where
  fromEnum t = case t of
    NORMAL -> 0
    LIVE -> 1
    VOIP -> 2
  toEnum t = case t of
    0 -> NORMAL
    1 -> LIVE
    2 -> VOIP
    _ -> X.throw T.ThriftException
instance H.Hashable BuddyOnAirType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddyOnAirType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddyResultState = ACCEPTED|SUCCEEDED|FAILED|CANCELLED|NOTIFY_FAILED|STORING|UPLOADING|NOTIFYING  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddyResultState where
  fromEnum t = case t of
    ACCEPTED -> 1
    SUCCEEDED -> 2
    FAILED -> 3
    CANCELLED -> 4
    NOTIFY_FAILED -> 5
    STORING -> 11
    UPLOADING -> 21
    NOTIFYING -> 31
  toEnum t = case t of
    1 -> ACCEPTED
    2 -> SUCCEEDED
    3 -> FAILED
    4 -> CANCELLED
    5 -> NOTIFY_FAILED
    11 -> STORING
    21 -> UPLOADING
    31 -> NOTIFYING
    _ -> X.throw T.ThriftException
instance H.Hashable BuddyResultState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddyResultState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddySearchRequestSource = NA|FRIEND_VIEW|OFFICIAL_ACCOUNT_VIEW  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddySearchRequestSource where
  fromEnum t = case t of
    NA -> 0
    FRIEND_VIEW -> 1
    OFFICIAL_ACCOUNT_VIEW -> 2
  toEnum t = case t of
    0 -> NA
    1 -> FRIEND_VIEW
    2 -> OFFICIAL_ACCOUNT_VIEW
    _ -> X.throw T.ThriftException
instance H.Hashable BuddySearchRequestSource where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddySearchRequestSource where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data CarrierCode = NOT_SPECIFIED|JP_DOCOMO|JP_AU|JP_SOFTBANK|KR_SKT|KR_KT|KR_LGT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum CarrierCode where
  fromEnum t = case t of
    NOT_SPECIFIED -> 0
    JP_DOCOMO -> 1
    JP_AU -> 2
    JP_SOFTBANK -> 3
    KR_SKT -> 17
    KR_KT -> 18
    KR_LGT -> 19
  toEnum t = case t of
    0 -> NOT_SPECIFIED
    1 -> JP_DOCOMO
    2 -> JP_AU
    3 -> JP_SOFTBANK
    17 -> KR_SKT
    18 -> KR_KT
    19 -> KR_LGT
    _ -> X.throw T.ThriftException
instance H.Hashable CarrierCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary CarrierCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelConfiguration = MESSAGE|MESSAGE_NOTIFICATION|NOTIFICATION_CENTER  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelConfiguration where
  fromEnum t = case t of
    MESSAGE -> 0
    MESSAGE_NOTIFICATION -> 1
    NOTIFICATION_CENTER -> 2
  toEnum t = case t of
    0 -> MESSAGE
    1 -> MESSAGE_NOTIFICATION
    2 -> NOTIFICATION_CENTER
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelConfiguration where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelConfiguration where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelErrorCode = ILLEGAL_ARGUMENT|INTERNAL_ERROR|CONNECTION_ERROR|AUTHENTICATIONI_FAILED|NEED_PERMISSION_APPROVAL|COIN_NOT_USABLE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelErrorCode where
  fromEnum t = case t of
    ILLEGAL_ARGUMENT -> 0
    INTERNAL_ERROR -> 1
    CONNECTION_ERROR -> 2
    AUTHENTICATIONI_FAILED -> 3
    NEED_PERMISSION_APPROVAL -> 4
    COIN_NOT_USABLE -> 5
  toEnum t = case t of
    0 -> ILLEGAL_ARGUMENT
    1 -> INTERNAL_ERROR
    2 -> CONNECTION_ERROR
    3 -> AUTHENTICATIONI_FAILED
    4 -> NEED_PERMISSION_APPROVAL
    5 -> COIN_NOT_USABLE
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelSyncType = SYNC|REMOVE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelSyncType where
  fromEnum t = case t of
    SYNC -> 0
    REMOVE -> 1
  toEnum t = case t of
    0 -> SYNC
    1 -> REMOVE
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelSyncType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelSyncType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactAttribute = CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL|CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL|CONTACT_ATTRIBUTE_CAPABLE_MY_HOME|CONTACT_ATTRIBUTE_CAPABLE_BUDDY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactAttribute where
  fromEnum t = case t of
    CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL -> 1
    CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL -> 2
    CONTACT_ATTRIBUTE_CAPABLE_MY_HOME -> 16
    CONTACT_ATTRIBUTE_CAPABLE_BUDDY -> 32
  toEnum t = case t of
    1 -> CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL
    2 -> CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL
    16 -> CONTACT_ATTRIBUTE_CAPABLE_MY_HOME
    32 -> CONTACT_ATTRIBUTE_CAPABLE_BUDDY
    _ -> X.throw T.ThriftException
instance H.Hashable ContactAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactCategory = NORMAL|RECOMMEND  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactCategory where
  fromEnum t = case t of
    NORMAL -> 0
    RECOMMEND -> 1
  toEnum t = case t of
    0 -> NORMAL
    1 -> RECOMMEND
    _ -> X.throw T.ThriftException
instance H.Hashable ContactCategory where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactCategory where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactRelation = ONEWAY|BOTH|NOT_REGISTERED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactRelation where
  fromEnum t = case t of
    ONEWAY -> 0
    BOTH -> 1
    NOT_REGISTERED -> 2
  toEnum t = case t of
    0 -> ONEWAY
    1 -> BOTH
    2 -> NOT_REGISTERED
    _ -> X.throw T.ThriftException
instance H.Hashable ContactRelation where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactRelation where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactSetting = CONTACT_SETTING_NOTIFICATION_DISABLE|CONTACT_SETTING_DISPLAY_NAME_OVERRIDE|CONTACT_SETTING_CONTACT_HIDE|CONTACT_SETTING_FAVORITE|CONTACT_SETTING_DELETE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactSetting where
  fromEnum t = case t of
    CONTACT_SETTING_NOTIFICATION_DISABLE -> 1
    CONTACT_SETTING_DISPLAY_NAME_OVERRIDE -> 2
    CONTACT_SETTING_CONTACT_HIDE -> 4
    CONTACT_SETTING_FAVORITE -> 8
    CONTACT_SETTING_DELETE -> 16
  toEnum t = case t of
    1 -> CONTACT_SETTING_NOTIFICATION_DISABLE
    2 -> CONTACT_SETTING_DISPLAY_NAME_OVERRIDE
    4 -> CONTACT_SETTING_CONTACT_HIDE
    8 -> CONTACT_SETTING_FAVORITE
    16 -> CONTACT_SETTING_DELETE
    _ -> X.throw T.ThriftException
instance H.Hashable ContactSetting where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactSetting where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactStatus = UNSPECIFIED|FRIEND|FRIEND_BLOCKED|RECOMMEND|RECOMMEND_BLOCKED|DELETED|DELETED_BLOCKED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactStatus where
  fromEnum t = case t of
    UNSPECIFIED -> 0
    FRIEND -> 1
    FRIEND_BLOCKED -> 2
    RECOMMEND -> 3
    RECOMMEND_BLOCKED -> 4
    DELETED -> 5
    DELETED_BLOCKED -> 6
  toEnum t = case t of
    0 -> UNSPECIFIED
    1 -> FRIEND
    2 -> FRIEND_BLOCKED
    3 -> RECOMMEND
    4 -> RECOMMEND_BLOCKED
    5 -> DELETED
    6 -> DELETED_BLOCKED
    _ -> X.throw T.ThriftException
instance H.Hashable ContactStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactType = MID|PHONE|EMAIL|USERID|PROXIMITY|GROUP|USER|QRCODE|PROMOTION_BOT|REPAIR|FACEBOOK|SINA|RENREN|FEIXIN  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactType where
  fromEnum t = case t of
    MID -> 0
    PHONE -> 1
    EMAIL -> 2
    USERID -> 3
    PROXIMITY -> 4
    GROUP -> 5
    USER -> 6
    QRCODE -> 7
    PROMOTION_BOT -> 8
    REPAIR -> 128
    FACEBOOK -> 2305
    SINA -> 2306
    RENREN -> 2307
    FEIXIN -> 2308
  toEnum t = case t of
    0 -> MID
    1 -> PHONE
    2 -> EMAIL
    3 -> USERID
    4 -> PROXIMITY
    5 -> GROUP
    6 -> USER
    7 -> QRCODE
    8 -> PROMOTION_BOT
    128 -> REPAIR
    2305 -> FACEBOOK
    2306 -> SINA
    2307 -> RENREN
    2308 -> FEIXIN
    _ -> X.throw T.ThriftException
instance H.Hashable ContactType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContentType = NONE|IMAGE|VIDEO|AUDIO|HTML|PDF|CALL|STICKER|PRESENCE|GIFT|GROUPBOARD|APPLINK|LINK|CONTACT|FILE|LOCATION|POSTNOTIFICATION|RICH|CHATEVENT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContentType where
  fromEnum t = case t of
    NONE -> 0
    IMAGE -> 1
    VIDEO -> 2
    AUDIO -> 3
    HTML -> 4
    PDF -> 5
    CALL -> 6
    STICKER -> 7
    PRESENCE -> 8
    GIFT -> 9
    GROUPBOARD -> 10
    APPLINK -> 11
    LINK -> 12
    CONTACT -> 13
    FILE -> 14
    LOCATION -> 15
    POSTNOTIFICATION -> 16
    RICH -> 17
    CHATEVENT -> 18
  toEnum t = case t of
    0 -> NONE
    1 -> IMAGE
    2 -> VIDEO
    3 -> AUDIO
    4 -> HTML
    5 -> PDF
    6 -> CALL
    7 -> STICKER
    8 -> PRESENCE
    9 -> GIFT
    10 -> GROUPBOARD
    11 -> APPLINK
    12 -> LINK
    13 -> CONTACT
    14 -> FILE
    15 -> LOCATION
    16 -> POSTNOTIFICATION
    17 -> RICH
    18 -> CHATEVENT
    _ -> X.throw T.ThriftException
instance H.Hashable ContentType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContentType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data CustomMode = PROMOTION_FRIENDS_INVITE|CAPABILITY_SERVER_SIDE_SMS|LINE_CLIENT_ANALYTICS_CONFIGURATION  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum CustomMode where
  fromEnum t = case t of
    PROMOTION_FRIENDS_INVITE -> 1
    CAPABILITY_SERVER_SIDE_SMS -> 2
    LINE_CLIENT_ANALYTICS_CONFIGURATION -> 3
  toEnum t = case t of
    1 -> PROMOTION_FRIENDS_INVITE
    2 -> CAPABILITY_SERVER_SIDE_SMS
    3 -> LINE_CLIENT_ANALYTICS_CONFIGURATION
    _ -> X.throw T.ThriftException
instance H.Hashable CustomMode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary CustomMode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data EmailConfirmationStatus = NOT_SPECIFIED|NOT_YET|DONE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum EmailConfirmationStatus where
  fromEnum t = case t of
    NOT_SPECIFIED -> 0
    NOT_YET -> 1
    DONE -> 3
  toEnum t = case t of
    0 -> NOT_SPECIFIED
    1 -> NOT_YET
    3 -> DONE
    _ -> X.throw T.ThriftException
instance H.Hashable EmailConfirmationStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary EmailConfirmationStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data EmailConfirmationType = SERVER_SIDE_EMAIL|CLIENT_SIDE_EMAIL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum EmailConfirmationType where
  fromEnum t = case t of
    SERVER_SIDE_EMAIL -> 0
    CLIENT_SIDE_EMAIL -> 1
  toEnum t = case t of
    0 -> SERVER_SIDE_EMAIL
    1 -> CLIENT_SIDE_EMAIL
    _ -> X.throw T.ThriftException
instance H.Hashable EmailConfirmationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary EmailConfirmationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ErrorCode = ILLEGAL_ARGUMENT|AUTHENTICATION_FAILED|DB_FAILED|INVALID_STATE|EXCESSIVE_ACCESS|NOT_FOUND|INVALID_LENGTH|NOT_AVAILABLE_USER|NOT_AUTHORIZED_DEVICE|INVALID_MID|NOT_A_MEMBER|INCOMPATIBLE_APP_VERSION|NOT_READY|NOT_AVAILABLE_SESSION|NOT_AUTHORIZED_SESSION|SYSTEM_ERROR|NO_AVAILABLE_VERIFICATION_METHOD|NOT_AUTHENTICATED|INVALID_IDENTITY_CREDENTIAL|NOT_AVAILABLE_IDENTITY_IDENTIFIER|INTERNAL_ERROR|NO_SUCH_IDENTITY_IDENFIER|DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY|ILLEGAL_IDENTITY_CREDENTIAL|UNKNOWN_CHANNEL|NO_SUCH_MESSAGE_BOX|NOT_AVAILABLE_MESSAGE_BOX|CHANNEL_DOES_NOT_MATCH|NOT_YOUR_MESSAGE|MESSAGE_DEFINED_ERROR|USER_CANNOT_ACCEPT_PRESENTS|USER_NOT_STICKER_OWNER|MAINTENANCE_ERROR|ACCOUNT_NOT_MATCHED|ABUSE_BLOCK|NOT_FRIEND|NOT_ALLOWED_CALL|BLOCK_FRIEND|INCOMPATIBLE_VOIP_VERSION|INVALID_SNS_ACCESS_TOKEN|EXTERNAL_SERVICE_NOT_AVAILABLE|NOT_ALLOWED_ADD_CONTACT|NOT_CERTIFICATED|NOT_ALLOWED_SECONDARY_DEVICE|INVALID_PIN_CODE|NOT_FOUND_IDENTITY_CREDENTIAL|EXCEED_FILE_MAX_SIZE|EXCEED_DAILY_QUOTA|NOT_SUPPORT_SEND_FILE|MUST_UPGRADE|NOT_AVAILABLE_PIN_CODE_SESSION  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ErrorCode where
  fromEnum t = case t of
    ILLEGAL_ARGUMENT -> 0
    AUTHENTICATION_FAILED -> 1
    DB_FAILED -> 2
    INVALID_STATE -> 3
    EXCESSIVE_ACCESS -> 4
    NOT_FOUND -> 5
    INVALID_LENGTH -> 6
    NOT_AVAILABLE_USER -> 7
    NOT_AUTHORIZED_DEVICE -> 8
    INVALID_MID -> 9
    NOT_A_MEMBER -> 10
    INCOMPATIBLE_APP_VERSION -> 11
    NOT_READY -> 12
    NOT_AVAILABLE_SESSION -> 13
    NOT_AUTHORIZED_SESSION -> 14
    SYSTEM_ERROR -> 15
    NO_AVAILABLE_VERIFICATION_METHOD -> 16
    NOT_AUTHENTICATED -> 17
    INVALID_IDENTITY_CREDENTIAL -> 18
    NOT_AVAILABLE_IDENTITY_IDENTIFIER -> 19
    INTERNAL_ERROR -> 20
    NO_SUCH_IDENTITY_IDENFIER -> 21
    DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY -> 22
    ILLEGAL_IDENTITY_CREDENTIAL -> 23
    UNKNOWN_CHANNEL -> 24
    NO_SUCH_MESSAGE_BOX -> 25
    NOT_AVAILABLE_MESSAGE_BOX -> 26
    CHANNEL_DOES_NOT_MATCH -> 27
    NOT_YOUR_MESSAGE -> 28
    MESSAGE_DEFINED_ERROR -> 29
    USER_CANNOT_ACCEPT_PRESENTS -> 30
    USER_NOT_STICKER_OWNER -> 32
    MAINTENANCE_ERROR -> 33
    ACCOUNT_NOT_MATCHED -> 34
    ABUSE_BLOCK -> 35
    NOT_FRIEND -> 36
    NOT_ALLOWED_CALL -> 37
    BLOCK_FRIEND -> 38
    INCOMPATIBLE_VOIP_VERSION -> 39
    INVALID_SNS_ACCESS_TOKEN -> 40
    EXTERNAL_SERVICE_NOT_AVAILABLE -> 41
    NOT_ALLOWED_ADD_CONTACT -> 42
    NOT_CERTIFICATED -> 43
    NOT_ALLOWED_SECONDARY_DEVICE -> 44
    INVALID_PIN_CODE -> 45
    NOT_FOUND_IDENTITY_CREDENTIAL -> 46
    EXCEED_FILE_MAX_SIZE -> 47
    EXCEED_DAILY_QUOTA -> 48
    NOT_SUPPORT_SEND_FILE -> 49
    MUST_UPGRADE -> 50
    NOT_AVAILABLE_PIN_CODE_SESSION -> 51
  toEnum t = case t of
    0 -> ILLEGAL_ARGUMENT
    1 -> AUTHENTICATION_FAILED
    2 -> DB_FAILED
    3 -> INVALID_STATE
    4 -> EXCESSIVE_ACCESS
    5 -> NOT_FOUND
    6 -> INVALID_LENGTH
    7 -> NOT_AVAILABLE_USER
    8 -> NOT_AUTHORIZED_DEVICE
    9 -> INVALID_MID
    10 -> NOT_A_MEMBER
    11 -> INCOMPATIBLE_APP_VERSION
    12 -> NOT_READY
    13 -> NOT_AVAILABLE_SESSION
    14 -> NOT_AUTHORIZED_SESSION
    15 -> SYSTEM_ERROR
    16 -> NO_AVAILABLE_VERIFICATION_METHOD
    17 -> NOT_AUTHENTICATED
    18 -> INVALID_IDENTITY_CREDENTIAL
    19 -> NOT_AVAILABLE_IDENTITY_IDENTIFIER
    20 -> INTERNAL_ERROR
    21 -> NO_SUCH_IDENTITY_IDENFIER
    22 -> DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY
    23 -> ILLEGAL_IDENTITY_CREDENTIAL
    24 -> UNKNOWN_CHANNEL
    25 -> NO_SUCH_MESSAGE_BOX
    26 -> NOT_AVAILABLE_MESSAGE_BOX
    27 -> CHANNEL_DOES_NOT_MATCH
    28 -> NOT_YOUR_MESSAGE
    29 -> MESSAGE_DEFINED_ERROR
    30 -> USER_CANNOT_ACCEPT_PRESENTS
    32 -> USER_NOT_STICKER_OWNER
    33 -> MAINTENANCE_ERROR
    34 -> ACCOUNT_NOT_MATCHED
    35 -> ABUSE_BLOCK
    36 -> NOT_FRIEND
    37 -> NOT_ALLOWED_CALL
    38 -> BLOCK_FRIEND
    39 -> INCOMPATIBLE_VOIP_VERSION
    40 -> INVALID_SNS_ACCESS_TOKEN
    41 -> EXTERNAL_SERVICE_NOT_AVAILABLE
    42 -> NOT_ALLOWED_ADD_CONTACT
    43 -> NOT_CERTIFICATED
    44 -> NOT_ALLOWED_SECONDARY_DEVICE
    45 -> INVALID_PIN_CODE
    46 -> NOT_FOUND_IDENTITY_CREDENTIAL
    47 -> EXCEED_FILE_MAX_SIZE
    48 -> EXCEED_DAILY_QUOTA
    49 -> NOT_SUPPORT_SEND_FILE
    50 -> MUST_UPGRADE
    51 -> NOT_AVAILABLE_PIN_CODE_SESSION
    _ -> X.throw T.ThriftException
instance H.Hashable ErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data FeatureType = OBJECT_STORAGE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum FeatureType where
  fromEnum t = case t of
    OBJECT_STORAGE -> 1
  toEnum t = case t of
    1 -> OBJECT_STORAGE
    _ -> X.throw T.ThriftException
instance H.Hashable FeatureType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary FeatureType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data GroupAttribute = NAME|PICTURE_STATUS|ALL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum GroupAttribute where
  fromEnum t = case t of
    NAME -> 1
    PICTURE_STATUS -> 2
    ALL -> 255
  toEnum t = case t of
    1 -> NAME
    2 -> PICTURE_STATUS
    255 -> ALL
    _ -> X.throw T.ThriftException
instance H.Hashable GroupAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary GroupAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data IdentityProvider = UNKNOWN|LINE|NAVER_KR  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum IdentityProvider where
  fromEnum t = case t of
    UNKNOWN -> 0
    LINE -> 1
    NAVER_KR -> 2
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> LINE
    2 -> NAVER_KR
    _ -> X.throw T.ThriftException
instance H.Hashable IdentityProvider where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary IdentityProvider where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data LoginResultType = SUCCESS|REQUIRE_QRCODE|REQUIRE_DEVICE_CONFIRM  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum LoginResultType where
  fromEnum t = case t of
    SUCCESS -> 1
    REQUIRE_QRCODE -> 2
    REQUIRE_DEVICE_CONFIRM -> 3
  toEnum t = case t of
    1 -> SUCCESS
    2 -> REQUIRE_QRCODE
    3 -> REQUIRE_DEVICE_CONFIRM
    _ -> X.throw T.ThriftException
instance H.Hashable LoginResultType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary LoginResultType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data MessageOperationType = SEND_MESSAGE|RECEIVE_MESSAGE|READ_MESSAGE|NOTIFIED_READ_MESSAGE|NOTIFIED_JOIN_CHAT|FAILED_SEND_MESSAGE|SEND_CONTENT|SEND_CONTENT_RECEIPT|SEND_CHAT_REMOVED|REMOVE_ALL_MESSAGES  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum MessageOperationType where
  fromEnum t = case t of
    SEND_MESSAGE -> 1
    RECEIVE_MESSAGE -> 2
    READ_MESSAGE -> 3
    NOTIFIED_READ_MESSAGE -> 4
    NOTIFIED_JOIN_CHAT -> 5
    FAILED_SEND_MESSAGE -> 6
    SEND_CONTENT -> 7
    SEND_CONTENT_RECEIPT -> 8
    SEND_CHAT_REMOVED -> 9
    REMOVE_ALL_MESSAGES -> 10
  toEnum t = case t of
    1 -> SEND_MESSAGE
    2 -> RECEIVE_MESSAGE
    3 -> READ_MESSAGE
    4 -> NOTIFIED_READ_MESSAGE
    5 -> NOTIFIED_JOIN_CHAT
    6 -> FAILED_SEND_MESSAGE
    7 -> SEND_CONTENT
    8 -> SEND_CONTENT_RECEIPT
    9 -> SEND_CHAT_REMOVED
    10 -> REMOVE_ALL_MESSAGES
    _ -> X.throw T.ThriftException
instance H.Hashable MessageOperationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary MessageOperationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data MIDType = USER|ROOM|GROUP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum MIDType where
  fromEnum t = case t of
    USER -> 0
    ROOM -> 1
    GROUP -> 2
  toEnum t = case t of
    0 -> USER
    1 -> ROOM
    2 -> GROUP
    _ -> X.throw T.ThriftException
instance H.Hashable MIDType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary MIDType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ModificationType = ADD|REMOVE|MODIFY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ModificationType where
  fromEnum t = case t of
    ADD -> 0
    REMOVE -> 1
    MODIFY -> 2
  toEnum t = case t of
    0 -> ADD
    1 -> REMOVE
    2 -> MODIFY
    _ -> X.throw T.ThriftException
instance H.Hashable ModificationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ModificationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationItemFetchMode = ALL|APPEND  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationItemFetchMode where
  fromEnum t = case t of
    ALL -> 0
    APPEND -> 1
  toEnum t = case t of
    0 -> ALL
    1 -> APPEND
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationItemFetchMode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationItemFetchMode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationQueueType = GLOBAL|MESSAGE|PRIMARY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationQueueType where
  fromEnum t = case t of
    GLOBAL -> 1
    MESSAGE -> 2
    PRIMARY -> 3
  toEnum t = case t of
    1 -> GLOBAL
    2 -> MESSAGE
    3 -> PRIMARY
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationQueueType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationQueueType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationStatus = NOTIFICATION_ITEM_EXIST|TIMELINE_ITEM_EXIST|NOTE_GROUP_NEW_ITEM_EXIST|TIMELINE_BUDDYGROUP_CHANGED|NOTE_ONE_TO_ONE_NEW_ITEM_EXIST|ALBUM_ITEM_EXIST|TIMELINE_ITEM_DELETED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationStatus where
  fromEnum t = case t of
    NOTIFICATION_ITEM_EXIST -> 1
    TIMELINE_ITEM_EXIST -> 2
    NOTE_GROUP_NEW_ITEM_EXIST -> 4
    TIMELINE_BUDDYGROUP_CHANGED -> 8
    NOTE_ONE_TO_ONE_NEW_ITEM_EXIST -> 16
    ALBUM_ITEM_EXIST -> 32
    TIMELINE_ITEM_DELETED -> 64
  toEnum t = case t of
    1 -> NOTIFICATION_ITEM_EXIST
    2 -> TIMELINE_ITEM_EXIST
    4 -> NOTE_GROUP_NEW_ITEM_EXIST
    8 -> TIMELINE_BUDDYGROUP_CHANGED
    16 -> NOTE_ONE_TO_ONE_NEW_ITEM_EXIST
    32 -> ALBUM_ITEM_EXIST
    64 -> TIMELINE_ITEM_DELETED
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationType = APPLE_APNS|GOOGLE_C2DM|NHN_NNI|SKT_AOM|MS_MPNS|RIM_BIS|GOOGLE_GCM|NOKIA_NNAPI|TIZEN|LINE_BOT|LINE_WAP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationType where
  fromEnum t = case t of
    APPLE_APNS -> 1
    GOOGLE_C2DM -> 2
    NHN_NNI -> 3
    SKT_AOM -> 4
    MS_MPNS -> 5
    RIM_BIS -> 6
    GOOGLE_GCM -> 7
    NOKIA_NNAPI -> 8
    TIZEN -> 9
    LINE_BOT -> 17
    LINE_WAP -> 18
  toEnum t = case t of
    1 -> APPLE_APNS
    2 -> GOOGLE_C2DM
    3 -> NHN_NNI
    4 -> SKT_AOM
    5 -> MS_MPNS
    6 -> RIM_BIS
    7 -> GOOGLE_GCM
    8 -> NOKIA_NNAPI
    9 -> TIZEN
    17 -> LINE_BOT
    18 -> LINE_WAP
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data OpStatus = NORMAL|ALERT_DISABLED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum OpStatus where
  fromEnum t = case t of
    NORMAL -> 0
    ALERT_DISABLED -> 1
  toEnum t = case t of
    0 -> NORMAL
    1 -> ALERT_DISABLED
    _ -> X.throw T.ThriftException
instance H.Hashable OpStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary OpStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data OpType = END_OF_OPERATION|UPDATE_PROFILE|NOTIFIED_UPDATE_PROFILE|REGISTER_USERID|ADD_CONTACT|NOTIFIED_ADD_CONTACT|BLOCK_CONTACT|UNBLOCK_CONTACT|NOTIFIED_RECOMMEND_CONTACT|CREATE_GROUP|UPDATE_GROUP|NOTIFIED_UPDATE_GROUP|INVITE_INTO_GROUP|NOTIFIED_INVITE_INTO_GROUP|LEAVE_GROUP|NOTIFIED_LEAVE_GROUP|ACCEPT_GROUP_INVITATION|NOTIFIED_ACCEPT_GROUP_INVITATION|KICKOUT_FROM_GROUP|NOTIFIED_KICKOUT_FROM_GROUP|CREATE_ROOM|INVITE_INTO_ROOM|NOTIFIED_INVITE_INTO_ROOM|LEAVE_ROOM|NOTIFIED_LEAVE_ROOM|SEND_MESSAGE|RECEIVE_MESSAGE|SEND_MESSAGE_RECEIPT|RECEIVE_MESSAGE_RECEIPT|SEND_CONTENT_RECEIPT|RECEIVE_ANNOUNCEMENT|CANCEL_INVITATION_GROUP|NOTIFIED_CANCEL_INVITATION_GROUP|NOTIFIED_UNREGISTER_USER|REJECT_GROUP_INVITATION|NOTIFIED_REJECT_GROUP_INVITATION|UPDATE_SETTINGS|NOTIFIED_REGISTER_USER|INVITE_VIA_EMAIL|NOTIFIED_REQUEST_RECOVERY|SEND_CHAT_CHECKED|SEND_CHAT_REMOVED|NOTIFIED_FORCE_SYNC|SEND_CONTENT|SEND_MESSAGE_MYHOME|NOTIFIED_UPDATE_CONTENT_PREVIEW|REMOVE_ALL_MESSAGES|NOTIFIED_UPDATE_PURCHASES|DUMMY|UPDATE_CONTACT|NOTIFIED_RECEIVED_CALL|CANCEL_CALL|NOTIFIED_REDIRECT|NOTIFIED_CHANNEL_SYNC|FAILED_SEND_MESSAGE|NOTIFIED_READ_MESSAGE|FAILED_EMAIL_CONFIRMATION|NOTIFIED_CHAT_CONTENT|NOTIFIED_PUSH_NOTICENTER_ITEM  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum OpType where
  fromEnum t = case t of
    END_OF_OPERATION -> 0
    UPDATE_PROFILE -> 1
    NOTIFIED_UPDATE_PROFILE -> 2
    REGISTER_USERID -> 3
    ADD_CONTACT -> 4
    NOTIFIED_ADD_CONTACT -> 5
    BLOCK_CONTACT -> 6
    UNBLOCK_CONTACT -> 7
    NOTIFIED_RECOMMEND_CONTACT -> 8
    CREATE_GROUP -> 9
    UPDATE_GROUP -> 10
    NOTIFIED_UPDATE_GROUP -> 11
    INVITE_INTO_GROUP -> 12
    NOTIFIED_INVITE_INTO_GROUP -> 13
    LEAVE_GROUP -> 14
    NOTIFIED_LEAVE_GROUP -> 15
    ACCEPT_GROUP_INVITATION -> 16
    NOTIFIED_ACCEPT_GROUP_INVITATION -> 17
    KICKOUT_FROM_GROUP -> 18
    NOTIFIED_KICKOUT_FROM_GROUP -> 19
    CREATE_ROOM -> 20
    INVITE_INTO_ROOM -> 21
    NOTIFIED_INVITE_INTO_ROOM -> 22
    LEAVE_ROOM -> 23
    NOTIFIED_LEAVE_ROOM -> 24
    SEND_MESSAGE -> 25
    RECEIVE_MESSAGE -> 26
    SEND_MESSAGE_RECEIPT -> 27
    RECEIVE_MESSAGE_RECEIPT -> 28
    SEND_CONTENT_RECEIPT -> 29
    RECEIVE_ANNOUNCEMENT -> 30
    CANCEL_INVITATION_GROUP -> 31
    NOTIFIED_CANCEL_INVITATION_GROUP -> 32
    NOTIFIED_UNREGISTER_USER -> 33
    REJECT_GROUP_INVITATION -> 34
    NOTIFIED_REJECT_GROUP_INVITATION -> 35
    UPDATE_SETTINGS -> 36
    NOTIFIED_REGISTER_USER -> 37
    INVITE_VIA_EMAIL -> 38
    NOTIFIED_REQUEST_RECOVERY -> 39
    SEND_CHAT_CHECKED -> 40
    SEND_CHAT_REMOVED -> 41
    NOTIFIED_FORCE_SYNC -> 42
    SEND_CONTENT -> 43
    SEND_MESSAGE_MYHOME -> 44
    NOTIFIED_UPDATE_CONTENT_PREVIEW -> 45
    REMOVE_ALL_MESSAGES -> 46
    NOTIFIED_UPDATE_PURCHASES -> 47
    DUMMY -> 48
    UPDATE_CONTACT -> 49
    NOTIFIED_RECEIVED_CALL -> 50
    CANCEL_CALL -> 51
    NOTIFIED_REDIRECT -> 52
    NOTIFIED_CHANNEL_SYNC -> 53
    FAILED_SEND_MESSAGE -> 54
    NOTIFIED_READ_MESSAGE -> 55
    FAILED_EMAIL_CONFIRMATION -> 56
    NOTIFIED_CHAT_CONTENT -> 58
    NOTIFIED_PUSH_NOTICENTER_ITEM -> 59
  toEnum t = case t of
    0 -> END_OF_OPERATION
    1 -> UPDATE_PROFILE
    2 -> NOTIFIED_UPDATE_PROFILE
    3 -> REGISTER_USERID
    4 -> ADD_CONTACT
    5 -> NOTIFIED_ADD_CONTACT
    6 -> BLOCK_CONTACT
    7 -> UNBLOCK_CONTACT
    8 -> NOTIFIED_RECOMMEND_CONTACT
    9 -> CREATE_GROUP
    10 -> UPDATE_GROUP
    11 -> NOTIFIED_UPDATE_GROUP
    12 -> INVITE_INTO_GROUP
    13 -> NOTIFIED_INVITE_INTO_GROUP
    14 -> LEAVE_GROUP
    15 -> NOTIFIED_LEAVE_GROUP
    16 -> ACCEPT_GROUP_INVITATION
    17 -> NOTIFIED_ACCEPT_GROUP_INVITATION
    18 -> KICKOUT_FROM_GROUP
    19 -> NOTIFIED_KICKOUT_FROM_GROUP
    20 -> CREATE_ROOM
    21 -> INVITE_INTO_ROOM
    22 -> NOTIFIED_INVITE_INTO_ROOM
    23 -> LEAVE_ROOM
    24 -> NOTIFIED_LEAVE_ROOM
    25 -> SEND_MESSAGE
    26 -> RECEIVE_MESSAGE
    27 -> SEND_MESSAGE_RECEIPT
    28 -> RECEIVE_MESSAGE_RECEIPT
    29 -> SEND_CONTENT_RECEIPT
    30 -> RECEIVE_ANNOUNCEMENT
    31 -> CANCEL_INVITATION_GROUP
    32 -> NOTIFIED_CANCEL_INVITATION_GROUP
    33 -> NOTIFIED_UNREGISTER_USER
    34 -> REJECT_GROUP_INVITATION
    35 -> NOTIFIED_REJECT_GROUP_INVITATION
    36 -> UPDATE_SETTINGS
    37 -> NOTIFIED_REGISTER_USER
    38 -> INVITE_VIA_EMAIL
    39 -> NOTIFIED_REQUEST_RECOVERY
    40 -> SEND_CHAT_CHECKED
    41 -> SEND_CHAT_REMOVED
    42 -> NOTIFIED_FORCE_SYNC
    43 -> SEND_CONTENT
    44 -> SEND_MESSAGE_MYHOME
    45 -> NOTIFIED_UPDATE_CONTENT_PREVIEW
    46 -> REMOVE_ALL_MESSAGES
    47 -> NOTIFIED_UPDATE_PURCHASES
    48 -> DUMMY
    49 -> UPDATE_CONTACT
    50 -> NOTIFIED_RECEIVED_CALL
    51 -> CANCEL_CALL
    52 -> NOTIFIED_REDIRECT
    53 -> NOTIFIED_CHANNEL_SYNC
    54 -> FAILED_SEND_MESSAGE
    55 -> NOTIFIED_READ_MESSAGE
    56 -> FAILED_EMAIL_CONFIRMATION
    58 -> NOTIFIED_CHAT_CONTENT
    59 -> NOTIFIED_PUSH_NOTICENTER_ITEM
    _ -> X.throw T.ThriftException
instance H.Hashable OpType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary OpType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PayloadType = PAYLOAD_BUY|PAYLOAD_CS|PAYLOAD_BONUS|PAYLOAD_EVENT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PayloadType where
  fromEnum t = case t of
    PAYLOAD_BUY -> 101
    PAYLOAD_CS -> 111
    PAYLOAD_BONUS -> 121
    PAYLOAD_EVENT -> 131
  toEnum t = case t of
    101 -> PAYLOAD_BUY
    111 -> PAYLOAD_CS
    121 -> PAYLOAD_BONUS
    131 -> PAYLOAD_EVENT
    _ -> X.throw T.ThriftException
instance H.Hashable PayloadType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PayloadType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PaymentPgType = PAYMENT_PG_NONE|PAYMENT_PG_AU|PAYMENT_PG_AL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PaymentPgType where
  fromEnum t = case t of
    PAYMENT_PG_NONE -> 0
    PAYMENT_PG_AU -> 1
    PAYMENT_PG_AL -> 2
  toEnum t = case t of
    0 -> PAYMENT_PG_NONE
    1 -> PAYMENT_PG_AU
    2 -> PAYMENT_PG_AL
    _ -> X.throw T.ThriftException
instance H.Hashable PaymentPgType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PaymentPgType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PaymentType = PAYMENT_APPLE|PAYMENT_GOOGLE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PaymentType where
  fromEnum t = case t of
    PAYMENT_APPLE -> 1
    PAYMENT_GOOGLE -> 2
  toEnum t = case t of
    1 -> PAYMENT_APPLE
    2 -> PAYMENT_GOOGLE
    _ -> X.throw T.ThriftException
instance H.Hashable PaymentType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PaymentType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ProductBannerLinkType = BANNER_LINK_NONE|BANNER_LINK_ITEM|BANNER_LINK_URL|BANNER_LINK_CATEGORY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ProductBannerLinkType where
  fromEnum t = case t of
    BANNER_LINK_NONE -> 0
    BANNER_LINK_ITEM -> 1
    BANNER_LINK_URL -> 2
    BANNER_LINK_CATEGORY -> 3
  toEnum t = case t of
    0 -> BANNER_LINK_NONE
    1 -> BANNER_LINK_ITEM
    2 -> BANNER_LINK_URL
    3 -> BANNER_LINK_CATEGORY
    _ -> X.throw T.ThriftException
instance H.Hashable ProductBannerLinkType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ProductBannerLinkType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ProductEventType = NO_EVENT|CARRIER_ANY|BUDDY_ANY|INSTALL_IOS|INSTALL_ANDROID|MISSION_ANY|MUSTBUY_ANY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ProductEventType where
  fromEnum t = case t of
    NO_EVENT -> 0
    CARRIER_ANY -> 65537
    BUDDY_ANY -> 131073
    INSTALL_IOS -> 196609
    INSTALL_ANDROID -> 196610
    MISSION_ANY -> 262145
    MUSTBUY_ANY -> 327681
  toEnum t = case t of
    0 -> NO_EVENT
    65537 -> CARRIER_ANY
    131073 -> BUDDY_ANY
    196609 -> INSTALL_IOS
    196610 -> INSTALL_ANDROID
    262145 -> MISSION_ANY
    327681 -> MUSTBUY_ANY
    _ -> X.throw T.ThriftException
instance H.Hashable ProductEventType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ProductEventType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ProfileAttribute = EMAIL|DISPLAY_NAME|PHONETIC_NAME|PICTURE|STATUS_MESSAGE|ALLOW_SEARCH_BY_USERID|ALLOW_SEARCH_BY_EMAIL|BUDDY_STATUS|ALL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ProfileAttribute where
  fromEnum t = case t of
    EMAIL -> 1
    DISPLAY_NAME -> 2
    PHONETIC_NAME -> 4
    PICTURE -> 8
    STATUS_MESSAGE -> 16
    ALLOW_SEARCH_BY_USERID -> 32
    ALLOW_SEARCH_BY_EMAIL -> 64
    BUDDY_STATUS -> 128
    ALL -> 255
  toEnum t = case t of
    1 -> EMAIL
    2 -> DISPLAY_NAME
    4 -> PHONETIC_NAME
    8 -> PICTURE
    16 -> STATUS_MESSAGE
    32 -> ALLOW_SEARCH_BY_USERID
    64 -> ALLOW_SEARCH_BY_EMAIL
    128 -> BUDDY_STATUS
    255 -> ALL
    _ -> X.throw T.ThriftException
instance H.Hashable ProfileAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ProfileAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PublicType = HIDDEN|PUBLIC  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PublicType where
  fromEnum t = case t of
    HIDDEN -> 0
    PUBLIC -> 1000
  toEnum t = case t of
    0 -> HIDDEN
    1000 -> PUBLIC
    _ -> X.throw T.ThriftException
instance H.Hashable PublicType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PublicType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RedirectType = NONE|EXPIRE_SECOND  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RedirectType where
  fromEnum t = case t of
    NONE -> 0
    EXPIRE_SECOND -> 1
  toEnum t = case t of
    0 -> NONE
    1 -> EXPIRE_SECOND
    _ -> X.throw T.ThriftException
instance H.Hashable RedirectType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RedirectType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RegistrationType = PHONE|EMAIL_WAP|FACEBOOK|SINA|RENREN|FEIXIN  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RegistrationType where
  fromEnum t = case t of
    PHONE -> 0
    EMAIL_WAP -> 1
    FACEBOOK -> 2305
    SINA -> 2306
    RENREN -> 2307
    FEIXIN -> 2308
  toEnum t = case t of
    0 -> PHONE
    1 -> EMAIL_WAP
    2305 -> FACEBOOK
    2306 -> SINA
    2307 -> RENREN
    2308 -> FEIXIN
    _ -> X.throw T.ThriftException
instance H.Hashable RegistrationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RegistrationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SettingsAttribute = NOTIFICATION_ENABLE|NOTIFICATION_MUTE_EXPIRATION|NOTIFICATION_NEW_MESSAGE|NOTIFICATION_GROUP_INVITATION|NOTIFICATION_SHOW_MESSAGE|NOTIFICATION_INCOMING_CALL|PRIVACY_SYNC_CONTACTS|PRIVACY_SEARCH_BY_PHONE_NUMBER|NOTIFICATION_SOUND_MESSAGE|NOTIFICATION_SOUND_GROUP|CONTACT_MY_TICKET|IDENTITY_PROVIDER|IDENTITY_IDENTIFIER|PRIVACY_SEARCH_BY_USERID|PRIVACY_SEARCH_BY_EMAIL|PREFERENCE_LOCALE|NOTIFICATION_DISABLED_WITH_SUB|SNS_ACCOUNT|PHONE_REGISTRATION|PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN|CUSTOM_MODE|PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME|EMAIL_CONFIRMATION_STATUS|PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND|ALL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SettingsAttribute where
  fromEnum t = case t of
    NOTIFICATION_ENABLE -> 1
    NOTIFICATION_MUTE_EXPIRATION -> 2
    NOTIFICATION_NEW_MESSAGE -> 4
    NOTIFICATION_GROUP_INVITATION -> 8
    NOTIFICATION_SHOW_MESSAGE -> 16
    NOTIFICATION_INCOMING_CALL -> 32
    PRIVACY_SYNC_CONTACTS -> 64
    PRIVACY_SEARCH_BY_PHONE_NUMBER -> 128
    NOTIFICATION_SOUND_MESSAGE -> 256
    NOTIFICATION_SOUND_GROUP -> 512
    CONTACT_MY_TICKET -> 1024
    IDENTITY_PROVIDER -> 2048
    IDENTITY_IDENTIFIER -> 4096
    PRIVACY_SEARCH_BY_USERID -> 8192
    PRIVACY_SEARCH_BY_EMAIL -> 16384
    PREFERENCE_LOCALE -> 32768
    NOTIFICATION_DISABLED_WITH_SUB -> 65536
    SNS_ACCOUNT -> 524288
    PHONE_REGISTRATION -> 1048576
    PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN -> 2097152
    CUSTOM_MODE -> 4194304
    PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME -> 8388608
    EMAIL_CONFIRMATION_STATUS -> 16777216
    PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND -> 33554432
    ALL -> 2147483647
  toEnum t = case t of
    1 -> NOTIFICATION_ENABLE
    2 -> NOTIFICATION_MUTE_EXPIRATION
    4 -> NOTIFICATION_NEW_MESSAGE
    8 -> NOTIFICATION_GROUP_INVITATION
    16 -> NOTIFICATION_SHOW_MESSAGE
    32 -> NOTIFICATION_INCOMING_CALL
    64 -> PRIVACY_SYNC_CONTACTS
    128 -> PRIVACY_SEARCH_BY_PHONE_NUMBER
    256 -> NOTIFICATION_SOUND_MESSAGE
    512 -> NOTIFICATION_SOUND_GROUP
    1024 -> CONTACT_MY_TICKET
    2048 -> IDENTITY_PROVIDER
    4096 -> IDENTITY_IDENTIFIER
    8192 -> PRIVACY_SEARCH_BY_USERID
    16384 -> PRIVACY_SEARCH_BY_EMAIL
    32768 -> PREFERENCE_LOCALE
    65536 -> NOTIFICATION_DISABLED_WITH_SUB
    524288 -> SNS_ACCOUNT
    1048576 -> PHONE_REGISTRATION
    2097152 -> PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN
    4194304 -> CUSTOM_MODE
    8388608 -> PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME
    16777216 -> EMAIL_CONFIRMATION_STATUS
    33554432 -> PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND
    2147483647 -> ALL
    _ -> X.throw T.ThriftException
instance H.Hashable SettingsAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SettingsAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SnsIdType = FACEBOOK|SINA|RENREN|FEIXIN  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SnsIdType where
  fromEnum t = case t of
    FACEBOOK -> 1
    SINA -> 2
    RENREN -> 3
    FEIXIN -> 4
  toEnum t = case t of
    1 -> FACEBOOK
    2 -> SINA
    3 -> RENREN
    4 -> FEIXIN
    _ -> X.throw T.ThriftException
instance H.Hashable SnsIdType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SnsIdType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SpammerReason = OTHER|ADVERTISING|GENDER_HARASSMENT|HARASSMENT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SpammerReason where
  fromEnum t = case t of
    OTHER -> 0
    ADVERTISING -> 1
    GENDER_HARASSMENT -> 2
    HARASSMENT -> 3
  toEnum t = case t of
    0 -> OTHER
    1 -> ADVERTISING
    2 -> GENDER_HARASSMENT
    3 -> HARASSMENT
    _ -> X.throw T.ThriftException
instance H.Hashable SpammerReason where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SpammerReason where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SyncActionType = SYNC|REPORT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SyncActionType where
  fromEnum t = case t of
    SYNC -> 0
    REPORT -> 1
  toEnum t = case t of
    0 -> SYNC
    1 -> REPORT
    _ -> X.throw T.ThriftException
instance H.Hashable SyncActionType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SyncActionType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SyncCategory = PROFILE|SETTINGS|OPS|CONTACT|RECOMMEND|BLOCK|GROUP|ROOM|NOTIFICATION  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SyncCategory where
  fromEnum t = case t of
    PROFILE -> 0
    SETTINGS -> 1
    OPS -> 2
    CONTACT -> 3
    RECOMMEND -> 4
    BLOCK -> 5
    GROUP -> 6
    ROOM -> 7
    NOTIFICATION -> 8
  toEnum t = case t of
    0 -> PROFILE
    1 -> SETTINGS
    2 -> OPS
    3 -> CONTACT
    4 -> RECOMMEND
    5 -> BLOCK
    6 -> GROUP
    7 -> ROOM
    8 -> NOTIFICATION
    _ -> X.throw T.ThriftException
instance H.Hashable SyncCategory where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SyncCategory where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data TMessageBoxStatus = ACTIVATED|UNREAD  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum TMessageBoxStatus where
  fromEnum t = case t of
    ACTIVATED -> 1
    UNREAD -> 2
  toEnum t = case t of
    1 -> ACTIVATED
    2 -> UNREAD
    _ -> X.throw T.ThriftException
instance H.Hashable TMessageBoxStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary TMessageBoxStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UniversalNotificationServiceErrorCode = INTERNAL_ERROR|INVALID_KEY|ILLEGAL_ARGUMENT|TOO_MANY_REQUEST|AUTHENTICATION_FAILED|NO_WRITE_PERMISSION  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UniversalNotificationServiceErrorCode where
  fromEnum t = case t of
    INTERNAL_ERROR -> 0
    INVALID_KEY -> 1
    ILLEGAL_ARGUMENT -> 2
    TOO_MANY_REQUEST -> 3
    AUTHENTICATION_FAILED -> 4
    NO_WRITE_PERMISSION -> 5
  toEnum t = case t of
    0 -> INTERNAL_ERROR
    1 -> INVALID_KEY
    2 -> ILLEGAL_ARGUMENT
    3 -> TOO_MANY_REQUEST
    4 -> AUTHENTICATION_FAILED
    5 -> NO_WRITE_PERMISSION
    _ -> X.throw T.ThriftException
instance H.Hashable UniversalNotificationServiceErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UniversalNotificationServiceErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UnregistrationReason = UNREGISTRATION_REASON_UNREGISTER_USER|UNREGISTRATION_REASON_UNBIND_DEVICE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UnregistrationReason where
  fromEnum t = case t of
    UNREGISTRATION_REASON_UNREGISTER_USER -> 1
    UNREGISTRATION_REASON_UNBIND_DEVICE -> 2
  toEnum t = case t of
    1 -> UNREGISTRATION_REASON_UNREGISTER_USER
    2 -> UNREGISTRATION_REASON_UNBIND_DEVICE
    _ -> X.throw T.ThriftException
instance H.Hashable UnregistrationReason where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UnregistrationReason where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UserAgeType = OVER|UNDER|UNDEFINED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UserAgeType where
  fromEnum t = case t of
    OVER -> 1
    UNDER -> 2
    UNDEFINED -> 3
  toEnum t = case t of
    1 -> OVER
    2 -> UNDER
    3 -> UNDEFINED
    _ -> X.throw T.ThriftException
instance H.Hashable UserAgeType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UserAgeType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data VerificationMethod = NO_AVAILABLE|PIN_VIA_SMS|CALLERID_INDIGO|PIN_VIA_TTS|SKIP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum VerificationMethod where
  fromEnum t = case t of
    NO_AVAILABLE -> 0
    PIN_VIA_SMS -> 1
    CALLERID_INDIGO -> 2
    PIN_VIA_TTS -> 4
    SKIP -> 10
  toEnum t = case t of
    0 -> NO_AVAILABLE
    1 -> PIN_VIA_SMS
    2 -> CALLERID_INDIGO
    4 -> PIN_VIA_TTS
    10 -> SKIP
    _ -> X.throw T.ThriftException
instance H.Hashable VerificationMethod where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary VerificationMethod where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data VerificationResult = FAILED|OK_NOT_REGISTERED_YET|OK_REGISTERED_WITH_SAME_DEVICE|OK_REGISTERED_WITH_ANOTHER_DEVICE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum VerificationResult where
  fromEnum t = case t of
    FAILED -> 0
    OK_NOT_REGISTERED_YET -> 1
    OK_REGISTERED_WITH_SAME_DEVICE -> 2
    OK_REGISTERED_WITH_ANOTHER_DEVICE -> 3
  toEnum t = case t of
    0 -> FAILED
    1 -> OK_NOT_REGISTERED_YET
    2 -> OK_REGISTERED_WITH_SAME_DEVICE
    3 -> OK_REGISTERED_WITH_ANOTHER_DEVICE
    _ -> X.throw T.ThriftException
instance H.Hashable VerificationResult where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary VerificationResult where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data WapInvitationType = REGISTRATION|CHAT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum WapInvitationType where
  fromEnum t = case t of
    REGISTRATION -> 1
    CHAT -> 2
  toEnum t = case t of
    1 -> REGISTRATION
    2 -> CHAT
    _ -> X.throw T.ThriftException
instance H.Hashable WapInvitationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary WapInvitationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data AgeCheckDocomoResult = AgeCheckDocomoResult  { ageCheckDocomoResult_authUrl :: LT.Text
  , ageCheckDocomoResult_userAgeType :: UserAgeType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AgeCheckDocomoResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` ageCheckDocomoResult_authUrl record   `H.hashWithSalt` ageCheckDocomoResult_userAgeType record  
instance QC.Arbitrary AgeCheckDocomoResult where 
  arbitrary = M.liftM AgeCheckDocomoResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AgeCheckDocomoResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AgeCheckDocomoResult{ageCheckDocomoResult_authUrl = ageCheckDocomoResult_authUrl obj} then P.Nothing else P.Just $ default_AgeCheckDocomoResult{ageCheckDocomoResult_authUrl = ageCheckDocomoResult_authUrl obj}
    , if obj == default_AgeCheckDocomoResult{ageCheckDocomoResult_userAgeType = ageCheckDocomoResult_userAgeType obj} then P.Nothing else P.Just $ default_AgeCheckDocomoResult{ageCheckDocomoResult_userAgeType = ageCheckDocomoResult_userAgeType obj}
    ]
from_AgeCheckDocomoResult :: AgeCheckDocomoResult -> T.ThriftVal
from_AgeCheckDocomoResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("authUrl",T.TString $ E.encodeUtf8 _v2))) $ ageCheckDocomoResult_authUrl record
  , (\_v2 -> P.Just (2, ("userAgeType",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) $ ageCheckDocomoResult_userAgeType record
  ]
write_AgeCheckDocomoResult :: T.Protocol p => p -> AgeCheckDocomoResult -> P.IO ()
write_AgeCheckDocomoResult oprot record = T.writeVal oprot $ from_AgeCheckDocomoResult record
encode_AgeCheckDocomoResult :: T.StatelessProtocol p => p -> AgeCheckDocomoResult -> LBS.ByteString
encode_AgeCheckDocomoResult oprot record = T.serializeVal oprot $ from_AgeCheckDocomoResult record
to_AgeCheckDocomoResult :: T.ThriftVal -> AgeCheckDocomoResult
to_AgeCheckDocomoResult (T.TStruct fields) = AgeCheckDocomoResult{
  ageCheckDocomoResult_authUrl = P.maybe (ageCheckDocomoResult_authUrl default_AgeCheckDocomoResult) (\(_,_val4) -> (case _val4 of {T.TString _val5 -> E.decodeUtf8 _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  ageCheckDocomoResult_userAgeType = P.maybe (ageCheckDocomoResult_userAgeType default_AgeCheckDocomoResult) (\(_,_val4) -> (case _val4 of {T.TI32 _val6 -> P.toEnum $ P.fromIntegral _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AgeCheckDocomoResult _ = P.error "not a struct"
read_AgeCheckDocomoResult :: T.Protocol p => p -> P.IO AgeCheckDocomoResult
read_AgeCheckDocomoResult iprot = to_AgeCheckDocomoResult <$> T.readVal iprot (T.T_STRUCT typemap_AgeCheckDocomoResult)
decode_AgeCheckDocomoResult :: T.StatelessProtocol p => p -> LBS.ByteString -> AgeCheckDocomoResult
decode_AgeCheckDocomoResult iprot bs = to_AgeCheckDocomoResult $ T.deserializeVal iprot (T.T_STRUCT typemap_AgeCheckDocomoResult) bs
typemap_AgeCheckDocomoResult :: T.TypeMap
typemap_AgeCheckDocomoResult = Map.fromList [(1,("authUrl",T.T_STRING)),(2,("userAgeType",T.T_I32))]
default_AgeCheckDocomoResult :: AgeCheckDocomoResult
default_AgeCheckDocomoResult = AgeCheckDocomoResult{
  ageCheckDocomoResult_authUrl = "",
  ageCheckDocomoResult_userAgeType = (P.toEnum 0)}
data AgeCheckRequestResult = AgeCheckRequestResult  { ageCheckRequestResult_authUrl :: LT.Text
  , ageCheckRequestResult_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AgeCheckRequestResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` ageCheckRequestResult_authUrl record   `H.hashWithSalt` ageCheckRequestResult_sessionId record  
instance QC.Arbitrary AgeCheckRequestResult where 
  arbitrary = M.liftM AgeCheckRequestResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AgeCheckRequestResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AgeCheckRequestResult{ageCheckRequestResult_authUrl = ageCheckRequestResult_authUrl obj} then P.Nothing else P.Just $ default_AgeCheckRequestResult{ageCheckRequestResult_authUrl = ageCheckRequestResult_authUrl obj}
    , if obj == default_AgeCheckRequestResult{ageCheckRequestResult_sessionId = ageCheckRequestResult_sessionId obj} then P.Nothing else P.Just $ default_AgeCheckRequestResult{ageCheckRequestResult_sessionId = ageCheckRequestResult_sessionId obj}
    ]
from_AgeCheckRequestResult :: AgeCheckRequestResult -> T.ThriftVal
from_AgeCheckRequestResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9 -> P.Just (1, ("authUrl",T.TString $ E.encodeUtf8 _v9))) $ ageCheckRequestResult_authUrl record
  , (\_v9 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v9))) $ ageCheckRequestResult_sessionId record
  ]
write_AgeCheckRequestResult :: T.Protocol p => p -> AgeCheckRequestResult -> P.IO ()
write_AgeCheckRequestResult oprot record = T.writeVal oprot $ from_AgeCheckRequestResult record
encode_AgeCheckRequestResult :: T.StatelessProtocol p => p -> AgeCheckRequestResult -> LBS.ByteString
encode_AgeCheckRequestResult oprot record = T.serializeVal oprot $ from_AgeCheckRequestResult record
to_AgeCheckRequestResult :: T.ThriftVal -> AgeCheckRequestResult
to_AgeCheckRequestResult (T.TStruct fields) = AgeCheckRequestResult{
  ageCheckRequestResult_authUrl = P.maybe (ageCheckRequestResult_authUrl default_AgeCheckRequestResult) (\(_,_val11) -> (case _val11 of {T.TString _val12 -> E.decodeUtf8 _val12; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  ageCheckRequestResult_sessionId = P.maybe (ageCheckRequestResult_sessionId default_AgeCheckRequestResult) (\(_,_val11) -> (case _val11 of {T.TString _val13 -> E.decodeUtf8 _val13; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AgeCheckRequestResult _ = P.error "not a struct"
read_AgeCheckRequestResult :: T.Protocol p => p -> P.IO AgeCheckRequestResult
read_AgeCheckRequestResult iprot = to_AgeCheckRequestResult <$> T.readVal iprot (T.T_STRUCT typemap_AgeCheckRequestResult)
decode_AgeCheckRequestResult :: T.StatelessProtocol p => p -> LBS.ByteString -> AgeCheckRequestResult
decode_AgeCheckRequestResult iprot bs = to_AgeCheckRequestResult $ T.deserializeVal iprot (T.T_STRUCT typemap_AgeCheckRequestResult) bs
typemap_AgeCheckRequestResult :: T.TypeMap
typemap_AgeCheckRequestResult = Map.fromList [(1,("authUrl",T.T_STRING)),(2,("sessionId",T.T_STRING))]
default_AgeCheckRequestResult :: AgeCheckRequestResult
default_AgeCheckRequestResult = AgeCheckRequestResult{
  ageCheckRequestResult_authUrl = "",
  ageCheckRequestResult_sessionId = ""}
data Announcement = Announcement  { announcement_index :: I.Int32
  , announcement_forceUpdate :: P.Bool
  , announcement_title :: LT.Text
  , announcement_text :: LT.Text
  , announcement_createdTime :: I.Int64
  , announcement_pictureUrl :: LT.Text
  , announcement_thumbnailUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Announcement where
  hashWithSalt salt record = salt   `H.hashWithSalt` announcement_index record   `H.hashWithSalt` announcement_forceUpdate record   `H.hashWithSalt` announcement_title record   `H.hashWithSalt` announcement_text record   `H.hashWithSalt` announcement_createdTime record   `H.hashWithSalt` announcement_pictureUrl record   `H.hashWithSalt` announcement_thumbnailUrl record  
instance QC.Arbitrary Announcement where 
  arbitrary = M.liftM Announcement (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Announcement = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Announcement{announcement_index = announcement_index obj} then P.Nothing else P.Just $ default_Announcement{announcement_index = announcement_index obj}
    , if obj == default_Announcement{announcement_forceUpdate = announcement_forceUpdate obj} then P.Nothing else P.Just $ default_Announcement{announcement_forceUpdate = announcement_forceUpdate obj}
    , if obj == default_Announcement{announcement_title = announcement_title obj} then P.Nothing else P.Just $ default_Announcement{announcement_title = announcement_title obj}
    , if obj == default_Announcement{announcement_text = announcement_text obj} then P.Nothing else P.Just $ default_Announcement{announcement_text = announcement_text obj}
    , if obj == default_Announcement{announcement_createdTime = announcement_createdTime obj} then P.Nothing else P.Just $ default_Announcement{announcement_createdTime = announcement_createdTime obj}
    , if obj == default_Announcement{announcement_pictureUrl = announcement_pictureUrl obj} then P.Nothing else P.Just $ default_Announcement{announcement_pictureUrl = announcement_pictureUrl obj}
    , if obj == default_Announcement{announcement_thumbnailUrl = announcement_thumbnailUrl obj} then P.Nothing else P.Just $ default_Announcement{announcement_thumbnailUrl = announcement_thumbnailUrl obj}
    ]
from_Announcement :: Announcement -> T.ThriftVal
from_Announcement record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v16 -> P.Just (1, ("index",T.TI32 _v16))) $ announcement_index record
  , (\_v16 -> P.Just (10, ("forceUpdate",T.TBool _v16))) $ announcement_forceUpdate record
  , (\_v16 -> P.Just (11, ("title",T.TString $ E.encodeUtf8 _v16))) $ announcement_title record
  , (\_v16 -> P.Just (12, ("text",T.TString $ E.encodeUtf8 _v16))) $ announcement_text record
  , (\_v16 -> P.Just (13, ("createdTime",T.TI64 _v16))) $ announcement_createdTime record
  , (\_v16 -> P.Just (14, ("pictureUrl",T.TString $ E.encodeUtf8 _v16))) $ announcement_pictureUrl record
  , (\_v16 -> P.Just (15, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v16))) $ announcement_thumbnailUrl record
  ]
write_Announcement :: T.Protocol p => p -> Announcement -> P.IO ()
write_Announcement oprot record = T.writeVal oprot $ from_Announcement record
encode_Announcement :: T.StatelessProtocol p => p -> Announcement -> LBS.ByteString
encode_Announcement oprot record = T.serializeVal oprot $ from_Announcement record
to_Announcement :: T.ThriftVal -> Announcement
to_Announcement (T.TStruct fields) = Announcement{
  announcement_index = P.maybe (announcement_index default_Announcement) (\(_,_val18) -> (case _val18 of {T.TI32 _val19 -> _val19; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  announcement_forceUpdate = P.maybe (announcement_forceUpdate default_Announcement) (\(_,_val18) -> (case _val18 of {T.TBool _val20 -> _val20; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  announcement_title = P.maybe (announcement_title default_Announcement) (\(_,_val18) -> (case _val18 of {T.TString _val21 -> E.decodeUtf8 _val21; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  announcement_text = P.maybe (announcement_text default_Announcement) (\(_,_val18) -> (case _val18 of {T.TString _val22 -> E.decodeUtf8 _val22; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  announcement_createdTime = P.maybe (announcement_createdTime default_Announcement) (\(_,_val18) -> (case _val18 of {T.TI64 _val23 -> _val23; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  announcement_pictureUrl = P.maybe (announcement_pictureUrl default_Announcement) (\(_,_val18) -> (case _val18 of {T.TString _val24 -> E.decodeUtf8 _val24; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  announcement_thumbnailUrl = P.maybe (announcement_thumbnailUrl default_Announcement) (\(_,_val18) -> (case _val18 of {T.TString _val25 -> E.decodeUtf8 _val25; _ -> P.error "wrong type"})) (Map.lookup (15) fields)
  }
to_Announcement _ = P.error "not a struct"
read_Announcement :: T.Protocol p => p -> P.IO Announcement
read_Announcement iprot = to_Announcement <$> T.readVal iprot (T.T_STRUCT typemap_Announcement)
decode_Announcement :: T.StatelessProtocol p => p -> LBS.ByteString -> Announcement
decode_Announcement iprot bs = to_Announcement $ T.deserializeVal iprot (T.T_STRUCT typemap_Announcement) bs
typemap_Announcement :: T.TypeMap
typemap_Announcement = Map.fromList [(1,("index",T.T_I32)),(10,("forceUpdate",T.T_BOOL)),(11,("title",T.T_STRING)),(12,("text",T.T_STRING)),(13,("createdTime",T.T_I64)),(14,("pictureUrl",T.T_STRING)),(15,("thumbnailUrl",T.T_STRING))]
default_Announcement :: Announcement
default_Announcement = Announcement{
  announcement_index = 0,
  announcement_forceUpdate = P.False,
  announcement_title = "",
  announcement_text = "",
  announcement_createdTime = 0,
  announcement_pictureUrl = "",
  announcement_thumbnailUrl = ""}
data ChannelProvider = ChannelProvider  { channelProvider_name :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelProvider where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelProvider_name record  
instance QC.Arbitrary ChannelProvider where 
  arbitrary = M.liftM ChannelProvider (QC.arbitrary)
  shrink obj | obj == default_ChannelProvider = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelProvider{channelProvider_name = channelProvider_name obj} then P.Nothing else P.Just $ default_ChannelProvider{channelProvider_name = channelProvider_name obj}
    ]
from_ChannelProvider :: ChannelProvider -> T.ThriftVal
from_ChannelProvider record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v28 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v28))) $ channelProvider_name record
  ]
write_ChannelProvider :: T.Protocol p => p -> ChannelProvider -> P.IO ()
write_ChannelProvider oprot record = T.writeVal oprot $ from_ChannelProvider record
encode_ChannelProvider :: T.StatelessProtocol p => p -> ChannelProvider -> LBS.ByteString
encode_ChannelProvider oprot record = T.serializeVal oprot $ from_ChannelProvider record
to_ChannelProvider :: T.ThriftVal -> ChannelProvider
to_ChannelProvider (T.TStruct fields) = ChannelProvider{
  channelProvider_name = P.maybe (channelProvider_name default_ChannelProvider) (\(_,_val30) -> (case _val30 of {T.TString _val31 -> E.decodeUtf8 _val31; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ChannelProvider _ = P.error "not a struct"
read_ChannelProvider :: T.Protocol p => p -> P.IO ChannelProvider
read_ChannelProvider iprot = to_ChannelProvider <$> T.readVal iprot (T.T_STRUCT typemap_ChannelProvider)
decode_ChannelProvider :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelProvider
decode_ChannelProvider iprot bs = to_ChannelProvider $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelProvider) bs
typemap_ChannelProvider :: T.TypeMap
typemap_ChannelProvider = Map.fromList [(1,("name",T.T_STRING))]
default_ChannelProvider :: ChannelProvider
default_ChannelProvider = ChannelProvider{
  channelProvider_name = ""}
data ChannelInfo = ChannelInfo  { channelInfo_channelId :: LT.Text
  , channelInfo_name :: LT.Text
  , channelInfo_entryPageUrl :: LT.Text
  , channelInfo_descriptionText :: LT.Text
  , channelInfo_provider :: ChannelProvider
  , channelInfo_publicType :: PublicType
  , channelInfo_iconImage :: LT.Text
  , channelInfo_permissions :: (Vector.Vector LT.Text)
  , channelInfo_iconThumbnailImage :: LT.Text
  , channelInfo_channelConfigurations :: (Vector.Vector ChannelConfiguration)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelInfo_channelId record   `H.hashWithSalt` channelInfo_name record   `H.hashWithSalt` channelInfo_entryPageUrl record   `H.hashWithSalt` channelInfo_descriptionText record   `H.hashWithSalt` channelInfo_provider record   `H.hashWithSalt` channelInfo_publicType record   `H.hashWithSalt` channelInfo_iconImage record   `H.hashWithSalt` channelInfo_permissions record   `H.hashWithSalt` channelInfo_iconThumbnailImage record   `H.hashWithSalt` channelInfo_channelConfigurations record  
instance QC.Arbitrary ChannelInfo where 
  arbitrary = M.liftM ChannelInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelInfo{channelInfo_channelId = channelInfo_channelId obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_channelId = channelInfo_channelId obj}
    , if obj == default_ChannelInfo{channelInfo_name = channelInfo_name obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_name = channelInfo_name obj}
    , if obj == default_ChannelInfo{channelInfo_entryPageUrl = channelInfo_entryPageUrl obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_entryPageUrl = channelInfo_entryPageUrl obj}
    , if obj == default_ChannelInfo{channelInfo_descriptionText = channelInfo_descriptionText obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_descriptionText = channelInfo_descriptionText obj}
    , if obj == default_ChannelInfo{channelInfo_provider = channelInfo_provider obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_provider = channelInfo_provider obj}
    , if obj == default_ChannelInfo{channelInfo_publicType = channelInfo_publicType obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_publicType = channelInfo_publicType obj}
    , if obj == default_ChannelInfo{channelInfo_iconImage = channelInfo_iconImage obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_iconImage = channelInfo_iconImage obj}
    , if obj == default_ChannelInfo{channelInfo_permissions = channelInfo_permissions obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_permissions = channelInfo_permissions obj}
    , if obj == default_ChannelInfo{channelInfo_iconThumbnailImage = channelInfo_iconThumbnailImage obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_iconThumbnailImage = channelInfo_iconThumbnailImage obj}
    , if obj == default_ChannelInfo{channelInfo_channelConfigurations = channelInfo_channelConfigurations obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_channelConfigurations = channelInfo_channelConfigurations obj}
    ]
from_ChannelInfo :: ChannelInfo -> T.ThriftVal
from_ChannelInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v34 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v34))) $ channelInfo_channelId record
  , (\_v34 -> P.Just (3, ("name",T.TString $ E.encodeUtf8 _v34))) $ channelInfo_name record
  , (\_v34 -> P.Just (4, ("entryPageUrl",T.TString $ E.encodeUtf8 _v34))) $ channelInfo_entryPageUrl record
  , (\_v34 -> P.Just (5, ("descriptionText",T.TString $ E.encodeUtf8 _v34))) $ channelInfo_descriptionText record
  , (\_v34 -> P.Just (6, ("provider",from_ChannelProvider _v34))) $ channelInfo_provider record
  , (\_v34 -> P.Just (7, ("publicType",T.TI32 $ P.fromIntegral $ P.fromEnum _v34))) $ channelInfo_publicType record
  , (\_v34 -> P.Just (8, ("iconImage",T.TString $ E.encodeUtf8 _v34))) $ channelInfo_iconImage record
  , (\_v34 -> P.Just (9, ("permissions",T.TList T.T_STRING $ P.map (\_v36 -> T.TString $ E.encodeUtf8 _v36) $ Vector.toList _v34))) $ channelInfo_permissions record
  , (\_v34 -> P.Just (11, ("iconThumbnailImage",T.TString $ E.encodeUtf8 _v34))) $ channelInfo_iconThumbnailImage record
  , (\_v34 -> P.Just (12, ("channelConfigurations",T.TList T.T_I32 $ P.map (\_v38 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v38) $ Vector.toList _v34))) $ channelInfo_channelConfigurations record
  ]
write_ChannelInfo :: T.Protocol p => p -> ChannelInfo -> P.IO ()
write_ChannelInfo oprot record = T.writeVal oprot $ from_ChannelInfo record
encode_ChannelInfo :: T.StatelessProtocol p => p -> ChannelInfo -> LBS.ByteString
encode_ChannelInfo oprot record = T.serializeVal oprot $ from_ChannelInfo record
to_ChannelInfo :: T.ThriftVal -> ChannelInfo
to_ChannelInfo (T.TStruct fields) = ChannelInfo{
  channelInfo_channelId = P.maybe (channelInfo_channelId default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TString _val41 -> E.decodeUtf8 _val41; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelInfo_name = P.maybe (channelInfo_name default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelInfo_entryPageUrl = P.maybe (channelInfo_entryPageUrl default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TString _val43 -> E.decodeUtf8 _val43; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  channelInfo_descriptionText = P.maybe (channelInfo_descriptionText default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TString _val44 -> E.decodeUtf8 _val44; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  channelInfo_provider = P.maybe (channelInfo_provider default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TStruct _val45 -> (to_ChannelProvider (T.TStruct _val45)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  channelInfo_publicType = P.maybe (channelInfo_publicType default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TI32 _val46 -> P.toEnum $ P.fromIntegral _val46; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  channelInfo_iconImage = P.maybe (channelInfo_iconImage default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TString _val47 -> E.decodeUtf8 _val47; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  channelInfo_permissions = P.maybe (channelInfo_permissions default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TList _ _val48 -> (Vector.fromList $ P.map (\_v49 -> (case _v49 of {T.TString _val50 -> E.decodeUtf8 _val50; _ -> P.error "wrong type"})) _val48); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  channelInfo_iconThumbnailImage = P.maybe (channelInfo_iconThumbnailImage default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TString _val51 -> E.decodeUtf8 _val51; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  channelInfo_channelConfigurations = P.maybe (channelInfo_channelConfigurations default_ChannelInfo) (\(_,_val40) -> (case _val40 of {T.TList _ _val52 -> (Vector.fromList $ P.map (\_v53 -> (case _v53 of {T.TI32 _val54 -> P.toEnum $ P.fromIntegral _val54; _ -> P.error "wrong type"})) _val52); _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_ChannelInfo _ = P.error "not a struct"
read_ChannelInfo :: T.Protocol p => p -> P.IO ChannelInfo
read_ChannelInfo iprot = to_ChannelInfo <$> T.readVal iprot (T.T_STRUCT typemap_ChannelInfo)
decode_ChannelInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelInfo
decode_ChannelInfo iprot bs = to_ChannelInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelInfo) bs
typemap_ChannelInfo :: T.TypeMap
typemap_ChannelInfo = Map.fromList [(1,("channelId",T.T_STRING)),(3,("name",T.T_STRING)),(4,("entryPageUrl",T.T_STRING)),(5,("descriptionText",T.T_STRING)),(6,("provider",(T.T_STRUCT typemap_ChannelProvider))),(7,("publicType",T.T_I32)),(8,("iconImage",T.T_STRING)),(9,("permissions",(T.T_LIST T.T_STRING))),(11,("iconThumbnailImage",T.T_STRING)),(12,("channelConfigurations",(T.T_LIST T.T_I32)))]
default_ChannelInfo :: ChannelInfo
default_ChannelInfo = ChannelInfo{
  channelInfo_channelId = "",
  channelInfo_name = "",
  channelInfo_entryPageUrl = "",
  channelInfo_descriptionText = "",
  channelInfo_provider = default_ChannelProvider,
  channelInfo_publicType = (P.toEnum 0),
  channelInfo_iconImage = "",
  channelInfo_permissions = Vector.empty,
  channelInfo_iconThumbnailImage = "",
  channelInfo_channelConfigurations = Vector.empty}
data ApprovedChannelInfo = ApprovedChannelInfo  { approvedChannelInfo_channelInfo :: ChannelInfo
  , approvedChannelInfo_approvedAt :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApprovedChannelInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` approvedChannelInfo_channelInfo record   `H.hashWithSalt` approvedChannelInfo_approvedAt record  
instance QC.Arbitrary ApprovedChannelInfo where 
  arbitrary = M.liftM ApprovedChannelInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApprovedChannelInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApprovedChannelInfo{approvedChannelInfo_channelInfo = approvedChannelInfo_channelInfo obj} then P.Nothing else P.Just $ default_ApprovedChannelInfo{approvedChannelInfo_channelInfo = approvedChannelInfo_channelInfo obj}
    , if obj == default_ApprovedChannelInfo{approvedChannelInfo_approvedAt = approvedChannelInfo_approvedAt obj} then P.Nothing else P.Just $ default_ApprovedChannelInfo{approvedChannelInfo_approvedAt = approvedChannelInfo_approvedAt obj}
    ]
from_ApprovedChannelInfo :: ApprovedChannelInfo -> T.ThriftVal
from_ApprovedChannelInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v57 -> P.Just (1, ("channelInfo",from_ChannelInfo _v57))) $ approvedChannelInfo_channelInfo record
  , (\_v57 -> P.Just (2, ("approvedAt",T.TI64 _v57))) $ approvedChannelInfo_approvedAt record
  ]
write_ApprovedChannelInfo :: T.Protocol p => p -> ApprovedChannelInfo -> P.IO ()
write_ApprovedChannelInfo oprot record = T.writeVal oprot $ from_ApprovedChannelInfo record
encode_ApprovedChannelInfo :: T.StatelessProtocol p => p -> ApprovedChannelInfo -> LBS.ByteString
encode_ApprovedChannelInfo oprot record = T.serializeVal oprot $ from_ApprovedChannelInfo record
to_ApprovedChannelInfo :: T.ThriftVal -> ApprovedChannelInfo
to_ApprovedChannelInfo (T.TStruct fields) = ApprovedChannelInfo{
  approvedChannelInfo_channelInfo = P.maybe (approvedChannelInfo_channelInfo default_ApprovedChannelInfo) (\(_,_val59) -> (case _val59 of {T.TStruct _val60 -> (to_ChannelInfo (T.TStruct _val60)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approvedChannelInfo_approvedAt = P.maybe (approvedChannelInfo_approvedAt default_ApprovedChannelInfo) (\(_,_val59) -> (case _val59 of {T.TI64 _val61 -> _val61; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApprovedChannelInfo _ = P.error "not a struct"
read_ApprovedChannelInfo :: T.Protocol p => p -> P.IO ApprovedChannelInfo
read_ApprovedChannelInfo iprot = to_ApprovedChannelInfo <$> T.readVal iprot (T.T_STRUCT typemap_ApprovedChannelInfo)
decode_ApprovedChannelInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> ApprovedChannelInfo
decode_ApprovedChannelInfo iprot bs = to_ApprovedChannelInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_ApprovedChannelInfo) bs
typemap_ApprovedChannelInfo :: T.TypeMap
typemap_ApprovedChannelInfo = Map.fromList [(1,("channelInfo",(T.T_STRUCT typemap_ChannelInfo))),(2,("approvedAt",T.T_I64))]
default_ApprovedChannelInfo :: ApprovedChannelInfo
default_ApprovedChannelInfo = ApprovedChannelInfo{
  approvedChannelInfo_channelInfo = default_ChannelInfo,
  approvedChannelInfo_approvedAt = 0}
data ApprovedChannelInfos = ApprovedChannelInfos  { approvedChannelInfos_approvedChannelInfos :: (Vector.Vector ApprovedChannelInfo)
  , approvedChannelInfos_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApprovedChannelInfos where
  hashWithSalt salt record = salt   `H.hashWithSalt` approvedChannelInfos_approvedChannelInfos record   `H.hashWithSalt` approvedChannelInfos_revision record  
instance QC.Arbitrary ApprovedChannelInfos where 
  arbitrary = M.liftM ApprovedChannelInfos (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApprovedChannelInfos = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApprovedChannelInfos{approvedChannelInfos_approvedChannelInfos = approvedChannelInfos_approvedChannelInfos obj} then P.Nothing else P.Just $ default_ApprovedChannelInfos{approvedChannelInfos_approvedChannelInfos = approvedChannelInfos_approvedChannelInfos obj}
    , if obj == default_ApprovedChannelInfos{approvedChannelInfos_revision = approvedChannelInfos_revision obj} then P.Nothing else P.Just $ default_ApprovedChannelInfos{approvedChannelInfos_revision = approvedChannelInfos_revision obj}
    ]
from_ApprovedChannelInfos :: ApprovedChannelInfos -> T.ThriftVal
from_ApprovedChannelInfos record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v64 -> P.Just (1, ("approvedChannelInfos",T.TList (T.T_STRUCT typemap_ApprovedChannelInfo) $ P.map (\_v66 -> from_ApprovedChannelInfo _v66) $ Vector.toList _v64))) $ approvedChannelInfos_approvedChannelInfos record
  , (\_v64 -> P.Just (2, ("revision",T.TI64 _v64))) $ approvedChannelInfos_revision record
  ]
write_ApprovedChannelInfos :: T.Protocol p => p -> ApprovedChannelInfos -> P.IO ()
write_ApprovedChannelInfos oprot record = T.writeVal oprot $ from_ApprovedChannelInfos record
encode_ApprovedChannelInfos :: T.StatelessProtocol p => p -> ApprovedChannelInfos -> LBS.ByteString
encode_ApprovedChannelInfos oprot record = T.serializeVal oprot $ from_ApprovedChannelInfos record
to_ApprovedChannelInfos :: T.ThriftVal -> ApprovedChannelInfos
to_ApprovedChannelInfos (T.TStruct fields) = ApprovedChannelInfos{
  approvedChannelInfos_approvedChannelInfos = P.maybe (approvedChannelInfos_approvedChannelInfos default_ApprovedChannelInfos) (\(_,_val68) -> (case _val68 of {T.TList _ _val69 -> (Vector.fromList $ P.map (\_v70 -> (case _v70 of {T.TStruct _val71 -> (to_ApprovedChannelInfo (T.TStruct _val71)); _ -> P.error "wrong type"})) _val69); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approvedChannelInfos_revision = P.maybe (approvedChannelInfos_revision default_ApprovedChannelInfos) (\(_,_val68) -> (case _val68 of {T.TI64 _val72 -> _val72; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApprovedChannelInfos _ = P.error "not a struct"
read_ApprovedChannelInfos :: T.Protocol p => p -> P.IO ApprovedChannelInfos
read_ApprovedChannelInfos iprot = to_ApprovedChannelInfos <$> T.readVal iprot (T.T_STRUCT typemap_ApprovedChannelInfos)
decode_ApprovedChannelInfos :: T.StatelessProtocol p => p -> LBS.ByteString -> ApprovedChannelInfos
decode_ApprovedChannelInfos iprot bs = to_ApprovedChannelInfos $ T.deserializeVal iprot (T.T_STRUCT typemap_ApprovedChannelInfos) bs
typemap_ApprovedChannelInfos :: T.TypeMap
typemap_ApprovedChannelInfos = Map.fromList [(1,("approvedChannelInfos",(T.T_LIST (T.T_STRUCT typemap_ApprovedChannelInfo)))),(2,("revision",T.T_I64))]
default_ApprovedChannelInfos :: ApprovedChannelInfos
default_ApprovedChannelInfos = ApprovedChannelInfos{
  approvedChannelInfos_approvedChannelInfos = Vector.empty,
  approvedChannelInfos_revision = 0}
data AuthQrcode = AuthQrcode  { authQrcode_qrcode :: LT.Text
  , authQrcode_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthQrcode where
  hashWithSalt salt record = salt   `H.hashWithSalt` authQrcode_qrcode record   `H.hashWithSalt` authQrcode_verifier record  
instance QC.Arbitrary AuthQrcode where 
  arbitrary = M.liftM AuthQrcode (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AuthQrcode = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthQrcode{authQrcode_qrcode = authQrcode_qrcode obj} then P.Nothing else P.Just $ default_AuthQrcode{authQrcode_qrcode = authQrcode_qrcode obj}
    , if obj == default_AuthQrcode{authQrcode_verifier = authQrcode_verifier obj} then P.Nothing else P.Just $ default_AuthQrcode{authQrcode_verifier = authQrcode_verifier obj}
    ]
from_AuthQrcode :: AuthQrcode -> T.ThriftVal
from_AuthQrcode record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v75 -> P.Just (1, ("qrcode",T.TString $ E.encodeUtf8 _v75))) $ authQrcode_qrcode record
  , (\_v75 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v75))) $ authQrcode_verifier record
  ]
write_AuthQrcode :: T.Protocol p => p -> AuthQrcode -> P.IO ()
write_AuthQrcode oprot record = T.writeVal oprot $ from_AuthQrcode record
encode_AuthQrcode :: T.StatelessProtocol p => p -> AuthQrcode -> LBS.ByteString
encode_AuthQrcode oprot record = T.serializeVal oprot $ from_AuthQrcode record
to_AuthQrcode :: T.ThriftVal -> AuthQrcode
to_AuthQrcode (T.TStruct fields) = AuthQrcode{
  authQrcode_qrcode = P.maybe (authQrcode_qrcode default_AuthQrcode) (\(_,_val77) -> (case _val77 of {T.TString _val78 -> E.decodeUtf8 _val78; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authQrcode_verifier = P.maybe (authQrcode_verifier default_AuthQrcode) (\(_,_val77) -> (case _val77 of {T.TString _val79 -> E.decodeUtf8 _val79; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AuthQrcode _ = P.error "not a struct"
read_AuthQrcode :: T.Protocol p => p -> P.IO AuthQrcode
read_AuthQrcode iprot = to_AuthQrcode <$> T.readVal iprot (T.T_STRUCT typemap_AuthQrcode)
decode_AuthQrcode :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthQrcode
decode_AuthQrcode iprot bs = to_AuthQrcode $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthQrcode) bs
typemap_AuthQrcode :: T.TypeMap
typemap_AuthQrcode = Map.fromList [(1,("qrcode",T.T_STRING)),(2,("verifier",T.T_STRING))]
default_AuthQrcode :: AuthQrcode
default_AuthQrcode = AuthQrcode{
  authQrcode_qrcode = "",
  authQrcode_verifier = ""}
data BuddyBanner = BuddyBanner  { buddyBanner_buddyBannerLinkType :: BuddyBannerLinkType
  , buddyBanner_buddyBannerLink :: LT.Text
  , buddyBanner_buddyBannerImageUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyBanner where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyBanner_buddyBannerLinkType record   `H.hashWithSalt` buddyBanner_buddyBannerLink record   `H.hashWithSalt` buddyBanner_buddyBannerImageUrl record  
instance QC.Arbitrary BuddyBanner where 
  arbitrary = M.liftM BuddyBanner (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyBanner = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyBanner{buddyBanner_buddyBannerLinkType = buddyBanner_buddyBannerLinkType obj} then P.Nothing else P.Just $ default_BuddyBanner{buddyBanner_buddyBannerLinkType = buddyBanner_buddyBannerLinkType obj}
    , if obj == default_BuddyBanner{buddyBanner_buddyBannerLink = buddyBanner_buddyBannerLink obj} then P.Nothing else P.Just $ default_BuddyBanner{buddyBanner_buddyBannerLink = buddyBanner_buddyBannerLink obj}
    , if obj == default_BuddyBanner{buddyBanner_buddyBannerImageUrl = buddyBanner_buddyBannerImageUrl obj} then P.Nothing else P.Just $ default_BuddyBanner{buddyBanner_buddyBannerImageUrl = buddyBanner_buddyBannerImageUrl obj}
    ]
from_BuddyBanner :: BuddyBanner -> T.ThriftVal
from_BuddyBanner record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v82 -> P.Just (1, ("buddyBannerLinkType",T.TI32 $ P.fromIntegral $ P.fromEnum _v82))) $ buddyBanner_buddyBannerLinkType record
  , (\_v82 -> P.Just (2, ("buddyBannerLink",T.TString $ E.encodeUtf8 _v82))) $ buddyBanner_buddyBannerLink record
  , (\_v82 -> P.Just (3, ("buddyBannerImageUrl",T.TString $ E.encodeUtf8 _v82))) $ buddyBanner_buddyBannerImageUrl record
  ]
write_BuddyBanner :: T.Protocol p => p -> BuddyBanner -> P.IO ()
write_BuddyBanner oprot record = T.writeVal oprot $ from_BuddyBanner record
encode_BuddyBanner :: T.StatelessProtocol p => p -> BuddyBanner -> LBS.ByteString
encode_BuddyBanner oprot record = T.serializeVal oprot $ from_BuddyBanner record
to_BuddyBanner :: T.ThriftVal -> BuddyBanner
to_BuddyBanner (T.TStruct fields) = BuddyBanner{
  buddyBanner_buddyBannerLinkType = P.maybe (buddyBanner_buddyBannerLinkType default_BuddyBanner) (\(_,_val84) -> (case _val84 of {T.TI32 _val85 -> P.toEnum $ P.fromIntegral _val85; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyBanner_buddyBannerLink = P.maybe (buddyBanner_buddyBannerLink default_BuddyBanner) (\(_,_val84) -> (case _val84 of {T.TString _val86 -> E.decodeUtf8 _val86; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyBanner_buddyBannerImageUrl = P.maybe (buddyBanner_buddyBannerImageUrl default_BuddyBanner) (\(_,_val84) -> (case _val84 of {T.TString _val87 -> E.decodeUtf8 _val87; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_BuddyBanner _ = P.error "not a struct"
read_BuddyBanner :: T.Protocol p => p -> P.IO BuddyBanner
read_BuddyBanner iprot = to_BuddyBanner <$> T.readVal iprot (T.T_STRUCT typemap_BuddyBanner)
decode_BuddyBanner :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyBanner
decode_BuddyBanner iprot bs = to_BuddyBanner $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyBanner) bs
typemap_BuddyBanner :: T.TypeMap
typemap_BuddyBanner = Map.fromList [(1,("buddyBannerLinkType",T.T_I32)),(2,("buddyBannerLink",T.T_STRING)),(3,("buddyBannerImageUrl",T.T_STRING))]
default_BuddyBanner :: BuddyBanner
default_BuddyBanner = BuddyBanner{
  buddyBanner_buddyBannerLinkType = (P.toEnum 0),
  buddyBanner_buddyBannerLink = "",
  buddyBanner_buddyBannerImageUrl = ""}
data BuddyDetail = BuddyDetail  { buddyDetail_mid :: LT.Text
  , buddyDetail_memberCount :: I.Int64
  , buddyDetail_onAir :: P.Bool
  , buddyDetail_businessAccount :: P.Bool
  , buddyDetail_addable :: P.Bool
  , buddyDetail_acceptableContentTypes :: (Set.HashSet ContentType)
  , buddyDetail_capableMyhome :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyDetail where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyDetail_mid record   `H.hashWithSalt` buddyDetail_memberCount record   `H.hashWithSalt` buddyDetail_onAir record   `H.hashWithSalt` buddyDetail_businessAccount record   `H.hashWithSalt` buddyDetail_addable record   `H.hashWithSalt` buddyDetail_acceptableContentTypes record   `H.hashWithSalt` buddyDetail_capableMyhome record  
instance QC.Arbitrary BuddyDetail where 
  arbitrary = M.liftM BuddyDetail (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyDetail = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyDetail{buddyDetail_mid = buddyDetail_mid obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_mid = buddyDetail_mid obj}
    , if obj == default_BuddyDetail{buddyDetail_memberCount = buddyDetail_memberCount obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_memberCount = buddyDetail_memberCount obj}
    , if obj == default_BuddyDetail{buddyDetail_onAir = buddyDetail_onAir obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_onAir = buddyDetail_onAir obj}
    , if obj == default_BuddyDetail{buddyDetail_businessAccount = buddyDetail_businessAccount obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_businessAccount = buddyDetail_businessAccount obj}
    , if obj == default_BuddyDetail{buddyDetail_addable = buddyDetail_addable obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_addable = buddyDetail_addable obj}
    , if obj == default_BuddyDetail{buddyDetail_acceptableContentTypes = buddyDetail_acceptableContentTypes obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_acceptableContentTypes = buddyDetail_acceptableContentTypes obj}
    , if obj == default_BuddyDetail{buddyDetail_capableMyhome = buddyDetail_capableMyhome obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_capableMyhome = buddyDetail_capableMyhome obj}
    ]
from_BuddyDetail :: BuddyDetail -> T.ThriftVal
from_BuddyDetail record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v90 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v90))) $ buddyDetail_mid record
  , (\_v90 -> P.Just (2, ("memberCount",T.TI64 _v90))) $ buddyDetail_memberCount record
  , (\_v90 -> P.Just (3, ("onAir",T.TBool _v90))) $ buddyDetail_onAir record
  , (\_v90 -> P.Just (4, ("businessAccount",T.TBool _v90))) $ buddyDetail_businessAccount record
  , (\_v90 -> P.Just (5, ("addable",T.TBool _v90))) $ buddyDetail_addable record
  , (\_v90 -> P.Just (6, ("acceptableContentTypes",T.TSet T.T_I32 $ P.map (\_v92 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v92) $ Set.toList _v90))) $ buddyDetail_acceptableContentTypes record
  , (\_v90 -> P.Just (7, ("capableMyhome",T.TBool _v90))) $ buddyDetail_capableMyhome record
  ]
write_BuddyDetail :: T.Protocol p => p -> BuddyDetail -> P.IO ()
write_BuddyDetail oprot record = T.writeVal oprot $ from_BuddyDetail record
encode_BuddyDetail :: T.StatelessProtocol p => p -> BuddyDetail -> LBS.ByteString
encode_BuddyDetail oprot record = T.serializeVal oprot $ from_BuddyDetail record
to_BuddyDetail :: T.ThriftVal -> BuddyDetail
to_BuddyDetail (T.TStruct fields) = BuddyDetail{
  buddyDetail_mid = P.maybe (buddyDetail_mid default_BuddyDetail) (\(_,_val94) -> (case _val94 of {T.TString _val95 -> E.decodeUtf8 _val95; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyDetail_memberCount = P.maybe (buddyDetail_memberCount default_BuddyDetail) (\(_,_val94) -> (case _val94 of {T.TI64 _val96 -> _val96; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyDetail_onAir = P.maybe (buddyDetail_onAir default_BuddyDetail) (\(_,_val94) -> (case _val94 of {T.TBool _val97 -> _val97; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyDetail_businessAccount = P.maybe (buddyDetail_businessAccount default_BuddyDetail) (\(_,_val94) -> (case _val94 of {T.TBool _val98 -> _val98; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyDetail_addable = P.maybe (buddyDetail_addable default_BuddyDetail) (\(_,_val94) -> (case _val94 of {T.TBool _val99 -> _val99; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddyDetail_acceptableContentTypes = P.maybe (buddyDetail_acceptableContentTypes default_BuddyDetail) (\(_,_val94) -> (case _val94 of {T.TSet _ _val100 -> (Set.fromList $ P.map (\_v101 -> (case _v101 of {T.TI32 _val102 -> P.toEnum $ P.fromIntegral _val102; _ -> P.error "wrong type"})) _val100); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  buddyDetail_capableMyhome = P.maybe (buddyDetail_capableMyhome default_BuddyDetail) (\(_,_val94) -> (case _val94 of {T.TBool _val103 -> _val103; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_BuddyDetail _ = P.error "not a struct"
read_BuddyDetail :: T.Protocol p => p -> P.IO BuddyDetail
read_BuddyDetail iprot = to_BuddyDetail <$> T.readVal iprot (T.T_STRUCT typemap_BuddyDetail)
decode_BuddyDetail :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyDetail
decode_BuddyDetail iprot bs = to_BuddyDetail $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyDetail) bs
typemap_BuddyDetail :: T.TypeMap
typemap_BuddyDetail = Map.fromList [(1,("mid",T.T_STRING)),(2,("memberCount",T.T_I64)),(3,("onAir",T.T_BOOL)),(4,("businessAccount",T.T_BOOL)),(5,("addable",T.T_BOOL)),(6,("acceptableContentTypes",(T.T_SET T.T_I32))),(7,("capableMyhome",T.T_BOOL))]
default_BuddyDetail :: BuddyDetail
default_BuddyDetail = BuddyDetail{
  buddyDetail_mid = "",
  buddyDetail_memberCount = 0,
  buddyDetail_onAir = P.False,
  buddyDetail_businessAccount = P.False,
  buddyDetail_addable = P.False,
  buddyDetail_acceptableContentTypes = Set.empty,
  buddyDetail_capableMyhome = P.False}
data Contact = Contact  { contact_mid :: LT.Text
  , contact_createdTime :: I.Int64
  , contact_type :: ContactType
  , contact_status :: ContactStatus
  , contact_relation :: ContactRelation
  , contact_displayName :: LT.Text
  , contact_phoneticName :: LT.Text
  , contact_pictureStatus :: LT.Text
  , contact_thumbnailUrl :: LT.Text
  , contact_statusMessage :: LT.Text
  , contact_displayNameOverridden :: LT.Text
  , contact_favoriteTime :: I.Int64
  , contact_capableVoiceCall :: P.Bool
  , contact_capableVideoCall :: P.Bool
  , contact_capableMyhome :: P.Bool
  , contact_capableBuddy :: P.Bool
  , contact_attributes :: I.Int32
  , contact_settings :: I.Int64
  , contact_picturePath :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Contact where
  hashWithSalt salt record = salt   `H.hashWithSalt` contact_mid record   `H.hashWithSalt` contact_createdTime record   `H.hashWithSalt` contact_type record   `H.hashWithSalt` contact_status record   `H.hashWithSalt` contact_relation record   `H.hashWithSalt` contact_displayName record   `H.hashWithSalt` contact_phoneticName record   `H.hashWithSalt` contact_pictureStatus record   `H.hashWithSalt` contact_thumbnailUrl record   `H.hashWithSalt` contact_statusMessage record   `H.hashWithSalt` contact_displayNameOverridden record   `H.hashWithSalt` contact_favoriteTime record   `H.hashWithSalt` contact_capableVoiceCall record   `H.hashWithSalt` contact_capableVideoCall record   `H.hashWithSalt` contact_capableMyhome record   `H.hashWithSalt` contact_capableBuddy record   `H.hashWithSalt` contact_attributes record   `H.hashWithSalt` contact_settings record   `H.hashWithSalt` contact_picturePath record  
instance QC.Arbitrary Contact where 
  arbitrary = M.liftM Contact (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Contact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Contact{contact_mid = contact_mid obj} then P.Nothing else P.Just $ default_Contact{contact_mid = contact_mid obj}
    , if obj == default_Contact{contact_createdTime = contact_createdTime obj} then P.Nothing else P.Just $ default_Contact{contact_createdTime = contact_createdTime obj}
    , if obj == default_Contact{contact_type = contact_type obj} then P.Nothing else P.Just $ default_Contact{contact_type = contact_type obj}
    , if obj == default_Contact{contact_status = contact_status obj} then P.Nothing else P.Just $ default_Contact{contact_status = contact_status obj}
    , if obj == default_Contact{contact_relation = contact_relation obj} then P.Nothing else P.Just $ default_Contact{contact_relation = contact_relation obj}
    , if obj == default_Contact{contact_displayName = contact_displayName obj} then P.Nothing else P.Just $ default_Contact{contact_displayName = contact_displayName obj}
    , if obj == default_Contact{contact_phoneticName = contact_phoneticName obj} then P.Nothing else P.Just $ default_Contact{contact_phoneticName = contact_phoneticName obj}
    , if obj == default_Contact{contact_pictureStatus = contact_pictureStatus obj} then P.Nothing else P.Just $ default_Contact{contact_pictureStatus = contact_pictureStatus obj}
    , if obj == default_Contact{contact_thumbnailUrl = contact_thumbnailUrl obj} then P.Nothing else P.Just $ default_Contact{contact_thumbnailUrl = contact_thumbnailUrl obj}
    , if obj == default_Contact{contact_statusMessage = contact_statusMessage obj} then P.Nothing else P.Just $ default_Contact{contact_statusMessage = contact_statusMessage obj}
    , if obj == default_Contact{contact_displayNameOverridden = contact_displayNameOverridden obj} then P.Nothing else P.Just $ default_Contact{contact_displayNameOverridden = contact_displayNameOverridden obj}
    , if obj == default_Contact{contact_favoriteTime = contact_favoriteTime obj} then P.Nothing else P.Just $ default_Contact{contact_favoriteTime = contact_favoriteTime obj}
    , if obj == default_Contact{contact_capableVoiceCall = contact_capableVoiceCall obj} then P.Nothing else P.Just $ default_Contact{contact_capableVoiceCall = contact_capableVoiceCall obj}
    , if obj == default_Contact{contact_capableVideoCall = contact_capableVideoCall obj} then P.Nothing else P.Just $ default_Contact{contact_capableVideoCall = contact_capableVideoCall obj}
    , if obj == default_Contact{contact_capableMyhome = contact_capableMyhome obj} then P.Nothing else P.Just $ default_Contact{contact_capableMyhome = contact_capableMyhome obj}
    , if obj == default_Contact{contact_capableBuddy = contact_capableBuddy obj} then P.Nothing else P.Just $ default_Contact{contact_capableBuddy = contact_capableBuddy obj}
    , if obj == default_Contact{contact_attributes = contact_attributes obj} then P.Nothing else P.Just $ default_Contact{contact_attributes = contact_attributes obj}
    , if obj == default_Contact{contact_settings = contact_settings obj} then P.Nothing else P.Just $ default_Contact{contact_settings = contact_settings obj}
    , if obj == default_Contact{contact_picturePath = contact_picturePath obj} then P.Nothing else P.Just $ default_Contact{contact_picturePath = contact_picturePath obj}
    ]
from_Contact :: Contact -> T.ThriftVal
from_Contact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v106 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v106))) $ contact_mid record
  , (\_v106 -> P.Just (2, ("createdTime",T.TI64 _v106))) $ contact_createdTime record
  , (\_v106 -> P.Just (10, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v106))) $ contact_type record
  , (\_v106 -> P.Just (11, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v106))) $ contact_status record
  , (\_v106 -> P.Just (21, ("relation",T.TI32 $ P.fromIntegral $ P.fromEnum _v106))) $ contact_relation record
  , (\_v106 -> P.Just (22, ("displayName",T.TString $ E.encodeUtf8 _v106))) $ contact_displayName record
  , (\_v106 -> P.Just (23, ("phoneticName",T.TString $ E.encodeUtf8 _v106))) $ contact_phoneticName record
  , (\_v106 -> P.Just (24, ("pictureStatus",T.TString $ E.encodeUtf8 _v106))) $ contact_pictureStatus record
  , (\_v106 -> P.Just (25, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v106))) $ contact_thumbnailUrl record
  , (\_v106 -> P.Just (26, ("statusMessage",T.TString $ E.encodeUtf8 _v106))) $ contact_statusMessage record
  , (\_v106 -> P.Just (27, ("displayNameOverridden",T.TString $ E.encodeUtf8 _v106))) $ contact_displayNameOverridden record
  , (\_v106 -> P.Just (28, ("favoriteTime",T.TI64 _v106))) $ contact_favoriteTime record
  , (\_v106 -> P.Just (31, ("capableVoiceCall",T.TBool _v106))) $ contact_capableVoiceCall record
  , (\_v106 -> P.Just (32, ("capableVideoCall",T.TBool _v106))) $ contact_capableVideoCall record
  , (\_v106 -> P.Just (33, ("capableMyhome",T.TBool _v106))) $ contact_capableMyhome record
  , (\_v106 -> P.Just (34, ("capableBuddy",T.TBool _v106))) $ contact_capableBuddy record
  , (\_v106 -> P.Just (35, ("attributes",T.TI32 _v106))) $ contact_attributes record
  , (\_v106 -> P.Just (36, ("settings",T.TI64 _v106))) $ contact_settings record
  , (\_v106 -> P.Just (37, ("picturePath",T.TString $ E.encodeUtf8 _v106))) $ contact_picturePath record
  ]
write_Contact :: T.Protocol p => p -> Contact -> P.IO ()
write_Contact oprot record = T.writeVal oprot $ from_Contact record
encode_Contact :: T.StatelessProtocol p => p -> Contact -> LBS.ByteString
encode_Contact oprot record = T.serializeVal oprot $ from_Contact record
to_Contact :: T.ThriftVal -> Contact
to_Contact (T.TStruct fields) = Contact{
  contact_mid = P.maybe (contact_mid default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val109 -> E.decodeUtf8 _val109; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contact_createdTime = P.maybe (contact_createdTime default_Contact) (\(_,_val108) -> (case _val108 of {T.TI64 _val110 -> _val110; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contact_type = P.maybe (contact_type default_Contact) (\(_,_val108) -> (case _val108 of {T.TI32 _val111 -> P.toEnum $ P.fromIntegral _val111; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  contact_status = P.maybe (contact_status default_Contact) (\(_,_val108) -> (case _val108 of {T.TI32 _val112 -> P.toEnum $ P.fromIntegral _val112; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  contact_relation = P.maybe (contact_relation default_Contact) (\(_,_val108) -> (case _val108 of {T.TI32 _val113 -> P.toEnum $ P.fromIntegral _val113; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  contact_displayName = P.maybe (contact_displayName default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val114 -> E.decodeUtf8 _val114; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  contact_phoneticName = P.maybe (contact_phoneticName default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val115 -> E.decodeUtf8 _val115; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  contact_pictureStatus = P.maybe (contact_pictureStatus default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val116 -> E.decodeUtf8 _val116; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  contact_thumbnailUrl = P.maybe (contact_thumbnailUrl default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val117 -> E.decodeUtf8 _val117; _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  contact_statusMessage = P.maybe (contact_statusMessage default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val118 -> E.decodeUtf8 _val118; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  contact_displayNameOverridden = P.maybe (contact_displayNameOverridden default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val119 -> E.decodeUtf8 _val119; _ -> P.error "wrong type"})) (Map.lookup (27) fields),
  contact_favoriteTime = P.maybe (contact_favoriteTime default_Contact) (\(_,_val108) -> (case _val108 of {T.TI64 _val120 -> _val120; _ -> P.error "wrong type"})) (Map.lookup (28) fields),
  contact_capableVoiceCall = P.maybe (contact_capableVoiceCall default_Contact) (\(_,_val108) -> (case _val108 of {T.TBool _val121 -> _val121; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  contact_capableVideoCall = P.maybe (contact_capableVideoCall default_Contact) (\(_,_val108) -> (case _val108 of {T.TBool _val122 -> _val122; _ -> P.error "wrong type"})) (Map.lookup (32) fields),
  contact_capableMyhome = P.maybe (contact_capableMyhome default_Contact) (\(_,_val108) -> (case _val108 of {T.TBool _val123 -> _val123; _ -> P.error "wrong type"})) (Map.lookup (33) fields),
  contact_capableBuddy = P.maybe (contact_capableBuddy default_Contact) (\(_,_val108) -> (case _val108 of {T.TBool _val124 -> _val124; _ -> P.error "wrong type"})) (Map.lookup (34) fields),
  contact_attributes = P.maybe (contact_attributes default_Contact) (\(_,_val108) -> (case _val108 of {T.TI32 _val125 -> _val125; _ -> P.error "wrong type"})) (Map.lookup (35) fields),
  contact_settings = P.maybe (contact_settings default_Contact) (\(_,_val108) -> (case _val108 of {T.TI64 _val126 -> _val126; _ -> P.error "wrong type"})) (Map.lookup (36) fields),
  contact_picturePath = P.maybe (contact_picturePath default_Contact) (\(_,_val108) -> (case _val108 of {T.TString _val127 -> E.decodeUtf8 _val127; _ -> P.error "wrong type"})) (Map.lookup (37) fields)
  }
to_Contact _ = P.error "not a struct"
read_Contact :: T.Protocol p => p -> P.IO Contact
read_Contact iprot = to_Contact <$> T.readVal iprot (T.T_STRUCT typemap_Contact)
decode_Contact :: T.StatelessProtocol p => p -> LBS.ByteString -> Contact
decode_Contact iprot bs = to_Contact $ T.deserializeVal iprot (T.T_STRUCT typemap_Contact) bs
typemap_Contact :: T.TypeMap
typemap_Contact = Map.fromList [(1,("mid",T.T_STRING)),(2,("createdTime",T.T_I64)),(10,("type",T.T_I32)),(11,("status",T.T_I32)),(21,("relation",T.T_I32)),(22,("displayName",T.T_STRING)),(23,("phoneticName",T.T_STRING)),(24,("pictureStatus",T.T_STRING)),(25,("thumbnailUrl",T.T_STRING)),(26,("statusMessage",T.T_STRING)),(27,("displayNameOverridden",T.T_STRING)),(28,("favoriteTime",T.T_I64)),(31,("capableVoiceCall",T.T_BOOL)),(32,("capableVideoCall",T.T_BOOL)),(33,("capableMyhome",T.T_BOOL)),(34,("capableBuddy",T.T_BOOL)),(35,("attributes",T.T_I32)),(36,("settings",T.T_I64)),(37,("picturePath",T.T_STRING))]
default_Contact :: Contact
default_Contact = Contact{
  contact_mid = "",
  contact_createdTime = 0,
  contact_type = (P.toEnum 0),
  contact_status = (P.toEnum 0),
  contact_relation = (P.toEnum 0),
  contact_displayName = "",
  contact_phoneticName = "",
  contact_pictureStatus = "",
  contact_thumbnailUrl = "",
  contact_statusMessage = "",
  contact_displayNameOverridden = "",
  contact_favoriteTime = 0,
  contact_capableVoiceCall = P.False,
  contact_capableVideoCall = P.False,
  contact_capableMyhome = P.False,
  contact_capableBuddy = P.False,
  contact_attributes = 0,
  contact_settings = 0,
  contact_picturePath = ""}
data BuddyList = BuddyList  { buddyList_classification :: LT.Text
  , buddyList_displayName :: LT.Text
  , buddyList_totalBuddyCount :: I.Int32
  , buddyList_popularContacts :: (Vector.Vector Contact)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyList where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyList_classification record   `H.hashWithSalt` buddyList_displayName record   `H.hashWithSalt` buddyList_totalBuddyCount record   `H.hashWithSalt` buddyList_popularContacts record  
instance QC.Arbitrary BuddyList where 
  arbitrary = M.liftM BuddyList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyList{buddyList_classification = buddyList_classification obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_classification = buddyList_classification obj}
    , if obj == default_BuddyList{buddyList_displayName = buddyList_displayName obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_displayName = buddyList_displayName obj}
    , if obj == default_BuddyList{buddyList_totalBuddyCount = buddyList_totalBuddyCount obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_totalBuddyCount = buddyList_totalBuddyCount obj}
    , if obj == default_BuddyList{buddyList_popularContacts = buddyList_popularContacts obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_popularContacts = buddyList_popularContacts obj}
    ]
from_BuddyList :: BuddyList -> T.ThriftVal
from_BuddyList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v130 -> P.Just (1, ("classification",T.TString $ E.encodeUtf8 _v130))) $ buddyList_classification record
  , (\_v130 -> P.Just (2, ("displayName",T.TString $ E.encodeUtf8 _v130))) $ buddyList_displayName record
  , (\_v130 -> P.Just (3, ("totalBuddyCount",T.TI32 _v130))) $ buddyList_totalBuddyCount record
  , (\_v130 -> P.Just (4, ("popularContacts",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v132 -> from_Contact _v132) $ Vector.toList _v130))) $ buddyList_popularContacts record
  ]
write_BuddyList :: T.Protocol p => p -> BuddyList -> P.IO ()
write_BuddyList oprot record = T.writeVal oprot $ from_BuddyList record
encode_BuddyList :: T.StatelessProtocol p => p -> BuddyList -> LBS.ByteString
encode_BuddyList oprot record = T.serializeVal oprot $ from_BuddyList record
to_BuddyList :: T.ThriftVal -> BuddyList
to_BuddyList (T.TStruct fields) = BuddyList{
  buddyList_classification = P.maybe (buddyList_classification default_BuddyList) (\(_,_val134) -> (case _val134 of {T.TString _val135 -> E.decodeUtf8 _val135; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyList_displayName = P.maybe (buddyList_displayName default_BuddyList) (\(_,_val134) -> (case _val134 of {T.TString _val136 -> E.decodeUtf8 _val136; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyList_totalBuddyCount = P.maybe (buddyList_totalBuddyCount default_BuddyList) (\(_,_val134) -> (case _val134 of {T.TI32 _val137 -> _val137; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyList_popularContacts = P.maybe (buddyList_popularContacts default_BuddyList) (\(_,_val134) -> (case _val134 of {T.TList _ _val138 -> (Vector.fromList $ P.map (\_v139 -> (case _v139 of {T.TStruct _val140 -> (to_Contact (T.TStruct _val140)); _ -> P.error "wrong type"})) _val138); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_BuddyList _ = P.error "not a struct"
read_BuddyList :: T.Protocol p => p -> P.IO BuddyList
read_BuddyList iprot = to_BuddyList <$> T.readVal iprot (T.T_STRUCT typemap_BuddyList)
decode_BuddyList :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyList
decode_BuddyList iprot bs = to_BuddyList $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyList) bs
typemap_BuddyList :: T.TypeMap
typemap_BuddyList = Map.fromList [(1,("classification",T.T_STRING)),(2,("displayName",T.T_STRING)),(3,("totalBuddyCount",T.T_I32)),(4,("popularContacts",(T.T_LIST (T.T_STRUCT typemap_Contact))))]
default_BuddyList :: BuddyList
default_BuddyList = BuddyList{
  buddyList_classification = "",
  buddyList_displayName = "",
  buddyList_totalBuddyCount = 0,
  buddyList_popularContacts = Vector.empty}
data Location = Location  { location_title :: LT.Text
  , location_address :: LT.Text
  , location_latitude :: P.Double
  , location_longitude :: P.Double
  , location_phone :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Location where
  hashWithSalt salt record = salt   `H.hashWithSalt` location_title record   `H.hashWithSalt` location_address record   `H.hashWithSalt` location_latitude record   `H.hashWithSalt` location_longitude record   `H.hashWithSalt` location_phone record  
instance QC.Arbitrary Location where 
  arbitrary = M.liftM Location (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Location = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Location{location_title = location_title obj} then P.Nothing else P.Just $ default_Location{location_title = location_title obj}
    , if obj == default_Location{location_address = location_address obj} then P.Nothing else P.Just $ default_Location{location_address = location_address obj}
    , if obj == default_Location{location_latitude = location_latitude obj} then P.Nothing else P.Just $ default_Location{location_latitude = location_latitude obj}
    , if obj == default_Location{location_longitude = location_longitude obj} then P.Nothing else P.Just $ default_Location{location_longitude = location_longitude obj}
    , if obj == default_Location{location_phone = location_phone obj} then P.Nothing else P.Just $ default_Location{location_phone = location_phone obj}
    ]
from_Location :: Location -> T.ThriftVal
from_Location record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v143 -> P.Just (1, ("title",T.TString $ E.encodeUtf8 _v143))) $ location_title record
  , (\_v143 -> P.Just (2, ("address",T.TString $ E.encodeUtf8 _v143))) $ location_address record
  , (\_v143 -> P.Just (3, ("latitude",T.TDouble _v143))) $ location_latitude record
  , (\_v143 -> P.Just (4, ("longitude",T.TDouble _v143))) $ location_longitude record
  , (\_v143 -> P.Just (5, ("phone",T.TString $ E.encodeUtf8 _v143))) $ location_phone record
  ]
write_Location :: T.Protocol p => p -> Location -> P.IO ()
write_Location oprot record = T.writeVal oprot $ from_Location record
encode_Location :: T.StatelessProtocol p => p -> Location -> LBS.ByteString
encode_Location oprot record = T.serializeVal oprot $ from_Location record
to_Location :: T.ThriftVal -> Location
to_Location (T.TStruct fields) = Location{
  location_title = P.maybe (location_title default_Location) (\(_,_val145) -> (case _val145 of {T.TString _val146 -> E.decodeUtf8 _val146; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  location_address = P.maybe (location_address default_Location) (\(_,_val145) -> (case _val145 of {T.TString _val147 -> E.decodeUtf8 _val147; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  location_latitude = P.maybe (location_latitude default_Location) (\(_,_val145) -> (case _val145 of {T.TDouble _val148 -> _val148; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  location_longitude = P.maybe (location_longitude default_Location) (\(_,_val145) -> (case _val145 of {T.TDouble _val149 -> _val149; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  location_phone = P.maybe (location_phone default_Location) (\(_,_val145) -> (case _val145 of {T.TString _val150 -> E.decodeUtf8 _val150; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Location _ = P.error "not a struct"
read_Location :: T.Protocol p => p -> P.IO Location
read_Location iprot = to_Location <$> T.readVal iprot (T.T_STRUCT typemap_Location)
decode_Location :: T.StatelessProtocol p => p -> LBS.ByteString -> Location
decode_Location iprot bs = to_Location $ T.deserializeVal iprot (T.T_STRUCT typemap_Location) bs
typemap_Location :: T.TypeMap
typemap_Location = Map.fromList [(1,("title",T.T_STRING)),(2,("address",T.T_STRING)),(3,("latitude",T.T_DOUBLE)),(4,("longitude",T.T_DOUBLE)),(5,("phone",T.T_STRING))]
default_Location :: Location
default_Location = Location{
  location_title = "",
  location_address = "",
  location_latitude = 0,
  location_longitude = 0,
  location_phone = ""}
data BuddyMessageRequest = BuddyMessageRequest  { buddyMessageRequest_contentType :: ContentType
  , buddyMessageRequest_text :: LT.Text
  , buddyMessageRequest_location :: Location
  , buddyMessageRequest_content :: LBS.ByteString
  , buddyMessageRequest_contentMetadata :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyMessageRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyMessageRequest_contentType record   `H.hashWithSalt` buddyMessageRequest_text record   `H.hashWithSalt` buddyMessageRequest_location record   `H.hashWithSalt` buddyMessageRequest_content record   `H.hashWithSalt` buddyMessageRequest_contentMetadata record  
instance QC.Arbitrary BuddyMessageRequest where 
  arbitrary = M.liftM BuddyMessageRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyMessageRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyMessageRequest{buddyMessageRequest_contentType = buddyMessageRequest_contentType obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_contentType = buddyMessageRequest_contentType obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_text = buddyMessageRequest_text obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_text = buddyMessageRequest_text obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_location = buddyMessageRequest_location obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_location = buddyMessageRequest_location obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_content = buddyMessageRequest_content obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_content = buddyMessageRequest_content obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_contentMetadata = buddyMessageRequest_contentMetadata obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_contentMetadata = buddyMessageRequest_contentMetadata obj}
    ]
from_BuddyMessageRequest :: BuddyMessageRequest -> T.ThriftVal
from_BuddyMessageRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v153 -> P.Just (1, ("contentType",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ buddyMessageRequest_contentType record
  , (\_v153 -> P.Just (2, ("text",T.TString $ E.encodeUtf8 _v153))) $ buddyMessageRequest_text record
  , (\_v153 -> P.Just (3, ("location",from_Location _v153))) $ buddyMessageRequest_location record
  , (\_v153 -> P.Just (4, ("content",T.TBinary _v153))) $ buddyMessageRequest_content record
  , (\_v153 -> P.Just (5, ("contentMetadata",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k154,_v155) -> (T.TString $ E.encodeUtf8 _k154, T.TString $ E.encodeUtf8 _v155)) $ Map.toList _v153))) $ buddyMessageRequest_contentMetadata record
  ]
write_BuddyMessageRequest :: T.Protocol p => p -> BuddyMessageRequest -> P.IO ()
write_BuddyMessageRequest oprot record = T.writeVal oprot $ from_BuddyMessageRequest record
encode_BuddyMessageRequest :: T.StatelessProtocol p => p -> BuddyMessageRequest -> LBS.ByteString
encode_BuddyMessageRequest oprot record = T.serializeVal oprot $ from_BuddyMessageRequest record
to_BuddyMessageRequest :: T.ThriftVal -> BuddyMessageRequest
to_BuddyMessageRequest (T.TStruct fields) = BuddyMessageRequest{
  buddyMessageRequest_contentType = P.maybe (buddyMessageRequest_contentType default_BuddyMessageRequest) (\(_,_val157) -> (case _val157 of {T.TI32 _val158 -> P.toEnum $ P.fromIntegral _val158; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyMessageRequest_text = P.maybe (buddyMessageRequest_text default_BuddyMessageRequest) (\(_,_val157) -> (case _val157 of {T.TString _val159 -> E.decodeUtf8 _val159; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyMessageRequest_location = P.maybe (buddyMessageRequest_location default_BuddyMessageRequest) (\(_,_val157) -> (case _val157 of {T.TStruct _val160 -> (to_Location (T.TStruct _val160)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyMessageRequest_content = P.maybe (buddyMessageRequest_content default_BuddyMessageRequest) (\(_,_val157) -> (case _val157 of {T.TBinary _val161 -> _val161; T.TString _val161 -> _val161; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyMessageRequest_contentMetadata = P.maybe (buddyMessageRequest_contentMetadata default_BuddyMessageRequest) (\(_,_val157) -> (case _val157 of {T.TMap _ _ _val162 -> (Map.fromList $ P.map (\(_k164,_v163) -> ((case _k164 of {T.TString _val165 -> E.decodeUtf8 _val165; _ -> P.error "wrong type"}),(case _v163 of {T.TString _val166 -> E.decodeUtf8 _val166; _ -> P.error "wrong type"}))) _val162); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_BuddyMessageRequest _ = P.error "not a struct"
read_BuddyMessageRequest :: T.Protocol p => p -> P.IO BuddyMessageRequest
read_BuddyMessageRequest iprot = to_BuddyMessageRequest <$> T.readVal iprot (T.T_STRUCT typemap_BuddyMessageRequest)
decode_BuddyMessageRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyMessageRequest
decode_BuddyMessageRequest iprot bs = to_BuddyMessageRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyMessageRequest) bs
typemap_BuddyMessageRequest :: T.TypeMap
typemap_BuddyMessageRequest = Map.fromList [(1,("contentType",T.T_I32)),(2,("text",T.T_STRING)),(3,("location",(T.T_STRUCT typemap_Location))),(4,("content",T.T_BINARY)),(5,("contentMetadata",(T.T_MAP T.T_STRING T.T_STRING)))]
default_BuddyMessageRequest :: BuddyMessageRequest
default_BuddyMessageRequest = BuddyMessageRequest{
  buddyMessageRequest_contentType = (P.toEnum 0),
  buddyMessageRequest_text = "",
  buddyMessageRequest_location = default_Location,
  buddyMessageRequest_content = "",
  buddyMessageRequest_contentMetadata = Map.empty}
data BuddyOnAirUrls = BuddyOnAirUrls  { buddyOnAirUrls_hls :: (Map.HashMap LT.Text LT.Text)
  , buddyOnAirUrls_smoothStreaming :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyOnAirUrls where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyOnAirUrls_hls record   `H.hashWithSalt` buddyOnAirUrls_smoothStreaming record  
instance QC.Arbitrary BuddyOnAirUrls where 
  arbitrary = M.liftM BuddyOnAirUrls (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyOnAirUrls = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyOnAirUrls{buddyOnAirUrls_hls = buddyOnAirUrls_hls obj} then P.Nothing else P.Just $ default_BuddyOnAirUrls{buddyOnAirUrls_hls = buddyOnAirUrls_hls obj}
    , if obj == default_BuddyOnAirUrls{buddyOnAirUrls_smoothStreaming = buddyOnAirUrls_smoothStreaming obj} then P.Nothing else P.Just $ default_BuddyOnAirUrls{buddyOnAirUrls_smoothStreaming = buddyOnAirUrls_smoothStreaming obj}
    ]
from_BuddyOnAirUrls :: BuddyOnAirUrls -> T.ThriftVal
from_BuddyOnAirUrls record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v169 -> P.Just (1, ("hls",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k170,_v171) -> (T.TString $ E.encodeUtf8 _k170, T.TString $ E.encodeUtf8 _v171)) $ Map.toList _v169))) $ buddyOnAirUrls_hls record
  , (\_v169 -> P.Just (2, ("smoothStreaming",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k172,_v173) -> (T.TString $ E.encodeUtf8 _k172, T.TString $ E.encodeUtf8 _v173)) $ Map.toList _v169))) $ buddyOnAirUrls_smoothStreaming record
  ]
write_BuddyOnAirUrls :: T.Protocol p => p -> BuddyOnAirUrls -> P.IO ()
write_BuddyOnAirUrls oprot record = T.writeVal oprot $ from_BuddyOnAirUrls record
encode_BuddyOnAirUrls :: T.StatelessProtocol p => p -> BuddyOnAirUrls -> LBS.ByteString
encode_BuddyOnAirUrls oprot record = T.serializeVal oprot $ from_BuddyOnAirUrls record
to_BuddyOnAirUrls :: T.ThriftVal -> BuddyOnAirUrls
to_BuddyOnAirUrls (T.TStruct fields) = BuddyOnAirUrls{
  buddyOnAirUrls_hls = P.maybe (buddyOnAirUrls_hls default_BuddyOnAirUrls) (\(_,_val175) -> (case _val175 of {T.TMap _ _ _val176 -> (Map.fromList $ P.map (\(_k178,_v177) -> ((case _k178 of {T.TString _val179 -> E.decodeUtf8 _val179; _ -> P.error "wrong type"}),(case _v177 of {T.TString _val180 -> E.decodeUtf8 _val180; _ -> P.error "wrong type"}))) _val176); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyOnAirUrls_smoothStreaming = P.maybe (buddyOnAirUrls_smoothStreaming default_BuddyOnAirUrls) (\(_,_val175) -> (case _val175 of {T.TMap _ _ _val181 -> (Map.fromList $ P.map (\(_k183,_v182) -> ((case _k183 of {T.TString _val184 -> E.decodeUtf8 _val184; _ -> P.error "wrong type"}),(case _v182 of {T.TString _val185 -> E.decodeUtf8 _val185; _ -> P.error "wrong type"}))) _val181); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BuddyOnAirUrls _ = P.error "not a struct"
read_BuddyOnAirUrls :: T.Protocol p => p -> P.IO BuddyOnAirUrls
read_BuddyOnAirUrls iprot = to_BuddyOnAirUrls <$> T.readVal iprot (T.T_STRUCT typemap_BuddyOnAirUrls)
decode_BuddyOnAirUrls :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyOnAirUrls
decode_BuddyOnAirUrls iprot bs = to_BuddyOnAirUrls $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyOnAirUrls) bs
typemap_BuddyOnAirUrls :: T.TypeMap
typemap_BuddyOnAirUrls = Map.fromList [(1,("hls",(T.T_MAP T.T_STRING T.T_STRING))),(2,("smoothStreaming",(T.T_MAP T.T_STRING T.T_STRING)))]
default_BuddyOnAirUrls :: BuddyOnAirUrls
default_BuddyOnAirUrls = BuddyOnAirUrls{
  buddyOnAirUrls_hls = Map.empty,
  buddyOnAirUrls_smoothStreaming = Map.empty}
data BuddyOnAir = BuddyOnAir  { buddyOnAir_mid :: LT.Text
  , buddyOnAir_freshnessLifetime :: I.Int64
  , buddyOnAir_onAirId :: LT.Text
  , buddyOnAir_onAir :: P.Bool
  , buddyOnAir_text :: LT.Text
  , buddyOnAir_viewerCount :: I.Int64
  , buddyOnAir_targetCount :: I.Int64
  , buddyOnAir_onAirType :: BuddyOnAirType
  , buddyOnAir_onAirUrls :: BuddyOnAirUrls
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyOnAir where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyOnAir_mid record   `H.hashWithSalt` buddyOnAir_freshnessLifetime record   `H.hashWithSalt` buddyOnAir_onAirId record   `H.hashWithSalt` buddyOnAir_onAir record   `H.hashWithSalt` buddyOnAir_text record   `H.hashWithSalt` buddyOnAir_viewerCount record   `H.hashWithSalt` buddyOnAir_targetCount record   `H.hashWithSalt` buddyOnAir_onAirType record   `H.hashWithSalt` buddyOnAir_onAirUrls record  
instance QC.Arbitrary BuddyOnAir where 
  arbitrary = M.liftM BuddyOnAir (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyOnAir = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyOnAir{buddyOnAir_mid = buddyOnAir_mid obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_mid = buddyOnAir_mid obj}
    , if obj == default_BuddyOnAir{buddyOnAir_freshnessLifetime = buddyOnAir_freshnessLifetime obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_freshnessLifetime = buddyOnAir_freshnessLifetime obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAirId = buddyOnAir_onAirId obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAirId = buddyOnAir_onAirId obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAir = buddyOnAir_onAir obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAir = buddyOnAir_onAir obj}
    , if obj == default_BuddyOnAir{buddyOnAir_text = buddyOnAir_text obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_text = buddyOnAir_text obj}
    , if obj == default_BuddyOnAir{buddyOnAir_viewerCount = buddyOnAir_viewerCount obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_viewerCount = buddyOnAir_viewerCount obj}
    , if obj == default_BuddyOnAir{buddyOnAir_targetCount = buddyOnAir_targetCount obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_targetCount = buddyOnAir_targetCount obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAirType = buddyOnAir_onAirType obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAirType = buddyOnAir_onAirType obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAirUrls = buddyOnAir_onAirUrls obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAirUrls = buddyOnAir_onAirUrls obj}
    ]
from_BuddyOnAir :: BuddyOnAir -> T.ThriftVal
from_BuddyOnAir record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v188 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v188))) $ buddyOnAir_mid record
  , (\_v188 -> P.Just (3, ("freshnessLifetime",T.TI64 _v188))) $ buddyOnAir_freshnessLifetime record
  , (\_v188 -> P.Just (4, ("onAirId",T.TString $ E.encodeUtf8 _v188))) $ buddyOnAir_onAirId record
  , (\_v188 -> P.Just (5, ("onAir",T.TBool _v188))) $ buddyOnAir_onAir record
  , (\_v188 -> P.Just (11, ("text",T.TString $ E.encodeUtf8 _v188))) $ buddyOnAir_text record
  , (\_v188 -> P.Just (12, ("viewerCount",T.TI64 _v188))) $ buddyOnAir_viewerCount record
  , (\_v188 -> P.Just (13, ("targetCount",T.TI64 _v188))) $ buddyOnAir_targetCount record
  , (\_v188 -> P.Just (31, ("onAirType",T.TI32 $ P.fromIntegral $ P.fromEnum _v188))) $ buddyOnAir_onAirType record
  , (\_v188 -> P.Just (32, ("onAirUrls",from_BuddyOnAirUrls _v188))) $ buddyOnAir_onAirUrls record
  ]
write_BuddyOnAir :: T.Protocol p => p -> BuddyOnAir -> P.IO ()
write_BuddyOnAir oprot record = T.writeVal oprot $ from_BuddyOnAir record
encode_BuddyOnAir :: T.StatelessProtocol p => p -> BuddyOnAir -> LBS.ByteString
encode_BuddyOnAir oprot record = T.serializeVal oprot $ from_BuddyOnAir record
to_BuddyOnAir :: T.ThriftVal -> BuddyOnAir
to_BuddyOnAir (T.TStruct fields) = BuddyOnAir{
  buddyOnAir_mid = P.maybe (buddyOnAir_mid default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TString _val191 -> E.decodeUtf8 _val191; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyOnAir_freshnessLifetime = P.maybe (buddyOnAir_freshnessLifetime default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TI64 _val192 -> _val192; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyOnAir_onAirId = P.maybe (buddyOnAir_onAirId default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TString _val193 -> E.decodeUtf8 _val193; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyOnAir_onAir = P.maybe (buddyOnAir_onAir default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TBool _val194 -> _val194; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddyOnAir_text = P.maybe (buddyOnAir_text default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TString _val195 -> E.decodeUtf8 _val195; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  buddyOnAir_viewerCount = P.maybe (buddyOnAir_viewerCount default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TI64 _val196 -> _val196; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  buddyOnAir_targetCount = P.maybe (buddyOnAir_targetCount default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TI64 _val197 -> _val197; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  buddyOnAir_onAirType = P.maybe (buddyOnAir_onAirType default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TI32 _val198 -> P.toEnum $ P.fromIntegral _val198; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  buddyOnAir_onAirUrls = P.maybe (buddyOnAir_onAirUrls default_BuddyOnAir) (\(_,_val190) -> (case _val190 of {T.TStruct _val199 -> (to_BuddyOnAirUrls (T.TStruct _val199)); _ -> P.error "wrong type"})) (Map.lookup (32) fields)
  }
to_BuddyOnAir _ = P.error "not a struct"
read_BuddyOnAir :: T.Protocol p => p -> P.IO BuddyOnAir
read_BuddyOnAir iprot = to_BuddyOnAir <$> T.readVal iprot (T.T_STRUCT typemap_BuddyOnAir)
decode_BuddyOnAir :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyOnAir
decode_BuddyOnAir iprot bs = to_BuddyOnAir $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyOnAir) bs
typemap_BuddyOnAir :: T.TypeMap
typemap_BuddyOnAir = Map.fromList [(1,("mid",T.T_STRING)),(3,("freshnessLifetime",T.T_I64)),(4,("onAirId",T.T_STRING)),(5,("onAir",T.T_BOOL)),(11,("text",T.T_STRING)),(12,("viewerCount",T.T_I64)),(13,("targetCount",T.T_I64)),(31,("onAirType",T.T_I32)),(32,("onAirUrls",(T.T_STRUCT typemap_BuddyOnAirUrls)))]
default_BuddyOnAir :: BuddyOnAir
default_BuddyOnAir = BuddyOnAir{
  buddyOnAir_mid = "",
  buddyOnAir_freshnessLifetime = 0,
  buddyOnAir_onAirId = "",
  buddyOnAir_onAir = P.False,
  buddyOnAir_text = "",
  buddyOnAir_viewerCount = 0,
  buddyOnAir_targetCount = 0,
  buddyOnAir_onAirType = (P.toEnum 0),
  buddyOnAir_onAirUrls = default_BuddyOnAirUrls}
data BuddyProfile = BuddyProfile  { buddyProfile_buddyId :: LT.Text
  , buddyProfile_mid :: LT.Text
  , buddyProfile_searchId :: LT.Text
  , buddyProfile_displayName :: LT.Text
  , buddyProfile_statusMessage :: LT.Text
  , buddyProfile_contactCount :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyProfile_buddyId record   `H.hashWithSalt` buddyProfile_mid record   `H.hashWithSalt` buddyProfile_searchId record   `H.hashWithSalt` buddyProfile_displayName record   `H.hashWithSalt` buddyProfile_statusMessage record   `H.hashWithSalt` buddyProfile_contactCount record  
instance QC.Arbitrary BuddyProfile where 
  arbitrary = M.liftM BuddyProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyProfile{buddyProfile_buddyId = buddyProfile_buddyId obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_buddyId = buddyProfile_buddyId obj}
    , if obj == default_BuddyProfile{buddyProfile_mid = buddyProfile_mid obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_mid = buddyProfile_mid obj}
    , if obj == default_BuddyProfile{buddyProfile_searchId = buddyProfile_searchId obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_searchId = buddyProfile_searchId obj}
    , if obj == default_BuddyProfile{buddyProfile_displayName = buddyProfile_displayName obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_displayName = buddyProfile_displayName obj}
    , if obj == default_BuddyProfile{buddyProfile_statusMessage = buddyProfile_statusMessage obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_statusMessage = buddyProfile_statusMessage obj}
    , if obj == default_BuddyProfile{buddyProfile_contactCount = buddyProfile_contactCount obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_contactCount = buddyProfile_contactCount obj}
    ]
from_BuddyProfile :: BuddyProfile -> T.ThriftVal
from_BuddyProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v202 -> P.Just (1, ("buddyId",T.TString $ E.encodeUtf8 _v202))) $ buddyProfile_buddyId record
  , (\_v202 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v202))) $ buddyProfile_mid record
  , (\_v202 -> P.Just (3, ("searchId",T.TString $ E.encodeUtf8 _v202))) $ buddyProfile_searchId record
  , (\_v202 -> P.Just (4, ("displayName",T.TString $ E.encodeUtf8 _v202))) $ buddyProfile_displayName record
  , (\_v202 -> P.Just (5, ("statusMessage",T.TString $ E.encodeUtf8 _v202))) $ buddyProfile_statusMessage record
  , (\_v202 -> P.Just (11, ("contactCount",T.TI64 _v202))) $ buddyProfile_contactCount record
  ]
write_BuddyProfile :: T.Protocol p => p -> BuddyProfile -> P.IO ()
write_BuddyProfile oprot record = T.writeVal oprot $ from_BuddyProfile record
encode_BuddyProfile :: T.StatelessProtocol p => p -> BuddyProfile -> LBS.ByteString
encode_BuddyProfile oprot record = T.serializeVal oprot $ from_BuddyProfile record
to_BuddyProfile :: T.ThriftVal -> BuddyProfile
to_BuddyProfile (T.TStruct fields) = BuddyProfile{
  buddyProfile_buddyId = P.maybe (buddyProfile_buddyId default_BuddyProfile) (\(_,_val204) -> (case _val204 of {T.TString _val205 -> E.decodeUtf8 _val205; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyProfile_mid = P.maybe (buddyProfile_mid default_BuddyProfile) (\(_,_val204) -> (case _val204 of {T.TString _val206 -> E.decodeUtf8 _val206; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyProfile_searchId = P.maybe (buddyProfile_searchId default_BuddyProfile) (\(_,_val204) -> (case _val204 of {T.TString _val207 -> E.decodeUtf8 _val207; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyProfile_displayName = P.maybe (buddyProfile_displayName default_BuddyProfile) (\(_,_val204) -> (case _val204 of {T.TString _val208 -> E.decodeUtf8 _val208; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyProfile_statusMessage = P.maybe (buddyProfile_statusMessage default_BuddyProfile) (\(_,_val204) -> (case _val204 of {T.TString _val209 -> E.decodeUtf8 _val209; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddyProfile_contactCount = P.maybe (buddyProfile_contactCount default_BuddyProfile) (\(_,_val204) -> (case _val204 of {T.TI64 _val210 -> _val210; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_BuddyProfile _ = P.error "not a struct"
read_BuddyProfile :: T.Protocol p => p -> P.IO BuddyProfile
read_BuddyProfile iprot = to_BuddyProfile <$> T.readVal iprot (T.T_STRUCT typemap_BuddyProfile)
decode_BuddyProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyProfile
decode_BuddyProfile iprot bs = to_BuddyProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyProfile) bs
typemap_BuddyProfile :: T.TypeMap
typemap_BuddyProfile = Map.fromList [(1,("buddyId",T.T_STRING)),(2,("mid",T.T_STRING)),(3,("searchId",T.T_STRING)),(4,("displayName",T.T_STRING)),(5,("statusMessage",T.T_STRING)),(11,("contactCount",T.T_I64))]
default_BuddyProfile :: BuddyProfile
default_BuddyProfile = BuddyProfile{
  buddyProfile_buddyId = "",
  buddyProfile_mid = "",
  buddyProfile_searchId = "",
  buddyProfile_displayName = "",
  buddyProfile_statusMessage = "",
  buddyProfile_contactCount = 0}
data BuddySearchResult = BuddySearchResult  { buddySearchResult_mid :: LT.Text
  , buddySearchResult_displayName :: LT.Text
  , buddySearchResult_pictureStatus :: LT.Text
  , buddySearchResult_picturePath :: LT.Text
  , buddySearchResult_statusMessage :: LT.Text
  , buddySearchResult_businessAccount :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddySearchResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddySearchResult_mid record   `H.hashWithSalt` buddySearchResult_displayName record   `H.hashWithSalt` buddySearchResult_pictureStatus record   `H.hashWithSalt` buddySearchResult_picturePath record   `H.hashWithSalt` buddySearchResult_statusMessage record   `H.hashWithSalt` buddySearchResult_businessAccount record  
instance QC.Arbitrary BuddySearchResult where 
  arbitrary = M.liftM BuddySearchResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddySearchResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddySearchResult{buddySearchResult_mid = buddySearchResult_mid obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_mid = buddySearchResult_mid obj}
    , if obj == default_BuddySearchResult{buddySearchResult_displayName = buddySearchResult_displayName obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_displayName = buddySearchResult_displayName obj}
    , if obj == default_BuddySearchResult{buddySearchResult_pictureStatus = buddySearchResult_pictureStatus obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_pictureStatus = buddySearchResult_pictureStatus obj}
    , if obj == default_BuddySearchResult{buddySearchResult_picturePath = buddySearchResult_picturePath obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_picturePath = buddySearchResult_picturePath obj}
    , if obj == default_BuddySearchResult{buddySearchResult_statusMessage = buddySearchResult_statusMessage obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_statusMessage = buddySearchResult_statusMessage obj}
    , if obj == default_BuddySearchResult{buddySearchResult_businessAccount = buddySearchResult_businessAccount obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_businessAccount = buddySearchResult_businessAccount obj}
    ]
from_BuddySearchResult :: BuddySearchResult -> T.ThriftVal
from_BuddySearchResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v213 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v213))) $ buddySearchResult_mid record
  , (\_v213 -> P.Just (2, ("displayName",T.TString $ E.encodeUtf8 _v213))) $ buddySearchResult_displayName record
  , (\_v213 -> P.Just (3, ("pictureStatus",T.TString $ E.encodeUtf8 _v213))) $ buddySearchResult_pictureStatus record
  , (\_v213 -> P.Just (4, ("picturePath",T.TString $ E.encodeUtf8 _v213))) $ buddySearchResult_picturePath record
  , (\_v213 -> P.Just (5, ("statusMessage",T.TString $ E.encodeUtf8 _v213))) $ buddySearchResult_statusMessage record
  , (\_v213 -> P.Just (6, ("businessAccount",T.TBool _v213))) $ buddySearchResult_businessAccount record
  ]
write_BuddySearchResult :: T.Protocol p => p -> BuddySearchResult -> P.IO ()
write_BuddySearchResult oprot record = T.writeVal oprot $ from_BuddySearchResult record
encode_BuddySearchResult :: T.StatelessProtocol p => p -> BuddySearchResult -> LBS.ByteString
encode_BuddySearchResult oprot record = T.serializeVal oprot $ from_BuddySearchResult record
to_BuddySearchResult :: T.ThriftVal -> BuddySearchResult
to_BuddySearchResult (T.TStruct fields) = BuddySearchResult{
  buddySearchResult_mid = P.maybe (buddySearchResult_mid default_BuddySearchResult) (\(_,_val215) -> (case _val215 of {T.TString _val216 -> E.decodeUtf8 _val216; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddySearchResult_displayName = P.maybe (buddySearchResult_displayName default_BuddySearchResult) (\(_,_val215) -> (case _val215 of {T.TString _val217 -> E.decodeUtf8 _val217; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddySearchResult_pictureStatus = P.maybe (buddySearchResult_pictureStatus default_BuddySearchResult) (\(_,_val215) -> (case _val215 of {T.TString _val218 -> E.decodeUtf8 _val218; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddySearchResult_picturePath = P.maybe (buddySearchResult_picturePath default_BuddySearchResult) (\(_,_val215) -> (case _val215 of {T.TString _val219 -> E.decodeUtf8 _val219; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddySearchResult_statusMessage = P.maybe (buddySearchResult_statusMessage default_BuddySearchResult) (\(_,_val215) -> (case _val215 of {T.TString _val220 -> E.decodeUtf8 _val220; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddySearchResult_businessAccount = P.maybe (buddySearchResult_businessAccount default_BuddySearchResult) (\(_,_val215) -> (case _val215 of {T.TBool _val221 -> _val221; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_BuddySearchResult _ = P.error "not a struct"
read_BuddySearchResult :: T.Protocol p => p -> P.IO BuddySearchResult
read_BuddySearchResult iprot = to_BuddySearchResult <$> T.readVal iprot (T.T_STRUCT typemap_BuddySearchResult)
decode_BuddySearchResult :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddySearchResult
decode_BuddySearchResult iprot bs = to_BuddySearchResult $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddySearchResult) bs
typemap_BuddySearchResult :: T.TypeMap
typemap_BuddySearchResult = Map.fromList [(1,("mid",T.T_STRING)),(2,("displayName",T.T_STRING)),(3,("pictureStatus",T.T_STRING)),(4,("picturePath",T.T_STRING)),(5,("statusMessage",T.T_STRING)),(6,("businessAccount",T.T_BOOL))]
default_BuddySearchResult :: BuddySearchResult
default_BuddySearchResult = BuddySearchResult{
  buddySearchResult_mid = "",
  buddySearchResult_displayName = "",
  buddySearchResult_pictureStatus = "",
  buddySearchResult_picturePath = "",
  buddySearchResult_statusMessage = "",
  buddySearchResult_businessAccount = P.False}
data ChannelDomain = ChannelDomain  { channelDomain_host :: LT.Text
  , channelDomain_removed :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelDomain where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelDomain_host record   `H.hashWithSalt` channelDomain_removed record  
instance QC.Arbitrary ChannelDomain where 
  arbitrary = M.liftM ChannelDomain (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelDomain = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelDomain{channelDomain_host = channelDomain_host obj} then P.Nothing else P.Just $ default_ChannelDomain{channelDomain_host = channelDomain_host obj}
    , if obj == default_ChannelDomain{channelDomain_removed = channelDomain_removed obj} then P.Nothing else P.Just $ default_ChannelDomain{channelDomain_removed = channelDomain_removed obj}
    ]
from_ChannelDomain :: ChannelDomain -> T.ThriftVal
from_ChannelDomain record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v224 -> P.Just (1, ("host",T.TString $ E.encodeUtf8 _v224))) $ channelDomain_host record
  , (\_v224 -> P.Just (2, ("removed",T.TBool _v224))) $ channelDomain_removed record
  ]
write_ChannelDomain :: T.Protocol p => p -> ChannelDomain -> P.IO ()
write_ChannelDomain oprot record = T.writeVal oprot $ from_ChannelDomain record
encode_ChannelDomain :: T.StatelessProtocol p => p -> ChannelDomain -> LBS.ByteString
encode_ChannelDomain oprot record = T.serializeVal oprot $ from_ChannelDomain record
to_ChannelDomain :: T.ThriftVal -> ChannelDomain
to_ChannelDomain (T.TStruct fields) = ChannelDomain{
  channelDomain_host = P.maybe (channelDomain_host default_ChannelDomain) (\(_,_val226) -> (case _val226 of {T.TString _val227 -> E.decodeUtf8 _val227; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelDomain_removed = P.maybe (channelDomain_removed default_ChannelDomain) (\(_,_val226) -> (case _val226 of {T.TBool _val228 -> _val228; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ChannelDomain _ = P.error "not a struct"
read_ChannelDomain :: T.Protocol p => p -> P.IO ChannelDomain
read_ChannelDomain iprot = to_ChannelDomain <$> T.readVal iprot (T.T_STRUCT typemap_ChannelDomain)
decode_ChannelDomain :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelDomain
decode_ChannelDomain iprot bs = to_ChannelDomain $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelDomain) bs
typemap_ChannelDomain :: T.TypeMap
typemap_ChannelDomain = Map.fromList [(1,("host",T.T_STRING)),(2,("removed",T.T_BOOL))]
default_ChannelDomain :: ChannelDomain
default_ChannelDomain = ChannelDomain{
  channelDomain_host = "",
  channelDomain_removed = P.False}
data ChannelDomains = ChannelDomains  { channelDomains_channelDomains :: (Vector.Vector ChannelDomain)
  , channelDomains_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelDomains where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelDomains_channelDomains record   `H.hashWithSalt` channelDomains_revision record  
instance QC.Arbitrary ChannelDomains where 
  arbitrary = M.liftM ChannelDomains (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelDomains = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelDomains{channelDomains_channelDomains = channelDomains_channelDomains obj} then P.Nothing else P.Just $ default_ChannelDomains{channelDomains_channelDomains = channelDomains_channelDomains obj}
    , if obj == default_ChannelDomains{channelDomains_revision = channelDomains_revision obj} then P.Nothing else P.Just $ default_ChannelDomains{channelDomains_revision = channelDomains_revision obj}
    ]
from_ChannelDomains :: ChannelDomains -> T.ThriftVal
from_ChannelDomains record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v231 -> P.Just (1, ("channelDomains",T.TList (T.T_STRUCT typemap_ChannelDomain) $ P.map (\_v233 -> from_ChannelDomain _v233) $ Vector.toList _v231))) $ channelDomains_channelDomains record
  , (\_v231 -> P.Just (2, ("revision",T.TI64 _v231))) $ channelDomains_revision record
  ]
write_ChannelDomains :: T.Protocol p => p -> ChannelDomains -> P.IO ()
write_ChannelDomains oprot record = T.writeVal oprot $ from_ChannelDomains record
encode_ChannelDomains :: T.StatelessProtocol p => p -> ChannelDomains -> LBS.ByteString
encode_ChannelDomains oprot record = T.serializeVal oprot $ from_ChannelDomains record
to_ChannelDomains :: T.ThriftVal -> ChannelDomains
to_ChannelDomains (T.TStruct fields) = ChannelDomains{
  channelDomains_channelDomains = P.maybe (channelDomains_channelDomains default_ChannelDomains) (\(_,_val235) -> (case _val235 of {T.TList _ _val236 -> (Vector.fromList $ P.map (\_v237 -> (case _v237 of {T.TStruct _val238 -> (to_ChannelDomain (T.TStruct _val238)); _ -> P.error "wrong type"})) _val236); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelDomains_revision = P.maybe (channelDomains_revision default_ChannelDomains) (\(_,_val235) -> (case _val235 of {T.TI64 _val239 -> _val239; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ChannelDomains _ = P.error "not a struct"
read_ChannelDomains :: T.Protocol p => p -> P.IO ChannelDomains
read_ChannelDomains iprot = to_ChannelDomains <$> T.readVal iprot (T.T_STRUCT typemap_ChannelDomains)
decode_ChannelDomains :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelDomains
decode_ChannelDomains iprot bs = to_ChannelDomains $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelDomains) bs
typemap_ChannelDomains :: T.TypeMap
typemap_ChannelDomains = Map.fromList [(1,("channelDomains",(T.T_LIST (T.T_STRUCT typemap_ChannelDomain)))),(2,("revision",T.T_I64))]
default_ChannelDomains :: ChannelDomains
default_ChannelDomains = ChannelDomains{
  channelDomains_channelDomains = Vector.empty,
  channelDomains_revision = 0}
data ChannelException = ChannelException  { channelException_code :: ChannelErrorCode
  , channelException_reason :: LT.Text
  , channelException_parameterMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception ChannelException
instance H.Hashable ChannelException where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelException_code record   `H.hashWithSalt` channelException_reason record   `H.hashWithSalt` channelException_parameterMap record  
instance QC.Arbitrary ChannelException where 
  arbitrary = M.liftM ChannelException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelException{channelException_code = channelException_code obj} then P.Nothing else P.Just $ default_ChannelException{channelException_code = channelException_code obj}
    , if obj == default_ChannelException{channelException_reason = channelException_reason obj} then P.Nothing else P.Just $ default_ChannelException{channelException_reason = channelException_reason obj}
    , if obj == default_ChannelException{channelException_parameterMap = channelException_parameterMap obj} then P.Nothing else P.Just $ default_ChannelException{channelException_parameterMap = channelException_parameterMap obj}
    ]
from_ChannelException :: ChannelException -> T.ThriftVal
from_ChannelException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v242 -> P.Just (1, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v242))) $ channelException_code record
  , (\_v242 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v242))) $ channelException_reason record
  , (\_v242 -> P.Just (3, ("parameterMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k243,_v244) -> (T.TString $ E.encodeUtf8 _k243, T.TString $ E.encodeUtf8 _v244)) $ Map.toList _v242))) $ channelException_parameterMap record
  ]
write_ChannelException :: T.Protocol p => p -> ChannelException -> P.IO ()
write_ChannelException oprot record = T.writeVal oprot $ from_ChannelException record
encode_ChannelException :: T.StatelessProtocol p => p -> ChannelException -> LBS.ByteString
encode_ChannelException oprot record = T.serializeVal oprot $ from_ChannelException record
to_ChannelException :: T.ThriftVal -> ChannelException
to_ChannelException (T.TStruct fields) = ChannelException{
  channelException_code = P.maybe (channelException_code default_ChannelException) (\(_,_val246) -> (case _val246 of {T.TI32 _val247 -> P.toEnum $ P.fromIntegral _val247; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelException_reason = P.maybe (channelException_reason default_ChannelException) (\(_,_val246) -> (case _val246 of {T.TString _val248 -> E.decodeUtf8 _val248; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelException_parameterMap = P.maybe (channelException_parameterMap default_ChannelException) (\(_,_val246) -> (case _val246 of {T.TMap _ _ _val249 -> (Map.fromList $ P.map (\(_k251,_v250) -> ((case _k251 of {T.TString _val252 -> E.decodeUtf8 _val252; _ -> P.error "wrong type"}),(case _v250 of {T.TString _val253 -> E.decodeUtf8 _val253; _ -> P.error "wrong type"}))) _val249); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ChannelException _ = P.error "not a struct"
read_ChannelException :: T.Protocol p => p -> P.IO ChannelException
read_ChannelException iprot = to_ChannelException <$> T.readVal iprot (T.T_STRUCT typemap_ChannelException)
decode_ChannelException :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelException
decode_ChannelException iprot bs = to_ChannelException $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelException) bs
typemap_ChannelException :: T.TypeMap
typemap_ChannelException = Map.fromList [(1,("code",T.T_I32)),(2,("reason",T.T_STRING)),(3,("parameterMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_ChannelException :: ChannelException
default_ChannelException = ChannelException{
  channelException_code = (P.toEnum 0),
  channelException_reason = "",
  channelException_parameterMap = Map.empty}
data ChannelInfos = ChannelInfos  { channelInfos_channelInfos :: (Vector.Vector ChannelInfo)
  , channelInfos_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelInfos where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelInfos_channelInfos record   `H.hashWithSalt` channelInfos_revision record  
instance QC.Arbitrary ChannelInfos where 
  arbitrary = M.liftM ChannelInfos (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelInfos = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelInfos{channelInfos_channelInfos = channelInfos_channelInfos obj} then P.Nothing else P.Just $ default_ChannelInfos{channelInfos_channelInfos = channelInfos_channelInfos obj}
    , if obj == default_ChannelInfos{channelInfos_revision = channelInfos_revision obj} then P.Nothing else P.Just $ default_ChannelInfos{channelInfos_revision = channelInfos_revision obj}
    ]
from_ChannelInfos :: ChannelInfos -> T.ThriftVal
from_ChannelInfos record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v256 -> P.Just (1, ("channelInfos",T.TList (T.T_STRUCT typemap_ChannelInfo) $ P.map (\_v258 -> from_ChannelInfo _v258) $ Vector.toList _v256))) $ channelInfos_channelInfos record
  , (\_v256 -> P.Just (2, ("revision",T.TI64 _v256))) $ channelInfos_revision record
  ]
write_ChannelInfos :: T.Protocol p => p -> ChannelInfos -> P.IO ()
write_ChannelInfos oprot record = T.writeVal oprot $ from_ChannelInfos record
encode_ChannelInfos :: T.StatelessProtocol p => p -> ChannelInfos -> LBS.ByteString
encode_ChannelInfos oprot record = T.serializeVal oprot $ from_ChannelInfos record
to_ChannelInfos :: T.ThriftVal -> ChannelInfos
to_ChannelInfos (T.TStruct fields) = ChannelInfos{
  channelInfos_channelInfos = P.maybe (channelInfos_channelInfos default_ChannelInfos) (\(_,_val260) -> (case _val260 of {T.TList _ _val261 -> (Vector.fromList $ P.map (\_v262 -> (case _v262 of {T.TStruct _val263 -> (to_ChannelInfo (T.TStruct _val263)); _ -> P.error "wrong type"})) _val261); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelInfos_revision = P.maybe (channelInfos_revision default_ChannelInfos) (\(_,_val260) -> (case _val260 of {T.TI64 _val264 -> _val264; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ChannelInfos _ = P.error "not a struct"
read_ChannelInfos :: T.Protocol p => p -> P.IO ChannelInfos
read_ChannelInfos iprot = to_ChannelInfos <$> T.readVal iprot (T.T_STRUCT typemap_ChannelInfos)
decode_ChannelInfos :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelInfos
decode_ChannelInfos iprot bs = to_ChannelInfos $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelInfos) bs
typemap_ChannelInfos :: T.TypeMap
typemap_ChannelInfos = Map.fromList [(1,("channelInfos",(T.T_LIST (T.T_STRUCT typemap_ChannelInfo)))),(2,("revision",T.T_I64))]
default_ChannelInfos :: ChannelInfos
default_ChannelInfos = ChannelInfos{
  channelInfos_channelInfos = Vector.empty,
  channelInfos_revision = 0}
data ChannelNotificationSetting = ChannelNotificationSetting  { channelNotificationSetting_channelId :: LT.Text
  , channelNotificationSetting_name :: LT.Text
  , channelNotificationSetting_notificationReceivable :: P.Bool
  , channelNotificationSetting_messageReceivable :: P.Bool
  , channelNotificationSetting_showDefault :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelNotificationSetting where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelNotificationSetting_channelId record   `H.hashWithSalt` channelNotificationSetting_name record   `H.hashWithSalt` channelNotificationSetting_notificationReceivable record   `H.hashWithSalt` channelNotificationSetting_messageReceivable record   `H.hashWithSalt` channelNotificationSetting_showDefault record  
instance QC.Arbitrary ChannelNotificationSetting where 
  arbitrary = M.liftM ChannelNotificationSetting (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelNotificationSetting = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelNotificationSetting{channelNotificationSetting_channelId = channelNotificationSetting_channelId obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_channelId = channelNotificationSetting_channelId obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_name = channelNotificationSetting_name obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_name = channelNotificationSetting_name obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_notificationReceivable = channelNotificationSetting_notificationReceivable obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_notificationReceivable = channelNotificationSetting_notificationReceivable obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_messageReceivable = channelNotificationSetting_messageReceivable obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_messageReceivable = channelNotificationSetting_messageReceivable obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_showDefault = channelNotificationSetting_showDefault obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_showDefault = channelNotificationSetting_showDefault obj}
    ]
from_ChannelNotificationSetting :: ChannelNotificationSetting -> T.ThriftVal
from_ChannelNotificationSetting record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v267 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v267))) $ channelNotificationSetting_channelId record
  , (\_v267 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v267))) $ channelNotificationSetting_name record
  , (\_v267 -> P.Just (3, ("notificationReceivable",T.TBool _v267))) $ channelNotificationSetting_notificationReceivable record
  , (\_v267 -> P.Just (4, ("messageReceivable",T.TBool _v267))) $ channelNotificationSetting_messageReceivable record
  , (\_v267 -> P.Just (5, ("showDefault",T.TBool _v267))) $ channelNotificationSetting_showDefault record
  ]
write_ChannelNotificationSetting :: T.Protocol p => p -> ChannelNotificationSetting -> P.IO ()
write_ChannelNotificationSetting oprot record = T.writeVal oprot $ from_ChannelNotificationSetting record
encode_ChannelNotificationSetting :: T.StatelessProtocol p => p -> ChannelNotificationSetting -> LBS.ByteString
encode_ChannelNotificationSetting oprot record = T.serializeVal oprot $ from_ChannelNotificationSetting record
to_ChannelNotificationSetting :: T.ThriftVal -> ChannelNotificationSetting
to_ChannelNotificationSetting (T.TStruct fields) = ChannelNotificationSetting{
  channelNotificationSetting_channelId = P.maybe (channelNotificationSetting_channelId default_ChannelNotificationSetting) (\(_,_val269) -> (case _val269 of {T.TString _val270 -> E.decodeUtf8 _val270; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelNotificationSetting_name = P.maybe (channelNotificationSetting_name default_ChannelNotificationSetting) (\(_,_val269) -> (case _val269 of {T.TString _val271 -> E.decodeUtf8 _val271; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelNotificationSetting_notificationReceivable = P.maybe (channelNotificationSetting_notificationReceivable default_ChannelNotificationSetting) (\(_,_val269) -> (case _val269 of {T.TBool _val272 -> _val272; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelNotificationSetting_messageReceivable = P.maybe (channelNotificationSetting_messageReceivable default_ChannelNotificationSetting) (\(_,_val269) -> (case _val269 of {T.TBool _val273 -> _val273; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  channelNotificationSetting_showDefault = P.maybe (channelNotificationSetting_showDefault default_ChannelNotificationSetting) (\(_,_val269) -> (case _val269 of {T.TBool _val274 -> _val274; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ChannelNotificationSetting _ = P.error "not a struct"
read_ChannelNotificationSetting :: T.Protocol p => p -> P.IO ChannelNotificationSetting
read_ChannelNotificationSetting iprot = to_ChannelNotificationSetting <$> T.readVal iprot (T.T_STRUCT typemap_ChannelNotificationSetting)
decode_ChannelNotificationSetting :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelNotificationSetting
decode_ChannelNotificationSetting iprot bs = to_ChannelNotificationSetting $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelNotificationSetting) bs
typemap_ChannelNotificationSetting :: T.TypeMap
typemap_ChannelNotificationSetting = Map.fromList [(1,("channelId",T.T_STRING)),(2,("name",T.T_STRING)),(3,("notificationReceivable",T.T_BOOL)),(4,("messageReceivable",T.T_BOOL)),(5,("showDefault",T.T_BOOL))]
default_ChannelNotificationSetting :: ChannelNotificationSetting
default_ChannelNotificationSetting = ChannelNotificationSetting{
  channelNotificationSetting_channelId = "",
  channelNotificationSetting_name = "",
  channelNotificationSetting_notificationReceivable = P.False,
  channelNotificationSetting_messageReceivable = P.False,
  channelNotificationSetting_showDefault = P.False}
data ChannelSyncDatas = ChannelSyncDatas  { channelSyncDatas_channelInfos :: (Vector.Vector ChannelInfo)
  , channelSyncDatas_channelDomains :: (Vector.Vector ChannelDomain)
  , channelSyncDatas_revision :: I.Int64
  , channelSyncDatas_expires :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelSyncDatas where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelSyncDatas_channelInfos record   `H.hashWithSalt` channelSyncDatas_channelDomains record   `H.hashWithSalt` channelSyncDatas_revision record   `H.hashWithSalt` channelSyncDatas_expires record  
instance QC.Arbitrary ChannelSyncDatas where 
  arbitrary = M.liftM ChannelSyncDatas (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelSyncDatas = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelSyncDatas{channelSyncDatas_channelInfos = channelSyncDatas_channelInfos obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_channelInfos = channelSyncDatas_channelInfos obj}
    , if obj == default_ChannelSyncDatas{channelSyncDatas_channelDomains = channelSyncDatas_channelDomains obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_channelDomains = channelSyncDatas_channelDomains obj}
    , if obj == default_ChannelSyncDatas{channelSyncDatas_revision = channelSyncDatas_revision obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_revision = channelSyncDatas_revision obj}
    , if obj == default_ChannelSyncDatas{channelSyncDatas_expires = channelSyncDatas_expires obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_expires = channelSyncDatas_expires obj}
    ]
from_ChannelSyncDatas :: ChannelSyncDatas -> T.ThriftVal
from_ChannelSyncDatas record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v277 -> P.Just (1, ("channelInfos",T.TList (T.T_STRUCT typemap_ChannelInfo) $ P.map (\_v279 -> from_ChannelInfo _v279) $ Vector.toList _v277))) $ channelSyncDatas_channelInfos record
  , (\_v277 -> P.Just (2, ("channelDomains",T.TList (T.T_STRUCT typemap_ChannelDomain) $ P.map (\_v281 -> from_ChannelDomain _v281) $ Vector.toList _v277))) $ channelSyncDatas_channelDomains record
  , (\_v277 -> P.Just (3, ("revision",T.TI64 _v277))) $ channelSyncDatas_revision record
  , (\_v277 -> P.Just (4, ("expires",T.TI64 _v277))) $ channelSyncDatas_expires record
  ]
write_ChannelSyncDatas :: T.Protocol p => p -> ChannelSyncDatas -> P.IO ()
write_ChannelSyncDatas oprot record = T.writeVal oprot $ from_ChannelSyncDatas record
encode_ChannelSyncDatas :: T.StatelessProtocol p => p -> ChannelSyncDatas -> LBS.ByteString
encode_ChannelSyncDatas oprot record = T.serializeVal oprot $ from_ChannelSyncDatas record
to_ChannelSyncDatas :: T.ThriftVal -> ChannelSyncDatas
to_ChannelSyncDatas (T.TStruct fields) = ChannelSyncDatas{
  channelSyncDatas_channelInfos = P.maybe (channelSyncDatas_channelInfos default_ChannelSyncDatas) (\(_,_val283) -> (case _val283 of {T.TList _ _val284 -> (Vector.fromList $ P.map (\_v285 -> (case _v285 of {T.TStruct _val286 -> (to_ChannelInfo (T.TStruct _val286)); _ -> P.error "wrong type"})) _val284); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelSyncDatas_channelDomains = P.maybe (channelSyncDatas_channelDomains default_ChannelSyncDatas) (\(_,_val283) -> (case _val283 of {T.TList _ _val287 -> (Vector.fromList $ P.map (\_v288 -> (case _v288 of {T.TStruct _val289 -> (to_ChannelDomain (T.TStruct _val289)); _ -> P.error "wrong type"})) _val287); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelSyncDatas_revision = P.maybe (channelSyncDatas_revision default_ChannelSyncDatas) (\(_,_val283) -> (case _val283 of {T.TI64 _val290 -> _val290; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelSyncDatas_expires = P.maybe (channelSyncDatas_expires default_ChannelSyncDatas) (\(_,_val283) -> (case _val283 of {T.TI64 _val291 -> _val291; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ChannelSyncDatas _ = P.error "not a struct"
read_ChannelSyncDatas :: T.Protocol p => p -> P.IO ChannelSyncDatas
read_ChannelSyncDatas iprot = to_ChannelSyncDatas <$> T.readVal iprot (T.T_STRUCT typemap_ChannelSyncDatas)
decode_ChannelSyncDatas :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelSyncDatas
decode_ChannelSyncDatas iprot bs = to_ChannelSyncDatas $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelSyncDatas) bs
typemap_ChannelSyncDatas :: T.TypeMap
typemap_ChannelSyncDatas = Map.fromList [(1,("channelInfos",(T.T_LIST (T.T_STRUCT typemap_ChannelInfo)))),(2,("channelDomains",(T.T_LIST (T.T_STRUCT typemap_ChannelDomain)))),(3,("revision",T.T_I64)),(4,("expires",T.T_I64))]
default_ChannelSyncDatas :: ChannelSyncDatas
default_ChannelSyncDatas = ChannelSyncDatas{
  channelSyncDatas_channelInfos = Vector.empty,
  channelSyncDatas_channelDomains = Vector.empty,
  channelSyncDatas_revision = 0,
  channelSyncDatas_expires = 0}
data ChannelToken = ChannelToken  { channelToken_token :: LT.Text
  , channelToken_obsToken :: LT.Text
  , channelToken_expiration :: I.Int64
  , channelToken_refreshToken :: LT.Text
  , channelToken_channelAccessToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelToken where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelToken_token record   `H.hashWithSalt` channelToken_obsToken record   `H.hashWithSalt` channelToken_expiration record   `H.hashWithSalt` channelToken_refreshToken record   `H.hashWithSalt` channelToken_channelAccessToken record  
instance QC.Arbitrary ChannelToken where 
  arbitrary = M.liftM ChannelToken (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelToken = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelToken{channelToken_token = channelToken_token obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_token = channelToken_token obj}
    , if obj == default_ChannelToken{channelToken_obsToken = channelToken_obsToken obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_obsToken = channelToken_obsToken obj}
    , if obj == default_ChannelToken{channelToken_expiration = channelToken_expiration obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_expiration = channelToken_expiration obj}
    , if obj == default_ChannelToken{channelToken_refreshToken = channelToken_refreshToken obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_refreshToken = channelToken_refreshToken obj}
    , if obj == default_ChannelToken{channelToken_channelAccessToken = channelToken_channelAccessToken obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_channelAccessToken = channelToken_channelAccessToken obj}
    ]
from_ChannelToken :: ChannelToken -> T.ThriftVal
from_ChannelToken record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v294 -> P.Just (1, ("token",T.TString $ E.encodeUtf8 _v294))) $ channelToken_token record
  , (\_v294 -> P.Just (2, ("obsToken",T.TString $ E.encodeUtf8 _v294))) $ channelToken_obsToken record
  , (\_v294 -> P.Just (3, ("expiration",T.TI64 _v294))) $ channelToken_expiration record
  , (\_v294 -> P.Just (4, ("refreshToken",T.TString $ E.encodeUtf8 _v294))) $ channelToken_refreshToken record
  , (\_v294 -> P.Just (5, ("channelAccessToken",T.TString $ E.encodeUtf8 _v294))) $ channelToken_channelAccessToken record
  ]
write_ChannelToken :: T.Protocol p => p -> ChannelToken -> P.IO ()
write_ChannelToken oprot record = T.writeVal oprot $ from_ChannelToken record
encode_ChannelToken :: T.StatelessProtocol p => p -> ChannelToken -> LBS.ByteString
encode_ChannelToken oprot record = T.serializeVal oprot $ from_ChannelToken record
to_ChannelToken :: T.ThriftVal -> ChannelToken
to_ChannelToken (T.TStruct fields) = ChannelToken{
  channelToken_token = P.maybe (channelToken_token default_ChannelToken) (\(_,_val296) -> (case _val296 of {T.TString _val297 -> E.decodeUtf8 _val297; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelToken_obsToken = P.maybe (channelToken_obsToken default_ChannelToken) (\(_,_val296) -> (case _val296 of {T.TString _val298 -> E.decodeUtf8 _val298; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelToken_expiration = P.maybe (channelToken_expiration default_ChannelToken) (\(_,_val296) -> (case _val296 of {T.TI64 _val299 -> _val299; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelToken_refreshToken = P.maybe (channelToken_refreshToken default_ChannelToken) (\(_,_val296) -> (case _val296 of {T.TString _val300 -> E.decodeUtf8 _val300; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  channelToken_channelAccessToken = P.maybe (channelToken_channelAccessToken default_ChannelToken) (\(_,_val296) -> (case _val296 of {T.TString _val301 -> E.decodeUtf8 _val301; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ChannelToken _ = P.error "not a struct"
read_ChannelToken :: T.Protocol p => p -> P.IO ChannelToken
read_ChannelToken iprot = to_ChannelToken <$> T.readVal iprot (T.T_STRUCT typemap_ChannelToken)
decode_ChannelToken :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelToken
decode_ChannelToken iprot bs = to_ChannelToken $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelToken) bs
typemap_ChannelToken :: T.TypeMap
typemap_ChannelToken = Map.fromList [(1,("token",T.T_STRING)),(2,("obsToken",T.T_STRING)),(3,("expiration",T.T_I64)),(4,("refreshToken",T.T_STRING)),(5,("channelAccessToken",T.T_STRING))]
default_ChannelToken :: ChannelToken
default_ChannelToken = ChannelToken{
  channelToken_token = "",
  channelToken_obsToken = "",
  channelToken_expiration = 0,
  channelToken_refreshToken = "",
  channelToken_channelAccessToken = ""}
data Coin = Coin  { coin_freeCoinBalance :: I.Int32
  , coin_payedCoinBalance :: I.Int32
  , coin_totalCoinBalance :: I.Int32
  , coin_rewardCoinBalance :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Coin where
  hashWithSalt salt record = salt   `H.hashWithSalt` coin_freeCoinBalance record   `H.hashWithSalt` coin_payedCoinBalance record   `H.hashWithSalt` coin_totalCoinBalance record   `H.hashWithSalt` coin_rewardCoinBalance record  
instance QC.Arbitrary Coin where 
  arbitrary = M.liftM Coin (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Coin = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Coin{coin_freeCoinBalance = coin_freeCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_freeCoinBalance = coin_freeCoinBalance obj}
    , if obj == default_Coin{coin_payedCoinBalance = coin_payedCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_payedCoinBalance = coin_payedCoinBalance obj}
    , if obj == default_Coin{coin_totalCoinBalance = coin_totalCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_totalCoinBalance = coin_totalCoinBalance obj}
    , if obj == default_Coin{coin_rewardCoinBalance = coin_rewardCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_rewardCoinBalance = coin_rewardCoinBalance obj}
    ]
from_Coin :: Coin -> T.ThriftVal
from_Coin record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v304 -> P.Just (1, ("freeCoinBalance",T.TI32 _v304))) $ coin_freeCoinBalance record
  , (\_v304 -> P.Just (2, ("payedCoinBalance",T.TI32 _v304))) $ coin_payedCoinBalance record
  , (\_v304 -> P.Just (3, ("totalCoinBalance",T.TI32 _v304))) $ coin_totalCoinBalance record
  , (\_v304 -> P.Just (4, ("rewardCoinBalance",T.TI32 _v304))) $ coin_rewardCoinBalance record
  ]
write_Coin :: T.Protocol p => p -> Coin -> P.IO ()
write_Coin oprot record = T.writeVal oprot $ from_Coin record
encode_Coin :: T.StatelessProtocol p => p -> Coin -> LBS.ByteString
encode_Coin oprot record = T.serializeVal oprot $ from_Coin record
to_Coin :: T.ThriftVal -> Coin
to_Coin (T.TStruct fields) = Coin{
  coin_freeCoinBalance = P.maybe (coin_freeCoinBalance default_Coin) (\(_,_val306) -> (case _val306 of {T.TI32 _val307 -> _val307; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coin_payedCoinBalance = P.maybe (coin_payedCoinBalance default_Coin) (\(_,_val306) -> (case _val306 of {T.TI32 _val308 -> _val308; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coin_totalCoinBalance = P.maybe (coin_totalCoinBalance default_Coin) (\(_,_val306) -> (case _val306 of {T.TI32 _val309 -> _val309; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coin_rewardCoinBalance = P.maybe (coin_rewardCoinBalance default_Coin) (\(_,_val306) -> (case _val306 of {T.TI32 _val310 -> _val310; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Coin _ = P.error "not a struct"
read_Coin :: T.Protocol p => p -> P.IO Coin
read_Coin iprot = to_Coin <$> T.readVal iprot (T.T_STRUCT typemap_Coin)
decode_Coin :: T.StatelessProtocol p => p -> LBS.ByteString -> Coin
decode_Coin iprot bs = to_Coin $ T.deserializeVal iprot (T.T_STRUCT typemap_Coin) bs
typemap_Coin :: T.TypeMap
typemap_Coin = Map.fromList [(1,("freeCoinBalance",T.T_I32)),(2,("payedCoinBalance",T.T_I32)),(3,("totalCoinBalance",T.T_I32)),(4,("rewardCoinBalance",T.T_I32))]
default_Coin :: Coin
default_Coin = Coin{
  coin_freeCoinBalance = 0,
  coin_payedCoinBalance = 0,
  coin_totalCoinBalance = 0,
  coin_rewardCoinBalance = 0}
data CoinPayLoad = CoinPayLoad  { coinPayLoad_payCoin :: I.Int32
  , coinPayLoad_freeCoin :: I.Int32
  , coinPayLoad_type :: PayloadType
  , coinPayLoad_rewardCoin :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinPayLoad where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinPayLoad_payCoin record   `H.hashWithSalt` coinPayLoad_freeCoin record   `H.hashWithSalt` coinPayLoad_type record   `H.hashWithSalt` coinPayLoad_rewardCoin record  
instance QC.Arbitrary CoinPayLoad where 
  arbitrary = M.liftM CoinPayLoad (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinPayLoad = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinPayLoad{coinPayLoad_payCoin = coinPayLoad_payCoin obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_payCoin = coinPayLoad_payCoin obj}
    , if obj == default_CoinPayLoad{coinPayLoad_freeCoin = coinPayLoad_freeCoin obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_freeCoin = coinPayLoad_freeCoin obj}
    , if obj == default_CoinPayLoad{coinPayLoad_type = coinPayLoad_type obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_type = coinPayLoad_type obj}
    , if obj == default_CoinPayLoad{coinPayLoad_rewardCoin = coinPayLoad_rewardCoin obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_rewardCoin = coinPayLoad_rewardCoin obj}
    ]
from_CoinPayLoad :: CoinPayLoad -> T.ThriftVal
from_CoinPayLoad record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v313 -> P.Just (1, ("payCoin",T.TI32 _v313))) $ coinPayLoad_payCoin record
  , (\_v313 -> P.Just (2, ("freeCoin",T.TI32 _v313))) $ coinPayLoad_freeCoin record
  , (\_v313 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v313))) $ coinPayLoad_type record
  , (\_v313 -> P.Just (4, ("rewardCoin",T.TI32 _v313))) $ coinPayLoad_rewardCoin record
  ]
write_CoinPayLoad :: T.Protocol p => p -> CoinPayLoad -> P.IO ()
write_CoinPayLoad oprot record = T.writeVal oprot $ from_CoinPayLoad record
encode_CoinPayLoad :: T.StatelessProtocol p => p -> CoinPayLoad -> LBS.ByteString
encode_CoinPayLoad oprot record = T.serializeVal oprot $ from_CoinPayLoad record
to_CoinPayLoad :: T.ThriftVal -> CoinPayLoad
to_CoinPayLoad (T.TStruct fields) = CoinPayLoad{
  coinPayLoad_payCoin = P.maybe (coinPayLoad_payCoin default_CoinPayLoad) (\(_,_val315) -> (case _val315 of {T.TI32 _val316 -> _val316; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinPayLoad_freeCoin = P.maybe (coinPayLoad_freeCoin default_CoinPayLoad) (\(_,_val315) -> (case _val315 of {T.TI32 _val317 -> _val317; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinPayLoad_type = P.maybe (coinPayLoad_type default_CoinPayLoad) (\(_,_val315) -> (case _val315 of {T.TI32 _val318 -> P.toEnum $ P.fromIntegral _val318; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinPayLoad_rewardCoin = P.maybe (coinPayLoad_rewardCoin default_CoinPayLoad) (\(_,_val315) -> (case _val315 of {T.TI32 _val319 -> _val319; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_CoinPayLoad _ = P.error "not a struct"
read_CoinPayLoad :: T.Protocol p => p -> P.IO CoinPayLoad
read_CoinPayLoad iprot = to_CoinPayLoad <$> T.readVal iprot (T.T_STRUCT typemap_CoinPayLoad)
decode_CoinPayLoad :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinPayLoad
decode_CoinPayLoad iprot bs = to_CoinPayLoad $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinPayLoad) bs
typemap_CoinPayLoad :: T.TypeMap
typemap_CoinPayLoad = Map.fromList [(1,("payCoin",T.T_I32)),(2,("freeCoin",T.T_I32)),(3,("type",T.T_I32)),(4,("rewardCoin",T.T_I32))]
default_CoinPayLoad :: CoinPayLoad
default_CoinPayLoad = CoinPayLoad{
  coinPayLoad_payCoin = 0,
  coinPayLoad_freeCoin = 0,
  coinPayLoad_type = (P.toEnum 0),
  coinPayLoad_rewardCoin = 0}
data CoinHistory = CoinHistory  { coinHistory_payDate :: I.Int64
  , coinHistory_coinBalance :: I.Int32
  , coinHistory_coin :: I.Int32
  , coinHistory_price :: LT.Text
  , coinHistory_title :: LT.Text
  , coinHistory_refund :: P.Bool
  , coinHistory_paySeq :: LT.Text
  , coinHistory_currency :: LT.Text
  , coinHistory_currencySign :: LT.Text
  , coinHistory_displayPrice :: LT.Text
  , coinHistory_payload :: CoinPayLoad
  , coinHistory_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinHistory where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinHistory_payDate record   `H.hashWithSalt` coinHistory_coinBalance record   `H.hashWithSalt` coinHistory_coin record   `H.hashWithSalt` coinHistory_price record   `H.hashWithSalt` coinHistory_title record   `H.hashWithSalt` coinHistory_refund record   `H.hashWithSalt` coinHistory_paySeq record   `H.hashWithSalt` coinHistory_currency record   `H.hashWithSalt` coinHistory_currencySign record   `H.hashWithSalt` coinHistory_displayPrice record   `H.hashWithSalt` coinHistory_payload record   `H.hashWithSalt` coinHistory_channelId record  
instance QC.Arbitrary CoinHistory where 
  arbitrary = M.liftM CoinHistory (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinHistory = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinHistory{coinHistory_payDate = coinHistory_payDate obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_payDate = coinHistory_payDate obj}
    , if obj == default_CoinHistory{coinHistory_coinBalance = coinHistory_coinBalance obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_coinBalance = coinHistory_coinBalance obj}
    , if obj == default_CoinHistory{coinHistory_coin = coinHistory_coin obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_coin = coinHistory_coin obj}
    , if obj == default_CoinHistory{coinHistory_price = coinHistory_price obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_price = coinHistory_price obj}
    , if obj == default_CoinHistory{coinHistory_title = coinHistory_title obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_title = coinHistory_title obj}
    , if obj == default_CoinHistory{coinHistory_refund = coinHistory_refund obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_refund = coinHistory_refund obj}
    , if obj == default_CoinHistory{coinHistory_paySeq = coinHistory_paySeq obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_paySeq = coinHistory_paySeq obj}
    , if obj == default_CoinHistory{coinHistory_currency = coinHistory_currency obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_currency = coinHistory_currency obj}
    , if obj == default_CoinHistory{coinHistory_currencySign = coinHistory_currencySign obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_currencySign = coinHistory_currencySign obj}
    , if obj == default_CoinHistory{coinHistory_displayPrice = coinHistory_displayPrice obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_displayPrice = coinHistory_displayPrice obj}
    , if obj == default_CoinHistory{coinHistory_payload = coinHistory_payload obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_payload = coinHistory_payload obj}
    , if obj == default_CoinHistory{coinHistory_channelId = coinHistory_channelId obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_channelId = coinHistory_channelId obj}
    ]
from_CoinHistory :: CoinHistory -> T.ThriftVal
from_CoinHistory record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v322 -> P.Just (1, ("payDate",T.TI64 _v322))) $ coinHistory_payDate record
  , (\_v322 -> P.Just (2, ("coinBalance",T.TI32 _v322))) $ coinHistory_coinBalance record
  , (\_v322 -> P.Just (3, ("coin",T.TI32 _v322))) $ coinHistory_coin record
  , (\_v322 -> P.Just (4, ("price",T.TString $ E.encodeUtf8 _v322))) $ coinHistory_price record
  , (\_v322 -> P.Just (5, ("title",T.TString $ E.encodeUtf8 _v322))) $ coinHistory_title record
  , (\_v322 -> P.Just (6, ("refund",T.TBool _v322))) $ coinHistory_refund record
  , (\_v322 -> P.Just (7, ("paySeq",T.TString $ E.encodeUtf8 _v322))) $ coinHistory_paySeq record
  , (\_v322 -> P.Just (8, ("currency",T.TString $ E.encodeUtf8 _v322))) $ coinHistory_currency record
  , (\_v322 -> P.Just (9, ("currencySign",T.TString $ E.encodeUtf8 _v322))) $ coinHistory_currencySign record
  , (\_v322 -> P.Just (10, ("displayPrice",T.TString $ E.encodeUtf8 _v322))) $ coinHistory_displayPrice record
  , (\_v322 -> P.Just (11, ("payload",from_CoinPayLoad _v322))) $ coinHistory_payload record
  , (\_v322 -> P.Just (12, ("channelId",T.TString $ E.encodeUtf8 _v322))) $ coinHistory_channelId record
  ]
write_CoinHistory :: T.Protocol p => p -> CoinHistory -> P.IO ()
write_CoinHistory oprot record = T.writeVal oprot $ from_CoinHistory record
encode_CoinHistory :: T.StatelessProtocol p => p -> CoinHistory -> LBS.ByteString
encode_CoinHistory oprot record = T.serializeVal oprot $ from_CoinHistory record
to_CoinHistory :: T.ThriftVal -> CoinHistory
to_CoinHistory (T.TStruct fields) = CoinHistory{
  coinHistory_payDate = P.maybe (coinHistory_payDate default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TI64 _val325 -> _val325; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinHistory_coinBalance = P.maybe (coinHistory_coinBalance default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TI32 _val326 -> _val326; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinHistory_coin = P.maybe (coinHistory_coin default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TI32 _val327 -> _val327; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinHistory_price = P.maybe (coinHistory_price default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TString _val328 -> E.decodeUtf8 _val328; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinHistory_title = P.maybe (coinHistory_title default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TString _val329 -> E.decodeUtf8 _val329; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinHistory_refund = P.maybe (coinHistory_refund default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TBool _val330 -> _val330; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinHistory_paySeq = P.maybe (coinHistory_paySeq default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TString _val331 -> E.decodeUtf8 _val331; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  coinHistory_currency = P.maybe (coinHistory_currency default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TString _val332 -> E.decodeUtf8 _val332; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  coinHistory_currencySign = P.maybe (coinHistory_currencySign default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TString _val333 -> E.decodeUtf8 _val333; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  coinHistory_displayPrice = P.maybe (coinHistory_displayPrice default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TString _val334 -> E.decodeUtf8 _val334; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  coinHistory_payload = P.maybe (coinHistory_payload default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TStruct _val335 -> (to_CoinPayLoad (T.TStruct _val335)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  coinHistory_channelId = P.maybe (coinHistory_channelId default_CoinHistory) (\(_,_val324) -> (case _val324 of {T.TString _val336 -> E.decodeUtf8 _val336; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_CoinHistory _ = P.error "not a struct"
read_CoinHistory :: T.Protocol p => p -> P.IO CoinHistory
read_CoinHistory iprot = to_CoinHistory <$> T.readVal iprot (T.T_STRUCT typemap_CoinHistory)
decode_CoinHistory :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinHistory
decode_CoinHistory iprot bs = to_CoinHistory $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinHistory) bs
typemap_CoinHistory :: T.TypeMap
typemap_CoinHistory = Map.fromList [(1,("payDate",T.T_I64)),(2,("coinBalance",T.T_I32)),(3,("coin",T.T_I32)),(4,("price",T.T_STRING)),(5,("title",T.T_STRING)),(6,("refund",T.T_BOOL)),(7,("paySeq",T.T_STRING)),(8,("currency",T.T_STRING)),(9,("currencySign",T.T_STRING)),(10,("displayPrice",T.T_STRING)),(11,("payload",(T.T_STRUCT typemap_CoinPayLoad))),(12,("channelId",T.T_STRING))]
default_CoinHistory :: CoinHistory
default_CoinHistory = CoinHistory{
  coinHistory_payDate = 0,
  coinHistory_coinBalance = 0,
  coinHistory_coin = 0,
  coinHistory_price = "",
  coinHistory_title = "",
  coinHistory_refund = P.False,
  coinHistory_paySeq = "",
  coinHistory_currency = "",
  coinHistory_currencySign = "",
  coinHistory_displayPrice = "",
  coinHistory_payload = default_CoinPayLoad,
  coinHistory_channelId = ""}
data CoinHistoryCondition = CoinHistoryCondition  { coinHistoryCondition_start :: I.Int64
  , coinHistoryCondition_size :: I.Int32
  , coinHistoryCondition_language :: LT.Text
  , coinHistoryCondition_eddt :: LT.Text
  , coinHistoryCondition_appStoreCode :: PaymentType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinHistoryCondition where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinHistoryCondition_start record   `H.hashWithSalt` coinHistoryCondition_size record   `H.hashWithSalt` coinHistoryCondition_language record   `H.hashWithSalt` coinHistoryCondition_eddt record   `H.hashWithSalt` coinHistoryCondition_appStoreCode record  
instance QC.Arbitrary CoinHistoryCondition where 
  arbitrary = M.liftM CoinHistoryCondition (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinHistoryCondition = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinHistoryCondition{coinHistoryCondition_start = coinHistoryCondition_start obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_start = coinHistoryCondition_start obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_size = coinHistoryCondition_size obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_size = coinHistoryCondition_size obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_language = coinHistoryCondition_language obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_language = coinHistoryCondition_language obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_eddt = coinHistoryCondition_eddt obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_eddt = coinHistoryCondition_eddt obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_appStoreCode = coinHistoryCondition_appStoreCode obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_appStoreCode = coinHistoryCondition_appStoreCode obj}
    ]
from_CoinHistoryCondition :: CoinHistoryCondition -> T.ThriftVal
from_CoinHistoryCondition record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v339 -> P.Just (1, ("start",T.TI64 _v339))) $ coinHistoryCondition_start record
  , (\_v339 -> P.Just (2, ("size",T.TI32 _v339))) $ coinHistoryCondition_size record
  , (\_v339 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v339))) $ coinHistoryCondition_language record
  , (\_v339 -> P.Just (4, ("eddt",T.TString $ E.encodeUtf8 _v339))) $ coinHistoryCondition_eddt record
  , (\_v339 -> P.Just (5, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v339))) $ coinHistoryCondition_appStoreCode record
  ]
write_CoinHistoryCondition :: T.Protocol p => p -> CoinHistoryCondition -> P.IO ()
write_CoinHistoryCondition oprot record = T.writeVal oprot $ from_CoinHistoryCondition record
encode_CoinHistoryCondition :: T.StatelessProtocol p => p -> CoinHistoryCondition -> LBS.ByteString
encode_CoinHistoryCondition oprot record = T.serializeVal oprot $ from_CoinHistoryCondition record
to_CoinHistoryCondition :: T.ThriftVal -> CoinHistoryCondition
to_CoinHistoryCondition (T.TStruct fields) = CoinHistoryCondition{
  coinHistoryCondition_start = P.maybe (coinHistoryCondition_start default_CoinHistoryCondition) (\(_,_val341) -> (case _val341 of {T.TI64 _val342 -> _val342; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinHistoryCondition_size = P.maybe (coinHistoryCondition_size default_CoinHistoryCondition) (\(_,_val341) -> (case _val341 of {T.TI32 _val343 -> _val343; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinHistoryCondition_language = P.maybe (coinHistoryCondition_language default_CoinHistoryCondition) (\(_,_val341) -> (case _val341 of {T.TString _val344 -> E.decodeUtf8 _val344; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinHistoryCondition_eddt = P.maybe (coinHistoryCondition_eddt default_CoinHistoryCondition) (\(_,_val341) -> (case _val341 of {T.TString _val345 -> E.decodeUtf8 _val345; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinHistoryCondition_appStoreCode = P.maybe (coinHistoryCondition_appStoreCode default_CoinHistoryCondition) (\(_,_val341) -> (case _val341 of {T.TI32 _val346 -> P.toEnum $ P.fromIntegral _val346; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_CoinHistoryCondition _ = P.error "not a struct"
read_CoinHistoryCondition :: T.Protocol p => p -> P.IO CoinHistoryCondition
read_CoinHistoryCondition iprot = to_CoinHistoryCondition <$> T.readVal iprot (T.T_STRUCT typemap_CoinHistoryCondition)
decode_CoinHistoryCondition :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinHistoryCondition
decode_CoinHistoryCondition iprot bs = to_CoinHistoryCondition $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinHistoryCondition) bs
typemap_CoinHistoryCondition :: T.TypeMap
typemap_CoinHistoryCondition = Map.fromList [(1,("start",T.T_I64)),(2,("size",T.T_I32)),(3,("language",T.T_STRING)),(4,("eddt",T.T_STRING)),(5,("appStoreCode",T.T_I32))]
default_CoinHistoryCondition :: CoinHistoryCondition
default_CoinHistoryCondition = CoinHistoryCondition{
  coinHistoryCondition_start = 0,
  coinHistoryCondition_size = 0,
  coinHistoryCondition_language = "",
  coinHistoryCondition_eddt = "",
  coinHistoryCondition_appStoreCode = (P.toEnum 0)}
data CoinHistoryResult = CoinHistoryResult  { coinHistoryResult_historys :: (Vector.Vector CoinHistory)
  , coinHistoryResult_balance :: Coin
  , coinHistoryResult_hasNext :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinHistoryResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinHistoryResult_historys record   `H.hashWithSalt` coinHistoryResult_balance record   `H.hashWithSalt` coinHistoryResult_hasNext record  
instance QC.Arbitrary CoinHistoryResult where 
  arbitrary = M.liftM CoinHistoryResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinHistoryResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinHistoryResult{coinHistoryResult_historys = coinHistoryResult_historys obj} then P.Nothing else P.Just $ default_CoinHistoryResult{coinHistoryResult_historys = coinHistoryResult_historys obj}
    , if obj == default_CoinHistoryResult{coinHistoryResult_balance = coinHistoryResult_balance obj} then P.Nothing else P.Just $ default_CoinHistoryResult{coinHistoryResult_balance = coinHistoryResult_balance obj}
    , if obj == default_CoinHistoryResult{coinHistoryResult_hasNext = coinHistoryResult_hasNext obj} then P.Nothing else P.Just $ default_CoinHistoryResult{coinHistoryResult_hasNext = coinHistoryResult_hasNext obj}
    ]
from_CoinHistoryResult :: CoinHistoryResult -> T.ThriftVal
from_CoinHistoryResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v349 -> P.Just (1, ("historys",T.TList (T.T_STRUCT typemap_CoinHistory) $ P.map (\_v351 -> from_CoinHistory _v351) $ Vector.toList _v349))) $ coinHistoryResult_historys record
  , (\_v349 -> P.Just (2, ("balance",from_Coin _v349))) $ coinHistoryResult_balance record
  , (\_v349 -> P.Just (3, ("hasNext",T.TBool _v349))) $ coinHistoryResult_hasNext record
  ]
write_CoinHistoryResult :: T.Protocol p => p -> CoinHistoryResult -> P.IO ()
write_CoinHistoryResult oprot record = T.writeVal oprot $ from_CoinHistoryResult record
encode_CoinHistoryResult :: T.StatelessProtocol p => p -> CoinHistoryResult -> LBS.ByteString
encode_CoinHistoryResult oprot record = T.serializeVal oprot $ from_CoinHistoryResult record
to_CoinHistoryResult :: T.ThriftVal -> CoinHistoryResult
to_CoinHistoryResult (T.TStruct fields) = CoinHistoryResult{
  coinHistoryResult_historys = P.maybe (coinHistoryResult_historys default_CoinHistoryResult) (\(_,_val353) -> (case _val353 of {T.TList _ _val354 -> (Vector.fromList $ P.map (\_v355 -> (case _v355 of {T.TStruct _val356 -> (to_CoinHistory (T.TStruct _val356)); _ -> P.error "wrong type"})) _val354); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinHistoryResult_balance = P.maybe (coinHistoryResult_balance default_CoinHistoryResult) (\(_,_val353) -> (case _val353 of {T.TStruct _val357 -> (to_Coin (T.TStruct _val357)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinHistoryResult_hasNext = P.maybe (coinHistoryResult_hasNext default_CoinHistoryResult) (\(_,_val353) -> (case _val353 of {T.TBool _val358 -> _val358; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CoinHistoryResult _ = P.error "not a struct"
read_CoinHistoryResult :: T.Protocol p => p -> P.IO CoinHistoryResult
read_CoinHistoryResult iprot = to_CoinHistoryResult <$> T.readVal iprot (T.T_STRUCT typemap_CoinHistoryResult)
decode_CoinHistoryResult :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinHistoryResult
decode_CoinHistoryResult iprot bs = to_CoinHistoryResult $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinHistoryResult) bs
typemap_CoinHistoryResult :: T.TypeMap
typemap_CoinHistoryResult = Map.fromList [(1,("historys",(T.T_LIST (T.T_STRUCT typemap_CoinHistory)))),(2,("balance",(T.T_STRUCT typemap_Coin))),(3,("hasNext",T.T_BOOL))]
default_CoinHistoryResult :: CoinHistoryResult
default_CoinHistoryResult = CoinHistoryResult{
  coinHistoryResult_historys = Vector.empty,
  coinHistoryResult_balance = default_Coin,
  coinHistoryResult_hasNext = P.False}
data CoinProductItem = CoinProductItem  { coinProductItem_itemId :: LT.Text
  , coinProductItem_coin :: I.Int32
  , coinProductItem_freeCoin :: I.Int32
  , coinProductItem_currency :: LT.Text
  , coinProductItem_price :: LT.Text
  , coinProductItem_displayPrice :: LT.Text
  , coinProductItem_name :: LT.Text
  , coinProductItem_desc :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinProductItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinProductItem_itemId record   `H.hashWithSalt` coinProductItem_coin record   `H.hashWithSalt` coinProductItem_freeCoin record   `H.hashWithSalt` coinProductItem_currency record   `H.hashWithSalt` coinProductItem_price record   `H.hashWithSalt` coinProductItem_displayPrice record   `H.hashWithSalt` coinProductItem_name record   `H.hashWithSalt` coinProductItem_desc record  
instance QC.Arbitrary CoinProductItem where 
  arbitrary = M.liftM CoinProductItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinProductItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinProductItem{coinProductItem_itemId = coinProductItem_itemId obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_itemId = coinProductItem_itemId obj}
    , if obj == default_CoinProductItem{coinProductItem_coin = coinProductItem_coin obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_coin = coinProductItem_coin obj}
    , if obj == default_CoinProductItem{coinProductItem_freeCoin = coinProductItem_freeCoin obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_freeCoin = coinProductItem_freeCoin obj}
    , if obj == default_CoinProductItem{coinProductItem_currency = coinProductItem_currency obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_currency = coinProductItem_currency obj}
    , if obj == default_CoinProductItem{coinProductItem_price = coinProductItem_price obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_price = coinProductItem_price obj}
    , if obj == default_CoinProductItem{coinProductItem_displayPrice = coinProductItem_displayPrice obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_displayPrice = coinProductItem_displayPrice obj}
    , if obj == default_CoinProductItem{coinProductItem_name = coinProductItem_name obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_name = coinProductItem_name obj}
    , if obj == default_CoinProductItem{coinProductItem_desc = coinProductItem_desc obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_desc = coinProductItem_desc obj}
    ]
from_CoinProductItem :: CoinProductItem -> T.ThriftVal
from_CoinProductItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v361 -> P.Just (1, ("itemId",T.TString $ E.encodeUtf8 _v361))) $ coinProductItem_itemId record
  , (\_v361 -> P.Just (2, ("coin",T.TI32 _v361))) $ coinProductItem_coin record
  , (\_v361 -> P.Just (3, ("freeCoin",T.TI32 _v361))) $ coinProductItem_freeCoin record
  , (\_v361 -> P.Just (5, ("currency",T.TString $ E.encodeUtf8 _v361))) $ coinProductItem_currency record
  , (\_v361 -> P.Just (6, ("price",T.TString $ E.encodeUtf8 _v361))) $ coinProductItem_price record
  , (\_v361 -> P.Just (7, ("displayPrice",T.TString $ E.encodeUtf8 _v361))) $ coinProductItem_displayPrice record
  , (\_v361 -> P.Just (8, ("name",T.TString $ E.encodeUtf8 _v361))) $ coinProductItem_name record
  , (\_v361 -> P.Just (9, ("desc",T.TString $ E.encodeUtf8 _v361))) $ coinProductItem_desc record
  ]
write_CoinProductItem :: T.Protocol p => p -> CoinProductItem -> P.IO ()
write_CoinProductItem oprot record = T.writeVal oprot $ from_CoinProductItem record
encode_CoinProductItem :: T.StatelessProtocol p => p -> CoinProductItem -> LBS.ByteString
encode_CoinProductItem oprot record = T.serializeVal oprot $ from_CoinProductItem record
to_CoinProductItem :: T.ThriftVal -> CoinProductItem
to_CoinProductItem (T.TStruct fields) = CoinProductItem{
  coinProductItem_itemId = P.maybe (coinProductItem_itemId default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TString _val364 -> E.decodeUtf8 _val364; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinProductItem_coin = P.maybe (coinProductItem_coin default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TI32 _val365 -> _val365; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinProductItem_freeCoin = P.maybe (coinProductItem_freeCoin default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TI32 _val366 -> _val366; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinProductItem_currency = P.maybe (coinProductItem_currency default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TString _val367 -> E.decodeUtf8 _val367; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinProductItem_price = P.maybe (coinProductItem_price default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TString _val368 -> E.decodeUtf8 _val368; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinProductItem_displayPrice = P.maybe (coinProductItem_displayPrice default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TString _val369 -> E.decodeUtf8 _val369; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  coinProductItem_name = P.maybe (coinProductItem_name default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TString _val370 -> E.decodeUtf8 _val370; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  coinProductItem_desc = P.maybe (coinProductItem_desc default_CoinProductItem) (\(_,_val363) -> (case _val363 of {T.TString _val371 -> E.decodeUtf8 _val371; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_CoinProductItem _ = P.error "not a struct"
read_CoinProductItem :: T.Protocol p => p -> P.IO CoinProductItem
read_CoinProductItem iprot = to_CoinProductItem <$> T.readVal iprot (T.T_STRUCT typemap_CoinProductItem)
decode_CoinProductItem :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinProductItem
decode_CoinProductItem iprot bs = to_CoinProductItem $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinProductItem) bs
typemap_CoinProductItem :: T.TypeMap
typemap_CoinProductItem = Map.fromList [(1,("itemId",T.T_STRING)),(2,("coin",T.T_I32)),(3,("freeCoin",T.T_I32)),(5,("currency",T.T_STRING)),(6,("price",T.T_STRING)),(7,("displayPrice",T.T_STRING)),(8,("name",T.T_STRING)),(9,("desc",T.T_STRING))]
default_CoinProductItem :: CoinProductItem
default_CoinProductItem = CoinProductItem{
  coinProductItem_itemId = "",
  coinProductItem_coin = 0,
  coinProductItem_freeCoin = 0,
  coinProductItem_currency = "",
  coinProductItem_price = "",
  coinProductItem_displayPrice = "",
  coinProductItem_name = "",
  coinProductItem_desc = ""}
data CoinPurchaseConfirm = CoinPurchaseConfirm  { coinPurchaseConfirm_orderId :: LT.Text
  , coinPurchaseConfirm_appStoreCode :: PaymentType
  , coinPurchaseConfirm_receipt :: LT.Text
  , coinPurchaseConfirm_signature :: LT.Text
  , coinPurchaseConfirm_seller :: LT.Text
  , coinPurchaseConfirm_requestType :: LT.Text
  , coinPurchaseConfirm_ignoreReceipt :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinPurchaseConfirm where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinPurchaseConfirm_orderId record   `H.hashWithSalt` coinPurchaseConfirm_appStoreCode record   `H.hashWithSalt` coinPurchaseConfirm_receipt record   `H.hashWithSalt` coinPurchaseConfirm_signature record   `H.hashWithSalt` coinPurchaseConfirm_seller record   `H.hashWithSalt` coinPurchaseConfirm_requestType record   `H.hashWithSalt` coinPurchaseConfirm_ignoreReceipt record  
instance QC.Arbitrary CoinPurchaseConfirm where 
  arbitrary = M.liftM CoinPurchaseConfirm (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinPurchaseConfirm = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_orderId = coinPurchaseConfirm_orderId obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_orderId = coinPurchaseConfirm_orderId obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_appStoreCode = coinPurchaseConfirm_appStoreCode obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_appStoreCode = coinPurchaseConfirm_appStoreCode obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_receipt = coinPurchaseConfirm_receipt obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_receipt = coinPurchaseConfirm_receipt obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_signature = coinPurchaseConfirm_signature obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_signature = coinPurchaseConfirm_signature obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_seller = coinPurchaseConfirm_seller obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_seller = coinPurchaseConfirm_seller obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_requestType = coinPurchaseConfirm_requestType obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_requestType = coinPurchaseConfirm_requestType obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_ignoreReceipt = coinPurchaseConfirm_ignoreReceipt obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_ignoreReceipt = coinPurchaseConfirm_ignoreReceipt obj}
    ]
from_CoinPurchaseConfirm :: CoinPurchaseConfirm -> T.ThriftVal
from_CoinPurchaseConfirm record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v374 -> P.Just (1, ("orderId",T.TString $ E.encodeUtf8 _v374))) $ coinPurchaseConfirm_orderId record
  , (\_v374 -> P.Just (2, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v374))) $ coinPurchaseConfirm_appStoreCode record
  , (\_v374 -> P.Just (3, ("receipt",T.TString $ E.encodeUtf8 _v374))) $ coinPurchaseConfirm_receipt record
  , (\_v374 -> P.Just (4, ("signature",T.TString $ E.encodeUtf8 _v374))) $ coinPurchaseConfirm_signature record
  , (\_v374 -> P.Just (5, ("seller",T.TString $ E.encodeUtf8 _v374))) $ coinPurchaseConfirm_seller record
  , (\_v374 -> P.Just (6, ("requestType",T.TString $ E.encodeUtf8 _v374))) $ coinPurchaseConfirm_requestType record
  , (\_v374 -> P.Just (7, ("ignoreReceipt",T.TBool _v374))) $ coinPurchaseConfirm_ignoreReceipt record
  ]
write_CoinPurchaseConfirm :: T.Protocol p => p -> CoinPurchaseConfirm -> P.IO ()
write_CoinPurchaseConfirm oprot record = T.writeVal oprot $ from_CoinPurchaseConfirm record
encode_CoinPurchaseConfirm :: T.StatelessProtocol p => p -> CoinPurchaseConfirm -> LBS.ByteString
encode_CoinPurchaseConfirm oprot record = T.serializeVal oprot $ from_CoinPurchaseConfirm record
to_CoinPurchaseConfirm :: T.ThriftVal -> CoinPurchaseConfirm
to_CoinPurchaseConfirm (T.TStruct fields) = CoinPurchaseConfirm{
  coinPurchaseConfirm_orderId = P.maybe (coinPurchaseConfirm_orderId default_CoinPurchaseConfirm) (\(_,_val376) -> (case _val376 of {T.TString _val377 -> E.decodeUtf8 _val377; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinPurchaseConfirm_appStoreCode = P.maybe (coinPurchaseConfirm_appStoreCode default_CoinPurchaseConfirm) (\(_,_val376) -> (case _val376 of {T.TI32 _val378 -> P.toEnum $ P.fromIntegral _val378; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinPurchaseConfirm_receipt = P.maybe (coinPurchaseConfirm_receipt default_CoinPurchaseConfirm) (\(_,_val376) -> (case _val376 of {T.TString _val379 -> E.decodeUtf8 _val379; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinPurchaseConfirm_signature = P.maybe (coinPurchaseConfirm_signature default_CoinPurchaseConfirm) (\(_,_val376) -> (case _val376 of {T.TString _val380 -> E.decodeUtf8 _val380; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinPurchaseConfirm_seller = P.maybe (coinPurchaseConfirm_seller default_CoinPurchaseConfirm) (\(_,_val376) -> (case _val376 of {T.TString _val381 -> E.decodeUtf8 _val381; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinPurchaseConfirm_requestType = P.maybe (coinPurchaseConfirm_requestType default_CoinPurchaseConfirm) (\(_,_val376) -> (case _val376 of {T.TString _val382 -> E.decodeUtf8 _val382; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinPurchaseConfirm_ignoreReceipt = P.maybe (coinPurchaseConfirm_ignoreReceipt default_CoinPurchaseConfirm) (\(_,_val376) -> (case _val376 of {T.TBool _val383 -> _val383; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_CoinPurchaseConfirm _ = P.error "not a struct"
read_CoinPurchaseConfirm :: T.Protocol p => p -> P.IO CoinPurchaseConfirm
read_CoinPurchaseConfirm iprot = to_CoinPurchaseConfirm <$> T.readVal iprot (T.T_STRUCT typemap_CoinPurchaseConfirm)
decode_CoinPurchaseConfirm :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinPurchaseConfirm
decode_CoinPurchaseConfirm iprot bs = to_CoinPurchaseConfirm $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinPurchaseConfirm) bs
typemap_CoinPurchaseConfirm :: T.TypeMap
typemap_CoinPurchaseConfirm = Map.fromList [(1,("orderId",T.T_STRING)),(2,("appStoreCode",T.T_I32)),(3,("receipt",T.T_STRING)),(4,("signature",T.T_STRING)),(5,("seller",T.T_STRING)),(6,("requestType",T.T_STRING)),(7,("ignoreReceipt",T.T_BOOL))]
default_CoinPurchaseConfirm :: CoinPurchaseConfirm
default_CoinPurchaseConfirm = CoinPurchaseConfirm{
  coinPurchaseConfirm_orderId = "",
  coinPurchaseConfirm_appStoreCode = (P.toEnum 0),
  coinPurchaseConfirm_receipt = "",
  coinPurchaseConfirm_signature = "",
  coinPurchaseConfirm_seller = "",
  coinPurchaseConfirm_requestType = "",
  coinPurchaseConfirm_ignoreReceipt = P.False}
data CoinPurchaseReservation = CoinPurchaseReservation  { coinPurchaseReservation_productId :: LT.Text
  , coinPurchaseReservation_country :: LT.Text
  , coinPurchaseReservation_currency :: LT.Text
  , coinPurchaseReservation_price :: LT.Text
  , coinPurchaseReservation_appStoreCode :: PaymentType
  , coinPurchaseReservation_language :: LT.Text
  , coinPurchaseReservation_pgCode :: PaymentPgType
  , coinPurchaseReservation_redirectUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinPurchaseReservation where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinPurchaseReservation_productId record   `H.hashWithSalt` coinPurchaseReservation_country record   `H.hashWithSalt` coinPurchaseReservation_currency record   `H.hashWithSalt` coinPurchaseReservation_price record   `H.hashWithSalt` coinPurchaseReservation_appStoreCode record   `H.hashWithSalt` coinPurchaseReservation_language record   `H.hashWithSalt` coinPurchaseReservation_pgCode record   `H.hashWithSalt` coinPurchaseReservation_redirectUrl record  
instance QC.Arbitrary CoinPurchaseReservation where 
  arbitrary = M.liftM CoinPurchaseReservation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinPurchaseReservation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinPurchaseReservation{coinPurchaseReservation_productId = coinPurchaseReservation_productId obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_productId = coinPurchaseReservation_productId obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_country = coinPurchaseReservation_country obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_country = coinPurchaseReservation_country obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_currency = coinPurchaseReservation_currency obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_currency = coinPurchaseReservation_currency obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_price = coinPurchaseReservation_price obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_price = coinPurchaseReservation_price obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_appStoreCode = coinPurchaseReservation_appStoreCode obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_appStoreCode = coinPurchaseReservation_appStoreCode obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_language = coinPurchaseReservation_language obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_language = coinPurchaseReservation_language obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_pgCode = coinPurchaseReservation_pgCode obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_pgCode = coinPurchaseReservation_pgCode obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_redirectUrl = coinPurchaseReservation_redirectUrl obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_redirectUrl = coinPurchaseReservation_redirectUrl obj}
    ]
from_CoinPurchaseReservation :: CoinPurchaseReservation -> T.ThriftVal
from_CoinPurchaseReservation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v386 -> P.Just (1, ("productId",T.TString $ E.encodeUtf8 _v386))) $ coinPurchaseReservation_productId record
  , (\_v386 -> P.Just (2, ("country",T.TString $ E.encodeUtf8 _v386))) $ coinPurchaseReservation_country record
  , (\_v386 -> P.Just (3, ("currency",T.TString $ E.encodeUtf8 _v386))) $ coinPurchaseReservation_currency record
  , (\_v386 -> P.Just (4, ("price",T.TString $ E.encodeUtf8 _v386))) $ coinPurchaseReservation_price record
  , (\_v386 -> P.Just (5, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v386))) $ coinPurchaseReservation_appStoreCode record
  , (\_v386 -> P.Just (6, ("language",T.TString $ E.encodeUtf8 _v386))) $ coinPurchaseReservation_language record
  , (\_v386 -> P.Just (7, ("pgCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v386))) $ coinPurchaseReservation_pgCode record
  , (\_v386 -> P.Just (8, ("redirectUrl",T.TString $ E.encodeUtf8 _v386))) $ coinPurchaseReservation_redirectUrl record
  ]
write_CoinPurchaseReservation :: T.Protocol p => p -> CoinPurchaseReservation -> P.IO ()
write_CoinPurchaseReservation oprot record = T.writeVal oprot $ from_CoinPurchaseReservation record
encode_CoinPurchaseReservation :: T.StatelessProtocol p => p -> CoinPurchaseReservation -> LBS.ByteString
encode_CoinPurchaseReservation oprot record = T.serializeVal oprot $ from_CoinPurchaseReservation record
to_CoinPurchaseReservation :: T.ThriftVal -> CoinPurchaseReservation
to_CoinPurchaseReservation (T.TStruct fields) = CoinPurchaseReservation{
  coinPurchaseReservation_productId = P.maybe (coinPurchaseReservation_productId default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TString _val389 -> E.decodeUtf8 _val389; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinPurchaseReservation_country = P.maybe (coinPurchaseReservation_country default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TString _val390 -> E.decodeUtf8 _val390; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinPurchaseReservation_currency = P.maybe (coinPurchaseReservation_currency default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TString _val391 -> E.decodeUtf8 _val391; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinPurchaseReservation_price = P.maybe (coinPurchaseReservation_price default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TString _val392 -> E.decodeUtf8 _val392; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinPurchaseReservation_appStoreCode = P.maybe (coinPurchaseReservation_appStoreCode default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TI32 _val393 -> P.toEnum $ P.fromIntegral _val393; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinPurchaseReservation_language = P.maybe (coinPurchaseReservation_language default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TString _val394 -> E.decodeUtf8 _val394; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinPurchaseReservation_pgCode = P.maybe (coinPurchaseReservation_pgCode default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TI32 _val395 -> P.toEnum $ P.fromIntegral _val395; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  coinPurchaseReservation_redirectUrl = P.maybe (coinPurchaseReservation_redirectUrl default_CoinPurchaseReservation) (\(_,_val388) -> (case _val388 of {T.TString _val396 -> E.decodeUtf8 _val396; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_CoinPurchaseReservation _ = P.error "not a struct"
read_CoinPurchaseReservation :: T.Protocol p => p -> P.IO CoinPurchaseReservation
read_CoinPurchaseReservation iprot = to_CoinPurchaseReservation <$> T.readVal iprot (T.T_STRUCT typemap_CoinPurchaseReservation)
decode_CoinPurchaseReservation :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinPurchaseReservation
decode_CoinPurchaseReservation iprot bs = to_CoinPurchaseReservation $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinPurchaseReservation) bs
typemap_CoinPurchaseReservation :: T.TypeMap
typemap_CoinPurchaseReservation = Map.fromList [(1,("productId",T.T_STRING)),(2,("country",T.T_STRING)),(3,("currency",T.T_STRING)),(4,("price",T.T_STRING)),(5,("appStoreCode",T.T_I32)),(6,("language",T.T_STRING)),(7,("pgCode",T.T_I32)),(8,("redirectUrl",T.T_STRING))]
default_CoinPurchaseReservation :: CoinPurchaseReservation
default_CoinPurchaseReservation = CoinPurchaseReservation{
  coinPurchaseReservation_productId = "",
  coinPurchaseReservation_country = "",
  coinPurchaseReservation_currency = "",
  coinPurchaseReservation_price = "",
  coinPurchaseReservation_appStoreCode = (P.toEnum 0),
  coinPurchaseReservation_language = "",
  coinPurchaseReservation_pgCode = (P.toEnum 0),
  coinPurchaseReservation_redirectUrl = ""}
data CoinUseReservationItem = CoinUseReservationItem  { coinUseReservationItem_itemId :: LT.Text
  , coinUseReservationItem_itemName :: LT.Text
  , coinUseReservationItem_amount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinUseReservationItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinUseReservationItem_itemId record   `H.hashWithSalt` coinUseReservationItem_itemName record   `H.hashWithSalt` coinUseReservationItem_amount record  
instance QC.Arbitrary CoinUseReservationItem where 
  arbitrary = M.liftM CoinUseReservationItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinUseReservationItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinUseReservationItem{coinUseReservationItem_itemId = coinUseReservationItem_itemId obj} then P.Nothing else P.Just $ default_CoinUseReservationItem{coinUseReservationItem_itemId = coinUseReservationItem_itemId obj}
    , if obj == default_CoinUseReservationItem{coinUseReservationItem_itemName = coinUseReservationItem_itemName obj} then P.Nothing else P.Just $ default_CoinUseReservationItem{coinUseReservationItem_itemName = coinUseReservationItem_itemName obj}
    , if obj == default_CoinUseReservationItem{coinUseReservationItem_amount = coinUseReservationItem_amount obj} then P.Nothing else P.Just $ default_CoinUseReservationItem{coinUseReservationItem_amount = coinUseReservationItem_amount obj}
    ]
from_CoinUseReservationItem :: CoinUseReservationItem -> T.ThriftVal
from_CoinUseReservationItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v399 -> P.Just (1, ("itemId",T.TString $ E.encodeUtf8 _v399))) $ coinUseReservationItem_itemId record
  , (\_v399 -> P.Just (2, ("itemName",T.TString $ E.encodeUtf8 _v399))) $ coinUseReservationItem_itemName record
  , (\_v399 -> P.Just (3, ("amount",T.TI32 _v399))) $ coinUseReservationItem_amount record
  ]
write_CoinUseReservationItem :: T.Protocol p => p -> CoinUseReservationItem -> P.IO ()
write_CoinUseReservationItem oprot record = T.writeVal oprot $ from_CoinUseReservationItem record
encode_CoinUseReservationItem :: T.StatelessProtocol p => p -> CoinUseReservationItem -> LBS.ByteString
encode_CoinUseReservationItem oprot record = T.serializeVal oprot $ from_CoinUseReservationItem record
to_CoinUseReservationItem :: T.ThriftVal -> CoinUseReservationItem
to_CoinUseReservationItem (T.TStruct fields) = CoinUseReservationItem{
  coinUseReservationItem_itemId = P.maybe (coinUseReservationItem_itemId default_CoinUseReservationItem) (\(_,_val401) -> (case _val401 of {T.TString _val402 -> E.decodeUtf8 _val402; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinUseReservationItem_itemName = P.maybe (coinUseReservationItem_itemName default_CoinUseReservationItem) (\(_,_val401) -> (case _val401 of {T.TString _val403 -> E.decodeUtf8 _val403; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinUseReservationItem_amount = P.maybe (coinUseReservationItem_amount default_CoinUseReservationItem) (\(_,_val401) -> (case _val401 of {T.TI32 _val404 -> _val404; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CoinUseReservationItem _ = P.error "not a struct"
read_CoinUseReservationItem :: T.Protocol p => p -> P.IO CoinUseReservationItem
read_CoinUseReservationItem iprot = to_CoinUseReservationItem <$> T.readVal iprot (T.T_STRUCT typemap_CoinUseReservationItem)
decode_CoinUseReservationItem :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinUseReservationItem
decode_CoinUseReservationItem iprot bs = to_CoinUseReservationItem $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinUseReservationItem) bs
typemap_CoinUseReservationItem :: T.TypeMap
typemap_CoinUseReservationItem = Map.fromList [(1,("itemId",T.T_STRING)),(2,("itemName",T.T_STRING)),(3,("amount",T.T_I32))]
default_CoinUseReservationItem :: CoinUseReservationItem
default_CoinUseReservationItem = CoinUseReservationItem{
  coinUseReservationItem_itemId = "",
  coinUseReservationItem_itemName = "",
  coinUseReservationItem_amount = 0}
data CoinUseReservation = CoinUseReservation  { coinUseReservation_channelId :: LT.Text
  , coinUseReservation_shopOrderId :: LT.Text
  , coinUseReservation_appStoreCode :: PaymentType
  , coinUseReservation_items :: (Vector.Vector CoinUseReservationItem)
  , coinUseReservation_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinUseReservation where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinUseReservation_channelId record   `H.hashWithSalt` coinUseReservation_shopOrderId record   `H.hashWithSalt` coinUseReservation_appStoreCode record   `H.hashWithSalt` coinUseReservation_items record   `H.hashWithSalt` coinUseReservation_country record  
instance QC.Arbitrary CoinUseReservation where 
  arbitrary = M.liftM CoinUseReservation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinUseReservation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinUseReservation{coinUseReservation_channelId = coinUseReservation_channelId obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_channelId = coinUseReservation_channelId obj}
    , if obj == default_CoinUseReservation{coinUseReservation_shopOrderId = coinUseReservation_shopOrderId obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_shopOrderId = coinUseReservation_shopOrderId obj}
    , if obj == default_CoinUseReservation{coinUseReservation_appStoreCode = coinUseReservation_appStoreCode obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_appStoreCode = coinUseReservation_appStoreCode obj}
    , if obj == default_CoinUseReservation{coinUseReservation_items = coinUseReservation_items obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_items = coinUseReservation_items obj}
    , if obj == default_CoinUseReservation{coinUseReservation_country = coinUseReservation_country obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_country = coinUseReservation_country obj}
    ]
from_CoinUseReservation :: CoinUseReservation -> T.ThriftVal
from_CoinUseReservation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v407 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v407))) $ coinUseReservation_channelId record
  , (\_v407 -> P.Just (2, ("shopOrderId",T.TString $ E.encodeUtf8 _v407))) $ coinUseReservation_shopOrderId record
  , (\_v407 -> P.Just (3, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v407))) $ coinUseReservation_appStoreCode record
  , (\_v407 -> P.Just (4, ("items",T.TList (T.T_STRUCT typemap_CoinUseReservationItem) $ P.map (\_v409 -> from_CoinUseReservationItem _v409) $ Vector.toList _v407))) $ coinUseReservation_items record
  , (\_v407 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v407))) $ coinUseReservation_country record
  ]
write_CoinUseReservation :: T.Protocol p => p -> CoinUseReservation -> P.IO ()
write_CoinUseReservation oprot record = T.writeVal oprot $ from_CoinUseReservation record
encode_CoinUseReservation :: T.StatelessProtocol p => p -> CoinUseReservation -> LBS.ByteString
encode_CoinUseReservation oprot record = T.serializeVal oprot $ from_CoinUseReservation record
to_CoinUseReservation :: T.ThriftVal -> CoinUseReservation
to_CoinUseReservation (T.TStruct fields) = CoinUseReservation{
  coinUseReservation_channelId = P.maybe (coinUseReservation_channelId default_CoinUseReservation) (\(_,_val411) -> (case _val411 of {T.TString _val412 -> E.decodeUtf8 _val412; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinUseReservation_shopOrderId = P.maybe (coinUseReservation_shopOrderId default_CoinUseReservation) (\(_,_val411) -> (case _val411 of {T.TString _val413 -> E.decodeUtf8 _val413; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinUseReservation_appStoreCode = P.maybe (coinUseReservation_appStoreCode default_CoinUseReservation) (\(_,_val411) -> (case _val411 of {T.TI32 _val414 -> P.toEnum $ P.fromIntegral _val414; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinUseReservation_items = P.maybe (coinUseReservation_items default_CoinUseReservation) (\(_,_val411) -> (case _val411 of {T.TList _ _val415 -> (Vector.fromList $ P.map (\_v416 -> (case _v416 of {T.TStruct _val417 -> (to_CoinUseReservationItem (T.TStruct _val417)); _ -> P.error "wrong type"})) _val415); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinUseReservation_country = P.maybe (coinUseReservation_country default_CoinUseReservation) (\(_,_val411) -> (case _val411 of {T.TString _val418 -> E.decodeUtf8 _val418; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_CoinUseReservation _ = P.error "not a struct"
read_CoinUseReservation :: T.Protocol p => p -> P.IO CoinUseReservation
read_CoinUseReservation iprot = to_CoinUseReservation <$> T.readVal iprot (T.T_STRUCT typemap_CoinUseReservation)
decode_CoinUseReservation :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinUseReservation
decode_CoinUseReservation iprot bs = to_CoinUseReservation $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinUseReservation) bs
typemap_CoinUseReservation :: T.TypeMap
typemap_CoinUseReservation = Map.fromList [(1,("channelId",T.T_STRING)),(2,("shopOrderId",T.T_STRING)),(3,("appStoreCode",T.T_I32)),(4,("items",(T.T_LIST (T.T_STRUCT typemap_CoinUseReservationItem)))),(5,("country",T.T_STRING))]
default_CoinUseReservation :: CoinUseReservation
default_CoinUseReservation = CoinUseReservation{
  coinUseReservation_channelId = "",
  coinUseReservation_shopOrderId = "",
  coinUseReservation_appStoreCode = (P.toEnum 0),
  coinUseReservation_items = Vector.empty,
  coinUseReservation_country = ""}
data CompactContact = CompactContact  { compactContact_mid :: LT.Text
  , compactContact_createdTime :: I.Int64
  , compactContact_modifiedTime :: I.Int64
  , compactContact_status :: ContactStatus
  , compactContact_settings :: I.Int64
  , compactContact_displayNameOverridden :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CompactContact where
  hashWithSalt salt record = salt   `H.hashWithSalt` compactContact_mid record   `H.hashWithSalt` compactContact_createdTime record   `H.hashWithSalt` compactContact_modifiedTime record   `H.hashWithSalt` compactContact_status record   `H.hashWithSalt` compactContact_settings record   `H.hashWithSalt` compactContact_displayNameOverridden record  
instance QC.Arbitrary CompactContact where 
  arbitrary = M.liftM CompactContact (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CompactContact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CompactContact{compactContact_mid = compactContact_mid obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_mid = compactContact_mid obj}
    , if obj == default_CompactContact{compactContact_createdTime = compactContact_createdTime obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_createdTime = compactContact_createdTime obj}
    , if obj == default_CompactContact{compactContact_modifiedTime = compactContact_modifiedTime obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_modifiedTime = compactContact_modifiedTime obj}
    , if obj == default_CompactContact{compactContact_status = compactContact_status obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_status = compactContact_status obj}
    , if obj == default_CompactContact{compactContact_settings = compactContact_settings obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_settings = compactContact_settings obj}
    , if obj == default_CompactContact{compactContact_displayNameOverridden = compactContact_displayNameOverridden obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_displayNameOverridden = compactContact_displayNameOverridden obj}
    ]
from_CompactContact :: CompactContact -> T.ThriftVal
from_CompactContact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v421 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v421))) $ compactContact_mid record
  , (\_v421 -> P.Just (2, ("createdTime",T.TI64 _v421))) $ compactContact_createdTime record
  , (\_v421 -> P.Just (3, ("modifiedTime",T.TI64 _v421))) $ compactContact_modifiedTime record
  , (\_v421 -> P.Just (4, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v421))) $ compactContact_status record
  , (\_v421 -> P.Just (5, ("settings",T.TI64 _v421))) $ compactContact_settings record
  , (\_v421 -> P.Just (6, ("displayNameOverridden",T.TString $ E.encodeUtf8 _v421))) $ compactContact_displayNameOverridden record
  ]
write_CompactContact :: T.Protocol p => p -> CompactContact -> P.IO ()
write_CompactContact oprot record = T.writeVal oprot $ from_CompactContact record
encode_CompactContact :: T.StatelessProtocol p => p -> CompactContact -> LBS.ByteString
encode_CompactContact oprot record = T.serializeVal oprot $ from_CompactContact record
to_CompactContact :: T.ThriftVal -> CompactContact
to_CompactContact (T.TStruct fields) = CompactContact{
  compactContact_mid = P.maybe (compactContact_mid default_CompactContact) (\(_,_val423) -> (case _val423 of {T.TString _val424 -> E.decodeUtf8 _val424; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  compactContact_createdTime = P.maybe (compactContact_createdTime default_CompactContact) (\(_,_val423) -> (case _val423 of {T.TI64 _val425 -> _val425; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  compactContact_modifiedTime = P.maybe (compactContact_modifiedTime default_CompactContact) (\(_,_val423) -> (case _val423 of {T.TI64 _val426 -> _val426; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  compactContact_status = P.maybe (compactContact_status default_CompactContact) (\(_,_val423) -> (case _val423 of {T.TI32 _val427 -> P.toEnum $ P.fromIntegral _val427; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  compactContact_settings = P.maybe (compactContact_settings default_CompactContact) (\(_,_val423) -> (case _val423 of {T.TI64 _val428 -> _val428; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  compactContact_displayNameOverridden = P.maybe (compactContact_displayNameOverridden default_CompactContact) (\(_,_val423) -> (case _val423 of {T.TString _val429 -> E.decodeUtf8 _val429; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_CompactContact _ = P.error "not a struct"
read_CompactContact :: T.Protocol p => p -> P.IO CompactContact
read_CompactContact iprot = to_CompactContact <$> T.readVal iprot (T.T_STRUCT typemap_CompactContact)
decode_CompactContact :: T.StatelessProtocol p => p -> LBS.ByteString -> CompactContact
decode_CompactContact iprot bs = to_CompactContact $ T.deserializeVal iprot (T.T_STRUCT typemap_CompactContact) bs
typemap_CompactContact :: T.TypeMap
typemap_CompactContact = Map.fromList [(1,("mid",T.T_STRING)),(2,("createdTime",T.T_I64)),(3,("modifiedTime",T.T_I64)),(4,("status",T.T_I32)),(5,("settings",T.T_I64)),(6,("displayNameOverridden",T.T_STRING))]
default_CompactContact :: CompactContact
default_CompactContact = CompactContact{
  compactContact_mid = "",
  compactContact_createdTime = 0,
  compactContact_modifiedTime = 0,
  compactContact_status = (P.toEnum 0),
  compactContact_settings = 0,
  compactContact_displayNameOverridden = ""}
data ContactModification = ContactModification  { contactModification_type :: ModificationType
  , contactModification_luid :: LT.Text
  , contactModification_phones :: (Vector.Vector LT.Text)
  , contactModification_emails :: (Vector.Vector LT.Text)
  , contactModification_userids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactModification where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactModification_type record   `H.hashWithSalt` contactModification_luid record   `H.hashWithSalt` contactModification_phones record   `H.hashWithSalt` contactModification_emails record   `H.hashWithSalt` contactModification_userids record  
instance QC.Arbitrary ContactModification where 
  arbitrary = M.liftM ContactModification (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactModification = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactModification{contactModification_type = contactModification_type obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_type = contactModification_type obj}
    , if obj == default_ContactModification{contactModification_luid = contactModification_luid obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_luid = contactModification_luid obj}
    , if obj == default_ContactModification{contactModification_phones = contactModification_phones obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_phones = contactModification_phones obj}
    , if obj == default_ContactModification{contactModification_emails = contactModification_emails obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_emails = contactModification_emails obj}
    , if obj == default_ContactModification{contactModification_userids = contactModification_userids obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_userids = contactModification_userids obj}
    ]
from_ContactModification :: ContactModification -> T.ThriftVal
from_ContactModification record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v432 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v432))) $ contactModification_type record
  , (\_v432 -> P.Just (2, ("luid",T.TString $ E.encodeUtf8 _v432))) $ contactModification_luid record
  , (\_v432 -> P.Just (11, ("phones",T.TList T.T_STRING $ P.map (\_v434 -> T.TString $ E.encodeUtf8 _v434) $ Vector.toList _v432))) $ contactModification_phones record
  , (\_v432 -> P.Just (12, ("emails",T.TList T.T_STRING $ P.map (\_v436 -> T.TString $ E.encodeUtf8 _v436) $ Vector.toList _v432))) $ contactModification_emails record
  , (\_v432 -> P.Just (13, ("userids",T.TList T.T_STRING $ P.map (\_v438 -> T.TString $ E.encodeUtf8 _v438) $ Vector.toList _v432))) $ contactModification_userids record
  ]
write_ContactModification :: T.Protocol p => p -> ContactModification -> P.IO ()
write_ContactModification oprot record = T.writeVal oprot $ from_ContactModification record
encode_ContactModification :: T.StatelessProtocol p => p -> ContactModification -> LBS.ByteString
encode_ContactModification oprot record = T.serializeVal oprot $ from_ContactModification record
to_ContactModification :: T.ThriftVal -> ContactModification
to_ContactModification (T.TStruct fields) = ContactModification{
  contactModification_type = P.maybe (contactModification_type default_ContactModification) (\(_,_val440) -> (case _val440 of {T.TI32 _val441 -> P.toEnum $ P.fromIntegral _val441; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactModification_luid = P.maybe (contactModification_luid default_ContactModification) (\(_,_val440) -> (case _val440 of {T.TString _val442 -> E.decodeUtf8 _val442; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contactModification_phones = P.maybe (contactModification_phones default_ContactModification) (\(_,_val440) -> (case _val440 of {T.TList _ _val443 -> (Vector.fromList $ P.map (\_v444 -> (case _v444 of {T.TString _val445 -> E.decodeUtf8 _val445; _ -> P.error "wrong type"})) _val443); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  contactModification_emails = P.maybe (contactModification_emails default_ContactModification) (\(_,_val440) -> (case _val440 of {T.TList _ _val446 -> (Vector.fromList $ P.map (\_v447 -> (case _v447 of {T.TString _val448 -> E.decodeUtf8 _val448; _ -> P.error "wrong type"})) _val446); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  contactModification_userids = P.maybe (contactModification_userids default_ContactModification) (\(_,_val440) -> (case _val440 of {T.TList _ _val449 -> (Vector.fromList $ P.map (\_v450 -> (case _v450 of {T.TString _val451 -> E.decodeUtf8 _val451; _ -> P.error "wrong type"})) _val449); _ -> P.error "wrong type"})) (Map.lookup (13) fields)
  }
to_ContactModification _ = P.error "not a struct"
read_ContactModification :: T.Protocol p => p -> P.IO ContactModification
read_ContactModification iprot = to_ContactModification <$> T.readVal iprot (T.T_STRUCT typemap_ContactModification)
decode_ContactModification :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactModification
decode_ContactModification iprot bs = to_ContactModification $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactModification) bs
typemap_ContactModification :: T.TypeMap
typemap_ContactModification = Map.fromList [(1,("type",T.T_I32)),(2,("luid",T.T_STRING)),(11,("phones",(T.T_LIST T.T_STRING))),(12,("emails",(T.T_LIST T.T_STRING))),(13,("userids",(T.T_LIST T.T_STRING)))]
default_ContactModification :: ContactModification
default_ContactModification = ContactModification{
  contactModification_type = (P.toEnum 0),
  contactModification_luid = "",
  contactModification_phones = Vector.empty,
  contactModification_emails = Vector.empty,
  contactModification_userids = Vector.empty}
data ContactRegistration = ContactRegistration  { contactRegistration_contact :: Contact
  , contactRegistration_luid :: LT.Text
  , contactRegistration_contactType :: ContactType
  , contactRegistration_contactKey :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactRegistration where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactRegistration_contact record   `H.hashWithSalt` contactRegistration_luid record   `H.hashWithSalt` contactRegistration_contactType record   `H.hashWithSalt` contactRegistration_contactKey record  
instance QC.Arbitrary ContactRegistration where 
  arbitrary = M.liftM ContactRegistration (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactRegistration = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactRegistration{contactRegistration_contact = contactRegistration_contact obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_contact = contactRegistration_contact obj}
    , if obj == default_ContactRegistration{contactRegistration_luid = contactRegistration_luid obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_luid = contactRegistration_luid obj}
    , if obj == default_ContactRegistration{contactRegistration_contactType = contactRegistration_contactType obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_contactType = contactRegistration_contactType obj}
    , if obj == default_ContactRegistration{contactRegistration_contactKey = contactRegistration_contactKey obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_contactKey = contactRegistration_contactKey obj}
    ]
from_ContactRegistration :: ContactRegistration -> T.ThriftVal
from_ContactRegistration record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v454 -> P.Just (1, ("contact",from_Contact _v454))) $ contactRegistration_contact record
  , (\_v454 -> P.Just (10, ("luid",T.TString $ E.encodeUtf8 _v454))) $ contactRegistration_luid record
  , (\_v454 -> P.Just (11, ("contactType",T.TI32 $ P.fromIntegral $ P.fromEnum _v454))) $ contactRegistration_contactType record
  , (\_v454 -> P.Just (12, ("contactKey",T.TString $ E.encodeUtf8 _v454))) $ contactRegistration_contactKey record
  ]
write_ContactRegistration :: T.Protocol p => p -> ContactRegistration -> P.IO ()
write_ContactRegistration oprot record = T.writeVal oprot $ from_ContactRegistration record
encode_ContactRegistration :: T.StatelessProtocol p => p -> ContactRegistration -> LBS.ByteString
encode_ContactRegistration oprot record = T.serializeVal oprot $ from_ContactRegistration record
to_ContactRegistration :: T.ThriftVal -> ContactRegistration
to_ContactRegistration (T.TStruct fields) = ContactRegistration{
  contactRegistration_contact = P.maybe (contactRegistration_contact default_ContactRegistration) (\(_,_val456) -> (case _val456 of {T.TStruct _val457 -> (to_Contact (T.TStruct _val457)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactRegistration_luid = P.maybe (contactRegistration_luid default_ContactRegistration) (\(_,_val456) -> (case _val456 of {T.TString _val458 -> E.decodeUtf8 _val458; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  contactRegistration_contactType = P.maybe (contactRegistration_contactType default_ContactRegistration) (\(_,_val456) -> (case _val456 of {T.TI32 _val459 -> P.toEnum $ P.fromIntegral _val459; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  contactRegistration_contactKey = P.maybe (contactRegistration_contactKey default_ContactRegistration) (\(_,_val456) -> (case _val456 of {T.TString _val460 -> E.decodeUtf8 _val460; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_ContactRegistration _ = P.error "not a struct"
read_ContactRegistration :: T.Protocol p => p -> P.IO ContactRegistration
read_ContactRegistration iprot = to_ContactRegistration <$> T.readVal iprot (T.T_STRUCT typemap_ContactRegistration)
decode_ContactRegistration :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactRegistration
decode_ContactRegistration iprot bs = to_ContactRegistration $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactRegistration) bs
typemap_ContactRegistration :: T.TypeMap
typemap_ContactRegistration = Map.fromList [(1,("contact",(T.T_STRUCT typemap_Contact))),(10,("luid",T.T_STRING)),(11,("contactType",T.T_I32)),(12,("contactKey",T.T_STRING))]
default_ContactRegistration :: ContactRegistration
default_ContactRegistration = ContactRegistration{
  contactRegistration_contact = default_Contact,
  contactRegistration_luid = "",
  contactRegistration_contactType = (P.toEnum 0),
  contactRegistration_contactKey = ""}
data ContactReport = ContactReport  { contactReport_mid :: LT.Text
  , contactReport_exists :: P.Bool
  , contactReport_contact :: Contact
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactReport where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactReport_mid record   `H.hashWithSalt` contactReport_exists record   `H.hashWithSalt` contactReport_contact record  
instance QC.Arbitrary ContactReport where 
  arbitrary = M.liftM ContactReport (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactReport = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactReport{contactReport_mid = contactReport_mid obj} then P.Nothing else P.Just $ default_ContactReport{contactReport_mid = contactReport_mid obj}
    , if obj == default_ContactReport{contactReport_exists = contactReport_exists obj} then P.Nothing else P.Just $ default_ContactReport{contactReport_exists = contactReport_exists obj}
    , if obj == default_ContactReport{contactReport_contact = contactReport_contact obj} then P.Nothing else P.Just $ default_ContactReport{contactReport_contact = contactReport_contact obj}
    ]
from_ContactReport :: ContactReport -> T.ThriftVal
from_ContactReport record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v463 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v463))) $ contactReport_mid record
  , (\_v463 -> P.Just (2, ("exists",T.TBool _v463))) $ contactReport_exists record
  , (\_v463 -> P.Just (3, ("contact",from_Contact _v463))) $ contactReport_contact record
  ]
write_ContactReport :: T.Protocol p => p -> ContactReport -> P.IO ()
write_ContactReport oprot record = T.writeVal oprot $ from_ContactReport record
encode_ContactReport :: T.StatelessProtocol p => p -> ContactReport -> LBS.ByteString
encode_ContactReport oprot record = T.serializeVal oprot $ from_ContactReport record
to_ContactReport :: T.ThriftVal -> ContactReport
to_ContactReport (T.TStruct fields) = ContactReport{
  contactReport_mid = P.maybe (contactReport_mid default_ContactReport) (\(_,_val465) -> (case _val465 of {T.TString _val466 -> E.decodeUtf8 _val466; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactReport_exists = P.maybe (contactReport_exists default_ContactReport) (\(_,_val465) -> (case _val465 of {T.TBool _val467 -> _val467; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contactReport_contact = P.maybe (contactReport_contact default_ContactReport) (\(_,_val465) -> (case _val465 of {T.TStruct _val468 -> (to_Contact (T.TStruct _val468)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ContactReport _ = P.error "not a struct"
read_ContactReport :: T.Protocol p => p -> P.IO ContactReport
read_ContactReport iprot = to_ContactReport <$> T.readVal iprot (T.T_STRUCT typemap_ContactReport)
decode_ContactReport :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactReport
decode_ContactReport iprot bs = to_ContactReport $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactReport) bs
typemap_ContactReport :: T.TypeMap
typemap_ContactReport = Map.fromList [(1,("mid",T.T_STRING)),(2,("exists",T.T_BOOL)),(3,("contact",(T.T_STRUCT typemap_Contact)))]
default_ContactReport :: ContactReport
default_ContactReport = ContactReport{
  contactReport_mid = "",
  contactReport_exists = P.False,
  contactReport_contact = default_Contact}
data ContactReportResult = ContactReportResult  { contactReportResult_mid :: LT.Text
  , contactReportResult_exists :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactReportResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactReportResult_mid record   `H.hashWithSalt` contactReportResult_exists record  
instance QC.Arbitrary ContactReportResult where 
  arbitrary = M.liftM ContactReportResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactReportResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactReportResult{contactReportResult_mid = contactReportResult_mid obj} then P.Nothing else P.Just $ default_ContactReportResult{contactReportResult_mid = contactReportResult_mid obj}
    , if obj == default_ContactReportResult{contactReportResult_exists = contactReportResult_exists obj} then P.Nothing else P.Just $ default_ContactReportResult{contactReportResult_exists = contactReportResult_exists obj}
    ]
from_ContactReportResult :: ContactReportResult -> T.ThriftVal
from_ContactReportResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v471 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v471))) $ contactReportResult_mid record
  , (\_v471 -> P.Just (2, ("exists",T.TBool _v471))) $ contactReportResult_exists record
  ]
write_ContactReportResult :: T.Protocol p => p -> ContactReportResult -> P.IO ()
write_ContactReportResult oprot record = T.writeVal oprot $ from_ContactReportResult record
encode_ContactReportResult :: T.StatelessProtocol p => p -> ContactReportResult -> LBS.ByteString
encode_ContactReportResult oprot record = T.serializeVal oprot $ from_ContactReportResult record
to_ContactReportResult :: T.ThriftVal -> ContactReportResult
to_ContactReportResult (T.TStruct fields) = ContactReportResult{
  contactReportResult_mid = P.maybe (contactReportResult_mid default_ContactReportResult) (\(_,_val473) -> (case _val473 of {T.TString _val474 -> E.decodeUtf8 _val474; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactReportResult_exists = P.maybe (contactReportResult_exists default_ContactReportResult) (\(_,_val473) -> (case _val473 of {T.TBool _val475 -> _val475; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ContactReportResult _ = P.error "not a struct"
read_ContactReportResult :: T.Protocol p => p -> P.IO ContactReportResult
read_ContactReportResult iprot = to_ContactReportResult <$> T.readVal iprot (T.T_STRUCT typemap_ContactReportResult)
decode_ContactReportResult :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactReportResult
decode_ContactReportResult iprot bs = to_ContactReportResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactReportResult) bs
typemap_ContactReportResult :: T.TypeMap
typemap_ContactReportResult = Map.fromList [(1,("mid",T.T_STRING)),(2,("exists",T.T_BOOL))]
default_ContactReportResult :: ContactReportResult
default_ContactReportResult = ContactReportResult{
  contactReportResult_mid = "",
  contactReportResult_exists = P.False}
data DeviceInfo = DeviceInfo  { deviceInfo_deviceName :: LT.Text
  , deviceInfo_systemName :: LT.Text
  , deviceInfo_systemVersion :: LT.Text
  , deviceInfo_model :: LT.Text
  , deviceInfo_carrierCode :: CarrierCode
  , deviceInfo_carrierName :: LT.Text
  , deviceInfo_applicationType :: ApplicationType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeviceInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` deviceInfo_deviceName record   `H.hashWithSalt` deviceInfo_systemName record   `H.hashWithSalt` deviceInfo_systemVersion record   `H.hashWithSalt` deviceInfo_model record   `H.hashWithSalt` deviceInfo_carrierCode record   `H.hashWithSalt` deviceInfo_carrierName record   `H.hashWithSalt` deviceInfo_applicationType record  
instance QC.Arbitrary DeviceInfo where 
  arbitrary = M.liftM DeviceInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DeviceInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeviceInfo{deviceInfo_deviceName = deviceInfo_deviceName obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_deviceName = deviceInfo_deviceName obj}
    , if obj == default_DeviceInfo{deviceInfo_systemName = deviceInfo_systemName obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_systemName = deviceInfo_systemName obj}
    , if obj == default_DeviceInfo{deviceInfo_systemVersion = deviceInfo_systemVersion obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_systemVersion = deviceInfo_systemVersion obj}
    , if obj == default_DeviceInfo{deviceInfo_model = deviceInfo_model obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_model = deviceInfo_model obj}
    , if obj == default_DeviceInfo{deviceInfo_carrierCode = deviceInfo_carrierCode obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_carrierCode = deviceInfo_carrierCode obj}
    , if obj == default_DeviceInfo{deviceInfo_carrierName = deviceInfo_carrierName obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_carrierName = deviceInfo_carrierName obj}
    , if obj == default_DeviceInfo{deviceInfo_applicationType = deviceInfo_applicationType obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_applicationType = deviceInfo_applicationType obj}
    ]
from_DeviceInfo :: DeviceInfo -> T.ThriftVal
from_DeviceInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v478 -> P.Just (1, ("deviceName",T.TString $ E.encodeUtf8 _v478))) $ deviceInfo_deviceName record
  , (\_v478 -> P.Just (2, ("systemName",T.TString $ E.encodeUtf8 _v478))) $ deviceInfo_systemName record
  , (\_v478 -> P.Just (3, ("systemVersion",T.TString $ E.encodeUtf8 _v478))) $ deviceInfo_systemVersion record
  , (\_v478 -> P.Just (4, ("model",T.TString $ E.encodeUtf8 _v478))) $ deviceInfo_model record
  , (\_v478 -> P.Just (10, ("carrierCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v478))) $ deviceInfo_carrierCode record
  , (\_v478 -> P.Just (11, ("carrierName",T.TString $ E.encodeUtf8 _v478))) $ deviceInfo_carrierName record
  , (\_v478 -> P.Just (20, ("applicationType",T.TI32 $ P.fromIntegral $ P.fromEnum _v478))) $ deviceInfo_applicationType record
  ]
write_DeviceInfo :: T.Protocol p => p -> DeviceInfo -> P.IO ()
write_DeviceInfo oprot record = T.writeVal oprot $ from_DeviceInfo record
encode_DeviceInfo :: T.StatelessProtocol p => p -> DeviceInfo -> LBS.ByteString
encode_DeviceInfo oprot record = T.serializeVal oprot $ from_DeviceInfo record
to_DeviceInfo :: T.ThriftVal -> DeviceInfo
to_DeviceInfo (T.TStruct fields) = DeviceInfo{
  deviceInfo_deviceName = P.maybe (deviceInfo_deviceName default_DeviceInfo) (\(_,_val480) -> (case _val480 of {T.TString _val481 -> E.decodeUtf8 _val481; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  deviceInfo_systemName = P.maybe (deviceInfo_systemName default_DeviceInfo) (\(_,_val480) -> (case _val480 of {T.TString _val482 -> E.decodeUtf8 _val482; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  deviceInfo_systemVersion = P.maybe (deviceInfo_systemVersion default_DeviceInfo) (\(_,_val480) -> (case _val480 of {T.TString _val483 -> E.decodeUtf8 _val483; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  deviceInfo_model = P.maybe (deviceInfo_model default_DeviceInfo) (\(_,_val480) -> (case _val480 of {T.TString _val484 -> E.decodeUtf8 _val484; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  deviceInfo_carrierCode = P.maybe (deviceInfo_carrierCode default_DeviceInfo) (\(_,_val480) -> (case _val480 of {T.TI32 _val485 -> P.toEnum $ P.fromIntegral _val485; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  deviceInfo_carrierName = P.maybe (deviceInfo_carrierName default_DeviceInfo) (\(_,_val480) -> (case _val480 of {T.TString _val486 -> E.decodeUtf8 _val486; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  deviceInfo_applicationType = P.maybe (deviceInfo_applicationType default_DeviceInfo) (\(_,_val480) -> (case _val480 of {T.TI32 _val487 -> P.toEnum $ P.fromIntegral _val487; _ -> P.error "wrong type"})) (Map.lookup (20) fields)
  }
to_DeviceInfo _ = P.error "not a struct"
read_DeviceInfo :: T.Protocol p => p -> P.IO DeviceInfo
read_DeviceInfo iprot = to_DeviceInfo <$> T.readVal iprot (T.T_STRUCT typemap_DeviceInfo)
decode_DeviceInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> DeviceInfo
decode_DeviceInfo iprot bs = to_DeviceInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_DeviceInfo) bs
typemap_DeviceInfo :: T.TypeMap
typemap_DeviceInfo = Map.fromList [(1,("deviceName",T.T_STRING)),(2,("systemName",T.T_STRING)),(3,("systemVersion",T.T_STRING)),(4,("model",T.T_STRING)),(10,("carrierCode",T.T_I32)),(11,("carrierName",T.T_STRING)),(20,("applicationType",T.T_I32))]
default_DeviceInfo :: DeviceInfo
default_DeviceInfo = DeviceInfo{
  deviceInfo_deviceName = "",
  deviceInfo_systemName = "",
  deviceInfo_systemVersion = "",
  deviceInfo_model = "",
  deviceInfo_carrierCode = (P.toEnum 0),
  deviceInfo_carrierName = "",
  deviceInfo_applicationType = (P.toEnum 0)}
data EmailConfirmation = EmailConfirmation  { emailConfirmation_usePasswordSet :: P.Bool
  , emailConfirmation_email :: LT.Text
  , emailConfirmation_password :: LT.Text
  , emailConfirmation_ignoreDuplication :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EmailConfirmation where
  hashWithSalt salt record = salt   `H.hashWithSalt` emailConfirmation_usePasswordSet record   `H.hashWithSalt` emailConfirmation_email record   `H.hashWithSalt` emailConfirmation_password record   `H.hashWithSalt` emailConfirmation_ignoreDuplication record  
instance QC.Arbitrary EmailConfirmation where 
  arbitrary = M.liftM EmailConfirmation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_EmailConfirmation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EmailConfirmation{emailConfirmation_usePasswordSet = emailConfirmation_usePasswordSet obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_usePasswordSet = emailConfirmation_usePasswordSet obj}
    , if obj == default_EmailConfirmation{emailConfirmation_email = emailConfirmation_email obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_email = emailConfirmation_email obj}
    , if obj == default_EmailConfirmation{emailConfirmation_password = emailConfirmation_password obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_password = emailConfirmation_password obj}
    , if obj == default_EmailConfirmation{emailConfirmation_ignoreDuplication = emailConfirmation_ignoreDuplication obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_ignoreDuplication = emailConfirmation_ignoreDuplication obj}
    ]
from_EmailConfirmation :: EmailConfirmation -> T.ThriftVal
from_EmailConfirmation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v490 -> P.Just (1, ("usePasswordSet",T.TBool _v490))) $ emailConfirmation_usePasswordSet record
  , (\_v490 -> P.Just (2, ("email",T.TString $ E.encodeUtf8 _v490))) $ emailConfirmation_email record
  , (\_v490 -> P.Just (3, ("password",T.TString $ E.encodeUtf8 _v490))) $ emailConfirmation_password record
  , (\_v490 -> P.Just (4, ("ignoreDuplication",T.TBool _v490))) $ emailConfirmation_ignoreDuplication record
  ]
write_EmailConfirmation :: T.Protocol p => p -> EmailConfirmation -> P.IO ()
write_EmailConfirmation oprot record = T.writeVal oprot $ from_EmailConfirmation record
encode_EmailConfirmation :: T.StatelessProtocol p => p -> EmailConfirmation -> LBS.ByteString
encode_EmailConfirmation oprot record = T.serializeVal oprot $ from_EmailConfirmation record
to_EmailConfirmation :: T.ThriftVal -> EmailConfirmation
to_EmailConfirmation (T.TStruct fields) = EmailConfirmation{
  emailConfirmation_usePasswordSet = P.maybe (emailConfirmation_usePasswordSet default_EmailConfirmation) (\(_,_val492) -> (case _val492 of {T.TBool _val493 -> _val493; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  emailConfirmation_email = P.maybe (emailConfirmation_email default_EmailConfirmation) (\(_,_val492) -> (case _val492 of {T.TString _val494 -> E.decodeUtf8 _val494; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  emailConfirmation_password = P.maybe (emailConfirmation_password default_EmailConfirmation) (\(_,_val492) -> (case _val492 of {T.TString _val495 -> E.decodeUtf8 _val495; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  emailConfirmation_ignoreDuplication = P.maybe (emailConfirmation_ignoreDuplication default_EmailConfirmation) (\(_,_val492) -> (case _val492 of {T.TBool _val496 -> _val496; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_EmailConfirmation _ = P.error "not a struct"
read_EmailConfirmation :: T.Protocol p => p -> P.IO EmailConfirmation
read_EmailConfirmation iprot = to_EmailConfirmation <$> T.readVal iprot (T.T_STRUCT typemap_EmailConfirmation)
decode_EmailConfirmation :: T.StatelessProtocol p => p -> LBS.ByteString -> EmailConfirmation
decode_EmailConfirmation iprot bs = to_EmailConfirmation $ T.deserializeVal iprot (T.T_STRUCT typemap_EmailConfirmation) bs
typemap_EmailConfirmation :: T.TypeMap
typemap_EmailConfirmation = Map.fromList [(1,("usePasswordSet",T.T_BOOL)),(2,("email",T.T_STRING)),(3,("password",T.T_STRING)),(4,("ignoreDuplication",T.T_BOOL))]
default_EmailConfirmation :: EmailConfirmation
default_EmailConfirmation = EmailConfirmation{
  emailConfirmation_usePasswordSet = P.False,
  emailConfirmation_email = "",
  emailConfirmation_password = "",
  emailConfirmation_ignoreDuplication = P.False}
data EmailConfirmationSession = EmailConfirmationSession  { emailConfirmationSession_emailConfirmationType :: EmailConfirmationType
  , emailConfirmationSession_verifier :: LT.Text
  , emailConfirmationSession_targetEmail :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EmailConfirmationSession where
  hashWithSalt salt record = salt   `H.hashWithSalt` emailConfirmationSession_emailConfirmationType record   `H.hashWithSalt` emailConfirmationSession_verifier record   `H.hashWithSalt` emailConfirmationSession_targetEmail record  
instance QC.Arbitrary EmailConfirmationSession where 
  arbitrary = M.liftM EmailConfirmationSession (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_EmailConfirmationSession = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EmailConfirmationSession{emailConfirmationSession_emailConfirmationType = emailConfirmationSession_emailConfirmationType obj} then P.Nothing else P.Just $ default_EmailConfirmationSession{emailConfirmationSession_emailConfirmationType = emailConfirmationSession_emailConfirmationType obj}
    , if obj == default_EmailConfirmationSession{emailConfirmationSession_verifier = emailConfirmationSession_verifier obj} then P.Nothing else P.Just $ default_EmailConfirmationSession{emailConfirmationSession_verifier = emailConfirmationSession_verifier obj}
    , if obj == default_EmailConfirmationSession{emailConfirmationSession_targetEmail = emailConfirmationSession_targetEmail obj} then P.Nothing else P.Just $ default_EmailConfirmationSession{emailConfirmationSession_targetEmail = emailConfirmationSession_targetEmail obj}
    ]
from_EmailConfirmationSession :: EmailConfirmationSession -> T.ThriftVal
from_EmailConfirmationSession record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v499 -> P.Just (1, ("emailConfirmationType",T.TI32 $ P.fromIntegral $ P.fromEnum _v499))) $ emailConfirmationSession_emailConfirmationType record
  , (\_v499 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v499))) $ emailConfirmationSession_verifier record
  , (\_v499 -> P.Just (3, ("targetEmail",T.TString $ E.encodeUtf8 _v499))) $ emailConfirmationSession_targetEmail record
  ]
write_EmailConfirmationSession :: T.Protocol p => p -> EmailConfirmationSession -> P.IO ()
write_EmailConfirmationSession oprot record = T.writeVal oprot $ from_EmailConfirmationSession record
encode_EmailConfirmationSession :: T.StatelessProtocol p => p -> EmailConfirmationSession -> LBS.ByteString
encode_EmailConfirmationSession oprot record = T.serializeVal oprot $ from_EmailConfirmationSession record
to_EmailConfirmationSession :: T.ThriftVal -> EmailConfirmationSession
to_EmailConfirmationSession (T.TStruct fields) = EmailConfirmationSession{
  emailConfirmationSession_emailConfirmationType = P.maybe (emailConfirmationSession_emailConfirmationType default_EmailConfirmationSession) (\(_,_val501) -> (case _val501 of {T.TI32 _val502 -> P.toEnum $ P.fromIntegral _val502; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  emailConfirmationSession_verifier = P.maybe (emailConfirmationSession_verifier default_EmailConfirmationSession) (\(_,_val501) -> (case _val501 of {T.TString _val503 -> E.decodeUtf8 _val503; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  emailConfirmationSession_targetEmail = P.maybe (emailConfirmationSession_targetEmail default_EmailConfirmationSession) (\(_,_val501) -> (case _val501 of {T.TString _val504 -> E.decodeUtf8 _val504; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_EmailConfirmationSession _ = P.error "not a struct"
read_EmailConfirmationSession :: T.Protocol p => p -> P.IO EmailConfirmationSession
read_EmailConfirmationSession iprot = to_EmailConfirmationSession <$> T.readVal iprot (T.T_STRUCT typemap_EmailConfirmationSession)
decode_EmailConfirmationSession :: T.StatelessProtocol p => p -> LBS.ByteString -> EmailConfirmationSession
decode_EmailConfirmationSession iprot bs = to_EmailConfirmationSession $ T.deserializeVal iprot (T.T_STRUCT typemap_EmailConfirmationSession) bs
typemap_EmailConfirmationSession :: T.TypeMap
typemap_EmailConfirmationSession = Map.fromList [(1,("emailConfirmationType",T.T_I32)),(2,("verifier",T.T_STRING)),(3,("targetEmail",T.T_STRING))]
default_EmailConfirmationSession :: EmailConfirmationSession
default_EmailConfirmationSession = EmailConfirmationSession{
  emailConfirmationSession_emailConfirmationType = (P.toEnum 0),
  emailConfirmationSession_verifier = "",
  emailConfirmationSession_targetEmail = ""}
data FriendChannelMatrix = FriendChannelMatrix  { friendChannelMatrix_channelId :: LT.Text
  , friendChannelMatrix_representMid :: LT.Text
  , friendChannelMatrix_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FriendChannelMatrix where
  hashWithSalt salt record = salt   `H.hashWithSalt` friendChannelMatrix_channelId record   `H.hashWithSalt` friendChannelMatrix_representMid record   `H.hashWithSalt` friendChannelMatrix_count record  
instance QC.Arbitrary FriendChannelMatrix where 
  arbitrary = M.liftM FriendChannelMatrix (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FriendChannelMatrix = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FriendChannelMatrix{friendChannelMatrix_channelId = friendChannelMatrix_channelId obj} then P.Nothing else P.Just $ default_FriendChannelMatrix{friendChannelMatrix_channelId = friendChannelMatrix_channelId obj}
    , if obj == default_FriendChannelMatrix{friendChannelMatrix_representMid = friendChannelMatrix_representMid obj} then P.Nothing else P.Just $ default_FriendChannelMatrix{friendChannelMatrix_representMid = friendChannelMatrix_representMid obj}
    , if obj == default_FriendChannelMatrix{friendChannelMatrix_count = friendChannelMatrix_count obj} then P.Nothing else P.Just $ default_FriendChannelMatrix{friendChannelMatrix_count = friendChannelMatrix_count obj}
    ]
from_FriendChannelMatrix :: FriendChannelMatrix -> T.ThriftVal
from_FriendChannelMatrix record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v507 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v507))) $ friendChannelMatrix_channelId record
  , (\_v507 -> P.Just (2, ("representMid",T.TString $ E.encodeUtf8 _v507))) $ friendChannelMatrix_representMid record
  , (\_v507 -> P.Just (3, ("count",T.TI32 _v507))) $ friendChannelMatrix_count record
  ]
write_FriendChannelMatrix :: T.Protocol p => p -> FriendChannelMatrix -> P.IO ()
write_FriendChannelMatrix oprot record = T.writeVal oprot $ from_FriendChannelMatrix record
encode_FriendChannelMatrix :: T.StatelessProtocol p => p -> FriendChannelMatrix -> LBS.ByteString
encode_FriendChannelMatrix oprot record = T.serializeVal oprot $ from_FriendChannelMatrix record
to_FriendChannelMatrix :: T.ThriftVal -> FriendChannelMatrix
to_FriendChannelMatrix (T.TStruct fields) = FriendChannelMatrix{
  friendChannelMatrix_channelId = P.maybe (friendChannelMatrix_channelId default_FriendChannelMatrix) (\(_,_val509) -> (case _val509 of {T.TString _val510 -> E.decodeUtf8 _val510; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  friendChannelMatrix_representMid = P.maybe (friendChannelMatrix_representMid default_FriendChannelMatrix) (\(_,_val509) -> (case _val509 of {T.TString _val511 -> E.decodeUtf8 _val511; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  friendChannelMatrix_count = P.maybe (friendChannelMatrix_count default_FriendChannelMatrix) (\(_,_val509) -> (case _val509 of {T.TI32 _val512 -> _val512; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FriendChannelMatrix _ = P.error "not a struct"
read_FriendChannelMatrix :: T.Protocol p => p -> P.IO FriendChannelMatrix
read_FriendChannelMatrix iprot = to_FriendChannelMatrix <$> T.readVal iprot (T.T_STRUCT typemap_FriendChannelMatrix)
decode_FriendChannelMatrix :: T.StatelessProtocol p => p -> LBS.ByteString -> FriendChannelMatrix
decode_FriendChannelMatrix iprot bs = to_FriendChannelMatrix $ T.deserializeVal iprot (T.T_STRUCT typemap_FriendChannelMatrix) bs
typemap_FriendChannelMatrix :: T.TypeMap
typemap_FriendChannelMatrix = Map.fromList [(1,("channelId",T.T_STRING)),(2,("representMid",T.T_STRING)),(3,("count",T.T_I32))]
default_FriendChannelMatrix :: FriendChannelMatrix
default_FriendChannelMatrix = FriendChannelMatrix{
  friendChannelMatrix_channelId = "",
  friendChannelMatrix_representMid = "",
  friendChannelMatrix_count = 0}
data FriendChannelMatricesResponse = FriendChannelMatricesResponse  { friendChannelMatricesResponse_expires :: I.Int64
  , friendChannelMatricesResponse_matrices :: (Vector.Vector FriendChannelMatrix)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FriendChannelMatricesResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` friendChannelMatricesResponse_expires record   `H.hashWithSalt` friendChannelMatricesResponse_matrices record  
instance QC.Arbitrary FriendChannelMatricesResponse where 
  arbitrary = M.liftM FriendChannelMatricesResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FriendChannelMatricesResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FriendChannelMatricesResponse{friendChannelMatricesResponse_expires = friendChannelMatricesResponse_expires obj} then P.Nothing else P.Just $ default_FriendChannelMatricesResponse{friendChannelMatricesResponse_expires = friendChannelMatricesResponse_expires obj}
    , if obj == default_FriendChannelMatricesResponse{friendChannelMatricesResponse_matrices = friendChannelMatricesResponse_matrices obj} then P.Nothing else P.Just $ default_FriendChannelMatricesResponse{friendChannelMatricesResponse_matrices = friendChannelMatricesResponse_matrices obj}
    ]
from_FriendChannelMatricesResponse :: FriendChannelMatricesResponse -> T.ThriftVal
from_FriendChannelMatricesResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v515 -> P.Just (1, ("expires",T.TI64 _v515))) $ friendChannelMatricesResponse_expires record
  , (\_v515 -> P.Just (2, ("matrices",T.TList (T.T_STRUCT typemap_FriendChannelMatrix) $ P.map (\_v517 -> from_FriendChannelMatrix _v517) $ Vector.toList _v515))) $ friendChannelMatricesResponse_matrices record
  ]
write_FriendChannelMatricesResponse :: T.Protocol p => p -> FriendChannelMatricesResponse -> P.IO ()
write_FriendChannelMatricesResponse oprot record = T.writeVal oprot $ from_FriendChannelMatricesResponse record
encode_FriendChannelMatricesResponse :: T.StatelessProtocol p => p -> FriendChannelMatricesResponse -> LBS.ByteString
encode_FriendChannelMatricesResponse oprot record = T.serializeVal oprot $ from_FriendChannelMatricesResponse record
to_FriendChannelMatricesResponse :: T.ThriftVal -> FriendChannelMatricesResponse
to_FriendChannelMatricesResponse (T.TStruct fields) = FriendChannelMatricesResponse{
  friendChannelMatricesResponse_expires = P.maybe (friendChannelMatricesResponse_expires default_FriendChannelMatricesResponse) (\(_,_val519) -> (case _val519 of {T.TI64 _val520 -> _val520; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  friendChannelMatricesResponse_matrices = P.maybe (friendChannelMatricesResponse_matrices default_FriendChannelMatricesResponse) (\(_,_val519) -> (case _val519 of {T.TList _ _val521 -> (Vector.fromList $ P.map (\_v522 -> (case _v522 of {T.TStruct _val523 -> (to_FriendChannelMatrix (T.TStruct _val523)); _ -> P.error "wrong type"})) _val521); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FriendChannelMatricesResponse _ = P.error "not a struct"
read_FriendChannelMatricesResponse :: T.Protocol p => p -> P.IO FriendChannelMatricesResponse
read_FriendChannelMatricesResponse iprot = to_FriendChannelMatricesResponse <$> T.readVal iprot (T.T_STRUCT typemap_FriendChannelMatricesResponse)
decode_FriendChannelMatricesResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> FriendChannelMatricesResponse
decode_FriendChannelMatricesResponse iprot bs = to_FriendChannelMatricesResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_FriendChannelMatricesResponse) bs
typemap_FriendChannelMatricesResponse :: T.TypeMap
typemap_FriendChannelMatricesResponse = Map.fromList [(1,("expires",T.T_I64)),(2,("matrices",(T.T_LIST (T.T_STRUCT typemap_FriendChannelMatrix))))]
default_FriendChannelMatricesResponse :: FriendChannelMatricesResponse
default_FriendChannelMatricesResponse = FriendChannelMatricesResponse{
  friendChannelMatricesResponse_expires = 0,
  friendChannelMatricesResponse_matrices = Vector.empty}
data Geolocation = Geolocation  { geolocation_longitude :: P.Double
  , geolocation_latitude :: P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Geolocation where
  hashWithSalt salt record = salt   `H.hashWithSalt` geolocation_longitude record   `H.hashWithSalt` geolocation_latitude record  
instance QC.Arbitrary Geolocation where 
  arbitrary = M.liftM Geolocation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Geolocation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Geolocation{geolocation_longitude = geolocation_longitude obj} then P.Nothing else P.Just $ default_Geolocation{geolocation_longitude = geolocation_longitude obj}
    , if obj == default_Geolocation{geolocation_latitude = geolocation_latitude obj} then P.Nothing else P.Just $ default_Geolocation{geolocation_latitude = geolocation_latitude obj}
    ]
from_Geolocation :: Geolocation -> T.ThriftVal
from_Geolocation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v526 -> P.Just (1, ("longitude",T.TDouble _v526))) $ geolocation_longitude record
  , (\_v526 -> P.Just (2, ("latitude",T.TDouble _v526))) $ geolocation_latitude record
  ]
write_Geolocation :: T.Protocol p => p -> Geolocation -> P.IO ()
write_Geolocation oprot record = T.writeVal oprot $ from_Geolocation record
encode_Geolocation :: T.StatelessProtocol p => p -> Geolocation -> LBS.ByteString
encode_Geolocation oprot record = T.serializeVal oprot $ from_Geolocation record
to_Geolocation :: T.ThriftVal -> Geolocation
to_Geolocation (T.TStruct fields) = Geolocation{
  geolocation_longitude = P.maybe (geolocation_longitude default_Geolocation) (\(_,_val528) -> (case _val528 of {T.TDouble _val529 -> _val529; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  geolocation_latitude = P.maybe (geolocation_latitude default_Geolocation) (\(_,_val528) -> (case _val528 of {T.TDouble _val530 -> _val530; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Geolocation _ = P.error "not a struct"
read_Geolocation :: T.Protocol p => p -> P.IO Geolocation
read_Geolocation iprot = to_Geolocation <$> T.readVal iprot (T.T_STRUCT typemap_Geolocation)
decode_Geolocation :: T.StatelessProtocol p => p -> LBS.ByteString -> Geolocation
decode_Geolocation iprot bs = to_Geolocation $ T.deserializeVal iprot (T.T_STRUCT typemap_Geolocation) bs
typemap_Geolocation :: T.TypeMap
typemap_Geolocation = Map.fromList [(1,("longitude",T.T_DOUBLE)),(2,("latitude",T.T_DOUBLE))]
default_Geolocation :: Geolocation
default_Geolocation = Geolocation{
  geolocation_longitude = 0,
  geolocation_latitude = 0}
data NotificationTarget = NotificationTarget  { notificationTarget_applicationType :: LT.Text
  , notificationTarget_applicationVersion :: LT.Text
  , notificationTarget_region :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotificationTarget where
  hashWithSalt salt record = salt   `H.hashWithSalt` notificationTarget_applicationType record   `H.hashWithSalt` notificationTarget_applicationVersion record   `H.hashWithSalt` notificationTarget_region record  
instance QC.Arbitrary NotificationTarget where 
  arbitrary = M.liftM NotificationTarget (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotificationTarget = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotificationTarget{notificationTarget_applicationType = notificationTarget_applicationType obj} then P.Nothing else P.Just $ default_NotificationTarget{notificationTarget_applicationType = notificationTarget_applicationType obj}
    , if obj == default_NotificationTarget{notificationTarget_applicationVersion = notificationTarget_applicationVersion obj} then P.Nothing else P.Just $ default_NotificationTarget{notificationTarget_applicationVersion = notificationTarget_applicationVersion obj}
    , if obj == default_NotificationTarget{notificationTarget_region = notificationTarget_region obj} then P.Nothing else P.Just $ default_NotificationTarget{notificationTarget_region = notificationTarget_region obj}
    ]
from_NotificationTarget :: NotificationTarget -> T.ThriftVal
from_NotificationTarget record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v533 -> P.Just (1, ("applicationType",T.TString $ E.encodeUtf8 _v533))) $ notificationTarget_applicationType record
  , (\_v533 -> P.Just (2, ("applicationVersion",T.TString $ E.encodeUtf8 _v533))) $ notificationTarget_applicationVersion record
  , (\_v533 -> P.Just (3, ("region",T.TString $ E.encodeUtf8 _v533))) $ notificationTarget_region record
  ]
write_NotificationTarget :: T.Protocol p => p -> NotificationTarget -> P.IO ()
write_NotificationTarget oprot record = T.writeVal oprot $ from_NotificationTarget record
encode_NotificationTarget :: T.StatelessProtocol p => p -> NotificationTarget -> LBS.ByteString
encode_NotificationTarget oprot record = T.serializeVal oprot $ from_NotificationTarget record
to_NotificationTarget :: T.ThriftVal -> NotificationTarget
to_NotificationTarget (T.TStruct fields) = NotificationTarget{
  notificationTarget_applicationType = P.maybe (notificationTarget_applicationType default_NotificationTarget) (\(_,_val535) -> (case _val535 of {T.TString _val536 -> E.decodeUtf8 _val536; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notificationTarget_applicationVersion = P.maybe (notificationTarget_applicationVersion default_NotificationTarget) (\(_,_val535) -> (case _val535 of {T.TString _val537 -> E.decodeUtf8 _val537; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notificationTarget_region = P.maybe (notificationTarget_region default_NotificationTarget) (\(_,_val535) -> (case _val535 of {T.TString _val538 -> E.decodeUtf8 _val538; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotificationTarget _ = P.error "not a struct"
read_NotificationTarget :: T.Protocol p => p -> P.IO NotificationTarget
read_NotificationTarget iprot = to_NotificationTarget <$> T.readVal iprot (T.T_STRUCT typemap_NotificationTarget)
decode_NotificationTarget :: T.StatelessProtocol p => p -> LBS.ByteString -> NotificationTarget
decode_NotificationTarget iprot bs = to_NotificationTarget $ T.deserializeVal iprot (T.T_STRUCT typemap_NotificationTarget) bs
typemap_NotificationTarget :: T.TypeMap
typemap_NotificationTarget = Map.fromList [(1,("applicationType",T.T_STRING)),(2,("applicationVersion",T.T_STRING)),(3,("region",T.T_STRING))]
default_NotificationTarget :: NotificationTarget
default_NotificationTarget = NotificationTarget{
  notificationTarget_applicationType = "",
  notificationTarget_applicationVersion = "",
  notificationTarget_region = ""}
data GlobalEvent = GlobalEvent  { globalEvent_key :: LT.Text
  , globalEvent_targets :: (Vector.Vector NotificationTarget)
  , globalEvent_createdTime :: I.Int64
  , globalEvent_data :: I.Int64
  , globalEvent_maxDelay :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GlobalEvent where
  hashWithSalt salt record = salt   `H.hashWithSalt` globalEvent_key record   `H.hashWithSalt` globalEvent_targets record   `H.hashWithSalt` globalEvent_createdTime record   `H.hashWithSalt` globalEvent_data record   `H.hashWithSalt` globalEvent_maxDelay record  
instance QC.Arbitrary GlobalEvent where 
  arbitrary = M.liftM GlobalEvent (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GlobalEvent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GlobalEvent{globalEvent_key = globalEvent_key obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_key = globalEvent_key obj}
    , if obj == default_GlobalEvent{globalEvent_targets = globalEvent_targets obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_targets = globalEvent_targets obj}
    , if obj == default_GlobalEvent{globalEvent_createdTime = globalEvent_createdTime obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_createdTime = globalEvent_createdTime obj}
    , if obj == default_GlobalEvent{globalEvent_data = globalEvent_data obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_data = globalEvent_data obj}
    , if obj == default_GlobalEvent{globalEvent_maxDelay = globalEvent_maxDelay obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_maxDelay = globalEvent_maxDelay obj}
    ]
from_GlobalEvent :: GlobalEvent -> T.ThriftVal
from_GlobalEvent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v541 -> P.Just (1, ("key",T.TString $ E.encodeUtf8 _v541))) $ globalEvent_key record
  , (\_v541 -> P.Just (2, ("targets",T.TList (T.T_STRUCT typemap_NotificationTarget) $ P.map (\_v543 -> from_NotificationTarget _v543) $ Vector.toList _v541))) $ globalEvent_targets record
  , (\_v541 -> P.Just (3, ("createdTime",T.TI64 _v541))) $ globalEvent_createdTime record
  , (\_v541 -> P.Just (4, ("data",T.TI64 _v541))) $ globalEvent_data record
  , (\_v541 -> P.Just (5, ("maxDelay",T.TI32 _v541))) $ globalEvent_maxDelay record
  ]
write_GlobalEvent :: T.Protocol p => p -> GlobalEvent -> P.IO ()
write_GlobalEvent oprot record = T.writeVal oprot $ from_GlobalEvent record
encode_GlobalEvent :: T.StatelessProtocol p => p -> GlobalEvent -> LBS.ByteString
encode_GlobalEvent oprot record = T.serializeVal oprot $ from_GlobalEvent record
to_GlobalEvent :: T.ThriftVal -> GlobalEvent
to_GlobalEvent (T.TStruct fields) = GlobalEvent{
  globalEvent_key = P.maybe (globalEvent_key default_GlobalEvent) (\(_,_val545) -> (case _val545 of {T.TString _val546 -> E.decodeUtf8 _val546; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  globalEvent_targets = P.maybe (globalEvent_targets default_GlobalEvent) (\(_,_val545) -> (case _val545 of {T.TList _ _val547 -> (Vector.fromList $ P.map (\_v548 -> (case _v548 of {T.TStruct _val549 -> (to_NotificationTarget (T.TStruct _val549)); _ -> P.error "wrong type"})) _val547); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  globalEvent_createdTime = P.maybe (globalEvent_createdTime default_GlobalEvent) (\(_,_val545) -> (case _val545 of {T.TI64 _val550 -> _val550; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  globalEvent_data = P.maybe (globalEvent_data default_GlobalEvent) (\(_,_val545) -> (case _val545 of {T.TI64 _val551 -> _val551; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  globalEvent_maxDelay = P.maybe (globalEvent_maxDelay default_GlobalEvent) (\(_,_val545) -> (case _val545 of {T.TI32 _val552 -> _val552; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GlobalEvent _ = P.error "not a struct"
read_GlobalEvent :: T.Protocol p => p -> P.IO GlobalEvent
read_GlobalEvent iprot = to_GlobalEvent <$> T.readVal iprot (T.T_STRUCT typemap_GlobalEvent)
decode_GlobalEvent :: T.StatelessProtocol p => p -> LBS.ByteString -> GlobalEvent
decode_GlobalEvent iprot bs = to_GlobalEvent $ T.deserializeVal iprot (T.T_STRUCT typemap_GlobalEvent) bs
typemap_GlobalEvent :: T.TypeMap
typemap_GlobalEvent = Map.fromList [(1,("key",T.T_STRING)),(2,("targets",(T.T_LIST (T.T_STRUCT typemap_NotificationTarget)))),(3,("createdTime",T.T_I64)),(4,("data",T.T_I64)),(5,("maxDelay",T.T_I32))]
default_GlobalEvent :: GlobalEvent
default_GlobalEvent = GlobalEvent{
  globalEvent_key = "",
  globalEvent_targets = Vector.empty,
  globalEvent_createdTime = 0,
  globalEvent_data = 0,
  globalEvent_maxDelay = 0}
data Group = Group  { group_id :: LT.Text
  , group_createdTime :: I.Int64
  , group_name :: LT.Text
  , group_pictureStatus :: LT.Text
  , group_members :: (Vector.Vector Contact)
  , group_creator :: Contact
  , group_invitee :: (Vector.Vector Contact)
  , group_notificationDisabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Group where
  hashWithSalt salt record = salt   `H.hashWithSalt` group_id record   `H.hashWithSalt` group_createdTime record   `H.hashWithSalt` group_name record   `H.hashWithSalt` group_pictureStatus record   `H.hashWithSalt` group_members record   `H.hashWithSalt` group_creator record   `H.hashWithSalt` group_invitee record   `H.hashWithSalt` group_notificationDisabled record  
instance QC.Arbitrary Group where 
  arbitrary = M.liftM Group (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Group = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Group{group_id = group_id obj} then P.Nothing else P.Just $ default_Group{group_id = group_id obj}
    , if obj == default_Group{group_createdTime = group_createdTime obj} then P.Nothing else P.Just $ default_Group{group_createdTime = group_createdTime obj}
    , if obj == default_Group{group_name = group_name obj} then P.Nothing else P.Just $ default_Group{group_name = group_name obj}
    , if obj == default_Group{group_pictureStatus = group_pictureStatus obj} then P.Nothing else P.Just $ default_Group{group_pictureStatus = group_pictureStatus obj}
    , if obj == default_Group{group_members = group_members obj} then P.Nothing else P.Just $ default_Group{group_members = group_members obj}
    , if obj == default_Group{group_creator = group_creator obj} then P.Nothing else P.Just $ default_Group{group_creator = group_creator obj}
    , if obj == default_Group{group_invitee = group_invitee obj} then P.Nothing else P.Just $ default_Group{group_invitee = group_invitee obj}
    , if obj == default_Group{group_notificationDisabled = group_notificationDisabled obj} then P.Nothing else P.Just $ default_Group{group_notificationDisabled = group_notificationDisabled obj}
    ]
from_Group :: Group -> T.ThriftVal
from_Group record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v555 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v555))) $ group_id record
  , (\_v555 -> P.Just (2, ("createdTime",T.TI64 _v555))) $ group_createdTime record
  , (\_v555 -> P.Just (10, ("name",T.TString $ E.encodeUtf8 _v555))) $ group_name record
  , (\_v555 -> P.Just (11, ("pictureStatus",T.TString $ E.encodeUtf8 _v555))) $ group_pictureStatus record
  , (\_v555 -> P.Just (20, ("members",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v557 -> from_Contact _v557) $ Vector.toList _v555))) $ group_members record
  , (\_v555 -> P.Just (21, ("creator",from_Contact _v555))) $ group_creator record
  , (\_v555 -> P.Just (22, ("invitee",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v559 -> from_Contact _v559) $ Vector.toList _v555))) $ group_invitee record
  , (\_v555 -> P.Just (31, ("notificationDisabled",T.TBool _v555))) $ group_notificationDisabled record
  ]
write_Group :: T.Protocol p => p -> Group -> P.IO ()
write_Group oprot record = T.writeVal oprot $ from_Group record
encode_Group :: T.StatelessProtocol p => p -> Group -> LBS.ByteString
encode_Group oprot record = T.serializeVal oprot $ from_Group record
to_Group :: T.ThriftVal -> Group
to_Group (T.TStruct fields) = Group{
  group_id = P.maybe (group_id default_Group) (\(_,_val561) -> (case _val561 of {T.TString _val562 -> E.decodeUtf8 _val562; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  group_createdTime = P.maybe (group_createdTime default_Group) (\(_,_val561) -> (case _val561 of {T.TI64 _val563 -> _val563; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  group_name = P.maybe (group_name default_Group) (\(_,_val561) -> (case _val561 of {T.TString _val564 -> E.decodeUtf8 _val564; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  group_pictureStatus = P.maybe (group_pictureStatus default_Group) (\(_,_val561) -> (case _val561 of {T.TString _val565 -> E.decodeUtf8 _val565; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  group_members = P.maybe (group_members default_Group) (\(_,_val561) -> (case _val561 of {T.TList _ _val566 -> (Vector.fromList $ P.map (\_v567 -> (case _v567 of {T.TStruct _val568 -> (to_Contact (T.TStruct _val568)); _ -> P.error "wrong type"})) _val566); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  group_creator = P.maybe (group_creator default_Group) (\(_,_val561) -> (case _val561 of {T.TStruct _val569 -> (to_Contact (T.TStruct _val569)); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  group_invitee = P.maybe (group_invitee default_Group) (\(_,_val561) -> (case _val561 of {T.TList _ _val570 -> (Vector.fromList $ P.map (\_v571 -> (case _v571 of {T.TStruct _val572 -> (to_Contact (T.TStruct _val572)); _ -> P.error "wrong type"})) _val570); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  group_notificationDisabled = P.maybe (group_notificationDisabled default_Group) (\(_,_val561) -> (case _val561 of {T.TBool _val573 -> _val573; _ -> P.error "wrong type"})) (Map.lookup (31) fields)
  }
to_Group _ = P.error "not a struct"
read_Group :: T.Protocol p => p -> P.IO Group
read_Group iprot = to_Group <$> T.readVal iprot (T.T_STRUCT typemap_Group)
decode_Group :: T.StatelessProtocol p => p -> LBS.ByteString -> Group
decode_Group iprot bs = to_Group $ T.deserializeVal iprot (T.T_STRUCT typemap_Group) bs
typemap_Group :: T.TypeMap
typemap_Group = Map.fromList [(1,("id",T.T_STRING)),(2,("createdTime",T.T_I64)),(10,("name",T.T_STRING)),(11,("pictureStatus",T.T_STRING)),(20,("members",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(21,("creator",(T.T_STRUCT typemap_Contact))),(22,("invitee",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(31,("notificationDisabled",T.T_BOOL))]
default_Group :: Group
default_Group = Group{
  group_id = "",
  group_createdTime = 0,
  group_name = "",
  group_pictureStatus = "",
  group_members = Vector.empty,
  group_creator = default_Contact,
  group_invitee = Vector.empty,
  group_notificationDisabled = P.False}
data IdentityCredential = IdentityCredential  { identityCredential_provider :: IdentityProvider
  , identityCredential_identifier :: LT.Text
  , identityCredential_password :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IdentityCredential where
  hashWithSalt salt record = salt   `H.hashWithSalt` identityCredential_provider record   `H.hashWithSalt` identityCredential_identifier record   `H.hashWithSalt` identityCredential_password record  
instance QC.Arbitrary IdentityCredential where 
  arbitrary = M.liftM IdentityCredential (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IdentityCredential = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IdentityCredential{identityCredential_provider = identityCredential_provider obj} then P.Nothing else P.Just $ default_IdentityCredential{identityCredential_provider = identityCredential_provider obj}
    , if obj == default_IdentityCredential{identityCredential_identifier = identityCredential_identifier obj} then P.Nothing else P.Just $ default_IdentityCredential{identityCredential_identifier = identityCredential_identifier obj}
    , if obj == default_IdentityCredential{identityCredential_password = identityCredential_password obj} then P.Nothing else P.Just $ default_IdentityCredential{identityCredential_password = identityCredential_password obj}
    ]
from_IdentityCredential :: IdentityCredential -> T.ThriftVal
from_IdentityCredential record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v576 -> P.Just (1, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v576))) $ identityCredential_provider record
  , (\_v576 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v576))) $ identityCredential_identifier record
  , (\_v576 -> P.Just (3, ("password",T.TString $ E.encodeUtf8 _v576))) $ identityCredential_password record
  ]
write_IdentityCredential :: T.Protocol p => p -> IdentityCredential -> P.IO ()
write_IdentityCredential oprot record = T.writeVal oprot $ from_IdentityCredential record
encode_IdentityCredential :: T.StatelessProtocol p => p -> IdentityCredential -> LBS.ByteString
encode_IdentityCredential oprot record = T.serializeVal oprot $ from_IdentityCredential record
to_IdentityCredential :: T.ThriftVal -> IdentityCredential
to_IdentityCredential (T.TStruct fields) = IdentityCredential{
  identityCredential_provider = P.maybe (identityCredential_provider default_IdentityCredential) (\(_,_val578) -> (case _val578 of {T.TI32 _val579 -> P.toEnum $ P.fromIntegral _val579; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  identityCredential_identifier = P.maybe (identityCredential_identifier default_IdentityCredential) (\(_,_val578) -> (case _val578 of {T.TString _val580 -> E.decodeUtf8 _val580; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  identityCredential_password = P.maybe (identityCredential_password default_IdentityCredential) (\(_,_val578) -> (case _val578 of {T.TString _val581 -> E.decodeUtf8 _val581; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_IdentityCredential _ = P.error "not a struct"
read_IdentityCredential :: T.Protocol p => p -> P.IO IdentityCredential
read_IdentityCredential iprot = to_IdentityCredential <$> T.readVal iprot (T.T_STRUCT typemap_IdentityCredential)
decode_IdentityCredential :: T.StatelessProtocol p => p -> LBS.ByteString -> IdentityCredential
decode_IdentityCredential iprot bs = to_IdentityCredential $ T.deserializeVal iprot (T.T_STRUCT typemap_IdentityCredential) bs
typemap_IdentityCredential :: T.TypeMap
typemap_IdentityCredential = Map.fromList [(1,("provider",T.T_I32)),(2,("identifier",T.T_STRING)),(3,("password",T.T_STRING))]
default_IdentityCredential :: IdentityCredential
default_IdentityCredential = IdentityCredential{
  identityCredential_provider = (P.toEnum 0),
  identityCredential_identifier = "",
  identityCredential_password = ""}
data LastReadMessageId = LastReadMessageId  { lastReadMessageId_mid :: LT.Text
  , lastReadMessageId_lastReadMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LastReadMessageId where
  hashWithSalt salt record = salt   `H.hashWithSalt` lastReadMessageId_mid record   `H.hashWithSalt` lastReadMessageId_lastReadMessageId record  
instance QC.Arbitrary LastReadMessageId where 
  arbitrary = M.liftM LastReadMessageId (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LastReadMessageId = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LastReadMessageId{lastReadMessageId_mid = lastReadMessageId_mid obj} then P.Nothing else P.Just $ default_LastReadMessageId{lastReadMessageId_mid = lastReadMessageId_mid obj}
    , if obj == default_LastReadMessageId{lastReadMessageId_lastReadMessageId = lastReadMessageId_lastReadMessageId obj} then P.Nothing else P.Just $ default_LastReadMessageId{lastReadMessageId_lastReadMessageId = lastReadMessageId_lastReadMessageId obj}
    ]
from_LastReadMessageId :: LastReadMessageId -> T.ThriftVal
from_LastReadMessageId record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v584 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v584))) $ lastReadMessageId_mid record
  , (\_v584 -> P.Just (2, ("lastReadMessageId",T.TString $ E.encodeUtf8 _v584))) $ lastReadMessageId_lastReadMessageId record
  ]
write_LastReadMessageId :: T.Protocol p => p -> LastReadMessageId -> P.IO ()
write_LastReadMessageId oprot record = T.writeVal oprot $ from_LastReadMessageId record
encode_LastReadMessageId :: T.StatelessProtocol p => p -> LastReadMessageId -> LBS.ByteString
encode_LastReadMessageId oprot record = T.serializeVal oprot $ from_LastReadMessageId record
to_LastReadMessageId :: T.ThriftVal -> LastReadMessageId
to_LastReadMessageId (T.TStruct fields) = LastReadMessageId{
  lastReadMessageId_mid = P.maybe (lastReadMessageId_mid default_LastReadMessageId) (\(_,_val586) -> (case _val586 of {T.TString _val587 -> E.decodeUtf8 _val587; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lastReadMessageId_lastReadMessageId = P.maybe (lastReadMessageId_lastReadMessageId default_LastReadMessageId) (\(_,_val586) -> (case _val586 of {T.TString _val588 -> E.decodeUtf8 _val588; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LastReadMessageId _ = P.error "not a struct"
read_LastReadMessageId :: T.Protocol p => p -> P.IO LastReadMessageId
read_LastReadMessageId iprot = to_LastReadMessageId <$> T.readVal iprot (T.T_STRUCT typemap_LastReadMessageId)
decode_LastReadMessageId :: T.StatelessProtocol p => p -> LBS.ByteString -> LastReadMessageId
decode_LastReadMessageId iprot bs = to_LastReadMessageId $ T.deserializeVal iprot (T.T_STRUCT typemap_LastReadMessageId) bs
typemap_LastReadMessageId :: T.TypeMap
typemap_LastReadMessageId = Map.fromList [(1,("mid",T.T_STRING)),(2,("lastReadMessageId",T.T_STRING))]
default_LastReadMessageId :: LastReadMessageId
default_LastReadMessageId = LastReadMessageId{
  lastReadMessageId_mid = "",
  lastReadMessageId_lastReadMessageId = ""}
data LastReadMessageIds = LastReadMessageIds  { lastReadMessageIds_chatId :: LT.Text
  , lastReadMessageIds_lastReadMessageIds :: (Vector.Vector LastReadMessageId)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LastReadMessageIds where
  hashWithSalt salt record = salt   `H.hashWithSalt` lastReadMessageIds_chatId record   `H.hashWithSalt` lastReadMessageIds_lastReadMessageIds record  
instance QC.Arbitrary LastReadMessageIds where 
  arbitrary = M.liftM LastReadMessageIds (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LastReadMessageIds = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LastReadMessageIds{lastReadMessageIds_chatId = lastReadMessageIds_chatId obj} then P.Nothing else P.Just $ default_LastReadMessageIds{lastReadMessageIds_chatId = lastReadMessageIds_chatId obj}
    , if obj == default_LastReadMessageIds{lastReadMessageIds_lastReadMessageIds = lastReadMessageIds_lastReadMessageIds obj} then P.Nothing else P.Just $ default_LastReadMessageIds{lastReadMessageIds_lastReadMessageIds = lastReadMessageIds_lastReadMessageIds obj}
    ]
from_LastReadMessageIds :: LastReadMessageIds -> T.ThriftVal
from_LastReadMessageIds record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v591 -> P.Just (1, ("chatId",T.TString $ E.encodeUtf8 _v591))) $ lastReadMessageIds_chatId record
  , (\_v591 -> P.Just (2, ("lastReadMessageIds",T.TList (T.T_STRUCT typemap_LastReadMessageId) $ P.map (\_v593 -> from_LastReadMessageId _v593) $ Vector.toList _v591))) $ lastReadMessageIds_lastReadMessageIds record
  ]
write_LastReadMessageIds :: T.Protocol p => p -> LastReadMessageIds -> P.IO ()
write_LastReadMessageIds oprot record = T.writeVal oprot $ from_LastReadMessageIds record
encode_LastReadMessageIds :: T.StatelessProtocol p => p -> LastReadMessageIds -> LBS.ByteString
encode_LastReadMessageIds oprot record = T.serializeVal oprot $ from_LastReadMessageIds record
to_LastReadMessageIds :: T.ThriftVal -> LastReadMessageIds
to_LastReadMessageIds (T.TStruct fields) = LastReadMessageIds{
  lastReadMessageIds_chatId = P.maybe (lastReadMessageIds_chatId default_LastReadMessageIds) (\(_,_val595) -> (case _val595 of {T.TString _val596 -> E.decodeUtf8 _val596; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lastReadMessageIds_lastReadMessageIds = P.maybe (lastReadMessageIds_lastReadMessageIds default_LastReadMessageIds) (\(_,_val595) -> (case _val595 of {T.TList _ _val597 -> (Vector.fromList $ P.map (\_v598 -> (case _v598 of {T.TStruct _val599 -> (to_LastReadMessageId (T.TStruct _val599)); _ -> P.error "wrong type"})) _val597); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LastReadMessageIds _ = P.error "not a struct"
read_LastReadMessageIds :: T.Protocol p => p -> P.IO LastReadMessageIds
read_LastReadMessageIds iprot = to_LastReadMessageIds <$> T.readVal iprot (T.T_STRUCT typemap_LastReadMessageIds)
decode_LastReadMessageIds :: T.StatelessProtocol p => p -> LBS.ByteString -> LastReadMessageIds
decode_LastReadMessageIds iprot bs = to_LastReadMessageIds $ T.deserializeVal iprot (T.T_STRUCT typemap_LastReadMessageIds) bs
typemap_LastReadMessageIds :: T.TypeMap
typemap_LastReadMessageIds = Map.fromList [(1,("chatId",T.T_STRING)),(2,("lastReadMessageIds",(T.T_LIST (T.T_STRUCT typemap_LastReadMessageId))))]
default_LastReadMessageIds :: LastReadMessageIds
default_LastReadMessageIds = LastReadMessageIds{
  lastReadMessageIds_chatId = "",
  lastReadMessageIds_lastReadMessageIds = Vector.empty}
data LoginResult = LoginResult  { loginResult_authToken :: LT.Text
  , loginResult_certificate :: LT.Text
  , loginResult_verifier :: LT.Text
  , loginResult_pinCode :: LT.Text
  , loginResult_type :: LoginResultType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginResult_authToken record   `H.hashWithSalt` loginResult_certificate record   `H.hashWithSalt` loginResult_verifier record   `H.hashWithSalt` loginResult_pinCode record   `H.hashWithSalt` loginResult_type record  
instance QC.Arbitrary LoginResult where 
  arbitrary = M.liftM LoginResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginResult{loginResult_authToken = loginResult_authToken obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_authToken = loginResult_authToken obj}
    , if obj == default_LoginResult{loginResult_certificate = loginResult_certificate obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_certificate = loginResult_certificate obj}
    , if obj == default_LoginResult{loginResult_verifier = loginResult_verifier obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_verifier = loginResult_verifier obj}
    , if obj == default_LoginResult{loginResult_pinCode = loginResult_pinCode obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_pinCode = loginResult_pinCode obj}
    , if obj == default_LoginResult{loginResult_type = loginResult_type obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_type = loginResult_type obj}
    ]
from_LoginResult :: LoginResult -> T.ThriftVal
from_LoginResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v602 -> P.Just (1, ("authToken",T.TString $ E.encodeUtf8 _v602))) $ loginResult_authToken record
  , (\_v602 -> P.Just (2, ("certificate",T.TString $ E.encodeUtf8 _v602))) $ loginResult_certificate record
  , (\_v602 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v602))) $ loginResult_verifier record
  , (\_v602 -> P.Just (4, ("pinCode",T.TString $ E.encodeUtf8 _v602))) $ loginResult_pinCode record
  , (\_v602 -> P.Just (5, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v602))) $ loginResult_type record
  ]
write_LoginResult :: T.Protocol p => p -> LoginResult -> P.IO ()
write_LoginResult oprot record = T.writeVal oprot $ from_LoginResult record
encode_LoginResult :: T.StatelessProtocol p => p -> LoginResult -> LBS.ByteString
encode_LoginResult oprot record = T.serializeVal oprot $ from_LoginResult record
to_LoginResult :: T.ThriftVal -> LoginResult
to_LoginResult (T.TStruct fields) = LoginResult{
  loginResult_authToken = P.maybe (loginResult_authToken default_LoginResult) (\(_,_val604) -> (case _val604 of {T.TString _val605 -> E.decodeUtf8 _val605; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  loginResult_certificate = P.maybe (loginResult_certificate default_LoginResult) (\(_,_val604) -> (case _val604 of {T.TString _val606 -> E.decodeUtf8 _val606; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  loginResult_verifier = P.maybe (loginResult_verifier default_LoginResult) (\(_,_val604) -> (case _val604 of {T.TString _val607 -> E.decodeUtf8 _val607; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginResult_pinCode = P.maybe (loginResult_pinCode default_LoginResult) (\(_,_val604) -> (case _val604 of {T.TString _val608 -> E.decodeUtf8 _val608; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  loginResult_type = P.maybe (loginResult_type default_LoginResult) (\(_,_val604) -> (case _val604 of {T.TI32 _val609 -> P.toEnum $ P.fromIntegral _val609; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_LoginResult _ = P.error "not a struct"
read_LoginResult :: T.Protocol p => p -> P.IO LoginResult
read_LoginResult iprot = to_LoginResult <$> T.readVal iprot (T.T_STRUCT typemap_LoginResult)
decode_LoginResult :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginResult
decode_LoginResult iprot bs = to_LoginResult $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginResult) bs
typemap_LoginResult :: T.TypeMap
typemap_LoginResult = Map.fromList [(1,("authToken",T.T_STRING)),(2,("certificate",T.T_STRING)),(3,("verifier",T.T_STRING)),(4,("pinCode",T.T_STRING)),(5,("type",T.T_I32))]
default_LoginResult :: LoginResult
default_LoginResult = LoginResult{
  loginResult_authToken = "",
  loginResult_certificate = "",
  loginResult_verifier = "",
  loginResult_pinCode = "",
  loginResult_type = (P.toEnum 0)}
data LoginSession = LoginSession  { loginSession_tokenKey :: LT.Text
  , loginSession_expirationTime :: I.Int64
  , loginSession_applicationType :: ApplicationType
  , loginSession_systemName :: LT.Text
  , loginSession_accessLocation :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginSession where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginSession_tokenKey record   `H.hashWithSalt` loginSession_expirationTime record   `H.hashWithSalt` loginSession_applicationType record   `H.hashWithSalt` loginSession_systemName record   `H.hashWithSalt` loginSession_accessLocation record  
instance QC.Arbitrary LoginSession where 
  arbitrary = M.liftM LoginSession (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginSession = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginSession{loginSession_tokenKey = loginSession_tokenKey obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_tokenKey = loginSession_tokenKey obj}
    , if obj == default_LoginSession{loginSession_expirationTime = loginSession_expirationTime obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_expirationTime = loginSession_expirationTime obj}
    , if obj == default_LoginSession{loginSession_applicationType = loginSession_applicationType obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_applicationType = loginSession_applicationType obj}
    , if obj == default_LoginSession{loginSession_systemName = loginSession_systemName obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_systemName = loginSession_systemName obj}
    , if obj == default_LoginSession{loginSession_accessLocation = loginSession_accessLocation obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_accessLocation = loginSession_accessLocation obj}
    ]
from_LoginSession :: LoginSession -> T.ThriftVal
from_LoginSession record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v612 -> P.Just (1, ("tokenKey",T.TString $ E.encodeUtf8 _v612))) $ loginSession_tokenKey record
  , (\_v612 -> P.Just (3, ("expirationTime",T.TI64 _v612))) $ loginSession_expirationTime record
  , (\_v612 -> P.Just (11, ("applicationType",T.TI32 $ P.fromIntegral $ P.fromEnum _v612))) $ loginSession_applicationType record
  , (\_v612 -> P.Just (12, ("systemName",T.TString $ E.encodeUtf8 _v612))) $ loginSession_systemName record
  , (\_v612 -> P.Just (22, ("accessLocation",T.TString $ E.encodeUtf8 _v612))) $ loginSession_accessLocation record
  ]
write_LoginSession :: T.Protocol p => p -> LoginSession -> P.IO ()
write_LoginSession oprot record = T.writeVal oprot $ from_LoginSession record
encode_LoginSession :: T.StatelessProtocol p => p -> LoginSession -> LBS.ByteString
encode_LoginSession oprot record = T.serializeVal oprot $ from_LoginSession record
to_LoginSession :: T.ThriftVal -> LoginSession
to_LoginSession (T.TStruct fields) = LoginSession{
  loginSession_tokenKey = P.maybe (loginSession_tokenKey default_LoginSession) (\(_,_val614) -> (case _val614 of {T.TString _val615 -> E.decodeUtf8 _val615; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  loginSession_expirationTime = P.maybe (loginSession_expirationTime default_LoginSession) (\(_,_val614) -> (case _val614 of {T.TI64 _val616 -> _val616; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginSession_applicationType = P.maybe (loginSession_applicationType default_LoginSession) (\(_,_val614) -> (case _val614 of {T.TI32 _val617 -> P.toEnum $ P.fromIntegral _val617; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  loginSession_systemName = P.maybe (loginSession_systemName default_LoginSession) (\(_,_val614) -> (case _val614 of {T.TString _val618 -> E.decodeUtf8 _val618; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  loginSession_accessLocation = P.maybe (loginSession_accessLocation default_LoginSession) (\(_,_val614) -> (case _val614 of {T.TString _val619 -> E.decodeUtf8 _val619; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_LoginSession _ = P.error "not a struct"
read_LoginSession :: T.Protocol p => p -> P.IO LoginSession
read_LoginSession iprot = to_LoginSession <$> T.readVal iprot (T.T_STRUCT typemap_LoginSession)
decode_LoginSession :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginSession
decode_LoginSession iprot bs = to_LoginSession $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginSession) bs
typemap_LoginSession :: T.TypeMap
typemap_LoginSession = Map.fromList [(1,("tokenKey",T.T_STRING)),(3,("expirationTime",T.T_I64)),(11,("applicationType",T.T_I32)),(12,("systemName",T.T_STRING)),(22,("accessLocation",T.T_STRING))]
default_LoginSession :: LoginSession
default_LoginSession = LoginSession{
  loginSession_tokenKey = "",
  loginSession_expirationTime = 0,
  loginSession_applicationType = (P.toEnum 0),
  loginSession_systemName = "",
  loginSession_accessLocation = ""}
data Message = Message  { message_from_ :: LT.Text
  , message_to :: LT.Text
  , message_toType :: MIDType
  , message_id :: LT.Text
  , message_createdTime :: I.Int64
  , message_deliveredTime :: I.Int64
  , message_text :: LT.Text
  , message_location :: Location
  , message_hasContent :: P.Bool
  , message_contentType :: ContentType
  , message_contentPreview :: LBS.ByteString
  , message_contentMetadata :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Message where
  hashWithSalt salt record = salt   `H.hashWithSalt` message_from_ record   `H.hashWithSalt` message_to record   `H.hashWithSalt` message_toType record   `H.hashWithSalt` message_id record   `H.hashWithSalt` message_createdTime record   `H.hashWithSalt` message_deliveredTime record   `H.hashWithSalt` message_text record   `H.hashWithSalt` message_location record   `H.hashWithSalt` message_hasContent record   `H.hashWithSalt` message_contentType record   `H.hashWithSalt` message_contentPreview record   `H.hashWithSalt` message_contentMetadata record  
instance QC.Arbitrary Message where 
  arbitrary = M.liftM Message (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Message = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Message{message_from_ = message_from_ obj} then P.Nothing else P.Just $ default_Message{message_from_ = message_from_ obj}
    , if obj == default_Message{message_to = message_to obj} then P.Nothing else P.Just $ default_Message{message_to = message_to obj}
    , if obj == default_Message{message_toType = message_toType obj} then P.Nothing else P.Just $ default_Message{message_toType = message_toType obj}
    , if obj == default_Message{message_id = message_id obj} then P.Nothing else P.Just $ default_Message{message_id = message_id obj}
    , if obj == default_Message{message_createdTime = message_createdTime obj} then P.Nothing else P.Just $ default_Message{message_createdTime = message_createdTime obj}
    , if obj == default_Message{message_deliveredTime = message_deliveredTime obj} then P.Nothing else P.Just $ default_Message{message_deliveredTime = message_deliveredTime obj}
    , if obj == default_Message{message_text = message_text obj} then P.Nothing else P.Just $ default_Message{message_text = message_text obj}
    , if obj == default_Message{message_location = message_location obj} then P.Nothing else P.Just $ default_Message{message_location = message_location obj}
    , if obj == default_Message{message_hasContent = message_hasContent obj} then P.Nothing else P.Just $ default_Message{message_hasContent = message_hasContent obj}
    , if obj == default_Message{message_contentType = message_contentType obj} then P.Nothing else P.Just $ default_Message{message_contentType = message_contentType obj}
    , if obj == default_Message{message_contentPreview = message_contentPreview obj} then P.Nothing else P.Just $ default_Message{message_contentPreview = message_contentPreview obj}
    , if obj == default_Message{message_contentMetadata = message_contentMetadata obj} then P.Nothing else P.Just $ default_Message{message_contentMetadata = message_contentMetadata obj}
    ]
from_Message :: Message -> T.ThriftVal
from_Message record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v622 -> P.Just (1, ("from_",T.TString $ E.encodeUtf8 _v622))) $ message_from_ record
  , (\_v622 -> P.Just (2, ("to",T.TString $ E.encodeUtf8 _v622))) $ message_to record
  , (\_v622 -> P.Just (3, ("toType",T.TI32 $ P.fromIntegral $ P.fromEnum _v622))) $ message_toType record
  , (\_v622 -> P.Just (4, ("id",T.TString $ E.encodeUtf8 _v622))) $ message_id record
  , (\_v622 -> P.Just (5, ("createdTime",T.TI64 _v622))) $ message_createdTime record
  , (\_v622 -> P.Just (6, ("deliveredTime",T.TI64 _v622))) $ message_deliveredTime record
  , (\_v622 -> P.Just (10, ("text",T.TString $ E.encodeUtf8 _v622))) $ message_text record
  , (\_v622 -> P.Just (11, ("location",from_Location _v622))) $ message_location record
  , (\_v622 -> P.Just (14, ("hasContent",T.TBool _v622))) $ message_hasContent record
  , (\_v622 -> P.Just (15, ("contentType",T.TI32 $ P.fromIntegral $ P.fromEnum _v622))) $ message_contentType record
  , (\_v622 -> P.Just (17, ("contentPreview",T.TBinary _v622))) $ message_contentPreview record
  , (\_v622 -> P.Just (18, ("contentMetadata",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k623,_v624) -> (T.TString $ E.encodeUtf8 _k623, T.TString $ E.encodeUtf8 _v624)) $ Map.toList _v622))) $ message_contentMetadata record
  ]
write_Message :: T.Protocol p => p -> Message -> P.IO ()
write_Message oprot record = T.writeVal oprot $ from_Message record
encode_Message :: T.StatelessProtocol p => p -> Message -> LBS.ByteString
encode_Message oprot record = T.serializeVal oprot $ from_Message record
to_Message :: T.ThriftVal -> Message
to_Message (T.TStruct fields) = Message{
  message_from_ = P.maybe (message_from_ default_Message) (\(_,_val626) -> (case _val626 of {T.TString _val627 -> E.decodeUtf8 _val627; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  message_to = P.maybe (message_to default_Message) (\(_,_val626) -> (case _val626 of {T.TString _val628 -> E.decodeUtf8 _val628; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  message_toType = P.maybe (message_toType default_Message) (\(_,_val626) -> (case _val626 of {T.TI32 _val629 -> P.toEnum $ P.fromIntegral _val629; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  message_id = P.maybe (message_id default_Message) (\(_,_val626) -> (case _val626 of {T.TString _val630 -> E.decodeUtf8 _val630; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  message_createdTime = P.maybe (message_createdTime default_Message) (\(_,_val626) -> (case _val626 of {T.TI64 _val631 -> _val631; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  message_deliveredTime = P.maybe (message_deliveredTime default_Message) (\(_,_val626) -> (case _val626 of {T.TI64 _val632 -> _val632; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  message_text = P.maybe (message_text default_Message) (\(_,_val626) -> (case _val626 of {T.TString _val633 -> E.decodeUtf8 _val633; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  message_location = P.maybe (message_location default_Message) (\(_,_val626) -> (case _val626 of {T.TStruct _val634 -> (to_Location (T.TStruct _val634)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  message_hasContent = P.maybe (message_hasContent default_Message) (\(_,_val626) -> (case _val626 of {T.TBool _val635 -> _val635; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  message_contentType = P.maybe (message_contentType default_Message) (\(_,_val626) -> (case _val626 of {T.TI32 _val636 -> P.toEnum $ P.fromIntegral _val636; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  message_contentPreview = P.maybe (message_contentPreview default_Message) (\(_,_val626) -> (case _val626 of {T.TBinary _val637 -> _val637; T.TString _val637 -> _val637; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  message_contentMetadata = P.maybe (message_contentMetadata default_Message) (\(_,_val626) -> (case _val626 of {T.TMap _ _ _val638 -> (Map.fromList $ P.map (\(_k640,_v639) -> ((case _k640 of {T.TString _val641 -> E.decodeUtf8 _val641; _ -> P.error "wrong type"}),(case _v639 of {T.TString _val642 -> E.decodeUtf8 _val642; _ -> P.error "wrong type"}))) _val638); _ -> P.error "wrong type"})) (Map.lookup (18) fields)
  }
to_Message _ = P.error "not a struct"
read_Message :: T.Protocol p => p -> P.IO Message
read_Message iprot = to_Message <$> T.readVal iprot (T.T_STRUCT typemap_Message)
decode_Message :: T.StatelessProtocol p => p -> LBS.ByteString -> Message
decode_Message iprot bs = to_Message $ T.deserializeVal iprot (T.T_STRUCT typemap_Message) bs
typemap_Message :: T.TypeMap
typemap_Message = Map.fromList [(1,("from_",T.T_STRING)),(2,("to",T.T_STRING)),(3,("toType",T.T_I32)),(4,("id",T.T_STRING)),(5,("createdTime",T.T_I64)),(6,("deliveredTime",T.T_I64)),(10,("text",T.T_STRING)),(11,("location",(T.T_STRUCT typemap_Location))),(14,("hasContent",T.T_BOOL)),(15,("contentType",T.T_I32)),(17,("contentPreview",T.T_BINARY)),(18,("contentMetadata",(T.T_MAP T.T_STRING T.T_STRING)))]
default_Message :: Message
default_Message = Message{
  message_from_ = "",
  message_to = "",
  message_toType = (P.toEnum 0),
  message_id = "",
  message_createdTime = 0,
  message_deliveredTime = 0,
  message_text = "",
  message_location = default_Location,
  message_hasContent = P.False,
  message_contentType = (P.toEnum 0),
  message_contentPreview = "",
  message_contentMetadata = Map.empty}
data MessageOperation = MessageOperation  { messageOperation_revision :: I.Int64
  , messageOperation_createdTime :: I.Int64
  , messageOperation_type :: MessageOperationType
  , messageOperation_reqSeq :: I.Int32
  , messageOperation_status :: OpStatus
  , messageOperation_param1 :: LT.Text
  , messageOperation_param2 :: LT.Text
  , messageOperation_param3 :: LT.Text
  , messageOperation_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MessageOperation where
  hashWithSalt salt record = salt   `H.hashWithSalt` messageOperation_revision record   `H.hashWithSalt` messageOperation_createdTime record   `H.hashWithSalt` messageOperation_type record   `H.hashWithSalt` messageOperation_reqSeq record   `H.hashWithSalt` messageOperation_status record   `H.hashWithSalt` messageOperation_param1 record   `H.hashWithSalt` messageOperation_param2 record   `H.hashWithSalt` messageOperation_param3 record   `H.hashWithSalt` messageOperation_message record  
instance QC.Arbitrary MessageOperation where 
  arbitrary = M.liftM MessageOperation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MessageOperation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MessageOperation{messageOperation_revision = messageOperation_revision obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_revision = messageOperation_revision obj}
    , if obj == default_MessageOperation{messageOperation_createdTime = messageOperation_createdTime obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_createdTime = messageOperation_createdTime obj}
    , if obj == default_MessageOperation{messageOperation_type = messageOperation_type obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_type = messageOperation_type obj}
    , if obj == default_MessageOperation{messageOperation_reqSeq = messageOperation_reqSeq obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_reqSeq = messageOperation_reqSeq obj}
    , if obj == default_MessageOperation{messageOperation_status = messageOperation_status obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_status = messageOperation_status obj}
    , if obj == default_MessageOperation{messageOperation_param1 = messageOperation_param1 obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_param1 = messageOperation_param1 obj}
    , if obj == default_MessageOperation{messageOperation_param2 = messageOperation_param2 obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_param2 = messageOperation_param2 obj}
    , if obj == default_MessageOperation{messageOperation_param3 = messageOperation_param3 obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_param3 = messageOperation_param3 obj}
    , if obj == default_MessageOperation{messageOperation_message = messageOperation_message obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_message = messageOperation_message obj}
    ]
from_MessageOperation :: MessageOperation -> T.ThriftVal
from_MessageOperation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v645 -> P.Just (1, ("revision",T.TI64 _v645))) $ messageOperation_revision record
  , (\_v645 -> P.Just (2, ("createdTime",T.TI64 _v645))) $ messageOperation_createdTime record
  , (\_v645 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v645))) $ messageOperation_type record
  , (\_v645 -> P.Just (4, ("reqSeq",T.TI32 _v645))) $ messageOperation_reqSeq record
  , (\_v645 -> P.Just (5, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v645))) $ messageOperation_status record
  , (\_v645 -> P.Just (10, ("param1",T.TString $ E.encodeUtf8 _v645))) $ messageOperation_param1 record
  , (\_v645 -> P.Just (11, ("param2",T.TString $ E.encodeUtf8 _v645))) $ messageOperation_param2 record
  , (\_v645 -> P.Just (12, ("param3",T.TString $ E.encodeUtf8 _v645))) $ messageOperation_param3 record
  , (\_v645 -> P.Just (20, ("message",from_Message _v645))) $ messageOperation_message record
  ]
write_MessageOperation :: T.Protocol p => p -> MessageOperation -> P.IO ()
write_MessageOperation oprot record = T.writeVal oprot $ from_MessageOperation record
encode_MessageOperation :: T.StatelessProtocol p => p -> MessageOperation -> LBS.ByteString
encode_MessageOperation oprot record = T.serializeVal oprot $ from_MessageOperation record
to_MessageOperation :: T.ThriftVal -> MessageOperation
to_MessageOperation (T.TStruct fields) = MessageOperation{
  messageOperation_revision = P.maybe (messageOperation_revision default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TI64 _val648 -> _val648; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  messageOperation_createdTime = P.maybe (messageOperation_createdTime default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TI64 _val649 -> _val649; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  messageOperation_type = P.maybe (messageOperation_type default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TI32 _val650 -> P.toEnum $ P.fromIntegral _val650; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  messageOperation_reqSeq = P.maybe (messageOperation_reqSeq default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TI32 _val651 -> _val651; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  messageOperation_status = P.maybe (messageOperation_status default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TI32 _val652 -> P.toEnum $ P.fromIntegral _val652; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  messageOperation_param1 = P.maybe (messageOperation_param1 default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TString _val653 -> E.decodeUtf8 _val653; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  messageOperation_param2 = P.maybe (messageOperation_param2 default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TString _val654 -> E.decodeUtf8 _val654; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  messageOperation_param3 = P.maybe (messageOperation_param3 default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TString _val655 -> E.decodeUtf8 _val655; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  messageOperation_message = P.maybe (messageOperation_message default_MessageOperation) (\(_,_val647) -> (case _val647 of {T.TStruct _val656 -> (to_Message (T.TStruct _val656)); _ -> P.error "wrong type"})) (Map.lookup (20) fields)
  }
to_MessageOperation _ = P.error "not a struct"
read_MessageOperation :: T.Protocol p => p -> P.IO MessageOperation
read_MessageOperation iprot = to_MessageOperation <$> T.readVal iprot (T.T_STRUCT typemap_MessageOperation)
decode_MessageOperation :: T.StatelessProtocol p => p -> LBS.ByteString -> MessageOperation
decode_MessageOperation iprot bs = to_MessageOperation $ T.deserializeVal iprot (T.T_STRUCT typemap_MessageOperation) bs
typemap_MessageOperation :: T.TypeMap
typemap_MessageOperation = Map.fromList [(1,("revision",T.T_I64)),(2,("createdTime",T.T_I64)),(3,("type",T.T_I32)),(4,("reqSeq",T.T_I32)),(5,("status",T.T_I32)),(10,("param1",T.T_STRING)),(11,("param2",T.T_STRING)),(12,("param3",T.T_STRING)),(20,("message",(T.T_STRUCT typemap_Message)))]
default_MessageOperation :: MessageOperation
default_MessageOperation = MessageOperation{
  messageOperation_revision = 0,
  messageOperation_createdTime = 0,
  messageOperation_type = (P.toEnum 0),
  messageOperation_reqSeq = 0,
  messageOperation_status = (P.toEnum 0),
  messageOperation_param1 = "",
  messageOperation_param2 = "",
  messageOperation_param3 = "",
  messageOperation_message = default_Message}
data MessageOperations = MessageOperations  { messageOperations_operations :: (Vector.Vector MessageOperation)
  , messageOperations_endFlag :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MessageOperations where
  hashWithSalt salt record = salt   `H.hashWithSalt` messageOperations_operations record   `H.hashWithSalt` messageOperations_endFlag record  
instance QC.Arbitrary MessageOperations where 
  arbitrary = M.liftM MessageOperations (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MessageOperations = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MessageOperations{messageOperations_operations = messageOperations_operations obj} then P.Nothing else P.Just $ default_MessageOperations{messageOperations_operations = messageOperations_operations obj}
    , if obj == default_MessageOperations{messageOperations_endFlag = messageOperations_endFlag obj} then P.Nothing else P.Just $ default_MessageOperations{messageOperations_endFlag = messageOperations_endFlag obj}
    ]
from_MessageOperations :: MessageOperations -> T.ThriftVal
from_MessageOperations record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v659 -> P.Just (1, ("operations",T.TList (T.T_STRUCT typemap_MessageOperation) $ P.map (\_v661 -> from_MessageOperation _v661) $ Vector.toList _v659))) $ messageOperations_operations record
  , (\_v659 -> P.Just (2, ("endFlag",T.TBool _v659))) $ messageOperations_endFlag record
  ]
write_MessageOperations :: T.Protocol p => p -> MessageOperations -> P.IO ()
write_MessageOperations oprot record = T.writeVal oprot $ from_MessageOperations record
encode_MessageOperations :: T.StatelessProtocol p => p -> MessageOperations -> LBS.ByteString
encode_MessageOperations oprot record = T.serializeVal oprot $ from_MessageOperations record
to_MessageOperations :: T.ThriftVal -> MessageOperations
to_MessageOperations (T.TStruct fields) = MessageOperations{
  messageOperations_operations = P.maybe (messageOperations_operations default_MessageOperations) (\(_,_val663) -> (case _val663 of {T.TList _ _val664 -> (Vector.fromList $ P.map (\_v665 -> (case _v665 of {T.TStruct _val666 -> (to_MessageOperation (T.TStruct _val666)); _ -> P.error "wrong type"})) _val664); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  messageOperations_endFlag = P.maybe (messageOperations_endFlag default_MessageOperations) (\(_,_val663) -> (case _val663 of {T.TBool _val667 -> _val667; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_MessageOperations _ = P.error "not a struct"
read_MessageOperations :: T.Protocol p => p -> P.IO MessageOperations
read_MessageOperations iprot = to_MessageOperations <$> T.readVal iprot (T.T_STRUCT typemap_MessageOperations)
decode_MessageOperations :: T.StatelessProtocol p => p -> LBS.ByteString -> MessageOperations
decode_MessageOperations iprot bs = to_MessageOperations $ T.deserializeVal iprot (T.T_STRUCT typemap_MessageOperations) bs
typemap_MessageOperations :: T.TypeMap
typemap_MessageOperations = Map.fromList [(1,("operations",(T.T_LIST (T.T_STRUCT typemap_MessageOperation)))),(2,("endFlag",T.T_BOOL))]
default_MessageOperations :: MessageOperations
default_MessageOperations = MessageOperations{
  messageOperations_operations = Vector.empty,
  messageOperations_endFlag = P.False}
data MetaProfile = MetaProfile  { metaProfile_createTime :: I.Int64
  , metaProfile_regionCode :: LT.Text
  , metaProfile_identities :: (Map.HashMap RegistrationType LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MetaProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` metaProfile_createTime record   `H.hashWithSalt` metaProfile_regionCode record   `H.hashWithSalt` metaProfile_identities record  
instance QC.Arbitrary MetaProfile where 
  arbitrary = M.liftM MetaProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MetaProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MetaProfile{metaProfile_createTime = metaProfile_createTime obj} then P.Nothing else P.Just $ default_MetaProfile{metaProfile_createTime = metaProfile_createTime obj}
    , if obj == default_MetaProfile{metaProfile_regionCode = metaProfile_regionCode obj} then P.Nothing else P.Just $ default_MetaProfile{metaProfile_regionCode = metaProfile_regionCode obj}
    , if obj == default_MetaProfile{metaProfile_identities = metaProfile_identities obj} then P.Nothing else P.Just $ default_MetaProfile{metaProfile_identities = metaProfile_identities obj}
    ]
from_MetaProfile :: MetaProfile -> T.ThriftVal
from_MetaProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v670 -> P.Just (1, ("createTime",T.TI64 _v670))) $ metaProfile_createTime record
  , (\_v670 -> P.Just (2, ("regionCode",T.TString $ E.encodeUtf8 _v670))) $ metaProfile_regionCode record
  , (\_v670 -> P.Just (3, ("identities",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k671,_v672) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k671, T.TString $ E.encodeUtf8 _v672)) $ Map.toList _v670))) $ metaProfile_identities record
  ]
write_MetaProfile :: T.Protocol p => p -> MetaProfile -> P.IO ()
write_MetaProfile oprot record = T.writeVal oprot $ from_MetaProfile record
encode_MetaProfile :: T.StatelessProtocol p => p -> MetaProfile -> LBS.ByteString
encode_MetaProfile oprot record = T.serializeVal oprot $ from_MetaProfile record
to_MetaProfile :: T.ThriftVal -> MetaProfile
to_MetaProfile (T.TStruct fields) = MetaProfile{
  metaProfile_createTime = P.maybe (metaProfile_createTime default_MetaProfile) (\(_,_val674) -> (case _val674 of {T.TI64 _val675 -> _val675; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  metaProfile_regionCode = P.maybe (metaProfile_regionCode default_MetaProfile) (\(_,_val674) -> (case _val674 of {T.TString _val676 -> E.decodeUtf8 _val676; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  metaProfile_identities = P.maybe (metaProfile_identities default_MetaProfile) (\(_,_val674) -> (case _val674 of {T.TMap _ _ _val677 -> (Map.fromList $ P.map (\(_k679,_v678) -> ((case _k679 of {T.TI32 _val680 -> P.toEnum $ P.fromIntegral _val680; _ -> P.error "wrong type"}),(case _v678 of {T.TString _val681 -> E.decodeUtf8 _val681; _ -> P.error "wrong type"}))) _val677); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_MetaProfile _ = P.error "not a struct"
read_MetaProfile :: T.Protocol p => p -> P.IO MetaProfile
read_MetaProfile iprot = to_MetaProfile <$> T.readVal iprot (T.T_STRUCT typemap_MetaProfile)
decode_MetaProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> MetaProfile
decode_MetaProfile iprot bs = to_MetaProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_MetaProfile) bs
typemap_MetaProfile :: T.TypeMap
typemap_MetaProfile = Map.fromList [(1,("createTime",T.T_I64)),(2,("regionCode",T.T_STRING)),(3,("identities",(T.T_MAP T.T_I32 T.T_STRING)))]
default_MetaProfile :: MetaProfile
default_MetaProfile = MetaProfile{
  metaProfile_createTime = 0,
  metaProfile_regionCode = "",
  metaProfile_identities = Map.empty}
data NotificationItem = NotificationItem  { notificationItem_id :: LT.Text
  , notificationItem_from_ :: LT.Text
  , notificationItem_to :: LT.Text
  , notificationItem_fromChannel :: LT.Text
  , notificationItem_toChannel :: LT.Text
  , notificationItem_revision :: I.Int64
  , notificationItem_createdTime :: I.Int64
  , notificationItem_content :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotificationItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` notificationItem_id record   `H.hashWithSalt` notificationItem_from_ record   `H.hashWithSalt` notificationItem_to record   `H.hashWithSalt` notificationItem_fromChannel record   `H.hashWithSalt` notificationItem_toChannel record   `H.hashWithSalt` notificationItem_revision record   `H.hashWithSalt` notificationItem_createdTime record   `H.hashWithSalt` notificationItem_content record  
instance QC.Arbitrary NotificationItem where 
  arbitrary = M.liftM NotificationItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotificationItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotificationItem{notificationItem_id = notificationItem_id obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_id = notificationItem_id obj}
    , if obj == default_NotificationItem{notificationItem_from_ = notificationItem_from_ obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_from_ = notificationItem_from_ obj}
    , if obj == default_NotificationItem{notificationItem_to = notificationItem_to obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_to = notificationItem_to obj}
    , if obj == default_NotificationItem{notificationItem_fromChannel = notificationItem_fromChannel obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_fromChannel = notificationItem_fromChannel obj}
    , if obj == default_NotificationItem{notificationItem_toChannel = notificationItem_toChannel obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_toChannel = notificationItem_toChannel obj}
    , if obj == default_NotificationItem{notificationItem_revision = notificationItem_revision obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_revision = notificationItem_revision obj}
    , if obj == default_NotificationItem{notificationItem_createdTime = notificationItem_createdTime obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_createdTime = notificationItem_createdTime obj}
    , if obj == default_NotificationItem{notificationItem_content = notificationItem_content obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_content = notificationItem_content obj}
    ]
from_NotificationItem :: NotificationItem -> T.ThriftVal
from_NotificationItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v684 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v684))) $ notificationItem_id record
  , (\_v684 -> P.Just (2, ("from_",T.TString $ E.encodeUtf8 _v684))) $ notificationItem_from_ record
  , (\_v684 -> P.Just (3, ("to",T.TString $ E.encodeUtf8 _v684))) $ notificationItem_to record
  , (\_v684 -> P.Just (4, ("fromChannel",T.TString $ E.encodeUtf8 _v684))) $ notificationItem_fromChannel record
  , (\_v684 -> P.Just (5, ("toChannel",T.TString $ E.encodeUtf8 _v684))) $ notificationItem_toChannel record
  , (\_v684 -> P.Just (7, ("revision",T.TI64 _v684))) $ notificationItem_revision record
  , (\_v684 -> P.Just (8, ("createdTime",T.TI64 _v684))) $ notificationItem_createdTime record
  , (\_v684 -> P.Just (9, ("content",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k685,_v686) -> (T.TString $ E.encodeUtf8 _k685, T.TString $ E.encodeUtf8 _v686)) $ Map.toList _v684))) $ notificationItem_content record
  ]
write_NotificationItem :: T.Protocol p => p -> NotificationItem -> P.IO ()
write_NotificationItem oprot record = T.writeVal oprot $ from_NotificationItem record
encode_NotificationItem :: T.StatelessProtocol p => p -> NotificationItem -> LBS.ByteString
encode_NotificationItem oprot record = T.serializeVal oprot $ from_NotificationItem record
to_NotificationItem :: T.ThriftVal -> NotificationItem
to_NotificationItem (T.TStruct fields) = NotificationItem{
  notificationItem_id = P.maybe (notificationItem_id default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TString _val689 -> E.decodeUtf8 _val689; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notificationItem_from_ = P.maybe (notificationItem_from_ default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TString _val690 -> E.decodeUtf8 _val690; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notificationItem_to = P.maybe (notificationItem_to default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TString _val691 -> E.decodeUtf8 _val691; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  notificationItem_fromChannel = P.maybe (notificationItem_fromChannel default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TString _val692 -> E.decodeUtf8 _val692; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  notificationItem_toChannel = P.maybe (notificationItem_toChannel default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TString _val693 -> E.decodeUtf8 _val693; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  notificationItem_revision = P.maybe (notificationItem_revision default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TI64 _val694 -> _val694; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  notificationItem_createdTime = P.maybe (notificationItem_createdTime default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TI64 _val695 -> _val695; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  notificationItem_content = P.maybe (notificationItem_content default_NotificationItem) (\(_,_val688) -> (case _val688 of {T.TMap _ _ _val696 -> (Map.fromList $ P.map (\(_k698,_v697) -> ((case _k698 of {T.TString _val699 -> E.decodeUtf8 _val699; _ -> P.error "wrong type"}),(case _v697 of {T.TString _val700 -> E.decodeUtf8 _val700; _ -> P.error "wrong type"}))) _val696); _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_NotificationItem _ = P.error "not a struct"
read_NotificationItem :: T.Protocol p => p -> P.IO NotificationItem
read_NotificationItem iprot = to_NotificationItem <$> T.readVal iprot (T.T_STRUCT typemap_NotificationItem)
decode_NotificationItem :: T.StatelessProtocol p => p -> LBS.ByteString -> NotificationItem
decode_NotificationItem iprot bs = to_NotificationItem $ T.deserializeVal iprot (T.T_STRUCT typemap_NotificationItem) bs
typemap_NotificationItem :: T.TypeMap
typemap_NotificationItem = Map.fromList [(1,("id",T.T_STRING)),(2,("from_",T.T_STRING)),(3,("to",T.T_STRING)),(4,("fromChannel",T.T_STRING)),(5,("toChannel",T.T_STRING)),(7,("revision",T.T_I64)),(8,("createdTime",T.T_I64)),(9,("content",(T.T_MAP T.T_STRING T.T_STRING)))]
default_NotificationItem :: NotificationItem
default_NotificationItem = NotificationItem{
  notificationItem_id = "",
  notificationItem_from_ = "",
  notificationItem_to = "",
  notificationItem_fromChannel = "",
  notificationItem_toChannel = "",
  notificationItem_revision = 0,
  notificationItem_createdTime = 0,
  notificationItem_content = Map.empty}
data NotificationFetchResult = NotificationFetchResult  { notificationFetchResult_fetchMode :: NotificationItemFetchMode
  , notificationFetchResult_itemList :: (Vector.Vector NotificationItem)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotificationFetchResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` notificationFetchResult_fetchMode record   `H.hashWithSalt` notificationFetchResult_itemList record  
instance QC.Arbitrary NotificationFetchResult where 
  arbitrary = M.liftM NotificationFetchResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotificationFetchResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotificationFetchResult{notificationFetchResult_fetchMode = notificationFetchResult_fetchMode obj} then P.Nothing else P.Just $ default_NotificationFetchResult{notificationFetchResult_fetchMode = notificationFetchResult_fetchMode obj}
    , if obj == default_NotificationFetchResult{notificationFetchResult_itemList = notificationFetchResult_itemList obj} then P.Nothing else P.Just $ default_NotificationFetchResult{notificationFetchResult_itemList = notificationFetchResult_itemList obj}
    ]
from_NotificationFetchResult :: NotificationFetchResult -> T.ThriftVal
from_NotificationFetchResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v703 -> P.Just (1, ("fetchMode",T.TI32 $ P.fromIntegral $ P.fromEnum _v703))) $ notificationFetchResult_fetchMode record
  , (\_v703 -> P.Just (2, ("itemList",T.TList (T.T_STRUCT typemap_NotificationItem) $ P.map (\_v705 -> from_NotificationItem _v705) $ Vector.toList _v703))) $ notificationFetchResult_itemList record
  ]
write_NotificationFetchResult :: T.Protocol p => p -> NotificationFetchResult -> P.IO ()
write_NotificationFetchResult oprot record = T.writeVal oprot $ from_NotificationFetchResult record
encode_NotificationFetchResult :: T.StatelessProtocol p => p -> NotificationFetchResult -> LBS.ByteString
encode_NotificationFetchResult oprot record = T.serializeVal oprot $ from_NotificationFetchResult record
to_NotificationFetchResult :: T.ThriftVal -> NotificationFetchResult
to_NotificationFetchResult (T.TStruct fields) = NotificationFetchResult{
  notificationFetchResult_fetchMode = P.maybe (notificationFetchResult_fetchMode default_NotificationFetchResult) (\(_,_val707) -> (case _val707 of {T.TI32 _val708 -> P.toEnum $ P.fromIntegral _val708; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notificationFetchResult_itemList = P.maybe (notificationFetchResult_itemList default_NotificationFetchResult) (\(_,_val707) -> (case _val707 of {T.TList _ _val709 -> (Vector.fromList $ P.map (\_v710 -> (case _v710 of {T.TStruct _val711 -> (to_NotificationItem (T.TStruct _val711)); _ -> P.error "wrong type"})) _val709); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NotificationFetchResult _ = P.error "not a struct"
read_NotificationFetchResult :: T.Protocol p => p -> P.IO NotificationFetchResult
read_NotificationFetchResult iprot = to_NotificationFetchResult <$> T.readVal iprot (T.T_STRUCT typemap_NotificationFetchResult)
decode_NotificationFetchResult :: T.StatelessProtocol p => p -> LBS.ByteString -> NotificationFetchResult
decode_NotificationFetchResult iprot bs = to_NotificationFetchResult $ T.deserializeVal iprot (T.T_STRUCT typemap_NotificationFetchResult) bs
typemap_NotificationFetchResult :: T.TypeMap
typemap_NotificationFetchResult = Map.fromList [(1,("fetchMode",T.T_I32)),(2,("itemList",(T.T_LIST (T.T_STRUCT typemap_NotificationItem))))]
default_NotificationFetchResult :: NotificationFetchResult
default_NotificationFetchResult = NotificationFetchResult{
  notificationFetchResult_fetchMode = (P.toEnum 0),
  notificationFetchResult_itemList = Vector.empty}
data Operation = Operation  { operation_revision :: I.Int64
  , operation_createdTime :: I.Int64
  , operation_type :: OpType
  , operation_reqSeq :: I.Int32
  , operation_checksum :: LT.Text
  , operation_status :: OpStatus
  , operation_param1 :: LT.Text
  , operation_param2 :: LT.Text
  , operation_param3 :: LT.Text
  , operation_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Operation where
  hashWithSalt salt record = salt   `H.hashWithSalt` operation_revision record   `H.hashWithSalt` operation_createdTime record   `H.hashWithSalt` operation_type record   `H.hashWithSalt` operation_reqSeq record   `H.hashWithSalt` operation_checksum record   `H.hashWithSalt` operation_status record   `H.hashWithSalt` operation_param1 record   `H.hashWithSalt` operation_param2 record   `H.hashWithSalt` operation_param3 record   `H.hashWithSalt` operation_message record  
instance QC.Arbitrary Operation where 
  arbitrary = M.liftM Operation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Operation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Operation{operation_revision = operation_revision obj} then P.Nothing else P.Just $ default_Operation{operation_revision = operation_revision obj}
    , if obj == default_Operation{operation_createdTime = operation_createdTime obj} then P.Nothing else P.Just $ default_Operation{operation_createdTime = operation_createdTime obj}
    , if obj == default_Operation{operation_type = operation_type obj} then P.Nothing else P.Just $ default_Operation{operation_type = operation_type obj}
    , if obj == default_Operation{operation_reqSeq = operation_reqSeq obj} then P.Nothing else P.Just $ default_Operation{operation_reqSeq = operation_reqSeq obj}
    , if obj == default_Operation{operation_checksum = operation_checksum obj} then P.Nothing else P.Just $ default_Operation{operation_checksum = operation_checksum obj}
    , if obj == default_Operation{operation_status = operation_status obj} then P.Nothing else P.Just $ default_Operation{operation_status = operation_status obj}
    , if obj == default_Operation{operation_param1 = operation_param1 obj} then P.Nothing else P.Just $ default_Operation{operation_param1 = operation_param1 obj}
    , if obj == default_Operation{operation_param2 = operation_param2 obj} then P.Nothing else P.Just $ default_Operation{operation_param2 = operation_param2 obj}
    , if obj == default_Operation{operation_param3 = operation_param3 obj} then P.Nothing else P.Just $ default_Operation{operation_param3 = operation_param3 obj}
    , if obj == default_Operation{operation_message = operation_message obj} then P.Nothing else P.Just $ default_Operation{operation_message = operation_message obj}
    ]
from_Operation :: Operation -> T.ThriftVal
from_Operation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v714 -> P.Just (1, ("revision",T.TI64 _v714))) $ operation_revision record
  , (\_v714 -> P.Just (2, ("createdTime",T.TI64 _v714))) $ operation_createdTime record
  , (\_v714 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v714))) $ operation_type record
  , (\_v714 -> P.Just (4, ("reqSeq",T.TI32 _v714))) $ operation_reqSeq record
  , (\_v714 -> P.Just (5, ("checksum",T.TString $ E.encodeUtf8 _v714))) $ operation_checksum record
  , (\_v714 -> P.Just (7, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v714))) $ operation_status record
  , (\_v714 -> P.Just (10, ("param1",T.TString $ E.encodeUtf8 _v714))) $ operation_param1 record
  , (\_v714 -> P.Just (11, ("param2",T.TString $ E.encodeUtf8 _v714))) $ operation_param2 record
  , (\_v714 -> P.Just (12, ("param3",T.TString $ E.encodeUtf8 _v714))) $ operation_param3 record
  , (\_v714 -> P.Just (20, ("message",from_Message _v714))) $ operation_message record
  ]
write_Operation :: T.Protocol p => p -> Operation -> P.IO ()
write_Operation oprot record = T.writeVal oprot $ from_Operation record
encode_Operation :: T.StatelessProtocol p => p -> Operation -> LBS.ByteString
encode_Operation oprot record = T.serializeVal oprot $ from_Operation record
to_Operation :: T.ThriftVal -> Operation
to_Operation (T.TStruct fields) = Operation{
  operation_revision = P.maybe (operation_revision default_Operation) (\(_,_val716) -> (case _val716 of {T.TI64 _val717 -> _val717; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  operation_createdTime = P.maybe (operation_createdTime default_Operation) (\(_,_val716) -> (case _val716 of {T.TI64 _val718 -> _val718; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  operation_type = P.maybe (operation_type default_Operation) (\(_,_val716) -> (case _val716 of {T.TI32 _val719 -> P.toEnum $ P.fromIntegral _val719; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  operation_reqSeq = P.maybe (operation_reqSeq default_Operation) (\(_,_val716) -> (case _val716 of {T.TI32 _val720 -> _val720; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  operation_checksum = P.maybe (operation_checksum default_Operation) (\(_,_val716) -> (case _val716 of {T.TString _val721 -> E.decodeUtf8 _val721; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  operation_status = P.maybe (operation_status default_Operation) (\(_,_val716) -> (case _val716 of {T.TI32 _val722 -> P.toEnum $ P.fromIntegral _val722; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  operation_param1 = P.maybe (operation_param1 default_Operation) (\(_,_val716) -> (case _val716 of {T.TString _val723 -> E.decodeUtf8 _val723; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  operation_param2 = P.maybe (operation_param2 default_Operation) (\(_,_val716) -> (case _val716 of {T.TString _val724 -> E.decodeUtf8 _val724; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  operation_param3 = P.maybe (operation_param3 default_Operation) (\(_,_val716) -> (case _val716 of {T.TString _val725 -> E.decodeUtf8 _val725; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  operation_message = P.maybe (operation_message default_Operation) (\(_,_val716) -> (case _val716 of {T.TStruct _val726 -> (to_Message (T.TStruct _val726)); _ -> P.error "wrong type"})) (Map.lookup (20) fields)
  }
to_Operation _ = P.error "not a struct"
read_Operation :: T.Protocol p => p -> P.IO Operation
read_Operation iprot = to_Operation <$> T.readVal iprot (T.T_STRUCT typemap_Operation)
decode_Operation :: T.StatelessProtocol p => p -> LBS.ByteString -> Operation
decode_Operation iprot bs = to_Operation $ T.deserializeVal iprot (T.T_STRUCT typemap_Operation) bs
typemap_Operation :: T.TypeMap
typemap_Operation = Map.fromList [(1,("revision",T.T_I64)),(2,("createdTime",T.T_I64)),(3,("type",T.T_I32)),(4,("reqSeq",T.T_I32)),(5,("checksum",T.T_STRING)),(7,("status",T.T_I32)),(10,("param1",T.T_STRING)),(11,("param2",T.T_STRING)),(12,("param3",T.T_STRING)),(20,("message",(T.T_STRUCT typemap_Message)))]
default_Operation :: Operation
default_Operation = Operation{
  operation_revision = 0,
  operation_createdTime = 0,
  operation_type = (P.toEnum 0),
  operation_reqSeq = 0,
  operation_checksum = "",
  operation_status = (P.toEnum 0),
  operation_param1 = "",
  operation_param2 = "",
  operation_param3 = "",
  operation_message = default_Message}
data PaymentReservation = PaymentReservation  { paymentReservation_receiverMid :: LT.Text
  , paymentReservation_productId :: LT.Text
  , paymentReservation_language :: LT.Text
  , paymentReservation_location :: LT.Text
  , paymentReservation_currency :: LT.Text
  , paymentReservation_price :: LT.Text
  , paymentReservation_appStoreCode :: PaymentType
  , paymentReservation_messageText :: LT.Text
  , paymentReservation_messageTemplate :: I.Int32
  , paymentReservation_packageId :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaymentReservation where
  hashWithSalt salt record = salt   `H.hashWithSalt` paymentReservation_receiverMid record   `H.hashWithSalt` paymentReservation_productId record   `H.hashWithSalt` paymentReservation_language record   `H.hashWithSalt` paymentReservation_location record   `H.hashWithSalt` paymentReservation_currency record   `H.hashWithSalt` paymentReservation_price record   `H.hashWithSalt` paymentReservation_appStoreCode record   `H.hashWithSalt` paymentReservation_messageText record   `H.hashWithSalt` paymentReservation_messageTemplate record   `H.hashWithSalt` paymentReservation_packageId record  
instance QC.Arbitrary PaymentReservation where 
  arbitrary = M.liftM PaymentReservation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaymentReservation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaymentReservation{paymentReservation_receiverMid = paymentReservation_receiverMid obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_receiverMid = paymentReservation_receiverMid obj}
    , if obj == default_PaymentReservation{paymentReservation_productId = paymentReservation_productId obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_productId = paymentReservation_productId obj}
    , if obj == default_PaymentReservation{paymentReservation_language = paymentReservation_language obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_language = paymentReservation_language obj}
    , if obj == default_PaymentReservation{paymentReservation_location = paymentReservation_location obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_location = paymentReservation_location obj}
    , if obj == default_PaymentReservation{paymentReservation_currency = paymentReservation_currency obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_currency = paymentReservation_currency obj}
    , if obj == default_PaymentReservation{paymentReservation_price = paymentReservation_price obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_price = paymentReservation_price obj}
    , if obj == default_PaymentReservation{paymentReservation_appStoreCode = paymentReservation_appStoreCode obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_appStoreCode = paymentReservation_appStoreCode obj}
    , if obj == default_PaymentReservation{paymentReservation_messageText = paymentReservation_messageText obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_messageText = paymentReservation_messageText obj}
    , if obj == default_PaymentReservation{paymentReservation_messageTemplate = paymentReservation_messageTemplate obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_messageTemplate = paymentReservation_messageTemplate obj}
    , if obj == default_PaymentReservation{paymentReservation_packageId = paymentReservation_packageId obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_packageId = paymentReservation_packageId obj}
    ]
from_PaymentReservation :: PaymentReservation -> T.ThriftVal
from_PaymentReservation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v729 -> P.Just (1, ("receiverMid",T.TString $ E.encodeUtf8 _v729))) $ paymentReservation_receiverMid record
  , (\_v729 -> P.Just (2, ("productId",T.TString $ E.encodeUtf8 _v729))) $ paymentReservation_productId record
  , (\_v729 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v729))) $ paymentReservation_language record
  , (\_v729 -> P.Just (4, ("location",T.TString $ E.encodeUtf8 _v729))) $ paymentReservation_location record
  , (\_v729 -> P.Just (5, ("currency",T.TString $ E.encodeUtf8 _v729))) $ paymentReservation_currency record
  , (\_v729 -> P.Just (6, ("price",T.TString $ E.encodeUtf8 _v729))) $ paymentReservation_price record
  , (\_v729 -> P.Just (7, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v729))) $ paymentReservation_appStoreCode record
  , (\_v729 -> P.Just (8, ("messageText",T.TString $ E.encodeUtf8 _v729))) $ paymentReservation_messageText record
  , (\_v729 -> P.Just (9, ("messageTemplate",T.TI32 _v729))) $ paymentReservation_messageTemplate record
  , (\_v729 -> P.Just (10, ("packageId",T.TI64 _v729))) $ paymentReservation_packageId record
  ]
write_PaymentReservation :: T.Protocol p => p -> PaymentReservation -> P.IO ()
write_PaymentReservation oprot record = T.writeVal oprot $ from_PaymentReservation record
encode_PaymentReservation :: T.StatelessProtocol p => p -> PaymentReservation -> LBS.ByteString
encode_PaymentReservation oprot record = T.serializeVal oprot $ from_PaymentReservation record
to_PaymentReservation :: T.ThriftVal -> PaymentReservation
to_PaymentReservation (T.TStruct fields) = PaymentReservation{
  paymentReservation_receiverMid = P.maybe (paymentReservation_receiverMid default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TString _val732 -> E.decodeUtf8 _val732; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paymentReservation_productId = P.maybe (paymentReservation_productId default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TString _val733 -> E.decodeUtf8 _val733; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paymentReservation_language = P.maybe (paymentReservation_language default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TString _val734 -> E.decodeUtf8 _val734; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paymentReservation_location = P.maybe (paymentReservation_location default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TString _val735 -> E.decodeUtf8 _val735; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  paymentReservation_currency = P.maybe (paymentReservation_currency default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TString _val736 -> E.decodeUtf8 _val736; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  paymentReservation_price = P.maybe (paymentReservation_price default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TString _val737 -> E.decodeUtf8 _val737; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  paymentReservation_appStoreCode = P.maybe (paymentReservation_appStoreCode default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TI32 _val738 -> P.toEnum $ P.fromIntegral _val738; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  paymentReservation_messageText = P.maybe (paymentReservation_messageText default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TString _val739 -> E.decodeUtf8 _val739; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  paymentReservation_messageTemplate = P.maybe (paymentReservation_messageTemplate default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TI32 _val740 -> _val740; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  paymentReservation_packageId = P.maybe (paymentReservation_packageId default_PaymentReservation) (\(_,_val731) -> (case _val731 of {T.TI64 _val741 -> _val741; _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_PaymentReservation _ = P.error "not a struct"
read_PaymentReservation :: T.Protocol p => p -> P.IO PaymentReservation
read_PaymentReservation iprot = to_PaymentReservation <$> T.readVal iprot (T.T_STRUCT typemap_PaymentReservation)
decode_PaymentReservation :: T.StatelessProtocol p => p -> LBS.ByteString -> PaymentReservation
decode_PaymentReservation iprot bs = to_PaymentReservation $ T.deserializeVal iprot (T.T_STRUCT typemap_PaymentReservation) bs
typemap_PaymentReservation :: T.TypeMap
typemap_PaymentReservation = Map.fromList [(1,("receiverMid",T.T_STRING)),(2,("productId",T.T_STRING)),(3,("language",T.T_STRING)),(4,("location",T.T_STRING)),(5,("currency",T.T_STRING)),(6,("price",T.T_STRING)),(7,("appStoreCode",T.T_I32)),(8,("messageText",T.T_STRING)),(9,("messageTemplate",T.T_I32)),(10,("packageId",T.T_I64))]
default_PaymentReservation :: PaymentReservation
default_PaymentReservation = PaymentReservation{
  paymentReservation_receiverMid = "",
  paymentReservation_productId = "",
  paymentReservation_language = "",
  paymentReservation_location = "",
  paymentReservation_currency = "",
  paymentReservation_price = "",
  paymentReservation_appStoreCode = (P.toEnum 0),
  paymentReservation_messageText = "",
  paymentReservation_messageTemplate = 0,
  paymentReservation_packageId = 0}
data PaymentReservationResult = PaymentReservationResult  { paymentReservationResult_orderId :: LT.Text
  , paymentReservationResult_confirmUrl :: LT.Text
  , paymentReservationResult_extras :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaymentReservationResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` paymentReservationResult_orderId record   `H.hashWithSalt` paymentReservationResult_confirmUrl record   `H.hashWithSalt` paymentReservationResult_extras record  
instance QC.Arbitrary PaymentReservationResult where 
  arbitrary = M.liftM PaymentReservationResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaymentReservationResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaymentReservationResult{paymentReservationResult_orderId = paymentReservationResult_orderId obj} then P.Nothing else P.Just $ default_PaymentReservationResult{paymentReservationResult_orderId = paymentReservationResult_orderId obj}
    , if obj == default_PaymentReservationResult{paymentReservationResult_confirmUrl = paymentReservationResult_confirmUrl obj} then P.Nothing else P.Just $ default_PaymentReservationResult{paymentReservationResult_confirmUrl = paymentReservationResult_confirmUrl obj}
    , if obj == default_PaymentReservationResult{paymentReservationResult_extras = paymentReservationResult_extras obj} then P.Nothing else P.Just $ default_PaymentReservationResult{paymentReservationResult_extras = paymentReservationResult_extras obj}
    ]
from_PaymentReservationResult :: PaymentReservationResult -> T.ThriftVal
from_PaymentReservationResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v744 -> P.Just (1, ("orderId",T.TString $ E.encodeUtf8 _v744))) $ paymentReservationResult_orderId record
  , (\_v744 -> P.Just (2, ("confirmUrl",T.TString $ E.encodeUtf8 _v744))) $ paymentReservationResult_confirmUrl record
  , (\_v744 -> P.Just (3, ("extras",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k745,_v746) -> (T.TString $ E.encodeUtf8 _k745, T.TString $ E.encodeUtf8 _v746)) $ Map.toList _v744))) $ paymentReservationResult_extras record
  ]
write_PaymentReservationResult :: T.Protocol p => p -> PaymentReservationResult -> P.IO ()
write_PaymentReservationResult oprot record = T.writeVal oprot $ from_PaymentReservationResult record
encode_PaymentReservationResult :: T.StatelessProtocol p => p -> PaymentReservationResult -> LBS.ByteString
encode_PaymentReservationResult oprot record = T.serializeVal oprot $ from_PaymentReservationResult record
to_PaymentReservationResult :: T.ThriftVal -> PaymentReservationResult
to_PaymentReservationResult (T.TStruct fields) = PaymentReservationResult{
  paymentReservationResult_orderId = P.maybe (paymentReservationResult_orderId default_PaymentReservationResult) (\(_,_val748) -> (case _val748 of {T.TString _val749 -> E.decodeUtf8 _val749; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paymentReservationResult_confirmUrl = P.maybe (paymentReservationResult_confirmUrl default_PaymentReservationResult) (\(_,_val748) -> (case _val748 of {T.TString _val750 -> E.decodeUtf8 _val750; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paymentReservationResult_extras = P.maybe (paymentReservationResult_extras default_PaymentReservationResult) (\(_,_val748) -> (case _val748 of {T.TMap _ _ _val751 -> (Map.fromList $ P.map (\(_k753,_v752) -> ((case _k753 of {T.TString _val754 -> E.decodeUtf8 _val754; _ -> P.error "wrong type"}),(case _v752 of {T.TString _val755 -> E.decodeUtf8 _val755; _ -> P.error "wrong type"}))) _val751); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_PaymentReservationResult _ = P.error "not a struct"
read_PaymentReservationResult :: T.Protocol p => p -> P.IO PaymentReservationResult
read_PaymentReservationResult iprot = to_PaymentReservationResult <$> T.readVal iprot (T.T_STRUCT typemap_PaymentReservationResult)
decode_PaymentReservationResult :: T.StatelessProtocol p => p -> LBS.ByteString -> PaymentReservationResult
decode_PaymentReservationResult iprot bs = to_PaymentReservationResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PaymentReservationResult) bs
typemap_PaymentReservationResult :: T.TypeMap
typemap_PaymentReservationResult = Map.fromList [(1,("orderId",T.T_STRING)),(2,("confirmUrl",T.T_STRING)),(3,("extras",(T.T_MAP T.T_STRING T.T_STRING)))]
default_PaymentReservationResult :: PaymentReservationResult
default_PaymentReservationResult = PaymentReservationResult{
  paymentReservationResult_orderId = "",
  paymentReservationResult_confirmUrl = "",
  paymentReservationResult_extras = Map.empty}
data Product = Product  { product_productId :: LT.Text
  , product_packageId :: I.Int64
  , product_version :: I.Int32
  , product_authorName :: LT.Text
  , product_onSale :: P.Bool
  , product_validDays :: I.Int32
  , product_saleType :: I.Int32
  , product_copyright :: LT.Text
  , product_title :: LT.Text
  , product_descriptionText :: LT.Text
  , product_shopOrderId :: I.Int64
  , product_fromMid :: LT.Text
  , product_toMid :: LT.Text
  , product_validUntil :: I.Int64
  , product_priceTier :: I.Int32
  , product_price :: LT.Text
  , product_currency :: LT.Text
  , product_currencySymbol :: LT.Text
  , product_paymentType :: PaymentType
  , product_createDate :: I.Int64
  , product_ownFlag :: P.Bool
  , product_eventType :: ProductEventType
  , product_urlSchema :: LT.Text
  , product_downloadUrl :: LT.Text
  , product_buddyMid :: LT.Text
  , product_publishSince :: I.Int64
  , product_newFlag :: P.Bool
  , product_missionFlag :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Product where
  hashWithSalt salt record = salt   `H.hashWithSalt` product_productId record   `H.hashWithSalt` product_packageId record   `H.hashWithSalt` product_version record   `H.hashWithSalt` product_authorName record   `H.hashWithSalt` product_onSale record   `H.hashWithSalt` product_validDays record   `H.hashWithSalt` product_saleType record   `H.hashWithSalt` product_copyright record   `H.hashWithSalt` product_title record   `H.hashWithSalt` product_descriptionText record   `H.hashWithSalt` product_shopOrderId record   `H.hashWithSalt` product_fromMid record   `H.hashWithSalt` product_toMid record   `H.hashWithSalt` product_validUntil record   `H.hashWithSalt` product_priceTier record   `H.hashWithSalt` product_price record   `H.hashWithSalt` product_currency record   `H.hashWithSalt` product_currencySymbol record   `H.hashWithSalt` product_paymentType record   `H.hashWithSalt` product_createDate record   `H.hashWithSalt` product_ownFlag record   `H.hashWithSalt` product_eventType record   `H.hashWithSalt` product_urlSchema record   `H.hashWithSalt` product_downloadUrl record   `H.hashWithSalt` product_buddyMid record   `H.hashWithSalt` product_publishSince record   `H.hashWithSalt` product_newFlag record   `H.hashWithSalt` product_missionFlag record  
instance QC.Arbitrary Product where 
  arbitrary = M.liftM Product (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Product = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Product{product_productId = product_productId obj} then P.Nothing else P.Just $ default_Product{product_productId = product_productId obj}
    , if obj == default_Product{product_packageId = product_packageId obj} then P.Nothing else P.Just $ default_Product{product_packageId = product_packageId obj}
    , if obj == default_Product{product_version = product_version obj} then P.Nothing else P.Just $ default_Product{product_version = product_version obj}
    , if obj == default_Product{product_authorName = product_authorName obj} then P.Nothing else P.Just $ default_Product{product_authorName = product_authorName obj}
    , if obj == default_Product{product_onSale = product_onSale obj} then P.Nothing else P.Just $ default_Product{product_onSale = product_onSale obj}
    , if obj == default_Product{product_validDays = product_validDays obj} then P.Nothing else P.Just $ default_Product{product_validDays = product_validDays obj}
    , if obj == default_Product{product_saleType = product_saleType obj} then P.Nothing else P.Just $ default_Product{product_saleType = product_saleType obj}
    , if obj == default_Product{product_copyright = product_copyright obj} then P.Nothing else P.Just $ default_Product{product_copyright = product_copyright obj}
    , if obj == default_Product{product_title = product_title obj} then P.Nothing else P.Just $ default_Product{product_title = product_title obj}
    , if obj == default_Product{product_descriptionText = product_descriptionText obj} then P.Nothing else P.Just $ default_Product{product_descriptionText = product_descriptionText obj}
    , if obj == default_Product{product_shopOrderId = product_shopOrderId obj} then P.Nothing else P.Just $ default_Product{product_shopOrderId = product_shopOrderId obj}
    , if obj == default_Product{product_fromMid = product_fromMid obj} then P.Nothing else P.Just $ default_Product{product_fromMid = product_fromMid obj}
    , if obj == default_Product{product_toMid = product_toMid obj} then P.Nothing else P.Just $ default_Product{product_toMid = product_toMid obj}
    , if obj == default_Product{product_validUntil = product_validUntil obj} then P.Nothing else P.Just $ default_Product{product_validUntil = product_validUntil obj}
    , if obj == default_Product{product_priceTier = product_priceTier obj} then P.Nothing else P.Just $ default_Product{product_priceTier = product_priceTier obj}
    , if obj == default_Product{product_price = product_price obj} then P.Nothing else P.Just $ default_Product{product_price = product_price obj}
    , if obj == default_Product{product_currency = product_currency obj} then P.Nothing else P.Just $ default_Product{product_currency = product_currency obj}
    , if obj == default_Product{product_currencySymbol = product_currencySymbol obj} then P.Nothing else P.Just $ default_Product{product_currencySymbol = product_currencySymbol obj}
    , if obj == default_Product{product_paymentType = product_paymentType obj} then P.Nothing else P.Just $ default_Product{product_paymentType = product_paymentType obj}
    , if obj == default_Product{product_createDate = product_createDate obj} then P.Nothing else P.Just $ default_Product{product_createDate = product_createDate obj}
    , if obj == default_Product{product_ownFlag = product_ownFlag obj} then P.Nothing else P.Just $ default_Product{product_ownFlag = product_ownFlag obj}
    , if obj == default_Product{product_eventType = product_eventType obj} then P.Nothing else P.Just $ default_Product{product_eventType = product_eventType obj}
    , if obj == default_Product{product_urlSchema = product_urlSchema obj} then P.Nothing else P.Just $ default_Product{product_urlSchema = product_urlSchema obj}
    , if obj == default_Product{product_downloadUrl = product_downloadUrl obj} then P.Nothing else P.Just $ default_Product{product_downloadUrl = product_downloadUrl obj}
    , if obj == default_Product{product_buddyMid = product_buddyMid obj} then P.Nothing else P.Just $ default_Product{product_buddyMid = product_buddyMid obj}
    , if obj == default_Product{product_publishSince = product_publishSince obj} then P.Nothing else P.Just $ default_Product{product_publishSince = product_publishSince obj}
    , if obj == default_Product{product_newFlag = product_newFlag obj} then P.Nothing else P.Just $ default_Product{product_newFlag = product_newFlag obj}
    , if obj == default_Product{product_missionFlag = product_missionFlag obj} then P.Nothing else P.Just $ default_Product{product_missionFlag = product_missionFlag obj}
    ]
from_Product :: Product -> T.ThriftVal
from_Product record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v758 -> P.Just (1, ("productId",T.TString $ E.encodeUtf8 _v758))) $ product_productId record
  , (\_v758 -> P.Just (2, ("packageId",T.TI64 _v758))) $ product_packageId record
  , (\_v758 -> P.Just (3, ("version",T.TI32 _v758))) $ product_version record
  , (\_v758 -> P.Just (4, ("authorName",T.TString $ E.encodeUtf8 _v758))) $ product_authorName record
  , (\_v758 -> P.Just (5, ("onSale",T.TBool _v758))) $ product_onSale record
  , (\_v758 -> P.Just (6, ("validDays",T.TI32 _v758))) $ product_validDays record
  , (\_v758 -> P.Just (7, ("saleType",T.TI32 _v758))) $ product_saleType record
  , (\_v758 -> P.Just (8, ("copyright",T.TString $ E.encodeUtf8 _v758))) $ product_copyright record
  , (\_v758 -> P.Just (9, ("title",T.TString $ E.encodeUtf8 _v758))) $ product_title record
  , (\_v758 -> P.Just (10, ("descriptionText",T.TString $ E.encodeUtf8 _v758))) $ product_descriptionText record
  , (\_v758 -> P.Just (11, ("shopOrderId",T.TI64 _v758))) $ product_shopOrderId record
  , (\_v758 -> P.Just (12, ("fromMid",T.TString $ E.encodeUtf8 _v758))) $ product_fromMid record
  , (\_v758 -> P.Just (13, ("toMid",T.TString $ E.encodeUtf8 _v758))) $ product_toMid record
  , (\_v758 -> P.Just (14, ("validUntil",T.TI64 _v758))) $ product_validUntil record
  , (\_v758 -> P.Just (15, ("priceTier",T.TI32 _v758))) $ product_priceTier record
  , (\_v758 -> P.Just (16, ("price",T.TString $ E.encodeUtf8 _v758))) $ product_price record
  , (\_v758 -> P.Just (17, ("currency",T.TString $ E.encodeUtf8 _v758))) $ product_currency record
  , (\_v758 -> P.Just (18, ("currencySymbol",T.TString $ E.encodeUtf8 _v758))) $ product_currencySymbol record
  , (\_v758 -> P.Just (19, ("paymentType",T.TI32 $ P.fromIntegral $ P.fromEnum _v758))) $ product_paymentType record
  , (\_v758 -> P.Just (20, ("createDate",T.TI64 _v758))) $ product_createDate record
  , (\_v758 -> P.Just (21, ("ownFlag",T.TBool _v758))) $ product_ownFlag record
  , (\_v758 -> P.Just (22, ("eventType",T.TI32 $ P.fromIntegral $ P.fromEnum _v758))) $ product_eventType record
  , (\_v758 -> P.Just (23, ("urlSchema",T.TString $ E.encodeUtf8 _v758))) $ product_urlSchema record
  , (\_v758 -> P.Just (24, ("downloadUrl",T.TString $ E.encodeUtf8 _v758))) $ product_downloadUrl record
  , (\_v758 -> P.Just (25, ("buddyMid",T.TString $ E.encodeUtf8 _v758))) $ product_buddyMid record
  , (\_v758 -> P.Just (26, ("publishSince",T.TI64 _v758))) $ product_publishSince record
  , (\_v758 -> P.Just (27, ("newFlag",T.TBool _v758))) $ product_newFlag record
  , (\_v758 -> P.Just (28, ("missionFlag",T.TBool _v758))) $ product_missionFlag record
  ]
write_Product :: T.Protocol p => p -> Product -> P.IO ()
write_Product oprot record = T.writeVal oprot $ from_Product record
encode_Product :: T.StatelessProtocol p => p -> Product -> LBS.ByteString
encode_Product oprot record = T.serializeVal oprot $ from_Product record
to_Product :: T.ThriftVal -> Product
to_Product (T.TStruct fields) = Product{
  product_productId = P.maybe (product_productId default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val761 -> E.decodeUtf8 _val761; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  product_packageId = P.maybe (product_packageId default_Product) (\(_,_val760) -> (case _val760 of {T.TI64 _val762 -> _val762; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  product_version = P.maybe (product_version default_Product) (\(_,_val760) -> (case _val760 of {T.TI32 _val763 -> _val763; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  product_authorName = P.maybe (product_authorName default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val764 -> E.decodeUtf8 _val764; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  product_onSale = P.maybe (product_onSale default_Product) (\(_,_val760) -> (case _val760 of {T.TBool _val765 -> _val765; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  product_validDays = P.maybe (product_validDays default_Product) (\(_,_val760) -> (case _val760 of {T.TI32 _val766 -> _val766; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  product_saleType = P.maybe (product_saleType default_Product) (\(_,_val760) -> (case _val760 of {T.TI32 _val767 -> _val767; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  product_copyright = P.maybe (product_copyright default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val768 -> E.decodeUtf8 _val768; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  product_title = P.maybe (product_title default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val769 -> E.decodeUtf8 _val769; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  product_descriptionText = P.maybe (product_descriptionText default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val770 -> E.decodeUtf8 _val770; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  product_shopOrderId = P.maybe (product_shopOrderId default_Product) (\(_,_val760) -> (case _val760 of {T.TI64 _val771 -> _val771; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  product_fromMid = P.maybe (product_fromMid default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val772 -> E.decodeUtf8 _val772; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  product_toMid = P.maybe (product_toMid default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val773 -> E.decodeUtf8 _val773; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  product_validUntil = P.maybe (product_validUntil default_Product) (\(_,_val760) -> (case _val760 of {T.TI64 _val774 -> _val774; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  product_priceTier = P.maybe (product_priceTier default_Product) (\(_,_val760) -> (case _val760 of {T.TI32 _val775 -> _val775; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  product_price = P.maybe (product_price default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val776 -> E.decodeUtf8 _val776; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  product_currency = P.maybe (product_currency default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val777 -> E.decodeUtf8 _val777; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  product_currencySymbol = P.maybe (product_currencySymbol default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val778 -> E.decodeUtf8 _val778; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  product_paymentType = P.maybe (product_paymentType default_Product) (\(_,_val760) -> (case _val760 of {T.TI32 _val779 -> P.toEnum $ P.fromIntegral _val779; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  product_createDate = P.maybe (product_createDate default_Product) (\(_,_val760) -> (case _val760 of {T.TI64 _val780 -> _val780; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  product_ownFlag = P.maybe (product_ownFlag default_Product) (\(_,_val760) -> (case _val760 of {T.TBool _val781 -> _val781; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  product_eventType = P.maybe (product_eventType default_Product) (\(_,_val760) -> (case _val760 of {T.TI32 _val782 -> P.toEnum $ P.fromIntegral _val782; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  product_urlSchema = P.maybe (product_urlSchema default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val783 -> E.decodeUtf8 _val783; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  product_downloadUrl = P.maybe (product_downloadUrl default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val784 -> E.decodeUtf8 _val784; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  product_buddyMid = P.maybe (product_buddyMid default_Product) (\(_,_val760) -> (case _val760 of {T.TString _val785 -> E.decodeUtf8 _val785; _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  product_publishSince = P.maybe (product_publishSince default_Product) (\(_,_val760) -> (case _val760 of {T.TI64 _val786 -> _val786; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  product_newFlag = P.maybe (product_newFlag default_Product) (\(_,_val760) -> (case _val760 of {T.TBool _val787 -> _val787; _ -> P.error "wrong type"})) (Map.lookup (27) fields),
  product_missionFlag = P.maybe (product_missionFlag default_Product) (\(_,_val760) -> (case _val760 of {T.TBool _val788 -> _val788; _ -> P.error "wrong type"})) (Map.lookup (28) fields)
  }
to_Product _ = P.error "not a struct"
read_Product :: T.Protocol p => p -> P.IO Product
read_Product iprot = to_Product <$> T.readVal iprot (T.T_STRUCT typemap_Product)
decode_Product :: T.StatelessProtocol p => p -> LBS.ByteString -> Product
decode_Product iprot bs = to_Product $ T.deserializeVal iprot (T.T_STRUCT typemap_Product) bs
typemap_Product :: T.TypeMap
typemap_Product = Map.fromList [(1,("productId",T.T_STRING)),(2,("packageId",T.T_I64)),(3,("version",T.T_I32)),(4,("authorName",T.T_STRING)),(5,("onSale",T.T_BOOL)),(6,("validDays",T.T_I32)),(7,("saleType",T.T_I32)),(8,("copyright",T.T_STRING)),(9,("title",T.T_STRING)),(10,("descriptionText",T.T_STRING)),(11,("shopOrderId",T.T_I64)),(12,("fromMid",T.T_STRING)),(13,("toMid",T.T_STRING)),(14,("validUntil",T.T_I64)),(15,("priceTier",T.T_I32)),(16,("price",T.T_STRING)),(17,("currency",T.T_STRING)),(18,("currencySymbol",T.T_STRING)),(19,("paymentType",T.T_I32)),(20,("createDate",T.T_I64)),(21,("ownFlag",T.T_BOOL)),(22,("eventType",T.T_I32)),(23,("urlSchema",T.T_STRING)),(24,("downloadUrl",T.T_STRING)),(25,("buddyMid",T.T_STRING)),(26,("publishSince",T.T_I64)),(27,("newFlag",T.T_BOOL)),(28,("missionFlag",T.T_BOOL))]
default_Product :: Product
default_Product = Product{
  product_productId = "",
  product_packageId = 0,
  product_version = 0,
  product_authorName = "",
  product_onSale = P.False,
  product_validDays = 0,
  product_saleType = 0,
  product_copyright = "",
  product_title = "",
  product_descriptionText = "",
  product_shopOrderId = 0,
  product_fromMid = "",
  product_toMid = "",
  product_validUntil = 0,
  product_priceTier = 0,
  product_price = "",
  product_currency = "",
  product_currencySymbol = "",
  product_paymentType = (P.toEnum 0),
  product_createDate = 0,
  product_ownFlag = P.False,
  product_eventType = (P.toEnum 0),
  product_urlSchema = "",
  product_downloadUrl = "",
  product_buddyMid = "",
  product_publishSince = 0,
  product_newFlag = P.False,
  product_missionFlag = P.False}
data ProductList = ProductList  { productList_hasNext :: P.Bool
  , productList_bannerSequence :: I.Int64
  , productList_bannerTargetType :: ProductBannerLinkType
  , productList_bannerTargetPath :: LT.Text
  , productList_productList :: (Vector.Vector Product)
  , productList_bannerLang :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProductList where
  hashWithSalt salt record = salt   `H.hashWithSalt` productList_hasNext record   `H.hashWithSalt` productList_bannerSequence record   `H.hashWithSalt` productList_bannerTargetType record   `H.hashWithSalt` productList_bannerTargetPath record   `H.hashWithSalt` productList_productList record   `H.hashWithSalt` productList_bannerLang record  
instance QC.Arbitrary ProductList where 
  arbitrary = M.liftM ProductList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProductList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProductList{productList_hasNext = productList_hasNext obj} then P.Nothing else P.Just $ default_ProductList{productList_hasNext = productList_hasNext obj}
    , if obj == default_ProductList{productList_bannerSequence = productList_bannerSequence obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerSequence = productList_bannerSequence obj}
    , if obj == default_ProductList{productList_bannerTargetType = productList_bannerTargetType obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerTargetType = productList_bannerTargetType obj}
    , if obj == default_ProductList{productList_bannerTargetPath = productList_bannerTargetPath obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerTargetPath = productList_bannerTargetPath obj}
    , if obj == default_ProductList{productList_productList = productList_productList obj} then P.Nothing else P.Just $ default_ProductList{productList_productList = productList_productList obj}
    , if obj == default_ProductList{productList_bannerLang = productList_bannerLang obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerLang = productList_bannerLang obj}
    ]
from_ProductList :: ProductList -> T.ThriftVal
from_ProductList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v791 -> P.Just (1, ("hasNext",T.TBool _v791))) $ productList_hasNext record
  , (\_v791 -> P.Just (4, ("bannerSequence",T.TI64 _v791))) $ productList_bannerSequence record
  , (\_v791 -> P.Just (5, ("bannerTargetType",T.TI32 $ P.fromIntegral $ P.fromEnum _v791))) $ productList_bannerTargetType record
  , (\_v791 -> P.Just (6, ("bannerTargetPath",T.TString $ E.encodeUtf8 _v791))) $ productList_bannerTargetPath record
  , (\_v791 -> P.Just (7, ("productList",T.TList (T.T_STRUCT typemap_Product) $ P.map (\_v793 -> from_Product _v793) $ Vector.toList _v791))) $ productList_productList record
  , (\_v791 -> P.Just (8, ("bannerLang",T.TString $ E.encodeUtf8 _v791))) $ productList_bannerLang record
  ]
write_ProductList :: T.Protocol p => p -> ProductList -> P.IO ()
write_ProductList oprot record = T.writeVal oprot $ from_ProductList record
encode_ProductList :: T.StatelessProtocol p => p -> ProductList -> LBS.ByteString
encode_ProductList oprot record = T.serializeVal oprot $ from_ProductList record
to_ProductList :: T.ThriftVal -> ProductList
to_ProductList (T.TStruct fields) = ProductList{
  productList_hasNext = P.maybe (productList_hasNext default_ProductList) (\(_,_val795) -> (case _val795 of {T.TBool _val796 -> _val796; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  productList_bannerSequence = P.maybe (productList_bannerSequence default_ProductList) (\(_,_val795) -> (case _val795 of {T.TI64 _val797 -> _val797; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  productList_bannerTargetType = P.maybe (productList_bannerTargetType default_ProductList) (\(_,_val795) -> (case _val795 of {T.TI32 _val798 -> P.toEnum $ P.fromIntegral _val798; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  productList_bannerTargetPath = P.maybe (productList_bannerTargetPath default_ProductList) (\(_,_val795) -> (case _val795 of {T.TString _val799 -> E.decodeUtf8 _val799; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  productList_productList = P.maybe (productList_productList default_ProductList) (\(_,_val795) -> (case _val795 of {T.TList _ _val800 -> (Vector.fromList $ P.map (\_v801 -> (case _v801 of {T.TStruct _val802 -> (to_Product (T.TStruct _val802)); _ -> P.error "wrong type"})) _val800); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  productList_bannerLang = P.maybe (productList_bannerLang default_ProductList) (\(_,_val795) -> (case _val795 of {T.TString _val803 -> E.decodeUtf8 _val803; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_ProductList _ = P.error "not a struct"
read_ProductList :: T.Protocol p => p -> P.IO ProductList
read_ProductList iprot = to_ProductList <$> T.readVal iprot (T.T_STRUCT typemap_ProductList)
decode_ProductList :: T.StatelessProtocol p => p -> LBS.ByteString -> ProductList
decode_ProductList iprot bs = to_ProductList $ T.deserializeVal iprot (T.T_STRUCT typemap_ProductList) bs
typemap_ProductList :: T.TypeMap
typemap_ProductList = Map.fromList [(1,("hasNext",T.T_BOOL)),(4,("bannerSequence",T.T_I64)),(5,("bannerTargetType",T.T_I32)),(6,("bannerTargetPath",T.T_STRING)),(7,("productList",(T.T_LIST (T.T_STRUCT typemap_Product)))),(8,("bannerLang",T.T_STRING))]
default_ProductList :: ProductList
default_ProductList = ProductList{
  productList_hasNext = P.False,
  productList_bannerSequence = 0,
  productList_bannerTargetType = (P.toEnum 0),
  productList_bannerTargetPath = "",
  productList_productList = Vector.empty,
  productList_bannerLang = ""}
data ProductSimple = ProductSimple  { productSimple_productId :: LT.Text
  , productSimple_packageId :: I.Int64
  , productSimple_version :: I.Int32
  , productSimple_onSale :: P.Bool
  , productSimple_validUntil :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProductSimple where
  hashWithSalt salt record = salt   `H.hashWithSalt` productSimple_productId record   `H.hashWithSalt` productSimple_packageId record   `H.hashWithSalt` productSimple_version record   `H.hashWithSalt` productSimple_onSale record   `H.hashWithSalt` productSimple_validUntil record  
instance QC.Arbitrary ProductSimple where 
  arbitrary = M.liftM ProductSimple (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProductSimple = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProductSimple{productSimple_productId = productSimple_productId obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_productId = productSimple_productId obj}
    , if obj == default_ProductSimple{productSimple_packageId = productSimple_packageId obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_packageId = productSimple_packageId obj}
    , if obj == default_ProductSimple{productSimple_version = productSimple_version obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_version = productSimple_version obj}
    , if obj == default_ProductSimple{productSimple_onSale = productSimple_onSale obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_onSale = productSimple_onSale obj}
    , if obj == default_ProductSimple{productSimple_validUntil = productSimple_validUntil obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_validUntil = productSimple_validUntil obj}
    ]
from_ProductSimple :: ProductSimple -> T.ThriftVal
from_ProductSimple record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v806 -> P.Just (1, ("productId",T.TString $ E.encodeUtf8 _v806))) $ productSimple_productId record
  , (\_v806 -> P.Just (2, ("packageId",T.TI64 _v806))) $ productSimple_packageId record
  , (\_v806 -> P.Just (3, ("version",T.TI32 _v806))) $ productSimple_version record
  , (\_v806 -> P.Just (4, ("onSale",T.TBool _v806))) $ productSimple_onSale record
  , (\_v806 -> P.Just (5, ("validUntil",T.TI64 _v806))) $ productSimple_validUntil record
  ]
write_ProductSimple :: T.Protocol p => p -> ProductSimple -> P.IO ()
write_ProductSimple oprot record = T.writeVal oprot $ from_ProductSimple record
encode_ProductSimple :: T.StatelessProtocol p => p -> ProductSimple -> LBS.ByteString
encode_ProductSimple oprot record = T.serializeVal oprot $ from_ProductSimple record
to_ProductSimple :: T.ThriftVal -> ProductSimple
to_ProductSimple (T.TStruct fields) = ProductSimple{
  productSimple_productId = P.maybe (productSimple_productId default_ProductSimple) (\(_,_val808) -> (case _val808 of {T.TString _val809 -> E.decodeUtf8 _val809; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  productSimple_packageId = P.maybe (productSimple_packageId default_ProductSimple) (\(_,_val808) -> (case _val808 of {T.TI64 _val810 -> _val810; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  productSimple_version = P.maybe (productSimple_version default_ProductSimple) (\(_,_val808) -> (case _val808 of {T.TI32 _val811 -> _val811; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  productSimple_onSale = P.maybe (productSimple_onSale default_ProductSimple) (\(_,_val808) -> (case _val808 of {T.TBool _val812 -> _val812; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  productSimple_validUntil = P.maybe (productSimple_validUntil default_ProductSimple) (\(_,_val808) -> (case _val808 of {T.TI64 _val813 -> _val813; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ProductSimple _ = P.error "not a struct"
read_ProductSimple :: T.Protocol p => p -> P.IO ProductSimple
read_ProductSimple iprot = to_ProductSimple <$> T.readVal iprot (T.T_STRUCT typemap_ProductSimple)
decode_ProductSimple :: T.StatelessProtocol p => p -> LBS.ByteString -> ProductSimple
decode_ProductSimple iprot bs = to_ProductSimple $ T.deserializeVal iprot (T.T_STRUCT typemap_ProductSimple) bs
typemap_ProductSimple :: T.TypeMap
typemap_ProductSimple = Map.fromList [(1,("productId",T.T_STRING)),(2,("packageId",T.T_I64)),(3,("version",T.T_I32)),(4,("onSale",T.T_BOOL)),(5,("validUntil",T.T_I64))]
default_ProductSimple :: ProductSimple
default_ProductSimple = ProductSimple{
  productSimple_productId = "",
  productSimple_packageId = 0,
  productSimple_version = 0,
  productSimple_onSale = P.False,
  productSimple_validUntil = 0}
data ProductSimpleList = ProductSimpleList  { productSimpleList_hasNext :: P.Bool
  , productSimpleList_reinvokeHour :: I.Int32
  , productSimpleList_lastVersionSeq :: I.Int64
  , productSimpleList_productList :: (Vector.Vector ProductSimple)
  , productSimpleList_recentNewReleaseDate :: I.Int64
  , productSimpleList_recentEventReleaseDate :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProductSimpleList where
  hashWithSalt salt record = salt   `H.hashWithSalt` productSimpleList_hasNext record   `H.hashWithSalt` productSimpleList_reinvokeHour record   `H.hashWithSalt` productSimpleList_lastVersionSeq record   `H.hashWithSalt` productSimpleList_productList record   `H.hashWithSalt` productSimpleList_recentNewReleaseDate record   `H.hashWithSalt` productSimpleList_recentEventReleaseDate record  
instance QC.Arbitrary ProductSimpleList where 
  arbitrary = M.liftM ProductSimpleList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProductSimpleList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProductSimpleList{productSimpleList_hasNext = productSimpleList_hasNext obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_hasNext = productSimpleList_hasNext obj}
    , if obj == default_ProductSimpleList{productSimpleList_reinvokeHour = productSimpleList_reinvokeHour obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_reinvokeHour = productSimpleList_reinvokeHour obj}
    , if obj == default_ProductSimpleList{productSimpleList_lastVersionSeq = productSimpleList_lastVersionSeq obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_lastVersionSeq = productSimpleList_lastVersionSeq obj}
    , if obj == default_ProductSimpleList{productSimpleList_productList = productSimpleList_productList obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_productList = productSimpleList_productList obj}
    , if obj == default_ProductSimpleList{productSimpleList_recentNewReleaseDate = productSimpleList_recentNewReleaseDate obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_recentNewReleaseDate = productSimpleList_recentNewReleaseDate obj}
    , if obj == default_ProductSimpleList{productSimpleList_recentEventReleaseDate = productSimpleList_recentEventReleaseDate obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_recentEventReleaseDate = productSimpleList_recentEventReleaseDate obj}
    ]
from_ProductSimpleList :: ProductSimpleList -> T.ThriftVal
from_ProductSimpleList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v816 -> P.Just (1, ("hasNext",T.TBool _v816))) $ productSimpleList_hasNext record
  , (\_v816 -> P.Just (2, ("reinvokeHour",T.TI32 _v816))) $ productSimpleList_reinvokeHour record
  , (\_v816 -> P.Just (3, ("lastVersionSeq",T.TI64 _v816))) $ productSimpleList_lastVersionSeq record
  , (\_v816 -> P.Just (4, ("productList",T.TList (T.T_STRUCT typemap_ProductSimple) $ P.map (\_v818 -> from_ProductSimple _v818) $ Vector.toList _v816))) $ productSimpleList_productList record
  , (\_v816 -> P.Just (5, ("recentNewReleaseDate",T.TI64 _v816))) $ productSimpleList_recentNewReleaseDate record
  , (\_v816 -> P.Just (6, ("recentEventReleaseDate",T.TI64 _v816))) $ productSimpleList_recentEventReleaseDate record
  ]
write_ProductSimpleList :: T.Protocol p => p -> ProductSimpleList -> P.IO ()
write_ProductSimpleList oprot record = T.writeVal oprot $ from_ProductSimpleList record
encode_ProductSimpleList :: T.StatelessProtocol p => p -> ProductSimpleList -> LBS.ByteString
encode_ProductSimpleList oprot record = T.serializeVal oprot $ from_ProductSimpleList record
to_ProductSimpleList :: T.ThriftVal -> ProductSimpleList
to_ProductSimpleList (T.TStruct fields) = ProductSimpleList{
  productSimpleList_hasNext = P.maybe (productSimpleList_hasNext default_ProductSimpleList) (\(_,_val820) -> (case _val820 of {T.TBool _val821 -> _val821; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  productSimpleList_reinvokeHour = P.maybe (productSimpleList_reinvokeHour default_ProductSimpleList) (\(_,_val820) -> (case _val820 of {T.TI32 _val822 -> _val822; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  productSimpleList_lastVersionSeq = P.maybe (productSimpleList_lastVersionSeq default_ProductSimpleList) (\(_,_val820) -> (case _val820 of {T.TI64 _val823 -> _val823; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  productSimpleList_productList = P.maybe (productSimpleList_productList default_ProductSimpleList) (\(_,_val820) -> (case _val820 of {T.TList _ _val824 -> (Vector.fromList $ P.map (\_v825 -> (case _v825 of {T.TStruct _val826 -> (to_ProductSimple (T.TStruct _val826)); _ -> P.error "wrong type"})) _val824); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  productSimpleList_recentNewReleaseDate = P.maybe (productSimpleList_recentNewReleaseDate default_ProductSimpleList) (\(_,_val820) -> (case _val820 of {T.TI64 _val827 -> _val827; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  productSimpleList_recentEventReleaseDate = P.maybe (productSimpleList_recentEventReleaseDate default_ProductSimpleList) (\(_,_val820) -> (case _val820 of {T.TI64 _val828 -> _val828; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_ProductSimpleList _ = P.error "not a struct"
read_ProductSimpleList :: T.Protocol p => p -> P.IO ProductSimpleList
read_ProductSimpleList iprot = to_ProductSimpleList <$> T.readVal iprot (T.T_STRUCT typemap_ProductSimpleList)
decode_ProductSimpleList :: T.StatelessProtocol p => p -> LBS.ByteString -> ProductSimpleList
decode_ProductSimpleList iprot bs = to_ProductSimpleList $ T.deserializeVal iprot (T.T_STRUCT typemap_ProductSimpleList) bs
typemap_ProductSimpleList :: T.TypeMap
typemap_ProductSimpleList = Map.fromList [(1,("hasNext",T.T_BOOL)),(2,("reinvokeHour",T.T_I32)),(3,("lastVersionSeq",T.T_I64)),(4,("productList",(T.T_LIST (T.T_STRUCT typemap_ProductSimple)))),(5,("recentNewReleaseDate",T.T_I64)),(6,("recentEventReleaseDate",T.T_I64))]
default_ProductSimpleList :: ProductSimpleList
default_ProductSimpleList = ProductSimpleList{
  productSimpleList_hasNext = P.False,
  productSimpleList_reinvokeHour = 0,
  productSimpleList_lastVersionSeq = 0,
  productSimpleList_productList = Vector.empty,
  productSimpleList_recentNewReleaseDate = 0,
  productSimpleList_recentEventReleaseDate = 0}
data Profile = Profile  { profile_mid :: LT.Text
  , profile_userid :: LT.Text
  , profile_phone :: LT.Text
  , profile_email :: LT.Text
  , profile_regionCode :: LT.Text
  , profile_displayName :: LT.Text
  , profile_phoneticName :: LT.Text
  , profile_pictureStatus :: LT.Text
  , profile_thumbnailUrl :: LT.Text
  , profile_statusMessage :: LT.Text
  , profile_allowSearchByUserid :: P.Bool
  , profile_allowSearchByEmail :: P.Bool
  , profile_picturePath :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Profile where
  hashWithSalt salt record = salt   `H.hashWithSalt` profile_mid record   `H.hashWithSalt` profile_userid record   `H.hashWithSalt` profile_phone record   `H.hashWithSalt` profile_email record   `H.hashWithSalt` profile_regionCode record   `H.hashWithSalt` profile_displayName record   `H.hashWithSalt` profile_phoneticName record   `H.hashWithSalt` profile_pictureStatus record   `H.hashWithSalt` profile_thumbnailUrl record   `H.hashWithSalt` profile_statusMessage record   `H.hashWithSalt` profile_allowSearchByUserid record   `H.hashWithSalt` profile_allowSearchByEmail record   `H.hashWithSalt` profile_picturePath record  
instance QC.Arbitrary Profile where 
  arbitrary = M.liftM Profile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Profile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Profile{profile_mid = profile_mid obj} then P.Nothing else P.Just $ default_Profile{profile_mid = profile_mid obj}
    , if obj == default_Profile{profile_userid = profile_userid obj} then P.Nothing else P.Just $ default_Profile{profile_userid = profile_userid obj}
    , if obj == default_Profile{profile_phone = profile_phone obj} then P.Nothing else P.Just $ default_Profile{profile_phone = profile_phone obj}
    , if obj == default_Profile{profile_email = profile_email obj} then P.Nothing else P.Just $ default_Profile{profile_email = profile_email obj}
    , if obj == default_Profile{profile_regionCode = profile_regionCode obj} then P.Nothing else P.Just $ default_Profile{profile_regionCode = profile_regionCode obj}
    , if obj == default_Profile{profile_displayName = profile_displayName obj} then P.Nothing else P.Just $ default_Profile{profile_displayName = profile_displayName obj}
    , if obj == default_Profile{profile_phoneticName = profile_phoneticName obj} then P.Nothing else P.Just $ default_Profile{profile_phoneticName = profile_phoneticName obj}
    , if obj == default_Profile{profile_pictureStatus = profile_pictureStatus obj} then P.Nothing else P.Just $ default_Profile{profile_pictureStatus = profile_pictureStatus obj}
    , if obj == default_Profile{profile_thumbnailUrl = profile_thumbnailUrl obj} then P.Nothing else P.Just $ default_Profile{profile_thumbnailUrl = profile_thumbnailUrl obj}
    , if obj == default_Profile{profile_statusMessage = profile_statusMessage obj} then P.Nothing else P.Just $ default_Profile{profile_statusMessage = profile_statusMessage obj}
    , if obj == default_Profile{profile_allowSearchByUserid = profile_allowSearchByUserid obj} then P.Nothing else P.Just $ default_Profile{profile_allowSearchByUserid = profile_allowSearchByUserid obj}
    , if obj == default_Profile{profile_allowSearchByEmail = profile_allowSearchByEmail obj} then P.Nothing else P.Just $ default_Profile{profile_allowSearchByEmail = profile_allowSearchByEmail obj}
    , if obj == default_Profile{profile_picturePath = profile_picturePath obj} then P.Nothing else P.Just $ default_Profile{profile_picturePath = profile_picturePath obj}
    ]
from_Profile :: Profile -> T.ThriftVal
from_Profile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v831 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v831))) $ profile_mid record
  , (\_v831 -> P.Just (3, ("userid",T.TString $ E.encodeUtf8 _v831))) $ profile_userid record
  , (\_v831 -> P.Just (10, ("phone",T.TString $ E.encodeUtf8 _v831))) $ profile_phone record
  , (\_v831 -> P.Just (11, ("email",T.TString $ E.encodeUtf8 _v831))) $ profile_email record
  , (\_v831 -> P.Just (12, ("regionCode",T.TString $ E.encodeUtf8 _v831))) $ profile_regionCode record
  , (\_v831 -> P.Just (20, ("displayName",T.TString $ E.encodeUtf8 _v831))) $ profile_displayName record
  , (\_v831 -> P.Just (21, ("phoneticName",T.TString $ E.encodeUtf8 _v831))) $ profile_phoneticName record
  , (\_v831 -> P.Just (22, ("pictureStatus",T.TString $ E.encodeUtf8 _v831))) $ profile_pictureStatus record
  , (\_v831 -> P.Just (23, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v831))) $ profile_thumbnailUrl record
  , (\_v831 -> P.Just (24, ("statusMessage",T.TString $ E.encodeUtf8 _v831))) $ profile_statusMessage record
  , (\_v831 -> P.Just (31, ("allowSearchByUserid",T.TBool _v831))) $ profile_allowSearchByUserid record
  , (\_v831 -> P.Just (32, ("allowSearchByEmail",T.TBool _v831))) $ profile_allowSearchByEmail record
  , (\_v831 -> P.Just (33, ("picturePath",T.TString $ E.encodeUtf8 _v831))) $ profile_picturePath record
  ]
write_Profile :: T.Protocol p => p -> Profile -> P.IO ()
write_Profile oprot record = T.writeVal oprot $ from_Profile record
encode_Profile :: T.StatelessProtocol p => p -> Profile -> LBS.ByteString
encode_Profile oprot record = T.serializeVal oprot $ from_Profile record
to_Profile :: T.ThriftVal -> Profile
to_Profile (T.TStruct fields) = Profile{
  profile_mid = P.maybe (profile_mid default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val834 -> E.decodeUtf8 _val834; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  profile_userid = P.maybe (profile_userid default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val835 -> E.decodeUtf8 _val835; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  profile_phone = P.maybe (profile_phone default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val836 -> E.decodeUtf8 _val836; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  profile_email = P.maybe (profile_email default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val837 -> E.decodeUtf8 _val837; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  profile_regionCode = P.maybe (profile_regionCode default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val838 -> E.decodeUtf8 _val838; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  profile_displayName = P.maybe (profile_displayName default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val839 -> E.decodeUtf8 _val839; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  profile_phoneticName = P.maybe (profile_phoneticName default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val840 -> E.decodeUtf8 _val840; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  profile_pictureStatus = P.maybe (profile_pictureStatus default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val841 -> E.decodeUtf8 _val841; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  profile_thumbnailUrl = P.maybe (profile_thumbnailUrl default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val842 -> E.decodeUtf8 _val842; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  profile_statusMessage = P.maybe (profile_statusMessage default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val843 -> E.decodeUtf8 _val843; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  profile_allowSearchByUserid = P.maybe (profile_allowSearchByUserid default_Profile) (\(_,_val833) -> (case _val833 of {T.TBool _val844 -> _val844; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  profile_allowSearchByEmail = P.maybe (profile_allowSearchByEmail default_Profile) (\(_,_val833) -> (case _val833 of {T.TBool _val845 -> _val845; _ -> P.error "wrong type"})) (Map.lookup (32) fields),
  profile_picturePath = P.maybe (profile_picturePath default_Profile) (\(_,_val833) -> (case _val833 of {T.TString _val846 -> E.decodeUtf8 _val846; _ -> P.error "wrong type"})) (Map.lookup (33) fields)
  }
to_Profile _ = P.error "not a struct"
read_Profile :: T.Protocol p => p -> P.IO Profile
read_Profile iprot = to_Profile <$> T.readVal iprot (T.T_STRUCT typemap_Profile)
decode_Profile :: T.StatelessProtocol p => p -> LBS.ByteString -> Profile
decode_Profile iprot bs = to_Profile $ T.deserializeVal iprot (T.T_STRUCT typemap_Profile) bs
typemap_Profile :: T.TypeMap
typemap_Profile = Map.fromList [(1,("mid",T.T_STRING)),(3,("userid",T.T_STRING)),(10,("phone",T.T_STRING)),(11,("email",T.T_STRING)),(12,("regionCode",T.T_STRING)),(20,("displayName",T.T_STRING)),(21,("phoneticName",T.T_STRING)),(22,("pictureStatus",T.T_STRING)),(23,("thumbnailUrl",T.T_STRING)),(24,("statusMessage",T.T_STRING)),(31,("allowSearchByUserid",T.T_BOOL)),(32,("allowSearchByEmail",T.T_BOOL)),(33,("picturePath",T.T_STRING))]
default_Profile :: Profile
default_Profile = Profile{
  profile_mid = "",
  profile_userid = "",
  profile_phone = "",
  profile_email = "",
  profile_regionCode = "",
  profile_displayName = "",
  profile_phoneticName = "",
  profile_pictureStatus = "",
  profile_thumbnailUrl = "",
  profile_statusMessage = "",
  profile_allowSearchByUserid = P.False,
  profile_allowSearchByEmail = P.False,
  profile_picturePath = ""}
data ProximityMatchCandidateResult = ProximityMatchCandidateResult  { proximityMatchCandidateResult_users :: (Vector.Vector Contact)
  , proximityMatchCandidateResult_buddies :: (Vector.Vector Contact)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProximityMatchCandidateResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` proximityMatchCandidateResult_users record   `H.hashWithSalt` proximityMatchCandidateResult_buddies record  
instance QC.Arbitrary ProximityMatchCandidateResult where 
  arbitrary = M.liftM ProximityMatchCandidateResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProximityMatchCandidateResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProximityMatchCandidateResult{proximityMatchCandidateResult_users = proximityMatchCandidateResult_users obj} then P.Nothing else P.Just $ default_ProximityMatchCandidateResult{proximityMatchCandidateResult_users = proximityMatchCandidateResult_users obj}
    , if obj == default_ProximityMatchCandidateResult{proximityMatchCandidateResult_buddies = proximityMatchCandidateResult_buddies obj} then P.Nothing else P.Just $ default_ProximityMatchCandidateResult{proximityMatchCandidateResult_buddies = proximityMatchCandidateResult_buddies obj}
    ]
from_ProximityMatchCandidateResult :: ProximityMatchCandidateResult -> T.ThriftVal
from_ProximityMatchCandidateResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v849 -> P.Just (1, ("users",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v851 -> from_Contact _v851) $ Vector.toList _v849))) $ proximityMatchCandidateResult_users record
  , (\_v849 -> P.Just (2, ("buddies",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v853 -> from_Contact _v853) $ Vector.toList _v849))) $ proximityMatchCandidateResult_buddies record
  ]
write_ProximityMatchCandidateResult :: T.Protocol p => p -> ProximityMatchCandidateResult -> P.IO ()
write_ProximityMatchCandidateResult oprot record = T.writeVal oprot $ from_ProximityMatchCandidateResult record
encode_ProximityMatchCandidateResult :: T.StatelessProtocol p => p -> ProximityMatchCandidateResult -> LBS.ByteString
encode_ProximityMatchCandidateResult oprot record = T.serializeVal oprot $ from_ProximityMatchCandidateResult record
to_ProximityMatchCandidateResult :: T.ThriftVal -> ProximityMatchCandidateResult
to_ProximityMatchCandidateResult (T.TStruct fields) = ProximityMatchCandidateResult{
  proximityMatchCandidateResult_users = P.maybe (proximityMatchCandidateResult_users default_ProximityMatchCandidateResult) (\(_,_val855) -> (case _val855 of {T.TList _ _val856 -> (Vector.fromList $ P.map (\_v857 -> (case _v857 of {T.TStruct _val858 -> (to_Contact (T.TStruct _val858)); _ -> P.error "wrong type"})) _val856); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  proximityMatchCandidateResult_buddies = P.maybe (proximityMatchCandidateResult_buddies default_ProximityMatchCandidateResult) (\(_,_val855) -> (case _val855 of {T.TList _ _val859 -> (Vector.fromList $ P.map (\_v860 -> (case _v860 of {T.TStruct _val861 -> (to_Contact (T.TStruct _val861)); _ -> P.error "wrong type"})) _val859); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ProximityMatchCandidateResult _ = P.error "not a struct"
read_ProximityMatchCandidateResult :: T.Protocol p => p -> P.IO ProximityMatchCandidateResult
read_ProximityMatchCandidateResult iprot = to_ProximityMatchCandidateResult <$> T.readVal iprot (T.T_STRUCT typemap_ProximityMatchCandidateResult)
decode_ProximityMatchCandidateResult :: T.StatelessProtocol p => p -> LBS.ByteString -> ProximityMatchCandidateResult
decode_ProximityMatchCandidateResult iprot bs = to_ProximityMatchCandidateResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ProximityMatchCandidateResult) bs
typemap_ProximityMatchCandidateResult :: T.TypeMap
typemap_ProximityMatchCandidateResult = Map.fromList [(1,("users",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(2,("buddies",(T.T_LIST (T.T_STRUCT typemap_Contact))))]
default_ProximityMatchCandidateResult :: ProximityMatchCandidateResult
default_ProximityMatchCandidateResult = ProximityMatchCandidateResult{
  proximityMatchCandidateResult_users = Vector.empty,
  proximityMatchCandidateResult_buddies = Vector.empty}
data RegisterWithSnsIdResult = RegisterWithSnsIdResult  { registerWithSnsIdResult_authToken :: LT.Text
  , registerWithSnsIdResult_userCreated :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsIdResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsIdResult_authToken record   `H.hashWithSalt` registerWithSnsIdResult_userCreated record  
instance QC.Arbitrary RegisterWithSnsIdResult where 
  arbitrary = M.liftM RegisterWithSnsIdResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsIdResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsIdResult{registerWithSnsIdResult_authToken = registerWithSnsIdResult_authToken obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdResult{registerWithSnsIdResult_authToken = registerWithSnsIdResult_authToken obj}
    , if obj == default_RegisterWithSnsIdResult{registerWithSnsIdResult_userCreated = registerWithSnsIdResult_userCreated obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdResult{registerWithSnsIdResult_userCreated = registerWithSnsIdResult_userCreated obj}
    ]
from_RegisterWithSnsIdResult :: RegisterWithSnsIdResult -> T.ThriftVal
from_RegisterWithSnsIdResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v864 -> P.Just (1, ("authToken",T.TString $ E.encodeUtf8 _v864))) $ registerWithSnsIdResult_authToken record
  , (\_v864 -> P.Just (2, ("userCreated",T.TBool _v864))) $ registerWithSnsIdResult_userCreated record
  ]
write_RegisterWithSnsIdResult :: T.Protocol p => p -> RegisterWithSnsIdResult -> P.IO ()
write_RegisterWithSnsIdResult oprot record = T.writeVal oprot $ from_RegisterWithSnsIdResult record
encode_RegisterWithSnsIdResult :: T.StatelessProtocol p => p -> RegisterWithSnsIdResult -> LBS.ByteString
encode_RegisterWithSnsIdResult oprot record = T.serializeVal oprot $ from_RegisterWithSnsIdResult record
to_RegisterWithSnsIdResult :: T.ThriftVal -> RegisterWithSnsIdResult
to_RegisterWithSnsIdResult (T.TStruct fields) = RegisterWithSnsIdResult{
  registerWithSnsIdResult_authToken = P.maybe (registerWithSnsIdResult_authToken default_RegisterWithSnsIdResult) (\(_,_val866) -> (case _val866 of {T.TString _val867 -> E.decodeUtf8 _val867; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  registerWithSnsIdResult_userCreated = P.maybe (registerWithSnsIdResult_userCreated default_RegisterWithSnsIdResult) (\(_,_val866) -> (case _val866 of {T.TBool _val868 -> _val868; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterWithSnsIdResult _ = P.error "not a struct"
read_RegisterWithSnsIdResult :: T.Protocol p => p -> P.IO RegisterWithSnsIdResult
read_RegisterWithSnsIdResult iprot = to_RegisterWithSnsIdResult <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdResult)
decode_RegisterWithSnsIdResult :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsIdResult
decode_RegisterWithSnsIdResult iprot bs = to_RegisterWithSnsIdResult $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdResult) bs
typemap_RegisterWithSnsIdResult :: T.TypeMap
typemap_RegisterWithSnsIdResult = Map.fromList [(1,("authToken",T.T_STRING)),(2,("userCreated",T.T_BOOL))]
default_RegisterWithSnsIdResult :: RegisterWithSnsIdResult
default_RegisterWithSnsIdResult = RegisterWithSnsIdResult{
  registerWithSnsIdResult_authToken = "",
  registerWithSnsIdResult_userCreated = P.False}
data RequestTokenResponse = RequestTokenResponse  { requestTokenResponse_requestToken :: LT.Text
  , requestTokenResponse_returnUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestTokenResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestTokenResponse_requestToken record   `H.hashWithSalt` requestTokenResponse_returnUrl record  
instance QC.Arbitrary RequestTokenResponse where 
  arbitrary = M.liftM RequestTokenResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestTokenResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestTokenResponse{requestTokenResponse_requestToken = requestTokenResponse_requestToken obj} then P.Nothing else P.Just $ default_RequestTokenResponse{requestTokenResponse_requestToken = requestTokenResponse_requestToken obj}
    , if obj == default_RequestTokenResponse{requestTokenResponse_returnUrl = requestTokenResponse_returnUrl obj} then P.Nothing else P.Just $ default_RequestTokenResponse{requestTokenResponse_returnUrl = requestTokenResponse_returnUrl obj}
    ]
from_RequestTokenResponse :: RequestTokenResponse -> T.ThriftVal
from_RequestTokenResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v871 -> P.Just (1, ("requestToken",T.TString $ E.encodeUtf8 _v871))) $ requestTokenResponse_requestToken record
  , (\_v871 -> P.Just (2, ("returnUrl",T.TString $ E.encodeUtf8 _v871))) $ requestTokenResponse_returnUrl record
  ]
write_RequestTokenResponse :: T.Protocol p => p -> RequestTokenResponse -> P.IO ()
write_RequestTokenResponse oprot record = T.writeVal oprot $ from_RequestTokenResponse record
encode_RequestTokenResponse :: T.StatelessProtocol p => p -> RequestTokenResponse -> LBS.ByteString
encode_RequestTokenResponse oprot record = T.serializeVal oprot $ from_RequestTokenResponse record
to_RequestTokenResponse :: T.ThriftVal -> RequestTokenResponse
to_RequestTokenResponse (T.TStruct fields) = RequestTokenResponse{
  requestTokenResponse_requestToken = P.maybe (requestTokenResponse_requestToken default_RequestTokenResponse) (\(_,_val873) -> (case _val873 of {T.TString _val874 -> E.decodeUtf8 _val874; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  requestTokenResponse_returnUrl = P.maybe (requestTokenResponse_returnUrl default_RequestTokenResponse) (\(_,_val873) -> (case _val873 of {T.TString _val875 -> E.decodeUtf8 _val875; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RequestTokenResponse _ = P.error "not a struct"
read_RequestTokenResponse :: T.Protocol p => p -> P.IO RequestTokenResponse
read_RequestTokenResponse iprot = to_RequestTokenResponse <$> T.readVal iprot (T.T_STRUCT typemap_RequestTokenResponse)
decode_RequestTokenResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestTokenResponse
decode_RequestTokenResponse iprot bs = to_RequestTokenResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestTokenResponse) bs
typemap_RequestTokenResponse :: T.TypeMap
typemap_RequestTokenResponse = Map.fromList [(1,("requestToken",T.T_STRING)),(2,("returnUrl",T.T_STRING))]
default_RequestTokenResponse :: RequestTokenResponse
default_RequestTokenResponse = RequestTokenResponse{
  requestTokenResponse_requestToken = "",
  requestTokenResponse_returnUrl = ""}
data Room = Room  { room_mid :: LT.Text
  , room_createdTime :: I.Int64
  , room_contacts :: (Vector.Vector Contact)
  , room_notificationDisabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Room where
  hashWithSalt salt record = salt   `H.hashWithSalt` room_mid record   `H.hashWithSalt` room_createdTime record   `H.hashWithSalt` room_contacts record   `H.hashWithSalt` room_notificationDisabled record  
instance QC.Arbitrary Room where 
  arbitrary = M.liftM Room (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Room = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Room{room_mid = room_mid obj} then P.Nothing else P.Just $ default_Room{room_mid = room_mid obj}
    , if obj == default_Room{room_createdTime = room_createdTime obj} then P.Nothing else P.Just $ default_Room{room_createdTime = room_createdTime obj}
    , if obj == default_Room{room_contacts = room_contacts obj} then P.Nothing else P.Just $ default_Room{room_contacts = room_contacts obj}
    , if obj == default_Room{room_notificationDisabled = room_notificationDisabled obj} then P.Nothing else P.Just $ default_Room{room_notificationDisabled = room_notificationDisabled obj}
    ]
from_Room :: Room -> T.ThriftVal
from_Room record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v878 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v878))) $ room_mid record
  , (\_v878 -> P.Just (2, ("createdTime",T.TI64 _v878))) $ room_createdTime record
  , (\_v878 -> P.Just (10, ("contacts",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v880 -> from_Contact _v880) $ Vector.toList _v878))) $ room_contacts record
  , (\_v878 -> P.Just (31, ("notificationDisabled",T.TBool _v878))) $ room_notificationDisabled record
  ]
write_Room :: T.Protocol p => p -> Room -> P.IO ()
write_Room oprot record = T.writeVal oprot $ from_Room record
encode_Room :: T.StatelessProtocol p => p -> Room -> LBS.ByteString
encode_Room oprot record = T.serializeVal oprot $ from_Room record
to_Room :: T.ThriftVal -> Room
to_Room (T.TStruct fields) = Room{
  room_mid = P.maybe (room_mid default_Room) (\(_,_val882) -> (case _val882 of {T.TString _val883 -> E.decodeUtf8 _val883; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  room_createdTime = P.maybe (room_createdTime default_Room) (\(_,_val882) -> (case _val882 of {T.TI64 _val884 -> _val884; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  room_contacts = P.maybe (room_contacts default_Room) (\(_,_val882) -> (case _val882 of {T.TList _ _val885 -> (Vector.fromList $ P.map (\_v886 -> (case _v886 of {T.TStruct _val887 -> (to_Contact (T.TStruct _val887)); _ -> P.error "wrong type"})) _val885); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  room_notificationDisabled = P.maybe (room_notificationDisabled default_Room) (\(_,_val882) -> (case _val882 of {T.TBool _val888 -> _val888; _ -> P.error "wrong type"})) (Map.lookup (31) fields)
  }
to_Room _ = P.error "not a struct"
read_Room :: T.Protocol p => p -> P.IO Room
read_Room iprot = to_Room <$> T.readVal iprot (T.T_STRUCT typemap_Room)
decode_Room :: T.StatelessProtocol p => p -> LBS.ByteString -> Room
decode_Room iprot bs = to_Room $ T.deserializeVal iprot (T.T_STRUCT typemap_Room) bs
typemap_Room :: T.TypeMap
typemap_Room = Map.fromList [(1,("mid",T.T_STRING)),(2,("createdTime",T.T_I64)),(10,("contacts",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(31,("notificationDisabled",T.T_BOOL))]
default_Room :: Room
default_Room = Room{
  room_mid = "",
  room_createdTime = 0,
  room_contacts = Vector.empty,
  room_notificationDisabled = P.False}
data RSAKey = RSAKey  { rSAKey_keynm :: LT.Text
  , rSAKey_nvalue :: LT.Text
  , rSAKey_evalue :: LT.Text
  , rSAKey_sessionKey :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RSAKey where
  hashWithSalt salt record = salt   `H.hashWithSalt` rSAKey_keynm record   `H.hashWithSalt` rSAKey_nvalue record   `H.hashWithSalt` rSAKey_evalue record   `H.hashWithSalt` rSAKey_sessionKey record  
instance QC.Arbitrary RSAKey where 
  arbitrary = M.liftM RSAKey (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RSAKey = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RSAKey{rSAKey_keynm = rSAKey_keynm obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_keynm = rSAKey_keynm obj}
    , if obj == default_RSAKey{rSAKey_nvalue = rSAKey_nvalue obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_nvalue = rSAKey_nvalue obj}
    , if obj == default_RSAKey{rSAKey_evalue = rSAKey_evalue obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_evalue = rSAKey_evalue obj}
    , if obj == default_RSAKey{rSAKey_sessionKey = rSAKey_sessionKey obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_sessionKey = rSAKey_sessionKey obj}
    ]
from_RSAKey :: RSAKey -> T.ThriftVal
from_RSAKey record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v891 -> P.Just (1, ("keynm",T.TString $ E.encodeUtf8 _v891))) $ rSAKey_keynm record
  , (\_v891 -> P.Just (2, ("nvalue",T.TString $ E.encodeUtf8 _v891))) $ rSAKey_nvalue record
  , (\_v891 -> P.Just (3, ("evalue",T.TString $ E.encodeUtf8 _v891))) $ rSAKey_evalue record
  , (\_v891 -> P.Just (4, ("sessionKey",T.TString $ E.encodeUtf8 _v891))) $ rSAKey_sessionKey record
  ]
write_RSAKey :: T.Protocol p => p -> RSAKey -> P.IO ()
write_RSAKey oprot record = T.writeVal oprot $ from_RSAKey record
encode_RSAKey :: T.StatelessProtocol p => p -> RSAKey -> LBS.ByteString
encode_RSAKey oprot record = T.serializeVal oprot $ from_RSAKey record
to_RSAKey :: T.ThriftVal -> RSAKey
to_RSAKey (T.TStruct fields) = RSAKey{
  rSAKey_keynm = P.maybe (rSAKey_keynm default_RSAKey) (\(_,_val893) -> (case _val893 of {T.TString _val894 -> E.decodeUtf8 _val894; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rSAKey_nvalue = P.maybe (rSAKey_nvalue default_RSAKey) (\(_,_val893) -> (case _val893 of {T.TString _val895 -> E.decodeUtf8 _val895; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  rSAKey_evalue = P.maybe (rSAKey_evalue default_RSAKey) (\(_,_val893) -> (case _val893 of {T.TString _val896 -> E.decodeUtf8 _val896; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  rSAKey_sessionKey = P.maybe (rSAKey_sessionKey default_RSAKey) (\(_,_val893) -> (case _val893 of {T.TString _val897 -> E.decodeUtf8 _val897; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RSAKey _ = P.error "not a struct"
read_RSAKey :: T.Protocol p => p -> P.IO RSAKey
read_RSAKey iprot = to_RSAKey <$> T.readVal iprot (T.T_STRUCT typemap_RSAKey)
decode_RSAKey :: T.StatelessProtocol p => p -> LBS.ByteString -> RSAKey
decode_RSAKey iprot bs = to_RSAKey $ T.deserializeVal iprot (T.T_STRUCT typemap_RSAKey) bs
typemap_RSAKey :: T.TypeMap
typemap_RSAKey = Map.fromList [(1,("keynm",T.T_STRING)),(2,("nvalue",T.T_STRING)),(3,("evalue",T.T_STRING)),(4,("sessionKey",T.T_STRING))]
default_RSAKey :: RSAKey
default_RSAKey = RSAKey{
  rSAKey_keynm = "",
  rSAKey_nvalue = "",
  rSAKey_evalue = "",
  rSAKey_sessionKey = ""}
data SendBuddyMessageResult = SendBuddyMessageResult  { sendBuddyMessageResult_requestId :: LT.Text
  , sendBuddyMessageResult_state :: BuddyResultState
  , sendBuddyMessageResult_messageId :: LT.Text
  , sendBuddyMessageResult_eventNo :: I.Int32
  , sendBuddyMessageResult_receiverCount :: I.Int64
  , sendBuddyMessageResult_successCount :: I.Int64
  , sendBuddyMessageResult_failCount :: I.Int64
  , sendBuddyMessageResult_cancelCount :: I.Int64
  , sendBuddyMessageResult_blockCount :: I.Int64
  , sendBuddyMessageResult_unregisterCount :: I.Int64
  , sendBuddyMessageResult_timestamp :: I.Int64
  , sendBuddyMessageResult_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendBuddyMessageResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendBuddyMessageResult_requestId record   `H.hashWithSalt` sendBuddyMessageResult_state record   `H.hashWithSalt` sendBuddyMessageResult_messageId record   `H.hashWithSalt` sendBuddyMessageResult_eventNo record   `H.hashWithSalt` sendBuddyMessageResult_receiverCount record   `H.hashWithSalt` sendBuddyMessageResult_successCount record   `H.hashWithSalt` sendBuddyMessageResult_failCount record   `H.hashWithSalt` sendBuddyMessageResult_cancelCount record   `H.hashWithSalt` sendBuddyMessageResult_blockCount record   `H.hashWithSalt` sendBuddyMessageResult_unregisterCount record   `H.hashWithSalt` sendBuddyMessageResult_timestamp record   `H.hashWithSalt` sendBuddyMessageResult_message record  
instance QC.Arbitrary SendBuddyMessageResult where 
  arbitrary = M.liftM SendBuddyMessageResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendBuddyMessageResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_requestId = sendBuddyMessageResult_requestId obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_requestId = sendBuddyMessageResult_requestId obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_state = sendBuddyMessageResult_state obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_state = sendBuddyMessageResult_state obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_messageId = sendBuddyMessageResult_messageId obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_messageId = sendBuddyMessageResult_messageId obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_eventNo = sendBuddyMessageResult_eventNo obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_eventNo = sendBuddyMessageResult_eventNo obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_receiverCount = sendBuddyMessageResult_receiverCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_receiverCount = sendBuddyMessageResult_receiverCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_successCount = sendBuddyMessageResult_successCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_successCount = sendBuddyMessageResult_successCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_failCount = sendBuddyMessageResult_failCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_failCount = sendBuddyMessageResult_failCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_cancelCount = sendBuddyMessageResult_cancelCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_cancelCount = sendBuddyMessageResult_cancelCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_blockCount = sendBuddyMessageResult_blockCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_blockCount = sendBuddyMessageResult_blockCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_unregisterCount = sendBuddyMessageResult_unregisterCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_unregisterCount = sendBuddyMessageResult_unregisterCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_timestamp = sendBuddyMessageResult_timestamp obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_timestamp = sendBuddyMessageResult_timestamp obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_message = sendBuddyMessageResult_message obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_message = sendBuddyMessageResult_message obj}
    ]
from_SendBuddyMessageResult :: SendBuddyMessageResult -> T.ThriftVal
from_SendBuddyMessageResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v900 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v900))) $ sendBuddyMessageResult_requestId record
  , (\_v900 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v900))) $ sendBuddyMessageResult_state record
  , (\_v900 -> P.Just (3, ("messageId",T.TString $ E.encodeUtf8 _v900))) $ sendBuddyMessageResult_messageId record
  , (\_v900 -> P.Just (4, ("eventNo",T.TI32 _v900))) $ sendBuddyMessageResult_eventNo record
  , (\_v900 -> P.Just (11, ("receiverCount",T.TI64 _v900))) $ sendBuddyMessageResult_receiverCount record
  , (\_v900 -> P.Just (12, ("successCount",T.TI64 _v900))) $ sendBuddyMessageResult_successCount record
  , (\_v900 -> P.Just (13, ("failCount",T.TI64 _v900))) $ sendBuddyMessageResult_failCount record
  , (\_v900 -> P.Just (14, ("cancelCount",T.TI64 _v900))) $ sendBuddyMessageResult_cancelCount record
  , (\_v900 -> P.Just (15, ("blockCount",T.TI64 _v900))) $ sendBuddyMessageResult_blockCount record
  , (\_v900 -> P.Just (16, ("unregisterCount",T.TI64 _v900))) $ sendBuddyMessageResult_unregisterCount record
  , (\_v900 -> P.Just (21, ("timestamp",T.TI64 _v900))) $ sendBuddyMessageResult_timestamp record
  , (\_v900 -> P.Just (22, ("message",T.TString $ E.encodeUtf8 _v900))) $ sendBuddyMessageResult_message record
  ]
write_SendBuddyMessageResult :: T.Protocol p => p -> SendBuddyMessageResult -> P.IO ()
write_SendBuddyMessageResult oprot record = T.writeVal oprot $ from_SendBuddyMessageResult record
encode_SendBuddyMessageResult :: T.StatelessProtocol p => p -> SendBuddyMessageResult -> LBS.ByteString
encode_SendBuddyMessageResult oprot record = T.serializeVal oprot $ from_SendBuddyMessageResult record
to_SendBuddyMessageResult :: T.ThriftVal -> SendBuddyMessageResult
to_SendBuddyMessageResult (T.TStruct fields) = SendBuddyMessageResult{
  sendBuddyMessageResult_requestId = P.maybe (sendBuddyMessageResult_requestId default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TString _val903 -> E.decodeUtf8 _val903; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendBuddyMessageResult_state = P.maybe (sendBuddyMessageResult_state default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI32 _val904 -> P.toEnum $ P.fromIntegral _val904; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendBuddyMessageResult_messageId = P.maybe (sendBuddyMessageResult_messageId default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TString _val905 -> E.decodeUtf8 _val905; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  sendBuddyMessageResult_eventNo = P.maybe (sendBuddyMessageResult_eventNo default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI32 _val906 -> _val906; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sendBuddyMessageResult_receiverCount = P.maybe (sendBuddyMessageResult_receiverCount default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI64 _val907 -> _val907; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  sendBuddyMessageResult_successCount = P.maybe (sendBuddyMessageResult_successCount default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI64 _val908 -> _val908; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  sendBuddyMessageResult_failCount = P.maybe (sendBuddyMessageResult_failCount default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI64 _val909 -> _val909; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  sendBuddyMessageResult_cancelCount = P.maybe (sendBuddyMessageResult_cancelCount default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI64 _val910 -> _val910; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  sendBuddyMessageResult_blockCount = P.maybe (sendBuddyMessageResult_blockCount default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI64 _val911 -> _val911; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  sendBuddyMessageResult_unregisterCount = P.maybe (sendBuddyMessageResult_unregisterCount default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI64 _val912 -> _val912; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  sendBuddyMessageResult_timestamp = P.maybe (sendBuddyMessageResult_timestamp default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TI64 _val913 -> _val913; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  sendBuddyMessageResult_message = P.maybe (sendBuddyMessageResult_message default_SendBuddyMessageResult) (\(_,_val902) -> (case _val902 of {T.TString _val914 -> E.decodeUtf8 _val914; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_SendBuddyMessageResult _ = P.error "not a struct"
read_SendBuddyMessageResult :: T.Protocol p => p -> P.IO SendBuddyMessageResult
read_SendBuddyMessageResult iprot = to_SendBuddyMessageResult <$> T.readVal iprot (T.T_STRUCT typemap_SendBuddyMessageResult)
decode_SendBuddyMessageResult :: T.StatelessProtocol p => p -> LBS.ByteString -> SendBuddyMessageResult
decode_SendBuddyMessageResult iprot bs = to_SendBuddyMessageResult $ T.deserializeVal iprot (T.T_STRUCT typemap_SendBuddyMessageResult) bs
typemap_SendBuddyMessageResult :: T.TypeMap
typemap_SendBuddyMessageResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("state",T.T_I32)),(3,("messageId",T.T_STRING)),(4,("eventNo",T.T_I32)),(11,("receiverCount",T.T_I64)),(12,("successCount",T.T_I64)),(13,("failCount",T.T_I64)),(14,("cancelCount",T.T_I64)),(15,("blockCount",T.T_I64)),(16,("unregisterCount",T.T_I64)),(21,("timestamp",T.T_I64)),(22,("message",T.T_STRING))]
default_SendBuddyMessageResult :: SendBuddyMessageResult
default_SendBuddyMessageResult = SendBuddyMessageResult{
  sendBuddyMessageResult_requestId = "",
  sendBuddyMessageResult_state = (P.toEnum 0),
  sendBuddyMessageResult_messageId = "",
  sendBuddyMessageResult_eventNo = 0,
  sendBuddyMessageResult_receiverCount = 0,
  sendBuddyMessageResult_successCount = 0,
  sendBuddyMessageResult_failCount = 0,
  sendBuddyMessageResult_cancelCount = 0,
  sendBuddyMessageResult_blockCount = 0,
  sendBuddyMessageResult_unregisterCount = 0,
  sendBuddyMessageResult_timestamp = 0,
  sendBuddyMessageResult_message = ""}
data SetBuddyOnAirResult = SetBuddyOnAirResult  { setBuddyOnAirResult_requestId :: LT.Text
  , setBuddyOnAirResult_state :: BuddyResultState
  , setBuddyOnAirResult_eventNo :: I.Int32
  , setBuddyOnAirResult_receiverCount :: I.Int64
  , setBuddyOnAirResult_successCount :: I.Int64
  , setBuddyOnAirResult_failCount :: I.Int64
  , setBuddyOnAirResult_cancelCount :: I.Int64
  , setBuddyOnAirResult_unregisterCount :: I.Int64
  , setBuddyOnAirResult_timestamp :: I.Int64
  , setBuddyOnAirResult_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetBuddyOnAirResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` setBuddyOnAirResult_requestId record   `H.hashWithSalt` setBuddyOnAirResult_state record   `H.hashWithSalt` setBuddyOnAirResult_eventNo record   `H.hashWithSalt` setBuddyOnAirResult_receiverCount record   `H.hashWithSalt` setBuddyOnAirResult_successCount record   `H.hashWithSalt` setBuddyOnAirResult_failCount record   `H.hashWithSalt` setBuddyOnAirResult_cancelCount record   `H.hashWithSalt` setBuddyOnAirResult_unregisterCount record   `H.hashWithSalt` setBuddyOnAirResult_timestamp record   `H.hashWithSalt` setBuddyOnAirResult_message record  
instance QC.Arbitrary SetBuddyOnAirResult where 
  arbitrary = M.liftM SetBuddyOnAirResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetBuddyOnAirResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_requestId = setBuddyOnAirResult_requestId obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_requestId = setBuddyOnAirResult_requestId obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_state = setBuddyOnAirResult_state obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_state = setBuddyOnAirResult_state obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_eventNo = setBuddyOnAirResult_eventNo obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_eventNo = setBuddyOnAirResult_eventNo obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_receiverCount = setBuddyOnAirResult_receiverCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_receiverCount = setBuddyOnAirResult_receiverCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_successCount = setBuddyOnAirResult_successCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_successCount = setBuddyOnAirResult_successCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_failCount = setBuddyOnAirResult_failCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_failCount = setBuddyOnAirResult_failCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_cancelCount = setBuddyOnAirResult_cancelCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_cancelCount = setBuddyOnAirResult_cancelCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_unregisterCount = setBuddyOnAirResult_unregisterCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_unregisterCount = setBuddyOnAirResult_unregisterCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_timestamp = setBuddyOnAirResult_timestamp obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_timestamp = setBuddyOnAirResult_timestamp obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_message = setBuddyOnAirResult_message obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_message = setBuddyOnAirResult_message obj}
    ]
from_SetBuddyOnAirResult :: SetBuddyOnAirResult -> T.ThriftVal
from_SetBuddyOnAirResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v917 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v917))) $ setBuddyOnAirResult_requestId record
  , (\_v917 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v917))) $ setBuddyOnAirResult_state record
  , (\_v917 -> P.Just (3, ("eventNo",T.TI32 _v917))) $ setBuddyOnAirResult_eventNo record
  , (\_v917 -> P.Just (11, ("receiverCount",T.TI64 _v917))) $ setBuddyOnAirResult_receiverCount record
  , (\_v917 -> P.Just (12, ("successCount",T.TI64 _v917))) $ setBuddyOnAirResult_successCount record
  , (\_v917 -> P.Just (13, ("failCount",T.TI64 _v917))) $ setBuddyOnAirResult_failCount record
  , (\_v917 -> P.Just (14, ("cancelCount",T.TI64 _v917))) $ setBuddyOnAirResult_cancelCount record
  , (\_v917 -> P.Just (15, ("unregisterCount",T.TI64 _v917))) $ setBuddyOnAirResult_unregisterCount record
  , (\_v917 -> P.Just (21, ("timestamp",T.TI64 _v917))) $ setBuddyOnAirResult_timestamp record
  , (\_v917 -> P.Just (22, ("message",T.TString $ E.encodeUtf8 _v917))) $ setBuddyOnAirResult_message record
  ]
write_SetBuddyOnAirResult :: T.Protocol p => p -> SetBuddyOnAirResult -> P.IO ()
write_SetBuddyOnAirResult oprot record = T.writeVal oprot $ from_SetBuddyOnAirResult record
encode_SetBuddyOnAirResult :: T.StatelessProtocol p => p -> SetBuddyOnAirResult -> LBS.ByteString
encode_SetBuddyOnAirResult oprot record = T.serializeVal oprot $ from_SetBuddyOnAirResult record
to_SetBuddyOnAirResult :: T.ThriftVal -> SetBuddyOnAirResult
to_SetBuddyOnAirResult (T.TStruct fields) = SetBuddyOnAirResult{
  setBuddyOnAirResult_requestId = P.maybe (setBuddyOnAirResult_requestId default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TString _val920 -> E.decodeUtf8 _val920; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setBuddyOnAirResult_state = P.maybe (setBuddyOnAirResult_state default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI32 _val921 -> P.toEnum $ P.fromIntegral _val921; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setBuddyOnAirResult_eventNo = P.maybe (setBuddyOnAirResult_eventNo default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI32 _val922 -> _val922; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setBuddyOnAirResult_receiverCount = P.maybe (setBuddyOnAirResult_receiverCount default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI64 _val923 -> _val923; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  setBuddyOnAirResult_successCount = P.maybe (setBuddyOnAirResult_successCount default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI64 _val924 -> _val924; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  setBuddyOnAirResult_failCount = P.maybe (setBuddyOnAirResult_failCount default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI64 _val925 -> _val925; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  setBuddyOnAirResult_cancelCount = P.maybe (setBuddyOnAirResult_cancelCount default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI64 _val926 -> _val926; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  setBuddyOnAirResult_unregisterCount = P.maybe (setBuddyOnAirResult_unregisterCount default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI64 _val927 -> _val927; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  setBuddyOnAirResult_timestamp = P.maybe (setBuddyOnAirResult_timestamp default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TI64 _val928 -> _val928; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  setBuddyOnAirResult_message = P.maybe (setBuddyOnAirResult_message default_SetBuddyOnAirResult) (\(_,_val919) -> (case _val919 of {T.TString _val929 -> E.decodeUtf8 _val929; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_SetBuddyOnAirResult _ = P.error "not a struct"
read_SetBuddyOnAirResult :: T.Protocol p => p -> P.IO SetBuddyOnAirResult
read_SetBuddyOnAirResult iprot = to_SetBuddyOnAirResult <$> T.readVal iprot (T.T_STRUCT typemap_SetBuddyOnAirResult)
decode_SetBuddyOnAirResult :: T.StatelessProtocol p => p -> LBS.ByteString -> SetBuddyOnAirResult
decode_SetBuddyOnAirResult iprot bs = to_SetBuddyOnAirResult $ T.deserializeVal iprot (T.T_STRUCT typemap_SetBuddyOnAirResult) bs
typemap_SetBuddyOnAirResult :: T.TypeMap
typemap_SetBuddyOnAirResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("state",T.T_I32)),(3,("eventNo",T.T_I32)),(11,("receiverCount",T.T_I64)),(12,("successCount",T.T_I64)),(13,("failCount",T.T_I64)),(14,("cancelCount",T.T_I64)),(15,("unregisterCount",T.T_I64)),(21,("timestamp",T.T_I64)),(22,("message",T.T_STRING))]
default_SetBuddyOnAirResult :: SetBuddyOnAirResult
default_SetBuddyOnAirResult = SetBuddyOnAirResult{
  setBuddyOnAirResult_requestId = "",
  setBuddyOnAirResult_state = (P.toEnum 0),
  setBuddyOnAirResult_eventNo = 0,
  setBuddyOnAirResult_receiverCount = 0,
  setBuddyOnAirResult_successCount = 0,
  setBuddyOnAirResult_failCount = 0,
  setBuddyOnAirResult_cancelCount = 0,
  setBuddyOnAirResult_unregisterCount = 0,
  setBuddyOnAirResult_timestamp = 0,
  setBuddyOnAirResult_message = ""}
data Settings = Settings  { settings_notificationEnable :: P.Bool
  , settings_notificationMuteExpiration :: I.Int64
  , settings_notificationNewMessage :: P.Bool
  , settings_notificationGroupInvitation :: P.Bool
  , settings_notificationShowMessage :: P.Bool
  , settings_notificationIncomingCall :: P.Bool
  , settings_notificationSoundMessage :: LT.Text
  , settings_notificationSoundGroup :: LT.Text
  , settings_notificationDisabledWithSub :: P.Bool
  , settings_privacySyncContacts :: P.Bool
  , settings_privacySearchByPhoneNumber :: P.Bool
  , settings_privacySearchByUserid :: P.Bool
  , settings_privacySearchByEmail :: P.Bool
  , settings_privacyAllowSecondaryDeviceLogin :: P.Bool
  , settings_privacyProfileImagePostToMyhome :: P.Bool
  , settings_privacyReceiveMessagesFromNotFriend :: P.Bool
  , settings_contactMyTicket :: LT.Text
  , settings_identityProvider :: IdentityProvider
  , settings_identityIdentifier :: LT.Text
  , settings_snsAccounts :: (Map.HashMap SnsIdType LT.Text)
  , settings_phoneRegistration :: P.Bool
  , settings_emailConfirmationStatus :: EmailConfirmationStatus
  , settings_preferenceLocale :: LT.Text
  , settings_customModes :: (Map.HashMap CustomMode LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Settings where
  hashWithSalt salt record = salt   `H.hashWithSalt` settings_notificationEnable record   `H.hashWithSalt` settings_notificationMuteExpiration record   `H.hashWithSalt` settings_notificationNewMessage record   `H.hashWithSalt` settings_notificationGroupInvitation record   `H.hashWithSalt` settings_notificationShowMessage record   `H.hashWithSalt` settings_notificationIncomingCall record   `H.hashWithSalt` settings_notificationSoundMessage record   `H.hashWithSalt` settings_notificationSoundGroup record   `H.hashWithSalt` settings_notificationDisabledWithSub record   `H.hashWithSalt` settings_privacySyncContacts record   `H.hashWithSalt` settings_privacySearchByPhoneNumber record   `H.hashWithSalt` settings_privacySearchByUserid record   `H.hashWithSalt` settings_privacySearchByEmail record   `H.hashWithSalt` settings_privacyAllowSecondaryDeviceLogin record   `H.hashWithSalt` settings_privacyProfileImagePostToMyhome record   `H.hashWithSalt` settings_privacyReceiveMessagesFromNotFriend record   `H.hashWithSalt` settings_contactMyTicket record   `H.hashWithSalt` settings_identityProvider record   `H.hashWithSalt` settings_identityIdentifier record   `H.hashWithSalt` settings_snsAccounts record   `H.hashWithSalt` settings_phoneRegistration record   `H.hashWithSalt` settings_emailConfirmationStatus record   `H.hashWithSalt` settings_preferenceLocale record   `H.hashWithSalt` settings_customModes record  
instance QC.Arbitrary Settings where 
  arbitrary = M.liftM Settings (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Settings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Settings{settings_notificationEnable = settings_notificationEnable obj} then P.Nothing else P.Just $ default_Settings{settings_notificationEnable = settings_notificationEnable obj}
    , if obj == default_Settings{settings_notificationMuteExpiration = settings_notificationMuteExpiration obj} then P.Nothing else P.Just $ default_Settings{settings_notificationMuteExpiration = settings_notificationMuteExpiration obj}
    , if obj == default_Settings{settings_notificationNewMessage = settings_notificationNewMessage obj} then P.Nothing else P.Just $ default_Settings{settings_notificationNewMessage = settings_notificationNewMessage obj}
    , if obj == default_Settings{settings_notificationGroupInvitation = settings_notificationGroupInvitation obj} then P.Nothing else P.Just $ default_Settings{settings_notificationGroupInvitation = settings_notificationGroupInvitation obj}
    , if obj == default_Settings{settings_notificationShowMessage = settings_notificationShowMessage obj} then P.Nothing else P.Just $ default_Settings{settings_notificationShowMessage = settings_notificationShowMessage obj}
    , if obj == default_Settings{settings_notificationIncomingCall = settings_notificationIncomingCall obj} then P.Nothing else P.Just $ default_Settings{settings_notificationIncomingCall = settings_notificationIncomingCall obj}
    , if obj == default_Settings{settings_notificationSoundMessage = settings_notificationSoundMessage obj} then P.Nothing else P.Just $ default_Settings{settings_notificationSoundMessage = settings_notificationSoundMessage obj}
    , if obj == default_Settings{settings_notificationSoundGroup = settings_notificationSoundGroup obj} then P.Nothing else P.Just $ default_Settings{settings_notificationSoundGroup = settings_notificationSoundGroup obj}
    , if obj == default_Settings{settings_notificationDisabledWithSub = settings_notificationDisabledWithSub obj} then P.Nothing else P.Just $ default_Settings{settings_notificationDisabledWithSub = settings_notificationDisabledWithSub obj}
    , if obj == default_Settings{settings_privacySyncContacts = settings_privacySyncContacts obj} then P.Nothing else P.Just $ default_Settings{settings_privacySyncContacts = settings_privacySyncContacts obj}
    , if obj == default_Settings{settings_privacySearchByPhoneNumber = settings_privacySearchByPhoneNumber obj} then P.Nothing else P.Just $ default_Settings{settings_privacySearchByPhoneNumber = settings_privacySearchByPhoneNumber obj}
    , if obj == default_Settings{settings_privacySearchByUserid = settings_privacySearchByUserid obj} then P.Nothing else P.Just $ default_Settings{settings_privacySearchByUserid = settings_privacySearchByUserid obj}
    , if obj == default_Settings{settings_privacySearchByEmail = settings_privacySearchByEmail obj} then P.Nothing else P.Just $ default_Settings{settings_privacySearchByEmail = settings_privacySearchByEmail obj}
    , if obj == default_Settings{settings_privacyAllowSecondaryDeviceLogin = settings_privacyAllowSecondaryDeviceLogin obj} then P.Nothing else P.Just $ default_Settings{settings_privacyAllowSecondaryDeviceLogin = settings_privacyAllowSecondaryDeviceLogin obj}
    , if obj == default_Settings{settings_privacyProfileImagePostToMyhome = settings_privacyProfileImagePostToMyhome obj} then P.Nothing else P.Just $ default_Settings{settings_privacyProfileImagePostToMyhome = settings_privacyProfileImagePostToMyhome obj}
    , if obj == default_Settings{settings_privacyReceiveMessagesFromNotFriend = settings_privacyReceiveMessagesFromNotFriend obj} then P.Nothing else P.Just $ default_Settings{settings_privacyReceiveMessagesFromNotFriend = settings_privacyReceiveMessagesFromNotFriend obj}
    , if obj == default_Settings{settings_contactMyTicket = settings_contactMyTicket obj} then P.Nothing else P.Just $ default_Settings{settings_contactMyTicket = settings_contactMyTicket obj}
    , if obj == default_Settings{settings_identityProvider = settings_identityProvider obj} then P.Nothing else P.Just $ default_Settings{settings_identityProvider = settings_identityProvider obj}
    , if obj == default_Settings{settings_identityIdentifier = settings_identityIdentifier obj} then P.Nothing else P.Just $ default_Settings{settings_identityIdentifier = settings_identityIdentifier obj}
    , if obj == default_Settings{settings_snsAccounts = settings_snsAccounts obj} then P.Nothing else P.Just $ default_Settings{settings_snsAccounts = settings_snsAccounts obj}
    , if obj == default_Settings{settings_phoneRegistration = settings_phoneRegistration obj} then P.Nothing else P.Just $ default_Settings{settings_phoneRegistration = settings_phoneRegistration obj}
    , if obj == default_Settings{settings_emailConfirmationStatus = settings_emailConfirmationStatus obj} then P.Nothing else P.Just $ default_Settings{settings_emailConfirmationStatus = settings_emailConfirmationStatus obj}
    , if obj == default_Settings{settings_preferenceLocale = settings_preferenceLocale obj} then P.Nothing else P.Just $ default_Settings{settings_preferenceLocale = settings_preferenceLocale obj}
    , if obj == default_Settings{settings_customModes = settings_customModes obj} then P.Nothing else P.Just $ default_Settings{settings_customModes = settings_customModes obj}
    ]
from_Settings :: Settings -> T.ThriftVal
from_Settings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v932 -> P.Just (10, ("notificationEnable",T.TBool _v932))) $ settings_notificationEnable record
  , (\_v932 -> P.Just (11, ("notificationMuteExpiration",T.TI64 _v932))) $ settings_notificationMuteExpiration record
  , (\_v932 -> P.Just (12, ("notificationNewMessage",T.TBool _v932))) $ settings_notificationNewMessage record
  , (\_v932 -> P.Just (13, ("notificationGroupInvitation",T.TBool _v932))) $ settings_notificationGroupInvitation record
  , (\_v932 -> P.Just (14, ("notificationShowMessage",T.TBool _v932))) $ settings_notificationShowMessage record
  , (\_v932 -> P.Just (15, ("notificationIncomingCall",T.TBool _v932))) $ settings_notificationIncomingCall record
  , (\_v932 -> P.Just (16, ("notificationSoundMessage",T.TString $ E.encodeUtf8 _v932))) $ settings_notificationSoundMessage record
  , (\_v932 -> P.Just (17, ("notificationSoundGroup",T.TString $ E.encodeUtf8 _v932))) $ settings_notificationSoundGroup record
  , (\_v932 -> P.Just (18, ("notificationDisabledWithSub",T.TBool _v932))) $ settings_notificationDisabledWithSub record
  , (\_v932 -> P.Just (20, ("privacySyncContacts",T.TBool _v932))) $ settings_privacySyncContacts record
  , (\_v932 -> P.Just (21, ("privacySearchByPhoneNumber",T.TBool _v932))) $ settings_privacySearchByPhoneNumber record
  , (\_v932 -> P.Just (22, ("privacySearchByUserid",T.TBool _v932))) $ settings_privacySearchByUserid record
  , (\_v932 -> P.Just (23, ("privacySearchByEmail",T.TBool _v932))) $ settings_privacySearchByEmail record
  , (\_v932 -> P.Just (24, ("privacyAllowSecondaryDeviceLogin",T.TBool _v932))) $ settings_privacyAllowSecondaryDeviceLogin record
  , (\_v932 -> P.Just (25, ("privacyProfileImagePostToMyhome",T.TBool _v932))) $ settings_privacyProfileImagePostToMyhome record
  , (\_v932 -> P.Just (26, ("privacyReceiveMessagesFromNotFriend",T.TBool _v932))) $ settings_privacyReceiveMessagesFromNotFriend record
  , (\_v932 -> P.Just (30, ("contactMyTicket",T.TString $ E.encodeUtf8 _v932))) $ settings_contactMyTicket record
  , (\_v932 -> P.Just (40, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v932))) $ settings_identityProvider record
  , (\_v932 -> P.Just (41, ("identityIdentifier",T.TString $ E.encodeUtf8 _v932))) $ settings_identityIdentifier record
  , (\_v932 -> P.Just (42, ("snsAccounts",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k933,_v934) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k933, T.TString $ E.encodeUtf8 _v934)) $ Map.toList _v932))) $ settings_snsAccounts record
  , (\_v932 -> P.Just (43, ("phoneRegistration",T.TBool _v932))) $ settings_phoneRegistration record
  , (\_v932 -> P.Just (44, ("emailConfirmationStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v932))) $ settings_emailConfirmationStatus record
  , (\_v932 -> P.Just (50, ("preferenceLocale",T.TString $ E.encodeUtf8 _v932))) $ settings_preferenceLocale record
  , (\_v932 -> P.Just (60, ("customModes",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k935,_v936) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k935, T.TString $ E.encodeUtf8 _v936)) $ Map.toList _v932))) $ settings_customModes record
  ]
write_Settings :: T.Protocol p => p -> Settings -> P.IO ()
write_Settings oprot record = T.writeVal oprot $ from_Settings record
encode_Settings :: T.StatelessProtocol p => p -> Settings -> LBS.ByteString
encode_Settings oprot record = T.serializeVal oprot $ from_Settings record
to_Settings :: T.ThriftVal -> Settings
to_Settings (T.TStruct fields) = Settings{
  settings_notificationEnable = P.maybe (settings_notificationEnable default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val939 -> _val939; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  settings_notificationMuteExpiration = P.maybe (settings_notificationMuteExpiration default_Settings) (\(_,_val938) -> (case _val938 of {T.TI64 _val940 -> _val940; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  settings_notificationNewMessage = P.maybe (settings_notificationNewMessage default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val941 -> _val941; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  settings_notificationGroupInvitation = P.maybe (settings_notificationGroupInvitation default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val942 -> _val942; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  settings_notificationShowMessage = P.maybe (settings_notificationShowMessage default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val943 -> _val943; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  settings_notificationIncomingCall = P.maybe (settings_notificationIncomingCall default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val944 -> _val944; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  settings_notificationSoundMessage = P.maybe (settings_notificationSoundMessage default_Settings) (\(_,_val938) -> (case _val938 of {T.TString _val945 -> E.decodeUtf8 _val945; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  settings_notificationSoundGroup = P.maybe (settings_notificationSoundGroup default_Settings) (\(_,_val938) -> (case _val938 of {T.TString _val946 -> E.decodeUtf8 _val946; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  settings_notificationDisabledWithSub = P.maybe (settings_notificationDisabledWithSub default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val947 -> _val947; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  settings_privacySyncContacts = P.maybe (settings_privacySyncContacts default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val948 -> _val948; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  settings_privacySearchByPhoneNumber = P.maybe (settings_privacySearchByPhoneNumber default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val949 -> _val949; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  settings_privacySearchByUserid = P.maybe (settings_privacySearchByUserid default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val950 -> _val950; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  settings_privacySearchByEmail = P.maybe (settings_privacySearchByEmail default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val951 -> _val951; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  settings_privacyAllowSecondaryDeviceLogin = P.maybe (settings_privacyAllowSecondaryDeviceLogin default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val952 -> _val952; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  settings_privacyProfileImagePostToMyhome = P.maybe (settings_privacyProfileImagePostToMyhome default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val953 -> _val953; _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  settings_privacyReceiveMessagesFromNotFriend = P.maybe (settings_privacyReceiveMessagesFromNotFriend default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val954 -> _val954; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  settings_contactMyTicket = P.maybe (settings_contactMyTicket default_Settings) (\(_,_val938) -> (case _val938 of {T.TString _val955 -> E.decodeUtf8 _val955; _ -> P.error "wrong type"})) (Map.lookup (30) fields),
  settings_identityProvider = P.maybe (settings_identityProvider default_Settings) (\(_,_val938) -> (case _val938 of {T.TI32 _val956 -> P.toEnum $ P.fromIntegral _val956; _ -> P.error "wrong type"})) (Map.lookup (40) fields),
  settings_identityIdentifier = P.maybe (settings_identityIdentifier default_Settings) (\(_,_val938) -> (case _val938 of {T.TString _val957 -> E.decodeUtf8 _val957; _ -> P.error "wrong type"})) (Map.lookup (41) fields),
  settings_snsAccounts = P.maybe (settings_snsAccounts default_Settings) (\(_,_val938) -> (case _val938 of {T.TMap _ _ _val958 -> (Map.fromList $ P.map (\(_k960,_v959) -> ((case _k960 of {T.TI32 _val961 -> P.toEnum $ P.fromIntegral _val961; _ -> P.error "wrong type"}),(case _v959 of {T.TString _val962 -> E.decodeUtf8 _val962; _ -> P.error "wrong type"}))) _val958); _ -> P.error "wrong type"})) (Map.lookup (42) fields),
  settings_phoneRegistration = P.maybe (settings_phoneRegistration default_Settings) (\(_,_val938) -> (case _val938 of {T.TBool _val963 -> _val963; _ -> P.error "wrong type"})) (Map.lookup (43) fields),
  settings_emailConfirmationStatus = P.maybe (settings_emailConfirmationStatus default_Settings) (\(_,_val938) -> (case _val938 of {T.TI32 _val964 -> P.toEnum $ P.fromIntegral _val964; _ -> P.error "wrong type"})) (Map.lookup (44) fields),
  settings_preferenceLocale = P.maybe (settings_preferenceLocale default_Settings) (\(_,_val938) -> (case _val938 of {T.TString _val965 -> E.decodeUtf8 _val965; _ -> P.error "wrong type"})) (Map.lookup (50) fields),
  settings_customModes = P.maybe (settings_customModes default_Settings) (\(_,_val938) -> (case _val938 of {T.TMap _ _ _val966 -> (Map.fromList $ P.map (\(_k968,_v967) -> ((case _k968 of {T.TI32 _val969 -> P.toEnum $ P.fromIntegral _val969; _ -> P.error "wrong type"}),(case _v967 of {T.TString _val970 -> E.decodeUtf8 _val970; _ -> P.error "wrong type"}))) _val966); _ -> P.error "wrong type"})) (Map.lookup (60) fields)
  }
to_Settings _ = P.error "not a struct"
read_Settings :: T.Protocol p => p -> P.IO Settings
read_Settings iprot = to_Settings <$> T.readVal iprot (T.T_STRUCT typemap_Settings)
decode_Settings :: T.StatelessProtocol p => p -> LBS.ByteString -> Settings
decode_Settings iprot bs = to_Settings $ T.deserializeVal iprot (T.T_STRUCT typemap_Settings) bs
typemap_Settings :: T.TypeMap
typemap_Settings = Map.fromList [(10,("notificationEnable",T.T_BOOL)),(11,("notificationMuteExpiration",T.T_I64)),(12,("notificationNewMessage",T.T_BOOL)),(13,("notificationGroupInvitation",T.T_BOOL)),(14,("notificationShowMessage",T.T_BOOL)),(15,("notificationIncomingCall",T.T_BOOL)),(16,("notificationSoundMessage",T.T_STRING)),(17,("notificationSoundGroup",T.T_STRING)),(18,("notificationDisabledWithSub",T.T_BOOL)),(20,("privacySyncContacts",T.T_BOOL)),(21,("privacySearchByPhoneNumber",T.T_BOOL)),(22,("privacySearchByUserid",T.T_BOOL)),(23,("privacySearchByEmail",T.T_BOOL)),(24,("privacyAllowSecondaryDeviceLogin",T.T_BOOL)),(25,("privacyProfileImagePostToMyhome",T.T_BOOL)),(26,("privacyReceiveMessagesFromNotFriend",T.T_BOOL)),(30,("contactMyTicket",T.T_STRING)),(40,("identityProvider",T.T_I32)),(41,("identityIdentifier",T.T_STRING)),(42,("snsAccounts",(T.T_MAP T.T_I32 T.T_STRING))),(43,("phoneRegistration",T.T_BOOL)),(44,("emailConfirmationStatus",T.T_I32)),(50,("preferenceLocale",T.T_STRING)),(60,("customModes",(T.T_MAP T.T_I32 T.T_STRING)))]
default_Settings :: Settings
default_Settings = Settings{
  settings_notificationEnable = P.False,
  settings_notificationMuteExpiration = 0,
  settings_notificationNewMessage = P.False,
  settings_notificationGroupInvitation = P.False,
  settings_notificationShowMessage = P.False,
  settings_notificationIncomingCall = P.False,
  settings_notificationSoundMessage = "",
  settings_notificationSoundGroup = "",
  settings_notificationDisabledWithSub = P.False,
  settings_privacySyncContacts = P.False,
  settings_privacySearchByPhoneNumber = P.False,
  settings_privacySearchByUserid = P.False,
  settings_privacySearchByEmail = P.False,
  settings_privacyAllowSecondaryDeviceLogin = P.False,
  settings_privacyProfileImagePostToMyhome = P.False,
  settings_privacyReceiveMessagesFromNotFriend = P.False,
  settings_contactMyTicket = "",
  settings_identityProvider = (P.toEnum 0),
  settings_identityIdentifier = "",
  settings_snsAccounts = Map.empty,
  settings_phoneRegistration = P.False,
  settings_emailConfirmationStatus = (P.toEnum 0),
  settings_preferenceLocale = "",
  settings_customModes = Map.empty}
data SimpleChannelClient = SimpleChannelClient  { simpleChannelClient_applicationType :: LT.Text
  , simpleChannelClient_applicationVersion :: LT.Text
  , simpleChannelClient_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SimpleChannelClient where
  hashWithSalt salt record = salt   `H.hashWithSalt` simpleChannelClient_applicationType record   `H.hashWithSalt` simpleChannelClient_applicationVersion record   `H.hashWithSalt` simpleChannelClient_locale record  
instance QC.Arbitrary SimpleChannelClient where 
  arbitrary = M.liftM SimpleChannelClient (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SimpleChannelClient = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SimpleChannelClient{simpleChannelClient_applicationType = simpleChannelClient_applicationType obj} then P.Nothing else P.Just $ default_SimpleChannelClient{simpleChannelClient_applicationType = simpleChannelClient_applicationType obj}
    , if obj == default_SimpleChannelClient{simpleChannelClient_applicationVersion = simpleChannelClient_applicationVersion obj} then P.Nothing else P.Just $ default_SimpleChannelClient{simpleChannelClient_applicationVersion = simpleChannelClient_applicationVersion obj}
    , if obj == default_SimpleChannelClient{simpleChannelClient_locale = simpleChannelClient_locale obj} then P.Nothing else P.Just $ default_SimpleChannelClient{simpleChannelClient_locale = simpleChannelClient_locale obj}
    ]
from_SimpleChannelClient :: SimpleChannelClient -> T.ThriftVal
from_SimpleChannelClient record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v973 -> P.Just (1, ("applicationType",T.TString $ E.encodeUtf8 _v973))) $ simpleChannelClient_applicationType record
  , (\_v973 -> P.Just (2, ("applicationVersion",T.TString $ E.encodeUtf8 _v973))) $ simpleChannelClient_applicationVersion record
  , (\_v973 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v973))) $ simpleChannelClient_locale record
  ]
write_SimpleChannelClient :: T.Protocol p => p -> SimpleChannelClient -> P.IO ()
write_SimpleChannelClient oprot record = T.writeVal oprot $ from_SimpleChannelClient record
encode_SimpleChannelClient :: T.StatelessProtocol p => p -> SimpleChannelClient -> LBS.ByteString
encode_SimpleChannelClient oprot record = T.serializeVal oprot $ from_SimpleChannelClient record
to_SimpleChannelClient :: T.ThriftVal -> SimpleChannelClient
to_SimpleChannelClient (T.TStruct fields) = SimpleChannelClient{
  simpleChannelClient_applicationType = P.maybe (simpleChannelClient_applicationType default_SimpleChannelClient) (\(_,_val975) -> (case _val975 of {T.TString _val976 -> E.decodeUtf8 _val976; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  simpleChannelClient_applicationVersion = P.maybe (simpleChannelClient_applicationVersion default_SimpleChannelClient) (\(_,_val975) -> (case _val975 of {T.TString _val977 -> E.decodeUtf8 _val977; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  simpleChannelClient_locale = P.maybe (simpleChannelClient_locale default_SimpleChannelClient) (\(_,_val975) -> (case _val975 of {T.TString _val978 -> E.decodeUtf8 _val978; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SimpleChannelClient _ = P.error "not a struct"
read_SimpleChannelClient :: T.Protocol p => p -> P.IO SimpleChannelClient
read_SimpleChannelClient iprot = to_SimpleChannelClient <$> T.readVal iprot (T.T_STRUCT typemap_SimpleChannelClient)
decode_SimpleChannelClient :: T.StatelessProtocol p => p -> LBS.ByteString -> SimpleChannelClient
decode_SimpleChannelClient iprot bs = to_SimpleChannelClient $ T.deserializeVal iprot (T.T_STRUCT typemap_SimpleChannelClient) bs
typemap_SimpleChannelClient :: T.TypeMap
typemap_SimpleChannelClient = Map.fromList [(1,("applicationType",T.T_STRING)),(2,("applicationVersion",T.T_STRING)),(3,("locale",T.T_STRING))]
default_SimpleChannelClient :: SimpleChannelClient
default_SimpleChannelClient = SimpleChannelClient{
  simpleChannelClient_applicationType = "",
  simpleChannelClient_applicationVersion = "",
  simpleChannelClient_locale = ""}
data SimpleChannelContact = SimpleChannelContact  { simpleChannelContact_mid :: LT.Text
  , simpleChannelContact_displayName :: LT.Text
  , simpleChannelContact_pictureStatus :: LT.Text
  , simpleChannelContact_picturePath :: LT.Text
  , simpleChannelContact_statusMessage :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SimpleChannelContact where
  hashWithSalt salt record = salt   `H.hashWithSalt` simpleChannelContact_mid record   `H.hashWithSalt` simpleChannelContact_displayName record   `H.hashWithSalt` simpleChannelContact_pictureStatus record   `H.hashWithSalt` simpleChannelContact_picturePath record   `H.hashWithSalt` simpleChannelContact_statusMessage record  
instance QC.Arbitrary SimpleChannelContact where 
  arbitrary = M.liftM SimpleChannelContact (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SimpleChannelContact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SimpleChannelContact{simpleChannelContact_mid = simpleChannelContact_mid obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_mid = simpleChannelContact_mid obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_displayName = simpleChannelContact_displayName obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_displayName = simpleChannelContact_displayName obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_pictureStatus = simpleChannelContact_pictureStatus obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_pictureStatus = simpleChannelContact_pictureStatus obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_picturePath = simpleChannelContact_picturePath obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_picturePath = simpleChannelContact_picturePath obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_statusMessage = simpleChannelContact_statusMessage obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_statusMessage = simpleChannelContact_statusMessage obj}
    ]
from_SimpleChannelContact :: SimpleChannelContact -> T.ThriftVal
from_SimpleChannelContact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v981 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v981))) $ simpleChannelContact_mid record
  , (\_v981 -> P.Just (2, ("displayName",T.TString $ E.encodeUtf8 _v981))) $ simpleChannelContact_displayName record
  , (\_v981 -> P.Just (3, ("pictureStatus",T.TString $ E.encodeUtf8 _v981))) $ simpleChannelContact_pictureStatus record
  , (\_v981 -> P.Just (4, ("picturePath",T.TString $ E.encodeUtf8 _v981))) $ simpleChannelContact_picturePath record
  , (\_v981 -> P.Just (5, ("statusMessage",T.TString $ E.encodeUtf8 _v981))) $ simpleChannelContact_statusMessage record
  ]
write_SimpleChannelContact :: T.Protocol p => p -> SimpleChannelContact -> P.IO ()
write_SimpleChannelContact oprot record = T.writeVal oprot $ from_SimpleChannelContact record
encode_SimpleChannelContact :: T.StatelessProtocol p => p -> SimpleChannelContact -> LBS.ByteString
encode_SimpleChannelContact oprot record = T.serializeVal oprot $ from_SimpleChannelContact record
to_SimpleChannelContact :: T.ThriftVal -> SimpleChannelContact
to_SimpleChannelContact (T.TStruct fields) = SimpleChannelContact{
  simpleChannelContact_mid = P.maybe (simpleChannelContact_mid default_SimpleChannelContact) (\(_,_val983) -> (case _val983 of {T.TString _val984 -> E.decodeUtf8 _val984; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  simpleChannelContact_displayName = P.maybe (simpleChannelContact_displayName default_SimpleChannelContact) (\(_,_val983) -> (case _val983 of {T.TString _val985 -> E.decodeUtf8 _val985; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  simpleChannelContact_pictureStatus = P.maybe (simpleChannelContact_pictureStatus default_SimpleChannelContact) (\(_,_val983) -> (case _val983 of {T.TString _val986 -> E.decodeUtf8 _val986; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  simpleChannelContact_picturePath = P.maybe (simpleChannelContact_picturePath default_SimpleChannelContact) (\(_,_val983) -> (case _val983 of {T.TString _val987 -> E.decodeUtf8 _val987; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  simpleChannelContact_statusMessage = P.maybe (simpleChannelContact_statusMessage default_SimpleChannelContact) (\(_,_val983) -> (case _val983 of {T.TString _val988 -> E.decodeUtf8 _val988; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SimpleChannelContact _ = P.error "not a struct"
read_SimpleChannelContact :: T.Protocol p => p -> P.IO SimpleChannelContact
read_SimpleChannelContact iprot = to_SimpleChannelContact <$> T.readVal iprot (T.T_STRUCT typemap_SimpleChannelContact)
decode_SimpleChannelContact :: T.StatelessProtocol p => p -> LBS.ByteString -> SimpleChannelContact
decode_SimpleChannelContact iprot bs = to_SimpleChannelContact $ T.deserializeVal iprot (T.T_STRUCT typemap_SimpleChannelContact) bs
typemap_SimpleChannelContact :: T.TypeMap
typemap_SimpleChannelContact = Map.fromList [(1,("mid",T.T_STRING)),(2,("displayName",T.T_STRING)),(3,("pictureStatus",T.T_STRING)),(4,("picturePath",T.T_STRING)),(5,("statusMessage",T.T_STRING))]
default_SimpleChannelContact :: SimpleChannelContact
default_SimpleChannelContact = SimpleChannelContact{
  simpleChannelContact_mid = "",
  simpleChannelContact_displayName = "",
  simpleChannelContact_pictureStatus = "",
  simpleChannelContact_picturePath = "",
  simpleChannelContact_statusMessage = ""}
data SnsFriend = SnsFriend  { snsFriend_snsUserId :: LT.Text
  , snsFriend_snsUserName :: LT.Text
  , snsFriend_snsIdType :: SnsIdType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriend where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriend_snsUserId record   `H.hashWithSalt` snsFriend_snsUserName record   `H.hashWithSalt` snsFriend_snsIdType record  
instance QC.Arbitrary SnsFriend where 
  arbitrary = M.liftM SnsFriend (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriend = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriend{snsFriend_snsUserId = snsFriend_snsUserId obj} then P.Nothing else P.Just $ default_SnsFriend{snsFriend_snsUserId = snsFriend_snsUserId obj}
    , if obj == default_SnsFriend{snsFriend_snsUserName = snsFriend_snsUserName obj} then P.Nothing else P.Just $ default_SnsFriend{snsFriend_snsUserName = snsFriend_snsUserName obj}
    , if obj == default_SnsFriend{snsFriend_snsIdType = snsFriend_snsIdType obj} then P.Nothing else P.Just $ default_SnsFriend{snsFriend_snsIdType = snsFriend_snsIdType obj}
    ]
from_SnsFriend :: SnsFriend -> T.ThriftVal
from_SnsFriend record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v991 -> P.Just (1, ("snsUserId",T.TString $ E.encodeUtf8 _v991))) $ snsFriend_snsUserId record
  , (\_v991 -> P.Just (2, ("snsUserName",T.TString $ E.encodeUtf8 _v991))) $ snsFriend_snsUserName record
  , (\_v991 -> P.Just (3, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v991))) $ snsFriend_snsIdType record
  ]
write_SnsFriend :: T.Protocol p => p -> SnsFriend -> P.IO ()
write_SnsFriend oprot record = T.writeVal oprot $ from_SnsFriend record
encode_SnsFriend :: T.StatelessProtocol p => p -> SnsFriend -> LBS.ByteString
encode_SnsFriend oprot record = T.serializeVal oprot $ from_SnsFriend record
to_SnsFriend :: T.ThriftVal -> SnsFriend
to_SnsFriend (T.TStruct fields) = SnsFriend{
  snsFriend_snsUserId = P.maybe (snsFriend_snsUserId default_SnsFriend) (\(_,_val993) -> (case _val993 of {T.TString _val994 -> E.decodeUtf8 _val994; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriend_snsUserName = P.maybe (snsFriend_snsUserName default_SnsFriend) (\(_,_val993) -> (case _val993 of {T.TString _val995 -> E.decodeUtf8 _val995; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsFriend_snsIdType = P.maybe (snsFriend_snsIdType default_SnsFriend) (\(_,_val993) -> (case _val993 of {T.TI32 _val996 -> P.toEnum $ P.fromIntegral _val996; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SnsFriend _ = P.error "not a struct"
read_SnsFriend :: T.Protocol p => p -> P.IO SnsFriend
read_SnsFriend iprot = to_SnsFriend <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriend)
decode_SnsFriend :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriend
decode_SnsFriend iprot bs = to_SnsFriend $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriend) bs
typemap_SnsFriend :: T.TypeMap
typemap_SnsFriend = Map.fromList [(1,("snsUserId",T.T_STRING)),(2,("snsUserName",T.T_STRING)),(3,("snsIdType",T.T_I32))]
default_SnsFriend :: SnsFriend
default_SnsFriend = SnsFriend{
  snsFriend_snsUserId = "",
  snsFriend_snsUserName = "",
  snsFriend_snsIdType = (P.toEnum 0)}
data SnsFriendContactRegistration = SnsFriendContactRegistration  { snsFriendContactRegistration_contact :: Contact
  , snsFriendContactRegistration_snsIdType :: SnsIdType
  , snsFriendContactRegistration_snsUserId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriendContactRegistration where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriendContactRegistration_contact record   `H.hashWithSalt` snsFriendContactRegistration_snsIdType record   `H.hashWithSalt` snsFriendContactRegistration_snsUserId record  
instance QC.Arbitrary SnsFriendContactRegistration where 
  arbitrary = M.liftM SnsFriendContactRegistration (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriendContactRegistration = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriendContactRegistration{snsFriendContactRegistration_contact = snsFriendContactRegistration_contact obj} then P.Nothing else P.Just $ default_SnsFriendContactRegistration{snsFriendContactRegistration_contact = snsFriendContactRegistration_contact obj}
    , if obj == default_SnsFriendContactRegistration{snsFriendContactRegistration_snsIdType = snsFriendContactRegistration_snsIdType obj} then P.Nothing else P.Just $ default_SnsFriendContactRegistration{snsFriendContactRegistration_snsIdType = snsFriendContactRegistration_snsIdType obj}
    , if obj == default_SnsFriendContactRegistration{snsFriendContactRegistration_snsUserId = snsFriendContactRegistration_snsUserId obj} then P.Nothing else P.Just $ default_SnsFriendContactRegistration{snsFriendContactRegistration_snsUserId = snsFriendContactRegistration_snsUserId obj}
    ]
from_SnsFriendContactRegistration :: SnsFriendContactRegistration -> T.ThriftVal
from_SnsFriendContactRegistration record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v999 -> P.Just (1, ("contact",from_Contact _v999))) $ snsFriendContactRegistration_contact record
  , (\_v999 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v999))) $ snsFriendContactRegistration_snsIdType record
  , (\_v999 -> P.Just (3, ("snsUserId",T.TString $ E.encodeUtf8 _v999))) $ snsFriendContactRegistration_snsUserId record
  ]
write_SnsFriendContactRegistration :: T.Protocol p => p -> SnsFriendContactRegistration -> P.IO ()
write_SnsFriendContactRegistration oprot record = T.writeVal oprot $ from_SnsFriendContactRegistration record
encode_SnsFriendContactRegistration :: T.StatelessProtocol p => p -> SnsFriendContactRegistration -> LBS.ByteString
encode_SnsFriendContactRegistration oprot record = T.serializeVal oprot $ from_SnsFriendContactRegistration record
to_SnsFriendContactRegistration :: T.ThriftVal -> SnsFriendContactRegistration
to_SnsFriendContactRegistration (T.TStruct fields) = SnsFriendContactRegistration{
  snsFriendContactRegistration_contact = P.maybe (snsFriendContactRegistration_contact default_SnsFriendContactRegistration) (\(_,_val1001) -> (case _val1001 of {T.TStruct _val1002 -> (to_Contact (T.TStruct _val1002)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriendContactRegistration_snsIdType = P.maybe (snsFriendContactRegistration_snsIdType default_SnsFriendContactRegistration) (\(_,_val1001) -> (case _val1001 of {T.TI32 _val1003 -> P.toEnum $ P.fromIntegral _val1003; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsFriendContactRegistration_snsUserId = P.maybe (snsFriendContactRegistration_snsUserId default_SnsFriendContactRegistration) (\(_,_val1001) -> (case _val1001 of {T.TString _val1004 -> E.decodeUtf8 _val1004; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SnsFriendContactRegistration _ = P.error "not a struct"
read_SnsFriendContactRegistration :: T.Protocol p => p -> P.IO SnsFriendContactRegistration
read_SnsFriendContactRegistration iprot = to_SnsFriendContactRegistration <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriendContactRegistration)
decode_SnsFriendContactRegistration :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriendContactRegistration
decode_SnsFriendContactRegistration iprot bs = to_SnsFriendContactRegistration $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriendContactRegistration) bs
typemap_SnsFriendContactRegistration :: T.TypeMap
typemap_SnsFriendContactRegistration = Map.fromList [(1,("contact",(T.T_STRUCT typemap_Contact))),(2,("snsIdType",T.T_I32)),(3,("snsUserId",T.T_STRING))]
default_SnsFriendContactRegistration :: SnsFriendContactRegistration
default_SnsFriendContactRegistration = SnsFriendContactRegistration{
  snsFriendContactRegistration_contact = default_Contact,
  snsFriendContactRegistration_snsIdType = (P.toEnum 0),
  snsFriendContactRegistration_snsUserId = ""}
data SnsFriendModification = SnsFriendModification  { snsFriendModification_type :: ModificationType
  , snsFriendModification_snsFriend :: SnsFriend
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriendModification where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriendModification_type record   `H.hashWithSalt` snsFriendModification_snsFriend record  
instance QC.Arbitrary SnsFriendModification where 
  arbitrary = M.liftM SnsFriendModification (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriendModification = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriendModification{snsFriendModification_type = snsFriendModification_type obj} then P.Nothing else P.Just $ default_SnsFriendModification{snsFriendModification_type = snsFriendModification_type obj}
    , if obj == default_SnsFriendModification{snsFriendModification_snsFriend = snsFriendModification_snsFriend obj} then P.Nothing else P.Just $ default_SnsFriendModification{snsFriendModification_snsFriend = snsFriendModification_snsFriend obj}
    ]
from_SnsFriendModification :: SnsFriendModification -> T.ThriftVal
from_SnsFriendModification record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1007 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v1007))) $ snsFriendModification_type record
  , (\_v1007 -> P.Just (2, ("snsFriend",from_SnsFriend _v1007))) $ snsFriendModification_snsFriend record
  ]
write_SnsFriendModification :: T.Protocol p => p -> SnsFriendModification -> P.IO ()
write_SnsFriendModification oprot record = T.writeVal oprot $ from_SnsFriendModification record
encode_SnsFriendModification :: T.StatelessProtocol p => p -> SnsFriendModification -> LBS.ByteString
encode_SnsFriendModification oprot record = T.serializeVal oprot $ from_SnsFriendModification record
to_SnsFriendModification :: T.ThriftVal -> SnsFriendModification
to_SnsFriendModification (T.TStruct fields) = SnsFriendModification{
  snsFriendModification_type = P.maybe (snsFriendModification_type default_SnsFriendModification) (\(_,_val1009) -> (case _val1009 of {T.TI32 _val1010 -> P.toEnum $ P.fromIntegral _val1010; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriendModification_snsFriend = P.maybe (snsFriendModification_snsFriend default_SnsFriendModification) (\(_,_val1009) -> (case _val1009 of {T.TStruct _val1011 -> (to_SnsFriend (T.TStruct _val1011)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SnsFriendModification _ = P.error "not a struct"
read_SnsFriendModification :: T.Protocol p => p -> P.IO SnsFriendModification
read_SnsFriendModification iprot = to_SnsFriendModification <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriendModification)
decode_SnsFriendModification :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriendModification
decode_SnsFriendModification iprot bs = to_SnsFriendModification $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriendModification) bs
typemap_SnsFriendModification :: T.TypeMap
typemap_SnsFriendModification = Map.fromList [(1,("type",T.T_I32)),(2,("snsFriend",(T.T_STRUCT typemap_SnsFriend)))]
default_SnsFriendModification :: SnsFriendModification
default_SnsFriendModification = SnsFriendModification{
  snsFriendModification_type = (P.toEnum 0),
  snsFriendModification_snsFriend = default_SnsFriend}
data SnsFriends = SnsFriends  { snsFriends_snsFriends :: (Vector.Vector SnsFriend)
  , snsFriends_hasMore :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriends where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriends_snsFriends record   `H.hashWithSalt` snsFriends_hasMore record  
instance QC.Arbitrary SnsFriends where 
  arbitrary = M.liftM SnsFriends (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriends = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriends{snsFriends_snsFriends = snsFriends_snsFriends obj} then P.Nothing else P.Just $ default_SnsFriends{snsFriends_snsFriends = snsFriends_snsFriends obj}
    , if obj == default_SnsFriends{snsFriends_hasMore = snsFriends_hasMore obj} then P.Nothing else P.Just $ default_SnsFriends{snsFriends_hasMore = snsFriends_hasMore obj}
    ]
from_SnsFriends :: SnsFriends -> T.ThriftVal
from_SnsFriends record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1014 -> P.Just (1, ("snsFriends",T.TList (T.T_STRUCT typemap_SnsFriend) $ P.map (\_v1016 -> from_SnsFriend _v1016) $ Vector.toList _v1014))) $ snsFriends_snsFriends record
  , (\_v1014 -> P.Just (2, ("hasMore",T.TBool _v1014))) $ snsFriends_hasMore record
  ]
write_SnsFriends :: T.Protocol p => p -> SnsFriends -> P.IO ()
write_SnsFriends oprot record = T.writeVal oprot $ from_SnsFriends record
encode_SnsFriends :: T.StatelessProtocol p => p -> SnsFriends -> LBS.ByteString
encode_SnsFriends oprot record = T.serializeVal oprot $ from_SnsFriends record
to_SnsFriends :: T.ThriftVal -> SnsFriends
to_SnsFriends (T.TStruct fields) = SnsFriends{
  snsFriends_snsFriends = P.maybe (snsFriends_snsFriends default_SnsFriends) (\(_,_val1018) -> (case _val1018 of {T.TList _ _val1019 -> (Vector.fromList $ P.map (\_v1020 -> (case _v1020 of {T.TStruct _val1021 -> (to_SnsFriend (T.TStruct _val1021)); _ -> P.error "wrong type"})) _val1019); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriends_hasMore = P.maybe (snsFriends_hasMore default_SnsFriends) (\(_,_val1018) -> (case _val1018 of {T.TBool _val1022 -> _val1022; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SnsFriends _ = P.error "not a struct"
read_SnsFriends :: T.Protocol p => p -> P.IO SnsFriends
read_SnsFriends iprot = to_SnsFriends <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriends)
decode_SnsFriends :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriends
decode_SnsFriends iprot bs = to_SnsFriends $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriends) bs
typemap_SnsFriends :: T.TypeMap
typemap_SnsFriends = Map.fromList [(1,("snsFriends",(T.T_LIST (T.T_STRUCT typemap_SnsFriend)))),(2,("hasMore",T.T_BOOL))]
default_SnsFriends :: SnsFriends
default_SnsFriends = SnsFriends{
  snsFriends_snsFriends = Vector.empty,
  snsFriends_hasMore = P.False}
data SnsIdUserStatus = SnsIdUserStatus  { snsIdUserStatus_userExisting :: P.Bool
  , snsIdUserStatus_phoneNumberRegistered :: P.Bool
  , snsIdUserStatus_sameDevice :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsIdUserStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsIdUserStatus_userExisting record   `H.hashWithSalt` snsIdUserStatus_phoneNumberRegistered record   `H.hashWithSalt` snsIdUserStatus_sameDevice record  
instance QC.Arbitrary SnsIdUserStatus where 
  arbitrary = M.liftM SnsIdUserStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsIdUserStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsIdUserStatus{snsIdUserStatus_userExisting = snsIdUserStatus_userExisting obj} then P.Nothing else P.Just $ default_SnsIdUserStatus{snsIdUserStatus_userExisting = snsIdUserStatus_userExisting obj}
    , if obj == default_SnsIdUserStatus{snsIdUserStatus_phoneNumberRegistered = snsIdUserStatus_phoneNumberRegistered obj} then P.Nothing else P.Just $ default_SnsIdUserStatus{snsIdUserStatus_phoneNumberRegistered = snsIdUserStatus_phoneNumberRegistered obj}
    , if obj == default_SnsIdUserStatus{snsIdUserStatus_sameDevice = snsIdUserStatus_sameDevice obj} then P.Nothing else P.Just $ default_SnsIdUserStatus{snsIdUserStatus_sameDevice = snsIdUserStatus_sameDevice obj}
    ]
from_SnsIdUserStatus :: SnsIdUserStatus -> T.ThriftVal
from_SnsIdUserStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1025 -> P.Just (1, ("userExisting",T.TBool _v1025))) $ snsIdUserStatus_userExisting record
  , (\_v1025 -> P.Just (2, ("phoneNumberRegistered",T.TBool _v1025))) $ snsIdUserStatus_phoneNumberRegistered record
  , (\_v1025 -> P.Just (3, ("sameDevice",T.TBool _v1025))) $ snsIdUserStatus_sameDevice record
  ]
write_SnsIdUserStatus :: T.Protocol p => p -> SnsIdUserStatus -> P.IO ()
write_SnsIdUserStatus oprot record = T.writeVal oprot $ from_SnsIdUserStatus record
encode_SnsIdUserStatus :: T.StatelessProtocol p => p -> SnsIdUserStatus -> LBS.ByteString
encode_SnsIdUserStatus oprot record = T.serializeVal oprot $ from_SnsIdUserStatus record
to_SnsIdUserStatus :: T.ThriftVal -> SnsIdUserStatus
to_SnsIdUserStatus (T.TStruct fields) = SnsIdUserStatus{
  snsIdUserStatus_userExisting = P.maybe (snsIdUserStatus_userExisting default_SnsIdUserStatus) (\(_,_val1027) -> (case _val1027 of {T.TBool _val1028 -> _val1028; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsIdUserStatus_phoneNumberRegistered = P.maybe (snsIdUserStatus_phoneNumberRegistered default_SnsIdUserStatus) (\(_,_val1027) -> (case _val1027 of {T.TBool _val1029 -> _val1029; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsIdUserStatus_sameDevice = P.maybe (snsIdUserStatus_sameDevice default_SnsIdUserStatus) (\(_,_val1027) -> (case _val1027 of {T.TBool _val1030 -> _val1030; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SnsIdUserStatus _ = P.error "not a struct"
read_SnsIdUserStatus :: T.Protocol p => p -> P.IO SnsIdUserStatus
read_SnsIdUserStatus iprot = to_SnsIdUserStatus <$> T.readVal iprot (T.T_STRUCT typemap_SnsIdUserStatus)
decode_SnsIdUserStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsIdUserStatus
decode_SnsIdUserStatus iprot bs = to_SnsIdUserStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsIdUserStatus) bs
typemap_SnsIdUserStatus :: T.TypeMap
typemap_SnsIdUserStatus = Map.fromList [(1,("userExisting",T.T_BOOL)),(2,("phoneNumberRegistered",T.T_BOOL)),(3,("sameDevice",T.T_BOOL))]
default_SnsIdUserStatus :: SnsIdUserStatus
default_SnsIdUserStatus = SnsIdUserStatus{
  snsIdUserStatus_userExisting = P.False,
  snsIdUserStatus_phoneNumberRegistered = P.False,
  snsIdUserStatus_sameDevice = P.False}
data SnsProfile = SnsProfile  { snsProfile_snsUserId :: LT.Text
  , snsProfile_snsUserName :: LT.Text
  , snsProfile_email :: LT.Text
  , snsProfile_thumbnailUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsProfile_snsUserId record   `H.hashWithSalt` snsProfile_snsUserName record   `H.hashWithSalt` snsProfile_email record   `H.hashWithSalt` snsProfile_thumbnailUrl record  
instance QC.Arbitrary SnsProfile where 
  arbitrary = M.liftM SnsProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsProfile{snsProfile_snsUserId = snsProfile_snsUserId obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_snsUserId = snsProfile_snsUserId obj}
    , if obj == default_SnsProfile{snsProfile_snsUserName = snsProfile_snsUserName obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_snsUserName = snsProfile_snsUserName obj}
    , if obj == default_SnsProfile{snsProfile_email = snsProfile_email obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_email = snsProfile_email obj}
    , if obj == default_SnsProfile{snsProfile_thumbnailUrl = snsProfile_thumbnailUrl obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_thumbnailUrl = snsProfile_thumbnailUrl obj}
    ]
from_SnsProfile :: SnsProfile -> T.ThriftVal
from_SnsProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1033 -> P.Just (1, ("snsUserId",T.TString $ E.encodeUtf8 _v1033))) $ snsProfile_snsUserId record
  , (\_v1033 -> P.Just (2, ("snsUserName",T.TString $ E.encodeUtf8 _v1033))) $ snsProfile_snsUserName record
  , (\_v1033 -> P.Just (3, ("email",T.TString $ E.encodeUtf8 _v1033))) $ snsProfile_email record
  , (\_v1033 -> P.Just (4, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v1033))) $ snsProfile_thumbnailUrl record
  ]
write_SnsProfile :: T.Protocol p => p -> SnsProfile -> P.IO ()
write_SnsProfile oprot record = T.writeVal oprot $ from_SnsProfile record
encode_SnsProfile :: T.StatelessProtocol p => p -> SnsProfile -> LBS.ByteString
encode_SnsProfile oprot record = T.serializeVal oprot $ from_SnsProfile record
to_SnsProfile :: T.ThriftVal -> SnsProfile
to_SnsProfile (T.TStruct fields) = SnsProfile{
  snsProfile_snsUserId = P.maybe (snsProfile_snsUserId default_SnsProfile) (\(_,_val1035) -> (case _val1035 of {T.TString _val1036 -> E.decodeUtf8 _val1036; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsProfile_snsUserName = P.maybe (snsProfile_snsUserName default_SnsProfile) (\(_,_val1035) -> (case _val1035 of {T.TString _val1037 -> E.decodeUtf8 _val1037; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsProfile_email = P.maybe (snsProfile_email default_SnsProfile) (\(_,_val1035) -> (case _val1035 of {T.TString _val1038 -> E.decodeUtf8 _val1038; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  snsProfile_thumbnailUrl = P.maybe (snsProfile_thumbnailUrl default_SnsProfile) (\(_,_val1035) -> (case _val1035 of {T.TString _val1039 -> E.decodeUtf8 _val1039; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SnsProfile _ = P.error "not a struct"
read_SnsProfile :: T.Protocol p => p -> P.IO SnsProfile
read_SnsProfile iprot = to_SnsProfile <$> T.readVal iprot (T.T_STRUCT typemap_SnsProfile)
decode_SnsProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsProfile
decode_SnsProfile iprot bs = to_SnsProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsProfile) bs
typemap_SnsProfile :: T.TypeMap
typemap_SnsProfile = Map.fromList [(1,("snsUserId",T.T_STRING)),(2,("snsUserName",T.T_STRING)),(3,("email",T.T_STRING)),(4,("thumbnailUrl",T.T_STRING))]
default_SnsProfile :: SnsProfile
default_SnsProfile = SnsProfile{
  snsProfile_snsUserId = "",
  snsProfile_snsUserName = "",
  snsProfile_email = "",
  snsProfile_thumbnailUrl = ""}
data SystemConfiguration = SystemConfiguration  { systemConfiguration_endpoint :: LT.Text
  , systemConfiguration_endpointSsl :: LT.Text
  , systemConfiguration_updateUrl :: LT.Text
  , systemConfiguration_c2dmAccount :: LT.Text
  , systemConfiguration_nniServer :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SystemConfiguration where
  hashWithSalt salt record = salt   `H.hashWithSalt` systemConfiguration_endpoint record   `H.hashWithSalt` systemConfiguration_endpointSsl record   `H.hashWithSalt` systemConfiguration_updateUrl record   `H.hashWithSalt` systemConfiguration_c2dmAccount record   `H.hashWithSalt` systemConfiguration_nniServer record  
instance QC.Arbitrary SystemConfiguration where 
  arbitrary = M.liftM SystemConfiguration (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SystemConfiguration = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SystemConfiguration{systemConfiguration_endpoint = systemConfiguration_endpoint obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_endpoint = systemConfiguration_endpoint obj}
    , if obj == default_SystemConfiguration{systemConfiguration_endpointSsl = systemConfiguration_endpointSsl obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_endpointSsl = systemConfiguration_endpointSsl obj}
    , if obj == default_SystemConfiguration{systemConfiguration_updateUrl = systemConfiguration_updateUrl obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_updateUrl = systemConfiguration_updateUrl obj}
    , if obj == default_SystemConfiguration{systemConfiguration_c2dmAccount = systemConfiguration_c2dmAccount obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_c2dmAccount = systemConfiguration_c2dmAccount obj}
    , if obj == default_SystemConfiguration{systemConfiguration_nniServer = systemConfiguration_nniServer obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_nniServer = systemConfiguration_nniServer obj}
    ]
from_SystemConfiguration :: SystemConfiguration -> T.ThriftVal
from_SystemConfiguration record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1042 -> P.Just (1, ("endpoint",T.TString $ E.encodeUtf8 _v1042))) $ systemConfiguration_endpoint record
  , (\_v1042 -> P.Just (2, ("endpointSsl",T.TString $ E.encodeUtf8 _v1042))) $ systemConfiguration_endpointSsl record
  , (\_v1042 -> P.Just (3, ("updateUrl",T.TString $ E.encodeUtf8 _v1042))) $ systemConfiguration_updateUrl record
  , (\_v1042 -> P.Just (11, ("c2dmAccount",T.TString $ E.encodeUtf8 _v1042))) $ systemConfiguration_c2dmAccount record
  , (\_v1042 -> P.Just (12, ("nniServer",T.TString $ E.encodeUtf8 _v1042))) $ systemConfiguration_nniServer record
  ]
write_SystemConfiguration :: T.Protocol p => p -> SystemConfiguration -> P.IO ()
write_SystemConfiguration oprot record = T.writeVal oprot $ from_SystemConfiguration record
encode_SystemConfiguration :: T.StatelessProtocol p => p -> SystemConfiguration -> LBS.ByteString
encode_SystemConfiguration oprot record = T.serializeVal oprot $ from_SystemConfiguration record
to_SystemConfiguration :: T.ThriftVal -> SystemConfiguration
to_SystemConfiguration (T.TStruct fields) = SystemConfiguration{
  systemConfiguration_endpoint = P.maybe (systemConfiguration_endpoint default_SystemConfiguration) (\(_,_val1044) -> (case _val1044 of {T.TString _val1045 -> E.decodeUtf8 _val1045; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  systemConfiguration_endpointSsl = P.maybe (systemConfiguration_endpointSsl default_SystemConfiguration) (\(_,_val1044) -> (case _val1044 of {T.TString _val1046 -> E.decodeUtf8 _val1046; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  systemConfiguration_updateUrl = P.maybe (systemConfiguration_updateUrl default_SystemConfiguration) (\(_,_val1044) -> (case _val1044 of {T.TString _val1047 -> E.decodeUtf8 _val1047; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  systemConfiguration_c2dmAccount = P.maybe (systemConfiguration_c2dmAccount default_SystemConfiguration) (\(_,_val1044) -> (case _val1044 of {T.TString _val1048 -> E.decodeUtf8 _val1048; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  systemConfiguration_nniServer = P.maybe (systemConfiguration_nniServer default_SystemConfiguration) (\(_,_val1044) -> (case _val1044 of {T.TString _val1049 -> E.decodeUtf8 _val1049; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_SystemConfiguration _ = P.error "not a struct"
read_SystemConfiguration :: T.Protocol p => p -> P.IO SystemConfiguration
read_SystemConfiguration iprot = to_SystemConfiguration <$> T.readVal iprot (T.T_STRUCT typemap_SystemConfiguration)
decode_SystemConfiguration :: T.StatelessProtocol p => p -> LBS.ByteString -> SystemConfiguration
decode_SystemConfiguration iprot bs = to_SystemConfiguration $ T.deserializeVal iprot (T.T_STRUCT typemap_SystemConfiguration) bs
typemap_SystemConfiguration :: T.TypeMap
typemap_SystemConfiguration = Map.fromList [(1,("endpoint",T.T_STRING)),(2,("endpointSsl",T.T_STRING)),(3,("updateUrl",T.T_STRING)),(11,("c2dmAccount",T.T_STRING)),(12,("nniServer",T.T_STRING))]
default_SystemConfiguration :: SystemConfiguration
default_SystemConfiguration = SystemConfiguration{
  systemConfiguration_endpoint = "",
  systemConfiguration_endpointSsl = "",
  systemConfiguration_updateUrl = "",
  systemConfiguration_c2dmAccount = "",
  systemConfiguration_nniServer = ""}
data TalkException = TalkException  { talkException_code :: ErrorCode
  , talkException_reason :: LT.Text
  , talkException_parameterMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception TalkException
instance H.Hashable TalkException where
  hashWithSalt salt record = salt   `H.hashWithSalt` talkException_code record   `H.hashWithSalt` talkException_reason record   `H.hashWithSalt` talkException_parameterMap record  
instance QC.Arbitrary TalkException where 
  arbitrary = M.liftM TalkException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TalkException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TalkException{talkException_code = talkException_code obj} then P.Nothing else P.Just $ default_TalkException{talkException_code = talkException_code obj}
    , if obj == default_TalkException{talkException_reason = talkException_reason obj} then P.Nothing else P.Just $ default_TalkException{talkException_reason = talkException_reason obj}
    , if obj == default_TalkException{talkException_parameterMap = talkException_parameterMap obj} then P.Nothing else P.Just $ default_TalkException{talkException_parameterMap = talkException_parameterMap obj}
    ]
from_TalkException :: TalkException -> T.ThriftVal
from_TalkException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1052 -> P.Just (1, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v1052))) $ talkException_code record
  , (\_v1052 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v1052))) $ talkException_reason record
  , (\_v1052 -> P.Just (3, ("parameterMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k1053,_v1054) -> (T.TString $ E.encodeUtf8 _k1053, T.TString $ E.encodeUtf8 _v1054)) $ Map.toList _v1052))) $ talkException_parameterMap record
  ]
write_TalkException :: T.Protocol p => p -> TalkException -> P.IO ()
write_TalkException oprot record = T.writeVal oprot $ from_TalkException record
encode_TalkException :: T.StatelessProtocol p => p -> TalkException -> LBS.ByteString
encode_TalkException oprot record = T.serializeVal oprot $ from_TalkException record
to_TalkException :: T.ThriftVal -> TalkException
to_TalkException (T.TStruct fields) = TalkException{
  talkException_code = P.maybe (talkException_code default_TalkException) (\(_,_val1056) -> (case _val1056 of {T.TI32 _val1057 -> P.toEnum $ P.fromIntegral _val1057; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  talkException_reason = P.maybe (talkException_reason default_TalkException) (\(_,_val1056) -> (case _val1056 of {T.TString _val1058 -> E.decodeUtf8 _val1058; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  talkException_parameterMap = P.maybe (talkException_parameterMap default_TalkException) (\(_,_val1056) -> (case _val1056 of {T.TMap _ _ _val1059 -> (Map.fromList $ P.map (\(_k1061,_v1060) -> ((case _k1061 of {T.TString _val1062 -> E.decodeUtf8 _val1062; _ -> P.error "wrong type"}),(case _v1060 of {T.TString _val1063 -> E.decodeUtf8 _val1063; _ -> P.error "wrong type"}))) _val1059); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TalkException _ = P.error "not a struct"
read_TalkException :: T.Protocol p => p -> P.IO TalkException
read_TalkException iprot = to_TalkException <$> T.readVal iprot (T.T_STRUCT typemap_TalkException)
decode_TalkException :: T.StatelessProtocol p => p -> LBS.ByteString -> TalkException
decode_TalkException iprot bs = to_TalkException $ T.deserializeVal iprot (T.T_STRUCT typemap_TalkException) bs
typemap_TalkException :: T.TypeMap
typemap_TalkException = Map.fromList [(1,("code",T.T_I32)),(2,("reason",T.T_STRING)),(3,("parameterMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TalkException :: TalkException
default_TalkException = TalkException{
  talkException_code = (P.toEnum 0),
  talkException_reason = "",
  talkException_parameterMap = Map.empty}
data Ticket = Ticket  { ticket_id :: LT.Text
  , ticket_expirationTime :: I.Int64
  , ticket_maxUseCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ticket where
  hashWithSalt salt record = salt   `H.hashWithSalt` ticket_id record   `H.hashWithSalt` ticket_expirationTime record   `H.hashWithSalt` ticket_maxUseCount record  
instance QC.Arbitrary Ticket where 
  arbitrary = M.liftM Ticket (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Ticket = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Ticket{ticket_id = ticket_id obj} then P.Nothing else P.Just $ default_Ticket{ticket_id = ticket_id obj}
    , if obj == default_Ticket{ticket_expirationTime = ticket_expirationTime obj} then P.Nothing else P.Just $ default_Ticket{ticket_expirationTime = ticket_expirationTime obj}
    , if obj == default_Ticket{ticket_maxUseCount = ticket_maxUseCount obj} then P.Nothing else P.Just $ default_Ticket{ticket_maxUseCount = ticket_maxUseCount obj}
    ]
from_Ticket :: Ticket -> T.ThriftVal
from_Ticket record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1066 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v1066))) $ ticket_id record
  , (\_v1066 -> P.Just (10, ("expirationTime",T.TI64 _v1066))) $ ticket_expirationTime record
  , (\_v1066 -> P.Just (21, ("maxUseCount",T.TI32 _v1066))) $ ticket_maxUseCount record
  ]
write_Ticket :: T.Protocol p => p -> Ticket -> P.IO ()
write_Ticket oprot record = T.writeVal oprot $ from_Ticket record
encode_Ticket :: T.StatelessProtocol p => p -> Ticket -> LBS.ByteString
encode_Ticket oprot record = T.serializeVal oprot $ from_Ticket record
to_Ticket :: T.ThriftVal -> Ticket
to_Ticket (T.TStruct fields) = Ticket{
  ticket_id = P.maybe (ticket_id default_Ticket) (\(_,_val1068) -> (case _val1068 of {T.TString _val1069 -> E.decodeUtf8 _val1069; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  ticket_expirationTime = P.maybe (ticket_expirationTime default_Ticket) (\(_,_val1068) -> (case _val1068 of {T.TI64 _val1070 -> _val1070; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  ticket_maxUseCount = P.maybe (ticket_maxUseCount default_Ticket) (\(_,_val1068) -> (case _val1068 of {T.TI32 _val1071 -> _val1071; _ -> P.error "wrong type"})) (Map.lookup (21) fields)
  }
to_Ticket _ = P.error "not a struct"
read_Ticket :: T.Protocol p => p -> P.IO Ticket
read_Ticket iprot = to_Ticket <$> T.readVal iprot (T.T_STRUCT typemap_Ticket)
decode_Ticket :: T.StatelessProtocol p => p -> LBS.ByteString -> Ticket
decode_Ticket iprot bs = to_Ticket $ T.deserializeVal iprot (T.T_STRUCT typemap_Ticket) bs
typemap_Ticket :: T.TypeMap
typemap_Ticket = Map.fromList [(1,("id",T.T_STRING)),(10,("expirationTime",T.T_I64)),(21,("maxUseCount",T.T_I32))]
default_Ticket :: Ticket
default_Ticket = Ticket{
  ticket_id = "",
  ticket_expirationTime = 0,
  ticket_maxUseCount = 0}
data TMessageBox = TMessageBox  { tMessageBox_id :: LT.Text
  , tMessageBox_channelId :: LT.Text
  , tMessageBox_lastSeq :: I.Int64
  , tMessageBox_unreadCount :: I.Int64
  , tMessageBox_lastModifiedTime :: I.Int64
  , tMessageBox_status :: I.Int32
  , tMessageBox_midType :: MIDType
  , tMessageBox_lastMessages :: (Vector.Vector Message)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageBox where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageBox_id record   `H.hashWithSalt` tMessageBox_channelId record   `H.hashWithSalt` tMessageBox_lastSeq record   `H.hashWithSalt` tMessageBox_unreadCount record   `H.hashWithSalt` tMessageBox_lastModifiedTime record   `H.hashWithSalt` tMessageBox_status record   `H.hashWithSalt` tMessageBox_midType record   `H.hashWithSalt` tMessageBox_lastMessages record  
instance QC.Arbitrary TMessageBox where 
  arbitrary = M.liftM TMessageBox (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageBox = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageBox{tMessageBox_id = tMessageBox_id obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_id = tMessageBox_id obj}
    , if obj == default_TMessageBox{tMessageBox_channelId = tMessageBox_channelId obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_channelId = tMessageBox_channelId obj}
    , if obj == default_TMessageBox{tMessageBox_lastSeq = tMessageBox_lastSeq obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_lastSeq = tMessageBox_lastSeq obj}
    , if obj == default_TMessageBox{tMessageBox_unreadCount = tMessageBox_unreadCount obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_unreadCount = tMessageBox_unreadCount obj}
    , if obj == default_TMessageBox{tMessageBox_lastModifiedTime = tMessageBox_lastModifiedTime obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_lastModifiedTime = tMessageBox_lastModifiedTime obj}
    , if obj == default_TMessageBox{tMessageBox_status = tMessageBox_status obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_status = tMessageBox_status obj}
    , if obj == default_TMessageBox{tMessageBox_midType = tMessageBox_midType obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_midType = tMessageBox_midType obj}
    , if obj == default_TMessageBox{tMessageBox_lastMessages = tMessageBox_lastMessages obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_lastMessages = tMessageBox_lastMessages obj}
    ]
from_TMessageBox :: TMessageBox -> T.ThriftVal
from_TMessageBox record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1074 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v1074))) $ tMessageBox_id record
  , (\_v1074 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v1074))) $ tMessageBox_channelId record
  , (\_v1074 -> P.Just (5, ("lastSeq",T.TI64 _v1074))) $ tMessageBox_lastSeq record
  , (\_v1074 -> P.Just (6, ("unreadCount",T.TI64 _v1074))) $ tMessageBox_unreadCount record
  , (\_v1074 -> P.Just (7, ("lastModifiedTime",T.TI64 _v1074))) $ tMessageBox_lastModifiedTime record
  , (\_v1074 -> P.Just (8, ("status",T.TI32 _v1074))) $ tMessageBox_status record
  , (\_v1074 -> P.Just (9, ("midType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1074))) $ tMessageBox_midType record
  , (\_v1074 -> P.Just (10, ("lastMessages",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v1076 -> from_Message _v1076) $ Vector.toList _v1074))) $ tMessageBox_lastMessages record
  ]
write_TMessageBox :: T.Protocol p => p -> TMessageBox -> P.IO ()
write_TMessageBox oprot record = T.writeVal oprot $ from_TMessageBox record
encode_TMessageBox :: T.StatelessProtocol p => p -> TMessageBox -> LBS.ByteString
encode_TMessageBox oprot record = T.serializeVal oprot $ from_TMessageBox record
to_TMessageBox :: T.ThriftVal -> TMessageBox
to_TMessageBox (T.TStruct fields) = TMessageBox{
  tMessageBox_id = P.maybe (tMessageBox_id default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TString _val1079 -> E.decodeUtf8 _val1079; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageBox_channelId = P.maybe (tMessageBox_channelId default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TString _val1080 -> E.decodeUtf8 _val1080; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tMessageBox_lastSeq = P.maybe (tMessageBox_lastSeq default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TI64 _val1081 -> _val1081; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tMessageBox_unreadCount = P.maybe (tMessageBox_unreadCount default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TI64 _val1082 -> _val1082; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  tMessageBox_lastModifiedTime = P.maybe (tMessageBox_lastModifiedTime default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TI64 _val1083 -> _val1083; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  tMessageBox_status = P.maybe (tMessageBox_status default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TI32 _val1084 -> _val1084; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  tMessageBox_midType = P.maybe (tMessageBox_midType default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TI32 _val1085 -> P.toEnum $ P.fromIntegral _val1085; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  tMessageBox_lastMessages = P.maybe (tMessageBox_lastMessages default_TMessageBox) (\(_,_val1078) -> (case _val1078 of {T.TList _ _val1086 -> (Vector.fromList $ P.map (\_v1087 -> (case _v1087 of {T.TStruct _val1088 -> (to_Message (T.TStruct _val1088)); _ -> P.error "wrong type"})) _val1086); _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_TMessageBox _ = P.error "not a struct"
read_TMessageBox :: T.Protocol p => p -> P.IO TMessageBox
read_TMessageBox iprot = to_TMessageBox <$> T.readVal iprot (T.T_STRUCT typemap_TMessageBox)
decode_TMessageBox :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageBox
decode_TMessageBox iprot bs = to_TMessageBox $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageBox) bs
typemap_TMessageBox :: T.TypeMap
typemap_TMessageBox = Map.fromList [(1,("id",T.T_STRING)),(2,("channelId",T.T_STRING)),(5,("lastSeq",T.T_I64)),(6,("unreadCount",T.T_I64)),(7,("lastModifiedTime",T.T_I64)),(8,("status",T.T_I32)),(9,("midType",T.T_I32)),(10,("lastMessages",(T.T_LIST (T.T_STRUCT typemap_Message))))]
default_TMessageBox :: TMessageBox
default_TMessageBox = TMessageBox{
  tMessageBox_id = "",
  tMessageBox_channelId = "",
  tMessageBox_lastSeq = 0,
  tMessageBox_unreadCount = 0,
  tMessageBox_lastModifiedTime = 0,
  tMessageBox_status = 0,
  tMessageBox_midType = (P.toEnum 0),
  tMessageBox_lastMessages = Vector.empty}
data TMessageBoxWrapUp = TMessageBoxWrapUp  { tMessageBoxWrapUp_messageBox :: TMessageBox
  , tMessageBoxWrapUp_name :: LT.Text
  , tMessageBoxWrapUp_contacts :: (Vector.Vector Contact)
  , tMessageBoxWrapUp_pictureRevision :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageBoxWrapUp where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageBoxWrapUp_messageBox record   `H.hashWithSalt` tMessageBoxWrapUp_name record   `H.hashWithSalt` tMessageBoxWrapUp_contacts record   `H.hashWithSalt` tMessageBoxWrapUp_pictureRevision record  
instance QC.Arbitrary TMessageBoxWrapUp where 
  arbitrary = M.liftM TMessageBoxWrapUp (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageBoxWrapUp = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_messageBox = tMessageBoxWrapUp_messageBox obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_messageBox = tMessageBoxWrapUp_messageBox obj}
    , if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_name = tMessageBoxWrapUp_name obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_name = tMessageBoxWrapUp_name obj}
    , if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_contacts = tMessageBoxWrapUp_contacts obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_contacts = tMessageBoxWrapUp_contacts obj}
    , if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_pictureRevision = tMessageBoxWrapUp_pictureRevision obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_pictureRevision = tMessageBoxWrapUp_pictureRevision obj}
    ]
from_TMessageBoxWrapUp :: TMessageBoxWrapUp -> T.ThriftVal
from_TMessageBoxWrapUp record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1091 -> P.Just (1, ("messageBox",from_TMessageBox _v1091))) $ tMessageBoxWrapUp_messageBox record
  , (\_v1091 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v1091))) $ tMessageBoxWrapUp_name record
  , (\_v1091 -> P.Just (3, ("contacts",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v1093 -> from_Contact _v1093) $ Vector.toList _v1091))) $ tMessageBoxWrapUp_contacts record
  , (\_v1091 -> P.Just (4, ("pictureRevision",T.TString $ E.encodeUtf8 _v1091))) $ tMessageBoxWrapUp_pictureRevision record
  ]
write_TMessageBoxWrapUp :: T.Protocol p => p -> TMessageBoxWrapUp -> P.IO ()
write_TMessageBoxWrapUp oprot record = T.writeVal oprot $ from_TMessageBoxWrapUp record
encode_TMessageBoxWrapUp :: T.StatelessProtocol p => p -> TMessageBoxWrapUp -> LBS.ByteString
encode_TMessageBoxWrapUp oprot record = T.serializeVal oprot $ from_TMessageBoxWrapUp record
to_TMessageBoxWrapUp :: T.ThriftVal -> TMessageBoxWrapUp
to_TMessageBoxWrapUp (T.TStruct fields) = TMessageBoxWrapUp{
  tMessageBoxWrapUp_messageBox = P.maybe (tMessageBoxWrapUp_messageBox default_TMessageBoxWrapUp) (\(_,_val1095) -> (case _val1095 of {T.TStruct _val1096 -> (to_TMessageBox (T.TStruct _val1096)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageBoxWrapUp_name = P.maybe (tMessageBoxWrapUp_name default_TMessageBoxWrapUp) (\(_,_val1095) -> (case _val1095 of {T.TString _val1097 -> E.decodeUtf8 _val1097; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tMessageBoxWrapUp_contacts = P.maybe (tMessageBoxWrapUp_contacts default_TMessageBoxWrapUp) (\(_,_val1095) -> (case _val1095 of {T.TList _ _val1098 -> (Vector.fromList $ P.map (\_v1099 -> (case _v1099 of {T.TStruct _val1100 -> (to_Contact (T.TStruct _val1100)); _ -> P.error "wrong type"})) _val1098); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tMessageBoxWrapUp_pictureRevision = P.maybe (tMessageBoxWrapUp_pictureRevision default_TMessageBoxWrapUp) (\(_,_val1095) -> (case _val1095 of {T.TString _val1101 -> E.decodeUtf8 _val1101; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TMessageBoxWrapUp _ = P.error "not a struct"
read_TMessageBoxWrapUp :: T.Protocol p => p -> P.IO TMessageBoxWrapUp
read_TMessageBoxWrapUp iprot = to_TMessageBoxWrapUp <$> T.readVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUp)
decode_TMessageBoxWrapUp :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageBoxWrapUp
decode_TMessageBoxWrapUp iprot bs = to_TMessageBoxWrapUp $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUp) bs
typemap_TMessageBoxWrapUp :: T.TypeMap
typemap_TMessageBoxWrapUp = Map.fromList [(1,("messageBox",(T.T_STRUCT typemap_TMessageBox))),(2,("name",T.T_STRING)),(3,("contacts",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(4,("pictureRevision",T.T_STRING))]
default_TMessageBoxWrapUp :: TMessageBoxWrapUp
default_TMessageBoxWrapUp = TMessageBoxWrapUp{
  tMessageBoxWrapUp_messageBox = default_TMessageBox,
  tMessageBoxWrapUp_name = "",
  tMessageBoxWrapUp_contacts = Vector.empty,
  tMessageBoxWrapUp_pictureRevision = ""}
data TMessageBoxWrapUpResponse = TMessageBoxWrapUpResponse  { tMessageBoxWrapUpResponse_messageBoxWrapUpList :: (Vector.Vector TMessageBoxWrapUp)
  , tMessageBoxWrapUpResponse_totalSize :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageBoxWrapUpResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageBoxWrapUpResponse_messageBoxWrapUpList record   `H.hashWithSalt` tMessageBoxWrapUpResponse_totalSize record  
instance QC.Arbitrary TMessageBoxWrapUpResponse where 
  arbitrary = M.liftM TMessageBoxWrapUpResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageBoxWrapUpResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_messageBoxWrapUpList = tMessageBoxWrapUpResponse_messageBoxWrapUpList obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_messageBoxWrapUpList = tMessageBoxWrapUpResponse_messageBoxWrapUpList obj}
    , if obj == default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_totalSize = tMessageBoxWrapUpResponse_totalSize obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_totalSize = tMessageBoxWrapUpResponse_totalSize obj}
    ]
from_TMessageBoxWrapUpResponse :: TMessageBoxWrapUpResponse -> T.ThriftVal
from_TMessageBoxWrapUpResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1104 -> P.Just (1, ("messageBoxWrapUpList",T.TList (T.T_STRUCT typemap_TMessageBoxWrapUp) $ P.map (\_v1106 -> from_TMessageBoxWrapUp _v1106) $ Vector.toList _v1104))) $ tMessageBoxWrapUpResponse_messageBoxWrapUpList record
  , (\_v1104 -> P.Just (2, ("totalSize",T.TI32 _v1104))) $ tMessageBoxWrapUpResponse_totalSize record
  ]
write_TMessageBoxWrapUpResponse :: T.Protocol p => p -> TMessageBoxWrapUpResponse -> P.IO ()
write_TMessageBoxWrapUpResponse oprot record = T.writeVal oprot $ from_TMessageBoxWrapUpResponse record
encode_TMessageBoxWrapUpResponse :: T.StatelessProtocol p => p -> TMessageBoxWrapUpResponse -> LBS.ByteString
encode_TMessageBoxWrapUpResponse oprot record = T.serializeVal oprot $ from_TMessageBoxWrapUpResponse record
to_TMessageBoxWrapUpResponse :: T.ThriftVal -> TMessageBoxWrapUpResponse
to_TMessageBoxWrapUpResponse (T.TStruct fields) = TMessageBoxWrapUpResponse{
  tMessageBoxWrapUpResponse_messageBoxWrapUpList = P.maybe (tMessageBoxWrapUpResponse_messageBoxWrapUpList default_TMessageBoxWrapUpResponse) (\(_,_val1108) -> (case _val1108 of {T.TList _ _val1109 -> (Vector.fromList $ P.map (\_v1110 -> (case _v1110 of {T.TStruct _val1111 -> (to_TMessageBoxWrapUp (T.TStruct _val1111)); _ -> P.error "wrong type"})) _val1109); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageBoxWrapUpResponse_totalSize = P.maybe (tMessageBoxWrapUpResponse_totalSize default_TMessageBoxWrapUpResponse) (\(_,_val1108) -> (case _val1108 of {T.TI32 _val1112 -> _val1112; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TMessageBoxWrapUpResponse _ = P.error "not a struct"
read_TMessageBoxWrapUpResponse :: T.Protocol p => p -> P.IO TMessageBoxWrapUpResponse
read_TMessageBoxWrapUpResponse iprot = to_TMessageBoxWrapUpResponse <$> T.readVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUpResponse)
decode_TMessageBoxWrapUpResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageBoxWrapUpResponse
decode_TMessageBoxWrapUpResponse iprot bs = to_TMessageBoxWrapUpResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUpResponse) bs
typemap_TMessageBoxWrapUpResponse :: T.TypeMap
typemap_TMessageBoxWrapUpResponse = Map.fromList [(1,("messageBoxWrapUpList",(T.T_LIST (T.T_STRUCT typemap_TMessageBoxWrapUp)))),(2,("totalSize",T.T_I32))]
default_TMessageBoxWrapUpResponse :: TMessageBoxWrapUpResponse
default_TMessageBoxWrapUpResponse = TMessageBoxWrapUpResponse{
  tMessageBoxWrapUpResponse_messageBoxWrapUpList = Vector.empty,
  tMessageBoxWrapUpResponse_totalSize = 0}
data UniversalNotificationServiceException = UniversalNotificationServiceException  { universalNotificationServiceException_code :: UniversalNotificationServiceErrorCode
  , universalNotificationServiceException_reason :: LT.Text
  , universalNotificationServiceException_parameterMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception UniversalNotificationServiceException
instance H.Hashable UniversalNotificationServiceException where
  hashWithSalt salt record = salt   `H.hashWithSalt` universalNotificationServiceException_code record   `H.hashWithSalt` universalNotificationServiceException_reason record   `H.hashWithSalt` universalNotificationServiceException_parameterMap record  
instance QC.Arbitrary UniversalNotificationServiceException where 
  arbitrary = M.liftM UniversalNotificationServiceException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UniversalNotificationServiceException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UniversalNotificationServiceException{universalNotificationServiceException_code = universalNotificationServiceException_code obj} then P.Nothing else P.Just $ default_UniversalNotificationServiceException{universalNotificationServiceException_code = universalNotificationServiceException_code obj}
    , if obj == default_UniversalNotificationServiceException{universalNotificationServiceException_reason = universalNotificationServiceException_reason obj} then P.Nothing else P.Just $ default_UniversalNotificationServiceException{universalNotificationServiceException_reason = universalNotificationServiceException_reason obj}
    , if obj == default_UniversalNotificationServiceException{universalNotificationServiceException_parameterMap = universalNotificationServiceException_parameterMap obj} then P.Nothing else P.Just $ default_UniversalNotificationServiceException{universalNotificationServiceException_parameterMap = universalNotificationServiceException_parameterMap obj}
    ]
from_UniversalNotificationServiceException :: UniversalNotificationServiceException -> T.ThriftVal
from_UniversalNotificationServiceException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1115 -> P.Just (1, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v1115))) $ universalNotificationServiceException_code record
  , (\_v1115 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v1115))) $ universalNotificationServiceException_reason record
  , (\_v1115 -> P.Just (3, ("parameterMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k1116,_v1117) -> (T.TString $ E.encodeUtf8 _k1116, T.TString $ E.encodeUtf8 _v1117)) $ Map.toList _v1115))) $ universalNotificationServiceException_parameterMap record
  ]
write_UniversalNotificationServiceException :: T.Protocol p => p -> UniversalNotificationServiceException -> P.IO ()
write_UniversalNotificationServiceException oprot record = T.writeVal oprot $ from_UniversalNotificationServiceException record
encode_UniversalNotificationServiceException :: T.StatelessProtocol p => p -> UniversalNotificationServiceException -> LBS.ByteString
encode_UniversalNotificationServiceException oprot record = T.serializeVal oprot $ from_UniversalNotificationServiceException record
to_UniversalNotificationServiceException :: T.ThriftVal -> UniversalNotificationServiceException
to_UniversalNotificationServiceException (T.TStruct fields) = UniversalNotificationServiceException{
  universalNotificationServiceException_code = P.maybe (universalNotificationServiceException_code default_UniversalNotificationServiceException) (\(_,_val1119) -> (case _val1119 of {T.TI32 _val1120 -> P.toEnum $ P.fromIntegral _val1120; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  universalNotificationServiceException_reason = P.maybe (universalNotificationServiceException_reason default_UniversalNotificationServiceException) (\(_,_val1119) -> (case _val1119 of {T.TString _val1121 -> E.decodeUtf8 _val1121; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  universalNotificationServiceException_parameterMap = P.maybe (universalNotificationServiceException_parameterMap default_UniversalNotificationServiceException) (\(_,_val1119) -> (case _val1119 of {T.TMap _ _ _val1122 -> (Map.fromList $ P.map (\(_k1124,_v1123) -> ((case _k1124 of {T.TString _val1125 -> E.decodeUtf8 _val1125; _ -> P.error "wrong type"}),(case _v1123 of {T.TString _val1126 -> E.decodeUtf8 _val1126; _ -> P.error "wrong type"}))) _val1122); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UniversalNotificationServiceException _ = P.error "not a struct"
read_UniversalNotificationServiceException :: T.Protocol p => p -> P.IO UniversalNotificationServiceException
read_UniversalNotificationServiceException iprot = to_UniversalNotificationServiceException <$> T.readVal iprot (T.T_STRUCT typemap_UniversalNotificationServiceException)
decode_UniversalNotificationServiceException :: T.StatelessProtocol p => p -> LBS.ByteString -> UniversalNotificationServiceException
decode_UniversalNotificationServiceException iprot bs = to_UniversalNotificationServiceException $ T.deserializeVal iprot (T.T_STRUCT typemap_UniversalNotificationServiceException) bs
typemap_UniversalNotificationServiceException :: T.TypeMap
typemap_UniversalNotificationServiceException = Map.fromList [(1,("code",T.T_I32)),(2,("reason",T.T_STRING)),(3,("parameterMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_UniversalNotificationServiceException :: UniversalNotificationServiceException
default_UniversalNotificationServiceException = UniversalNotificationServiceException{
  universalNotificationServiceException_code = (P.toEnum 0),
  universalNotificationServiceException_reason = "",
  universalNotificationServiceException_parameterMap = Map.empty}
data UpdateBuddyProfileResult = UpdateBuddyProfileResult  { updateBuddyProfileResult_requestId :: LT.Text
  , updateBuddyProfileResult_state :: BuddyResultState
  , updateBuddyProfileResult_eventNo :: I.Int32
  , updateBuddyProfileResult_receiverCount :: I.Int64
  , updateBuddyProfileResult_successCount :: I.Int64
  , updateBuddyProfileResult_failCount :: I.Int64
  , updateBuddyProfileResult_cancelCount :: I.Int64
  , updateBuddyProfileResult_unregisterCount :: I.Int64
  , updateBuddyProfileResult_timestamp :: I.Int64
  , updateBuddyProfileResult_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBuddyProfileResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBuddyProfileResult_requestId record   `H.hashWithSalt` updateBuddyProfileResult_state record   `H.hashWithSalt` updateBuddyProfileResult_eventNo record   `H.hashWithSalt` updateBuddyProfileResult_receiverCount record   `H.hashWithSalt` updateBuddyProfileResult_successCount record   `H.hashWithSalt` updateBuddyProfileResult_failCount record   `H.hashWithSalt` updateBuddyProfileResult_cancelCount record   `H.hashWithSalt` updateBuddyProfileResult_unregisterCount record   `H.hashWithSalt` updateBuddyProfileResult_timestamp record   `H.hashWithSalt` updateBuddyProfileResult_message record  
instance QC.Arbitrary UpdateBuddyProfileResult where 
  arbitrary = M.liftM UpdateBuddyProfileResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateBuddyProfileResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_requestId = updateBuddyProfileResult_requestId obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_requestId = updateBuddyProfileResult_requestId obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_state = updateBuddyProfileResult_state obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_state = updateBuddyProfileResult_state obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_eventNo = updateBuddyProfileResult_eventNo obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_eventNo = updateBuddyProfileResult_eventNo obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_receiverCount = updateBuddyProfileResult_receiverCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_receiverCount = updateBuddyProfileResult_receiverCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_successCount = updateBuddyProfileResult_successCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_successCount = updateBuddyProfileResult_successCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_failCount = updateBuddyProfileResult_failCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_failCount = updateBuddyProfileResult_failCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_cancelCount = updateBuddyProfileResult_cancelCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_cancelCount = updateBuddyProfileResult_cancelCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_unregisterCount = updateBuddyProfileResult_unregisterCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_unregisterCount = updateBuddyProfileResult_unregisterCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_timestamp = updateBuddyProfileResult_timestamp obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_timestamp = updateBuddyProfileResult_timestamp obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_message = updateBuddyProfileResult_message obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_message = updateBuddyProfileResult_message obj}
    ]
from_UpdateBuddyProfileResult :: UpdateBuddyProfileResult -> T.ThriftVal
from_UpdateBuddyProfileResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1129 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v1129))) $ updateBuddyProfileResult_requestId record
  , (\_v1129 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v1129))) $ updateBuddyProfileResult_state record
  , (\_v1129 -> P.Just (3, ("eventNo",T.TI32 _v1129))) $ updateBuddyProfileResult_eventNo record
  , (\_v1129 -> P.Just (11, ("receiverCount",T.TI64 _v1129))) $ updateBuddyProfileResult_receiverCount record
  , (\_v1129 -> P.Just (12, ("successCount",T.TI64 _v1129))) $ updateBuddyProfileResult_successCount record
  , (\_v1129 -> P.Just (13, ("failCount",T.TI64 _v1129))) $ updateBuddyProfileResult_failCount record
  , (\_v1129 -> P.Just (14, ("cancelCount",T.TI64 _v1129))) $ updateBuddyProfileResult_cancelCount record
  , (\_v1129 -> P.Just (15, ("unregisterCount",T.TI64 _v1129))) $ updateBuddyProfileResult_unregisterCount record
  , (\_v1129 -> P.Just (21, ("timestamp",T.TI64 _v1129))) $ updateBuddyProfileResult_timestamp record
  , (\_v1129 -> P.Just (22, ("message",T.TString $ E.encodeUtf8 _v1129))) $ updateBuddyProfileResult_message record
  ]
write_UpdateBuddyProfileResult :: T.Protocol p => p -> UpdateBuddyProfileResult -> P.IO ()
write_UpdateBuddyProfileResult oprot record = T.writeVal oprot $ from_UpdateBuddyProfileResult record
encode_UpdateBuddyProfileResult :: T.StatelessProtocol p => p -> UpdateBuddyProfileResult -> LBS.ByteString
encode_UpdateBuddyProfileResult oprot record = T.serializeVal oprot $ from_UpdateBuddyProfileResult record
to_UpdateBuddyProfileResult :: T.ThriftVal -> UpdateBuddyProfileResult
to_UpdateBuddyProfileResult (T.TStruct fields) = UpdateBuddyProfileResult{
  updateBuddyProfileResult_requestId = P.maybe (updateBuddyProfileResult_requestId default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TString _val1132 -> E.decodeUtf8 _val1132; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateBuddyProfileResult_state = P.maybe (updateBuddyProfileResult_state default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI32 _val1133 -> P.toEnum $ P.fromIntegral _val1133; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateBuddyProfileResult_eventNo = P.maybe (updateBuddyProfileResult_eventNo default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI32 _val1134 -> _val1134; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateBuddyProfileResult_receiverCount = P.maybe (updateBuddyProfileResult_receiverCount default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI64 _val1135 -> _val1135; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  updateBuddyProfileResult_successCount = P.maybe (updateBuddyProfileResult_successCount default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI64 _val1136 -> _val1136; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  updateBuddyProfileResult_failCount = P.maybe (updateBuddyProfileResult_failCount default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI64 _val1137 -> _val1137; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  updateBuddyProfileResult_cancelCount = P.maybe (updateBuddyProfileResult_cancelCount default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI64 _val1138 -> _val1138; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  updateBuddyProfileResult_unregisterCount = P.maybe (updateBuddyProfileResult_unregisterCount default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI64 _val1139 -> _val1139; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  updateBuddyProfileResult_timestamp = P.maybe (updateBuddyProfileResult_timestamp default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TI64 _val1140 -> _val1140; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  updateBuddyProfileResult_message = P.maybe (updateBuddyProfileResult_message default_UpdateBuddyProfileResult) (\(_,_val1131) -> (case _val1131 of {T.TString _val1141 -> E.decodeUtf8 _val1141; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_UpdateBuddyProfileResult _ = P.error "not a struct"
read_UpdateBuddyProfileResult :: T.Protocol p => p -> P.IO UpdateBuddyProfileResult
read_UpdateBuddyProfileResult iprot = to_UpdateBuddyProfileResult <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBuddyProfileResult)
decode_UpdateBuddyProfileResult :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBuddyProfileResult
decode_UpdateBuddyProfileResult iprot bs = to_UpdateBuddyProfileResult $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBuddyProfileResult) bs
typemap_UpdateBuddyProfileResult :: T.TypeMap
typemap_UpdateBuddyProfileResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("state",T.T_I32)),(3,("eventNo",T.T_I32)),(11,("receiverCount",T.T_I64)),(12,("successCount",T.T_I64)),(13,("failCount",T.T_I64)),(14,("cancelCount",T.T_I64)),(15,("unregisterCount",T.T_I64)),(21,("timestamp",T.T_I64)),(22,("message",T.T_STRING))]
default_UpdateBuddyProfileResult :: UpdateBuddyProfileResult
default_UpdateBuddyProfileResult = UpdateBuddyProfileResult{
  updateBuddyProfileResult_requestId = "",
  updateBuddyProfileResult_state = (P.toEnum 0),
  updateBuddyProfileResult_eventNo = 0,
  updateBuddyProfileResult_receiverCount = 0,
  updateBuddyProfileResult_successCount = 0,
  updateBuddyProfileResult_failCount = 0,
  updateBuddyProfileResult_cancelCount = 0,
  updateBuddyProfileResult_unregisterCount = 0,
  updateBuddyProfileResult_timestamp = 0,
  updateBuddyProfileResult_message = ""}
data UserAuthStatus = UserAuthStatus  { userAuthStatus_phoneNumberRegistered :: P.Bool
  , userAuthStatus_registeredSnsIdTypes :: (Vector.Vector SnsIdType)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserAuthStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` userAuthStatus_phoneNumberRegistered record   `H.hashWithSalt` userAuthStatus_registeredSnsIdTypes record  
instance QC.Arbitrary UserAuthStatus where 
  arbitrary = M.liftM UserAuthStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UserAuthStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserAuthStatus{userAuthStatus_phoneNumberRegistered = userAuthStatus_phoneNumberRegistered obj} then P.Nothing else P.Just $ default_UserAuthStatus{userAuthStatus_phoneNumberRegistered = userAuthStatus_phoneNumberRegistered obj}
    , if obj == default_UserAuthStatus{userAuthStatus_registeredSnsIdTypes = userAuthStatus_registeredSnsIdTypes obj} then P.Nothing else P.Just $ default_UserAuthStatus{userAuthStatus_registeredSnsIdTypes = userAuthStatus_registeredSnsIdTypes obj}
    ]
from_UserAuthStatus :: UserAuthStatus -> T.ThriftVal
from_UserAuthStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1144 -> P.Just (1, ("phoneNumberRegistered",T.TBool _v1144))) $ userAuthStatus_phoneNumberRegistered record
  , (\_v1144 -> P.Just (2, ("registeredSnsIdTypes",T.TList T.T_I32 $ P.map (\_v1146 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v1146) $ Vector.toList _v1144))) $ userAuthStatus_registeredSnsIdTypes record
  ]
write_UserAuthStatus :: T.Protocol p => p -> UserAuthStatus -> P.IO ()
write_UserAuthStatus oprot record = T.writeVal oprot $ from_UserAuthStatus record
encode_UserAuthStatus :: T.StatelessProtocol p => p -> UserAuthStatus -> LBS.ByteString
encode_UserAuthStatus oprot record = T.serializeVal oprot $ from_UserAuthStatus record
to_UserAuthStatus :: T.ThriftVal -> UserAuthStatus
to_UserAuthStatus (T.TStruct fields) = UserAuthStatus{
  userAuthStatus_phoneNumberRegistered = P.maybe (userAuthStatus_phoneNumberRegistered default_UserAuthStatus) (\(_,_val1148) -> (case _val1148 of {T.TBool _val1149 -> _val1149; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userAuthStatus_registeredSnsIdTypes = P.maybe (userAuthStatus_registeredSnsIdTypes default_UserAuthStatus) (\(_,_val1148) -> (case _val1148 of {T.TList _ _val1150 -> (Vector.fromList $ P.map (\_v1151 -> (case _v1151 of {T.TI32 _val1152 -> P.toEnum $ P.fromIntegral _val1152; _ -> P.error "wrong type"})) _val1150); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UserAuthStatus _ = P.error "not a struct"
read_UserAuthStatus :: T.Protocol p => p -> P.IO UserAuthStatus
read_UserAuthStatus iprot = to_UserAuthStatus <$> T.readVal iprot (T.T_STRUCT typemap_UserAuthStatus)
decode_UserAuthStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> UserAuthStatus
decode_UserAuthStatus iprot bs = to_UserAuthStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_UserAuthStatus) bs
typemap_UserAuthStatus :: T.TypeMap
typemap_UserAuthStatus = Map.fromList [(1,("phoneNumberRegistered",T.T_BOOL)),(2,("registeredSnsIdTypes",(T.T_LIST T.T_I32)))]
default_UserAuthStatus :: UserAuthStatus
default_UserAuthStatus = UserAuthStatus{
  userAuthStatus_phoneNumberRegistered = P.False,
  userAuthStatus_registeredSnsIdTypes = Vector.empty}
data VerificationSessionData = VerificationSessionData  { verificationSessionData_sessionId :: LT.Text
  , verificationSessionData_method :: VerificationMethod
  , verificationSessionData_callback :: LT.Text
  , verificationSessionData_normalizedPhone :: LT.Text
  , verificationSessionData_countryCode :: LT.Text
  , verificationSessionData_nationalSignificantNumber :: LT.Text
  , verificationSessionData_availableVerificationMethods :: (Vector.Vector VerificationMethod)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerificationSessionData where
  hashWithSalt salt record = salt   `H.hashWithSalt` verificationSessionData_sessionId record   `H.hashWithSalt` verificationSessionData_method record   `H.hashWithSalt` verificationSessionData_callback record   `H.hashWithSalt` verificationSessionData_normalizedPhone record   `H.hashWithSalt` verificationSessionData_countryCode record   `H.hashWithSalt` verificationSessionData_nationalSignificantNumber record   `H.hashWithSalt` verificationSessionData_availableVerificationMethods record  
instance QC.Arbitrary VerificationSessionData where 
  arbitrary = M.liftM VerificationSessionData (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerificationSessionData = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerificationSessionData{verificationSessionData_sessionId = verificationSessionData_sessionId obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_sessionId = verificationSessionData_sessionId obj}
    , if obj == default_VerificationSessionData{verificationSessionData_method = verificationSessionData_method obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_method = verificationSessionData_method obj}
    , if obj == default_VerificationSessionData{verificationSessionData_callback = verificationSessionData_callback obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_callback = verificationSessionData_callback obj}
    , if obj == default_VerificationSessionData{verificationSessionData_normalizedPhone = verificationSessionData_normalizedPhone obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_normalizedPhone = verificationSessionData_normalizedPhone obj}
    , if obj == default_VerificationSessionData{verificationSessionData_countryCode = verificationSessionData_countryCode obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_countryCode = verificationSessionData_countryCode obj}
    , if obj == default_VerificationSessionData{verificationSessionData_nationalSignificantNumber = verificationSessionData_nationalSignificantNumber obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_nationalSignificantNumber = verificationSessionData_nationalSignificantNumber obj}
    , if obj == default_VerificationSessionData{verificationSessionData_availableVerificationMethods = verificationSessionData_availableVerificationMethods obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_availableVerificationMethods = verificationSessionData_availableVerificationMethods obj}
    ]
from_VerificationSessionData :: VerificationSessionData -> T.ThriftVal
from_VerificationSessionData record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1155 -> P.Just (1, ("sessionId",T.TString $ E.encodeUtf8 _v1155))) $ verificationSessionData_sessionId record
  , (\_v1155 -> P.Just (2, ("method",T.TI32 $ P.fromIntegral $ P.fromEnum _v1155))) $ verificationSessionData_method record
  , (\_v1155 -> P.Just (3, ("callback",T.TString $ E.encodeUtf8 _v1155))) $ verificationSessionData_callback record
  , (\_v1155 -> P.Just (4, ("normalizedPhone",T.TString $ E.encodeUtf8 _v1155))) $ verificationSessionData_normalizedPhone record
  , (\_v1155 -> P.Just (5, ("countryCode",T.TString $ E.encodeUtf8 _v1155))) $ verificationSessionData_countryCode record
  , (\_v1155 -> P.Just (6, ("nationalSignificantNumber",T.TString $ E.encodeUtf8 _v1155))) $ verificationSessionData_nationalSignificantNumber record
  , (\_v1155 -> P.Just (7, ("availableVerificationMethods",T.TList T.T_I32 $ P.map (\_v1157 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v1157) $ Vector.toList _v1155))) $ verificationSessionData_availableVerificationMethods record
  ]
write_VerificationSessionData :: T.Protocol p => p -> VerificationSessionData -> P.IO ()
write_VerificationSessionData oprot record = T.writeVal oprot $ from_VerificationSessionData record
encode_VerificationSessionData :: T.StatelessProtocol p => p -> VerificationSessionData -> LBS.ByteString
encode_VerificationSessionData oprot record = T.serializeVal oprot $ from_VerificationSessionData record
to_VerificationSessionData :: T.ThriftVal -> VerificationSessionData
to_VerificationSessionData (T.TStruct fields) = VerificationSessionData{
  verificationSessionData_sessionId = P.maybe (verificationSessionData_sessionId default_VerificationSessionData) (\(_,_val1159) -> (case _val1159 of {T.TString _val1160 -> E.decodeUtf8 _val1160; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  verificationSessionData_method = P.maybe (verificationSessionData_method default_VerificationSessionData) (\(_,_val1159) -> (case _val1159 of {T.TI32 _val1161 -> P.toEnum $ P.fromIntegral _val1161; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verificationSessionData_callback = P.maybe (verificationSessionData_callback default_VerificationSessionData) (\(_,_val1159) -> (case _val1159 of {T.TString _val1162 -> E.decodeUtf8 _val1162; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verificationSessionData_normalizedPhone = P.maybe (verificationSessionData_normalizedPhone default_VerificationSessionData) (\(_,_val1159) -> (case _val1159 of {T.TString _val1163 -> E.decodeUtf8 _val1163; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  verificationSessionData_countryCode = P.maybe (verificationSessionData_countryCode default_VerificationSessionData) (\(_,_val1159) -> (case _val1159 of {T.TString _val1164 -> E.decodeUtf8 _val1164; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  verificationSessionData_nationalSignificantNumber = P.maybe (verificationSessionData_nationalSignificantNumber default_VerificationSessionData) (\(_,_val1159) -> (case _val1159 of {T.TString _val1165 -> E.decodeUtf8 _val1165; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  verificationSessionData_availableVerificationMethods = P.maybe (verificationSessionData_availableVerificationMethods default_VerificationSessionData) (\(_,_val1159) -> (case _val1159 of {T.TList _ _val1166 -> (Vector.fromList $ P.map (\_v1167 -> (case _v1167 of {T.TI32 _val1168 -> P.toEnum $ P.fromIntegral _val1168; _ -> P.error "wrong type"})) _val1166); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_VerificationSessionData _ = P.error "not a struct"
read_VerificationSessionData :: T.Protocol p => p -> P.IO VerificationSessionData
read_VerificationSessionData iprot = to_VerificationSessionData <$> T.readVal iprot (T.T_STRUCT typemap_VerificationSessionData)
decode_VerificationSessionData :: T.StatelessProtocol p => p -> LBS.ByteString -> VerificationSessionData
decode_VerificationSessionData iprot bs = to_VerificationSessionData $ T.deserializeVal iprot (T.T_STRUCT typemap_VerificationSessionData) bs
typemap_VerificationSessionData :: T.TypeMap
typemap_VerificationSessionData = Map.fromList [(1,("sessionId",T.T_STRING)),(2,("method",T.T_I32)),(3,("callback",T.T_STRING)),(4,("normalizedPhone",T.T_STRING)),(5,("countryCode",T.T_STRING)),(6,("nationalSignificantNumber",T.T_STRING)),(7,("availableVerificationMethods",(T.T_LIST T.T_I32)))]
default_VerificationSessionData :: VerificationSessionData
default_VerificationSessionData = VerificationSessionData{
  verificationSessionData_sessionId = "",
  verificationSessionData_method = (P.toEnum 0),
  verificationSessionData_callback = "",
  verificationSessionData_normalizedPhone = "",
  verificationSessionData_countryCode = "",
  verificationSessionData_nationalSignificantNumber = "",
  verificationSessionData_availableVerificationMethods = Vector.empty}
data WapInvitation = WapInvitation  { wapInvitation_type :: WapInvitationType
  , wapInvitation_inviteeEmail :: LT.Text
  , wapInvitation_inviterMid :: LT.Text
  , wapInvitation_roomMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable WapInvitation where
  hashWithSalt salt record = salt   `H.hashWithSalt` wapInvitation_type record   `H.hashWithSalt` wapInvitation_inviteeEmail record   `H.hashWithSalt` wapInvitation_inviterMid record   `H.hashWithSalt` wapInvitation_roomMid record  
instance QC.Arbitrary WapInvitation where 
  arbitrary = M.liftM WapInvitation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_WapInvitation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_WapInvitation{wapInvitation_type = wapInvitation_type obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_type = wapInvitation_type obj}
    , if obj == default_WapInvitation{wapInvitation_inviteeEmail = wapInvitation_inviteeEmail obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_inviteeEmail = wapInvitation_inviteeEmail obj}
    , if obj == default_WapInvitation{wapInvitation_inviterMid = wapInvitation_inviterMid obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_inviterMid = wapInvitation_inviterMid obj}
    , if obj == default_WapInvitation{wapInvitation_roomMid = wapInvitation_roomMid obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_roomMid = wapInvitation_roomMid obj}
    ]
from_WapInvitation :: WapInvitation -> T.ThriftVal
from_WapInvitation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1171 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v1171))) $ wapInvitation_type record
  , (\_v1171 -> P.Just (10, ("inviteeEmail",T.TString $ E.encodeUtf8 _v1171))) $ wapInvitation_inviteeEmail record
  , (\_v1171 -> P.Just (11, ("inviterMid",T.TString $ E.encodeUtf8 _v1171))) $ wapInvitation_inviterMid record
  , (\_v1171 -> P.Just (12, ("roomMid",T.TString $ E.encodeUtf8 _v1171))) $ wapInvitation_roomMid record
  ]
write_WapInvitation :: T.Protocol p => p -> WapInvitation -> P.IO ()
write_WapInvitation oprot record = T.writeVal oprot $ from_WapInvitation record
encode_WapInvitation :: T.StatelessProtocol p => p -> WapInvitation -> LBS.ByteString
encode_WapInvitation oprot record = T.serializeVal oprot $ from_WapInvitation record
to_WapInvitation :: T.ThriftVal -> WapInvitation
to_WapInvitation (T.TStruct fields) = WapInvitation{
  wapInvitation_type = P.maybe (wapInvitation_type default_WapInvitation) (\(_,_val1173) -> (case _val1173 of {T.TI32 _val1174 -> P.toEnum $ P.fromIntegral _val1174; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  wapInvitation_inviteeEmail = P.maybe (wapInvitation_inviteeEmail default_WapInvitation) (\(_,_val1173) -> (case _val1173 of {T.TString _val1175 -> E.decodeUtf8 _val1175; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  wapInvitation_inviterMid = P.maybe (wapInvitation_inviterMid default_WapInvitation) (\(_,_val1173) -> (case _val1173 of {T.TString _val1176 -> E.decodeUtf8 _val1176; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  wapInvitation_roomMid = P.maybe (wapInvitation_roomMid default_WapInvitation) (\(_,_val1173) -> (case _val1173 of {T.TString _val1177 -> E.decodeUtf8 _val1177; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_WapInvitation _ = P.error "not a struct"
read_WapInvitation :: T.Protocol p => p -> P.IO WapInvitation
read_WapInvitation iprot = to_WapInvitation <$> T.readVal iprot (T.T_STRUCT typemap_WapInvitation)
decode_WapInvitation :: T.StatelessProtocol p => p -> LBS.ByteString -> WapInvitation
decode_WapInvitation iprot bs = to_WapInvitation $ T.deserializeVal iprot (T.T_STRUCT typemap_WapInvitation) bs
typemap_WapInvitation :: T.TypeMap
typemap_WapInvitation = Map.fromList [(1,("type",T.T_I32)),(10,("inviteeEmail",T.T_STRING)),(11,("inviterMid",T.T_STRING)),(12,("roomMid",T.T_STRING))]
default_WapInvitation :: WapInvitation
default_WapInvitation = WapInvitation{
  wapInvitation_type = (P.toEnum 0),
  wapInvitation_inviteeEmail = "",
  wapInvitation_inviterMid = "",
  wapInvitation_roomMid = ""}
