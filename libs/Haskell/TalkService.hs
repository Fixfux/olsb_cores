{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module TalkService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified TalkService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data AcceptGroupInvitation_args = AcceptGroupInvitation_args  { acceptGroupInvitation_args_reqSeq :: I.Int32
  , acceptGroupInvitation_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptGroupInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptGroupInvitation_args_reqSeq record   `H.hashWithSalt` acceptGroupInvitation_args_groupId record  
instance QC.Arbitrary AcceptGroupInvitation_args where 
  arbitrary = M.liftM AcceptGroupInvitation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcceptGroupInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptGroupInvitation_args{acceptGroupInvitation_args_reqSeq = acceptGroupInvitation_args_reqSeq obj} then P.Nothing else P.Just $ default_AcceptGroupInvitation_args{acceptGroupInvitation_args_reqSeq = acceptGroupInvitation_args_reqSeq obj}
    , if obj == default_AcceptGroupInvitation_args{acceptGroupInvitation_args_groupId = acceptGroupInvitation_args_groupId obj} then P.Nothing else P.Just $ default_AcceptGroupInvitation_args{acceptGroupInvitation_args_groupId = acceptGroupInvitation_args_groupId obj}
    ]
from_AcceptGroupInvitation_args :: AcceptGroupInvitation_args -> T.ThriftVal
from_AcceptGroupInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3527 -> P.Just (1, ("reqSeq",T.TI32 _v3527))) $ acceptGroupInvitation_args_reqSeq record
  , (\_v3527 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v3527))) $ acceptGroupInvitation_args_groupId record
  ]
write_AcceptGroupInvitation_args :: T.Protocol p => p -> AcceptGroupInvitation_args -> P.IO ()
write_AcceptGroupInvitation_args oprot record = T.writeVal oprot $ from_AcceptGroupInvitation_args record
encode_AcceptGroupInvitation_args :: T.StatelessProtocol p => p -> AcceptGroupInvitation_args -> LBS.ByteString
encode_AcceptGroupInvitation_args oprot record = T.serializeVal oprot $ from_AcceptGroupInvitation_args record
to_AcceptGroupInvitation_args :: T.ThriftVal -> AcceptGroupInvitation_args
to_AcceptGroupInvitation_args (T.TStruct fields) = AcceptGroupInvitation_args{
  acceptGroupInvitation_args_reqSeq = P.maybe (acceptGroupInvitation_args_reqSeq default_AcceptGroupInvitation_args) (\(_,_val3529) -> (case _val3529 of {T.TI32 _val3530 -> _val3530; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  acceptGroupInvitation_args_groupId = P.maybe (acceptGroupInvitation_args_groupId default_AcceptGroupInvitation_args) (\(_,_val3529) -> (case _val3529 of {T.TString _val3531 -> E.decodeUtf8 _val3531; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcceptGroupInvitation_args _ = P.error "not a struct"
read_AcceptGroupInvitation_args :: T.Protocol p => p -> P.IO AcceptGroupInvitation_args
read_AcceptGroupInvitation_args iprot = to_AcceptGroupInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_args)
decode_AcceptGroupInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptGroupInvitation_args
decode_AcceptGroupInvitation_args iprot bs = to_AcceptGroupInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_args) bs
typemap_AcceptGroupInvitation_args :: T.TypeMap
typemap_AcceptGroupInvitation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING))]
default_AcceptGroupInvitation_args :: AcceptGroupInvitation_args
default_AcceptGroupInvitation_args = AcceptGroupInvitation_args{
  acceptGroupInvitation_args_reqSeq = 0,
  acceptGroupInvitation_args_groupId = ""}
data AcceptGroupInvitation_result = AcceptGroupInvitation_result  { acceptGroupInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptGroupInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptGroupInvitation_result_e record  
instance QC.Arbitrary AcceptGroupInvitation_result where 
  arbitrary = M.liftM AcceptGroupInvitation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcceptGroupInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptGroupInvitation_result{acceptGroupInvitation_result_e = acceptGroupInvitation_result_e obj} then P.Nothing else P.Just $ default_AcceptGroupInvitation_result{acceptGroupInvitation_result_e = acceptGroupInvitation_result_e obj}
    ]
from_AcceptGroupInvitation_result :: AcceptGroupInvitation_result -> T.ThriftVal
from_AcceptGroupInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3534 -> (1, ("e",from_TalkException _v3534))) <$> acceptGroupInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3534 -> (1, ("e",from_TalkException _v3534))) <$> acceptGroupInvitation_result_e record
    ]
    )
write_AcceptGroupInvitation_result :: T.Protocol p => p -> AcceptGroupInvitation_result -> P.IO ()
write_AcceptGroupInvitation_result oprot record = T.writeVal oprot $ from_AcceptGroupInvitation_result record
encode_AcceptGroupInvitation_result :: T.StatelessProtocol p => p -> AcceptGroupInvitation_result -> LBS.ByteString
encode_AcceptGroupInvitation_result oprot record = T.serializeVal oprot $ from_AcceptGroupInvitation_result record
to_AcceptGroupInvitation_result :: T.ThriftVal -> AcceptGroupInvitation_result
to_AcceptGroupInvitation_result (T.TStruct fields) = AcceptGroupInvitation_result{
  acceptGroupInvitation_result_e = P.maybe (P.Nothing) (\(_,_val3536) -> P.Just (case _val3536 of {T.TStruct _val3537 -> (to_TalkException (T.TStruct _val3537)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcceptGroupInvitation_result _ = P.error "not a struct"
read_AcceptGroupInvitation_result :: T.Protocol p => p -> P.IO AcceptGroupInvitation_result
read_AcceptGroupInvitation_result iprot = to_AcceptGroupInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_result)
decode_AcceptGroupInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptGroupInvitation_result
decode_AcceptGroupInvitation_result iprot bs = to_AcceptGroupInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_result) bs
typemap_AcceptGroupInvitation_result :: T.TypeMap
typemap_AcceptGroupInvitation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcceptGroupInvitation_result :: AcceptGroupInvitation_result
default_AcceptGroupInvitation_result = AcceptGroupInvitation_result{
  acceptGroupInvitation_result_e = P.Nothing}
data AcceptProximityMatches_args = AcceptProximityMatches_args  { acceptProximityMatches_args_sessionId :: LT.Text
  , acceptProximityMatches_args_ids :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptProximityMatches_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptProximityMatches_args_sessionId record   `H.hashWithSalt` acceptProximityMatches_args_ids record  
instance QC.Arbitrary AcceptProximityMatches_args where 
  arbitrary = M.liftM AcceptProximityMatches_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcceptProximityMatches_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptProximityMatches_args{acceptProximityMatches_args_sessionId = acceptProximityMatches_args_sessionId obj} then P.Nothing else P.Just $ default_AcceptProximityMatches_args{acceptProximityMatches_args_sessionId = acceptProximityMatches_args_sessionId obj}
    , if obj == default_AcceptProximityMatches_args{acceptProximityMatches_args_ids = acceptProximityMatches_args_ids obj} then P.Nothing else P.Just $ default_AcceptProximityMatches_args{acceptProximityMatches_args_ids = acceptProximityMatches_args_ids obj}
    ]
from_AcceptProximityMatches_args :: AcceptProximityMatches_args -> T.ThriftVal
from_AcceptProximityMatches_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3540 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v3540))) $ acceptProximityMatches_args_sessionId record
  , (\_v3540 -> P.Just (3, ("ids",T.TSet T.T_STRING $ P.map (\_v3542 -> T.TString $ E.encodeUtf8 _v3542) $ Set.toList _v3540))) $ acceptProximityMatches_args_ids record
  ]
write_AcceptProximityMatches_args :: T.Protocol p => p -> AcceptProximityMatches_args -> P.IO ()
write_AcceptProximityMatches_args oprot record = T.writeVal oprot $ from_AcceptProximityMatches_args record
encode_AcceptProximityMatches_args :: T.StatelessProtocol p => p -> AcceptProximityMatches_args -> LBS.ByteString
encode_AcceptProximityMatches_args oprot record = T.serializeVal oprot $ from_AcceptProximityMatches_args record
to_AcceptProximityMatches_args :: T.ThriftVal -> AcceptProximityMatches_args
to_AcceptProximityMatches_args (T.TStruct fields) = AcceptProximityMatches_args{
  acceptProximityMatches_args_sessionId = P.maybe (acceptProximityMatches_args_sessionId default_AcceptProximityMatches_args) (\(_,_val3544) -> (case _val3544 of {T.TString _val3545 -> E.decodeUtf8 _val3545; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  acceptProximityMatches_args_ids = P.maybe (acceptProximityMatches_args_ids default_AcceptProximityMatches_args) (\(_,_val3544) -> (case _val3544 of {T.TSet _ _val3546 -> (Set.fromList $ P.map (\_v3547 -> (case _v3547 of {T.TString _val3548 -> E.decodeUtf8 _val3548; _ -> P.error "wrong type"})) _val3546); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AcceptProximityMatches_args _ = P.error "not a struct"
read_AcceptProximityMatches_args :: T.Protocol p => p -> P.IO AcceptProximityMatches_args
read_AcceptProximityMatches_args iprot = to_AcceptProximityMatches_args <$> T.readVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_args)
decode_AcceptProximityMatches_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptProximityMatches_args
decode_AcceptProximityMatches_args iprot bs = to_AcceptProximityMatches_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_args) bs
typemap_AcceptProximityMatches_args :: T.TypeMap
typemap_AcceptProximityMatches_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("ids",(T.T_SET T.T_STRING)))]
default_AcceptProximityMatches_args :: AcceptProximityMatches_args
default_AcceptProximityMatches_args = AcceptProximityMatches_args{
  acceptProximityMatches_args_sessionId = "",
  acceptProximityMatches_args_ids = Set.empty}
data AcceptProximityMatches_result = AcceptProximityMatches_result  { acceptProximityMatches_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptProximityMatches_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptProximityMatches_result_e record  
instance QC.Arbitrary AcceptProximityMatches_result where 
  arbitrary = M.liftM AcceptProximityMatches_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcceptProximityMatches_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptProximityMatches_result{acceptProximityMatches_result_e = acceptProximityMatches_result_e obj} then P.Nothing else P.Just $ default_AcceptProximityMatches_result{acceptProximityMatches_result_e = acceptProximityMatches_result_e obj}
    ]
from_AcceptProximityMatches_result :: AcceptProximityMatches_result -> T.ThriftVal
from_AcceptProximityMatches_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3551 -> (1, ("e",from_TalkException _v3551))) <$> acceptProximityMatches_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3551 -> (1, ("e",from_TalkException _v3551))) <$> acceptProximityMatches_result_e record
    ]
    )
write_AcceptProximityMatches_result :: T.Protocol p => p -> AcceptProximityMatches_result -> P.IO ()
write_AcceptProximityMatches_result oprot record = T.writeVal oprot $ from_AcceptProximityMatches_result record
encode_AcceptProximityMatches_result :: T.StatelessProtocol p => p -> AcceptProximityMatches_result -> LBS.ByteString
encode_AcceptProximityMatches_result oprot record = T.serializeVal oprot $ from_AcceptProximityMatches_result record
to_AcceptProximityMatches_result :: T.ThriftVal -> AcceptProximityMatches_result
to_AcceptProximityMatches_result (T.TStruct fields) = AcceptProximityMatches_result{
  acceptProximityMatches_result_e = P.maybe (P.Nothing) (\(_,_val3553) -> P.Just (case _val3553 of {T.TStruct _val3554 -> (to_TalkException (T.TStruct _val3554)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcceptProximityMatches_result _ = P.error "not a struct"
read_AcceptProximityMatches_result :: T.Protocol p => p -> P.IO AcceptProximityMatches_result
read_AcceptProximityMatches_result iprot = to_AcceptProximityMatches_result <$> T.readVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_result)
decode_AcceptProximityMatches_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptProximityMatches_result
decode_AcceptProximityMatches_result iprot bs = to_AcceptProximityMatches_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_result) bs
typemap_AcceptProximityMatches_result :: T.TypeMap
typemap_AcceptProximityMatches_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcceptProximityMatches_result :: AcceptProximityMatches_result
default_AcceptProximityMatches_result = AcceptProximityMatches_result{
  acceptProximityMatches_result_e = P.Nothing}
data AcquireCallRoute_args = AcquireCallRoute_args  { acquireCallRoute_args_to :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallRoute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallRoute_args_to record  
instance QC.Arbitrary AcquireCallRoute_args where 
  arbitrary = M.liftM AcquireCallRoute_args (QC.arbitrary)
  shrink obj | obj == default_AcquireCallRoute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallRoute_args{acquireCallRoute_args_to = acquireCallRoute_args_to obj} then P.Nothing else P.Just $ default_AcquireCallRoute_args{acquireCallRoute_args_to = acquireCallRoute_args_to obj}
    ]
from_AcquireCallRoute_args :: AcquireCallRoute_args -> T.ThriftVal
from_AcquireCallRoute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3557 -> P.Just (2, ("to",T.TString $ E.encodeUtf8 _v3557))) $ acquireCallRoute_args_to record
  ]
write_AcquireCallRoute_args :: T.Protocol p => p -> AcquireCallRoute_args -> P.IO ()
write_AcquireCallRoute_args oprot record = T.writeVal oprot $ from_AcquireCallRoute_args record
encode_AcquireCallRoute_args :: T.StatelessProtocol p => p -> AcquireCallRoute_args -> LBS.ByteString
encode_AcquireCallRoute_args oprot record = T.serializeVal oprot $ from_AcquireCallRoute_args record
to_AcquireCallRoute_args :: T.ThriftVal -> AcquireCallRoute_args
to_AcquireCallRoute_args (T.TStruct fields) = AcquireCallRoute_args{
  acquireCallRoute_args_to = P.maybe (acquireCallRoute_args_to default_AcquireCallRoute_args) (\(_,_val3559) -> (case _val3559 of {T.TString _val3560 -> E.decodeUtf8 _val3560; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquireCallRoute_args _ = P.error "not a struct"
read_AcquireCallRoute_args :: T.Protocol p => p -> P.IO AcquireCallRoute_args
read_AcquireCallRoute_args iprot = to_AcquireCallRoute_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallRoute_args)
decode_AcquireCallRoute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallRoute_args
decode_AcquireCallRoute_args iprot bs = to_AcquireCallRoute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallRoute_args) bs
typemap_AcquireCallRoute_args :: T.TypeMap
typemap_AcquireCallRoute_args = Map.fromList [(2,("to",T.T_STRING))]
default_AcquireCallRoute_args :: AcquireCallRoute_args
default_AcquireCallRoute_args = AcquireCallRoute_args{
  acquireCallRoute_args_to = ""}
data AcquireCallRoute_result = AcquireCallRoute_result  { acquireCallRoute_result_success :: (Vector.Vector LT.Text)
  , acquireCallRoute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallRoute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallRoute_result_success record   `H.hashWithSalt` acquireCallRoute_result_e record  
instance QC.Arbitrary AcquireCallRoute_result where 
  arbitrary = M.liftM AcquireCallRoute_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireCallRoute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallRoute_result{acquireCallRoute_result_success = acquireCallRoute_result_success obj} then P.Nothing else P.Just $ default_AcquireCallRoute_result{acquireCallRoute_result_success = acquireCallRoute_result_success obj}
    , if obj == default_AcquireCallRoute_result{acquireCallRoute_result_e = acquireCallRoute_result_e obj} then P.Nothing else P.Just $ default_AcquireCallRoute_result{acquireCallRoute_result_e = acquireCallRoute_result_e obj}
    ]
from_AcquireCallRoute_result :: AcquireCallRoute_result -> T.ThriftVal
from_AcquireCallRoute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3563 -> (1, ("e",from_TalkException _v3563))) <$> acquireCallRoute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3563 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v3565 -> T.TString $ E.encodeUtf8 _v3565) $ Vector.toList _v3563))) $ acquireCallRoute_result_success record
    , (\_v3563 -> (1, ("e",from_TalkException _v3563))) <$> acquireCallRoute_result_e record
    ]
    )
write_AcquireCallRoute_result :: T.Protocol p => p -> AcquireCallRoute_result -> P.IO ()
write_AcquireCallRoute_result oprot record = T.writeVal oprot $ from_AcquireCallRoute_result record
encode_AcquireCallRoute_result :: T.StatelessProtocol p => p -> AcquireCallRoute_result -> LBS.ByteString
encode_AcquireCallRoute_result oprot record = T.serializeVal oprot $ from_AcquireCallRoute_result record
to_AcquireCallRoute_result :: T.ThriftVal -> AcquireCallRoute_result
to_AcquireCallRoute_result (T.TStruct fields) = AcquireCallRoute_result{
  acquireCallRoute_result_success = P.maybe (acquireCallRoute_result_success default_AcquireCallRoute_result) (\(_,_val3567) -> (case _val3567 of {T.TList _ _val3568 -> (Vector.fromList $ P.map (\_v3569 -> (case _v3569 of {T.TString _val3570 -> E.decodeUtf8 _val3570; _ -> P.error "wrong type"})) _val3568); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireCallRoute_result_e = P.maybe (P.Nothing) (\(_,_val3567) -> P.Just (case _val3567 of {T.TStruct _val3571 -> (to_TalkException (T.TStruct _val3571)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireCallRoute_result _ = P.error "not a struct"
read_AcquireCallRoute_result :: T.Protocol p => p -> P.IO AcquireCallRoute_result
read_AcquireCallRoute_result iprot = to_AcquireCallRoute_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallRoute_result)
decode_AcquireCallRoute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallRoute_result
decode_AcquireCallRoute_result iprot bs = to_AcquireCallRoute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallRoute_result) bs
typemap_AcquireCallRoute_result :: T.TypeMap
typemap_AcquireCallRoute_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireCallRoute_result :: AcquireCallRoute_result
default_AcquireCallRoute_result = AcquireCallRoute_result{
  acquireCallRoute_result_success = Vector.empty,
  acquireCallRoute_result_e = P.Nothing}
data AcquireCallTicket_args = AcquireCallTicket_args  { acquireCallTicket_args_to :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallTicket_args_to record  
instance QC.Arbitrary AcquireCallTicket_args where 
  arbitrary = M.liftM AcquireCallTicket_args (QC.arbitrary)
  shrink obj | obj == default_AcquireCallTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallTicket_args{acquireCallTicket_args_to = acquireCallTicket_args_to obj} then P.Nothing else P.Just $ default_AcquireCallTicket_args{acquireCallTicket_args_to = acquireCallTicket_args_to obj}
    ]
from_AcquireCallTicket_args :: AcquireCallTicket_args -> T.ThriftVal
from_AcquireCallTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3574 -> P.Just (2, ("to",T.TString $ E.encodeUtf8 _v3574))) $ acquireCallTicket_args_to record
  ]
write_AcquireCallTicket_args :: T.Protocol p => p -> AcquireCallTicket_args -> P.IO ()
write_AcquireCallTicket_args oprot record = T.writeVal oprot $ from_AcquireCallTicket_args record
encode_AcquireCallTicket_args :: T.StatelessProtocol p => p -> AcquireCallTicket_args -> LBS.ByteString
encode_AcquireCallTicket_args oprot record = T.serializeVal oprot $ from_AcquireCallTicket_args record
to_AcquireCallTicket_args :: T.ThriftVal -> AcquireCallTicket_args
to_AcquireCallTicket_args (T.TStruct fields) = AcquireCallTicket_args{
  acquireCallTicket_args_to = P.maybe (acquireCallTicket_args_to default_AcquireCallTicket_args) (\(_,_val3576) -> (case _val3576 of {T.TString _val3577 -> E.decodeUtf8 _val3577; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquireCallTicket_args _ = P.error "not a struct"
read_AcquireCallTicket_args :: T.Protocol p => p -> P.IO AcquireCallTicket_args
read_AcquireCallTicket_args iprot = to_AcquireCallTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallTicket_args)
decode_AcquireCallTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallTicket_args
decode_AcquireCallTicket_args iprot bs = to_AcquireCallTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallTicket_args) bs
typemap_AcquireCallTicket_args :: T.TypeMap
typemap_AcquireCallTicket_args = Map.fromList [(2,("to",T.T_STRING))]
default_AcquireCallTicket_args :: AcquireCallTicket_args
default_AcquireCallTicket_args = AcquireCallTicket_args{
  acquireCallTicket_args_to = ""}
data AcquireCallTicket_result = AcquireCallTicket_result  { acquireCallTicket_result_success :: LT.Text
  , acquireCallTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallTicket_result_success record   `H.hashWithSalt` acquireCallTicket_result_e record  
instance QC.Arbitrary AcquireCallTicket_result where 
  arbitrary = M.liftM AcquireCallTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireCallTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallTicket_result{acquireCallTicket_result_success = acquireCallTicket_result_success obj} then P.Nothing else P.Just $ default_AcquireCallTicket_result{acquireCallTicket_result_success = acquireCallTicket_result_success obj}
    , if obj == default_AcquireCallTicket_result{acquireCallTicket_result_e = acquireCallTicket_result_e obj} then P.Nothing else P.Just $ default_AcquireCallTicket_result{acquireCallTicket_result_e = acquireCallTicket_result_e obj}
    ]
from_AcquireCallTicket_result :: AcquireCallTicket_result -> T.ThriftVal
from_AcquireCallTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3580 -> (1, ("e",from_TalkException _v3580))) <$> acquireCallTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3580 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v3580))) $ acquireCallTicket_result_success record
    , (\_v3580 -> (1, ("e",from_TalkException _v3580))) <$> acquireCallTicket_result_e record
    ]
    )
write_AcquireCallTicket_result :: T.Protocol p => p -> AcquireCallTicket_result -> P.IO ()
write_AcquireCallTicket_result oprot record = T.writeVal oprot $ from_AcquireCallTicket_result record
encode_AcquireCallTicket_result :: T.StatelessProtocol p => p -> AcquireCallTicket_result -> LBS.ByteString
encode_AcquireCallTicket_result oprot record = T.serializeVal oprot $ from_AcquireCallTicket_result record
to_AcquireCallTicket_result :: T.ThriftVal -> AcquireCallTicket_result
to_AcquireCallTicket_result (T.TStruct fields) = AcquireCallTicket_result{
  acquireCallTicket_result_success = P.maybe (acquireCallTicket_result_success default_AcquireCallTicket_result) (\(_,_val3582) -> (case _val3582 of {T.TString _val3583 -> E.decodeUtf8 _val3583; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireCallTicket_result_e = P.maybe (P.Nothing) (\(_,_val3582) -> P.Just (case _val3582 of {T.TStruct _val3584 -> (to_TalkException (T.TStruct _val3584)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireCallTicket_result _ = P.error "not a struct"
read_AcquireCallTicket_result :: T.Protocol p => p -> P.IO AcquireCallTicket_result
read_AcquireCallTicket_result iprot = to_AcquireCallTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallTicket_result)
decode_AcquireCallTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallTicket_result
decode_AcquireCallTicket_result iprot bs = to_AcquireCallTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallTicket_result) bs
typemap_AcquireCallTicket_result :: T.TypeMap
typemap_AcquireCallTicket_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireCallTicket_result :: AcquireCallTicket_result
default_AcquireCallTicket_result = AcquireCallTicket_result{
  acquireCallTicket_result_success = "",
  acquireCallTicket_result_e = P.Nothing}
data AcquireEncryptedAccessToken_args = AcquireEncryptedAccessToken_args  { acquireEncryptedAccessToken_args_featureType :: FeatureType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireEncryptedAccessToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireEncryptedAccessToken_args_featureType record  
instance QC.Arbitrary AcquireEncryptedAccessToken_args where 
  arbitrary = M.liftM AcquireEncryptedAccessToken_args (QC.arbitrary)
  shrink obj | obj == default_AcquireEncryptedAccessToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireEncryptedAccessToken_args{acquireEncryptedAccessToken_args_featureType = acquireEncryptedAccessToken_args_featureType obj} then P.Nothing else P.Just $ default_AcquireEncryptedAccessToken_args{acquireEncryptedAccessToken_args_featureType = acquireEncryptedAccessToken_args_featureType obj}
    ]
from_AcquireEncryptedAccessToken_args :: AcquireEncryptedAccessToken_args -> T.ThriftVal
from_AcquireEncryptedAccessToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3587 -> P.Just (2, ("featureType",T.TI32 $ P.fromIntegral $ P.fromEnum _v3587))) $ acquireEncryptedAccessToken_args_featureType record
  ]
write_AcquireEncryptedAccessToken_args :: T.Protocol p => p -> AcquireEncryptedAccessToken_args -> P.IO ()
write_AcquireEncryptedAccessToken_args oprot record = T.writeVal oprot $ from_AcquireEncryptedAccessToken_args record
encode_AcquireEncryptedAccessToken_args :: T.StatelessProtocol p => p -> AcquireEncryptedAccessToken_args -> LBS.ByteString
encode_AcquireEncryptedAccessToken_args oprot record = T.serializeVal oprot $ from_AcquireEncryptedAccessToken_args record
to_AcquireEncryptedAccessToken_args :: T.ThriftVal -> AcquireEncryptedAccessToken_args
to_AcquireEncryptedAccessToken_args (T.TStruct fields) = AcquireEncryptedAccessToken_args{
  acquireEncryptedAccessToken_args_featureType = P.maybe (acquireEncryptedAccessToken_args_featureType default_AcquireEncryptedAccessToken_args) (\(_,_val3589) -> (case _val3589 of {T.TI32 _val3590 -> P.toEnum $ P.fromIntegral _val3590; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquireEncryptedAccessToken_args _ = P.error "not a struct"
read_AcquireEncryptedAccessToken_args :: T.Protocol p => p -> P.IO AcquireEncryptedAccessToken_args
read_AcquireEncryptedAccessToken_args iprot = to_AcquireEncryptedAccessToken_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_args)
decode_AcquireEncryptedAccessToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireEncryptedAccessToken_args
decode_AcquireEncryptedAccessToken_args iprot bs = to_AcquireEncryptedAccessToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_args) bs
typemap_AcquireEncryptedAccessToken_args :: T.TypeMap
typemap_AcquireEncryptedAccessToken_args = Map.fromList [(2,("featureType",T.T_I32))]
default_AcquireEncryptedAccessToken_args :: AcquireEncryptedAccessToken_args
default_AcquireEncryptedAccessToken_args = AcquireEncryptedAccessToken_args{
  acquireEncryptedAccessToken_args_featureType = (P.toEnum 0)}
data AcquireEncryptedAccessToken_result = AcquireEncryptedAccessToken_result  { acquireEncryptedAccessToken_result_success :: LT.Text
  , acquireEncryptedAccessToken_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireEncryptedAccessToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireEncryptedAccessToken_result_success record   `H.hashWithSalt` acquireEncryptedAccessToken_result_e record  
instance QC.Arbitrary AcquireEncryptedAccessToken_result where 
  arbitrary = M.liftM AcquireEncryptedAccessToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireEncryptedAccessToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_success = acquireEncryptedAccessToken_result_success obj} then P.Nothing else P.Just $ default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_success = acquireEncryptedAccessToken_result_success obj}
    , if obj == default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_e = acquireEncryptedAccessToken_result_e obj} then P.Nothing else P.Just $ default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_e = acquireEncryptedAccessToken_result_e obj}
    ]
from_AcquireEncryptedAccessToken_result :: AcquireEncryptedAccessToken_result -> T.ThriftVal
from_AcquireEncryptedAccessToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3593 -> (1, ("e",from_TalkException _v3593))) <$> acquireEncryptedAccessToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3593 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v3593))) $ acquireEncryptedAccessToken_result_success record
    , (\_v3593 -> (1, ("e",from_TalkException _v3593))) <$> acquireEncryptedAccessToken_result_e record
    ]
    )
write_AcquireEncryptedAccessToken_result :: T.Protocol p => p -> AcquireEncryptedAccessToken_result -> P.IO ()
write_AcquireEncryptedAccessToken_result oprot record = T.writeVal oprot $ from_AcquireEncryptedAccessToken_result record
encode_AcquireEncryptedAccessToken_result :: T.StatelessProtocol p => p -> AcquireEncryptedAccessToken_result -> LBS.ByteString
encode_AcquireEncryptedAccessToken_result oprot record = T.serializeVal oprot $ from_AcquireEncryptedAccessToken_result record
to_AcquireEncryptedAccessToken_result :: T.ThriftVal -> AcquireEncryptedAccessToken_result
to_AcquireEncryptedAccessToken_result (T.TStruct fields) = AcquireEncryptedAccessToken_result{
  acquireEncryptedAccessToken_result_success = P.maybe (acquireEncryptedAccessToken_result_success default_AcquireEncryptedAccessToken_result) (\(_,_val3595) -> (case _val3595 of {T.TString _val3596 -> E.decodeUtf8 _val3596; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireEncryptedAccessToken_result_e = P.maybe (P.Nothing) (\(_,_val3595) -> P.Just (case _val3595 of {T.TStruct _val3597 -> (to_TalkException (T.TStruct _val3597)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireEncryptedAccessToken_result _ = P.error "not a struct"
read_AcquireEncryptedAccessToken_result :: T.Protocol p => p -> P.IO AcquireEncryptedAccessToken_result
read_AcquireEncryptedAccessToken_result iprot = to_AcquireEncryptedAccessToken_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_result)
decode_AcquireEncryptedAccessToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireEncryptedAccessToken_result
decode_AcquireEncryptedAccessToken_result iprot bs = to_AcquireEncryptedAccessToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_result) bs
typemap_AcquireEncryptedAccessToken_result :: T.TypeMap
typemap_AcquireEncryptedAccessToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireEncryptedAccessToken_result :: AcquireEncryptedAccessToken_result
default_AcquireEncryptedAccessToken_result = AcquireEncryptedAccessToken_result{
  acquireEncryptedAccessToken_result_success = "",
  acquireEncryptedAccessToken_result_e = P.Nothing}
data AddSnsId_args = AddSnsId_args  { addSnsId_args_snsIdType :: SnsIdType
  , addSnsId_args_snsAccessToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddSnsId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addSnsId_args_snsIdType record   `H.hashWithSalt` addSnsId_args_snsAccessToken record  
instance QC.Arbitrary AddSnsId_args where 
  arbitrary = M.liftM AddSnsId_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddSnsId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddSnsId_args{addSnsId_args_snsIdType = addSnsId_args_snsIdType obj} then P.Nothing else P.Just $ default_AddSnsId_args{addSnsId_args_snsIdType = addSnsId_args_snsIdType obj}
    , if obj == default_AddSnsId_args{addSnsId_args_snsAccessToken = addSnsId_args_snsAccessToken obj} then P.Nothing else P.Just $ default_AddSnsId_args{addSnsId_args_snsAccessToken = addSnsId_args_snsAccessToken obj}
    ]
from_AddSnsId_args :: AddSnsId_args -> T.ThriftVal
from_AddSnsId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3600 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v3600))) $ addSnsId_args_snsIdType record
  , (\_v3600 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v3600))) $ addSnsId_args_snsAccessToken record
  ]
write_AddSnsId_args :: T.Protocol p => p -> AddSnsId_args -> P.IO ()
write_AddSnsId_args oprot record = T.writeVal oprot $ from_AddSnsId_args record
encode_AddSnsId_args :: T.StatelessProtocol p => p -> AddSnsId_args -> LBS.ByteString
encode_AddSnsId_args oprot record = T.serializeVal oprot $ from_AddSnsId_args record
to_AddSnsId_args :: T.ThriftVal -> AddSnsId_args
to_AddSnsId_args (T.TStruct fields) = AddSnsId_args{
  addSnsId_args_snsIdType = P.maybe (addSnsId_args_snsIdType default_AddSnsId_args) (\(_,_val3602) -> (case _val3602 of {T.TI32 _val3603 -> P.toEnum $ P.fromIntegral _val3603; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addSnsId_args_snsAccessToken = P.maybe (addSnsId_args_snsAccessToken default_AddSnsId_args) (\(_,_val3602) -> (case _val3602 of {T.TString _val3604 -> E.decodeUtf8 _val3604; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AddSnsId_args _ = P.error "not a struct"
read_AddSnsId_args :: T.Protocol p => p -> P.IO AddSnsId_args
read_AddSnsId_args iprot = to_AddSnsId_args <$> T.readVal iprot (T.T_STRUCT typemap_AddSnsId_args)
decode_AddSnsId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddSnsId_args
decode_AddSnsId_args iprot bs = to_AddSnsId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddSnsId_args) bs
typemap_AddSnsId_args :: T.TypeMap
typemap_AddSnsId_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING))]
default_AddSnsId_args :: AddSnsId_args
default_AddSnsId_args = AddSnsId_args{
  addSnsId_args_snsIdType = (P.toEnum 0),
  addSnsId_args_snsAccessToken = ""}
data AddSnsId_result = AddSnsId_result  { addSnsId_result_success :: LT.Text
  , addSnsId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddSnsId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addSnsId_result_success record   `H.hashWithSalt` addSnsId_result_e record  
instance QC.Arbitrary AddSnsId_result where 
  arbitrary = M.liftM AddSnsId_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddSnsId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddSnsId_result{addSnsId_result_success = addSnsId_result_success obj} then P.Nothing else P.Just $ default_AddSnsId_result{addSnsId_result_success = addSnsId_result_success obj}
    , if obj == default_AddSnsId_result{addSnsId_result_e = addSnsId_result_e obj} then P.Nothing else P.Just $ default_AddSnsId_result{addSnsId_result_e = addSnsId_result_e obj}
    ]
from_AddSnsId_result :: AddSnsId_result -> T.ThriftVal
from_AddSnsId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3607 -> (1, ("e",from_TalkException _v3607))) <$> addSnsId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3607 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v3607))) $ addSnsId_result_success record
    , (\_v3607 -> (1, ("e",from_TalkException _v3607))) <$> addSnsId_result_e record
    ]
    )
write_AddSnsId_result :: T.Protocol p => p -> AddSnsId_result -> P.IO ()
write_AddSnsId_result oprot record = T.writeVal oprot $ from_AddSnsId_result record
encode_AddSnsId_result :: T.StatelessProtocol p => p -> AddSnsId_result -> LBS.ByteString
encode_AddSnsId_result oprot record = T.serializeVal oprot $ from_AddSnsId_result record
to_AddSnsId_result :: T.ThriftVal -> AddSnsId_result
to_AddSnsId_result (T.TStruct fields) = AddSnsId_result{
  addSnsId_result_success = P.maybe (addSnsId_result_success default_AddSnsId_result) (\(_,_val3609) -> (case _val3609 of {T.TString _val3610 -> E.decodeUtf8 _val3610; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  addSnsId_result_e = P.maybe (P.Nothing) (\(_,_val3609) -> P.Just (case _val3609 of {T.TStruct _val3611 -> (to_TalkException (T.TStruct _val3611)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddSnsId_result _ = P.error "not a struct"
read_AddSnsId_result :: T.Protocol p => p -> P.IO AddSnsId_result
read_AddSnsId_result iprot = to_AddSnsId_result <$> T.readVal iprot (T.T_STRUCT typemap_AddSnsId_result)
decode_AddSnsId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddSnsId_result
decode_AddSnsId_result iprot bs = to_AddSnsId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddSnsId_result) bs
typemap_AddSnsId_result :: T.TypeMap
typemap_AddSnsId_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddSnsId_result :: AddSnsId_result
default_AddSnsId_result = AddSnsId_result{
  addSnsId_result_success = "",
  addSnsId_result_e = P.Nothing}
data BlockContact_args = BlockContact_args  { blockContact_args_reqSeq :: I.Int32
  , blockContact_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockContact_args_reqSeq record   `H.hashWithSalt` blockContact_args_id record  
instance QC.Arbitrary BlockContact_args where 
  arbitrary = M.liftM BlockContact_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BlockContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockContact_args{blockContact_args_reqSeq = blockContact_args_reqSeq obj} then P.Nothing else P.Just $ default_BlockContact_args{blockContact_args_reqSeq = blockContact_args_reqSeq obj}
    , if obj == default_BlockContact_args{blockContact_args_id = blockContact_args_id obj} then P.Nothing else P.Just $ default_BlockContact_args{blockContact_args_id = blockContact_args_id obj}
    ]
from_BlockContact_args :: BlockContact_args -> T.ThriftVal
from_BlockContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3614 -> P.Just (1, ("reqSeq",T.TI32 _v3614))) $ blockContact_args_reqSeq record
  , (\_v3614 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v3614))) $ blockContact_args_id record
  ]
write_BlockContact_args :: T.Protocol p => p -> BlockContact_args -> P.IO ()
write_BlockContact_args oprot record = T.writeVal oprot $ from_BlockContact_args record
encode_BlockContact_args :: T.StatelessProtocol p => p -> BlockContact_args -> LBS.ByteString
encode_BlockContact_args oprot record = T.serializeVal oprot $ from_BlockContact_args record
to_BlockContact_args :: T.ThriftVal -> BlockContact_args
to_BlockContact_args (T.TStruct fields) = BlockContact_args{
  blockContact_args_reqSeq = P.maybe (blockContact_args_reqSeq default_BlockContact_args) (\(_,_val3616) -> (case _val3616 of {T.TI32 _val3617 -> _val3617; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  blockContact_args_id = P.maybe (blockContact_args_id default_BlockContact_args) (\(_,_val3616) -> (case _val3616 of {T.TString _val3618 -> E.decodeUtf8 _val3618; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BlockContact_args _ = P.error "not a struct"
read_BlockContact_args :: T.Protocol p => p -> P.IO BlockContact_args
read_BlockContact_args iprot = to_BlockContact_args <$> T.readVal iprot (T.T_STRUCT typemap_BlockContact_args)
decode_BlockContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockContact_args
decode_BlockContact_args iprot bs = to_BlockContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockContact_args) bs
typemap_BlockContact_args :: T.TypeMap
typemap_BlockContact_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_BlockContact_args :: BlockContact_args
default_BlockContact_args = BlockContact_args{
  blockContact_args_reqSeq = 0,
  blockContact_args_id = ""}
data BlockContact_result = BlockContact_result  { blockContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockContact_result_e record  
instance QC.Arbitrary BlockContact_result where 
  arbitrary = M.liftM BlockContact_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BlockContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockContact_result{blockContact_result_e = blockContact_result_e obj} then P.Nothing else P.Just $ default_BlockContact_result{blockContact_result_e = blockContact_result_e obj}
    ]
from_BlockContact_result :: BlockContact_result -> T.ThriftVal
from_BlockContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3621 -> (1, ("e",from_TalkException _v3621))) <$> blockContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3621 -> (1, ("e",from_TalkException _v3621))) <$> blockContact_result_e record
    ]
    )
write_BlockContact_result :: T.Protocol p => p -> BlockContact_result -> P.IO ()
write_BlockContact_result oprot record = T.writeVal oprot $ from_BlockContact_result record
encode_BlockContact_result :: T.StatelessProtocol p => p -> BlockContact_result -> LBS.ByteString
encode_BlockContact_result oprot record = T.serializeVal oprot $ from_BlockContact_result record
to_BlockContact_result :: T.ThriftVal -> BlockContact_result
to_BlockContact_result (T.TStruct fields) = BlockContact_result{
  blockContact_result_e = P.maybe (P.Nothing) (\(_,_val3623) -> P.Just (case _val3623 of {T.TStruct _val3624 -> (to_TalkException (T.TStruct _val3624)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BlockContact_result _ = P.error "not a struct"
read_BlockContact_result :: T.Protocol p => p -> P.IO BlockContact_result
read_BlockContact_result iprot = to_BlockContact_result <$> T.readVal iprot (T.T_STRUCT typemap_BlockContact_result)
decode_BlockContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockContact_result
decode_BlockContact_result iprot bs = to_BlockContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockContact_result) bs
typemap_BlockContact_result :: T.TypeMap
typemap_BlockContact_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_BlockContact_result :: BlockContact_result
default_BlockContact_result = BlockContact_result{
  blockContact_result_e = P.Nothing}
data BlockRecommendation_args = BlockRecommendation_args  { blockRecommendation_args_reqSeq :: I.Int32
  , blockRecommendation_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockRecommendation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockRecommendation_args_reqSeq record   `H.hashWithSalt` blockRecommendation_args_id record  
instance QC.Arbitrary BlockRecommendation_args where 
  arbitrary = M.liftM BlockRecommendation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BlockRecommendation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockRecommendation_args{blockRecommendation_args_reqSeq = blockRecommendation_args_reqSeq obj} then P.Nothing else P.Just $ default_BlockRecommendation_args{blockRecommendation_args_reqSeq = blockRecommendation_args_reqSeq obj}
    , if obj == default_BlockRecommendation_args{blockRecommendation_args_id = blockRecommendation_args_id obj} then P.Nothing else P.Just $ default_BlockRecommendation_args{blockRecommendation_args_id = blockRecommendation_args_id obj}
    ]
from_BlockRecommendation_args :: BlockRecommendation_args -> T.ThriftVal
from_BlockRecommendation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3627 -> P.Just (1, ("reqSeq",T.TI32 _v3627))) $ blockRecommendation_args_reqSeq record
  , (\_v3627 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v3627))) $ blockRecommendation_args_id record
  ]
write_BlockRecommendation_args :: T.Protocol p => p -> BlockRecommendation_args -> P.IO ()
write_BlockRecommendation_args oprot record = T.writeVal oprot $ from_BlockRecommendation_args record
encode_BlockRecommendation_args :: T.StatelessProtocol p => p -> BlockRecommendation_args -> LBS.ByteString
encode_BlockRecommendation_args oprot record = T.serializeVal oprot $ from_BlockRecommendation_args record
to_BlockRecommendation_args :: T.ThriftVal -> BlockRecommendation_args
to_BlockRecommendation_args (T.TStruct fields) = BlockRecommendation_args{
  blockRecommendation_args_reqSeq = P.maybe (blockRecommendation_args_reqSeq default_BlockRecommendation_args) (\(_,_val3629) -> (case _val3629 of {T.TI32 _val3630 -> _val3630; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  blockRecommendation_args_id = P.maybe (blockRecommendation_args_id default_BlockRecommendation_args) (\(_,_val3629) -> (case _val3629 of {T.TString _val3631 -> E.decodeUtf8 _val3631; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BlockRecommendation_args _ = P.error "not a struct"
read_BlockRecommendation_args :: T.Protocol p => p -> P.IO BlockRecommendation_args
read_BlockRecommendation_args iprot = to_BlockRecommendation_args <$> T.readVal iprot (T.T_STRUCT typemap_BlockRecommendation_args)
decode_BlockRecommendation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockRecommendation_args
decode_BlockRecommendation_args iprot bs = to_BlockRecommendation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockRecommendation_args) bs
typemap_BlockRecommendation_args :: T.TypeMap
typemap_BlockRecommendation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_BlockRecommendation_args :: BlockRecommendation_args
default_BlockRecommendation_args = BlockRecommendation_args{
  blockRecommendation_args_reqSeq = 0,
  blockRecommendation_args_id = ""}
data BlockRecommendation_result = BlockRecommendation_result  { blockRecommendation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockRecommendation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockRecommendation_result_e record  
instance QC.Arbitrary BlockRecommendation_result where 
  arbitrary = M.liftM BlockRecommendation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BlockRecommendation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockRecommendation_result{blockRecommendation_result_e = blockRecommendation_result_e obj} then P.Nothing else P.Just $ default_BlockRecommendation_result{blockRecommendation_result_e = blockRecommendation_result_e obj}
    ]
from_BlockRecommendation_result :: BlockRecommendation_result -> T.ThriftVal
from_BlockRecommendation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3634 -> (1, ("e",from_TalkException _v3634))) <$> blockRecommendation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3634 -> (1, ("e",from_TalkException _v3634))) <$> blockRecommendation_result_e record
    ]
    )
write_BlockRecommendation_result :: T.Protocol p => p -> BlockRecommendation_result -> P.IO ()
write_BlockRecommendation_result oprot record = T.writeVal oprot $ from_BlockRecommendation_result record
encode_BlockRecommendation_result :: T.StatelessProtocol p => p -> BlockRecommendation_result -> LBS.ByteString
encode_BlockRecommendation_result oprot record = T.serializeVal oprot $ from_BlockRecommendation_result record
to_BlockRecommendation_result :: T.ThriftVal -> BlockRecommendation_result
to_BlockRecommendation_result (T.TStruct fields) = BlockRecommendation_result{
  blockRecommendation_result_e = P.maybe (P.Nothing) (\(_,_val3636) -> P.Just (case _val3636 of {T.TStruct _val3637 -> (to_TalkException (T.TStruct _val3637)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BlockRecommendation_result _ = P.error "not a struct"
read_BlockRecommendation_result :: T.Protocol p => p -> P.IO BlockRecommendation_result
read_BlockRecommendation_result iprot = to_BlockRecommendation_result <$> T.readVal iprot (T.T_STRUCT typemap_BlockRecommendation_result)
decode_BlockRecommendation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockRecommendation_result
decode_BlockRecommendation_result iprot bs = to_BlockRecommendation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockRecommendation_result) bs
typemap_BlockRecommendation_result :: T.TypeMap
typemap_BlockRecommendation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_BlockRecommendation_result :: BlockRecommendation_result
default_BlockRecommendation_result = BlockRecommendation_result{
  blockRecommendation_result_e = P.Nothing}
data CancelGroupInvitation_args = CancelGroupInvitation_args  { cancelGroupInvitation_args_reqSeq :: I.Int32
  , cancelGroupInvitation_args_groupId :: LT.Text
  , cancelGroupInvitation_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CancelGroupInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` cancelGroupInvitation_args_reqSeq record   `H.hashWithSalt` cancelGroupInvitation_args_groupId record   `H.hashWithSalt` cancelGroupInvitation_args_contactIds record  
instance QC.Arbitrary CancelGroupInvitation_args where 
  arbitrary = M.liftM CancelGroupInvitation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CancelGroupInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CancelGroupInvitation_args{cancelGroupInvitation_args_reqSeq = cancelGroupInvitation_args_reqSeq obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_args{cancelGroupInvitation_args_reqSeq = cancelGroupInvitation_args_reqSeq obj}
    , if obj == default_CancelGroupInvitation_args{cancelGroupInvitation_args_groupId = cancelGroupInvitation_args_groupId obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_args{cancelGroupInvitation_args_groupId = cancelGroupInvitation_args_groupId obj}
    , if obj == default_CancelGroupInvitation_args{cancelGroupInvitation_args_contactIds = cancelGroupInvitation_args_contactIds obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_args{cancelGroupInvitation_args_contactIds = cancelGroupInvitation_args_contactIds obj}
    ]
from_CancelGroupInvitation_args :: CancelGroupInvitation_args -> T.ThriftVal
from_CancelGroupInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3640 -> P.Just (1, ("reqSeq",T.TI32 _v3640))) $ cancelGroupInvitation_args_reqSeq record
  , (\_v3640 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v3640))) $ cancelGroupInvitation_args_groupId record
  , (\_v3640 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v3642 -> T.TString $ E.encodeUtf8 _v3642) $ Vector.toList _v3640))) $ cancelGroupInvitation_args_contactIds record
  ]
write_CancelGroupInvitation_args :: T.Protocol p => p -> CancelGroupInvitation_args -> P.IO ()
write_CancelGroupInvitation_args oprot record = T.writeVal oprot $ from_CancelGroupInvitation_args record
encode_CancelGroupInvitation_args :: T.StatelessProtocol p => p -> CancelGroupInvitation_args -> LBS.ByteString
encode_CancelGroupInvitation_args oprot record = T.serializeVal oprot $ from_CancelGroupInvitation_args record
to_CancelGroupInvitation_args :: T.ThriftVal -> CancelGroupInvitation_args
to_CancelGroupInvitation_args (T.TStruct fields) = CancelGroupInvitation_args{
  cancelGroupInvitation_args_reqSeq = P.maybe (cancelGroupInvitation_args_reqSeq default_CancelGroupInvitation_args) (\(_,_val3644) -> (case _val3644 of {T.TI32 _val3645 -> _val3645; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  cancelGroupInvitation_args_groupId = P.maybe (cancelGroupInvitation_args_groupId default_CancelGroupInvitation_args) (\(_,_val3644) -> (case _val3644 of {T.TString _val3646 -> E.decodeUtf8 _val3646; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  cancelGroupInvitation_args_contactIds = P.maybe (cancelGroupInvitation_args_contactIds default_CancelGroupInvitation_args) (\(_,_val3644) -> (case _val3644 of {T.TList _ _val3647 -> (Vector.fromList $ P.map (\_v3648 -> (case _v3648 of {T.TString _val3649 -> E.decodeUtf8 _val3649; _ -> P.error "wrong type"})) _val3647); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CancelGroupInvitation_args _ = P.error "not a struct"
read_CancelGroupInvitation_args :: T.Protocol p => p -> P.IO CancelGroupInvitation_args
read_CancelGroupInvitation_args iprot = to_CancelGroupInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_args)
decode_CancelGroupInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CancelGroupInvitation_args
decode_CancelGroupInvitation_args iprot bs = to_CancelGroupInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_args) bs
typemap_CancelGroupInvitation_args :: T.TypeMap
typemap_CancelGroupInvitation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_CancelGroupInvitation_args :: CancelGroupInvitation_args
default_CancelGroupInvitation_args = CancelGroupInvitation_args{
  cancelGroupInvitation_args_reqSeq = 0,
  cancelGroupInvitation_args_groupId = "",
  cancelGroupInvitation_args_contactIds = Vector.empty}
data CancelGroupInvitation_result = CancelGroupInvitation_result  { cancelGroupInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CancelGroupInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` cancelGroupInvitation_result_e record  
instance QC.Arbitrary CancelGroupInvitation_result where 
  arbitrary = M.liftM CancelGroupInvitation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CancelGroupInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CancelGroupInvitation_result{cancelGroupInvitation_result_e = cancelGroupInvitation_result_e obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_result{cancelGroupInvitation_result_e = cancelGroupInvitation_result_e obj}
    ]
from_CancelGroupInvitation_result :: CancelGroupInvitation_result -> T.ThriftVal
from_CancelGroupInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3652 -> (1, ("e",from_TalkException _v3652))) <$> cancelGroupInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3652 -> (1, ("e",from_TalkException _v3652))) <$> cancelGroupInvitation_result_e record
    ]
    )
write_CancelGroupInvitation_result :: T.Protocol p => p -> CancelGroupInvitation_result -> P.IO ()
write_CancelGroupInvitation_result oprot record = T.writeVal oprot $ from_CancelGroupInvitation_result record
encode_CancelGroupInvitation_result :: T.StatelessProtocol p => p -> CancelGroupInvitation_result -> LBS.ByteString
encode_CancelGroupInvitation_result oprot record = T.serializeVal oprot $ from_CancelGroupInvitation_result record
to_CancelGroupInvitation_result :: T.ThriftVal -> CancelGroupInvitation_result
to_CancelGroupInvitation_result (T.TStruct fields) = CancelGroupInvitation_result{
  cancelGroupInvitation_result_e = P.maybe (P.Nothing) (\(_,_val3654) -> P.Just (case _val3654 of {T.TStruct _val3655 -> (to_TalkException (T.TStruct _val3655)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CancelGroupInvitation_result _ = P.error "not a struct"
read_CancelGroupInvitation_result :: T.Protocol p => p -> P.IO CancelGroupInvitation_result
read_CancelGroupInvitation_result iprot = to_CancelGroupInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_result)
decode_CancelGroupInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CancelGroupInvitation_result
decode_CancelGroupInvitation_result iprot bs = to_CancelGroupInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_result) bs
typemap_CancelGroupInvitation_result :: T.TypeMap
typemap_CancelGroupInvitation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CancelGroupInvitation_result :: CancelGroupInvitation_result
default_CancelGroupInvitation_result = CancelGroupInvitation_result{
  cancelGroupInvitation_result_e = P.Nothing}
data ChangeVerificationMethod_args = ChangeVerificationMethod_args  { changeVerificationMethod_args_sessionId :: LT.Text
  , changeVerificationMethod_args_method :: VerificationMethod
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChangeVerificationMethod_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` changeVerificationMethod_args_sessionId record   `H.hashWithSalt` changeVerificationMethod_args_method record  
instance QC.Arbitrary ChangeVerificationMethod_args where 
  arbitrary = M.liftM ChangeVerificationMethod_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChangeVerificationMethod_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChangeVerificationMethod_args{changeVerificationMethod_args_sessionId = changeVerificationMethod_args_sessionId obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_args{changeVerificationMethod_args_sessionId = changeVerificationMethod_args_sessionId obj}
    , if obj == default_ChangeVerificationMethod_args{changeVerificationMethod_args_method = changeVerificationMethod_args_method obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_args{changeVerificationMethod_args_method = changeVerificationMethod_args_method obj}
    ]
from_ChangeVerificationMethod_args :: ChangeVerificationMethod_args -> T.ThriftVal
from_ChangeVerificationMethod_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3658 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v3658))) $ changeVerificationMethod_args_sessionId record
  , (\_v3658 -> P.Just (3, ("method",T.TI32 $ P.fromIntegral $ P.fromEnum _v3658))) $ changeVerificationMethod_args_method record
  ]
write_ChangeVerificationMethod_args :: T.Protocol p => p -> ChangeVerificationMethod_args -> P.IO ()
write_ChangeVerificationMethod_args oprot record = T.writeVal oprot $ from_ChangeVerificationMethod_args record
encode_ChangeVerificationMethod_args :: T.StatelessProtocol p => p -> ChangeVerificationMethod_args -> LBS.ByteString
encode_ChangeVerificationMethod_args oprot record = T.serializeVal oprot $ from_ChangeVerificationMethod_args record
to_ChangeVerificationMethod_args :: T.ThriftVal -> ChangeVerificationMethod_args
to_ChangeVerificationMethod_args (T.TStruct fields) = ChangeVerificationMethod_args{
  changeVerificationMethod_args_sessionId = P.maybe (changeVerificationMethod_args_sessionId default_ChangeVerificationMethod_args) (\(_,_val3660) -> (case _val3660 of {T.TString _val3661 -> E.decodeUtf8 _val3661; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  changeVerificationMethod_args_method = P.maybe (changeVerificationMethod_args_method default_ChangeVerificationMethod_args) (\(_,_val3660) -> (case _val3660 of {T.TI32 _val3662 -> P.toEnum $ P.fromIntegral _val3662; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ChangeVerificationMethod_args _ = P.error "not a struct"
read_ChangeVerificationMethod_args :: T.Protocol p => p -> P.IO ChangeVerificationMethod_args
read_ChangeVerificationMethod_args iprot = to_ChangeVerificationMethod_args <$> T.readVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_args)
decode_ChangeVerificationMethod_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ChangeVerificationMethod_args
decode_ChangeVerificationMethod_args iprot bs = to_ChangeVerificationMethod_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_args) bs
typemap_ChangeVerificationMethod_args :: T.TypeMap
typemap_ChangeVerificationMethod_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("method",T.T_I32))]
default_ChangeVerificationMethod_args :: ChangeVerificationMethod_args
default_ChangeVerificationMethod_args = ChangeVerificationMethod_args{
  changeVerificationMethod_args_sessionId = "",
  changeVerificationMethod_args_method = (P.toEnum 0)}
data ChangeVerificationMethod_result = ChangeVerificationMethod_result  { changeVerificationMethod_result_success :: VerificationSessionData
  , changeVerificationMethod_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChangeVerificationMethod_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` changeVerificationMethod_result_success record   `H.hashWithSalt` changeVerificationMethod_result_e record  
instance QC.Arbitrary ChangeVerificationMethod_result where 
  arbitrary = M.liftM ChangeVerificationMethod_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ChangeVerificationMethod_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChangeVerificationMethod_result{changeVerificationMethod_result_success = changeVerificationMethod_result_success obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_result{changeVerificationMethod_result_success = changeVerificationMethod_result_success obj}
    , if obj == default_ChangeVerificationMethod_result{changeVerificationMethod_result_e = changeVerificationMethod_result_e obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_result{changeVerificationMethod_result_e = changeVerificationMethod_result_e obj}
    ]
from_ChangeVerificationMethod_result :: ChangeVerificationMethod_result -> T.ThriftVal
from_ChangeVerificationMethod_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3665 -> (1, ("e",from_TalkException _v3665))) <$> changeVerificationMethod_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3665 -> P.Just (0, ("success",from_VerificationSessionData _v3665))) $ changeVerificationMethod_result_success record
    , (\_v3665 -> (1, ("e",from_TalkException _v3665))) <$> changeVerificationMethod_result_e record
    ]
    )
write_ChangeVerificationMethod_result :: T.Protocol p => p -> ChangeVerificationMethod_result -> P.IO ()
write_ChangeVerificationMethod_result oprot record = T.writeVal oprot $ from_ChangeVerificationMethod_result record
encode_ChangeVerificationMethod_result :: T.StatelessProtocol p => p -> ChangeVerificationMethod_result -> LBS.ByteString
encode_ChangeVerificationMethod_result oprot record = T.serializeVal oprot $ from_ChangeVerificationMethod_result record
to_ChangeVerificationMethod_result :: T.ThriftVal -> ChangeVerificationMethod_result
to_ChangeVerificationMethod_result (T.TStruct fields) = ChangeVerificationMethod_result{
  changeVerificationMethod_result_success = P.maybe (changeVerificationMethod_result_success default_ChangeVerificationMethod_result) (\(_,_val3667) -> (case _val3667 of {T.TStruct _val3668 -> (to_VerificationSessionData (T.TStruct _val3668)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  changeVerificationMethod_result_e = P.maybe (P.Nothing) (\(_,_val3667) -> P.Just (case _val3667 of {T.TStruct _val3669 -> (to_TalkException (T.TStruct _val3669)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ChangeVerificationMethod_result _ = P.error "not a struct"
read_ChangeVerificationMethod_result :: T.Protocol p => p -> P.IO ChangeVerificationMethod_result
read_ChangeVerificationMethod_result iprot = to_ChangeVerificationMethod_result <$> T.readVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_result)
decode_ChangeVerificationMethod_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ChangeVerificationMethod_result
decode_ChangeVerificationMethod_result iprot bs = to_ChangeVerificationMethod_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_result) bs
typemap_ChangeVerificationMethod_result :: T.TypeMap
typemap_ChangeVerificationMethod_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_VerificationSessionData))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ChangeVerificationMethod_result :: ChangeVerificationMethod_result
default_ChangeVerificationMethod_result = ChangeVerificationMethod_result{
  changeVerificationMethod_result_success = default_VerificationSessionData,
  changeVerificationMethod_result_e = P.Nothing}
data ClearIdentityCredential_args = ClearIdentityCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearIdentityCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ClearIdentityCredential_args where 
  arbitrary = QC.elements [ClearIdentityCredential_args]
from_ClearIdentityCredential_args :: ClearIdentityCredential_args -> T.ThriftVal
from_ClearIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ClearIdentityCredential_args :: T.Protocol p => p -> ClearIdentityCredential_args -> P.IO ()
write_ClearIdentityCredential_args oprot record = T.writeVal oprot $ from_ClearIdentityCredential_args record
encode_ClearIdentityCredential_args :: T.StatelessProtocol p => p -> ClearIdentityCredential_args -> LBS.ByteString
encode_ClearIdentityCredential_args oprot record = T.serializeVal oprot $ from_ClearIdentityCredential_args record
to_ClearIdentityCredential_args :: T.ThriftVal -> ClearIdentityCredential_args
to_ClearIdentityCredential_args (T.TStruct fields) = ClearIdentityCredential_args{

  }
to_ClearIdentityCredential_args _ = P.error "not a struct"
read_ClearIdentityCredential_args :: T.Protocol p => p -> P.IO ClearIdentityCredential_args
read_ClearIdentityCredential_args iprot = to_ClearIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_args)
decode_ClearIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearIdentityCredential_args
decode_ClearIdentityCredential_args iprot bs = to_ClearIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_args) bs
typemap_ClearIdentityCredential_args :: T.TypeMap
typemap_ClearIdentityCredential_args = Map.fromList []
default_ClearIdentityCredential_args :: ClearIdentityCredential_args
default_ClearIdentityCredential_args = ClearIdentityCredential_args{
}
data ClearIdentityCredential_result = ClearIdentityCredential_result  { clearIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` clearIdentityCredential_result_e record  
instance QC.Arbitrary ClearIdentityCredential_result where 
  arbitrary = M.liftM ClearIdentityCredential_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ClearIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ClearIdentityCredential_result{clearIdentityCredential_result_e = clearIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_ClearIdentityCredential_result{clearIdentityCredential_result_e = clearIdentityCredential_result_e obj}
    ]
from_ClearIdentityCredential_result :: ClearIdentityCredential_result -> T.ThriftVal
from_ClearIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3677 -> (1, ("e",from_TalkException _v3677))) <$> clearIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3677 -> (1, ("e",from_TalkException _v3677))) <$> clearIdentityCredential_result_e record
    ]
    )
write_ClearIdentityCredential_result :: T.Protocol p => p -> ClearIdentityCredential_result -> P.IO ()
write_ClearIdentityCredential_result oprot record = T.writeVal oprot $ from_ClearIdentityCredential_result record
encode_ClearIdentityCredential_result :: T.StatelessProtocol p => p -> ClearIdentityCredential_result -> LBS.ByteString
encode_ClearIdentityCredential_result oprot record = T.serializeVal oprot $ from_ClearIdentityCredential_result record
to_ClearIdentityCredential_result :: T.ThriftVal -> ClearIdentityCredential_result
to_ClearIdentityCredential_result (T.TStruct fields) = ClearIdentityCredential_result{
  clearIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val3679) -> P.Just (case _val3679 of {T.TStruct _val3680 -> (to_TalkException (T.TStruct _val3680)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ClearIdentityCredential_result _ = P.error "not a struct"
read_ClearIdentityCredential_result :: T.Protocol p => p -> P.IO ClearIdentityCredential_result
read_ClearIdentityCredential_result iprot = to_ClearIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_result)
decode_ClearIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearIdentityCredential_result
decode_ClearIdentityCredential_result iprot bs = to_ClearIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_result) bs
typemap_ClearIdentityCredential_result :: T.TypeMap
typemap_ClearIdentityCredential_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ClearIdentityCredential_result :: ClearIdentityCredential_result
default_ClearIdentityCredential_result = ClearIdentityCredential_result{
  clearIdentityCredential_result_e = P.Nothing}
data ClearMessageBox_args = ClearMessageBox_args  { clearMessageBox_args_channelId :: LT.Text
  , clearMessageBox_args_messageBoxId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearMessageBox_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` clearMessageBox_args_channelId record   `H.hashWithSalt` clearMessageBox_args_messageBoxId record  
instance QC.Arbitrary ClearMessageBox_args where 
  arbitrary = M.liftM ClearMessageBox_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ClearMessageBox_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ClearMessageBox_args{clearMessageBox_args_channelId = clearMessageBox_args_channelId obj} then P.Nothing else P.Just $ default_ClearMessageBox_args{clearMessageBox_args_channelId = clearMessageBox_args_channelId obj}
    , if obj == default_ClearMessageBox_args{clearMessageBox_args_messageBoxId = clearMessageBox_args_messageBoxId obj} then P.Nothing else P.Just $ default_ClearMessageBox_args{clearMessageBox_args_messageBoxId = clearMessageBox_args_messageBoxId obj}
    ]
from_ClearMessageBox_args :: ClearMessageBox_args -> T.ThriftVal
from_ClearMessageBox_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3683 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v3683))) $ clearMessageBox_args_channelId record
  , (\_v3683 -> P.Just (3, ("messageBoxId",T.TString $ E.encodeUtf8 _v3683))) $ clearMessageBox_args_messageBoxId record
  ]
write_ClearMessageBox_args :: T.Protocol p => p -> ClearMessageBox_args -> P.IO ()
write_ClearMessageBox_args oprot record = T.writeVal oprot $ from_ClearMessageBox_args record
encode_ClearMessageBox_args :: T.StatelessProtocol p => p -> ClearMessageBox_args -> LBS.ByteString
encode_ClearMessageBox_args oprot record = T.serializeVal oprot $ from_ClearMessageBox_args record
to_ClearMessageBox_args :: T.ThriftVal -> ClearMessageBox_args
to_ClearMessageBox_args (T.TStruct fields) = ClearMessageBox_args{
  clearMessageBox_args_channelId = P.maybe (clearMessageBox_args_channelId default_ClearMessageBox_args) (\(_,_val3685) -> (case _val3685 of {T.TString _val3686 -> E.decodeUtf8 _val3686; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  clearMessageBox_args_messageBoxId = P.maybe (clearMessageBox_args_messageBoxId default_ClearMessageBox_args) (\(_,_val3685) -> (case _val3685 of {T.TString _val3687 -> E.decodeUtf8 _val3687; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ClearMessageBox_args _ = P.error "not a struct"
read_ClearMessageBox_args :: T.Protocol p => p -> P.IO ClearMessageBox_args
read_ClearMessageBox_args iprot = to_ClearMessageBox_args <$> T.readVal iprot (T.T_STRUCT typemap_ClearMessageBox_args)
decode_ClearMessageBox_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearMessageBox_args
decode_ClearMessageBox_args iprot bs = to_ClearMessageBox_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearMessageBox_args) bs
typemap_ClearMessageBox_args :: T.TypeMap
typemap_ClearMessageBox_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("messageBoxId",T.T_STRING))]
default_ClearMessageBox_args :: ClearMessageBox_args
default_ClearMessageBox_args = ClearMessageBox_args{
  clearMessageBox_args_channelId = "",
  clearMessageBox_args_messageBoxId = ""}
data ClearMessageBox_result = ClearMessageBox_result  { clearMessageBox_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearMessageBox_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` clearMessageBox_result_e record  
instance QC.Arbitrary ClearMessageBox_result where 
  arbitrary = M.liftM ClearMessageBox_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ClearMessageBox_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ClearMessageBox_result{clearMessageBox_result_e = clearMessageBox_result_e obj} then P.Nothing else P.Just $ default_ClearMessageBox_result{clearMessageBox_result_e = clearMessageBox_result_e obj}
    ]
from_ClearMessageBox_result :: ClearMessageBox_result -> T.ThriftVal
from_ClearMessageBox_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3690 -> (1, ("e",from_TalkException _v3690))) <$> clearMessageBox_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3690 -> (1, ("e",from_TalkException _v3690))) <$> clearMessageBox_result_e record
    ]
    )
write_ClearMessageBox_result :: T.Protocol p => p -> ClearMessageBox_result -> P.IO ()
write_ClearMessageBox_result oprot record = T.writeVal oprot $ from_ClearMessageBox_result record
encode_ClearMessageBox_result :: T.StatelessProtocol p => p -> ClearMessageBox_result -> LBS.ByteString
encode_ClearMessageBox_result oprot record = T.serializeVal oprot $ from_ClearMessageBox_result record
to_ClearMessageBox_result :: T.ThriftVal -> ClearMessageBox_result
to_ClearMessageBox_result (T.TStruct fields) = ClearMessageBox_result{
  clearMessageBox_result_e = P.maybe (P.Nothing) (\(_,_val3692) -> P.Just (case _val3692 of {T.TStruct _val3693 -> (to_TalkException (T.TStruct _val3693)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ClearMessageBox_result _ = P.error "not a struct"
read_ClearMessageBox_result :: T.Protocol p => p -> P.IO ClearMessageBox_result
read_ClearMessageBox_result iprot = to_ClearMessageBox_result <$> T.readVal iprot (T.T_STRUCT typemap_ClearMessageBox_result)
decode_ClearMessageBox_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearMessageBox_result
decode_ClearMessageBox_result iprot bs = to_ClearMessageBox_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearMessageBox_result) bs
typemap_ClearMessageBox_result :: T.TypeMap
typemap_ClearMessageBox_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ClearMessageBox_result :: ClearMessageBox_result
default_ClearMessageBox_result = ClearMessageBox_result{
  clearMessageBox_result_e = P.Nothing}
data CloseProximityMatch_args = CloseProximityMatch_args  { closeProximityMatch_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CloseProximityMatch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` closeProximityMatch_args_sessionId record  
instance QC.Arbitrary CloseProximityMatch_args where 
  arbitrary = M.liftM CloseProximityMatch_args (QC.arbitrary)
  shrink obj | obj == default_CloseProximityMatch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CloseProximityMatch_args{closeProximityMatch_args_sessionId = closeProximityMatch_args_sessionId obj} then P.Nothing else P.Just $ default_CloseProximityMatch_args{closeProximityMatch_args_sessionId = closeProximityMatch_args_sessionId obj}
    ]
from_CloseProximityMatch_args :: CloseProximityMatch_args -> T.ThriftVal
from_CloseProximityMatch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3696 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v3696))) $ closeProximityMatch_args_sessionId record
  ]
write_CloseProximityMatch_args :: T.Protocol p => p -> CloseProximityMatch_args -> P.IO ()
write_CloseProximityMatch_args oprot record = T.writeVal oprot $ from_CloseProximityMatch_args record
encode_CloseProximityMatch_args :: T.StatelessProtocol p => p -> CloseProximityMatch_args -> LBS.ByteString
encode_CloseProximityMatch_args oprot record = T.serializeVal oprot $ from_CloseProximityMatch_args record
to_CloseProximityMatch_args :: T.ThriftVal -> CloseProximityMatch_args
to_CloseProximityMatch_args (T.TStruct fields) = CloseProximityMatch_args{
  closeProximityMatch_args_sessionId = P.maybe (closeProximityMatch_args_sessionId default_CloseProximityMatch_args) (\(_,_val3698) -> (case _val3698 of {T.TString _val3699 -> E.decodeUtf8 _val3699; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CloseProximityMatch_args _ = P.error "not a struct"
read_CloseProximityMatch_args :: T.Protocol p => p -> P.IO CloseProximityMatch_args
read_CloseProximityMatch_args iprot = to_CloseProximityMatch_args <$> T.readVal iprot (T.T_STRUCT typemap_CloseProximityMatch_args)
decode_CloseProximityMatch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CloseProximityMatch_args
decode_CloseProximityMatch_args iprot bs = to_CloseProximityMatch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CloseProximityMatch_args) bs
typemap_CloseProximityMatch_args :: T.TypeMap
typemap_CloseProximityMatch_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_CloseProximityMatch_args :: CloseProximityMatch_args
default_CloseProximityMatch_args = CloseProximityMatch_args{
  closeProximityMatch_args_sessionId = ""}
data CloseProximityMatch_result = CloseProximityMatch_result  { closeProximityMatch_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CloseProximityMatch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` closeProximityMatch_result_e record  
instance QC.Arbitrary CloseProximityMatch_result where 
  arbitrary = M.liftM CloseProximityMatch_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CloseProximityMatch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CloseProximityMatch_result{closeProximityMatch_result_e = closeProximityMatch_result_e obj} then P.Nothing else P.Just $ default_CloseProximityMatch_result{closeProximityMatch_result_e = closeProximityMatch_result_e obj}
    ]
from_CloseProximityMatch_result :: CloseProximityMatch_result -> T.ThriftVal
from_CloseProximityMatch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3702 -> (1, ("e",from_TalkException _v3702))) <$> closeProximityMatch_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3702 -> (1, ("e",from_TalkException _v3702))) <$> closeProximityMatch_result_e record
    ]
    )
write_CloseProximityMatch_result :: T.Protocol p => p -> CloseProximityMatch_result -> P.IO ()
write_CloseProximityMatch_result oprot record = T.writeVal oprot $ from_CloseProximityMatch_result record
encode_CloseProximityMatch_result :: T.StatelessProtocol p => p -> CloseProximityMatch_result -> LBS.ByteString
encode_CloseProximityMatch_result oprot record = T.serializeVal oprot $ from_CloseProximityMatch_result record
to_CloseProximityMatch_result :: T.ThriftVal -> CloseProximityMatch_result
to_CloseProximityMatch_result (T.TStruct fields) = CloseProximityMatch_result{
  closeProximityMatch_result_e = P.maybe (P.Nothing) (\(_,_val3704) -> P.Just (case _val3704 of {T.TStruct _val3705 -> (to_TalkException (T.TStruct _val3705)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CloseProximityMatch_result _ = P.error "not a struct"
read_CloseProximityMatch_result :: T.Protocol p => p -> P.IO CloseProximityMatch_result
read_CloseProximityMatch_result iprot = to_CloseProximityMatch_result <$> T.readVal iprot (T.T_STRUCT typemap_CloseProximityMatch_result)
decode_CloseProximityMatch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CloseProximityMatch_result
decode_CloseProximityMatch_result iprot bs = to_CloseProximityMatch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CloseProximityMatch_result) bs
typemap_CloseProximityMatch_result :: T.TypeMap
typemap_CloseProximityMatch_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CloseProximityMatch_result :: CloseProximityMatch_result
default_CloseProximityMatch_result = CloseProximityMatch_result{
  closeProximityMatch_result_e = P.Nothing}
data CommitSendMessage_args = CommitSendMessage_args  { commitSendMessage_args_seq :: I.Int32
  , commitSendMessage_args_messageId :: LT.Text
  , commitSendMessage_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessage_args_seq record   `H.hashWithSalt` commitSendMessage_args_messageId record   `H.hashWithSalt` commitSendMessage_args_receiverMids record  
instance QC.Arbitrary CommitSendMessage_args where 
  arbitrary = M.liftM CommitSendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CommitSendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessage_args{commitSendMessage_args_seq = commitSendMessage_args_seq obj} then P.Nothing else P.Just $ default_CommitSendMessage_args{commitSendMessage_args_seq = commitSendMessage_args_seq obj}
    , if obj == default_CommitSendMessage_args{commitSendMessage_args_messageId = commitSendMessage_args_messageId obj} then P.Nothing else P.Just $ default_CommitSendMessage_args{commitSendMessage_args_messageId = commitSendMessage_args_messageId obj}
    , if obj == default_CommitSendMessage_args{commitSendMessage_args_receiverMids = commitSendMessage_args_receiverMids obj} then P.Nothing else P.Just $ default_CommitSendMessage_args{commitSendMessage_args_receiverMids = commitSendMessage_args_receiverMids obj}
    ]
from_CommitSendMessage_args :: CommitSendMessage_args -> T.ThriftVal
from_CommitSendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3708 -> P.Just (1, ("seq",T.TI32 _v3708))) $ commitSendMessage_args_seq record
  , (\_v3708 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v3708))) $ commitSendMessage_args_messageId record
  , (\_v3708 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v3710 -> T.TString $ E.encodeUtf8 _v3710) $ Vector.toList _v3708))) $ commitSendMessage_args_receiverMids record
  ]
write_CommitSendMessage_args :: T.Protocol p => p -> CommitSendMessage_args -> P.IO ()
write_CommitSendMessage_args oprot record = T.writeVal oprot $ from_CommitSendMessage_args record
encode_CommitSendMessage_args :: T.StatelessProtocol p => p -> CommitSendMessage_args -> LBS.ByteString
encode_CommitSendMessage_args oprot record = T.serializeVal oprot $ from_CommitSendMessage_args record
to_CommitSendMessage_args :: T.ThriftVal -> CommitSendMessage_args
to_CommitSendMessage_args (T.TStruct fields) = CommitSendMessage_args{
  commitSendMessage_args_seq = P.maybe (commitSendMessage_args_seq default_CommitSendMessage_args) (\(_,_val3712) -> (case _val3712 of {T.TI32 _val3713 -> _val3713; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  commitSendMessage_args_messageId = P.maybe (commitSendMessage_args_messageId default_CommitSendMessage_args) (\(_,_val3712) -> (case _val3712 of {T.TString _val3714 -> E.decodeUtf8 _val3714; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  commitSendMessage_args_receiverMids = P.maybe (commitSendMessage_args_receiverMids default_CommitSendMessage_args) (\(_,_val3712) -> (case _val3712 of {T.TList _ _val3715 -> (Vector.fromList $ P.map (\_v3716 -> (case _v3716 of {T.TString _val3717 -> E.decodeUtf8 _val3717; _ -> P.error "wrong type"})) _val3715); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CommitSendMessage_args _ = P.error "not a struct"
read_CommitSendMessage_args :: T.Protocol p => p -> P.IO CommitSendMessage_args
read_CommitSendMessage_args iprot = to_CommitSendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessage_args)
decode_CommitSendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessage_args
decode_CommitSendMessage_args iprot bs = to_CommitSendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessage_args) bs
typemap_CommitSendMessage_args :: T.TypeMap
typemap_CommitSendMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("messageId",T.T_STRING)),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_CommitSendMessage_args :: CommitSendMessage_args
default_CommitSendMessage_args = CommitSendMessage_args{
  commitSendMessage_args_seq = 0,
  commitSendMessage_args_messageId = "",
  commitSendMessage_args_receiverMids = Vector.empty}
data CommitSendMessage_result = CommitSendMessage_result  { commitSendMessage_result_success :: (Map.HashMap LT.Text LT.Text)
  , commitSendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessage_result_success record   `H.hashWithSalt` commitSendMessage_result_e record  
instance QC.Arbitrary CommitSendMessage_result where 
  arbitrary = M.liftM CommitSendMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommitSendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessage_result{commitSendMessage_result_success = commitSendMessage_result_success obj} then P.Nothing else P.Just $ default_CommitSendMessage_result{commitSendMessage_result_success = commitSendMessage_result_success obj}
    , if obj == default_CommitSendMessage_result{commitSendMessage_result_e = commitSendMessage_result_e obj} then P.Nothing else P.Just $ default_CommitSendMessage_result{commitSendMessage_result_e = commitSendMessage_result_e obj}
    ]
from_CommitSendMessage_result :: CommitSendMessage_result -> T.ThriftVal
from_CommitSendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3720 -> (1, ("e",from_TalkException _v3720))) <$> commitSendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3720 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3721,_v3722) -> (T.TString $ E.encodeUtf8 _k3721, T.TString $ E.encodeUtf8 _v3722)) $ Map.toList _v3720))) $ commitSendMessage_result_success record
    , (\_v3720 -> (1, ("e",from_TalkException _v3720))) <$> commitSendMessage_result_e record
    ]
    )
write_CommitSendMessage_result :: T.Protocol p => p -> CommitSendMessage_result -> P.IO ()
write_CommitSendMessage_result oprot record = T.writeVal oprot $ from_CommitSendMessage_result record
encode_CommitSendMessage_result :: T.StatelessProtocol p => p -> CommitSendMessage_result -> LBS.ByteString
encode_CommitSendMessage_result oprot record = T.serializeVal oprot $ from_CommitSendMessage_result record
to_CommitSendMessage_result :: T.ThriftVal -> CommitSendMessage_result
to_CommitSendMessage_result (T.TStruct fields) = CommitSendMessage_result{
  commitSendMessage_result_success = P.maybe (commitSendMessage_result_success default_CommitSendMessage_result) (\(_,_val3724) -> (case _val3724 of {T.TMap _ _ _val3725 -> (Map.fromList $ P.map (\(_k3727,_v3726) -> ((case _k3727 of {T.TString _val3728 -> E.decodeUtf8 _val3728; _ -> P.error "wrong type"}),(case _v3726 of {T.TString _val3729 -> E.decodeUtf8 _val3729; _ -> P.error "wrong type"}))) _val3725); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  commitSendMessage_result_e = P.maybe (P.Nothing) (\(_,_val3724) -> P.Just (case _val3724 of {T.TStruct _val3730 -> (to_TalkException (T.TStruct _val3730)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CommitSendMessage_result _ = P.error "not a struct"
read_CommitSendMessage_result :: T.Protocol p => p -> P.IO CommitSendMessage_result
read_CommitSendMessage_result iprot = to_CommitSendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessage_result)
decode_CommitSendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessage_result
decode_CommitSendMessage_result iprot bs = to_CommitSendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessage_result) bs
typemap_CommitSendMessage_result :: T.TypeMap
typemap_CommitSendMessage_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CommitSendMessage_result :: CommitSendMessage_result
default_CommitSendMessage_result = CommitSendMessage_result{
  commitSendMessage_result_success = Map.empty,
  commitSendMessage_result_e = P.Nothing}
data CommitSendMessages_args = CommitSendMessages_args  { commitSendMessages_args_seq :: I.Int32
  , commitSendMessages_args_messageIds :: (Vector.Vector LT.Text)
  , commitSendMessages_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessages_args_seq record   `H.hashWithSalt` commitSendMessages_args_messageIds record   `H.hashWithSalt` commitSendMessages_args_receiverMids record  
instance QC.Arbitrary CommitSendMessages_args where 
  arbitrary = M.liftM CommitSendMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CommitSendMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessages_args{commitSendMessages_args_seq = commitSendMessages_args_seq obj} then P.Nothing else P.Just $ default_CommitSendMessages_args{commitSendMessages_args_seq = commitSendMessages_args_seq obj}
    , if obj == default_CommitSendMessages_args{commitSendMessages_args_messageIds = commitSendMessages_args_messageIds obj} then P.Nothing else P.Just $ default_CommitSendMessages_args{commitSendMessages_args_messageIds = commitSendMessages_args_messageIds obj}
    , if obj == default_CommitSendMessages_args{commitSendMessages_args_receiverMids = commitSendMessages_args_receiverMids obj} then P.Nothing else P.Just $ default_CommitSendMessages_args{commitSendMessages_args_receiverMids = commitSendMessages_args_receiverMids obj}
    ]
from_CommitSendMessages_args :: CommitSendMessages_args -> T.ThriftVal
from_CommitSendMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3733 -> P.Just (1, ("seq",T.TI32 _v3733))) $ commitSendMessages_args_seq record
  , (\_v3733 -> P.Just (2, ("messageIds",T.TList T.T_STRING $ P.map (\_v3735 -> T.TString $ E.encodeUtf8 _v3735) $ Vector.toList _v3733))) $ commitSendMessages_args_messageIds record
  , (\_v3733 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v3737 -> T.TString $ E.encodeUtf8 _v3737) $ Vector.toList _v3733))) $ commitSendMessages_args_receiverMids record
  ]
write_CommitSendMessages_args :: T.Protocol p => p -> CommitSendMessages_args -> P.IO ()
write_CommitSendMessages_args oprot record = T.writeVal oprot $ from_CommitSendMessages_args record
encode_CommitSendMessages_args :: T.StatelessProtocol p => p -> CommitSendMessages_args -> LBS.ByteString
encode_CommitSendMessages_args oprot record = T.serializeVal oprot $ from_CommitSendMessages_args record
to_CommitSendMessages_args :: T.ThriftVal -> CommitSendMessages_args
to_CommitSendMessages_args (T.TStruct fields) = CommitSendMessages_args{
  commitSendMessages_args_seq = P.maybe (commitSendMessages_args_seq default_CommitSendMessages_args) (\(_,_val3739) -> (case _val3739 of {T.TI32 _val3740 -> _val3740; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  commitSendMessages_args_messageIds = P.maybe (commitSendMessages_args_messageIds default_CommitSendMessages_args) (\(_,_val3739) -> (case _val3739 of {T.TList _ _val3741 -> (Vector.fromList $ P.map (\_v3742 -> (case _v3742 of {T.TString _val3743 -> E.decodeUtf8 _val3743; _ -> P.error "wrong type"})) _val3741); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  commitSendMessages_args_receiverMids = P.maybe (commitSendMessages_args_receiverMids default_CommitSendMessages_args) (\(_,_val3739) -> (case _val3739 of {T.TList _ _val3744 -> (Vector.fromList $ P.map (\_v3745 -> (case _v3745 of {T.TString _val3746 -> E.decodeUtf8 _val3746; _ -> P.error "wrong type"})) _val3744); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CommitSendMessages_args _ = P.error "not a struct"
read_CommitSendMessages_args :: T.Protocol p => p -> P.IO CommitSendMessages_args
read_CommitSendMessages_args iprot = to_CommitSendMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessages_args)
decode_CommitSendMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessages_args
decode_CommitSendMessages_args iprot bs = to_CommitSendMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessages_args) bs
typemap_CommitSendMessages_args :: T.TypeMap
typemap_CommitSendMessages_args = Map.fromList [(1,("seq",T.T_I32)),(2,("messageIds",(T.T_LIST T.T_STRING))),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_CommitSendMessages_args :: CommitSendMessages_args
default_CommitSendMessages_args = CommitSendMessages_args{
  commitSendMessages_args_seq = 0,
  commitSendMessages_args_messageIds = Vector.empty,
  commitSendMessages_args_receiverMids = Vector.empty}
data CommitSendMessages_result = CommitSendMessages_result  { commitSendMessages_result_success :: (Map.HashMap LT.Text LT.Text)
  , commitSendMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessages_result_success record   `H.hashWithSalt` commitSendMessages_result_e record  
instance QC.Arbitrary CommitSendMessages_result where 
  arbitrary = M.liftM CommitSendMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommitSendMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessages_result{commitSendMessages_result_success = commitSendMessages_result_success obj} then P.Nothing else P.Just $ default_CommitSendMessages_result{commitSendMessages_result_success = commitSendMessages_result_success obj}
    , if obj == default_CommitSendMessages_result{commitSendMessages_result_e = commitSendMessages_result_e obj} then P.Nothing else P.Just $ default_CommitSendMessages_result{commitSendMessages_result_e = commitSendMessages_result_e obj}
    ]
from_CommitSendMessages_result :: CommitSendMessages_result -> T.ThriftVal
from_CommitSendMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3749 -> (1, ("e",from_TalkException _v3749))) <$> commitSendMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3749 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3750,_v3751) -> (T.TString $ E.encodeUtf8 _k3750, T.TString $ E.encodeUtf8 _v3751)) $ Map.toList _v3749))) $ commitSendMessages_result_success record
    , (\_v3749 -> (1, ("e",from_TalkException _v3749))) <$> commitSendMessages_result_e record
    ]
    )
write_CommitSendMessages_result :: T.Protocol p => p -> CommitSendMessages_result -> P.IO ()
write_CommitSendMessages_result oprot record = T.writeVal oprot $ from_CommitSendMessages_result record
encode_CommitSendMessages_result :: T.StatelessProtocol p => p -> CommitSendMessages_result -> LBS.ByteString
encode_CommitSendMessages_result oprot record = T.serializeVal oprot $ from_CommitSendMessages_result record
to_CommitSendMessages_result :: T.ThriftVal -> CommitSendMessages_result
to_CommitSendMessages_result (T.TStruct fields) = CommitSendMessages_result{
  commitSendMessages_result_success = P.maybe (commitSendMessages_result_success default_CommitSendMessages_result) (\(_,_val3753) -> (case _val3753 of {T.TMap _ _ _val3754 -> (Map.fromList $ P.map (\(_k3756,_v3755) -> ((case _k3756 of {T.TString _val3757 -> E.decodeUtf8 _val3757; _ -> P.error "wrong type"}),(case _v3755 of {T.TString _val3758 -> E.decodeUtf8 _val3758; _ -> P.error "wrong type"}))) _val3754); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  commitSendMessages_result_e = P.maybe (P.Nothing) (\(_,_val3753) -> P.Just (case _val3753 of {T.TStruct _val3759 -> (to_TalkException (T.TStruct _val3759)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CommitSendMessages_result _ = P.error "not a struct"
read_CommitSendMessages_result :: T.Protocol p => p -> P.IO CommitSendMessages_result
read_CommitSendMessages_result iprot = to_CommitSendMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessages_result)
decode_CommitSendMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessages_result
decode_CommitSendMessages_result iprot bs = to_CommitSendMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessages_result) bs
typemap_CommitSendMessages_result :: T.TypeMap
typemap_CommitSendMessages_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CommitSendMessages_result :: CommitSendMessages_result
default_CommitSendMessages_result = CommitSendMessages_result{
  commitSendMessages_result_success = Map.empty,
  commitSendMessages_result_e = P.Nothing}
data CommitUpdateProfile_args = CommitUpdateProfile_args  { commitUpdateProfile_args_seq :: I.Int32
  , commitUpdateProfile_args_attrs :: (Vector.Vector ProfileAttribute)
  , commitUpdateProfile_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitUpdateProfile_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitUpdateProfile_args_seq record   `H.hashWithSalt` commitUpdateProfile_args_attrs record   `H.hashWithSalt` commitUpdateProfile_args_receiverMids record  
instance QC.Arbitrary CommitUpdateProfile_args where 
  arbitrary = M.liftM CommitUpdateProfile_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CommitUpdateProfile_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitUpdateProfile_args{commitUpdateProfile_args_seq = commitUpdateProfile_args_seq obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_args{commitUpdateProfile_args_seq = commitUpdateProfile_args_seq obj}
    , if obj == default_CommitUpdateProfile_args{commitUpdateProfile_args_attrs = commitUpdateProfile_args_attrs obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_args{commitUpdateProfile_args_attrs = commitUpdateProfile_args_attrs obj}
    , if obj == default_CommitUpdateProfile_args{commitUpdateProfile_args_receiverMids = commitUpdateProfile_args_receiverMids obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_args{commitUpdateProfile_args_receiverMids = commitUpdateProfile_args_receiverMids obj}
    ]
from_CommitUpdateProfile_args :: CommitUpdateProfile_args -> T.ThriftVal
from_CommitUpdateProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3762 -> P.Just (1, ("seq",T.TI32 _v3762))) $ commitUpdateProfile_args_seq record
  , (\_v3762 -> P.Just (2, ("attrs",T.TList T.T_I32 $ P.map (\_v3764 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3764) $ Vector.toList _v3762))) $ commitUpdateProfile_args_attrs record
  , (\_v3762 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v3766 -> T.TString $ E.encodeUtf8 _v3766) $ Vector.toList _v3762))) $ commitUpdateProfile_args_receiverMids record
  ]
write_CommitUpdateProfile_args :: T.Protocol p => p -> CommitUpdateProfile_args -> P.IO ()
write_CommitUpdateProfile_args oprot record = T.writeVal oprot $ from_CommitUpdateProfile_args record
encode_CommitUpdateProfile_args :: T.StatelessProtocol p => p -> CommitUpdateProfile_args -> LBS.ByteString
encode_CommitUpdateProfile_args oprot record = T.serializeVal oprot $ from_CommitUpdateProfile_args record
to_CommitUpdateProfile_args :: T.ThriftVal -> CommitUpdateProfile_args
to_CommitUpdateProfile_args (T.TStruct fields) = CommitUpdateProfile_args{
  commitUpdateProfile_args_seq = P.maybe (commitUpdateProfile_args_seq default_CommitUpdateProfile_args) (\(_,_val3768) -> (case _val3768 of {T.TI32 _val3769 -> _val3769; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  commitUpdateProfile_args_attrs = P.maybe (commitUpdateProfile_args_attrs default_CommitUpdateProfile_args) (\(_,_val3768) -> (case _val3768 of {T.TList _ _val3770 -> (Vector.fromList $ P.map (\_v3771 -> (case _v3771 of {T.TI32 _val3772 -> P.toEnum $ P.fromIntegral _val3772; _ -> P.error "wrong type"})) _val3770); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  commitUpdateProfile_args_receiverMids = P.maybe (commitUpdateProfile_args_receiverMids default_CommitUpdateProfile_args) (\(_,_val3768) -> (case _val3768 of {T.TList _ _val3773 -> (Vector.fromList $ P.map (\_v3774 -> (case _v3774 of {T.TString _val3775 -> E.decodeUtf8 _val3775; _ -> P.error "wrong type"})) _val3773); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CommitUpdateProfile_args _ = P.error "not a struct"
read_CommitUpdateProfile_args :: T.Protocol p => p -> P.IO CommitUpdateProfile_args
read_CommitUpdateProfile_args iprot = to_CommitUpdateProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_args)
decode_CommitUpdateProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitUpdateProfile_args
decode_CommitUpdateProfile_args iprot bs = to_CommitUpdateProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_args) bs
typemap_CommitUpdateProfile_args :: T.TypeMap
typemap_CommitUpdateProfile_args = Map.fromList [(1,("seq",T.T_I32)),(2,("attrs",(T.T_LIST T.T_I32))),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_CommitUpdateProfile_args :: CommitUpdateProfile_args
default_CommitUpdateProfile_args = CommitUpdateProfile_args{
  commitUpdateProfile_args_seq = 0,
  commitUpdateProfile_args_attrs = Vector.empty,
  commitUpdateProfile_args_receiverMids = Vector.empty}
data CommitUpdateProfile_result = CommitUpdateProfile_result  { commitUpdateProfile_result_success :: (Map.HashMap LT.Text LT.Text)
  , commitUpdateProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitUpdateProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitUpdateProfile_result_success record   `H.hashWithSalt` commitUpdateProfile_result_e record  
instance QC.Arbitrary CommitUpdateProfile_result where 
  arbitrary = M.liftM CommitUpdateProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommitUpdateProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitUpdateProfile_result{commitUpdateProfile_result_success = commitUpdateProfile_result_success obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_result{commitUpdateProfile_result_success = commitUpdateProfile_result_success obj}
    , if obj == default_CommitUpdateProfile_result{commitUpdateProfile_result_e = commitUpdateProfile_result_e obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_result{commitUpdateProfile_result_e = commitUpdateProfile_result_e obj}
    ]
from_CommitUpdateProfile_result :: CommitUpdateProfile_result -> T.ThriftVal
from_CommitUpdateProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3778 -> (1, ("e",from_TalkException _v3778))) <$> commitUpdateProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3778 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3779,_v3780) -> (T.TString $ E.encodeUtf8 _k3779, T.TString $ E.encodeUtf8 _v3780)) $ Map.toList _v3778))) $ commitUpdateProfile_result_success record
    , (\_v3778 -> (1, ("e",from_TalkException _v3778))) <$> commitUpdateProfile_result_e record
    ]
    )
write_CommitUpdateProfile_result :: T.Protocol p => p -> CommitUpdateProfile_result -> P.IO ()
write_CommitUpdateProfile_result oprot record = T.writeVal oprot $ from_CommitUpdateProfile_result record
encode_CommitUpdateProfile_result :: T.StatelessProtocol p => p -> CommitUpdateProfile_result -> LBS.ByteString
encode_CommitUpdateProfile_result oprot record = T.serializeVal oprot $ from_CommitUpdateProfile_result record
to_CommitUpdateProfile_result :: T.ThriftVal -> CommitUpdateProfile_result
to_CommitUpdateProfile_result (T.TStruct fields) = CommitUpdateProfile_result{
  commitUpdateProfile_result_success = P.maybe (commitUpdateProfile_result_success default_CommitUpdateProfile_result) (\(_,_val3782) -> (case _val3782 of {T.TMap _ _ _val3783 -> (Map.fromList $ P.map (\(_k3785,_v3784) -> ((case _k3785 of {T.TString _val3786 -> E.decodeUtf8 _val3786; _ -> P.error "wrong type"}),(case _v3784 of {T.TString _val3787 -> E.decodeUtf8 _val3787; _ -> P.error "wrong type"}))) _val3783); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  commitUpdateProfile_result_e = P.maybe (P.Nothing) (\(_,_val3782) -> P.Just (case _val3782 of {T.TStruct _val3788 -> (to_TalkException (T.TStruct _val3788)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CommitUpdateProfile_result _ = P.error "not a struct"
read_CommitUpdateProfile_result :: T.Protocol p => p -> P.IO CommitUpdateProfile_result
read_CommitUpdateProfile_result iprot = to_CommitUpdateProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_result)
decode_CommitUpdateProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitUpdateProfile_result
decode_CommitUpdateProfile_result iprot bs = to_CommitUpdateProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_result) bs
typemap_CommitUpdateProfile_result :: T.TypeMap
typemap_CommitUpdateProfile_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CommitUpdateProfile_result :: CommitUpdateProfile_result
default_CommitUpdateProfile_result = CommitUpdateProfile_result{
  commitUpdateProfile_result_success = Map.empty,
  commitUpdateProfile_result_e = P.Nothing}
data ConfirmEmail_args = ConfirmEmail_args  { confirmEmail_args_verifier :: LT.Text
  , confirmEmail_args_pinCode :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmEmail_args_verifier record   `H.hashWithSalt` confirmEmail_args_pinCode record  
instance QC.Arbitrary ConfirmEmail_args where 
  arbitrary = M.liftM ConfirmEmail_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConfirmEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmEmail_args{confirmEmail_args_verifier = confirmEmail_args_verifier obj} then P.Nothing else P.Just $ default_ConfirmEmail_args{confirmEmail_args_verifier = confirmEmail_args_verifier obj}
    , if obj == default_ConfirmEmail_args{confirmEmail_args_pinCode = confirmEmail_args_pinCode obj} then P.Nothing else P.Just $ default_ConfirmEmail_args{confirmEmail_args_pinCode = confirmEmail_args_pinCode obj}
    ]
from_ConfirmEmail_args :: ConfirmEmail_args -> T.ThriftVal
from_ConfirmEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3791 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v3791))) $ confirmEmail_args_verifier record
  , (\_v3791 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v3791))) $ confirmEmail_args_pinCode record
  ]
write_ConfirmEmail_args :: T.Protocol p => p -> ConfirmEmail_args -> P.IO ()
write_ConfirmEmail_args oprot record = T.writeVal oprot $ from_ConfirmEmail_args record
encode_ConfirmEmail_args :: T.StatelessProtocol p => p -> ConfirmEmail_args -> LBS.ByteString
encode_ConfirmEmail_args oprot record = T.serializeVal oprot $ from_ConfirmEmail_args record
to_ConfirmEmail_args :: T.ThriftVal -> ConfirmEmail_args
to_ConfirmEmail_args (T.TStruct fields) = ConfirmEmail_args{
  confirmEmail_args_verifier = P.maybe (confirmEmail_args_verifier default_ConfirmEmail_args) (\(_,_val3793) -> (case _val3793 of {T.TString _val3794 -> E.decodeUtf8 _val3794; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  confirmEmail_args_pinCode = P.maybe (confirmEmail_args_pinCode default_ConfirmEmail_args) (\(_,_val3793) -> (case _val3793 of {T.TString _val3795 -> E.decodeUtf8 _val3795; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ConfirmEmail_args _ = P.error "not a struct"
read_ConfirmEmail_args :: T.Protocol p => p -> P.IO ConfirmEmail_args
read_ConfirmEmail_args iprot = to_ConfirmEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmEmail_args)
decode_ConfirmEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmEmail_args
decode_ConfirmEmail_args iprot bs = to_ConfirmEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmEmail_args) bs
typemap_ConfirmEmail_args :: T.TypeMap
typemap_ConfirmEmail_args = Map.fromList [(2,("verifier",T.T_STRING)),(3,("pinCode",T.T_STRING))]
default_ConfirmEmail_args :: ConfirmEmail_args
default_ConfirmEmail_args = ConfirmEmail_args{
  confirmEmail_args_verifier = "",
  confirmEmail_args_pinCode = ""}
data ConfirmEmail_result = ConfirmEmail_result  { confirmEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmEmail_result_e record  
instance QC.Arbitrary ConfirmEmail_result where 
  arbitrary = M.liftM ConfirmEmail_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ConfirmEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmEmail_result{confirmEmail_result_e = confirmEmail_result_e obj} then P.Nothing else P.Just $ default_ConfirmEmail_result{confirmEmail_result_e = confirmEmail_result_e obj}
    ]
from_ConfirmEmail_result :: ConfirmEmail_result -> T.ThriftVal
from_ConfirmEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3798 -> (1, ("e",from_TalkException _v3798))) <$> confirmEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3798 -> (1, ("e",from_TalkException _v3798))) <$> confirmEmail_result_e record
    ]
    )
write_ConfirmEmail_result :: T.Protocol p => p -> ConfirmEmail_result -> P.IO ()
write_ConfirmEmail_result oprot record = T.writeVal oprot $ from_ConfirmEmail_result record
encode_ConfirmEmail_result :: T.StatelessProtocol p => p -> ConfirmEmail_result -> LBS.ByteString
encode_ConfirmEmail_result oprot record = T.serializeVal oprot $ from_ConfirmEmail_result record
to_ConfirmEmail_result :: T.ThriftVal -> ConfirmEmail_result
to_ConfirmEmail_result (T.TStruct fields) = ConfirmEmail_result{
  confirmEmail_result_e = P.maybe (P.Nothing) (\(_,_val3800) -> P.Just (case _val3800 of {T.TStruct _val3801 -> (to_TalkException (T.TStruct _val3801)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ConfirmEmail_result _ = P.error "not a struct"
read_ConfirmEmail_result :: T.Protocol p => p -> P.IO ConfirmEmail_result
read_ConfirmEmail_result iprot = to_ConfirmEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmEmail_result)
decode_ConfirmEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmEmail_result
decode_ConfirmEmail_result iprot bs = to_ConfirmEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmEmail_result) bs
typemap_ConfirmEmail_result :: T.TypeMap
typemap_ConfirmEmail_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ConfirmEmail_result :: ConfirmEmail_result
default_ConfirmEmail_result = ConfirmEmail_result{
  confirmEmail_result_e = P.Nothing}
data CreateGroup_args = CreateGroup_args  { createGroup_args_seq :: I.Int32
  , createGroup_args_name :: LT.Text
  , createGroup_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createGroup_args_seq record   `H.hashWithSalt` createGroup_args_name record   `H.hashWithSalt` createGroup_args_contactIds record  
instance QC.Arbitrary CreateGroup_args where 
  arbitrary = M.liftM CreateGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateGroup_args{createGroup_args_seq = createGroup_args_seq obj} then P.Nothing else P.Just $ default_CreateGroup_args{createGroup_args_seq = createGroup_args_seq obj}
    , if obj == default_CreateGroup_args{createGroup_args_name = createGroup_args_name obj} then P.Nothing else P.Just $ default_CreateGroup_args{createGroup_args_name = createGroup_args_name obj}
    , if obj == default_CreateGroup_args{createGroup_args_contactIds = createGroup_args_contactIds obj} then P.Nothing else P.Just $ default_CreateGroup_args{createGroup_args_contactIds = createGroup_args_contactIds obj}
    ]
from_CreateGroup_args :: CreateGroup_args -> T.ThriftVal
from_CreateGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3804 -> P.Just (1, ("seq",T.TI32 _v3804))) $ createGroup_args_seq record
  , (\_v3804 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v3804))) $ createGroup_args_name record
  , (\_v3804 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v3806 -> T.TString $ E.encodeUtf8 _v3806) $ Vector.toList _v3804))) $ createGroup_args_contactIds record
  ]
write_CreateGroup_args :: T.Protocol p => p -> CreateGroup_args -> P.IO ()
write_CreateGroup_args oprot record = T.writeVal oprot $ from_CreateGroup_args record
encode_CreateGroup_args :: T.StatelessProtocol p => p -> CreateGroup_args -> LBS.ByteString
encode_CreateGroup_args oprot record = T.serializeVal oprot $ from_CreateGroup_args record
to_CreateGroup_args :: T.ThriftVal -> CreateGroup_args
to_CreateGroup_args (T.TStruct fields) = CreateGroup_args{
  createGroup_args_seq = P.maybe (createGroup_args_seq default_CreateGroup_args) (\(_,_val3808) -> (case _val3808 of {T.TI32 _val3809 -> _val3809; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createGroup_args_name = P.maybe (createGroup_args_name default_CreateGroup_args) (\(_,_val3808) -> (case _val3808 of {T.TString _val3810 -> E.decodeUtf8 _val3810; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createGroup_args_contactIds = P.maybe (createGroup_args_contactIds default_CreateGroup_args) (\(_,_val3808) -> (case _val3808 of {T.TList _ _val3811 -> (Vector.fromList $ P.map (\_v3812 -> (case _v3812 of {T.TString _val3813 -> E.decodeUtf8 _val3813; _ -> P.error "wrong type"})) _val3811); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateGroup_args _ = P.error "not a struct"
read_CreateGroup_args :: T.Protocol p => p -> P.IO CreateGroup_args
read_CreateGroup_args iprot = to_CreateGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateGroup_args)
decode_CreateGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateGroup_args
decode_CreateGroup_args iprot bs = to_CreateGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateGroup_args) bs
typemap_CreateGroup_args :: T.TypeMap
typemap_CreateGroup_args = Map.fromList [(1,("seq",T.T_I32)),(2,("name",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_CreateGroup_args :: CreateGroup_args
default_CreateGroup_args = CreateGroup_args{
  createGroup_args_seq = 0,
  createGroup_args_name = "",
  createGroup_args_contactIds = Vector.empty}
data CreateGroup_result = CreateGroup_result  { createGroup_result_success :: Group
  , createGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createGroup_result_success record   `H.hashWithSalt` createGroup_result_e record  
instance QC.Arbitrary CreateGroup_result where 
  arbitrary = M.liftM CreateGroup_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateGroup_result{createGroup_result_success = createGroup_result_success obj} then P.Nothing else P.Just $ default_CreateGroup_result{createGroup_result_success = createGroup_result_success obj}
    , if obj == default_CreateGroup_result{createGroup_result_e = createGroup_result_e obj} then P.Nothing else P.Just $ default_CreateGroup_result{createGroup_result_e = createGroup_result_e obj}
    ]
from_CreateGroup_result :: CreateGroup_result -> T.ThriftVal
from_CreateGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3816 -> (1, ("e",from_TalkException _v3816))) <$> createGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3816 -> P.Just (0, ("success",from_Group _v3816))) $ createGroup_result_success record
    , (\_v3816 -> (1, ("e",from_TalkException _v3816))) <$> createGroup_result_e record
    ]
    )
write_CreateGroup_result :: T.Protocol p => p -> CreateGroup_result -> P.IO ()
write_CreateGroup_result oprot record = T.writeVal oprot $ from_CreateGroup_result record
encode_CreateGroup_result :: T.StatelessProtocol p => p -> CreateGroup_result -> LBS.ByteString
encode_CreateGroup_result oprot record = T.serializeVal oprot $ from_CreateGroup_result record
to_CreateGroup_result :: T.ThriftVal -> CreateGroup_result
to_CreateGroup_result (T.TStruct fields) = CreateGroup_result{
  createGroup_result_success = P.maybe (createGroup_result_success default_CreateGroup_result) (\(_,_val3818) -> (case _val3818 of {T.TStruct _val3819 -> (to_Group (T.TStruct _val3819)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createGroup_result_e = P.maybe (P.Nothing) (\(_,_val3818) -> P.Just (case _val3818 of {T.TStruct _val3820 -> (to_TalkException (T.TStruct _val3820)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateGroup_result _ = P.error "not a struct"
read_CreateGroup_result :: T.Protocol p => p -> P.IO CreateGroup_result
read_CreateGroup_result iprot = to_CreateGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateGroup_result)
decode_CreateGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateGroup_result
decode_CreateGroup_result iprot bs = to_CreateGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateGroup_result) bs
typemap_CreateGroup_result :: T.TypeMap
typemap_CreateGroup_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateGroup_result :: CreateGroup_result
default_CreateGroup_result = CreateGroup_result{
  createGroup_result_success = default_Group,
  createGroup_result_e = P.Nothing}
data CreateQrcodeBase64Image_args = CreateQrcodeBase64Image_args  { createQrcodeBase64Image_args_url :: LT.Text
  , createQrcodeBase64Image_args_characterSet :: LT.Text
  , createQrcodeBase64Image_args_imageSize :: I.Int32
  , createQrcodeBase64Image_args_x :: I.Int32
  , createQrcodeBase64Image_args_y :: I.Int32
  , createQrcodeBase64Image_args_width :: I.Int32
  , createQrcodeBase64Image_args_height :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateQrcodeBase64Image_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createQrcodeBase64Image_args_url record   `H.hashWithSalt` createQrcodeBase64Image_args_characterSet record   `H.hashWithSalt` createQrcodeBase64Image_args_imageSize record   `H.hashWithSalt` createQrcodeBase64Image_args_x record   `H.hashWithSalt` createQrcodeBase64Image_args_y record   `H.hashWithSalt` createQrcodeBase64Image_args_width record   `H.hashWithSalt` createQrcodeBase64Image_args_height record  
instance QC.Arbitrary CreateQrcodeBase64Image_args where 
  arbitrary = M.liftM CreateQrcodeBase64Image_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateQrcodeBase64Image_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_url = createQrcodeBase64Image_args_url obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_url = createQrcodeBase64Image_args_url obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_characterSet = createQrcodeBase64Image_args_characterSet obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_characterSet = createQrcodeBase64Image_args_characterSet obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_imageSize = createQrcodeBase64Image_args_imageSize obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_imageSize = createQrcodeBase64Image_args_imageSize obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_x = createQrcodeBase64Image_args_x obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_x = createQrcodeBase64Image_args_x obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_y = createQrcodeBase64Image_args_y obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_y = createQrcodeBase64Image_args_y obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_width = createQrcodeBase64Image_args_width obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_width = createQrcodeBase64Image_args_width obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_height = createQrcodeBase64Image_args_height obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_height = createQrcodeBase64Image_args_height obj}
    ]
from_CreateQrcodeBase64Image_args :: CreateQrcodeBase64Image_args -> T.ThriftVal
from_CreateQrcodeBase64Image_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3823 -> P.Just (2, ("url",T.TString $ E.encodeUtf8 _v3823))) $ createQrcodeBase64Image_args_url record
  , (\_v3823 -> P.Just (3, ("characterSet",T.TString $ E.encodeUtf8 _v3823))) $ createQrcodeBase64Image_args_characterSet record
  , (\_v3823 -> P.Just (4, ("imageSize",T.TI32 _v3823))) $ createQrcodeBase64Image_args_imageSize record
  , (\_v3823 -> P.Just (5, ("x",T.TI32 _v3823))) $ createQrcodeBase64Image_args_x record
  , (\_v3823 -> P.Just (6, ("y",T.TI32 _v3823))) $ createQrcodeBase64Image_args_y record
  , (\_v3823 -> P.Just (7, ("width",T.TI32 _v3823))) $ createQrcodeBase64Image_args_width record
  , (\_v3823 -> P.Just (8, ("height",T.TI32 _v3823))) $ createQrcodeBase64Image_args_height record
  ]
write_CreateQrcodeBase64Image_args :: T.Protocol p => p -> CreateQrcodeBase64Image_args -> P.IO ()
write_CreateQrcodeBase64Image_args oprot record = T.writeVal oprot $ from_CreateQrcodeBase64Image_args record
encode_CreateQrcodeBase64Image_args :: T.StatelessProtocol p => p -> CreateQrcodeBase64Image_args -> LBS.ByteString
encode_CreateQrcodeBase64Image_args oprot record = T.serializeVal oprot $ from_CreateQrcodeBase64Image_args record
to_CreateQrcodeBase64Image_args :: T.ThriftVal -> CreateQrcodeBase64Image_args
to_CreateQrcodeBase64Image_args (T.TStruct fields) = CreateQrcodeBase64Image_args{
  createQrcodeBase64Image_args_url = P.maybe (createQrcodeBase64Image_args_url default_CreateQrcodeBase64Image_args) (\(_,_val3825) -> (case _val3825 of {T.TString _val3826 -> E.decodeUtf8 _val3826; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createQrcodeBase64Image_args_characterSet = P.maybe (createQrcodeBase64Image_args_characterSet default_CreateQrcodeBase64Image_args) (\(_,_val3825) -> (case _val3825 of {T.TString _val3827 -> E.decodeUtf8 _val3827; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  createQrcodeBase64Image_args_imageSize = P.maybe (createQrcodeBase64Image_args_imageSize default_CreateQrcodeBase64Image_args) (\(_,_val3825) -> (case _val3825 of {T.TI32 _val3828 -> _val3828; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  createQrcodeBase64Image_args_x = P.maybe (createQrcodeBase64Image_args_x default_CreateQrcodeBase64Image_args) (\(_,_val3825) -> (case _val3825 of {T.TI32 _val3829 -> _val3829; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  createQrcodeBase64Image_args_y = P.maybe (createQrcodeBase64Image_args_y default_CreateQrcodeBase64Image_args) (\(_,_val3825) -> (case _val3825 of {T.TI32 _val3830 -> _val3830; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  createQrcodeBase64Image_args_width = P.maybe (createQrcodeBase64Image_args_width default_CreateQrcodeBase64Image_args) (\(_,_val3825) -> (case _val3825 of {T.TI32 _val3831 -> _val3831; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  createQrcodeBase64Image_args_height = P.maybe (createQrcodeBase64Image_args_height default_CreateQrcodeBase64Image_args) (\(_,_val3825) -> (case _val3825 of {T.TI32 _val3832 -> _val3832; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_CreateQrcodeBase64Image_args _ = P.error "not a struct"
read_CreateQrcodeBase64Image_args :: T.Protocol p => p -> P.IO CreateQrcodeBase64Image_args
read_CreateQrcodeBase64Image_args iprot = to_CreateQrcodeBase64Image_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_args)
decode_CreateQrcodeBase64Image_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateQrcodeBase64Image_args
decode_CreateQrcodeBase64Image_args iprot bs = to_CreateQrcodeBase64Image_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_args) bs
typemap_CreateQrcodeBase64Image_args :: T.TypeMap
typemap_CreateQrcodeBase64Image_args = Map.fromList [(2,("url",T.T_STRING)),(3,("characterSet",T.T_STRING)),(4,("imageSize",T.T_I32)),(5,("x",T.T_I32)),(6,("y",T.T_I32)),(7,("width",T.T_I32)),(8,("height",T.T_I32))]
default_CreateQrcodeBase64Image_args :: CreateQrcodeBase64Image_args
default_CreateQrcodeBase64Image_args = CreateQrcodeBase64Image_args{
  createQrcodeBase64Image_args_url = "",
  createQrcodeBase64Image_args_characterSet = "",
  createQrcodeBase64Image_args_imageSize = 0,
  createQrcodeBase64Image_args_x = 0,
  createQrcodeBase64Image_args_y = 0,
  createQrcodeBase64Image_args_width = 0,
  createQrcodeBase64Image_args_height = 0}
data CreateQrcodeBase64Image_result = CreateQrcodeBase64Image_result  { createQrcodeBase64Image_result_success :: LT.Text
  , createQrcodeBase64Image_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateQrcodeBase64Image_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createQrcodeBase64Image_result_success record   `H.hashWithSalt` createQrcodeBase64Image_result_e record  
instance QC.Arbitrary CreateQrcodeBase64Image_result where 
  arbitrary = M.liftM CreateQrcodeBase64Image_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateQrcodeBase64Image_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_success = createQrcodeBase64Image_result_success obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_success = createQrcodeBase64Image_result_success obj}
    , if obj == default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_e = createQrcodeBase64Image_result_e obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_e = createQrcodeBase64Image_result_e obj}
    ]
from_CreateQrcodeBase64Image_result :: CreateQrcodeBase64Image_result -> T.ThriftVal
from_CreateQrcodeBase64Image_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3835 -> (1, ("e",from_TalkException _v3835))) <$> createQrcodeBase64Image_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3835 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v3835))) $ createQrcodeBase64Image_result_success record
    , (\_v3835 -> (1, ("e",from_TalkException _v3835))) <$> createQrcodeBase64Image_result_e record
    ]
    )
write_CreateQrcodeBase64Image_result :: T.Protocol p => p -> CreateQrcodeBase64Image_result -> P.IO ()
write_CreateQrcodeBase64Image_result oprot record = T.writeVal oprot $ from_CreateQrcodeBase64Image_result record
encode_CreateQrcodeBase64Image_result :: T.StatelessProtocol p => p -> CreateQrcodeBase64Image_result -> LBS.ByteString
encode_CreateQrcodeBase64Image_result oprot record = T.serializeVal oprot $ from_CreateQrcodeBase64Image_result record
to_CreateQrcodeBase64Image_result :: T.ThriftVal -> CreateQrcodeBase64Image_result
to_CreateQrcodeBase64Image_result (T.TStruct fields) = CreateQrcodeBase64Image_result{
  createQrcodeBase64Image_result_success = P.maybe (createQrcodeBase64Image_result_success default_CreateQrcodeBase64Image_result) (\(_,_val3837) -> (case _val3837 of {T.TString _val3838 -> E.decodeUtf8 _val3838; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createQrcodeBase64Image_result_e = P.maybe (P.Nothing) (\(_,_val3837) -> P.Just (case _val3837 of {T.TStruct _val3839 -> (to_TalkException (T.TStruct _val3839)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateQrcodeBase64Image_result _ = P.error "not a struct"
read_CreateQrcodeBase64Image_result :: T.Protocol p => p -> P.IO CreateQrcodeBase64Image_result
read_CreateQrcodeBase64Image_result iprot = to_CreateQrcodeBase64Image_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_result)
decode_CreateQrcodeBase64Image_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateQrcodeBase64Image_result
decode_CreateQrcodeBase64Image_result iprot bs = to_CreateQrcodeBase64Image_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_result) bs
typemap_CreateQrcodeBase64Image_result :: T.TypeMap
typemap_CreateQrcodeBase64Image_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateQrcodeBase64Image_result :: CreateQrcodeBase64Image_result
default_CreateQrcodeBase64Image_result = CreateQrcodeBase64Image_result{
  createQrcodeBase64Image_result_success = "",
  createQrcodeBase64Image_result_e = P.Nothing}
data CreateRoom_args = CreateRoom_args  { createRoom_args_reqSeq :: I.Int32
  , createRoom_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoom_args_reqSeq record   `H.hashWithSalt` createRoom_args_contactIds record  
instance QC.Arbitrary CreateRoom_args where 
  arbitrary = M.liftM CreateRoom_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoom_args{createRoom_args_reqSeq = createRoom_args_reqSeq obj} then P.Nothing else P.Just $ default_CreateRoom_args{createRoom_args_reqSeq = createRoom_args_reqSeq obj}
    , if obj == default_CreateRoom_args{createRoom_args_contactIds = createRoom_args_contactIds obj} then P.Nothing else P.Just $ default_CreateRoom_args{createRoom_args_contactIds = createRoom_args_contactIds obj}
    ]
from_CreateRoom_args :: CreateRoom_args -> T.ThriftVal
from_CreateRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3842 -> P.Just (1, ("reqSeq",T.TI32 _v3842))) $ createRoom_args_reqSeq record
  , (\_v3842 -> P.Just (2, ("contactIds",T.TList T.T_STRING $ P.map (\_v3844 -> T.TString $ E.encodeUtf8 _v3844) $ Vector.toList _v3842))) $ createRoom_args_contactIds record
  ]
write_CreateRoom_args :: T.Protocol p => p -> CreateRoom_args -> P.IO ()
write_CreateRoom_args oprot record = T.writeVal oprot $ from_CreateRoom_args record
encode_CreateRoom_args :: T.StatelessProtocol p => p -> CreateRoom_args -> LBS.ByteString
encode_CreateRoom_args oprot record = T.serializeVal oprot $ from_CreateRoom_args record
to_CreateRoom_args :: T.ThriftVal -> CreateRoom_args
to_CreateRoom_args (T.TStruct fields) = CreateRoom_args{
  createRoom_args_reqSeq = P.maybe (createRoom_args_reqSeq default_CreateRoom_args) (\(_,_val3846) -> (case _val3846 of {T.TI32 _val3847 -> _val3847; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createRoom_args_contactIds = P.maybe (createRoom_args_contactIds default_CreateRoom_args) (\(_,_val3846) -> (case _val3846 of {T.TList _ _val3848 -> (Vector.fromList $ P.map (\_v3849 -> (case _v3849 of {T.TString _val3850 -> E.decodeUtf8 _val3850; _ -> P.error "wrong type"})) _val3848); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateRoom_args _ = P.error "not a struct"
read_CreateRoom_args :: T.Protocol p => p -> P.IO CreateRoom_args
read_CreateRoom_args iprot = to_CreateRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoom_args)
decode_CreateRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoom_args
decode_CreateRoom_args iprot bs = to_CreateRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoom_args) bs
typemap_CreateRoom_args :: T.TypeMap
typemap_CreateRoom_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("contactIds",(T.T_LIST T.T_STRING)))]
default_CreateRoom_args :: CreateRoom_args
default_CreateRoom_args = CreateRoom_args{
  createRoom_args_reqSeq = 0,
  createRoom_args_contactIds = Vector.empty}
data CreateRoom_result = CreateRoom_result  { createRoom_result_success :: Room
  , createRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoom_result_success record   `H.hashWithSalt` createRoom_result_e record  
instance QC.Arbitrary CreateRoom_result where 
  arbitrary = M.liftM CreateRoom_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoom_result{createRoom_result_success = createRoom_result_success obj} then P.Nothing else P.Just $ default_CreateRoom_result{createRoom_result_success = createRoom_result_success obj}
    , if obj == default_CreateRoom_result{createRoom_result_e = createRoom_result_e obj} then P.Nothing else P.Just $ default_CreateRoom_result{createRoom_result_e = createRoom_result_e obj}
    ]
from_CreateRoom_result :: CreateRoom_result -> T.ThriftVal
from_CreateRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3853 -> (1, ("e",from_TalkException _v3853))) <$> createRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3853 -> P.Just (0, ("success",from_Room _v3853))) $ createRoom_result_success record
    , (\_v3853 -> (1, ("e",from_TalkException _v3853))) <$> createRoom_result_e record
    ]
    )
write_CreateRoom_result :: T.Protocol p => p -> CreateRoom_result -> P.IO ()
write_CreateRoom_result oprot record = T.writeVal oprot $ from_CreateRoom_result record
encode_CreateRoom_result :: T.StatelessProtocol p => p -> CreateRoom_result -> LBS.ByteString
encode_CreateRoom_result oprot record = T.serializeVal oprot $ from_CreateRoom_result record
to_CreateRoom_result :: T.ThriftVal -> CreateRoom_result
to_CreateRoom_result (T.TStruct fields) = CreateRoom_result{
  createRoom_result_success = P.maybe (createRoom_result_success default_CreateRoom_result) (\(_,_val3855) -> (case _val3855 of {T.TStruct _val3856 -> (to_Room (T.TStruct _val3856)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createRoom_result_e = P.maybe (P.Nothing) (\(_,_val3855) -> P.Just (case _val3855 of {T.TStruct _val3857 -> (to_TalkException (T.TStruct _val3857)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateRoom_result _ = P.error "not a struct"
read_CreateRoom_result :: T.Protocol p => p -> P.IO CreateRoom_result
read_CreateRoom_result iprot = to_CreateRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoom_result)
decode_CreateRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoom_result
decode_CreateRoom_result iprot bs = to_CreateRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoom_result) bs
typemap_CreateRoom_result :: T.TypeMap
typemap_CreateRoom_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateRoom_result :: CreateRoom_result
default_CreateRoom_result = CreateRoom_result{
  createRoom_result_success = default_Room,
  createRoom_result_e = P.Nothing}
data CreateSession_args = CreateSession_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSession_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary CreateSession_args where 
  arbitrary = QC.elements [CreateSession_args]
from_CreateSession_args :: CreateSession_args -> T.ThriftVal
from_CreateSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_CreateSession_args :: T.Protocol p => p -> CreateSession_args -> P.IO ()
write_CreateSession_args oprot record = T.writeVal oprot $ from_CreateSession_args record
encode_CreateSession_args :: T.StatelessProtocol p => p -> CreateSession_args -> LBS.ByteString
encode_CreateSession_args oprot record = T.serializeVal oprot $ from_CreateSession_args record
to_CreateSession_args :: T.ThriftVal -> CreateSession_args
to_CreateSession_args (T.TStruct fields) = CreateSession_args{

  }
to_CreateSession_args _ = P.error "not a struct"
read_CreateSession_args :: T.Protocol p => p -> P.IO CreateSession_args
read_CreateSession_args iprot = to_CreateSession_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateSession_args)
decode_CreateSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSession_args
decode_CreateSession_args iprot bs = to_CreateSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSession_args) bs
typemap_CreateSession_args :: T.TypeMap
typemap_CreateSession_args = Map.fromList []
default_CreateSession_args :: CreateSession_args
default_CreateSession_args = CreateSession_args{
}
data CreateSession_result = CreateSession_result  { createSession_result_success :: LT.Text
  , createSession_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSession_result_success record   `H.hashWithSalt` createSession_result_e record  
instance QC.Arbitrary CreateSession_result where 
  arbitrary = M.liftM CreateSession_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSession_result{createSession_result_success = createSession_result_success obj} then P.Nothing else P.Just $ default_CreateSession_result{createSession_result_success = createSession_result_success obj}
    , if obj == default_CreateSession_result{createSession_result_e = createSession_result_e obj} then P.Nothing else P.Just $ default_CreateSession_result{createSession_result_e = createSession_result_e obj}
    ]
from_CreateSession_result :: CreateSession_result -> T.ThriftVal
from_CreateSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3865 -> (1, ("e",from_TalkException _v3865))) <$> createSession_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3865 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v3865))) $ createSession_result_success record
    , (\_v3865 -> (1, ("e",from_TalkException _v3865))) <$> createSession_result_e record
    ]
    )
write_CreateSession_result :: T.Protocol p => p -> CreateSession_result -> P.IO ()
write_CreateSession_result oprot record = T.writeVal oprot $ from_CreateSession_result record
encode_CreateSession_result :: T.StatelessProtocol p => p -> CreateSession_result -> LBS.ByteString
encode_CreateSession_result oprot record = T.serializeVal oprot $ from_CreateSession_result record
to_CreateSession_result :: T.ThriftVal -> CreateSession_result
to_CreateSession_result (T.TStruct fields) = CreateSession_result{
  createSession_result_success = P.maybe (createSession_result_success default_CreateSession_result) (\(_,_val3867) -> (case _val3867 of {T.TString _val3868 -> E.decodeUtf8 _val3868; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createSession_result_e = P.maybe (P.Nothing) (\(_,_val3867) -> P.Just (case _val3867 of {T.TStruct _val3869 -> (to_TalkException (T.TStruct _val3869)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSession_result _ = P.error "not a struct"
read_CreateSession_result :: T.Protocol p => p -> P.IO CreateSession_result
read_CreateSession_result iprot = to_CreateSession_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateSession_result)
decode_CreateSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSession_result
decode_CreateSession_result iprot bs = to_CreateSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSession_result) bs
typemap_CreateSession_result :: T.TypeMap
typemap_CreateSession_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateSession_result :: CreateSession_result
default_CreateSession_result = CreateSession_result{
  createSession_result_success = "",
  createSession_result_e = P.Nothing}
data FetchAnnouncements_args = FetchAnnouncements_args  { fetchAnnouncements_args_lastFetchedIndex :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchAnnouncements_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchAnnouncements_args_lastFetchedIndex record  
instance QC.Arbitrary FetchAnnouncements_args where 
  arbitrary = M.liftM FetchAnnouncements_args (QC.arbitrary)
  shrink obj | obj == default_FetchAnnouncements_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchAnnouncements_args{fetchAnnouncements_args_lastFetchedIndex = fetchAnnouncements_args_lastFetchedIndex obj} then P.Nothing else P.Just $ default_FetchAnnouncements_args{fetchAnnouncements_args_lastFetchedIndex = fetchAnnouncements_args_lastFetchedIndex obj}
    ]
from_FetchAnnouncements_args :: FetchAnnouncements_args -> T.ThriftVal
from_FetchAnnouncements_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3872 -> P.Just (2, ("lastFetchedIndex",T.TI32 _v3872))) $ fetchAnnouncements_args_lastFetchedIndex record
  ]
write_FetchAnnouncements_args :: T.Protocol p => p -> FetchAnnouncements_args -> P.IO ()
write_FetchAnnouncements_args oprot record = T.writeVal oprot $ from_FetchAnnouncements_args record
encode_FetchAnnouncements_args :: T.StatelessProtocol p => p -> FetchAnnouncements_args -> LBS.ByteString
encode_FetchAnnouncements_args oprot record = T.serializeVal oprot $ from_FetchAnnouncements_args record
to_FetchAnnouncements_args :: T.ThriftVal -> FetchAnnouncements_args
to_FetchAnnouncements_args (T.TStruct fields) = FetchAnnouncements_args{
  fetchAnnouncements_args_lastFetchedIndex = P.maybe (fetchAnnouncements_args_lastFetchedIndex default_FetchAnnouncements_args) (\(_,_val3874) -> (case _val3874 of {T.TI32 _val3875 -> _val3875; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FetchAnnouncements_args _ = P.error "not a struct"
read_FetchAnnouncements_args :: T.Protocol p => p -> P.IO FetchAnnouncements_args
read_FetchAnnouncements_args iprot = to_FetchAnnouncements_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchAnnouncements_args)
decode_FetchAnnouncements_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchAnnouncements_args
decode_FetchAnnouncements_args iprot bs = to_FetchAnnouncements_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchAnnouncements_args) bs
typemap_FetchAnnouncements_args :: T.TypeMap
typemap_FetchAnnouncements_args = Map.fromList [(2,("lastFetchedIndex",T.T_I32))]
default_FetchAnnouncements_args :: FetchAnnouncements_args
default_FetchAnnouncements_args = FetchAnnouncements_args{
  fetchAnnouncements_args_lastFetchedIndex = 0}
data FetchAnnouncements_result = FetchAnnouncements_result  { fetchAnnouncements_result_success :: (Vector.Vector Announcement)
  , fetchAnnouncements_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchAnnouncements_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchAnnouncements_result_success record   `H.hashWithSalt` fetchAnnouncements_result_e record  
instance QC.Arbitrary FetchAnnouncements_result where 
  arbitrary = M.liftM FetchAnnouncements_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchAnnouncements_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchAnnouncements_result{fetchAnnouncements_result_success = fetchAnnouncements_result_success obj} then P.Nothing else P.Just $ default_FetchAnnouncements_result{fetchAnnouncements_result_success = fetchAnnouncements_result_success obj}
    , if obj == default_FetchAnnouncements_result{fetchAnnouncements_result_e = fetchAnnouncements_result_e obj} then P.Nothing else P.Just $ default_FetchAnnouncements_result{fetchAnnouncements_result_e = fetchAnnouncements_result_e obj}
    ]
from_FetchAnnouncements_result :: FetchAnnouncements_result -> T.ThriftVal
from_FetchAnnouncements_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3878 -> (1, ("e",from_TalkException _v3878))) <$> fetchAnnouncements_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3878 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Announcement) $ P.map (\_v3880 -> from_Announcement _v3880) $ Vector.toList _v3878))) $ fetchAnnouncements_result_success record
    , (\_v3878 -> (1, ("e",from_TalkException _v3878))) <$> fetchAnnouncements_result_e record
    ]
    )
write_FetchAnnouncements_result :: T.Protocol p => p -> FetchAnnouncements_result -> P.IO ()
write_FetchAnnouncements_result oprot record = T.writeVal oprot $ from_FetchAnnouncements_result record
encode_FetchAnnouncements_result :: T.StatelessProtocol p => p -> FetchAnnouncements_result -> LBS.ByteString
encode_FetchAnnouncements_result oprot record = T.serializeVal oprot $ from_FetchAnnouncements_result record
to_FetchAnnouncements_result :: T.ThriftVal -> FetchAnnouncements_result
to_FetchAnnouncements_result (T.TStruct fields) = FetchAnnouncements_result{
  fetchAnnouncements_result_success = P.maybe (fetchAnnouncements_result_success default_FetchAnnouncements_result) (\(_,_val3882) -> (case _val3882 of {T.TList _ _val3883 -> (Vector.fromList $ P.map (\_v3884 -> (case _v3884 of {T.TStruct _val3885 -> (to_Announcement (T.TStruct _val3885)); _ -> P.error "wrong type"})) _val3883); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchAnnouncements_result_e = P.maybe (P.Nothing) (\(_,_val3882) -> P.Just (case _val3882 of {T.TStruct _val3886 -> (to_TalkException (T.TStruct _val3886)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchAnnouncements_result _ = P.error "not a struct"
read_FetchAnnouncements_result :: T.Protocol p => p -> P.IO FetchAnnouncements_result
read_FetchAnnouncements_result iprot = to_FetchAnnouncements_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchAnnouncements_result)
decode_FetchAnnouncements_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchAnnouncements_result
decode_FetchAnnouncements_result iprot bs = to_FetchAnnouncements_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchAnnouncements_result) bs
typemap_FetchAnnouncements_result :: T.TypeMap
typemap_FetchAnnouncements_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Announcement)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FetchAnnouncements_result :: FetchAnnouncements_result
default_FetchAnnouncements_result = FetchAnnouncements_result{
  fetchAnnouncements_result_success = Vector.empty,
  fetchAnnouncements_result_e = P.Nothing}
data FetchMessages_args = FetchMessages_args  { fetchMessages_args_localTs :: I.Int64
  , fetchMessages_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMessages_args_localTs record   `H.hashWithSalt` fetchMessages_args_count record  
instance QC.Arbitrary FetchMessages_args where 
  arbitrary = M.liftM FetchMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMessages_args{fetchMessages_args_localTs = fetchMessages_args_localTs obj} then P.Nothing else P.Just $ default_FetchMessages_args{fetchMessages_args_localTs = fetchMessages_args_localTs obj}
    , if obj == default_FetchMessages_args{fetchMessages_args_count = fetchMessages_args_count obj} then P.Nothing else P.Just $ default_FetchMessages_args{fetchMessages_args_count = fetchMessages_args_count obj}
    ]
from_FetchMessages_args :: FetchMessages_args -> T.ThriftVal
from_FetchMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3889 -> P.Just (2, ("localTs",T.TI64 _v3889))) $ fetchMessages_args_localTs record
  , (\_v3889 -> P.Just (3, ("count",T.TI32 _v3889))) $ fetchMessages_args_count record
  ]
write_FetchMessages_args :: T.Protocol p => p -> FetchMessages_args -> P.IO ()
write_FetchMessages_args oprot record = T.writeVal oprot $ from_FetchMessages_args record
encode_FetchMessages_args :: T.StatelessProtocol p => p -> FetchMessages_args -> LBS.ByteString
encode_FetchMessages_args oprot record = T.serializeVal oprot $ from_FetchMessages_args record
to_FetchMessages_args :: T.ThriftVal -> FetchMessages_args
to_FetchMessages_args (T.TStruct fields) = FetchMessages_args{
  fetchMessages_args_localTs = P.maybe (fetchMessages_args_localTs default_FetchMessages_args) (\(_,_val3891) -> (case _val3891 of {T.TI64 _val3892 -> _val3892; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchMessages_args_count = P.maybe (fetchMessages_args_count default_FetchMessages_args) (\(_,_val3891) -> (case _val3891 of {T.TI32 _val3893 -> _val3893; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FetchMessages_args _ = P.error "not a struct"
read_FetchMessages_args :: T.Protocol p => p -> P.IO FetchMessages_args
read_FetchMessages_args iprot = to_FetchMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchMessages_args)
decode_FetchMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMessages_args
decode_FetchMessages_args iprot bs = to_FetchMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMessages_args) bs
typemap_FetchMessages_args :: T.TypeMap
typemap_FetchMessages_args = Map.fromList [(2,("localTs",T.T_I64)),(3,("count",T.T_I32))]
default_FetchMessages_args :: FetchMessages_args
default_FetchMessages_args = FetchMessages_args{
  fetchMessages_args_localTs = 0,
  fetchMessages_args_count = 0}
data FetchMessages_result = FetchMessages_result  { fetchMessages_result_success :: (Vector.Vector Message)
  , fetchMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMessages_result_success record   `H.hashWithSalt` fetchMessages_result_e record  
instance QC.Arbitrary FetchMessages_result where 
  arbitrary = M.liftM FetchMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMessages_result{fetchMessages_result_success = fetchMessages_result_success obj} then P.Nothing else P.Just $ default_FetchMessages_result{fetchMessages_result_success = fetchMessages_result_success obj}
    , if obj == default_FetchMessages_result{fetchMessages_result_e = fetchMessages_result_e obj} then P.Nothing else P.Just $ default_FetchMessages_result{fetchMessages_result_e = fetchMessages_result_e obj}
    ]
from_FetchMessages_result :: FetchMessages_result -> T.ThriftVal
from_FetchMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3896 -> (1, ("e",from_TalkException _v3896))) <$> fetchMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3896 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v3898 -> from_Message _v3898) $ Vector.toList _v3896))) $ fetchMessages_result_success record
    , (\_v3896 -> (1, ("e",from_TalkException _v3896))) <$> fetchMessages_result_e record
    ]
    )
write_FetchMessages_result :: T.Protocol p => p -> FetchMessages_result -> P.IO ()
write_FetchMessages_result oprot record = T.writeVal oprot $ from_FetchMessages_result record
encode_FetchMessages_result :: T.StatelessProtocol p => p -> FetchMessages_result -> LBS.ByteString
encode_FetchMessages_result oprot record = T.serializeVal oprot $ from_FetchMessages_result record
to_FetchMessages_result :: T.ThriftVal -> FetchMessages_result
to_FetchMessages_result (T.TStruct fields) = FetchMessages_result{
  fetchMessages_result_success = P.maybe (fetchMessages_result_success default_FetchMessages_result) (\(_,_val3900) -> (case _val3900 of {T.TList _ _val3901 -> (Vector.fromList $ P.map (\_v3902 -> (case _v3902 of {T.TStruct _val3903 -> (to_Message (T.TStruct _val3903)); _ -> P.error "wrong type"})) _val3901); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchMessages_result_e = P.maybe (P.Nothing) (\(_,_val3900) -> P.Just (case _val3900 of {T.TStruct _val3904 -> (to_TalkException (T.TStruct _val3904)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchMessages_result _ = P.error "not a struct"
read_FetchMessages_result :: T.Protocol p => p -> P.IO FetchMessages_result
read_FetchMessages_result iprot = to_FetchMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchMessages_result)
decode_FetchMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMessages_result
decode_FetchMessages_result iprot bs = to_FetchMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMessages_result) bs
typemap_FetchMessages_result :: T.TypeMap
typemap_FetchMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FetchMessages_result :: FetchMessages_result
default_FetchMessages_result = FetchMessages_result{
  fetchMessages_result_success = Vector.empty,
  fetchMessages_result_e = P.Nothing}
data FetchOperations_args = FetchOperations_args  { fetchOperations_args_localRev :: I.Int64
  , fetchOperations_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOperations_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOperations_args_localRev record   `H.hashWithSalt` fetchOperations_args_count record  
instance QC.Arbitrary FetchOperations_args where 
  arbitrary = M.liftM FetchOperations_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchOperations_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOperations_args{fetchOperations_args_localRev = fetchOperations_args_localRev obj} then P.Nothing else P.Just $ default_FetchOperations_args{fetchOperations_args_localRev = fetchOperations_args_localRev obj}
    , if obj == default_FetchOperations_args{fetchOperations_args_count = fetchOperations_args_count obj} then P.Nothing else P.Just $ default_FetchOperations_args{fetchOperations_args_count = fetchOperations_args_count obj}
    ]
from_FetchOperations_args :: FetchOperations_args -> T.ThriftVal
from_FetchOperations_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3907 -> P.Just (2, ("localRev",T.TI64 _v3907))) $ fetchOperations_args_localRev record
  , (\_v3907 -> P.Just (3, ("count",T.TI32 _v3907))) $ fetchOperations_args_count record
  ]
write_FetchOperations_args :: T.Protocol p => p -> FetchOperations_args -> P.IO ()
write_FetchOperations_args oprot record = T.writeVal oprot $ from_FetchOperations_args record
encode_FetchOperations_args :: T.StatelessProtocol p => p -> FetchOperations_args -> LBS.ByteString
encode_FetchOperations_args oprot record = T.serializeVal oprot $ from_FetchOperations_args record
to_FetchOperations_args :: T.ThriftVal -> FetchOperations_args
to_FetchOperations_args (T.TStruct fields) = FetchOperations_args{
  fetchOperations_args_localRev = P.maybe (fetchOperations_args_localRev default_FetchOperations_args) (\(_,_val3909) -> (case _val3909 of {T.TI64 _val3910 -> _val3910; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchOperations_args_count = P.maybe (fetchOperations_args_count default_FetchOperations_args) (\(_,_val3909) -> (case _val3909 of {T.TI32 _val3911 -> _val3911; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FetchOperations_args _ = P.error "not a struct"
read_FetchOperations_args :: T.Protocol p => p -> P.IO FetchOperations_args
read_FetchOperations_args iprot = to_FetchOperations_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchOperations_args)
decode_FetchOperations_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOperations_args
decode_FetchOperations_args iprot bs = to_FetchOperations_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOperations_args) bs
typemap_FetchOperations_args :: T.TypeMap
typemap_FetchOperations_args = Map.fromList [(2,("localRev",T.T_I64)),(3,("count",T.T_I32))]
default_FetchOperations_args :: FetchOperations_args
default_FetchOperations_args = FetchOperations_args{
  fetchOperations_args_localRev = 0,
  fetchOperations_args_count = 0}
data FetchOperations_result = FetchOperations_result  { fetchOperations_result_success :: (Vector.Vector Operation)
  , fetchOperations_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOperations_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOperations_result_success record   `H.hashWithSalt` fetchOperations_result_e record  
instance QC.Arbitrary FetchOperations_result where 
  arbitrary = M.liftM FetchOperations_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchOperations_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOperations_result{fetchOperations_result_success = fetchOperations_result_success obj} then P.Nothing else P.Just $ default_FetchOperations_result{fetchOperations_result_success = fetchOperations_result_success obj}
    , if obj == default_FetchOperations_result{fetchOperations_result_e = fetchOperations_result_e obj} then P.Nothing else P.Just $ default_FetchOperations_result{fetchOperations_result_e = fetchOperations_result_e obj}
    ]
from_FetchOperations_result :: FetchOperations_result -> T.ThriftVal
from_FetchOperations_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3914 -> (1, ("e",from_TalkException _v3914))) <$> fetchOperations_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3914 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Operation) $ P.map (\_v3916 -> from_Operation _v3916) $ Vector.toList _v3914))) $ fetchOperations_result_success record
    , (\_v3914 -> (1, ("e",from_TalkException _v3914))) <$> fetchOperations_result_e record
    ]
    )
write_FetchOperations_result :: T.Protocol p => p -> FetchOperations_result -> P.IO ()
write_FetchOperations_result oprot record = T.writeVal oprot $ from_FetchOperations_result record
encode_FetchOperations_result :: T.StatelessProtocol p => p -> FetchOperations_result -> LBS.ByteString
encode_FetchOperations_result oprot record = T.serializeVal oprot $ from_FetchOperations_result record
to_FetchOperations_result :: T.ThriftVal -> FetchOperations_result
to_FetchOperations_result (T.TStruct fields) = FetchOperations_result{
  fetchOperations_result_success = P.maybe (fetchOperations_result_success default_FetchOperations_result) (\(_,_val3918) -> (case _val3918 of {T.TList _ _val3919 -> (Vector.fromList $ P.map (\_v3920 -> (case _v3920 of {T.TStruct _val3921 -> (to_Operation (T.TStruct _val3921)); _ -> P.error "wrong type"})) _val3919); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchOperations_result_e = P.maybe (P.Nothing) (\(_,_val3918) -> P.Just (case _val3918 of {T.TStruct _val3922 -> (to_TalkException (T.TStruct _val3922)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchOperations_result _ = P.error "not a struct"
read_FetchOperations_result :: T.Protocol p => p -> P.IO FetchOperations_result
read_FetchOperations_result iprot = to_FetchOperations_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchOperations_result)
decode_FetchOperations_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOperations_result
decode_FetchOperations_result iprot bs = to_FetchOperations_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOperations_result) bs
typemap_FetchOperations_result :: T.TypeMap
typemap_FetchOperations_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Operation)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FetchOperations_result :: FetchOperations_result
default_FetchOperations_result = FetchOperations_result{
  fetchOperations_result_success = Vector.empty,
  fetchOperations_result_e = P.Nothing}
data FetchOps_args = FetchOps_args  { fetchOps_args_localRev :: I.Int64
  , fetchOps_args_count :: I.Int32
  , fetchOps_args_globalRev :: I.Int64
  , fetchOps_args_individualRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOps_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOps_args_localRev record   `H.hashWithSalt` fetchOps_args_count record   `H.hashWithSalt` fetchOps_args_globalRev record   `H.hashWithSalt` fetchOps_args_individualRev record  
instance QC.Arbitrary FetchOps_args where 
  arbitrary = M.liftM FetchOps_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchOps_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOps_args{fetchOps_args_localRev = fetchOps_args_localRev obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_localRev = fetchOps_args_localRev obj}
    , if obj == default_FetchOps_args{fetchOps_args_count = fetchOps_args_count obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_count = fetchOps_args_count obj}
    , if obj == default_FetchOps_args{fetchOps_args_globalRev = fetchOps_args_globalRev obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_globalRev = fetchOps_args_globalRev obj}
    , if obj == default_FetchOps_args{fetchOps_args_individualRev = fetchOps_args_individualRev obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_individualRev = fetchOps_args_individualRev obj}
    ]
from_FetchOps_args :: FetchOps_args -> T.ThriftVal
from_FetchOps_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3925 -> P.Just (2, ("localRev",T.TI64 _v3925))) $ fetchOps_args_localRev record
  , (\_v3925 -> P.Just (3, ("count",T.TI32 _v3925))) $ fetchOps_args_count record
  , (\_v3925 -> P.Just (4, ("globalRev",T.TI64 _v3925))) $ fetchOps_args_globalRev record
  , (\_v3925 -> P.Just (5, ("individualRev",T.TI64 _v3925))) $ fetchOps_args_individualRev record
  ]
write_FetchOps_args :: T.Protocol p => p -> FetchOps_args -> P.IO ()
write_FetchOps_args oprot record = T.writeVal oprot $ from_FetchOps_args record
encode_FetchOps_args :: T.StatelessProtocol p => p -> FetchOps_args -> LBS.ByteString
encode_FetchOps_args oprot record = T.serializeVal oprot $ from_FetchOps_args record
to_FetchOps_args :: T.ThriftVal -> FetchOps_args
to_FetchOps_args (T.TStruct fields) = FetchOps_args{
  fetchOps_args_localRev = P.maybe (fetchOps_args_localRev default_FetchOps_args) (\(_,_val3927) -> (case _val3927 of {T.TI64 _val3928 -> _val3928; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchOps_args_count = P.maybe (fetchOps_args_count default_FetchOps_args) (\(_,_val3927) -> (case _val3927 of {T.TI32 _val3929 -> _val3929; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  fetchOps_args_globalRev = P.maybe (fetchOps_args_globalRev default_FetchOps_args) (\(_,_val3927) -> (case _val3927 of {T.TI64 _val3930 -> _val3930; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  fetchOps_args_individualRev = P.maybe (fetchOps_args_individualRev default_FetchOps_args) (\(_,_val3927) -> (case _val3927 of {T.TI64 _val3931 -> _val3931; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_FetchOps_args _ = P.error "not a struct"
read_FetchOps_args :: T.Protocol p => p -> P.IO FetchOps_args
read_FetchOps_args iprot = to_FetchOps_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchOps_args)
decode_FetchOps_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOps_args
decode_FetchOps_args iprot bs = to_FetchOps_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOps_args) bs
typemap_FetchOps_args :: T.TypeMap
typemap_FetchOps_args = Map.fromList [(2,("localRev",T.T_I64)),(3,("count",T.T_I32)),(4,("globalRev",T.T_I64)),(5,("individualRev",T.T_I64))]
default_FetchOps_args :: FetchOps_args
default_FetchOps_args = FetchOps_args{
  fetchOps_args_localRev = 0,
  fetchOps_args_count = 0,
  fetchOps_args_globalRev = 0,
  fetchOps_args_individualRev = 0}
data FetchOps_result = FetchOps_result  { fetchOps_result_success :: (Vector.Vector Operation)
  , fetchOps_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOps_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOps_result_success record   `H.hashWithSalt` fetchOps_result_e record  
instance QC.Arbitrary FetchOps_result where 
  arbitrary = M.liftM FetchOps_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchOps_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOps_result{fetchOps_result_success = fetchOps_result_success obj} then P.Nothing else P.Just $ default_FetchOps_result{fetchOps_result_success = fetchOps_result_success obj}
    , if obj == default_FetchOps_result{fetchOps_result_e = fetchOps_result_e obj} then P.Nothing else P.Just $ default_FetchOps_result{fetchOps_result_e = fetchOps_result_e obj}
    ]
from_FetchOps_result :: FetchOps_result -> T.ThriftVal
from_FetchOps_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3934 -> (1, ("e",from_TalkException _v3934))) <$> fetchOps_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3934 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Operation) $ P.map (\_v3936 -> from_Operation _v3936) $ Vector.toList _v3934))) $ fetchOps_result_success record
    , (\_v3934 -> (1, ("e",from_TalkException _v3934))) <$> fetchOps_result_e record
    ]
    )
write_FetchOps_result :: T.Protocol p => p -> FetchOps_result -> P.IO ()
write_FetchOps_result oprot record = T.writeVal oprot $ from_FetchOps_result record
encode_FetchOps_result :: T.StatelessProtocol p => p -> FetchOps_result -> LBS.ByteString
encode_FetchOps_result oprot record = T.serializeVal oprot $ from_FetchOps_result record
to_FetchOps_result :: T.ThriftVal -> FetchOps_result
to_FetchOps_result (T.TStruct fields) = FetchOps_result{
  fetchOps_result_success = P.maybe (fetchOps_result_success default_FetchOps_result) (\(_,_val3938) -> (case _val3938 of {T.TList _ _val3939 -> (Vector.fromList $ P.map (\_v3940 -> (case _v3940 of {T.TStruct _val3941 -> (to_Operation (T.TStruct _val3941)); _ -> P.error "wrong type"})) _val3939); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchOps_result_e = P.maybe (P.Nothing) (\(_,_val3938) -> P.Just (case _val3938 of {T.TStruct _val3942 -> (to_TalkException (T.TStruct _val3942)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchOps_result _ = P.error "not a struct"
read_FetchOps_result :: T.Protocol p => p -> P.IO FetchOps_result
read_FetchOps_result iprot = to_FetchOps_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchOps_result)
decode_FetchOps_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOps_result
decode_FetchOps_result iprot bs = to_FetchOps_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOps_result) bs
typemap_FetchOps_result :: T.TypeMap
typemap_FetchOps_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Operation)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FetchOps_result :: FetchOps_result
default_FetchOps_result = FetchOps_result{
  fetchOps_result_success = Vector.empty,
  fetchOps_result_e = P.Nothing}
data FindAndAddContactsByEmail_args = FindAndAddContactsByEmail_args  { findAndAddContactsByEmail_args_reqSeq :: I.Int32
  , findAndAddContactsByEmail_args_emails :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByEmail_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByEmail_args_emails record  
instance QC.Arbitrary FindAndAddContactsByEmail_args where 
  arbitrary = M.liftM FindAndAddContactsByEmail_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_reqSeq = findAndAddContactsByEmail_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_reqSeq = findAndAddContactsByEmail_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_emails = findAndAddContactsByEmail_args_emails obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_emails = findAndAddContactsByEmail_args_emails obj}
    ]
from_FindAndAddContactsByEmail_args :: FindAndAddContactsByEmail_args -> T.ThriftVal
from_FindAndAddContactsByEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3945 -> P.Just (1, ("reqSeq",T.TI32 _v3945))) $ findAndAddContactsByEmail_args_reqSeq record
  , (\_v3945 -> P.Just (2, ("emails",T.TSet T.T_STRING $ P.map (\_v3947 -> T.TString $ E.encodeUtf8 _v3947) $ Set.toList _v3945))) $ findAndAddContactsByEmail_args_emails record
  ]
write_FindAndAddContactsByEmail_args :: T.Protocol p => p -> FindAndAddContactsByEmail_args -> P.IO ()
write_FindAndAddContactsByEmail_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByEmail_args record
encode_FindAndAddContactsByEmail_args :: T.StatelessProtocol p => p -> FindAndAddContactsByEmail_args -> LBS.ByteString
encode_FindAndAddContactsByEmail_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByEmail_args record
to_FindAndAddContactsByEmail_args :: T.ThriftVal -> FindAndAddContactsByEmail_args
to_FindAndAddContactsByEmail_args (T.TStruct fields) = FindAndAddContactsByEmail_args{
  findAndAddContactsByEmail_args_reqSeq = P.maybe (findAndAddContactsByEmail_args_reqSeq default_FindAndAddContactsByEmail_args) (\(_,_val3949) -> (case _val3949 of {T.TI32 _val3950 -> _val3950; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByEmail_args_emails = P.maybe (findAndAddContactsByEmail_args_emails default_FindAndAddContactsByEmail_args) (\(_,_val3949) -> (case _val3949 of {T.TSet _ _val3951 -> (Set.fromList $ P.map (\_v3952 -> (case _v3952 of {T.TString _val3953 -> E.decodeUtf8 _val3953; _ -> P.error "wrong type"})) _val3951); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindAndAddContactsByEmail_args _ = P.error "not a struct"
read_FindAndAddContactsByEmail_args :: T.Protocol p => p -> P.IO FindAndAddContactsByEmail_args
read_FindAndAddContactsByEmail_args iprot = to_FindAndAddContactsByEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_args)
decode_FindAndAddContactsByEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByEmail_args
decode_FindAndAddContactsByEmail_args iprot bs = to_FindAndAddContactsByEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_args) bs
typemap_FindAndAddContactsByEmail_args :: T.TypeMap
typemap_FindAndAddContactsByEmail_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("emails",(T.T_SET T.T_STRING)))]
default_FindAndAddContactsByEmail_args :: FindAndAddContactsByEmail_args
default_FindAndAddContactsByEmail_args = FindAndAddContactsByEmail_args{
  findAndAddContactsByEmail_args_reqSeq = 0,
  findAndAddContactsByEmail_args_emails = Set.empty}
data FindAndAddContactsByEmail_result = FindAndAddContactsByEmail_result  { findAndAddContactsByEmail_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByEmail_result_success record   `H.hashWithSalt` findAndAddContactsByEmail_result_e record  
instance QC.Arbitrary FindAndAddContactsByEmail_result where 
  arbitrary = M.liftM FindAndAddContactsByEmail_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_success = findAndAddContactsByEmail_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_success = findAndAddContactsByEmail_result_success obj}
    , if obj == default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_e = findAndAddContactsByEmail_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_e = findAndAddContactsByEmail_result_e obj}
    ]
from_FindAndAddContactsByEmail_result :: FindAndAddContactsByEmail_result -> T.ThriftVal
from_FindAndAddContactsByEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3956 -> (1, ("e",from_TalkException _v3956))) <$> findAndAddContactsByEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3956 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k3957,_v3958) -> (T.TString $ E.encodeUtf8 _k3957, from_Contact _v3958)) $ Map.toList _v3956))) $ findAndAddContactsByEmail_result_success record
    , (\_v3956 -> (1, ("e",from_TalkException _v3956))) <$> findAndAddContactsByEmail_result_e record
    ]
    )
write_FindAndAddContactsByEmail_result :: T.Protocol p => p -> FindAndAddContactsByEmail_result -> P.IO ()
write_FindAndAddContactsByEmail_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByEmail_result record
encode_FindAndAddContactsByEmail_result :: T.StatelessProtocol p => p -> FindAndAddContactsByEmail_result -> LBS.ByteString
encode_FindAndAddContactsByEmail_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByEmail_result record
to_FindAndAddContactsByEmail_result :: T.ThriftVal -> FindAndAddContactsByEmail_result
to_FindAndAddContactsByEmail_result (T.TStruct fields) = FindAndAddContactsByEmail_result{
  findAndAddContactsByEmail_result_success = P.maybe (findAndAddContactsByEmail_result_success default_FindAndAddContactsByEmail_result) (\(_,_val3960) -> (case _val3960 of {T.TMap _ _ _val3961 -> (Map.fromList $ P.map (\(_k3963,_v3962) -> ((case _k3963 of {T.TString _val3964 -> E.decodeUtf8 _val3964; _ -> P.error "wrong type"}),(case _v3962 of {T.TStruct _val3965 -> (to_Contact (T.TStruct _val3965)); _ -> P.error "wrong type"}))) _val3961); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByEmail_result_e = P.maybe (P.Nothing) (\(_,_val3960) -> P.Just (case _val3960 of {T.TStruct _val3966 -> (to_TalkException (T.TStruct _val3966)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByEmail_result _ = P.error "not a struct"
read_FindAndAddContactsByEmail_result :: T.Protocol p => p -> P.IO FindAndAddContactsByEmail_result
read_FindAndAddContactsByEmail_result iprot = to_FindAndAddContactsByEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_result)
decode_FindAndAddContactsByEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByEmail_result
decode_FindAndAddContactsByEmail_result iprot bs = to_FindAndAddContactsByEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_result) bs
typemap_FindAndAddContactsByEmail_result :: T.TypeMap
typemap_FindAndAddContactsByEmail_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByEmail_result :: FindAndAddContactsByEmail_result
default_FindAndAddContactsByEmail_result = FindAndAddContactsByEmail_result{
  findAndAddContactsByEmail_result_success = Map.empty,
  findAndAddContactsByEmail_result_e = P.Nothing}
data FindAndAddContactsByMid_args = FindAndAddContactsByMid_args  { findAndAddContactsByMid_args_reqSeq :: I.Int32
  , findAndAddContactsByMid_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByMid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByMid_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByMid_args_mid record  
instance QC.Arbitrary FindAndAddContactsByMid_args where 
  arbitrary = M.liftM FindAndAddContactsByMid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByMid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_reqSeq = findAndAddContactsByMid_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_reqSeq = findAndAddContactsByMid_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_mid = findAndAddContactsByMid_args_mid obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_mid = findAndAddContactsByMid_args_mid obj}
    ]
from_FindAndAddContactsByMid_args :: FindAndAddContactsByMid_args -> T.ThriftVal
from_FindAndAddContactsByMid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3969 -> P.Just (1, ("reqSeq",T.TI32 _v3969))) $ findAndAddContactsByMid_args_reqSeq record
  , (\_v3969 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v3969))) $ findAndAddContactsByMid_args_mid record
  ]
write_FindAndAddContactsByMid_args :: T.Protocol p => p -> FindAndAddContactsByMid_args -> P.IO ()
write_FindAndAddContactsByMid_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByMid_args record
encode_FindAndAddContactsByMid_args :: T.StatelessProtocol p => p -> FindAndAddContactsByMid_args -> LBS.ByteString
encode_FindAndAddContactsByMid_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByMid_args record
to_FindAndAddContactsByMid_args :: T.ThriftVal -> FindAndAddContactsByMid_args
to_FindAndAddContactsByMid_args (T.TStruct fields) = FindAndAddContactsByMid_args{
  findAndAddContactsByMid_args_reqSeq = P.maybe (findAndAddContactsByMid_args_reqSeq default_FindAndAddContactsByMid_args) (\(_,_val3971) -> (case _val3971 of {T.TI32 _val3972 -> _val3972; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByMid_args_mid = P.maybe (findAndAddContactsByMid_args_mid default_FindAndAddContactsByMid_args) (\(_,_val3971) -> (case _val3971 of {T.TString _val3973 -> E.decodeUtf8 _val3973; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindAndAddContactsByMid_args _ = P.error "not a struct"
read_FindAndAddContactsByMid_args :: T.Protocol p => p -> P.IO FindAndAddContactsByMid_args
read_FindAndAddContactsByMid_args iprot = to_FindAndAddContactsByMid_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_args)
decode_FindAndAddContactsByMid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByMid_args
decode_FindAndAddContactsByMid_args iprot bs = to_FindAndAddContactsByMid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_args) bs
typemap_FindAndAddContactsByMid_args :: T.TypeMap
typemap_FindAndAddContactsByMid_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("mid",T.T_STRING))]
default_FindAndAddContactsByMid_args :: FindAndAddContactsByMid_args
default_FindAndAddContactsByMid_args = FindAndAddContactsByMid_args{
  findAndAddContactsByMid_args_reqSeq = 0,
  findAndAddContactsByMid_args_mid = ""}
data FindAndAddContactsByMid_result = FindAndAddContactsByMid_result  { findAndAddContactsByMid_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByMid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByMid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByMid_result_success record   `H.hashWithSalt` findAndAddContactsByMid_result_e record  
instance QC.Arbitrary FindAndAddContactsByMid_result where 
  arbitrary = M.liftM FindAndAddContactsByMid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByMid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_success = findAndAddContactsByMid_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_success = findAndAddContactsByMid_result_success obj}
    , if obj == default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_e = findAndAddContactsByMid_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_e = findAndAddContactsByMid_result_e obj}
    ]
from_FindAndAddContactsByMid_result :: FindAndAddContactsByMid_result -> T.ThriftVal
from_FindAndAddContactsByMid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3976 -> (1, ("e",from_TalkException _v3976))) <$> findAndAddContactsByMid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3976 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k3977,_v3978) -> (T.TString $ E.encodeUtf8 _k3977, from_Contact _v3978)) $ Map.toList _v3976))) $ findAndAddContactsByMid_result_success record
    , (\_v3976 -> (1, ("e",from_TalkException _v3976))) <$> findAndAddContactsByMid_result_e record
    ]
    )
write_FindAndAddContactsByMid_result :: T.Protocol p => p -> FindAndAddContactsByMid_result -> P.IO ()
write_FindAndAddContactsByMid_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByMid_result record
encode_FindAndAddContactsByMid_result :: T.StatelessProtocol p => p -> FindAndAddContactsByMid_result -> LBS.ByteString
encode_FindAndAddContactsByMid_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByMid_result record
to_FindAndAddContactsByMid_result :: T.ThriftVal -> FindAndAddContactsByMid_result
to_FindAndAddContactsByMid_result (T.TStruct fields) = FindAndAddContactsByMid_result{
  findAndAddContactsByMid_result_success = P.maybe (findAndAddContactsByMid_result_success default_FindAndAddContactsByMid_result) (\(_,_val3980) -> (case _val3980 of {T.TMap _ _ _val3981 -> (Map.fromList $ P.map (\(_k3983,_v3982) -> ((case _k3983 of {T.TString _val3984 -> E.decodeUtf8 _val3984; _ -> P.error "wrong type"}),(case _v3982 of {T.TStruct _val3985 -> (to_Contact (T.TStruct _val3985)); _ -> P.error "wrong type"}))) _val3981); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByMid_result_e = P.maybe (P.Nothing) (\(_,_val3980) -> P.Just (case _val3980 of {T.TStruct _val3986 -> (to_TalkException (T.TStruct _val3986)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByMid_result _ = P.error "not a struct"
read_FindAndAddContactsByMid_result :: T.Protocol p => p -> P.IO FindAndAddContactsByMid_result
read_FindAndAddContactsByMid_result iprot = to_FindAndAddContactsByMid_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_result)
decode_FindAndAddContactsByMid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByMid_result
decode_FindAndAddContactsByMid_result iprot bs = to_FindAndAddContactsByMid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_result) bs
typemap_FindAndAddContactsByMid_result :: T.TypeMap
typemap_FindAndAddContactsByMid_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByMid_result :: FindAndAddContactsByMid_result
default_FindAndAddContactsByMid_result = FindAndAddContactsByMid_result{
  findAndAddContactsByMid_result_success = Map.empty,
  findAndAddContactsByMid_result_e = P.Nothing}
data FindAndAddContactsByPhone_args = FindAndAddContactsByPhone_args  { findAndAddContactsByPhone_args_reqSeq :: I.Int32
  , findAndAddContactsByPhone_args_phones :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByPhone_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByPhone_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByPhone_args_phones record  
instance QC.Arbitrary FindAndAddContactsByPhone_args where 
  arbitrary = M.liftM FindAndAddContactsByPhone_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByPhone_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_reqSeq = findAndAddContactsByPhone_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_reqSeq = findAndAddContactsByPhone_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_phones = findAndAddContactsByPhone_args_phones obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_phones = findAndAddContactsByPhone_args_phones obj}
    ]
from_FindAndAddContactsByPhone_args :: FindAndAddContactsByPhone_args -> T.ThriftVal
from_FindAndAddContactsByPhone_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3989 -> P.Just (1, ("reqSeq",T.TI32 _v3989))) $ findAndAddContactsByPhone_args_reqSeq record
  , (\_v3989 -> P.Just (2, ("phones",T.TSet T.T_STRING $ P.map (\_v3991 -> T.TString $ E.encodeUtf8 _v3991) $ Set.toList _v3989))) $ findAndAddContactsByPhone_args_phones record
  ]
write_FindAndAddContactsByPhone_args :: T.Protocol p => p -> FindAndAddContactsByPhone_args -> P.IO ()
write_FindAndAddContactsByPhone_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByPhone_args record
encode_FindAndAddContactsByPhone_args :: T.StatelessProtocol p => p -> FindAndAddContactsByPhone_args -> LBS.ByteString
encode_FindAndAddContactsByPhone_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByPhone_args record
to_FindAndAddContactsByPhone_args :: T.ThriftVal -> FindAndAddContactsByPhone_args
to_FindAndAddContactsByPhone_args (T.TStruct fields) = FindAndAddContactsByPhone_args{
  findAndAddContactsByPhone_args_reqSeq = P.maybe (findAndAddContactsByPhone_args_reqSeq default_FindAndAddContactsByPhone_args) (\(_,_val3993) -> (case _val3993 of {T.TI32 _val3994 -> _val3994; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByPhone_args_phones = P.maybe (findAndAddContactsByPhone_args_phones default_FindAndAddContactsByPhone_args) (\(_,_val3993) -> (case _val3993 of {T.TSet _ _val3995 -> (Set.fromList $ P.map (\_v3996 -> (case _v3996 of {T.TString _val3997 -> E.decodeUtf8 _val3997; _ -> P.error "wrong type"})) _val3995); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindAndAddContactsByPhone_args _ = P.error "not a struct"
read_FindAndAddContactsByPhone_args :: T.Protocol p => p -> P.IO FindAndAddContactsByPhone_args
read_FindAndAddContactsByPhone_args iprot = to_FindAndAddContactsByPhone_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_args)
decode_FindAndAddContactsByPhone_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByPhone_args
decode_FindAndAddContactsByPhone_args iprot bs = to_FindAndAddContactsByPhone_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_args) bs
typemap_FindAndAddContactsByPhone_args :: T.TypeMap
typemap_FindAndAddContactsByPhone_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("phones",(T.T_SET T.T_STRING)))]
default_FindAndAddContactsByPhone_args :: FindAndAddContactsByPhone_args
default_FindAndAddContactsByPhone_args = FindAndAddContactsByPhone_args{
  findAndAddContactsByPhone_args_reqSeq = 0,
  findAndAddContactsByPhone_args_phones = Set.empty}
data FindAndAddContactsByPhone_result = FindAndAddContactsByPhone_result  { findAndAddContactsByPhone_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByPhone_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByPhone_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByPhone_result_success record   `H.hashWithSalt` findAndAddContactsByPhone_result_e record  
instance QC.Arbitrary FindAndAddContactsByPhone_result where 
  arbitrary = M.liftM FindAndAddContactsByPhone_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByPhone_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_success = findAndAddContactsByPhone_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_success = findAndAddContactsByPhone_result_success obj}
    , if obj == default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_e = findAndAddContactsByPhone_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_e = findAndAddContactsByPhone_result_e obj}
    ]
from_FindAndAddContactsByPhone_result :: FindAndAddContactsByPhone_result -> T.ThriftVal
from_FindAndAddContactsByPhone_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4000 -> (1, ("e",from_TalkException _v4000))) <$> findAndAddContactsByPhone_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4000 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k4001,_v4002) -> (T.TString $ E.encodeUtf8 _k4001, from_Contact _v4002)) $ Map.toList _v4000))) $ findAndAddContactsByPhone_result_success record
    , (\_v4000 -> (1, ("e",from_TalkException _v4000))) <$> findAndAddContactsByPhone_result_e record
    ]
    )
write_FindAndAddContactsByPhone_result :: T.Protocol p => p -> FindAndAddContactsByPhone_result -> P.IO ()
write_FindAndAddContactsByPhone_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByPhone_result record
encode_FindAndAddContactsByPhone_result :: T.StatelessProtocol p => p -> FindAndAddContactsByPhone_result -> LBS.ByteString
encode_FindAndAddContactsByPhone_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByPhone_result record
to_FindAndAddContactsByPhone_result :: T.ThriftVal -> FindAndAddContactsByPhone_result
to_FindAndAddContactsByPhone_result (T.TStruct fields) = FindAndAddContactsByPhone_result{
  findAndAddContactsByPhone_result_success = P.maybe (findAndAddContactsByPhone_result_success default_FindAndAddContactsByPhone_result) (\(_,_val4004) -> (case _val4004 of {T.TMap _ _ _val4005 -> (Map.fromList $ P.map (\(_k4007,_v4006) -> ((case _k4007 of {T.TString _val4008 -> E.decodeUtf8 _val4008; _ -> P.error "wrong type"}),(case _v4006 of {T.TStruct _val4009 -> (to_Contact (T.TStruct _val4009)); _ -> P.error "wrong type"}))) _val4005); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByPhone_result_e = P.maybe (P.Nothing) (\(_,_val4004) -> P.Just (case _val4004 of {T.TStruct _val4010 -> (to_TalkException (T.TStruct _val4010)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByPhone_result _ = P.error "not a struct"
read_FindAndAddContactsByPhone_result :: T.Protocol p => p -> P.IO FindAndAddContactsByPhone_result
read_FindAndAddContactsByPhone_result iprot = to_FindAndAddContactsByPhone_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_result)
decode_FindAndAddContactsByPhone_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByPhone_result
decode_FindAndAddContactsByPhone_result iprot bs = to_FindAndAddContactsByPhone_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_result) bs
typemap_FindAndAddContactsByPhone_result :: T.TypeMap
typemap_FindAndAddContactsByPhone_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByPhone_result :: FindAndAddContactsByPhone_result
default_FindAndAddContactsByPhone_result = FindAndAddContactsByPhone_result{
  findAndAddContactsByPhone_result_success = Map.empty,
  findAndAddContactsByPhone_result_e = P.Nothing}
data FindAndAddContactsByUserid_args = FindAndAddContactsByUserid_args  { findAndAddContactsByUserid_args_reqSeq :: I.Int32
  , findAndAddContactsByUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByUserid_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByUserid_args_userid record  
instance QC.Arbitrary FindAndAddContactsByUserid_args where 
  arbitrary = M.liftM FindAndAddContactsByUserid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_reqSeq = findAndAddContactsByUserid_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_reqSeq = findAndAddContactsByUserid_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_userid = findAndAddContactsByUserid_args_userid obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_userid = findAndAddContactsByUserid_args_userid obj}
    ]
from_FindAndAddContactsByUserid_args :: FindAndAddContactsByUserid_args -> T.ThriftVal
from_FindAndAddContactsByUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4013 -> P.Just (1, ("reqSeq",T.TI32 _v4013))) $ findAndAddContactsByUserid_args_reqSeq record
  , (\_v4013 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v4013))) $ findAndAddContactsByUserid_args_userid record
  ]
write_FindAndAddContactsByUserid_args :: T.Protocol p => p -> FindAndAddContactsByUserid_args -> P.IO ()
write_FindAndAddContactsByUserid_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByUserid_args record
encode_FindAndAddContactsByUserid_args :: T.StatelessProtocol p => p -> FindAndAddContactsByUserid_args -> LBS.ByteString
encode_FindAndAddContactsByUserid_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByUserid_args record
to_FindAndAddContactsByUserid_args :: T.ThriftVal -> FindAndAddContactsByUserid_args
to_FindAndAddContactsByUserid_args (T.TStruct fields) = FindAndAddContactsByUserid_args{
  findAndAddContactsByUserid_args_reqSeq = P.maybe (findAndAddContactsByUserid_args_reqSeq default_FindAndAddContactsByUserid_args) (\(_,_val4015) -> (case _val4015 of {T.TI32 _val4016 -> _val4016; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByUserid_args_userid = P.maybe (findAndAddContactsByUserid_args_userid default_FindAndAddContactsByUserid_args) (\(_,_val4015) -> (case _val4015 of {T.TString _val4017 -> E.decodeUtf8 _val4017; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindAndAddContactsByUserid_args _ = P.error "not a struct"
read_FindAndAddContactsByUserid_args :: T.Protocol p => p -> P.IO FindAndAddContactsByUserid_args
read_FindAndAddContactsByUserid_args iprot = to_FindAndAddContactsByUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_args)
decode_FindAndAddContactsByUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByUserid_args
decode_FindAndAddContactsByUserid_args iprot bs = to_FindAndAddContactsByUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_args) bs
typemap_FindAndAddContactsByUserid_args :: T.TypeMap
typemap_FindAndAddContactsByUserid_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("userid",T.T_STRING))]
default_FindAndAddContactsByUserid_args :: FindAndAddContactsByUserid_args
default_FindAndAddContactsByUserid_args = FindAndAddContactsByUserid_args{
  findAndAddContactsByUserid_args_reqSeq = 0,
  findAndAddContactsByUserid_args_userid = ""}
data FindAndAddContactsByUserid_result = FindAndAddContactsByUserid_result  { findAndAddContactsByUserid_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByUserid_result_success record   `H.hashWithSalt` findAndAddContactsByUserid_result_e record  
instance QC.Arbitrary FindAndAddContactsByUserid_result where 
  arbitrary = M.liftM FindAndAddContactsByUserid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_success = findAndAddContactsByUserid_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_success = findAndAddContactsByUserid_result_success obj}
    , if obj == default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_e = findAndAddContactsByUserid_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_e = findAndAddContactsByUserid_result_e obj}
    ]
from_FindAndAddContactsByUserid_result :: FindAndAddContactsByUserid_result -> T.ThriftVal
from_FindAndAddContactsByUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4020 -> (1, ("e",from_TalkException _v4020))) <$> findAndAddContactsByUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4020 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k4021,_v4022) -> (T.TString $ E.encodeUtf8 _k4021, from_Contact _v4022)) $ Map.toList _v4020))) $ findAndAddContactsByUserid_result_success record
    , (\_v4020 -> (1, ("e",from_TalkException _v4020))) <$> findAndAddContactsByUserid_result_e record
    ]
    )
write_FindAndAddContactsByUserid_result :: T.Protocol p => p -> FindAndAddContactsByUserid_result -> P.IO ()
write_FindAndAddContactsByUserid_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByUserid_result record
encode_FindAndAddContactsByUserid_result :: T.StatelessProtocol p => p -> FindAndAddContactsByUserid_result -> LBS.ByteString
encode_FindAndAddContactsByUserid_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByUserid_result record
to_FindAndAddContactsByUserid_result :: T.ThriftVal -> FindAndAddContactsByUserid_result
to_FindAndAddContactsByUserid_result (T.TStruct fields) = FindAndAddContactsByUserid_result{
  findAndAddContactsByUserid_result_success = P.maybe (findAndAddContactsByUserid_result_success default_FindAndAddContactsByUserid_result) (\(_,_val4024) -> (case _val4024 of {T.TMap _ _ _val4025 -> (Map.fromList $ P.map (\(_k4027,_v4026) -> ((case _k4027 of {T.TString _val4028 -> E.decodeUtf8 _val4028; _ -> P.error "wrong type"}),(case _v4026 of {T.TStruct _val4029 -> (to_Contact (T.TStruct _val4029)); _ -> P.error "wrong type"}))) _val4025); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByUserid_result_e = P.maybe (P.Nothing) (\(_,_val4024) -> P.Just (case _val4024 of {T.TStruct _val4030 -> (to_TalkException (T.TStruct _val4030)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByUserid_result _ = P.error "not a struct"
read_FindAndAddContactsByUserid_result :: T.Protocol p => p -> P.IO FindAndAddContactsByUserid_result
read_FindAndAddContactsByUserid_result iprot = to_FindAndAddContactsByUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_result)
decode_FindAndAddContactsByUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByUserid_result
decode_FindAndAddContactsByUserid_result iprot bs = to_FindAndAddContactsByUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_result) bs
typemap_FindAndAddContactsByUserid_result :: T.TypeMap
typemap_FindAndAddContactsByUserid_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByUserid_result :: FindAndAddContactsByUserid_result
default_FindAndAddContactsByUserid_result = FindAndAddContactsByUserid_result{
  findAndAddContactsByUserid_result_success = Map.empty,
  findAndAddContactsByUserid_result_e = P.Nothing}
data FindContactByUserid_args = FindContactByUserid_args  { findContactByUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserid_args_userid record  
instance QC.Arbitrary FindContactByUserid_args where 
  arbitrary = M.liftM FindContactByUserid_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserid_args{findContactByUserid_args_userid = findContactByUserid_args_userid obj} then P.Nothing else P.Just $ default_FindContactByUserid_args{findContactByUserid_args_userid = findContactByUserid_args_userid obj}
    ]
from_FindContactByUserid_args :: FindContactByUserid_args -> T.ThriftVal
from_FindContactByUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4033 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v4033))) $ findContactByUserid_args_userid record
  ]
write_FindContactByUserid_args :: T.Protocol p => p -> FindContactByUserid_args -> P.IO ()
write_FindContactByUserid_args oprot record = T.writeVal oprot $ from_FindContactByUserid_args record
encode_FindContactByUserid_args :: T.StatelessProtocol p => p -> FindContactByUserid_args -> LBS.ByteString
encode_FindContactByUserid_args oprot record = T.serializeVal oprot $ from_FindContactByUserid_args record
to_FindContactByUserid_args :: T.ThriftVal -> FindContactByUserid_args
to_FindContactByUserid_args (T.TStruct fields) = FindContactByUserid_args{
  findContactByUserid_args_userid = P.maybe (findContactByUserid_args_userid default_FindContactByUserid_args) (\(_,_val4035) -> (case _val4035 of {T.TString _val4036 -> E.decodeUtf8 _val4036; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUserid_args _ = P.error "not a struct"
read_FindContactByUserid_args :: T.Protocol p => p -> P.IO FindContactByUserid_args
read_FindContactByUserid_args iprot = to_FindContactByUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserid_args)
decode_FindContactByUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserid_args
decode_FindContactByUserid_args iprot bs = to_FindContactByUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserid_args) bs
typemap_FindContactByUserid_args :: T.TypeMap
typemap_FindContactByUserid_args = Map.fromList [(2,("userid",T.T_STRING))]
default_FindContactByUserid_args :: FindContactByUserid_args
default_FindContactByUserid_args = FindContactByUserid_args{
  findContactByUserid_args_userid = ""}
data FindContactByUserid_result = FindContactByUserid_result  { findContactByUserid_result_success :: Contact
  , findContactByUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserid_result_success record   `H.hashWithSalt` findContactByUserid_result_e record  
instance QC.Arbitrary FindContactByUserid_result where 
  arbitrary = M.liftM FindContactByUserid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserid_result{findContactByUserid_result_success = findContactByUserid_result_success obj} then P.Nothing else P.Just $ default_FindContactByUserid_result{findContactByUserid_result_success = findContactByUserid_result_success obj}
    , if obj == default_FindContactByUserid_result{findContactByUserid_result_e = findContactByUserid_result_e obj} then P.Nothing else P.Just $ default_FindContactByUserid_result{findContactByUserid_result_e = findContactByUserid_result_e obj}
    ]
from_FindContactByUserid_result :: FindContactByUserid_result -> T.ThriftVal
from_FindContactByUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4039 -> (1, ("e",from_TalkException _v4039))) <$> findContactByUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4039 -> P.Just (0, ("success",from_Contact _v4039))) $ findContactByUserid_result_success record
    , (\_v4039 -> (1, ("e",from_TalkException _v4039))) <$> findContactByUserid_result_e record
    ]
    )
write_FindContactByUserid_result :: T.Protocol p => p -> FindContactByUserid_result -> P.IO ()
write_FindContactByUserid_result oprot record = T.writeVal oprot $ from_FindContactByUserid_result record
encode_FindContactByUserid_result :: T.StatelessProtocol p => p -> FindContactByUserid_result -> LBS.ByteString
encode_FindContactByUserid_result oprot record = T.serializeVal oprot $ from_FindContactByUserid_result record
to_FindContactByUserid_result :: T.ThriftVal -> FindContactByUserid_result
to_FindContactByUserid_result (T.TStruct fields) = FindContactByUserid_result{
  findContactByUserid_result_success = P.maybe (findContactByUserid_result_success default_FindContactByUserid_result) (\(_,_val4041) -> (case _val4041 of {T.TStruct _val4042 -> (to_Contact (T.TStruct _val4042)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUserid_result_e = P.maybe (P.Nothing) (\(_,_val4041) -> P.Just (case _val4041 of {T.TStruct _val4043 -> (to_TalkException (T.TStruct _val4043)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUserid_result _ = P.error "not a struct"
read_FindContactByUserid_result :: T.Protocol p => p -> P.IO FindContactByUserid_result
read_FindContactByUserid_result iprot = to_FindContactByUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserid_result)
decode_FindContactByUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserid_result
decode_FindContactByUserid_result iprot bs = to_FindContactByUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserid_result) bs
typemap_FindContactByUserid_result :: T.TypeMap
typemap_FindContactByUserid_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUserid_result :: FindContactByUserid_result
default_FindContactByUserid_result = FindContactByUserid_result{
  findContactByUserid_result_success = default_Contact,
  findContactByUserid_result_e = P.Nothing}
data FindContactByUserTicket_args = FindContactByUserTicket_args  { findContactByUserTicket_args_ticketId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserTicket_args_ticketId record  
instance QC.Arbitrary FindContactByUserTicket_args where 
  arbitrary = M.liftM FindContactByUserTicket_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUserTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserTicket_args{findContactByUserTicket_args_ticketId = findContactByUserTicket_args_ticketId obj} then P.Nothing else P.Just $ default_FindContactByUserTicket_args{findContactByUserTicket_args_ticketId = findContactByUserTicket_args_ticketId obj}
    ]
from_FindContactByUserTicket_args :: FindContactByUserTicket_args -> T.ThriftVal
from_FindContactByUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4046 -> P.Just (2, ("ticketId",T.TString $ E.encodeUtf8 _v4046))) $ findContactByUserTicket_args_ticketId record
  ]
write_FindContactByUserTicket_args :: T.Protocol p => p -> FindContactByUserTicket_args -> P.IO ()
write_FindContactByUserTicket_args oprot record = T.writeVal oprot $ from_FindContactByUserTicket_args record
encode_FindContactByUserTicket_args :: T.StatelessProtocol p => p -> FindContactByUserTicket_args -> LBS.ByteString
encode_FindContactByUserTicket_args oprot record = T.serializeVal oprot $ from_FindContactByUserTicket_args record
to_FindContactByUserTicket_args :: T.ThriftVal -> FindContactByUserTicket_args
to_FindContactByUserTicket_args (T.TStruct fields) = FindContactByUserTicket_args{
  findContactByUserTicket_args_ticketId = P.maybe (findContactByUserTicket_args_ticketId default_FindContactByUserTicket_args) (\(_,_val4048) -> (case _val4048 of {T.TString _val4049 -> E.decodeUtf8 _val4049; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUserTicket_args _ = P.error "not a struct"
read_FindContactByUserTicket_args :: T.Protocol p => p -> P.IO FindContactByUserTicket_args
read_FindContactByUserTicket_args iprot = to_FindContactByUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_args)
decode_FindContactByUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserTicket_args
decode_FindContactByUserTicket_args iprot bs = to_FindContactByUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_args) bs
typemap_FindContactByUserTicket_args :: T.TypeMap
typemap_FindContactByUserTicket_args = Map.fromList [(2,("ticketId",T.T_STRING))]
default_FindContactByUserTicket_args :: FindContactByUserTicket_args
default_FindContactByUserTicket_args = FindContactByUserTicket_args{
  findContactByUserTicket_args_ticketId = ""}
data FindContactByUserTicket_result = FindContactByUserTicket_result  { findContactByUserTicket_result_success :: Contact
  , findContactByUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserTicket_result_success record   `H.hashWithSalt` findContactByUserTicket_result_e record  
instance QC.Arbitrary FindContactByUserTicket_result where 
  arbitrary = M.liftM FindContactByUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserTicket_result{findContactByUserTicket_result_success = findContactByUserTicket_result_success obj} then P.Nothing else P.Just $ default_FindContactByUserTicket_result{findContactByUserTicket_result_success = findContactByUserTicket_result_success obj}
    , if obj == default_FindContactByUserTicket_result{findContactByUserTicket_result_e = findContactByUserTicket_result_e obj} then P.Nothing else P.Just $ default_FindContactByUserTicket_result{findContactByUserTicket_result_e = findContactByUserTicket_result_e obj}
    ]
from_FindContactByUserTicket_result :: FindContactByUserTicket_result -> T.ThriftVal
from_FindContactByUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4052 -> (1, ("e",from_TalkException _v4052))) <$> findContactByUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4052 -> P.Just (0, ("success",from_Contact _v4052))) $ findContactByUserTicket_result_success record
    , (\_v4052 -> (1, ("e",from_TalkException _v4052))) <$> findContactByUserTicket_result_e record
    ]
    )
write_FindContactByUserTicket_result :: T.Protocol p => p -> FindContactByUserTicket_result -> P.IO ()
write_FindContactByUserTicket_result oprot record = T.writeVal oprot $ from_FindContactByUserTicket_result record
encode_FindContactByUserTicket_result :: T.StatelessProtocol p => p -> FindContactByUserTicket_result -> LBS.ByteString
encode_FindContactByUserTicket_result oprot record = T.serializeVal oprot $ from_FindContactByUserTicket_result record
to_FindContactByUserTicket_result :: T.ThriftVal -> FindContactByUserTicket_result
to_FindContactByUserTicket_result (T.TStruct fields) = FindContactByUserTicket_result{
  findContactByUserTicket_result_success = P.maybe (findContactByUserTicket_result_success default_FindContactByUserTicket_result) (\(_,_val4054) -> (case _val4054 of {T.TStruct _val4055 -> (to_Contact (T.TStruct _val4055)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val4054) -> P.Just (case _val4054 of {T.TStruct _val4056 -> (to_TalkException (T.TStruct _val4056)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUserTicket_result _ = P.error "not a struct"
read_FindContactByUserTicket_result :: T.Protocol p => p -> P.IO FindContactByUserTicket_result
read_FindContactByUserTicket_result iprot = to_FindContactByUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_result)
decode_FindContactByUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserTicket_result
decode_FindContactByUserTicket_result iprot bs = to_FindContactByUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_result) bs
typemap_FindContactByUserTicket_result :: T.TypeMap
typemap_FindContactByUserTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUserTicket_result :: FindContactByUserTicket_result
default_FindContactByUserTicket_result = FindContactByUserTicket_result{
  findContactByUserTicket_result_success = default_Contact,
  findContactByUserTicket_result_e = P.Nothing}
data FindContactsByEmail_args = FindContactsByEmail_args  { findContactsByEmail_args_emails :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByEmail_args_emails record  
instance QC.Arbitrary FindContactsByEmail_args where 
  arbitrary = M.liftM FindContactsByEmail_args (QC.arbitrary)
  shrink obj | obj == default_FindContactsByEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByEmail_args{findContactsByEmail_args_emails = findContactsByEmail_args_emails obj} then P.Nothing else P.Just $ default_FindContactsByEmail_args{findContactsByEmail_args_emails = findContactsByEmail_args_emails obj}
    ]
from_FindContactsByEmail_args :: FindContactsByEmail_args -> T.ThriftVal
from_FindContactsByEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4059 -> P.Just (2, ("emails",T.TSet T.T_STRING $ P.map (\_v4061 -> T.TString $ E.encodeUtf8 _v4061) $ Set.toList _v4059))) $ findContactsByEmail_args_emails record
  ]
write_FindContactsByEmail_args :: T.Protocol p => p -> FindContactsByEmail_args -> P.IO ()
write_FindContactsByEmail_args oprot record = T.writeVal oprot $ from_FindContactsByEmail_args record
encode_FindContactsByEmail_args :: T.StatelessProtocol p => p -> FindContactsByEmail_args -> LBS.ByteString
encode_FindContactsByEmail_args oprot record = T.serializeVal oprot $ from_FindContactsByEmail_args record
to_FindContactsByEmail_args :: T.ThriftVal -> FindContactsByEmail_args
to_FindContactsByEmail_args (T.TStruct fields) = FindContactsByEmail_args{
  findContactsByEmail_args_emails = P.maybe (findContactsByEmail_args_emails default_FindContactsByEmail_args) (\(_,_val4063) -> (case _val4063 of {T.TSet _ _val4064 -> (Set.fromList $ P.map (\_v4065 -> (case _v4065 of {T.TString _val4066 -> E.decodeUtf8 _val4066; _ -> P.error "wrong type"})) _val4064); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactsByEmail_args _ = P.error "not a struct"
read_FindContactsByEmail_args :: T.Protocol p => p -> P.IO FindContactsByEmail_args
read_FindContactsByEmail_args iprot = to_FindContactsByEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByEmail_args)
decode_FindContactsByEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByEmail_args
decode_FindContactsByEmail_args iprot bs = to_FindContactsByEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByEmail_args) bs
typemap_FindContactsByEmail_args :: T.TypeMap
typemap_FindContactsByEmail_args = Map.fromList [(2,("emails",(T.T_SET T.T_STRING)))]
default_FindContactsByEmail_args :: FindContactsByEmail_args
default_FindContactsByEmail_args = FindContactsByEmail_args{
  findContactsByEmail_args_emails = Set.empty}
data FindContactsByEmail_result = FindContactsByEmail_result  { findContactsByEmail_result_success :: (Map.HashMap LT.Text Contact)
  , findContactsByEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByEmail_result_success record   `H.hashWithSalt` findContactsByEmail_result_e record  
instance QC.Arbitrary FindContactsByEmail_result where 
  arbitrary = M.liftM FindContactsByEmail_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactsByEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByEmail_result{findContactsByEmail_result_success = findContactsByEmail_result_success obj} then P.Nothing else P.Just $ default_FindContactsByEmail_result{findContactsByEmail_result_success = findContactsByEmail_result_success obj}
    , if obj == default_FindContactsByEmail_result{findContactsByEmail_result_e = findContactsByEmail_result_e obj} then P.Nothing else P.Just $ default_FindContactsByEmail_result{findContactsByEmail_result_e = findContactsByEmail_result_e obj}
    ]
from_FindContactsByEmail_result :: FindContactsByEmail_result -> T.ThriftVal
from_FindContactsByEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4069 -> (1, ("e",from_TalkException _v4069))) <$> findContactsByEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4069 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k4070,_v4071) -> (T.TString $ E.encodeUtf8 _k4070, from_Contact _v4071)) $ Map.toList _v4069))) $ findContactsByEmail_result_success record
    , (\_v4069 -> (1, ("e",from_TalkException _v4069))) <$> findContactsByEmail_result_e record
    ]
    )
write_FindContactsByEmail_result :: T.Protocol p => p -> FindContactsByEmail_result -> P.IO ()
write_FindContactsByEmail_result oprot record = T.writeVal oprot $ from_FindContactsByEmail_result record
encode_FindContactsByEmail_result :: T.StatelessProtocol p => p -> FindContactsByEmail_result -> LBS.ByteString
encode_FindContactsByEmail_result oprot record = T.serializeVal oprot $ from_FindContactsByEmail_result record
to_FindContactsByEmail_result :: T.ThriftVal -> FindContactsByEmail_result
to_FindContactsByEmail_result (T.TStruct fields) = FindContactsByEmail_result{
  findContactsByEmail_result_success = P.maybe (findContactsByEmail_result_success default_FindContactsByEmail_result) (\(_,_val4073) -> (case _val4073 of {T.TMap _ _ _val4074 -> (Map.fromList $ P.map (\(_k4076,_v4075) -> ((case _k4076 of {T.TString _val4077 -> E.decodeUtf8 _val4077; _ -> P.error "wrong type"}),(case _v4075 of {T.TStruct _val4078 -> (to_Contact (T.TStruct _val4078)); _ -> P.error "wrong type"}))) _val4074); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactsByEmail_result_e = P.maybe (P.Nothing) (\(_,_val4073) -> P.Just (case _val4073 of {T.TStruct _val4079 -> (to_TalkException (T.TStruct _val4079)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactsByEmail_result _ = P.error "not a struct"
read_FindContactsByEmail_result :: T.Protocol p => p -> P.IO FindContactsByEmail_result
read_FindContactsByEmail_result iprot = to_FindContactsByEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByEmail_result)
decode_FindContactsByEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByEmail_result
decode_FindContactsByEmail_result iprot bs = to_FindContactsByEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByEmail_result) bs
typemap_FindContactsByEmail_result :: T.TypeMap
typemap_FindContactsByEmail_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactsByEmail_result :: FindContactsByEmail_result
default_FindContactsByEmail_result = FindContactsByEmail_result{
  findContactsByEmail_result_success = Map.empty,
  findContactsByEmail_result_e = P.Nothing}
data FindContactsByPhone_args = FindContactsByPhone_args  { findContactsByPhone_args_phones :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByPhone_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByPhone_args_phones record  
instance QC.Arbitrary FindContactsByPhone_args where 
  arbitrary = M.liftM FindContactsByPhone_args (QC.arbitrary)
  shrink obj | obj == default_FindContactsByPhone_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByPhone_args{findContactsByPhone_args_phones = findContactsByPhone_args_phones obj} then P.Nothing else P.Just $ default_FindContactsByPhone_args{findContactsByPhone_args_phones = findContactsByPhone_args_phones obj}
    ]
from_FindContactsByPhone_args :: FindContactsByPhone_args -> T.ThriftVal
from_FindContactsByPhone_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4082 -> P.Just (2, ("phones",T.TSet T.T_STRING $ P.map (\_v4084 -> T.TString $ E.encodeUtf8 _v4084) $ Set.toList _v4082))) $ findContactsByPhone_args_phones record
  ]
write_FindContactsByPhone_args :: T.Protocol p => p -> FindContactsByPhone_args -> P.IO ()
write_FindContactsByPhone_args oprot record = T.writeVal oprot $ from_FindContactsByPhone_args record
encode_FindContactsByPhone_args :: T.StatelessProtocol p => p -> FindContactsByPhone_args -> LBS.ByteString
encode_FindContactsByPhone_args oprot record = T.serializeVal oprot $ from_FindContactsByPhone_args record
to_FindContactsByPhone_args :: T.ThriftVal -> FindContactsByPhone_args
to_FindContactsByPhone_args (T.TStruct fields) = FindContactsByPhone_args{
  findContactsByPhone_args_phones = P.maybe (findContactsByPhone_args_phones default_FindContactsByPhone_args) (\(_,_val4086) -> (case _val4086 of {T.TSet _ _val4087 -> (Set.fromList $ P.map (\_v4088 -> (case _v4088 of {T.TString _val4089 -> E.decodeUtf8 _val4089; _ -> P.error "wrong type"})) _val4087); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactsByPhone_args _ = P.error "not a struct"
read_FindContactsByPhone_args :: T.Protocol p => p -> P.IO FindContactsByPhone_args
read_FindContactsByPhone_args iprot = to_FindContactsByPhone_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByPhone_args)
decode_FindContactsByPhone_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByPhone_args
decode_FindContactsByPhone_args iprot bs = to_FindContactsByPhone_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByPhone_args) bs
typemap_FindContactsByPhone_args :: T.TypeMap
typemap_FindContactsByPhone_args = Map.fromList [(2,("phones",(T.T_SET T.T_STRING)))]
default_FindContactsByPhone_args :: FindContactsByPhone_args
default_FindContactsByPhone_args = FindContactsByPhone_args{
  findContactsByPhone_args_phones = Set.empty}
data FindContactsByPhone_result = FindContactsByPhone_result  { findContactsByPhone_result_success :: (Map.HashMap LT.Text Contact)
  , findContactsByPhone_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByPhone_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByPhone_result_success record   `H.hashWithSalt` findContactsByPhone_result_e record  
instance QC.Arbitrary FindContactsByPhone_result where 
  arbitrary = M.liftM FindContactsByPhone_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactsByPhone_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByPhone_result{findContactsByPhone_result_success = findContactsByPhone_result_success obj} then P.Nothing else P.Just $ default_FindContactsByPhone_result{findContactsByPhone_result_success = findContactsByPhone_result_success obj}
    , if obj == default_FindContactsByPhone_result{findContactsByPhone_result_e = findContactsByPhone_result_e obj} then P.Nothing else P.Just $ default_FindContactsByPhone_result{findContactsByPhone_result_e = findContactsByPhone_result_e obj}
    ]
from_FindContactsByPhone_result :: FindContactsByPhone_result -> T.ThriftVal
from_FindContactsByPhone_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4092 -> (1, ("e",from_TalkException _v4092))) <$> findContactsByPhone_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4092 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k4093,_v4094) -> (T.TString $ E.encodeUtf8 _k4093, from_Contact _v4094)) $ Map.toList _v4092))) $ findContactsByPhone_result_success record
    , (\_v4092 -> (1, ("e",from_TalkException _v4092))) <$> findContactsByPhone_result_e record
    ]
    )
write_FindContactsByPhone_result :: T.Protocol p => p -> FindContactsByPhone_result -> P.IO ()
write_FindContactsByPhone_result oprot record = T.writeVal oprot $ from_FindContactsByPhone_result record
encode_FindContactsByPhone_result :: T.StatelessProtocol p => p -> FindContactsByPhone_result -> LBS.ByteString
encode_FindContactsByPhone_result oprot record = T.serializeVal oprot $ from_FindContactsByPhone_result record
to_FindContactsByPhone_result :: T.ThriftVal -> FindContactsByPhone_result
to_FindContactsByPhone_result (T.TStruct fields) = FindContactsByPhone_result{
  findContactsByPhone_result_success = P.maybe (findContactsByPhone_result_success default_FindContactsByPhone_result) (\(_,_val4096) -> (case _val4096 of {T.TMap _ _ _val4097 -> (Map.fromList $ P.map (\(_k4099,_v4098) -> ((case _k4099 of {T.TString _val4100 -> E.decodeUtf8 _val4100; _ -> P.error "wrong type"}),(case _v4098 of {T.TStruct _val4101 -> (to_Contact (T.TStruct _val4101)); _ -> P.error "wrong type"}))) _val4097); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactsByPhone_result_e = P.maybe (P.Nothing) (\(_,_val4096) -> P.Just (case _val4096 of {T.TStruct _val4102 -> (to_TalkException (T.TStruct _val4102)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactsByPhone_result _ = P.error "not a struct"
read_FindContactsByPhone_result :: T.Protocol p => p -> P.IO FindContactsByPhone_result
read_FindContactsByPhone_result iprot = to_FindContactsByPhone_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByPhone_result)
decode_FindContactsByPhone_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByPhone_result
decode_FindContactsByPhone_result iprot bs = to_FindContactsByPhone_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByPhone_result) bs
typemap_FindContactsByPhone_result :: T.TypeMap
typemap_FindContactsByPhone_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactsByPhone_result :: FindContactsByPhone_result
default_FindContactsByPhone_result = FindContactsByPhone_result{
  findContactsByPhone_result_success = Map.empty,
  findContactsByPhone_result_e = P.Nothing}
data FindSnsIdUserStatus_args = FindSnsIdUserStatus_args  { findSnsIdUserStatus_args_snsIdType :: SnsIdType
  , findSnsIdUserStatus_args_snsAccessToken :: LT.Text
  , findSnsIdUserStatus_args_udidHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSnsIdUserStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSnsIdUserStatus_args_snsIdType record   `H.hashWithSalt` findSnsIdUserStatus_args_snsAccessToken record   `H.hashWithSalt` findSnsIdUserStatus_args_udidHash record  
instance QC.Arbitrary FindSnsIdUserStatus_args where 
  arbitrary = M.liftM FindSnsIdUserStatus_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindSnsIdUserStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsIdType = findSnsIdUserStatus_args_snsIdType obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsIdType = findSnsIdUserStatus_args_snsIdType obj}
    , if obj == default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsAccessToken = findSnsIdUserStatus_args_snsAccessToken obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsAccessToken = findSnsIdUserStatus_args_snsAccessToken obj}
    , if obj == default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_udidHash = findSnsIdUserStatus_args_udidHash obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_udidHash = findSnsIdUserStatus_args_udidHash obj}
    ]
from_FindSnsIdUserStatus_args :: FindSnsIdUserStatus_args -> T.ThriftVal
from_FindSnsIdUserStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4105 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v4105))) $ findSnsIdUserStatus_args_snsIdType record
  , (\_v4105 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v4105))) $ findSnsIdUserStatus_args_snsAccessToken record
  , (\_v4105 -> P.Just (4, ("udidHash",T.TString $ E.encodeUtf8 _v4105))) $ findSnsIdUserStatus_args_udidHash record
  ]
write_FindSnsIdUserStatus_args :: T.Protocol p => p -> FindSnsIdUserStatus_args -> P.IO ()
write_FindSnsIdUserStatus_args oprot record = T.writeVal oprot $ from_FindSnsIdUserStatus_args record
encode_FindSnsIdUserStatus_args :: T.StatelessProtocol p => p -> FindSnsIdUserStatus_args -> LBS.ByteString
encode_FindSnsIdUserStatus_args oprot record = T.serializeVal oprot $ from_FindSnsIdUserStatus_args record
to_FindSnsIdUserStatus_args :: T.ThriftVal -> FindSnsIdUserStatus_args
to_FindSnsIdUserStatus_args (T.TStruct fields) = FindSnsIdUserStatus_args{
  findSnsIdUserStatus_args_snsIdType = P.maybe (findSnsIdUserStatus_args_snsIdType default_FindSnsIdUserStatus_args) (\(_,_val4107) -> (case _val4107 of {T.TI32 _val4108 -> P.toEnum $ P.fromIntegral _val4108; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findSnsIdUserStatus_args_snsAccessToken = P.maybe (findSnsIdUserStatus_args_snsAccessToken default_FindSnsIdUserStatus_args) (\(_,_val4107) -> (case _val4107 of {T.TString _val4109 -> E.decodeUtf8 _val4109; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  findSnsIdUserStatus_args_udidHash = P.maybe (findSnsIdUserStatus_args_udidHash default_FindSnsIdUserStatus_args) (\(_,_val4107) -> (case _val4107 of {T.TString _val4110 -> E.decodeUtf8 _val4110; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FindSnsIdUserStatus_args _ = P.error "not a struct"
read_FindSnsIdUserStatus_args :: T.Protocol p => p -> P.IO FindSnsIdUserStatus_args
read_FindSnsIdUserStatus_args iprot = to_FindSnsIdUserStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_args)
decode_FindSnsIdUserStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSnsIdUserStatus_args
decode_FindSnsIdUserStatus_args iprot bs = to_FindSnsIdUserStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_args) bs
typemap_FindSnsIdUserStatus_args :: T.TypeMap
typemap_FindSnsIdUserStatus_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING)),(4,("udidHash",T.T_STRING))]
default_FindSnsIdUserStatus_args :: FindSnsIdUserStatus_args
default_FindSnsIdUserStatus_args = FindSnsIdUserStatus_args{
  findSnsIdUserStatus_args_snsIdType = (P.toEnum 0),
  findSnsIdUserStatus_args_snsAccessToken = "",
  findSnsIdUserStatus_args_udidHash = ""}
data FindSnsIdUserStatus_result = FindSnsIdUserStatus_result  { findSnsIdUserStatus_result_success :: SnsIdUserStatus
  , findSnsIdUserStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSnsIdUserStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSnsIdUserStatus_result_success record   `H.hashWithSalt` findSnsIdUserStatus_result_e record  
instance QC.Arbitrary FindSnsIdUserStatus_result where 
  arbitrary = M.liftM FindSnsIdUserStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindSnsIdUserStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_success = findSnsIdUserStatus_result_success obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_success = findSnsIdUserStatus_result_success obj}
    , if obj == default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_e = findSnsIdUserStatus_result_e obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_e = findSnsIdUserStatus_result_e obj}
    ]
from_FindSnsIdUserStatus_result :: FindSnsIdUserStatus_result -> T.ThriftVal
from_FindSnsIdUserStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4113 -> (1, ("e",from_TalkException _v4113))) <$> findSnsIdUserStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4113 -> P.Just (0, ("success",from_SnsIdUserStatus _v4113))) $ findSnsIdUserStatus_result_success record
    , (\_v4113 -> (1, ("e",from_TalkException _v4113))) <$> findSnsIdUserStatus_result_e record
    ]
    )
write_FindSnsIdUserStatus_result :: T.Protocol p => p -> FindSnsIdUserStatus_result -> P.IO ()
write_FindSnsIdUserStatus_result oprot record = T.writeVal oprot $ from_FindSnsIdUserStatus_result record
encode_FindSnsIdUserStatus_result :: T.StatelessProtocol p => p -> FindSnsIdUserStatus_result -> LBS.ByteString
encode_FindSnsIdUserStatus_result oprot record = T.serializeVal oprot $ from_FindSnsIdUserStatus_result record
to_FindSnsIdUserStatus_result :: T.ThriftVal -> FindSnsIdUserStatus_result
to_FindSnsIdUserStatus_result (T.TStruct fields) = FindSnsIdUserStatus_result{
  findSnsIdUserStatus_result_success = P.maybe (findSnsIdUserStatus_result_success default_FindSnsIdUserStatus_result) (\(_,_val4115) -> (case _val4115 of {T.TStruct _val4116 -> (to_SnsIdUserStatus (T.TStruct _val4116)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findSnsIdUserStatus_result_e = P.maybe (P.Nothing) (\(_,_val4115) -> P.Just (case _val4115 of {T.TStruct _val4117 -> (to_TalkException (T.TStruct _val4117)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindSnsIdUserStatus_result _ = P.error "not a struct"
read_FindSnsIdUserStatus_result :: T.Protocol p => p -> P.IO FindSnsIdUserStatus_result
read_FindSnsIdUserStatus_result iprot = to_FindSnsIdUserStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_result)
decode_FindSnsIdUserStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSnsIdUserStatus_result
decode_FindSnsIdUserStatus_result iprot bs = to_FindSnsIdUserStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_result) bs
typemap_FindSnsIdUserStatus_result :: T.TypeMap
typemap_FindSnsIdUserStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SnsIdUserStatus))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindSnsIdUserStatus_result :: FindSnsIdUserStatus_result
default_FindSnsIdUserStatus_result = FindSnsIdUserStatus_result{
  findSnsIdUserStatus_result_success = default_SnsIdUserStatus,
  findSnsIdUserStatus_result_e = P.Nothing}
data FinishUpdateVerification_args = FinishUpdateVerification_args  { finishUpdateVerification_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FinishUpdateVerification_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` finishUpdateVerification_args_sessionId record  
instance QC.Arbitrary FinishUpdateVerification_args where 
  arbitrary = M.liftM FinishUpdateVerification_args (QC.arbitrary)
  shrink obj | obj == default_FinishUpdateVerification_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FinishUpdateVerification_args{finishUpdateVerification_args_sessionId = finishUpdateVerification_args_sessionId obj} then P.Nothing else P.Just $ default_FinishUpdateVerification_args{finishUpdateVerification_args_sessionId = finishUpdateVerification_args_sessionId obj}
    ]
from_FinishUpdateVerification_args :: FinishUpdateVerification_args -> T.ThriftVal
from_FinishUpdateVerification_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4120 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v4120))) $ finishUpdateVerification_args_sessionId record
  ]
write_FinishUpdateVerification_args :: T.Protocol p => p -> FinishUpdateVerification_args -> P.IO ()
write_FinishUpdateVerification_args oprot record = T.writeVal oprot $ from_FinishUpdateVerification_args record
encode_FinishUpdateVerification_args :: T.StatelessProtocol p => p -> FinishUpdateVerification_args -> LBS.ByteString
encode_FinishUpdateVerification_args oprot record = T.serializeVal oprot $ from_FinishUpdateVerification_args record
to_FinishUpdateVerification_args :: T.ThriftVal -> FinishUpdateVerification_args
to_FinishUpdateVerification_args (T.TStruct fields) = FinishUpdateVerification_args{
  finishUpdateVerification_args_sessionId = P.maybe (finishUpdateVerification_args_sessionId default_FinishUpdateVerification_args) (\(_,_val4122) -> (case _val4122 of {T.TString _val4123 -> E.decodeUtf8 _val4123; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FinishUpdateVerification_args _ = P.error "not a struct"
read_FinishUpdateVerification_args :: T.Protocol p => p -> P.IO FinishUpdateVerification_args
read_FinishUpdateVerification_args iprot = to_FinishUpdateVerification_args <$> T.readVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_args)
decode_FinishUpdateVerification_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FinishUpdateVerification_args
decode_FinishUpdateVerification_args iprot bs = to_FinishUpdateVerification_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_args) bs
typemap_FinishUpdateVerification_args :: T.TypeMap
typemap_FinishUpdateVerification_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_FinishUpdateVerification_args :: FinishUpdateVerification_args
default_FinishUpdateVerification_args = FinishUpdateVerification_args{
  finishUpdateVerification_args_sessionId = ""}
data FinishUpdateVerification_result = FinishUpdateVerification_result  { finishUpdateVerification_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FinishUpdateVerification_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` finishUpdateVerification_result_e record  
instance QC.Arbitrary FinishUpdateVerification_result where 
  arbitrary = M.liftM FinishUpdateVerification_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FinishUpdateVerification_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FinishUpdateVerification_result{finishUpdateVerification_result_e = finishUpdateVerification_result_e obj} then P.Nothing else P.Just $ default_FinishUpdateVerification_result{finishUpdateVerification_result_e = finishUpdateVerification_result_e obj}
    ]
from_FinishUpdateVerification_result :: FinishUpdateVerification_result -> T.ThriftVal
from_FinishUpdateVerification_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4126 -> (1, ("e",from_TalkException _v4126))) <$> finishUpdateVerification_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4126 -> (1, ("e",from_TalkException _v4126))) <$> finishUpdateVerification_result_e record
    ]
    )
write_FinishUpdateVerification_result :: T.Protocol p => p -> FinishUpdateVerification_result -> P.IO ()
write_FinishUpdateVerification_result oprot record = T.writeVal oprot $ from_FinishUpdateVerification_result record
encode_FinishUpdateVerification_result :: T.StatelessProtocol p => p -> FinishUpdateVerification_result -> LBS.ByteString
encode_FinishUpdateVerification_result oprot record = T.serializeVal oprot $ from_FinishUpdateVerification_result record
to_FinishUpdateVerification_result :: T.ThriftVal -> FinishUpdateVerification_result
to_FinishUpdateVerification_result (T.TStruct fields) = FinishUpdateVerification_result{
  finishUpdateVerification_result_e = P.maybe (P.Nothing) (\(_,_val4128) -> P.Just (case _val4128 of {T.TStruct _val4129 -> (to_TalkException (T.TStruct _val4129)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FinishUpdateVerification_result _ = P.error "not a struct"
read_FinishUpdateVerification_result :: T.Protocol p => p -> P.IO FinishUpdateVerification_result
read_FinishUpdateVerification_result iprot = to_FinishUpdateVerification_result <$> T.readVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_result)
decode_FinishUpdateVerification_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FinishUpdateVerification_result
decode_FinishUpdateVerification_result iprot bs = to_FinishUpdateVerification_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_result) bs
typemap_FinishUpdateVerification_result :: T.TypeMap
typemap_FinishUpdateVerification_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FinishUpdateVerification_result :: FinishUpdateVerification_result
default_FinishUpdateVerification_result = FinishUpdateVerification_result{
  finishUpdateVerification_result_e = P.Nothing}
data GenerateUserTicket_args = GenerateUserTicket_args  { generateUserTicket_args_expirationTime :: I.Int64
  , generateUserTicket_args_maxUseCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GenerateUserTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` generateUserTicket_args_expirationTime record   `H.hashWithSalt` generateUserTicket_args_maxUseCount record  
instance QC.Arbitrary GenerateUserTicket_args where 
  arbitrary = M.liftM GenerateUserTicket_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GenerateUserTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GenerateUserTicket_args{generateUserTicket_args_expirationTime = generateUserTicket_args_expirationTime obj} then P.Nothing else P.Just $ default_GenerateUserTicket_args{generateUserTicket_args_expirationTime = generateUserTicket_args_expirationTime obj}
    , if obj == default_GenerateUserTicket_args{generateUserTicket_args_maxUseCount = generateUserTicket_args_maxUseCount obj} then P.Nothing else P.Just $ default_GenerateUserTicket_args{generateUserTicket_args_maxUseCount = generateUserTicket_args_maxUseCount obj}
    ]
from_GenerateUserTicket_args :: GenerateUserTicket_args -> T.ThriftVal
from_GenerateUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4132 -> P.Just (3, ("expirationTime",T.TI64 _v4132))) $ generateUserTicket_args_expirationTime record
  , (\_v4132 -> P.Just (4, ("maxUseCount",T.TI32 _v4132))) $ generateUserTicket_args_maxUseCount record
  ]
write_GenerateUserTicket_args :: T.Protocol p => p -> GenerateUserTicket_args -> P.IO ()
write_GenerateUserTicket_args oprot record = T.writeVal oprot $ from_GenerateUserTicket_args record
encode_GenerateUserTicket_args :: T.StatelessProtocol p => p -> GenerateUserTicket_args -> LBS.ByteString
encode_GenerateUserTicket_args oprot record = T.serializeVal oprot $ from_GenerateUserTicket_args record
to_GenerateUserTicket_args :: T.ThriftVal -> GenerateUserTicket_args
to_GenerateUserTicket_args (T.TStruct fields) = GenerateUserTicket_args{
  generateUserTicket_args_expirationTime = P.maybe (generateUserTicket_args_expirationTime default_GenerateUserTicket_args) (\(_,_val4134) -> (case _val4134 of {T.TI64 _val4135 -> _val4135; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  generateUserTicket_args_maxUseCount = P.maybe (generateUserTicket_args_maxUseCount default_GenerateUserTicket_args) (\(_,_val4134) -> (case _val4134 of {T.TI32 _val4136 -> _val4136; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GenerateUserTicket_args _ = P.error "not a struct"
read_GenerateUserTicket_args :: T.Protocol p => p -> P.IO GenerateUserTicket_args
read_GenerateUserTicket_args iprot = to_GenerateUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_GenerateUserTicket_args)
decode_GenerateUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GenerateUserTicket_args
decode_GenerateUserTicket_args iprot bs = to_GenerateUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GenerateUserTicket_args) bs
typemap_GenerateUserTicket_args :: T.TypeMap
typemap_GenerateUserTicket_args = Map.fromList [(3,("expirationTime",T.T_I64)),(4,("maxUseCount",T.T_I32))]
default_GenerateUserTicket_args :: GenerateUserTicket_args
default_GenerateUserTicket_args = GenerateUserTicket_args{
  generateUserTicket_args_expirationTime = 0,
  generateUserTicket_args_maxUseCount = 0}
data GenerateUserTicket_result = GenerateUserTicket_result  { generateUserTicket_result_success :: Ticket
  , generateUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GenerateUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` generateUserTicket_result_success record   `H.hashWithSalt` generateUserTicket_result_e record  
instance QC.Arbitrary GenerateUserTicket_result where 
  arbitrary = M.liftM GenerateUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GenerateUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GenerateUserTicket_result{generateUserTicket_result_success = generateUserTicket_result_success obj} then P.Nothing else P.Just $ default_GenerateUserTicket_result{generateUserTicket_result_success = generateUserTicket_result_success obj}
    , if obj == default_GenerateUserTicket_result{generateUserTicket_result_e = generateUserTicket_result_e obj} then P.Nothing else P.Just $ default_GenerateUserTicket_result{generateUserTicket_result_e = generateUserTicket_result_e obj}
    ]
from_GenerateUserTicket_result :: GenerateUserTicket_result -> T.ThriftVal
from_GenerateUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4139 -> (1, ("e",from_TalkException _v4139))) <$> generateUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4139 -> P.Just (0, ("success",from_Ticket _v4139))) $ generateUserTicket_result_success record
    , (\_v4139 -> (1, ("e",from_TalkException _v4139))) <$> generateUserTicket_result_e record
    ]
    )
write_GenerateUserTicket_result :: T.Protocol p => p -> GenerateUserTicket_result -> P.IO ()
write_GenerateUserTicket_result oprot record = T.writeVal oprot $ from_GenerateUserTicket_result record
encode_GenerateUserTicket_result :: T.StatelessProtocol p => p -> GenerateUserTicket_result -> LBS.ByteString
encode_GenerateUserTicket_result oprot record = T.serializeVal oprot $ from_GenerateUserTicket_result record
to_GenerateUserTicket_result :: T.ThriftVal -> GenerateUserTicket_result
to_GenerateUserTicket_result (T.TStruct fields) = GenerateUserTicket_result{
  generateUserTicket_result_success = P.maybe (generateUserTicket_result_success default_GenerateUserTicket_result) (\(_,_val4141) -> (case _val4141 of {T.TStruct _val4142 -> (to_Ticket (T.TStruct _val4142)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  generateUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val4141) -> P.Just (case _val4141 of {T.TStruct _val4143 -> (to_TalkException (T.TStruct _val4143)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GenerateUserTicket_result _ = P.error "not a struct"
read_GenerateUserTicket_result :: T.Protocol p => p -> P.IO GenerateUserTicket_result
read_GenerateUserTicket_result iprot = to_GenerateUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_GenerateUserTicket_result)
decode_GenerateUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GenerateUserTicket_result
decode_GenerateUserTicket_result iprot bs = to_GenerateUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GenerateUserTicket_result) bs
typemap_GenerateUserTicket_result :: T.TypeMap
typemap_GenerateUserTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Ticket))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GenerateUserTicket_result :: GenerateUserTicket_result
default_GenerateUserTicket_result = GenerateUserTicket_result{
  generateUserTicket_result_success = default_Ticket,
  generateUserTicket_result_e = P.Nothing}
data GetAcceptedProximityMatches_args = GetAcceptedProximityMatches_args  { getAcceptedProximityMatches_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAcceptedProximityMatches_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAcceptedProximityMatches_args_sessionId record  
instance QC.Arbitrary GetAcceptedProximityMatches_args where 
  arbitrary = M.liftM GetAcceptedProximityMatches_args (QC.arbitrary)
  shrink obj | obj == default_GetAcceptedProximityMatches_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAcceptedProximityMatches_args{getAcceptedProximityMatches_args_sessionId = getAcceptedProximityMatches_args_sessionId obj} then P.Nothing else P.Just $ default_GetAcceptedProximityMatches_args{getAcceptedProximityMatches_args_sessionId = getAcceptedProximityMatches_args_sessionId obj}
    ]
from_GetAcceptedProximityMatches_args :: GetAcceptedProximityMatches_args -> T.ThriftVal
from_GetAcceptedProximityMatches_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4146 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v4146))) $ getAcceptedProximityMatches_args_sessionId record
  ]
write_GetAcceptedProximityMatches_args :: T.Protocol p => p -> GetAcceptedProximityMatches_args -> P.IO ()
write_GetAcceptedProximityMatches_args oprot record = T.writeVal oprot $ from_GetAcceptedProximityMatches_args record
encode_GetAcceptedProximityMatches_args :: T.StatelessProtocol p => p -> GetAcceptedProximityMatches_args -> LBS.ByteString
encode_GetAcceptedProximityMatches_args oprot record = T.serializeVal oprot $ from_GetAcceptedProximityMatches_args record
to_GetAcceptedProximityMatches_args :: T.ThriftVal -> GetAcceptedProximityMatches_args
to_GetAcceptedProximityMatches_args (T.TStruct fields) = GetAcceptedProximityMatches_args{
  getAcceptedProximityMatches_args_sessionId = P.maybe (getAcceptedProximityMatches_args_sessionId default_GetAcceptedProximityMatches_args) (\(_,_val4148) -> (case _val4148 of {T.TString _val4149 -> E.decodeUtf8 _val4149; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetAcceptedProximityMatches_args _ = P.error "not a struct"
read_GetAcceptedProximityMatches_args :: T.Protocol p => p -> P.IO GetAcceptedProximityMatches_args
read_GetAcceptedProximityMatches_args iprot = to_GetAcceptedProximityMatches_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_args)
decode_GetAcceptedProximityMatches_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAcceptedProximityMatches_args
decode_GetAcceptedProximityMatches_args iprot bs = to_GetAcceptedProximityMatches_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_args) bs
typemap_GetAcceptedProximityMatches_args :: T.TypeMap
typemap_GetAcceptedProximityMatches_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_GetAcceptedProximityMatches_args :: GetAcceptedProximityMatches_args
default_GetAcceptedProximityMatches_args = GetAcceptedProximityMatches_args{
  getAcceptedProximityMatches_args_sessionId = ""}
data GetAcceptedProximityMatches_result = GetAcceptedProximityMatches_result  { getAcceptedProximityMatches_result_success :: (Set.HashSet LT.Text)
  , getAcceptedProximityMatches_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAcceptedProximityMatches_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAcceptedProximityMatches_result_success record   `H.hashWithSalt` getAcceptedProximityMatches_result_e record  
instance QC.Arbitrary GetAcceptedProximityMatches_result where 
  arbitrary = M.liftM GetAcceptedProximityMatches_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAcceptedProximityMatches_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_success = getAcceptedProximityMatches_result_success obj} then P.Nothing else P.Just $ default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_success = getAcceptedProximityMatches_result_success obj}
    , if obj == default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_e = getAcceptedProximityMatches_result_e obj} then P.Nothing else P.Just $ default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_e = getAcceptedProximityMatches_result_e obj}
    ]
from_GetAcceptedProximityMatches_result :: GetAcceptedProximityMatches_result -> T.ThriftVal
from_GetAcceptedProximityMatches_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4152 -> (1, ("e",from_TalkException _v4152))) <$> getAcceptedProximityMatches_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4152 -> P.Just (0, ("success",T.TSet T.T_STRING $ P.map (\_v4154 -> T.TString $ E.encodeUtf8 _v4154) $ Set.toList _v4152))) $ getAcceptedProximityMatches_result_success record
    , (\_v4152 -> (1, ("e",from_TalkException _v4152))) <$> getAcceptedProximityMatches_result_e record
    ]
    )
write_GetAcceptedProximityMatches_result :: T.Protocol p => p -> GetAcceptedProximityMatches_result -> P.IO ()
write_GetAcceptedProximityMatches_result oprot record = T.writeVal oprot $ from_GetAcceptedProximityMatches_result record
encode_GetAcceptedProximityMatches_result :: T.StatelessProtocol p => p -> GetAcceptedProximityMatches_result -> LBS.ByteString
encode_GetAcceptedProximityMatches_result oprot record = T.serializeVal oprot $ from_GetAcceptedProximityMatches_result record
to_GetAcceptedProximityMatches_result :: T.ThriftVal -> GetAcceptedProximityMatches_result
to_GetAcceptedProximityMatches_result (T.TStruct fields) = GetAcceptedProximityMatches_result{
  getAcceptedProximityMatches_result_success = P.maybe (getAcceptedProximityMatches_result_success default_GetAcceptedProximityMatches_result) (\(_,_val4156) -> (case _val4156 of {T.TSet _ _val4157 -> (Set.fromList $ P.map (\_v4158 -> (case _v4158 of {T.TString _val4159 -> E.decodeUtf8 _val4159; _ -> P.error "wrong type"})) _val4157); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAcceptedProximityMatches_result_e = P.maybe (P.Nothing) (\(_,_val4156) -> P.Just (case _val4156 of {T.TStruct _val4160 -> (to_TalkException (T.TStruct _val4160)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAcceptedProximityMatches_result _ = P.error "not a struct"
read_GetAcceptedProximityMatches_result :: T.Protocol p => p -> P.IO GetAcceptedProximityMatches_result
read_GetAcceptedProximityMatches_result iprot = to_GetAcceptedProximityMatches_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_result)
decode_GetAcceptedProximityMatches_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAcceptedProximityMatches_result
decode_GetAcceptedProximityMatches_result iprot bs = to_GetAcceptedProximityMatches_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_result) bs
typemap_GetAcceptedProximityMatches_result :: T.TypeMap
typemap_GetAcceptedProximityMatches_result = Map.fromList [(0,("success",(T.T_SET T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAcceptedProximityMatches_result :: GetAcceptedProximityMatches_result
default_GetAcceptedProximityMatches_result = GetAcceptedProximityMatches_result{
  getAcceptedProximityMatches_result_success = Set.empty,
  getAcceptedProximityMatches_result_e = P.Nothing}
data GetActiveBuddySubscriberIds_args = GetActiveBuddySubscriberIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActiveBuddySubscriberIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetActiveBuddySubscriberIds_args where 
  arbitrary = QC.elements [GetActiveBuddySubscriberIds_args]
from_GetActiveBuddySubscriberIds_args :: GetActiveBuddySubscriberIds_args -> T.ThriftVal
from_GetActiveBuddySubscriberIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetActiveBuddySubscriberIds_args :: T.Protocol p => p -> GetActiveBuddySubscriberIds_args -> P.IO ()
write_GetActiveBuddySubscriberIds_args oprot record = T.writeVal oprot $ from_GetActiveBuddySubscriberIds_args record
encode_GetActiveBuddySubscriberIds_args :: T.StatelessProtocol p => p -> GetActiveBuddySubscriberIds_args -> LBS.ByteString
encode_GetActiveBuddySubscriberIds_args oprot record = T.serializeVal oprot $ from_GetActiveBuddySubscriberIds_args record
to_GetActiveBuddySubscriberIds_args :: T.ThriftVal -> GetActiveBuddySubscriberIds_args
to_GetActiveBuddySubscriberIds_args (T.TStruct fields) = GetActiveBuddySubscriberIds_args{

  }
to_GetActiveBuddySubscriberIds_args _ = P.error "not a struct"
read_GetActiveBuddySubscriberIds_args :: T.Protocol p => p -> P.IO GetActiveBuddySubscriberIds_args
read_GetActiveBuddySubscriberIds_args iprot = to_GetActiveBuddySubscriberIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_args)
decode_GetActiveBuddySubscriberIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActiveBuddySubscriberIds_args
decode_GetActiveBuddySubscriberIds_args iprot bs = to_GetActiveBuddySubscriberIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_args) bs
typemap_GetActiveBuddySubscriberIds_args :: T.TypeMap
typemap_GetActiveBuddySubscriberIds_args = Map.fromList []
default_GetActiveBuddySubscriberIds_args :: GetActiveBuddySubscriberIds_args
default_GetActiveBuddySubscriberIds_args = GetActiveBuddySubscriberIds_args{
}
data GetActiveBuddySubscriberIds_result = GetActiveBuddySubscriberIds_result  { getActiveBuddySubscriberIds_result_success :: (Vector.Vector LT.Text)
  , getActiveBuddySubscriberIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActiveBuddySubscriberIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getActiveBuddySubscriberIds_result_success record   `H.hashWithSalt` getActiveBuddySubscriberIds_result_e record  
instance QC.Arbitrary GetActiveBuddySubscriberIds_result where 
  arbitrary = M.liftM GetActiveBuddySubscriberIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetActiveBuddySubscriberIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_success = getActiveBuddySubscriberIds_result_success obj} then P.Nothing else P.Just $ default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_success = getActiveBuddySubscriberIds_result_success obj}
    , if obj == default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_e = getActiveBuddySubscriberIds_result_e obj} then P.Nothing else P.Just $ default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_e = getActiveBuddySubscriberIds_result_e obj}
    ]
from_GetActiveBuddySubscriberIds_result :: GetActiveBuddySubscriberIds_result -> T.ThriftVal
from_GetActiveBuddySubscriberIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4168 -> (1, ("e",from_TalkException _v4168))) <$> getActiveBuddySubscriberIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4168 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4170 -> T.TString $ E.encodeUtf8 _v4170) $ Vector.toList _v4168))) $ getActiveBuddySubscriberIds_result_success record
    , (\_v4168 -> (1, ("e",from_TalkException _v4168))) <$> getActiveBuddySubscriberIds_result_e record
    ]
    )
write_GetActiveBuddySubscriberIds_result :: T.Protocol p => p -> GetActiveBuddySubscriberIds_result -> P.IO ()
write_GetActiveBuddySubscriberIds_result oprot record = T.writeVal oprot $ from_GetActiveBuddySubscriberIds_result record
encode_GetActiveBuddySubscriberIds_result :: T.StatelessProtocol p => p -> GetActiveBuddySubscriberIds_result -> LBS.ByteString
encode_GetActiveBuddySubscriberIds_result oprot record = T.serializeVal oprot $ from_GetActiveBuddySubscriberIds_result record
to_GetActiveBuddySubscriberIds_result :: T.ThriftVal -> GetActiveBuddySubscriberIds_result
to_GetActiveBuddySubscriberIds_result (T.TStruct fields) = GetActiveBuddySubscriberIds_result{
  getActiveBuddySubscriberIds_result_success = P.maybe (getActiveBuddySubscriberIds_result_success default_GetActiveBuddySubscriberIds_result) (\(_,_val4172) -> (case _val4172 of {T.TList _ _val4173 -> (Vector.fromList $ P.map (\_v4174 -> (case _v4174 of {T.TString _val4175 -> E.decodeUtf8 _val4175; _ -> P.error "wrong type"})) _val4173); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getActiveBuddySubscriberIds_result_e = P.maybe (P.Nothing) (\(_,_val4172) -> P.Just (case _val4172 of {T.TStruct _val4176 -> (to_TalkException (T.TStruct _val4176)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetActiveBuddySubscriberIds_result _ = P.error "not a struct"
read_GetActiveBuddySubscriberIds_result :: T.Protocol p => p -> P.IO GetActiveBuddySubscriberIds_result
read_GetActiveBuddySubscriberIds_result iprot = to_GetActiveBuddySubscriberIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_result)
decode_GetActiveBuddySubscriberIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActiveBuddySubscriberIds_result
decode_GetActiveBuddySubscriberIds_result iprot bs = to_GetActiveBuddySubscriberIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_result) bs
typemap_GetActiveBuddySubscriberIds_result :: T.TypeMap
typemap_GetActiveBuddySubscriberIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetActiveBuddySubscriberIds_result :: GetActiveBuddySubscriberIds_result
default_GetActiveBuddySubscriberIds_result = GetActiveBuddySubscriberIds_result{
  getActiveBuddySubscriberIds_result_success = Vector.empty,
  getActiveBuddySubscriberIds_result_e = P.Nothing}
data GetAllContactIds_args = GetAllContactIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetAllContactIds_args where 
  arbitrary = QC.elements [GetAllContactIds_args]
from_GetAllContactIds_args :: GetAllContactIds_args -> T.ThriftVal
from_GetAllContactIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetAllContactIds_args :: T.Protocol p => p -> GetAllContactIds_args -> P.IO ()
write_GetAllContactIds_args oprot record = T.writeVal oprot $ from_GetAllContactIds_args record
encode_GetAllContactIds_args :: T.StatelessProtocol p => p -> GetAllContactIds_args -> LBS.ByteString
encode_GetAllContactIds_args oprot record = T.serializeVal oprot $ from_GetAllContactIds_args record
to_GetAllContactIds_args :: T.ThriftVal -> GetAllContactIds_args
to_GetAllContactIds_args (T.TStruct fields) = GetAllContactIds_args{

  }
to_GetAllContactIds_args _ = P.error "not a struct"
read_GetAllContactIds_args :: T.Protocol p => p -> P.IO GetAllContactIds_args
read_GetAllContactIds_args iprot = to_GetAllContactIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIds_args)
decode_GetAllContactIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIds_args
decode_GetAllContactIds_args iprot bs = to_GetAllContactIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIds_args) bs
typemap_GetAllContactIds_args :: T.TypeMap
typemap_GetAllContactIds_args = Map.fromList []
default_GetAllContactIds_args :: GetAllContactIds_args
default_GetAllContactIds_args = GetAllContactIds_args{
}
data GetAllContactIds_result = GetAllContactIds_result  { getAllContactIds_result_success :: (Vector.Vector LT.Text)
  , getAllContactIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllContactIds_result_success record   `H.hashWithSalt` getAllContactIds_result_e record  
instance QC.Arbitrary GetAllContactIds_result where 
  arbitrary = M.liftM GetAllContactIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllContactIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllContactIds_result{getAllContactIds_result_success = getAllContactIds_result_success obj} then P.Nothing else P.Just $ default_GetAllContactIds_result{getAllContactIds_result_success = getAllContactIds_result_success obj}
    , if obj == default_GetAllContactIds_result{getAllContactIds_result_e = getAllContactIds_result_e obj} then P.Nothing else P.Just $ default_GetAllContactIds_result{getAllContactIds_result_e = getAllContactIds_result_e obj}
    ]
from_GetAllContactIds_result :: GetAllContactIds_result -> T.ThriftVal
from_GetAllContactIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4184 -> (1, ("e",from_TalkException _v4184))) <$> getAllContactIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4184 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4186 -> T.TString $ E.encodeUtf8 _v4186) $ Vector.toList _v4184))) $ getAllContactIds_result_success record
    , (\_v4184 -> (1, ("e",from_TalkException _v4184))) <$> getAllContactIds_result_e record
    ]
    )
write_GetAllContactIds_result :: T.Protocol p => p -> GetAllContactIds_result -> P.IO ()
write_GetAllContactIds_result oprot record = T.writeVal oprot $ from_GetAllContactIds_result record
encode_GetAllContactIds_result :: T.StatelessProtocol p => p -> GetAllContactIds_result -> LBS.ByteString
encode_GetAllContactIds_result oprot record = T.serializeVal oprot $ from_GetAllContactIds_result record
to_GetAllContactIds_result :: T.ThriftVal -> GetAllContactIds_result
to_GetAllContactIds_result (T.TStruct fields) = GetAllContactIds_result{
  getAllContactIds_result_success = P.maybe (getAllContactIds_result_success default_GetAllContactIds_result) (\(_,_val4188) -> (case _val4188 of {T.TList _ _val4189 -> (Vector.fromList $ P.map (\_v4190 -> (case _v4190 of {T.TString _val4191 -> E.decodeUtf8 _val4191; _ -> P.error "wrong type"})) _val4189); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllContactIds_result_e = P.maybe (P.Nothing) (\(_,_val4188) -> P.Just (case _val4188 of {T.TStruct _val4192 -> (to_TalkException (T.TStruct _val4192)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllContactIds_result _ = P.error "not a struct"
read_GetAllContactIds_result :: T.Protocol p => p -> P.IO GetAllContactIds_result
read_GetAllContactIds_result iprot = to_GetAllContactIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIds_result)
decode_GetAllContactIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIds_result
decode_GetAllContactIds_result iprot bs = to_GetAllContactIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIds_result) bs
typemap_GetAllContactIds_result :: T.TypeMap
typemap_GetAllContactIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllContactIds_result :: GetAllContactIds_result
default_GetAllContactIds_result = GetAllContactIds_result{
  getAllContactIds_result_success = Vector.empty,
  getAllContactIds_result_e = P.Nothing}
data GetAuthQrcode_args = GetAuthQrcode_args  { getAuthQrcode_args_keepLoggedIn :: P.Bool
  , getAuthQrcode_args_systemName :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAuthQrcode_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAuthQrcode_args_keepLoggedIn record   `H.hashWithSalt` getAuthQrcode_args_systemName record  
instance QC.Arbitrary GetAuthQrcode_args where 
  arbitrary = M.liftM GetAuthQrcode_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetAuthQrcode_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAuthQrcode_args{getAuthQrcode_args_keepLoggedIn = getAuthQrcode_args_keepLoggedIn obj} then P.Nothing else P.Just $ default_GetAuthQrcode_args{getAuthQrcode_args_keepLoggedIn = getAuthQrcode_args_keepLoggedIn obj}
    , if obj == default_GetAuthQrcode_args{getAuthQrcode_args_systemName = getAuthQrcode_args_systemName obj} then P.Nothing else P.Just $ default_GetAuthQrcode_args{getAuthQrcode_args_systemName = getAuthQrcode_args_systemName obj}
    ]
from_GetAuthQrcode_args :: GetAuthQrcode_args -> T.ThriftVal
from_GetAuthQrcode_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4195 -> P.Just (2, ("keepLoggedIn",T.TBool _v4195))) $ getAuthQrcode_args_keepLoggedIn record
  , (\_v4195 -> P.Just (3, ("systemName",T.TString $ E.encodeUtf8 _v4195))) $ getAuthQrcode_args_systemName record
  ]
write_GetAuthQrcode_args :: T.Protocol p => p -> GetAuthQrcode_args -> P.IO ()
write_GetAuthQrcode_args oprot record = T.writeVal oprot $ from_GetAuthQrcode_args record
encode_GetAuthQrcode_args :: T.StatelessProtocol p => p -> GetAuthQrcode_args -> LBS.ByteString
encode_GetAuthQrcode_args oprot record = T.serializeVal oprot $ from_GetAuthQrcode_args record
to_GetAuthQrcode_args :: T.ThriftVal -> GetAuthQrcode_args
to_GetAuthQrcode_args (T.TStruct fields) = GetAuthQrcode_args{
  getAuthQrcode_args_keepLoggedIn = P.maybe (getAuthQrcode_args_keepLoggedIn default_GetAuthQrcode_args) (\(_,_val4197) -> (case _val4197 of {T.TBool _val4198 -> _val4198; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getAuthQrcode_args_systemName = P.maybe (getAuthQrcode_args_systemName default_GetAuthQrcode_args) (\(_,_val4197) -> (case _val4197 of {T.TString _val4199 -> E.decodeUtf8 _val4199; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetAuthQrcode_args _ = P.error "not a struct"
read_GetAuthQrcode_args :: T.Protocol p => p -> P.IO GetAuthQrcode_args
read_GetAuthQrcode_args iprot = to_GetAuthQrcode_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAuthQrcode_args)
decode_GetAuthQrcode_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAuthQrcode_args
decode_GetAuthQrcode_args iprot bs = to_GetAuthQrcode_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAuthQrcode_args) bs
typemap_GetAuthQrcode_args :: T.TypeMap
typemap_GetAuthQrcode_args = Map.fromList [(2,("keepLoggedIn",T.T_BOOL)),(3,("systemName",T.T_STRING))]
default_GetAuthQrcode_args :: GetAuthQrcode_args
default_GetAuthQrcode_args = GetAuthQrcode_args{
  getAuthQrcode_args_keepLoggedIn = P.False,
  getAuthQrcode_args_systemName = ""}
data GetAuthQrcode_result = GetAuthQrcode_result  { getAuthQrcode_result_success :: AuthQrcode
  , getAuthQrcode_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAuthQrcode_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAuthQrcode_result_success record   `H.hashWithSalt` getAuthQrcode_result_e record  
instance QC.Arbitrary GetAuthQrcode_result where 
  arbitrary = M.liftM GetAuthQrcode_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAuthQrcode_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAuthQrcode_result{getAuthQrcode_result_success = getAuthQrcode_result_success obj} then P.Nothing else P.Just $ default_GetAuthQrcode_result{getAuthQrcode_result_success = getAuthQrcode_result_success obj}
    , if obj == default_GetAuthQrcode_result{getAuthQrcode_result_e = getAuthQrcode_result_e obj} then P.Nothing else P.Just $ default_GetAuthQrcode_result{getAuthQrcode_result_e = getAuthQrcode_result_e obj}
    ]
from_GetAuthQrcode_result :: GetAuthQrcode_result -> T.ThriftVal
from_GetAuthQrcode_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4202 -> (1, ("e",from_TalkException _v4202))) <$> getAuthQrcode_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4202 -> P.Just (0, ("success",from_AuthQrcode _v4202))) $ getAuthQrcode_result_success record
    , (\_v4202 -> (1, ("e",from_TalkException _v4202))) <$> getAuthQrcode_result_e record
    ]
    )
write_GetAuthQrcode_result :: T.Protocol p => p -> GetAuthQrcode_result -> P.IO ()
write_GetAuthQrcode_result oprot record = T.writeVal oprot $ from_GetAuthQrcode_result record
encode_GetAuthQrcode_result :: T.StatelessProtocol p => p -> GetAuthQrcode_result -> LBS.ByteString
encode_GetAuthQrcode_result oprot record = T.serializeVal oprot $ from_GetAuthQrcode_result record
to_GetAuthQrcode_result :: T.ThriftVal -> GetAuthQrcode_result
to_GetAuthQrcode_result (T.TStruct fields) = GetAuthQrcode_result{
  getAuthQrcode_result_success = P.maybe (getAuthQrcode_result_success default_GetAuthQrcode_result) (\(_,_val4204) -> (case _val4204 of {T.TStruct _val4205 -> (to_AuthQrcode (T.TStruct _val4205)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAuthQrcode_result_e = P.maybe (P.Nothing) (\(_,_val4204) -> P.Just (case _val4204 of {T.TStruct _val4206 -> (to_TalkException (T.TStruct _val4206)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAuthQrcode_result _ = P.error "not a struct"
read_GetAuthQrcode_result :: T.Protocol p => p -> P.IO GetAuthQrcode_result
read_GetAuthQrcode_result iprot = to_GetAuthQrcode_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAuthQrcode_result)
decode_GetAuthQrcode_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAuthQrcode_result
decode_GetAuthQrcode_result iprot bs = to_GetAuthQrcode_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAuthQrcode_result) bs
typemap_GetAuthQrcode_result :: T.TypeMap
typemap_GetAuthQrcode_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_AuthQrcode))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAuthQrcode_result :: GetAuthQrcode_result
default_GetAuthQrcode_result = GetAuthQrcode_result{
  getAuthQrcode_result_success = default_AuthQrcode,
  getAuthQrcode_result_e = P.Nothing}
data GetBlockedContactIds_args = GetBlockedContactIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetBlockedContactIds_args where 
  arbitrary = QC.elements [GetBlockedContactIds_args]
from_GetBlockedContactIds_args :: GetBlockedContactIds_args -> T.ThriftVal
from_GetBlockedContactIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetBlockedContactIds_args :: T.Protocol p => p -> GetBlockedContactIds_args -> P.IO ()
write_GetBlockedContactIds_args oprot record = T.writeVal oprot $ from_GetBlockedContactIds_args record
encode_GetBlockedContactIds_args :: T.StatelessProtocol p => p -> GetBlockedContactIds_args -> LBS.ByteString
encode_GetBlockedContactIds_args oprot record = T.serializeVal oprot $ from_GetBlockedContactIds_args record
to_GetBlockedContactIds_args :: T.ThriftVal -> GetBlockedContactIds_args
to_GetBlockedContactIds_args (T.TStruct fields) = GetBlockedContactIds_args{

  }
to_GetBlockedContactIds_args _ = P.error "not a struct"
read_GetBlockedContactIds_args :: T.Protocol p => p -> P.IO GetBlockedContactIds_args
read_GetBlockedContactIds_args iprot = to_GetBlockedContactIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_args)
decode_GetBlockedContactIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIds_args
decode_GetBlockedContactIds_args iprot bs = to_GetBlockedContactIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_args) bs
typemap_GetBlockedContactIds_args :: T.TypeMap
typemap_GetBlockedContactIds_args = Map.fromList []
default_GetBlockedContactIds_args :: GetBlockedContactIds_args
default_GetBlockedContactIds_args = GetBlockedContactIds_args{
}
data GetBlockedContactIds_result = GetBlockedContactIds_result  { getBlockedContactIds_result_success :: (Vector.Vector LT.Text)
  , getBlockedContactIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedContactIds_result_success record   `H.hashWithSalt` getBlockedContactIds_result_e record  
instance QC.Arbitrary GetBlockedContactIds_result where 
  arbitrary = M.liftM GetBlockedContactIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBlockedContactIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedContactIds_result{getBlockedContactIds_result_success = getBlockedContactIds_result_success obj} then P.Nothing else P.Just $ default_GetBlockedContactIds_result{getBlockedContactIds_result_success = getBlockedContactIds_result_success obj}
    , if obj == default_GetBlockedContactIds_result{getBlockedContactIds_result_e = getBlockedContactIds_result_e obj} then P.Nothing else P.Just $ default_GetBlockedContactIds_result{getBlockedContactIds_result_e = getBlockedContactIds_result_e obj}
    ]
from_GetBlockedContactIds_result :: GetBlockedContactIds_result -> T.ThriftVal
from_GetBlockedContactIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4214 -> (1, ("e",from_TalkException _v4214))) <$> getBlockedContactIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4214 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4216 -> T.TString $ E.encodeUtf8 _v4216) $ Vector.toList _v4214))) $ getBlockedContactIds_result_success record
    , (\_v4214 -> (1, ("e",from_TalkException _v4214))) <$> getBlockedContactIds_result_e record
    ]
    )
write_GetBlockedContactIds_result :: T.Protocol p => p -> GetBlockedContactIds_result -> P.IO ()
write_GetBlockedContactIds_result oprot record = T.writeVal oprot $ from_GetBlockedContactIds_result record
encode_GetBlockedContactIds_result :: T.StatelessProtocol p => p -> GetBlockedContactIds_result -> LBS.ByteString
encode_GetBlockedContactIds_result oprot record = T.serializeVal oprot $ from_GetBlockedContactIds_result record
to_GetBlockedContactIds_result :: T.ThriftVal -> GetBlockedContactIds_result
to_GetBlockedContactIds_result (T.TStruct fields) = GetBlockedContactIds_result{
  getBlockedContactIds_result_success = P.maybe (getBlockedContactIds_result_success default_GetBlockedContactIds_result) (\(_,_val4218) -> (case _val4218 of {T.TList _ _val4219 -> (Vector.fromList $ P.map (\_v4220 -> (case _v4220 of {T.TString _val4221 -> E.decodeUtf8 _val4221; _ -> P.error "wrong type"})) _val4219); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBlockedContactIds_result_e = P.maybe (P.Nothing) (\(_,_val4218) -> P.Just (case _val4218 of {T.TStruct _val4222 -> (to_TalkException (T.TStruct _val4222)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBlockedContactIds_result _ = P.error "not a struct"
read_GetBlockedContactIds_result :: T.Protocol p => p -> P.IO GetBlockedContactIds_result
read_GetBlockedContactIds_result iprot = to_GetBlockedContactIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_result)
decode_GetBlockedContactIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIds_result
decode_GetBlockedContactIds_result iprot bs = to_GetBlockedContactIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_result) bs
typemap_GetBlockedContactIds_result :: T.TypeMap
typemap_GetBlockedContactIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBlockedContactIds_result :: GetBlockedContactIds_result
default_GetBlockedContactIds_result = GetBlockedContactIds_result{
  getBlockedContactIds_result_success = Vector.empty,
  getBlockedContactIds_result_e = P.Nothing}
data GetBlockedContactIdsByRange_args = GetBlockedContactIdsByRange_args  { getBlockedContactIdsByRange_args_start :: I.Int32
  , getBlockedContactIdsByRange_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIdsByRange_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedContactIdsByRange_args_start record   `H.hashWithSalt` getBlockedContactIdsByRange_args_count record  
instance QC.Arbitrary GetBlockedContactIdsByRange_args where 
  arbitrary = M.liftM GetBlockedContactIdsByRange_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetBlockedContactIdsByRange_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_start = getBlockedContactIdsByRange_args_start obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_start = getBlockedContactIdsByRange_args_start obj}
    , if obj == default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_count = getBlockedContactIdsByRange_args_count obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_count = getBlockedContactIdsByRange_args_count obj}
    ]
from_GetBlockedContactIdsByRange_args :: GetBlockedContactIdsByRange_args -> T.ThriftVal
from_GetBlockedContactIdsByRange_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4225 -> P.Just (2, ("start",T.TI32 _v4225))) $ getBlockedContactIdsByRange_args_start record
  , (\_v4225 -> P.Just (3, ("count",T.TI32 _v4225))) $ getBlockedContactIdsByRange_args_count record
  ]
write_GetBlockedContactIdsByRange_args :: T.Protocol p => p -> GetBlockedContactIdsByRange_args -> P.IO ()
write_GetBlockedContactIdsByRange_args oprot record = T.writeVal oprot $ from_GetBlockedContactIdsByRange_args record
encode_GetBlockedContactIdsByRange_args :: T.StatelessProtocol p => p -> GetBlockedContactIdsByRange_args -> LBS.ByteString
encode_GetBlockedContactIdsByRange_args oprot record = T.serializeVal oprot $ from_GetBlockedContactIdsByRange_args record
to_GetBlockedContactIdsByRange_args :: T.ThriftVal -> GetBlockedContactIdsByRange_args
to_GetBlockedContactIdsByRange_args (T.TStruct fields) = GetBlockedContactIdsByRange_args{
  getBlockedContactIdsByRange_args_start = P.maybe (getBlockedContactIdsByRange_args_start default_GetBlockedContactIdsByRange_args) (\(_,_val4227) -> (case _val4227 of {T.TI32 _val4228 -> _val4228; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getBlockedContactIdsByRange_args_count = P.maybe (getBlockedContactIdsByRange_args_count default_GetBlockedContactIdsByRange_args) (\(_,_val4227) -> (case _val4227 of {T.TI32 _val4229 -> _val4229; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetBlockedContactIdsByRange_args _ = P.error "not a struct"
read_GetBlockedContactIdsByRange_args :: T.Protocol p => p -> P.IO GetBlockedContactIdsByRange_args
read_GetBlockedContactIdsByRange_args iprot = to_GetBlockedContactIdsByRange_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_args)
decode_GetBlockedContactIdsByRange_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIdsByRange_args
decode_GetBlockedContactIdsByRange_args iprot bs = to_GetBlockedContactIdsByRange_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_args) bs
typemap_GetBlockedContactIdsByRange_args :: T.TypeMap
typemap_GetBlockedContactIdsByRange_args = Map.fromList [(2,("start",T.T_I32)),(3,("count",T.T_I32))]
default_GetBlockedContactIdsByRange_args :: GetBlockedContactIdsByRange_args
default_GetBlockedContactIdsByRange_args = GetBlockedContactIdsByRange_args{
  getBlockedContactIdsByRange_args_start = 0,
  getBlockedContactIdsByRange_args_count = 0}
data GetBlockedContactIdsByRange_result = GetBlockedContactIdsByRange_result  { getBlockedContactIdsByRange_result_success :: (Vector.Vector LT.Text)
  , getBlockedContactIdsByRange_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIdsByRange_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedContactIdsByRange_result_success record   `H.hashWithSalt` getBlockedContactIdsByRange_result_e record  
instance QC.Arbitrary GetBlockedContactIdsByRange_result where 
  arbitrary = M.liftM GetBlockedContactIdsByRange_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBlockedContactIdsByRange_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_success = getBlockedContactIdsByRange_result_success obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_success = getBlockedContactIdsByRange_result_success obj}
    , if obj == default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_e = getBlockedContactIdsByRange_result_e obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_e = getBlockedContactIdsByRange_result_e obj}
    ]
from_GetBlockedContactIdsByRange_result :: GetBlockedContactIdsByRange_result -> T.ThriftVal
from_GetBlockedContactIdsByRange_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4232 -> (1, ("e",from_TalkException _v4232))) <$> getBlockedContactIdsByRange_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4232 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4234 -> T.TString $ E.encodeUtf8 _v4234) $ Vector.toList _v4232))) $ getBlockedContactIdsByRange_result_success record
    , (\_v4232 -> (1, ("e",from_TalkException _v4232))) <$> getBlockedContactIdsByRange_result_e record
    ]
    )
write_GetBlockedContactIdsByRange_result :: T.Protocol p => p -> GetBlockedContactIdsByRange_result -> P.IO ()
write_GetBlockedContactIdsByRange_result oprot record = T.writeVal oprot $ from_GetBlockedContactIdsByRange_result record
encode_GetBlockedContactIdsByRange_result :: T.StatelessProtocol p => p -> GetBlockedContactIdsByRange_result -> LBS.ByteString
encode_GetBlockedContactIdsByRange_result oprot record = T.serializeVal oprot $ from_GetBlockedContactIdsByRange_result record
to_GetBlockedContactIdsByRange_result :: T.ThriftVal -> GetBlockedContactIdsByRange_result
to_GetBlockedContactIdsByRange_result (T.TStruct fields) = GetBlockedContactIdsByRange_result{
  getBlockedContactIdsByRange_result_success = P.maybe (getBlockedContactIdsByRange_result_success default_GetBlockedContactIdsByRange_result) (\(_,_val4236) -> (case _val4236 of {T.TList _ _val4237 -> (Vector.fromList $ P.map (\_v4238 -> (case _v4238 of {T.TString _val4239 -> E.decodeUtf8 _val4239; _ -> P.error "wrong type"})) _val4237); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBlockedContactIdsByRange_result_e = P.maybe (P.Nothing) (\(_,_val4236) -> P.Just (case _val4236 of {T.TStruct _val4240 -> (to_TalkException (T.TStruct _val4240)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBlockedContactIdsByRange_result _ = P.error "not a struct"
read_GetBlockedContactIdsByRange_result :: T.Protocol p => p -> P.IO GetBlockedContactIdsByRange_result
read_GetBlockedContactIdsByRange_result iprot = to_GetBlockedContactIdsByRange_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_result)
decode_GetBlockedContactIdsByRange_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIdsByRange_result
decode_GetBlockedContactIdsByRange_result iprot bs = to_GetBlockedContactIdsByRange_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_result) bs
typemap_GetBlockedContactIdsByRange_result :: T.TypeMap
typemap_GetBlockedContactIdsByRange_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBlockedContactIdsByRange_result :: GetBlockedContactIdsByRange_result
default_GetBlockedContactIdsByRange_result = GetBlockedContactIdsByRange_result{
  getBlockedContactIdsByRange_result_success = Vector.empty,
  getBlockedContactIdsByRange_result_e = P.Nothing}
data GetBlockedRecommendationIds_args = GetBlockedRecommendationIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedRecommendationIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetBlockedRecommendationIds_args where 
  arbitrary = QC.elements [GetBlockedRecommendationIds_args]
from_GetBlockedRecommendationIds_args :: GetBlockedRecommendationIds_args -> T.ThriftVal
from_GetBlockedRecommendationIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetBlockedRecommendationIds_args :: T.Protocol p => p -> GetBlockedRecommendationIds_args -> P.IO ()
write_GetBlockedRecommendationIds_args oprot record = T.writeVal oprot $ from_GetBlockedRecommendationIds_args record
encode_GetBlockedRecommendationIds_args :: T.StatelessProtocol p => p -> GetBlockedRecommendationIds_args -> LBS.ByteString
encode_GetBlockedRecommendationIds_args oprot record = T.serializeVal oprot $ from_GetBlockedRecommendationIds_args record
to_GetBlockedRecommendationIds_args :: T.ThriftVal -> GetBlockedRecommendationIds_args
to_GetBlockedRecommendationIds_args (T.TStruct fields) = GetBlockedRecommendationIds_args{

  }
to_GetBlockedRecommendationIds_args _ = P.error "not a struct"
read_GetBlockedRecommendationIds_args :: T.Protocol p => p -> P.IO GetBlockedRecommendationIds_args
read_GetBlockedRecommendationIds_args iprot = to_GetBlockedRecommendationIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_args)
decode_GetBlockedRecommendationIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedRecommendationIds_args
decode_GetBlockedRecommendationIds_args iprot bs = to_GetBlockedRecommendationIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_args) bs
typemap_GetBlockedRecommendationIds_args :: T.TypeMap
typemap_GetBlockedRecommendationIds_args = Map.fromList []
default_GetBlockedRecommendationIds_args :: GetBlockedRecommendationIds_args
default_GetBlockedRecommendationIds_args = GetBlockedRecommendationIds_args{
}
data GetBlockedRecommendationIds_result = GetBlockedRecommendationIds_result  { getBlockedRecommendationIds_result_success :: (Vector.Vector LT.Text)
  , getBlockedRecommendationIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedRecommendationIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedRecommendationIds_result_success record   `H.hashWithSalt` getBlockedRecommendationIds_result_e record  
instance QC.Arbitrary GetBlockedRecommendationIds_result where 
  arbitrary = M.liftM GetBlockedRecommendationIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBlockedRecommendationIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_success = getBlockedRecommendationIds_result_success obj} then P.Nothing else P.Just $ default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_success = getBlockedRecommendationIds_result_success obj}
    , if obj == default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_e = getBlockedRecommendationIds_result_e obj} then P.Nothing else P.Just $ default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_e = getBlockedRecommendationIds_result_e obj}
    ]
from_GetBlockedRecommendationIds_result :: GetBlockedRecommendationIds_result -> T.ThriftVal
from_GetBlockedRecommendationIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4248 -> (1, ("e",from_TalkException _v4248))) <$> getBlockedRecommendationIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4248 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4250 -> T.TString $ E.encodeUtf8 _v4250) $ Vector.toList _v4248))) $ getBlockedRecommendationIds_result_success record
    , (\_v4248 -> (1, ("e",from_TalkException _v4248))) <$> getBlockedRecommendationIds_result_e record
    ]
    )
write_GetBlockedRecommendationIds_result :: T.Protocol p => p -> GetBlockedRecommendationIds_result -> P.IO ()
write_GetBlockedRecommendationIds_result oprot record = T.writeVal oprot $ from_GetBlockedRecommendationIds_result record
encode_GetBlockedRecommendationIds_result :: T.StatelessProtocol p => p -> GetBlockedRecommendationIds_result -> LBS.ByteString
encode_GetBlockedRecommendationIds_result oprot record = T.serializeVal oprot $ from_GetBlockedRecommendationIds_result record
to_GetBlockedRecommendationIds_result :: T.ThriftVal -> GetBlockedRecommendationIds_result
to_GetBlockedRecommendationIds_result (T.TStruct fields) = GetBlockedRecommendationIds_result{
  getBlockedRecommendationIds_result_success = P.maybe (getBlockedRecommendationIds_result_success default_GetBlockedRecommendationIds_result) (\(_,_val4252) -> (case _val4252 of {T.TList _ _val4253 -> (Vector.fromList $ P.map (\_v4254 -> (case _v4254 of {T.TString _val4255 -> E.decodeUtf8 _val4255; _ -> P.error "wrong type"})) _val4253); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBlockedRecommendationIds_result_e = P.maybe (P.Nothing) (\(_,_val4252) -> P.Just (case _val4252 of {T.TStruct _val4256 -> (to_TalkException (T.TStruct _val4256)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBlockedRecommendationIds_result _ = P.error "not a struct"
read_GetBlockedRecommendationIds_result :: T.Protocol p => p -> P.IO GetBlockedRecommendationIds_result
read_GetBlockedRecommendationIds_result iprot = to_GetBlockedRecommendationIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_result)
decode_GetBlockedRecommendationIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedRecommendationIds_result
decode_GetBlockedRecommendationIds_result iprot bs = to_GetBlockedRecommendationIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_result) bs
typemap_GetBlockedRecommendationIds_result :: T.TypeMap
typemap_GetBlockedRecommendationIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBlockedRecommendationIds_result :: GetBlockedRecommendationIds_result
default_GetBlockedRecommendationIds_result = GetBlockedRecommendationIds_result{
  getBlockedRecommendationIds_result_success = Vector.empty,
  getBlockedRecommendationIds_result_e = P.Nothing}
data GetBuddyBlockerIds_args = GetBuddyBlockerIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyBlockerIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetBuddyBlockerIds_args where 
  arbitrary = QC.elements [GetBuddyBlockerIds_args]
from_GetBuddyBlockerIds_args :: GetBuddyBlockerIds_args -> T.ThriftVal
from_GetBuddyBlockerIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetBuddyBlockerIds_args :: T.Protocol p => p -> GetBuddyBlockerIds_args -> P.IO ()
write_GetBuddyBlockerIds_args oprot record = T.writeVal oprot $ from_GetBuddyBlockerIds_args record
encode_GetBuddyBlockerIds_args :: T.StatelessProtocol p => p -> GetBuddyBlockerIds_args -> LBS.ByteString
encode_GetBuddyBlockerIds_args oprot record = T.serializeVal oprot $ from_GetBuddyBlockerIds_args record
to_GetBuddyBlockerIds_args :: T.ThriftVal -> GetBuddyBlockerIds_args
to_GetBuddyBlockerIds_args (T.TStruct fields) = GetBuddyBlockerIds_args{

  }
to_GetBuddyBlockerIds_args _ = P.error "not a struct"
read_GetBuddyBlockerIds_args :: T.Protocol p => p -> P.IO GetBuddyBlockerIds_args
read_GetBuddyBlockerIds_args iprot = to_GetBuddyBlockerIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_args)
decode_GetBuddyBlockerIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyBlockerIds_args
decode_GetBuddyBlockerIds_args iprot bs = to_GetBuddyBlockerIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_args) bs
typemap_GetBuddyBlockerIds_args :: T.TypeMap
typemap_GetBuddyBlockerIds_args = Map.fromList []
default_GetBuddyBlockerIds_args :: GetBuddyBlockerIds_args
default_GetBuddyBlockerIds_args = GetBuddyBlockerIds_args{
}
data GetBuddyBlockerIds_result = GetBuddyBlockerIds_result  { getBuddyBlockerIds_result_success :: (Vector.Vector LT.Text)
  , getBuddyBlockerIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyBlockerIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBuddyBlockerIds_result_success record   `H.hashWithSalt` getBuddyBlockerIds_result_e record  
instance QC.Arbitrary GetBuddyBlockerIds_result where 
  arbitrary = M.liftM GetBuddyBlockerIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBuddyBlockerIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_success = getBuddyBlockerIds_result_success obj} then P.Nothing else P.Just $ default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_success = getBuddyBlockerIds_result_success obj}
    , if obj == default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_e = getBuddyBlockerIds_result_e obj} then P.Nothing else P.Just $ default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_e = getBuddyBlockerIds_result_e obj}
    ]
from_GetBuddyBlockerIds_result :: GetBuddyBlockerIds_result -> T.ThriftVal
from_GetBuddyBlockerIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4264 -> (1, ("e",from_TalkException _v4264))) <$> getBuddyBlockerIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4264 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4266 -> T.TString $ E.encodeUtf8 _v4266) $ Vector.toList _v4264))) $ getBuddyBlockerIds_result_success record
    , (\_v4264 -> (1, ("e",from_TalkException _v4264))) <$> getBuddyBlockerIds_result_e record
    ]
    )
write_GetBuddyBlockerIds_result :: T.Protocol p => p -> GetBuddyBlockerIds_result -> P.IO ()
write_GetBuddyBlockerIds_result oprot record = T.writeVal oprot $ from_GetBuddyBlockerIds_result record
encode_GetBuddyBlockerIds_result :: T.StatelessProtocol p => p -> GetBuddyBlockerIds_result -> LBS.ByteString
encode_GetBuddyBlockerIds_result oprot record = T.serializeVal oprot $ from_GetBuddyBlockerIds_result record
to_GetBuddyBlockerIds_result :: T.ThriftVal -> GetBuddyBlockerIds_result
to_GetBuddyBlockerIds_result (T.TStruct fields) = GetBuddyBlockerIds_result{
  getBuddyBlockerIds_result_success = P.maybe (getBuddyBlockerIds_result_success default_GetBuddyBlockerIds_result) (\(_,_val4268) -> (case _val4268 of {T.TList _ _val4269 -> (Vector.fromList $ P.map (\_v4270 -> (case _v4270 of {T.TString _val4271 -> E.decodeUtf8 _val4271; _ -> P.error "wrong type"})) _val4269); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBuddyBlockerIds_result_e = P.maybe (P.Nothing) (\(_,_val4268) -> P.Just (case _val4268 of {T.TStruct _val4272 -> (to_TalkException (T.TStruct _val4272)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBuddyBlockerIds_result _ = P.error "not a struct"
read_GetBuddyBlockerIds_result :: T.Protocol p => p -> P.IO GetBuddyBlockerIds_result
read_GetBuddyBlockerIds_result iprot = to_GetBuddyBlockerIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_result)
decode_GetBuddyBlockerIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyBlockerIds_result
decode_GetBuddyBlockerIds_result iprot bs = to_GetBuddyBlockerIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_result) bs
typemap_GetBuddyBlockerIds_result :: T.TypeMap
typemap_GetBuddyBlockerIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBuddyBlockerIds_result :: GetBuddyBlockerIds_result
default_GetBuddyBlockerIds_result = GetBuddyBlockerIds_result{
  getBuddyBlockerIds_result_success = Vector.empty,
  getBuddyBlockerIds_result_e = P.Nothing}
data GetBuddyLocation_args = GetBuddyLocation_args  { getBuddyLocation_args_mid :: LT.Text
  , getBuddyLocation_args_index :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyLocation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBuddyLocation_args_mid record   `H.hashWithSalt` getBuddyLocation_args_index record  
instance QC.Arbitrary GetBuddyLocation_args where 
  arbitrary = M.liftM GetBuddyLocation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetBuddyLocation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBuddyLocation_args{getBuddyLocation_args_mid = getBuddyLocation_args_mid obj} then P.Nothing else P.Just $ default_GetBuddyLocation_args{getBuddyLocation_args_mid = getBuddyLocation_args_mid obj}
    , if obj == default_GetBuddyLocation_args{getBuddyLocation_args_index = getBuddyLocation_args_index obj} then P.Nothing else P.Just $ default_GetBuddyLocation_args{getBuddyLocation_args_index = getBuddyLocation_args_index obj}
    ]
from_GetBuddyLocation_args :: GetBuddyLocation_args -> T.ThriftVal
from_GetBuddyLocation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4275 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v4275))) $ getBuddyLocation_args_mid record
  , (\_v4275 -> P.Just (3, ("index",T.TI32 _v4275))) $ getBuddyLocation_args_index record
  ]
write_GetBuddyLocation_args :: T.Protocol p => p -> GetBuddyLocation_args -> P.IO ()
write_GetBuddyLocation_args oprot record = T.writeVal oprot $ from_GetBuddyLocation_args record
encode_GetBuddyLocation_args :: T.StatelessProtocol p => p -> GetBuddyLocation_args -> LBS.ByteString
encode_GetBuddyLocation_args oprot record = T.serializeVal oprot $ from_GetBuddyLocation_args record
to_GetBuddyLocation_args :: T.ThriftVal -> GetBuddyLocation_args
to_GetBuddyLocation_args (T.TStruct fields) = GetBuddyLocation_args{
  getBuddyLocation_args_mid = P.maybe (getBuddyLocation_args_mid default_GetBuddyLocation_args) (\(_,_val4277) -> (case _val4277 of {T.TString _val4278 -> E.decodeUtf8 _val4278; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getBuddyLocation_args_index = P.maybe (getBuddyLocation_args_index default_GetBuddyLocation_args) (\(_,_val4277) -> (case _val4277 of {T.TI32 _val4279 -> _val4279; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetBuddyLocation_args _ = P.error "not a struct"
read_GetBuddyLocation_args :: T.Protocol p => p -> P.IO GetBuddyLocation_args
read_GetBuddyLocation_args iprot = to_GetBuddyLocation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyLocation_args)
decode_GetBuddyLocation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyLocation_args
decode_GetBuddyLocation_args iprot bs = to_GetBuddyLocation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyLocation_args) bs
typemap_GetBuddyLocation_args :: T.TypeMap
typemap_GetBuddyLocation_args = Map.fromList [(2,("mid",T.T_STRING)),(3,("index",T.T_I32))]
default_GetBuddyLocation_args :: GetBuddyLocation_args
default_GetBuddyLocation_args = GetBuddyLocation_args{
  getBuddyLocation_args_mid = "",
  getBuddyLocation_args_index = 0}
data GetBuddyLocation_result = GetBuddyLocation_result  { getBuddyLocation_result_success :: Geolocation
  , getBuddyLocation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyLocation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBuddyLocation_result_success record   `H.hashWithSalt` getBuddyLocation_result_e record  
instance QC.Arbitrary GetBuddyLocation_result where 
  arbitrary = M.liftM GetBuddyLocation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBuddyLocation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBuddyLocation_result{getBuddyLocation_result_success = getBuddyLocation_result_success obj} then P.Nothing else P.Just $ default_GetBuddyLocation_result{getBuddyLocation_result_success = getBuddyLocation_result_success obj}
    , if obj == default_GetBuddyLocation_result{getBuddyLocation_result_e = getBuddyLocation_result_e obj} then P.Nothing else P.Just $ default_GetBuddyLocation_result{getBuddyLocation_result_e = getBuddyLocation_result_e obj}
    ]
from_GetBuddyLocation_result :: GetBuddyLocation_result -> T.ThriftVal
from_GetBuddyLocation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4282 -> (1, ("e",from_TalkException _v4282))) <$> getBuddyLocation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4282 -> P.Just (0, ("success",from_Geolocation _v4282))) $ getBuddyLocation_result_success record
    , (\_v4282 -> (1, ("e",from_TalkException _v4282))) <$> getBuddyLocation_result_e record
    ]
    )
write_GetBuddyLocation_result :: T.Protocol p => p -> GetBuddyLocation_result -> P.IO ()
write_GetBuddyLocation_result oprot record = T.writeVal oprot $ from_GetBuddyLocation_result record
encode_GetBuddyLocation_result :: T.StatelessProtocol p => p -> GetBuddyLocation_result -> LBS.ByteString
encode_GetBuddyLocation_result oprot record = T.serializeVal oprot $ from_GetBuddyLocation_result record
to_GetBuddyLocation_result :: T.ThriftVal -> GetBuddyLocation_result
to_GetBuddyLocation_result (T.TStruct fields) = GetBuddyLocation_result{
  getBuddyLocation_result_success = P.maybe (getBuddyLocation_result_success default_GetBuddyLocation_result) (\(_,_val4284) -> (case _val4284 of {T.TStruct _val4285 -> (to_Geolocation (T.TStruct _val4285)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBuddyLocation_result_e = P.maybe (P.Nothing) (\(_,_val4284) -> P.Just (case _val4284 of {T.TStruct _val4286 -> (to_TalkException (T.TStruct _val4286)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBuddyLocation_result _ = P.error "not a struct"
read_GetBuddyLocation_result :: T.Protocol p => p -> P.IO GetBuddyLocation_result
read_GetBuddyLocation_result iprot = to_GetBuddyLocation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyLocation_result)
decode_GetBuddyLocation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyLocation_result
decode_GetBuddyLocation_result iprot bs = to_GetBuddyLocation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyLocation_result) bs
typemap_GetBuddyLocation_result :: T.TypeMap
typemap_GetBuddyLocation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Geolocation))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBuddyLocation_result :: GetBuddyLocation_result
default_GetBuddyLocation_result = GetBuddyLocation_result{
  getBuddyLocation_result_success = default_Geolocation,
  getBuddyLocation_result_e = P.Nothing}
data GetCompactContactsModifiedSince_args = GetCompactContactsModifiedSince_args  { getCompactContactsModifiedSince_args_timestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContactsModifiedSince_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContactsModifiedSince_args_timestamp record  
instance QC.Arbitrary GetCompactContactsModifiedSince_args where 
  arbitrary = M.liftM GetCompactContactsModifiedSince_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactContactsModifiedSince_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContactsModifiedSince_args{getCompactContactsModifiedSince_args_timestamp = getCompactContactsModifiedSince_args_timestamp obj} then P.Nothing else P.Just $ default_GetCompactContactsModifiedSince_args{getCompactContactsModifiedSince_args_timestamp = getCompactContactsModifiedSince_args_timestamp obj}
    ]
from_GetCompactContactsModifiedSince_args :: GetCompactContactsModifiedSince_args -> T.ThriftVal
from_GetCompactContactsModifiedSince_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4289 -> P.Just (2, ("timestamp",T.TI64 _v4289))) $ getCompactContactsModifiedSince_args_timestamp record
  ]
write_GetCompactContactsModifiedSince_args :: T.Protocol p => p -> GetCompactContactsModifiedSince_args -> P.IO ()
write_GetCompactContactsModifiedSince_args oprot record = T.writeVal oprot $ from_GetCompactContactsModifiedSince_args record
encode_GetCompactContactsModifiedSince_args :: T.StatelessProtocol p => p -> GetCompactContactsModifiedSince_args -> LBS.ByteString
encode_GetCompactContactsModifiedSince_args oprot record = T.serializeVal oprot $ from_GetCompactContactsModifiedSince_args record
to_GetCompactContactsModifiedSince_args :: T.ThriftVal -> GetCompactContactsModifiedSince_args
to_GetCompactContactsModifiedSince_args (T.TStruct fields) = GetCompactContactsModifiedSince_args{
  getCompactContactsModifiedSince_args_timestamp = P.maybe (getCompactContactsModifiedSince_args_timestamp default_GetCompactContactsModifiedSince_args) (\(_,_val4291) -> (case _val4291 of {T.TI64 _val4292 -> _val4292; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactContactsModifiedSince_args _ = P.error "not a struct"
read_GetCompactContactsModifiedSince_args :: T.Protocol p => p -> P.IO GetCompactContactsModifiedSince_args
read_GetCompactContactsModifiedSince_args iprot = to_GetCompactContactsModifiedSince_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_args)
decode_GetCompactContactsModifiedSince_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContactsModifiedSince_args
decode_GetCompactContactsModifiedSince_args iprot bs = to_GetCompactContactsModifiedSince_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_args) bs
typemap_GetCompactContactsModifiedSince_args :: T.TypeMap
typemap_GetCompactContactsModifiedSince_args = Map.fromList [(2,("timestamp",T.T_I64))]
default_GetCompactContactsModifiedSince_args :: GetCompactContactsModifiedSince_args
default_GetCompactContactsModifiedSince_args = GetCompactContactsModifiedSince_args{
  getCompactContactsModifiedSince_args_timestamp = 0}
data GetCompactContactsModifiedSince_result = GetCompactContactsModifiedSince_result  { getCompactContactsModifiedSince_result_success :: (Vector.Vector CompactContact)
  , getCompactContactsModifiedSince_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContactsModifiedSince_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContactsModifiedSince_result_success record   `H.hashWithSalt` getCompactContactsModifiedSince_result_e record  
instance QC.Arbitrary GetCompactContactsModifiedSince_result where 
  arbitrary = M.liftM GetCompactContactsModifiedSince_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactContactsModifiedSince_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_success = getCompactContactsModifiedSince_result_success obj} then P.Nothing else P.Just $ default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_success = getCompactContactsModifiedSince_result_success obj}
    , if obj == default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_e = getCompactContactsModifiedSince_result_e obj} then P.Nothing else P.Just $ default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_e = getCompactContactsModifiedSince_result_e obj}
    ]
from_GetCompactContactsModifiedSince_result :: GetCompactContactsModifiedSince_result -> T.ThriftVal
from_GetCompactContactsModifiedSince_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4295 -> (1, ("e",from_TalkException _v4295))) <$> getCompactContactsModifiedSince_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4295 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CompactContact) $ P.map (\_v4297 -> from_CompactContact _v4297) $ Vector.toList _v4295))) $ getCompactContactsModifiedSince_result_success record
    , (\_v4295 -> (1, ("e",from_TalkException _v4295))) <$> getCompactContactsModifiedSince_result_e record
    ]
    )
write_GetCompactContactsModifiedSince_result :: T.Protocol p => p -> GetCompactContactsModifiedSince_result -> P.IO ()
write_GetCompactContactsModifiedSince_result oprot record = T.writeVal oprot $ from_GetCompactContactsModifiedSince_result record
encode_GetCompactContactsModifiedSince_result :: T.StatelessProtocol p => p -> GetCompactContactsModifiedSince_result -> LBS.ByteString
encode_GetCompactContactsModifiedSince_result oprot record = T.serializeVal oprot $ from_GetCompactContactsModifiedSince_result record
to_GetCompactContactsModifiedSince_result :: T.ThriftVal -> GetCompactContactsModifiedSince_result
to_GetCompactContactsModifiedSince_result (T.TStruct fields) = GetCompactContactsModifiedSince_result{
  getCompactContactsModifiedSince_result_success = P.maybe (getCompactContactsModifiedSince_result_success default_GetCompactContactsModifiedSince_result) (\(_,_val4299) -> (case _val4299 of {T.TList _ _val4300 -> (Vector.fromList $ P.map (\_v4301 -> (case _v4301 of {T.TStruct _val4302 -> (to_CompactContact (T.TStruct _val4302)); _ -> P.error "wrong type"})) _val4300); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactContactsModifiedSince_result_e = P.maybe (P.Nothing) (\(_,_val4299) -> P.Just (case _val4299 of {T.TStruct _val4303 -> (to_TalkException (T.TStruct _val4303)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactContactsModifiedSince_result _ = P.error "not a struct"
read_GetCompactContactsModifiedSince_result :: T.Protocol p => p -> P.IO GetCompactContactsModifiedSince_result
read_GetCompactContactsModifiedSince_result iprot = to_GetCompactContactsModifiedSince_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_result)
decode_GetCompactContactsModifiedSince_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContactsModifiedSince_result
decode_GetCompactContactsModifiedSince_result iprot bs = to_GetCompactContactsModifiedSince_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_result) bs
typemap_GetCompactContactsModifiedSince_result :: T.TypeMap
typemap_GetCompactContactsModifiedSince_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactContactsModifiedSince_result :: GetCompactContactsModifiedSince_result
default_GetCompactContactsModifiedSince_result = GetCompactContactsModifiedSince_result{
  getCompactContactsModifiedSince_result_success = Vector.empty,
  getCompactContactsModifiedSince_result_e = P.Nothing}
data GetCompactGroup_args = GetCompactGroup_args  { getCompactGroup_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactGroup_args_groupId record  
instance QC.Arbitrary GetCompactGroup_args where 
  arbitrary = M.liftM GetCompactGroup_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactGroup_args{getCompactGroup_args_groupId = getCompactGroup_args_groupId obj} then P.Nothing else P.Just $ default_GetCompactGroup_args{getCompactGroup_args_groupId = getCompactGroup_args_groupId obj}
    ]
from_GetCompactGroup_args :: GetCompactGroup_args -> T.ThriftVal
from_GetCompactGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4306 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v4306))) $ getCompactGroup_args_groupId record
  ]
write_GetCompactGroup_args :: T.Protocol p => p -> GetCompactGroup_args -> P.IO ()
write_GetCompactGroup_args oprot record = T.writeVal oprot $ from_GetCompactGroup_args record
encode_GetCompactGroup_args :: T.StatelessProtocol p => p -> GetCompactGroup_args -> LBS.ByteString
encode_GetCompactGroup_args oprot record = T.serializeVal oprot $ from_GetCompactGroup_args record
to_GetCompactGroup_args :: T.ThriftVal -> GetCompactGroup_args
to_GetCompactGroup_args (T.TStruct fields) = GetCompactGroup_args{
  getCompactGroup_args_groupId = P.maybe (getCompactGroup_args_groupId default_GetCompactGroup_args) (\(_,_val4308) -> (case _val4308 of {T.TString _val4309 -> E.decodeUtf8 _val4309; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactGroup_args _ = P.error "not a struct"
read_GetCompactGroup_args :: T.Protocol p => p -> P.IO GetCompactGroup_args
read_GetCompactGroup_args iprot = to_GetCompactGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactGroup_args)
decode_GetCompactGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactGroup_args
decode_GetCompactGroup_args iprot bs = to_GetCompactGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactGroup_args) bs
typemap_GetCompactGroup_args :: T.TypeMap
typemap_GetCompactGroup_args = Map.fromList [(2,("groupId",T.T_STRING))]
default_GetCompactGroup_args :: GetCompactGroup_args
default_GetCompactGroup_args = GetCompactGroup_args{
  getCompactGroup_args_groupId = ""}
data GetCompactGroup_result = GetCompactGroup_result  { getCompactGroup_result_success :: Group
  , getCompactGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactGroup_result_success record   `H.hashWithSalt` getCompactGroup_result_e record  
instance QC.Arbitrary GetCompactGroup_result where 
  arbitrary = M.liftM GetCompactGroup_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactGroup_result{getCompactGroup_result_success = getCompactGroup_result_success obj} then P.Nothing else P.Just $ default_GetCompactGroup_result{getCompactGroup_result_success = getCompactGroup_result_success obj}
    , if obj == default_GetCompactGroup_result{getCompactGroup_result_e = getCompactGroup_result_e obj} then P.Nothing else P.Just $ default_GetCompactGroup_result{getCompactGroup_result_e = getCompactGroup_result_e obj}
    ]
from_GetCompactGroup_result :: GetCompactGroup_result -> T.ThriftVal
from_GetCompactGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4312 -> (1, ("e",from_TalkException _v4312))) <$> getCompactGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4312 -> P.Just (0, ("success",from_Group _v4312))) $ getCompactGroup_result_success record
    , (\_v4312 -> (1, ("e",from_TalkException _v4312))) <$> getCompactGroup_result_e record
    ]
    )
write_GetCompactGroup_result :: T.Protocol p => p -> GetCompactGroup_result -> P.IO ()
write_GetCompactGroup_result oprot record = T.writeVal oprot $ from_GetCompactGroup_result record
encode_GetCompactGroup_result :: T.StatelessProtocol p => p -> GetCompactGroup_result -> LBS.ByteString
encode_GetCompactGroup_result oprot record = T.serializeVal oprot $ from_GetCompactGroup_result record
to_GetCompactGroup_result :: T.ThriftVal -> GetCompactGroup_result
to_GetCompactGroup_result (T.TStruct fields) = GetCompactGroup_result{
  getCompactGroup_result_success = P.maybe (getCompactGroup_result_success default_GetCompactGroup_result) (\(_,_val4314) -> (case _val4314 of {T.TStruct _val4315 -> (to_Group (T.TStruct _val4315)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactGroup_result_e = P.maybe (P.Nothing) (\(_,_val4314) -> P.Just (case _val4314 of {T.TStruct _val4316 -> (to_TalkException (T.TStruct _val4316)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactGroup_result _ = P.error "not a struct"
read_GetCompactGroup_result :: T.Protocol p => p -> P.IO GetCompactGroup_result
read_GetCompactGroup_result iprot = to_GetCompactGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactGroup_result)
decode_GetCompactGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactGroup_result
decode_GetCompactGroup_result iprot bs = to_GetCompactGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactGroup_result) bs
typemap_GetCompactGroup_result :: T.TypeMap
typemap_GetCompactGroup_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactGroup_result :: GetCompactGroup_result
default_GetCompactGroup_result = GetCompactGroup_result{
  getCompactGroup_result_success = default_Group,
  getCompactGroup_result_e = P.Nothing}
data GetCompactRoom_args = GetCompactRoom_args  { getCompactRoom_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactRoom_args_roomId record  
instance QC.Arbitrary GetCompactRoom_args where 
  arbitrary = M.liftM GetCompactRoom_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactRoom_args{getCompactRoom_args_roomId = getCompactRoom_args_roomId obj} then P.Nothing else P.Just $ default_GetCompactRoom_args{getCompactRoom_args_roomId = getCompactRoom_args_roomId obj}
    ]
from_GetCompactRoom_args :: GetCompactRoom_args -> T.ThriftVal
from_GetCompactRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4319 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v4319))) $ getCompactRoom_args_roomId record
  ]
write_GetCompactRoom_args :: T.Protocol p => p -> GetCompactRoom_args -> P.IO ()
write_GetCompactRoom_args oprot record = T.writeVal oprot $ from_GetCompactRoom_args record
encode_GetCompactRoom_args :: T.StatelessProtocol p => p -> GetCompactRoom_args -> LBS.ByteString
encode_GetCompactRoom_args oprot record = T.serializeVal oprot $ from_GetCompactRoom_args record
to_GetCompactRoom_args :: T.ThriftVal -> GetCompactRoom_args
to_GetCompactRoom_args (T.TStruct fields) = GetCompactRoom_args{
  getCompactRoom_args_roomId = P.maybe (getCompactRoom_args_roomId default_GetCompactRoom_args) (\(_,_val4321) -> (case _val4321 of {T.TString _val4322 -> E.decodeUtf8 _val4322; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactRoom_args _ = P.error "not a struct"
read_GetCompactRoom_args :: T.Protocol p => p -> P.IO GetCompactRoom_args
read_GetCompactRoom_args iprot = to_GetCompactRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactRoom_args)
decode_GetCompactRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactRoom_args
decode_GetCompactRoom_args iprot bs = to_GetCompactRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactRoom_args) bs
typemap_GetCompactRoom_args :: T.TypeMap
typemap_GetCompactRoom_args = Map.fromList [(2,("roomId",T.T_STRING))]
default_GetCompactRoom_args :: GetCompactRoom_args
default_GetCompactRoom_args = GetCompactRoom_args{
  getCompactRoom_args_roomId = ""}
data GetCompactRoom_result = GetCompactRoom_result  { getCompactRoom_result_success :: Room
  , getCompactRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactRoom_result_success record   `H.hashWithSalt` getCompactRoom_result_e record  
instance QC.Arbitrary GetCompactRoom_result where 
  arbitrary = M.liftM GetCompactRoom_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactRoom_result{getCompactRoom_result_success = getCompactRoom_result_success obj} then P.Nothing else P.Just $ default_GetCompactRoom_result{getCompactRoom_result_success = getCompactRoom_result_success obj}
    , if obj == default_GetCompactRoom_result{getCompactRoom_result_e = getCompactRoom_result_e obj} then P.Nothing else P.Just $ default_GetCompactRoom_result{getCompactRoom_result_e = getCompactRoom_result_e obj}
    ]
from_GetCompactRoom_result :: GetCompactRoom_result -> T.ThriftVal
from_GetCompactRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4325 -> (1, ("e",from_TalkException _v4325))) <$> getCompactRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4325 -> P.Just (0, ("success",from_Room _v4325))) $ getCompactRoom_result_success record
    , (\_v4325 -> (1, ("e",from_TalkException _v4325))) <$> getCompactRoom_result_e record
    ]
    )
write_GetCompactRoom_result :: T.Protocol p => p -> GetCompactRoom_result -> P.IO ()
write_GetCompactRoom_result oprot record = T.writeVal oprot $ from_GetCompactRoom_result record
encode_GetCompactRoom_result :: T.StatelessProtocol p => p -> GetCompactRoom_result -> LBS.ByteString
encode_GetCompactRoom_result oprot record = T.serializeVal oprot $ from_GetCompactRoom_result record
to_GetCompactRoom_result :: T.ThriftVal -> GetCompactRoom_result
to_GetCompactRoom_result (T.TStruct fields) = GetCompactRoom_result{
  getCompactRoom_result_success = P.maybe (getCompactRoom_result_success default_GetCompactRoom_result) (\(_,_val4327) -> (case _val4327 of {T.TStruct _val4328 -> (to_Room (T.TStruct _val4328)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactRoom_result_e = P.maybe (P.Nothing) (\(_,_val4327) -> P.Just (case _val4327 of {T.TStruct _val4329 -> (to_TalkException (T.TStruct _val4329)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactRoom_result _ = P.error "not a struct"
read_GetCompactRoom_result :: T.Protocol p => p -> P.IO GetCompactRoom_result
read_GetCompactRoom_result iprot = to_GetCompactRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactRoom_result)
decode_GetCompactRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactRoom_result
decode_GetCompactRoom_result iprot bs = to_GetCompactRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactRoom_result) bs
typemap_GetCompactRoom_result :: T.TypeMap
typemap_GetCompactRoom_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactRoom_result :: GetCompactRoom_result
default_GetCompactRoom_result = GetCompactRoom_result{
  getCompactRoom_result_success = default_Room,
  getCompactRoom_result_e = P.Nothing}
data GetContact_args = GetContact_args  { getContact_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContact_args_id record  
instance QC.Arbitrary GetContact_args where 
  arbitrary = M.liftM GetContact_args (QC.arbitrary)
  shrink obj | obj == default_GetContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContact_args{getContact_args_id = getContact_args_id obj} then P.Nothing else P.Just $ default_GetContact_args{getContact_args_id = getContact_args_id obj}
    ]
from_GetContact_args :: GetContact_args -> T.ThriftVal
from_GetContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4332 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v4332))) $ getContact_args_id record
  ]
write_GetContact_args :: T.Protocol p => p -> GetContact_args -> P.IO ()
write_GetContact_args oprot record = T.writeVal oprot $ from_GetContact_args record
encode_GetContact_args :: T.StatelessProtocol p => p -> GetContact_args -> LBS.ByteString
encode_GetContact_args oprot record = T.serializeVal oprot $ from_GetContact_args record
to_GetContact_args :: T.ThriftVal -> GetContact_args
to_GetContact_args (T.TStruct fields) = GetContact_args{
  getContact_args_id = P.maybe (getContact_args_id default_GetContact_args) (\(_,_val4334) -> (case _val4334 of {T.TString _val4335 -> E.decodeUtf8 _val4335; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContact_args _ = P.error "not a struct"
read_GetContact_args :: T.Protocol p => p -> P.IO GetContact_args
read_GetContact_args iprot = to_GetContact_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContact_args)
decode_GetContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContact_args
decode_GetContact_args iprot bs = to_GetContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContact_args) bs
typemap_GetContact_args :: T.TypeMap
typemap_GetContact_args = Map.fromList [(2,("id",T.T_STRING))]
default_GetContact_args :: GetContact_args
default_GetContact_args = GetContact_args{
  getContact_args_id = ""}
data GetContact_result = GetContact_result  { getContact_result_success :: Contact
  , getContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContact_result_success record   `H.hashWithSalt` getContact_result_e record  
instance QC.Arbitrary GetContact_result where 
  arbitrary = M.liftM GetContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContact_result{getContact_result_success = getContact_result_success obj} then P.Nothing else P.Just $ default_GetContact_result{getContact_result_success = getContact_result_success obj}
    , if obj == default_GetContact_result{getContact_result_e = getContact_result_e obj} then P.Nothing else P.Just $ default_GetContact_result{getContact_result_e = getContact_result_e obj}
    ]
from_GetContact_result :: GetContact_result -> T.ThriftVal
from_GetContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4338 -> (1, ("e",from_TalkException _v4338))) <$> getContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4338 -> P.Just (0, ("success",from_Contact _v4338))) $ getContact_result_success record
    , (\_v4338 -> (1, ("e",from_TalkException _v4338))) <$> getContact_result_e record
    ]
    )
write_GetContact_result :: T.Protocol p => p -> GetContact_result -> P.IO ()
write_GetContact_result oprot record = T.writeVal oprot $ from_GetContact_result record
encode_GetContact_result :: T.StatelessProtocol p => p -> GetContact_result -> LBS.ByteString
encode_GetContact_result oprot record = T.serializeVal oprot $ from_GetContact_result record
to_GetContact_result :: T.ThriftVal -> GetContact_result
to_GetContact_result (T.TStruct fields) = GetContact_result{
  getContact_result_success = P.maybe (getContact_result_success default_GetContact_result) (\(_,_val4340) -> (case _val4340 of {T.TStruct _val4341 -> (to_Contact (T.TStruct _val4341)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContact_result_e = P.maybe (P.Nothing) (\(_,_val4340) -> P.Just (case _val4340 of {T.TStruct _val4342 -> (to_TalkException (T.TStruct _val4342)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContact_result _ = P.error "not a struct"
read_GetContact_result :: T.Protocol p => p -> P.IO GetContact_result
read_GetContact_result iprot = to_GetContact_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContact_result)
decode_GetContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContact_result
decode_GetContact_result iprot bs = to_GetContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContact_result) bs
typemap_GetContact_result :: T.TypeMap
typemap_GetContact_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContact_result :: GetContact_result
default_GetContact_result = GetContact_result{
  getContact_result_success = default_Contact,
  getContact_result_e = P.Nothing}
data GetContacts_args = GetContacts_args  { getContacts_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContacts_args_ids record  
instance QC.Arbitrary GetContacts_args where 
  arbitrary = M.liftM GetContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContacts_args{getContacts_args_ids = getContacts_args_ids obj} then P.Nothing else P.Just $ default_GetContacts_args{getContacts_args_ids = getContacts_args_ids obj}
    ]
from_GetContacts_args :: GetContacts_args -> T.ThriftVal
from_GetContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4345 -> P.Just (2, ("ids",T.TList T.T_STRING $ P.map (\_v4347 -> T.TString $ E.encodeUtf8 _v4347) $ Vector.toList _v4345))) $ getContacts_args_ids record
  ]
write_GetContacts_args :: T.Protocol p => p -> GetContacts_args -> P.IO ()
write_GetContacts_args oprot record = T.writeVal oprot $ from_GetContacts_args record
encode_GetContacts_args :: T.StatelessProtocol p => p -> GetContacts_args -> LBS.ByteString
encode_GetContacts_args oprot record = T.serializeVal oprot $ from_GetContacts_args record
to_GetContacts_args :: T.ThriftVal -> GetContacts_args
to_GetContacts_args (T.TStruct fields) = GetContacts_args{
  getContacts_args_ids = P.maybe (getContacts_args_ids default_GetContacts_args) (\(_,_val4349) -> (case _val4349 of {T.TList _ _val4350 -> (Vector.fromList $ P.map (\_v4351 -> (case _v4351 of {T.TString _val4352 -> E.decodeUtf8 _val4352; _ -> P.error "wrong type"})) _val4350); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContacts_args _ = P.error "not a struct"
read_GetContacts_args :: T.Protocol p => p -> P.IO GetContacts_args
read_GetContacts_args iprot = to_GetContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContacts_args)
decode_GetContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContacts_args
decode_GetContacts_args iprot bs = to_GetContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContacts_args) bs
typemap_GetContacts_args :: T.TypeMap
typemap_GetContacts_args = Map.fromList [(2,("ids",(T.T_LIST T.T_STRING)))]
default_GetContacts_args :: GetContacts_args
default_GetContacts_args = GetContacts_args{
  getContacts_args_ids = Vector.empty}
data GetContacts_result = GetContacts_result  { getContacts_result_success :: (Vector.Vector Contact)
  , getContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContacts_result_success record   `H.hashWithSalt` getContacts_result_e record  
instance QC.Arbitrary GetContacts_result where 
  arbitrary = M.liftM GetContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContacts_result{getContacts_result_success = getContacts_result_success obj} then P.Nothing else P.Just $ default_GetContacts_result{getContacts_result_success = getContacts_result_success obj}
    , if obj == default_GetContacts_result{getContacts_result_e = getContacts_result_e obj} then P.Nothing else P.Just $ default_GetContacts_result{getContacts_result_e = getContacts_result_e obj}
    ]
from_GetContacts_result :: GetContacts_result -> T.ThriftVal
from_GetContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4355 -> (1, ("e",from_TalkException _v4355))) <$> getContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4355 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v4357 -> from_Contact _v4357) $ Vector.toList _v4355))) $ getContacts_result_success record
    , (\_v4355 -> (1, ("e",from_TalkException _v4355))) <$> getContacts_result_e record
    ]
    )
write_GetContacts_result :: T.Protocol p => p -> GetContacts_result -> P.IO ()
write_GetContacts_result oprot record = T.writeVal oprot $ from_GetContacts_result record
encode_GetContacts_result :: T.StatelessProtocol p => p -> GetContacts_result -> LBS.ByteString
encode_GetContacts_result oprot record = T.serializeVal oprot $ from_GetContacts_result record
to_GetContacts_result :: T.ThriftVal -> GetContacts_result
to_GetContacts_result (T.TStruct fields) = GetContacts_result{
  getContacts_result_success = P.maybe (getContacts_result_success default_GetContacts_result) (\(_,_val4359) -> (case _val4359 of {T.TList _ _val4360 -> (Vector.fromList $ P.map (\_v4361 -> (case _v4361 of {T.TStruct _val4362 -> (to_Contact (T.TStruct _val4362)); _ -> P.error "wrong type"})) _val4360); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContacts_result_e = P.maybe (P.Nothing) (\(_,_val4359) -> P.Just (case _val4359 of {T.TStruct _val4363 -> (to_TalkException (T.TStruct _val4363)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContacts_result _ = P.error "not a struct"
read_GetContacts_result :: T.Protocol p => p -> P.IO GetContacts_result
read_GetContacts_result iprot = to_GetContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContacts_result)
decode_GetContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContacts_result
decode_GetContacts_result iprot bs = to_GetContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContacts_result) bs
typemap_GetContacts_result :: T.TypeMap
typemap_GetContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContacts_result :: GetContacts_result
default_GetContacts_result = GetContacts_result{
  getContacts_result_success = Vector.empty,
  getContacts_result_e = P.Nothing}
data GetCountryWithRequestIp_args = GetCountryWithRequestIp_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCountryWithRequestIp_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetCountryWithRequestIp_args where 
  arbitrary = QC.elements [GetCountryWithRequestIp_args]
from_GetCountryWithRequestIp_args :: GetCountryWithRequestIp_args -> T.ThriftVal
from_GetCountryWithRequestIp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetCountryWithRequestIp_args :: T.Protocol p => p -> GetCountryWithRequestIp_args -> P.IO ()
write_GetCountryWithRequestIp_args oprot record = T.writeVal oprot $ from_GetCountryWithRequestIp_args record
encode_GetCountryWithRequestIp_args :: T.StatelessProtocol p => p -> GetCountryWithRequestIp_args -> LBS.ByteString
encode_GetCountryWithRequestIp_args oprot record = T.serializeVal oprot $ from_GetCountryWithRequestIp_args record
to_GetCountryWithRequestIp_args :: T.ThriftVal -> GetCountryWithRequestIp_args
to_GetCountryWithRequestIp_args (T.TStruct fields) = GetCountryWithRequestIp_args{

  }
to_GetCountryWithRequestIp_args _ = P.error "not a struct"
read_GetCountryWithRequestIp_args :: T.Protocol p => p -> P.IO GetCountryWithRequestIp_args
read_GetCountryWithRequestIp_args iprot = to_GetCountryWithRequestIp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_args)
decode_GetCountryWithRequestIp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCountryWithRequestIp_args
decode_GetCountryWithRequestIp_args iprot bs = to_GetCountryWithRequestIp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_args) bs
typemap_GetCountryWithRequestIp_args :: T.TypeMap
typemap_GetCountryWithRequestIp_args = Map.fromList []
default_GetCountryWithRequestIp_args :: GetCountryWithRequestIp_args
default_GetCountryWithRequestIp_args = GetCountryWithRequestIp_args{
}
data GetCountryWithRequestIp_result = GetCountryWithRequestIp_result  { getCountryWithRequestIp_result_success :: LT.Text
  , getCountryWithRequestIp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCountryWithRequestIp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCountryWithRequestIp_result_success record   `H.hashWithSalt` getCountryWithRequestIp_result_e record  
instance QC.Arbitrary GetCountryWithRequestIp_result where 
  arbitrary = M.liftM GetCountryWithRequestIp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCountryWithRequestIp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_success = getCountryWithRequestIp_result_success obj} then P.Nothing else P.Just $ default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_success = getCountryWithRequestIp_result_success obj}
    , if obj == default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_e = getCountryWithRequestIp_result_e obj} then P.Nothing else P.Just $ default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_e = getCountryWithRequestIp_result_e obj}
    ]
from_GetCountryWithRequestIp_result :: GetCountryWithRequestIp_result -> T.ThriftVal
from_GetCountryWithRequestIp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4371 -> (1, ("e",from_TalkException _v4371))) <$> getCountryWithRequestIp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4371 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v4371))) $ getCountryWithRequestIp_result_success record
    , (\_v4371 -> (1, ("e",from_TalkException _v4371))) <$> getCountryWithRequestIp_result_e record
    ]
    )
write_GetCountryWithRequestIp_result :: T.Protocol p => p -> GetCountryWithRequestIp_result -> P.IO ()
write_GetCountryWithRequestIp_result oprot record = T.writeVal oprot $ from_GetCountryWithRequestIp_result record
encode_GetCountryWithRequestIp_result :: T.StatelessProtocol p => p -> GetCountryWithRequestIp_result -> LBS.ByteString
encode_GetCountryWithRequestIp_result oprot record = T.serializeVal oprot $ from_GetCountryWithRequestIp_result record
to_GetCountryWithRequestIp_result :: T.ThriftVal -> GetCountryWithRequestIp_result
to_GetCountryWithRequestIp_result (T.TStruct fields) = GetCountryWithRequestIp_result{
  getCountryWithRequestIp_result_success = P.maybe (getCountryWithRequestIp_result_success default_GetCountryWithRequestIp_result) (\(_,_val4373) -> (case _val4373 of {T.TString _val4374 -> E.decodeUtf8 _val4374; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCountryWithRequestIp_result_e = P.maybe (P.Nothing) (\(_,_val4373) -> P.Just (case _val4373 of {T.TStruct _val4375 -> (to_TalkException (T.TStruct _val4375)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCountryWithRequestIp_result _ = P.error "not a struct"
read_GetCountryWithRequestIp_result :: T.Protocol p => p -> P.IO GetCountryWithRequestIp_result
read_GetCountryWithRequestIp_result iprot = to_GetCountryWithRequestIp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_result)
decode_GetCountryWithRequestIp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCountryWithRequestIp_result
decode_GetCountryWithRequestIp_result iprot bs = to_GetCountryWithRequestIp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_result) bs
typemap_GetCountryWithRequestIp_result :: T.TypeMap
typemap_GetCountryWithRequestIp_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCountryWithRequestIp_result :: GetCountryWithRequestIp_result
default_GetCountryWithRequestIp_result = GetCountryWithRequestIp_result{
  getCountryWithRequestIp_result_success = "",
  getCountryWithRequestIp_result_e = P.Nothing}
data GetFavoriteMids_args = GetFavoriteMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteMids_args where 
  arbitrary = QC.elements [GetFavoriteMids_args]
from_GetFavoriteMids_args :: GetFavoriteMids_args -> T.ThriftVal
from_GetFavoriteMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteMids_args :: T.Protocol p => p -> GetFavoriteMids_args -> P.IO ()
write_GetFavoriteMids_args oprot record = T.writeVal oprot $ from_GetFavoriteMids_args record
encode_GetFavoriteMids_args :: T.StatelessProtocol p => p -> GetFavoriteMids_args -> LBS.ByteString
encode_GetFavoriteMids_args oprot record = T.serializeVal oprot $ from_GetFavoriteMids_args record
to_GetFavoriteMids_args :: T.ThriftVal -> GetFavoriteMids_args
to_GetFavoriteMids_args (T.TStruct fields) = GetFavoriteMids_args{

  }
to_GetFavoriteMids_args _ = P.error "not a struct"
read_GetFavoriteMids_args :: T.Protocol p => p -> P.IO GetFavoriteMids_args
read_GetFavoriteMids_args iprot = to_GetFavoriteMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMids_args)
decode_GetFavoriteMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMids_args
decode_GetFavoriteMids_args iprot bs = to_GetFavoriteMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMids_args) bs
typemap_GetFavoriteMids_args :: T.TypeMap
typemap_GetFavoriteMids_args = Map.fromList []
default_GetFavoriteMids_args :: GetFavoriteMids_args
default_GetFavoriteMids_args = GetFavoriteMids_args{
}
data GetFavoriteMids_result = GetFavoriteMids_result  { getFavoriteMids_result_success :: (Vector.Vector LT.Text)
  , getFavoriteMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteMids_result_success record   `H.hashWithSalt` getFavoriteMids_result_e record  
instance QC.Arbitrary GetFavoriteMids_result where 
  arbitrary = M.liftM GetFavoriteMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteMids_result{getFavoriteMids_result_success = getFavoriteMids_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteMids_result{getFavoriteMids_result_success = getFavoriteMids_result_success obj}
    , if obj == default_GetFavoriteMids_result{getFavoriteMids_result_e = getFavoriteMids_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteMids_result{getFavoriteMids_result_e = getFavoriteMids_result_e obj}
    ]
from_GetFavoriteMids_result :: GetFavoriteMids_result -> T.ThriftVal
from_GetFavoriteMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4383 -> (1, ("e",from_TalkException _v4383))) <$> getFavoriteMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4383 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4385 -> T.TString $ E.encodeUtf8 _v4385) $ Vector.toList _v4383))) $ getFavoriteMids_result_success record
    , (\_v4383 -> (1, ("e",from_TalkException _v4383))) <$> getFavoriteMids_result_e record
    ]
    )
write_GetFavoriteMids_result :: T.Protocol p => p -> GetFavoriteMids_result -> P.IO ()
write_GetFavoriteMids_result oprot record = T.writeVal oprot $ from_GetFavoriteMids_result record
encode_GetFavoriteMids_result :: T.StatelessProtocol p => p -> GetFavoriteMids_result -> LBS.ByteString
encode_GetFavoriteMids_result oprot record = T.serializeVal oprot $ from_GetFavoriteMids_result record
to_GetFavoriteMids_result :: T.ThriftVal -> GetFavoriteMids_result
to_GetFavoriteMids_result (T.TStruct fields) = GetFavoriteMids_result{
  getFavoriteMids_result_success = P.maybe (getFavoriteMids_result_success default_GetFavoriteMids_result) (\(_,_val4387) -> (case _val4387 of {T.TList _ _val4388 -> (Vector.fromList $ P.map (\_v4389 -> (case _v4389 of {T.TString _val4390 -> E.decodeUtf8 _val4390; _ -> P.error "wrong type"})) _val4388); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteMids_result_e = P.maybe (P.Nothing) (\(_,_val4387) -> P.Just (case _val4387 of {T.TStruct _val4391 -> (to_TalkException (T.TStruct _val4391)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteMids_result _ = P.error "not a struct"
read_GetFavoriteMids_result :: T.Protocol p => p -> P.IO GetFavoriteMids_result
read_GetFavoriteMids_result iprot = to_GetFavoriteMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMids_result)
decode_GetFavoriteMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMids_result
decode_GetFavoriteMids_result iprot bs = to_GetFavoriteMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMids_result) bs
typemap_GetFavoriteMids_result :: T.TypeMap
typemap_GetFavoriteMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteMids_result :: GetFavoriteMids_result
default_GetFavoriteMids_result = GetFavoriteMids_result{
  getFavoriteMids_result_success = Vector.empty,
  getFavoriteMids_result_e = P.Nothing}
data GetGroup_args = GetGroup_args  { getGroup_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroup_args_groupId record  
instance QC.Arbitrary GetGroup_args where 
  arbitrary = M.liftM GetGroup_args (QC.arbitrary)
  shrink obj | obj == default_GetGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroup_args{getGroup_args_groupId = getGroup_args_groupId obj} then P.Nothing else P.Just $ default_GetGroup_args{getGroup_args_groupId = getGroup_args_groupId obj}
    ]
from_GetGroup_args :: GetGroup_args -> T.ThriftVal
from_GetGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4394 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v4394))) $ getGroup_args_groupId record
  ]
write_GetGroup_args :: T.Protocol p => p -> GetGroup_args -> P.IO ()
write_GetGroup_args oprot record = T.writeVal oprot $ from_GetGroup_args record
encode_GetGroup_args :: T.StatelessProtocol p => p -> GetGroup_args -> LBS.ByteString
encode_GetGroup_args oprot record = T.serializeVal oprot $ from_GetGroup_args record
to_GetGroup_args :: T.ThriftVal -> GetGroup_args
to_GetGroup_args (T.TStruct fields) = GetGroup_args{
  getGroup_args_groupId = P.maybe (getGroup_args_groupId default_GetGroup_args) (\(_,_val4396) -> (case _val4396 of {T.TString _val4397 -> E.decodeUtf8 _val4397; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroup_args _ = P.error "not a struct"
read_GetGroup_args :: T.Protocol p => p -> P.IO GetGroup_args
read_GetGroup_args iprot = to_GetGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroup_args)
decode_GetGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroup_args
decode_GetGroup_args iprot bs = to_GetGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroup_args) bs
typemap_GetGroup_args :: T.TypeMap
typemap_GetGroup_args = Map.fromList [(2,("groupId",T.T_STRING))]
default_GetGroup_args :: GetGroup_args
default_GetGroup_args = GetGroup_args{
  getGroup_args_groupId = ""}
data GetGroup_result = GetGroup_result  { getGroup_result_success :: Group
  , getGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroup_result_success record   `H.hashWithSalt` getGroup_result_e record  
instance QC.Arbitrary GetGroup_result where 
  arbitrary = M.liftM GetGroup_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroup_result{getGroup_result_success = getGroup_result_success obj} then P.Nothing else P.Just $ default_GetGroup_result{getGroup_result_success = getGroup_result_success obj}
    , if obj == default_GetGroup_result{getGroup_result_e = getGroup_result_e obj} then P.Nothing else P.Just $ default_GetGroup_result{getGroup_result_e = getGroup_result_e obj}
    ]
from_GetGroup_result :: GetGroup_result -> T.ThriftVal
from_GetGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4400 -> (1, ("e",from_TalkException _v4400))) <$> getGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4400 -> P.Just (0, ("success",from_Group _v4400))) $ getGroup_result_success record
    , (\_v4400 -> (1, ("e",from_TalkException _v4400))) <$> getGroup_result_e record
    ]
    )
write_GetGroup_result :: T.Protocol p => p -> GetGroup_result -> P.IO ()
write_GetGroup_result oprot record = T.writeVal oprot $ from_GetGroup_result record
encode_GetGroup_result :: T.StatelessProtocol p => p -> GetGroup_result -> LBS.ByteString
encode_GetGroup_result oprot record = T.serializeVal oprot $ from_GetGroup_result record
to_GetGroup_result :: T.ThriftVal -> GetGroup_result
to_GetGroup_result (T.TStruct fields) = GetGroup_result{
  getGroup_result_success = P.maybe (getGroup_result_success default_GetGroup_result) (\(_,_val4402) -> (case _val4402 of {T.TStruct _val4403 -> (to_Group (T.TStruct _val4403)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroup_result_e = P.maybe (P.Nothing) (\(_,_val4402) -> P.Just (case _val4402 of {T.TStruct _val4404 -> (to_TalkException (T.TStruct _val4404)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroup_result _ = P.error "not a struct"
read_GetGroup_result :: T.Protocol p => p -> P.IO GetGroup_result
read_GetGroup_result iprot = to_GetGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroup_result)
decode_GetGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroup_result
decode_GetGroup_result iprot bs = to_GetGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroup_result) bs
typemap_GetGroup_result :: T.TypeMap
typemap_GetGroup_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroup_result :: GetGroup_result
default_GetGroup_result = GetGroup_result{
  getGroup_result_success = default_Group,
  getGroup_result_e = P.Nothing}
data GetGroupIdsInvited_args = GetGroupIdsInvited_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsInvited_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetGroupIdsInvited_args where 
  arbitrary = QC.elements [GetGroupIdsInvited_args]
from_GetGroupIdsInvited_args :: GetGroupIdsInvited_args -> T.ThriftVal
from_GetGroupIdsInvited_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetGroupIdsInvited_args :: T.Protocol p => p -> GetGroupIdsInvited_args -> P.IO ()
write_GetGroupIdsInvited_args oprot record = T.writeVal oprot $ from_GetGroupIdsInvited_args record
encode_GetGroupIdsInvited_args :: T.StatelessProtocol p => p -> GetGroupIdsInvited_args -> LBS.ByteString
encode_GetGroupIdsInvited_args oprot record = T.serializeVal oprot $ from_GetGroupIdsInvited_args record
to_GetGroupIdsInvited_args :: T.ThriftVal -> GetGroupIdsInvited_args
to_GetGroupIdsInvited_args (T.TStruct fields) = GetGroupIdsInvited_args{

  }
to_GetGroupIdsInvited_args _ = P.error "not a struct"
read_GetGroupIdsInvited_args :: T.Protocol p => p -> P.IO GetGroupIdsInvited_args
read_GetGroupIdsInvited_args iprot = to_GetGroupIdsInvited_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_args)
decode_GetGroupIdsInvited_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsInvited_args
decode_GetGroupIdsInvited_args iprot bs = to_GetGroupIdsInvited_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_args) bs
typemap_GetGroupIdsInvited_args :: T.TypeMap
typemap_GetGroupIdsInvited_args = Map.fromList []
default_GetGroupIdsInvited_args :: GetGroupIdsInvited_args
default_GetGroupIdsInvited_args = GetGroupIdsInvited_args{
}
data GetGroupIdsInvited_result = GetGroupIdsInvited_result  { getGroupIdsInvited_result_success :: (Vector.Vector LT.Text)
  , getGroupIdsInvited_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsInvited_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupIdsInvited_result_success record   `H.hashWithSalt` getGroupIdsInvited_result_e record  
instance QC.Arbitrary GetGroupIdsInvited_result where 
  arbitrary = M.liftM GetGroupIdsInvited_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupIdsInvited_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupIdsInvited_result{getGroupIdsInvited_result_success = getGroupIdsInvited_result_success obj} then P.Nothing else P.Just $ default_GetGroupIdsInvited_result{getGroupIdsInvited_result_success = getGroupIdsInvited_result_success obj}
    , if obj == default_GetGroupIdsInvited_result{getGroupIdsInvited_result_e = getGroupIdsInvited_result_e obj} then P.Nothing else P.Just $ default_GetGroupIdsInvited_result{getGroupIdsInvited_result_e = getGroupIdsInvited_result_e obj}
    ]
from_GetGroupIdsInvited_result :: GetGroupIdsInvited_result -> T.ThriftVal
from_GetGroupIdsInvited_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4412 -> (1, ("e",from_TalkException _v4412))) <$> getGroupIdsInvited_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4412 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4414 -> T.TString $ E.encodeUtf8 _v4414) $ Vector.toList _v4412))) $ getGroupIdsInvited_result_success record
    , (\_v4412 -> (1, ("e",from_TalkException _v4412))) <$> getGroupIdsInvited_result_e record
    ]
    )
write_GetGroupIdsInvited_result :: T.Protocol p => p -> GetGroupIdsInvited_result -> P.IO ()
write_GetGroupIdsInvited_result oprot record = T.writeVal oprot $ from_GetGroupIdsInvited_result record
encode_GetGroupIdsInvited_result :: T.StatelessProtocol p => p -> GetGroupIdsInvited_result -> LBS.ByteString
encode_GetGroupIdsInvited_result oprot record = T.serializeVal oprot $ from_GetGroupIdsInvited_result record
to_GetGroupIdsInvited_result :: T.ThriftVal -> GetGroupIdsInvited_result
to_GetGroupIdsInvited_result (T.TStruct fields) = GetGroupIdsInvited_result{
  getGroupIdsInvited_result_success = P.maybe (getGroupIdsInvited_result_success default_GetGroupIdsInvited_result) (\(_,_val4416) -> (case _val4416 of {T.TList _ _val4417 -> (Vector.fromList $ P.map (\_v4418 -> (case _v4418 of {T.TString _val4419 -> E.decodeUtf8 _val4419; _ -> P.error "wrong type"})) _val4417); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupIdsInvited_result_e = P.maybe (P.Nothing) (\(_,_val4416) -> P.Just (case _val4416 of {T.TStruct _val4420 -> (to_TalkException (T.TStruct _val4420)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupIdsInvited_result _ = P.error "not a struct"
read_GetGroupIdsInvited_result :: T.Protocol p => p -> P.IO GetGroupIdsInvited_result
read_GetGroupIdsInvited_result iprot = to_GetGroupIdsInvited_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_result)
decode_GetGroupIdsInvited_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsInvited_result
decode_GetGroupIdsInvited_result iprot bs = to_GetGroupIdsInvited_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_result) bs
typemap_GetGroupIdsInvited_result :: T.TypeMap
typemap_GetGroupIdsInvited_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupIdsInvited_result :: GetGroupIdsInvited_result
default_GetGroupIdsInvited_result = GetGroupIdsInvited_result{
  getGroupIdsInvited_result_success = Vector.empty,
  getGroupIdsInvited_result_e = P.Nothing}
data GetGroupIdsJoined_args = GetGroupIdsJoined_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsJoined_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetGroupIdsJoined_args where 
  arbitrary = QC.elements [GetGroupIdsJoined_args]
from_GetGroupIdsJoined_args :: GetGroupIdsJoined_args -> T.ThriftVal
from_GetGroupIdsJoined_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetGroupIdsJoined_args :: T.Protocol p => p -> GetGroupIdsJoined_args -> P.IO ()
write_GetGroupIdsJoined_args oprot record = T.writeVal oprot $ from_GetGroupIdsJoined_args record
encode_GetGroupIdsJoined_args :: T.StatelessProtocol p => p -> GetGroupIdsJoined_args -> LBS.ByteString
encode_GetGroupIdsJoined_args oprot record = T.serializeVal oprot $ from_GetGroupIdsJoined_args record
to_GetGroupIdsJoined_args :: T.ThriftVal -> GetGroupIdsJoined_args
to_GetGroupIdsJoined_args (T.TStruct fields) = GetGroupIdsJoined_args{

  }
to_GetGroupIdsJoined_args _ = P.error "not a struct"
read_GetGroupIdsJoined_args :: T.Protocol p => p -> P.IO GetGroupIdsJoined_args
read_GetGroupIdsJoined_args iprot = to_GetGroupIdsJoined_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_args)
decode_GetGroupIdsJoined_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsJoined_args
decode_GetGroupIdsJoined_args iprot bs = to_GetGroupIdsJoined_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_args) bs
typemap_GetGroupIdsJoined_args :: T.TypeMap
typemap_GetGroupIdsJoined_args = Map.fromList []
default_GetGroupIdsJoined_args :: GetGroupIdsJoined_args
default_GetGroupIdsJoined_args = GetGroupIdsJoined_args{
}
data GetGroupIdsJoined_result = GetGroupIdsJoined_result  { getGroupIdsJoined_result_success :: (Vector.Vector LT.Text)
  , getGroupIdsJoined_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsJoined_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupIdsJoined_result_success record   `H.hashWithSalt` getGroupIdsJoined_result_e record  
instance QC.Arbitrary GetGroupIdsJoined_result where 
  arbitrary = M.liftM GetGroupIdsJoined_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupIdsJoined_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupIdsJoined_result{getGroupIdsJoined_result_success = getGroupIdsJoined_result_success obj} then P.Nothing else P.Just $ default_GetGroupIdsJoined_result{getGroupIdsJoined_result_success = getGroupIdsJoined_result_success obj}
    , if obj == default_GetGroupIdsJoined_result{getGroupIdsJoined_result_e = getGroupIdsJoined_result_e obj} then P.Nothing else P.Just $ default_GetGroupIdsJoined_result{getGroupIdsJoined_result_e = getGroupIdsJoined_result_e obj}
    ]
from_GetGroupIdsJoined_result :: GetGroupIdsJoined_result -> T.ThriftVal
from_GetGroupIdsJoined_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4428 -> (1, ("e",from_TalkException _v4428))) <$> getGroupIdsJoined_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4428 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4430 -> T.TString $ E.encodeUtf8 _v4430) $ Vector.toList _v4428))) $ getGroupIdsJoined_result_success record
    , (\_v4428 -> (1, ("e",from_TalkException _v4428))) <$> getGroupIdsJoined_result_e record
    ]
    )
write_GetGroupIdsJoined_result :: T.Protocol p => p -> GetGroupIdsJoined_result -> P.IO ()
write_GetGroupIdsJoined_result oprot record = T.writeVal oprot $ from_GetGroupIdsJoined_result record
encode_GetGroupIdsJoined_result :: T.StatelessProtocol p => p -> GetGroupIdsJoined_result -> LBS.ByteString
encode_GetGroupIdsJoined_result oprot record = T.serializeVal oprot $ from_GetGroupIdsJoined_result record
to_GetGroupIdsJoined_result :: T.ThriftVal -> GetGroupIdsJoined_result
to_GetGroupIdsJoined_result (T.TStruct fields) = GetGroupIdsJoined_result{
  getGroupIdsJoined_result_success = P.maybe (getGroupIdsJoined_result_success default_GetGroupIdsJoined_result) (\(_,_val4432) -> (case _val4432 of {T.TList _ _val4433 -> (Vector.fromList $ P.map (\_v4434 -> (case _v4434 of {T.TString _val4435 -> E.decodeUtf8 _val4435; _ -> P.error "wrong type"})) _val4433); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupIdsJoined_result_e = P.maybe (P.Nothing) (\(_,_val4432) -> P.Just (case _val4432 of {T.TStruct _val4436 -> (to_TalkException (T.TStruct _val4436)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupIdsJoined_result _ = P.error "not a struct"
read_GetGroupIdsJoined_result :: T.Protocol p => p -> P.IO GetGroupIdsJoined_result
read_GetGroupIdsJoined_result iprot = to_GetGroupIdsJoined_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_result)
decode_GetGroupIdsJoined_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsJoined_result
decode_GetGroupIdsJoined_result iprot bs = to_GetGroupIdsJoined_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_result) bs
typemap_GetGroupIdsJoined_result :: T.TypeMap
typemap_GetGroupIdsJoined_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupIdsJoined_result :: GetGroupIdsJoined_result
default_GetGroupIdsJoined_result = GetGroupIdsJoined_result{
  getGroupIdsJoined_result_success = Vector.empty,
  getGroupIdsJoined_result_e = P.Nothing}
data GetGroups_args = GetGroups_args  { getGroups_args_groupIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroups_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroups_args_groupIds record  
instance QC.Arbitrary GetGroups_args where 
  arbitrary = M.liftM GetGroups_args (QC.arbitrary)
  shrink obj | obj == default_GetGroups_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroups_args{getGroups_args_groupIds = getGroups_args_groupIds obj} then P.Nothing else P.Just $ default_GetGroups_args{getGroups_args_groupIds = getGroups_args_groupIds obj}
    ]
from_GetGroups_args :: GetGroups_args -> T.ThriftVal
from_GetGroups_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4439 -> P.Just (2, ("groupIds",T.TList T.T_STRING $ P.map (\_v4441 -> T.TString $ E.encodeUtf8 _v4441) $ Vector.toList _v4439))) $ getGroups_args_groupIds record
  ]
write_GetGroups_args :: T.Protocol p => p -> GetGroups_args -> P.IO ()
write_GetGroups_args oprot record = T.writeVal oprot $ from_GetGroups_args record
encode_GetGroups_args :: T.StatelessProtocol p => p -> GetGroups_args -> LBS.ByteString
encode_GetGroups_args oprot record = T.serializeVal oprot $ from_GetGroups_args record
to_GetGroups_args :: T.ThriftVal -> GetGroups_args
to_GetGroups_args (T.TStruct fields) = GetGroups_args{
  getGroups_args_groupIds = P.maybe (getGroups_args_groupIds default_GetGroups_args) (\(_,_val4443) -> (case _val4443 of {T.TList _ _val4444 -> (Vector.fromList $ P.map (\_v4445 -> (case _v4445 of {T.TString _val4446 -> E.decodeUtf8 _val4446; _ -> P.error "wrong type"})) _val4444); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroups_args _ = P.error "not a struct"
read_GetGroups_args :: T.Protocol p => p -> P.IO GetGroups_args
read_GetGroups_args iprot = to_GetGroups_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroups_args)
decode_GetGroups_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroups_args
decode_GetGroups_args iprot bs = to_GetGroups_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroups_args) bs
typemap_GetGroups_args :: T.TypeMap
typemap_GetGroups_args = Map.fromList [(2,("groupIds",(T.T_LIST T.T_STRING)))]
default_GetGroups_args :: GetGroups_args
default_GetGroups_args = GetGroups_args{
  getGroups_args_groupIds = Vector.empty}
data GetGroups_result = GetGroups_result  { getGroups_result_success :: (Vector.Vector Group)
  , getGroups_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroups_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroups_result_success record   `H.hashWithSalt` getGroups_result_e record  
instance QC.Arbitrary GetGroups_result where 
  arbitrary = M.liftM GetGroups_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroups_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroups_result{getGroups_result_success = getGroups_result_success obj} then P.Nothing else P.Just $ default_GetGroups_result{getGroups_result_success = getGroups_result_success obj}
    , if obj == default_GetGroups_result{getGroups_result_e = getGroups_result_e obj} then P.Nothing else P.Just $ default_GetGroups_result{getGroups_result_e = getGroups_result_e obj}
    ]
from_GetGroups_result :: GetGroups_result -> T.ThriftVal
from_GetGroups_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4449 -> (1, ("e",from_TalkException _v4449))) <$> getGroups_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4449 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v4451 -> from_Group _v4451) $ Vector.toList _v4449))) $ getGroups_result_success record
    , (\_v4449 -> (1, ("e",from_TalkException _v4449))) <$> getGroups_result_e record
    ]
    )
write_GetGroups_result :: T.Protocol p => p -> GetGroups_result -> P.IO ()
write_GetGroups_result oprot record = T.writeVal oprot $ from_GetGroups_result record
encode_GetGroups_result :: T.StatelessProtocol p => p -> GetGroups_result -> LBS.ByteString
encode_GetGroups_result oprot record = T.serializeVal oprot $ from_GetGroups_result record
to_GetGroups_result :: T.ThriftVal -> GetGroups_result
to_GetGroups_result (T.TStruct fields) = GetGroups_result{
  getGroups_result_success = P.maybe (getGroups_result_success default_GetGroups_result) (\(_,_val4453) -> (case _val4453 of {T.TList _ _val4454 -> (Vector.fromList $ P.map (\_v4455 -> (case _v4455 of {T.TStruct _val4456 -> (to_Group (T.TStruct _val4456)); _ -> P.error "wrong type"})) _val4454); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroups_result_e = P.maybe (P.Nothing) (\(_,_val4453) -> P.Just (case _val4453 of {T.TStruct _val4457 -> (to_TalkException (T.TStruct _val4457)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroups_result _ = P.error "not a struct"
read_GetGroups_result :: T.Protocol p => p -> P.IO GetGroups_result
read_GetGroups_result iprot = to_GetGroups_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroups_result)
decode_GetGroups_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroups_result
decode_GetGroups_result iprot bs = to_GetGroups_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroups_result) bs
typemap_GetGroups_result :: T.TypeMap
typemap_GetGroups_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Group)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroups_result :: GetGroups_result
default_GetGroups_result = GetGroups_result{
  getGroups_result_success = Vector.empty,
  getGroups_result_e = P.Nothing}
data GetHiddenContactMids_args = GetHiddenContactMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetHiddenContactMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetHiddenContactMids_args where 
  arbitrary = QC.elements [GetHiddenContactMids_args]
from_GetHiddenContactMids_args :: GetHiddenContactMids_args -> T.ThriftVal
from_GetHiddenContactMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetHiddenContactMids_args :: T.Protocol p => p -> GetHiddenContactMids_args -> P.IO ()
write_GetHiddenContactMids_args oprot record = T.writeVal oprot $ from_GetHiddenContactMids_args record
encode_GetHiddenContactMids_args :: T.StatelessProtocol p => p -> GetHiddenContactMids_args -> LBS.ByteString
encode_GetHiddenContactMids_args oprot record = T.serializeVal oprot $ from_GetHiddenContactMids_args record
to_GetHiddenContactMids_args :: T.ThriftVal -> GetHiddenContactMids_args
to_GetHiddenContactMids_args (T.TStruct fields) = GetHiddenContactMids_args{

  }
to_GetHiddenContactMids_args _ = P.error "not a struct"
read_GetHiddenContactMids_args :: T.Protocol p => p -> P.IO GetHiddenContactMids_args
read_GetHiddenContactMids_args iprot = to_GetHiddenContactMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_args)
decode_GetHiddenContactMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetHiddenContactMids_args
decode_GetHiddenContactMids_args iprot bs = to_GetHiddenContactMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_args) bs
typemap_GetHiddenContactMids_args :: T.TypeMap
typemap_GetHiddenContactMids_args = Map.fromList []
default_GetHiddenContactMids_args :: GetHiddenContactMids_args
default_GetHiddenContactMids_args = GetHiddenContactMids_args{
}
data GetHiddenContactMids_result = GetHiddenContactMids_result  { getHiddenContactMids_result_success :: (Vector.Vector LT.Text)
  , getHiddenContactMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetHiddenContactMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getHiddenContactMids_result_success record   `H.hashWithSalt` getHiddenContactMids_result_e record  
instance QC.Arbitrary GetHiddenContactMids_result where 
  arbitrary = M.liftM GetHiddenContactMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetHiddenContactMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetHiddenContactMids_result{getHiddenContactMids_result_success = getHiddenContactMids_result_success obj} then P.Nothing else P.Just $ default_GetHiddenContactMids_result{getHiddenContactMids_result_success = getHiddenContactMids_result_success obj}
    , if obj == default_GetHiddenContactMids_result{getHiddenContactMids_result_e = getHiddenContactMids_result_e obj} then P.Nothing else P.Just $ default_GetHiddenContactMids_result{getHiddenContactMids_result_e = getHiddenContactMids_result_e obj}
    ]
from_GetHiddenContactMids_result :: GetHiddenContactMids_result -> T.ThriftVal
from_GetHiddenContactMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4465 -> (1, ("e",from_TalkException _v4465))) <$> getHiddenContactMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4465 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4467 -> T.TString $ E.encodeUtf8 _v4467) $ Vector.toList _v4465))) $ getHiddenContactMids_result_success record
    , (\_v4465 -> (1, ("e",from_TalkException _v4465))) <$> getHiddenContactMids_result_e record
    ]
    )
write_GetHiddenContactMids_result :: T.Protocol p => p -> GetHiddenContactMids_result -> P.IO ()
write_GetHiddenContactMids_result oprot record = T.writeVal oprot $ from_GetHiddenContactMids_result record
encode_GetHiddenContactMids_result :: T.StatelessProtocol p => p -> GetHiddenContactMids_result -> LBS.ByteString
encode_GetHiddenContactMids_result oprot record = T.serializeVal oprot $ from_GetHiddenContactMids_result record
to_GetHiddenContactMids_result :: T.ThriftVal -> GetHiddenContactMids_result
to_GetHiddenContactMids_result (T.TStruct fields) = GetHiddenContactMids_result{
  getHiddenContactMids_result_success = P.maybe (getHiddenContactMids_result_success default_GetHiddenContactMids_result) (\(_,_val4469) -> (case _val4469 of {T.TList _ _val4470 -> (Vector.fromList $ P.map (\_v4471 -> (case _v4471 of {T.TString _val4472 -> E.decodeUtf8 _val4472; _ -> P.error "wrong type"})) _val4470); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getHiddenContactMids_result_e = P.maybe (P.Nothing) (\(_,_val4469) -> P.Just (case _val4469 of {T.TStruct _val4473 -> (to_TalkException (T.TStruct _val4473)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetHiddenContactMids_result _ = P.error "not a struct"
read_GetHiddenContactMids_result :: T.Protocol p => p -> P.IO GetHiddenContactMids_result
read_GetHiddenContactMids_result iprot = to_GetHiddenContactMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_result)
decode_GetHiddenContactMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetHiddenContactMids_result
decode_GetHiddenContactMids_result iprot bs = to_GetHiddenContactMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_result) bs
typemap_GetHiddenContactMids_result :: T.TypeMap
typemap_GetHiddenContactMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetHiddenContactMids_result :: GetHiddenContactMids_result
default_GetHiddenContactMids_result = GetHiddenContactMids_result{
  getHiddenContactMids_result_success = Vector.empty,
  getHiddenContactMids_result_e = P.Nothing}
data GetIdentityIdentifier_args = GetIdentityIdentifier_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityIdentifier_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetIdentityIdentifier_args where 
  arbitrary = QC.elements [GetIdentityIdentifier_args]
from_GetIdentityIdentifier_args :: GetIdentityIdentifier_args -> T.ThriftVal
from_GetIdentityIdentifier_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetIdentityIdentifier_args :: T.Protocol p => p -> GetIdentityIdentifier_args -> P.IO ()
write_GetIdentityIdentifier_args oprot record = T.writeVal oprot $ from_GetIdentityIdentifier_args record
encode_GetIdentityIdentifier_args :: T.StatelessProtocol p => p -> GetIdentityIdentifier_args -> LBS.ByteString
encode_GetIdentityIdentifier_args oprot record = T.serializeVal oprot $ from_GetIdentityIdentifier_args record
to_GetIdentityIdentifier_args :: T.ThriftVal -> GetIdentityIdentifier_args
to_GetIdentityIdentifier_args (T.TStruct fields) = GetIdentityIdentifier_args{

  }
to_GetIdentityIdentifier_args _ = P.error "not a struct"
read_GetIdentityIdentifier_args :: T.Protocol p => p -> P.IO GetIdentityIdentifier_args
read_GetIdentityIdentifier_args iprot = to_GetIdentityIdentifier_args <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_args)
decode_GetIdentityIdentifier_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityIdentifier_args
decode_GetIdentityIdentifier_args iprot bs = to_GetIdentityIdentifier_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_args) bs
typemap_GetIdentityIdentifier_args :: T.TypeMap
typemap_GetIdentityIdentifier_args = Map.fromList []
default_GetIdentityIdentifier_args :: GetIdentityIdentifier_args
default_GetIdentityIdentifier_args = GetIdentityIdentifier_args{
}
data GetIdentityIdentifier_result = GetIdentityIdentifier_result  { getIdentityIdentifier_result_success :: LT.Text
  , getIdentityIdentifier_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityIdentifier_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getIdentityIdentifier_result_success record   `H.hashWithSalt` getIdentityIdentifier_result_e record  
instance QC.Arbitrary GetIdentityIdentifier_result where 
  arbitrary = M.liftM GetIdentityIdentifier_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetIdentityIdentifier_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetIdentityIdentifier_result{getIdentityIdentifier_result_success = getIdentityIdentifier_result_success obj} then P.Nothing else P.Just $ default_GetIdentityIdentifier_result{getIdentityIdentifier_result_success = getIdentityIdentifier_result_success obj}
    , if obj == default_GetIdentityIdentifier_result{getIdentityIdentifier_result_e = getIdentityIdentifier_result_e obj} then P.Nothing else P.Just $ default_GetIdentityIdentifier_result{getIdentityIdentifier_result_e = getIdentityIdentifier_result_e obj}
    ]
from_GetIdentityIdentifier_result :: GetIdentityIdentifier_result -> T.ThriftVal
from_GetIdentityIdentifier_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4481 -> (1, ("e",from_TalkException _v4481))) <$> getIdentityIdentifier_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4481 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v4481))) $ getIdentityIdentifier_result_success record
    , (\_v4481 -> (1, ("e",from_TalkException _v4481))) <$> getIdentityIdentifier_result_e record
    ]
    )
write_GetIdentityIdentifier_result :: T.Protocol p => p -> GetIdentityIdentifier_result -> P.IO ()
write_GetIdentityIdentifier_result oprot record = T.writeVal oprot $ from_GetIdentityIdentifier_result record
encode_GetIdentityIdentifier_result :: T.StatelessProtocol p => p -> GetIdentityIdentifier_result -> LBS.ByteString
encode_GetIdentityIdentifier_result oprot record = T.serializeVal oprot $ from_GetIdentityIdentifier_result record
to_GetIdentityIdentifier_result :: T.ThriftVal -> GetIdentityIdentifier_result
to_GetIdentityIdentifier_result (T.TStruct fields) = GetIdentityIdentifier_result{
  getIdentityIdentifier_result_success = P.maybe (getIdentityIdentifier_result_success default_GetIdentityIdentifier_result) (\(_,_val4483) -> (case _val4483 of {T.TString _val4484 -> E.decodeUtf8 _val4484; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getIdentityIdentifier_result_e = P.maybe (P.Nothing) (\(_,_val4483) -> P.Just (case _val4483 of {T.TStruct _val4485 -> (to_TalkException (T.TStruct _val4485)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetIdentityIdentifier_result _ = P.error "not a struct"
read_GetIdentityIdentifier_result :: T.Protocol p => p -> P.IO GetIdentityIdentifier_result
read_GetIdentityIdentifier_result iprot = to_GetIdentityIdentifier_result <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_result)
decode_GetIdentityIdentifier_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityIdentifier_result
decode_GetIdentityIdentifier_result iprot bs = to_GetIdentityIdentifier_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_result) bs
typemap_GetIdentityIdentifier_result :: T.TypeMap
typemap_GetIdentityIdentifier_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetIdentityIdentifier_result :: GetIdentityIdentifier_result
default_GetIdentityIdentifier_result = GetIdentityIdentifier_result{
  getIdentityIdentifier_result_success = "",
  getIdentityIdentifier_result_e = P.Nothing}
data GetLastAnnouncementIndex_args = GetLastAnnouncementIndex_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastAnnouncementIndex_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetLastAnnouncementIndex_args where 
  arbitrary = QC.elements [GetLastAnnouncementIndex_args]
from_GetLastAnnouncementIndex_args :: GetLastAnnouncementIndex_args -> T.ThriftVal
from_GetLastAnnouncementIndex_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetLastAnnouncementIndex_args :: T.Protocol p => p -> GetLastAnnouncementIndex_args -> P.IO ()
write_GetLastAnnouncementIndex_args oprot record = T.writeVal oprot $ from_GetLastAnnouncementIndex_args record
encode_GetLastAnnouncementIndex_args :: T.StatelessProtocol p => p -> GetLastAnnouncementIndex_args -> LBS.ByteString
encode_GetLastAnnouncementIndex_args oprot record = T.serializeVal oprot $ from_GetLastAnnouncementIndex_args record
to_GetLastAnnouncementIndex_args :: T.ThriftVal -> GetLastAnnouncementIndex_args
to_GetLastAnnouncementIndex_args (T.TStruct fields) = GetLastAnnouncementIndex_args{

  }
to_GetLastAnnouncementIndex_args _ = P.error "not a struct"
read_GetLastAnnouncementIndex_args :: T.Protocol p => p -> P.IO GetLastAnnouncementIndex_args
read_GetLastAnnouncementIndex_args iprot = to_GetLastAnnouncementIndex_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_args)
decode_GetLastAnnouncementIndex_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastAnnouncementIndex_args
decode_GetLastAnnouncementIndex_args iprot bs = to_GetLastAnnouncementIndex_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_args) bs
typemap_GetLastAnnouncementIndex_args :: T.TypeMap
typemap_GetLastAnnouncementIndex_args = Map.fromList []
default_GetLastAnnouncementIndex_args :: GetLastAnnouncementIndex_args
default_GetLastAnnouncementIndex_args = GetLastAnnouncementIndex_args{
}
data GetLastAnnouncementIndex_result = GetLastAnnouncementIndex_result  { getLastAnnouncementIndex_result_success :: I.Int32
  , getLastAnnouncementIndex_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastAnnouncementIndex_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastAnnouncementIndex_result_success record   `H.hashWithSalt` getLastAnnouncementIndex_result_e record  
instance QC.Arbitrary GetLastAnnouncementIndex_result where 
  arbitrary = M.liftM GetLastAnnouncementIndex_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLastAnnouncementIndex_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_success = getLastAnnouncementIndex_result_success obj} then P.Nothing else P.Just $ default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_success = getLastAnnouncementIndex_result_success obj}
    , if obj == default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_e = getLastAnnouncementIndex_result_e obj} then P.Nothing else P.Just $ default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_e = getLastAnnouncementIndex_result_e obj}
    ]
from_GetLastAnnouncementIndex_result :: GetLastAnnouncementIndex_result -> T.ThriftVal
from_GetLastAnnouncementIndex_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4493 -> (1, ("e",from_TalkException _v4493))) <$> getLastAnnouncementIndex_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4493 -> P.Just (0, ("success",T.TI32 _v4493))) $ getLastAnnouncementIndex_result_success record
    , (\_v4493 -> (1, ("e",from_TalkException _v4493))) <$> getLastAnnouncementIndex_result_e record
    ]
    )
write_GetLastAnnouncementIndex_result :: T.Protocol p => p -> GetLastAnnouncementIndex_result -> P.IO ()
write_GetLastAnnouncementIndex_result oprot record = T.writeVal oprot $ from_GetLastAnnouncementIndex_result record
encode_GetLastAnnouncementIndex_result :: T.StatelessProtocol p => p -> GetLastAnnouncementIndex_result -> LBS.ByteString
encode_GetLastAnnouncementIndex_result oprot record = T.serializeVal oprot $ from_GetLastAnnouncementIndex_result record
to_GetLastAnnouncementIndex_result :: T.ThriftVal -> GetLastAnnouncementIndex_result
to_GetLastAnnouncementIndex_result (T.TStruct fields) = GetLastAnnouncementIndex_result{
  getLastAnnouncementIndex_result_success = P.maybe (getLastAnnouncementIndex_result_success default_GetLastAnnouncementIndex_result) (\(_,_val4495) -> (case _val4495 of {T.TI32 _val4496 -> _val4496; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLastAnnouncementIndex_result_e = P.maybe (P.Nothing) (\(_,_val4495) -> P.Just (case _val4495 of {T.TStruct _val4497 -> (to_TalkException (T.TStruct _val4497)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLastAnnouncementIndex_result _ = P.error "not a struct"
read_GetLastAnnouncementIndex_result :: T.Protocol p => p -> P.IO GetLastAnnouncementIndex_result
read_GetLastAnnouncementIndex_result iprot = to_GetLastAnnouncementIndex_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_result)
decode_GetLastAnnouncementIndex_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastAnnouncementIndex_result
decode_GetLastAnnouncementIndex_result iprot bs = to_GetLastAnnouncementIndex_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_result) bs
typemap_GetLastAnnouncementIndex_result :: T.TypeMap
typemap_GetLastAnnouncementIndex_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetLastAnnouncementIndex_result :: GetLastAnnouncementIndex_result
default_GetLastAnnouncementIndex_result = GetLastAnnouncementIndex_result{
  getLastAnnouncementIndex_result_success = 0,
  getLastAnnouncementIndex_result_e = P.Nothing}
data GetLastOpRevision_args = GetLastOpRevision_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastOpRevision_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetLastOpRevision_args where 
  arbitrary = QC.elements [GetLastOpRevision_args]
from_GetLastOpRevision_args :: GetLastOpRevision_args -> T.ThriftVal
from_GetLastOpRevision_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetLastOpRevision_args :: T.Protocol p => p -> GetLastOpRevision_args -> P.IO ()
write_GetLastOpRevision_args oprot record = T.writeVal oprot $ from_GetLastOpRevision_args record
encode_GetLastOpRevision_args :: T.StatelessProtocol p => p -> GetLastOpRevision_args -> LBS.ByteString
encode_GetLastOpRevision_args oprot record = T.serializeVal oprot $ from_GetLastOpRevision_args record
to_GetLastOpRevision_args :: T.ThriftVal -> GetLastOpRevision_args
to_GetLastOpRevision_args (T.TStruct fields) = GetLastOpRevision_args{

  }
to_GetLastOpRevision_args _ = P.error "not a struct"
read_GetLastOpRevision_args :: T.Protocol p => p -> P.IO GetLastOpRevision_args
read_GetLastOpRevision_args iprot = to_GetLastOpRevision_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLastOpRevision_args)
decode_GetLastOpRevision_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastOpRevision_args
decode_GetLastOpRevision_args iprot bs = to_GetLastOpRevision_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastOpRevision_args) bs
typemap_GetLastOpRevision_args :: T.TypeMap
typemap_GetLastOpRevision_args = Map.fromList []
default_GetLastOpRevision_args :: GetLastOpRevision_args
default_GetLastOpRevision_args = GetLastOpRevision_args{
}
data GetLastOpRevision_result = GetLastOpRevision_result  { getLastOpRevision_result_success :: I.Int64
  , getLastOpRevision_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastOpRevision_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastOpRevision_result_success record   `H.hashWithSalt` getLastOpRevision_result_e record  
instance QC.Arbitrary GetLastOpRevision_result where 
  arbitrary = M.liftM GetLastOpRevision_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLastOpRevision_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastOpRevision_result{getLastOpRevision_result_success = getLastOpRevision_result_success obj} then P.Nothing else P.Just $ default_GetLastOpRevision_result{getLastOpRevision_result_success = getLastOpRevision_result_success obj}
    , if obj == default_GetLastOpRevision_result{getLastOpRevision_result_e = getLastOpRevision_result_e obj} then P.Nothing else P.Just $ default_GetLastOpRevision_result{getLastOpRevision_result_e = getLastOpRevision_result_e obj}
    ]
from_GetLastOpRevision_result :: GetLastOpRevision_result -> T.ThriftVal
from_GetLastOpRevision_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4505 -> (1, ("e",from_TalkException _v4505))) <$> getLastOpRevision_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4505 -> P.Just (0, ("success",T.TI64 _v4505))) $ getLastOpRevision_result_success record
    , (\_v4505 -> (1, ("e",from_TalkException _v4505))) <$> getLastOpRevision_result_e record
    ]
    )
write_GetLastOpRevision_result :: T.Protocol p => p -> GetLastOpRevision_result -> P.IO ()
write_GetLastOpRevision_result oprot record = T.writeVal oprot $ from_GetLastOpRevision_result record
encode_GetLastOpRevision_result :: T.StatelessProtocol p => p -> GetLastOpRevision_result -> LBS.ByteString
encode_GetLastOpRevision_result oprot record = T.serializeVal oprot $ from_GetLastOpRevision_result record
to_GetLastOpRevision_result :: T.ThriftVal -> GetLastOpRevision_result
to_GetLastOpRevision_result (T.TStruct fields) = GetLastOpRevision_result{
  getLastOpRevision_result_success = P.maybe (getLastOpRevision_result_success default_GetLastOpRevision_result) (\(_,_val4507) -> (case _val4507 of {T.TI64 _val4508 -> _val4508; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLastOpRevision_result_e = P.maybe (P.Nothing) (\(_,_val4507) -> P.Just (case _val4507 of {T.TStruct _val4509 -> (to_TalkException (T.TStruct _val4509)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLastOpRevision_result _ = P.error "not a struct"
read_GetLastOpRevision_result :: T.Protocol p => p -> P.IO GetLastOpRevision_result
read_GetLastOpRevision_result iprot = to_GetLastOpRevision_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLastOpRevision_result)
decode_GetLastOpRevision_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastOpRevision_result
decode_GetLastOpRevision_result iprot bs = to_GetLastOpRevision_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastOpRevision_result) bs
typemap_GetLastOpRevision_result :: T.TypeMap
typemap_GetLastOpRevision_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetLastOpRevision_result :: GetLastOpRevision_result
default_GetLastOpRevision_result = GetLastOpRevision_result{
  getLastOpRevision_result_success = 0,
  getLastOpRevision_result_e = P.Nothing}
data GetMessageBox_args = GetMessageBox_args  { getMessageBox_args_channelId :: LT.Text
  , getMessageBox_args_messageBoxId :: LT.Text
  , getMessageBox_args_lastMessagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBox_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBox_args_channelId record   `H.hashWithSalt` getMessageBox_args_messageBoxId record   `H.hashWithSalt` getMessageBox_args_lastMessagesCount record  
instance QC.Arbitrary GetMessageBox_args where 
  arbitrary = M.liftM GetMessageBox_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBox_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBox_args{getMessageBox_args_channelId = getMessageBox_args_channelId obj} then P.Nothing else P.Just $ default_GetMessageBox_args{getMessageBox_args_channelId = getMessageBox_args_channelId obj}
    , if obj == default_GetMessageBox_args{getMessageBox_args_messageBoxId = getMessageBox_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetMessageBox_args{getMessageBox_args_messageBoxId = getMessageBox_args_messageBoxId obj}
    , if obj == default_GetMessageBox_args{getMessageBox_args_lastMessagesCount = getMessageBox_args_lastMessagesCount obj} then P.Nothing else P.Just $ default_GetMessageBox_args{getMessageBox_args_lastMessagesCount = getMessageBox_args_lastMessagesCount obj}
    ]
from_GetMessageBox_args :: GetMessageBox_args -> T.ThriftVal
from_GetMessageBox_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4512 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v4512))) $ getMessageBox_args_channelId record
  , (\_v4512 -> P.Just (3, ("messageBoxId",T.TString $ E.encodeUtf8 _v4512))) $ getMessageBox_args_messageBoxId record
  , (\_v4512 -> P.Just (4, ("lastMessagesCount",T.TI32 _v4512))) $ getMessageBox_args_lastMessagesCount record
  ]
write_GetMessageBox_args :: T.Protocol p => p -> GetMessageBox_args -> P.IO ()
write_GetMessageBox_args oprot record = T.writeVal oprot $ from_GetMessageBox_args record
encode_GetMessageBox_args :: T.StatelessProtocol p => p -> GetMessageBox_args -> LBS.ByteString
encode_GetMessageBox_args oprot record = T.serializeVal oprot $ from_GetMessageBox_args record
to_GetMessageBox_args :: T.ThriftVal -> GetMessageBox_args
to_GetMessageBox_args (T.TStruct fields) = GetMessageBox_args{
  getMessageBox_args_channelId = P.maybe (getMessageBox_args_channelId default_GetMessageBox_args) (\(_,_val4514) -> (case _val4514 of {T.TString _val4515 -> E.decodeUtf8 _val4515; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBox_args_messageBoxId = P.maybe (getMessageBox_args_messageBoxId default_GetMessageBox_args) (\(_,_val4514) -> (case _val4514 of {T.TString _val4516 -> E.decodeUtf8 _val4516; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getMessageBox_args_lastMessagesCount = P.maybe (getMessageBox_args_lastMessagesCount default_GetMessageBox_args) (\(_,_val4514) -> (case _val4514 of {T.TI32 _val4517 -> _val4517; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetMessageBox_args _ = P.error "not a struct"
read_GetMessageBox_args :: T.Protocol p => p -> P.IO GetMessageBox_args
read_GetMessageBox_args iprot = to_GetMessageBox_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBox_args)
decode_GetMessageBox_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBox_args
decode_GetMessageBox_args iprot bs = to_GetMessageBox_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBox_args) bs
typemap_GetMessageBox_args :: T.TypeMap
typemap_GetMessageBox_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("messageBoxId",T.T_STRING)),(4,("lastMessagesCount",T.T_I32))]
default_GetMessageBox_args :: GetMessageBox_args
default_GetMessageBox_args = GetMessageBox_args{
  getMessageBox_args_channelId = "",
  getMessageBox_args_messageBoxId = "",
  getMessageBox_args_lastMessagesCount = 0}
data GetMessageBox_result = GetMessageBox_result  { getMessageBox_result_success :: TMessageBox
  , getMessageBox_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBox_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBox_result_success record   `H.hashWithSalt` getMessageBox_result_e record  
instance QC.Arbitrary GetMessageBox_result where 
  arbitrary = M.liftM GetMessageBox_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBox_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBox_result{getMessageBox_result_success = getMessageBox_result_success obj} then P.Nothing else P.Just $ default_GetMessageBox_result{getMessageBox_result_success = getMessageBox_result_success obj}
    , if obj == default_GetMessageBox_result{getMessageBox_result_e = getMessageBox_result_e obj} then P.Nothing else P.Just $ default_GetMessageBox_result{getMessageBox_result_e = getMessageBox_result_e obj}
    ]
from_GetMessageBox_result :: GetMessageBox_result -> T.ThriftVal
from_GetMessageBox_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4520 -> (1, ("e",from_TalkException _v4520))) <$> getMessageBox_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4520 -> P.Just (0, ("success",from_TMessageBox _v4520))) $ getMessageBox_result_success record
    , (\_v4520 -> (1, ("e",from_TalkException _v4520))) <$> getMessageBox_result_e record
    ]
    )
write_GetMessageBox_result :: T.Protocol p => p -> GetMessageBox_result -> P.IO ()
write_GetMessageBox_result oprot record = T.writeVal oprot $ from_GetMessageBox_result record
encode_GetMessageBox_result :: T.StatelessProtocol p => p -> GetMessageBox_result -> LBS.ByteString
encode_GetMessageBox_result oprot record = T.serializeVal oprot $ from_GetMessageBox_result record
to_GetMessageBox_result :: T.ThriftVal -> GetMessageBox_result
to_GetMessageBox_result (T.TStruct fields) = GetMessageBox_result{
  getMessageBox_result_success = P.maybe (getMessageBox_result_success default_GetMessageBox_result) (\(_,_val4522) -> (case _val4522 of {T.TStruct _val4523 -> (to_TMessageBox (T.TStruct _val4523)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBox_result_e = P.maybe (P.Nothing) (\(_,_val4522) -> P.Just (case _val4522 of {T.TStruct _val4524 -> (to_TalkException (T.TStruct _val4524)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBox_result _ = P.error "not a struct"
read_GetMessageBox_result :: T.Protocol p => p -> P.IO GetMessageBox_result
read_GetMessageBox_result iprot = to_GetMessageBox_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBox_result)
decode_GetMessageBox_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBox_result
decode_GetMessageBox_result iprot bs = to_GetMessageBox_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBox_result) bs
typemap_GetMessageBox_result :: T.TypeMap
typemap_GetMessageBox_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBox))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBox_result :: GetMessageBox_result
default_GetMessageBox_result = GetMessageBox_result{
  getMessageBox_result_success = default_TMessageBox,
  getMessageBox_result_e = P.Nothing}
data GetMessageBoxCompactWrapUp_args = GetMessageBoxCompactWrapUp_args  { getMessageBoxCompactWrapUp_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUp_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUp_args_mid record  
instance QC.Arbitrary GetMessageBoxCompactWrapUp_args where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUp_args (QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUp_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUp_args{getMessageBoxCompactWrapUp_args_mid = getMessageBoxCompactWrapUp_args_mid obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUp_args{getMessageBoxCompactWrapUp_args_mid = getMessageBoxCompactWrapUp_args_mid obj}
    ]
from_GetMessageBoxCompactWrapUp_args :: GetMessageBoxCompactWrapUp_args -> T.ThriftVal
from_GetMessageBoxCompactWrapUp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4527 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v4527))) $ getMessageBoxCompactWrapUp_args_mid record
  ]
write_GetMessageBoxCompactWrapUp_args :: T.Protocol p => p -> GetMessageBoxCompactWrapUp_args -> P.IO ()
write_GetMessageBoxCompactWrapUp_args oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUp_args record
encode_GetMessageBoxCompactWrapUp_args :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUp_args -> LBS.ByteString
encode_GetMessageBoxCompactWrapUp_args oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUp_args record
to_GetMessageBoxCompactWrapUp_args :: T.ThriftVal -> GetMessageBoxCompactWrapUp_args
to_GetMessageBoxCompactWrapUp_args (T.TStruct fields) = GetMessageBoxCompactWrapUp_args{
  getMessageBoxCompactWrapUp_args_mid = P.maybe (getMessageBoxCompactWrapUp_args_mid default_GetMessageBoxCompactWrapUp_args) (\(_,_val4529) -> (case _val4529 of {T.TString _val4530 -> E.decodeUtf8 _val4530; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetMessageBoxCompactWrapUp_args _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUp_args :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUp_args
read_GetMessageBoxCompactWrapUp_args iprot = to_GetMessageBoxCompactWrapUp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_args)
decode_GetMessageBoxCompactWrapUp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUp_args
decode_GetMessageBoxCompactWrapUp_args iprot bs = to_GetMessageBoxCompactWrapUp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_args) bs
typemap_GetMessageBoxCompactWrapUp_args :: T.TypeMap
typemap_GetMessageBoxCompactWrapUp_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetMessageBoxCompactWrapUp_args :: GetMessageBoxCompactWrapUp_args
default_GetMessageBoxCompactWrapUp_args = GetMessageBoxCompactWrapUp_args{
  getMessageBoxCompactWrapUp_args_mid = ""}
data GetMessageBoxCompactWrapUp_result = GetMessageBoxCompactWrapUp_result  { getMessageBoxCompactWrapUp_result_success :: TMessageBoxWrapUp
  , getMessageBoxCompactWrapUp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUp_result_success record   `H.hashWithSalt` getMessageBoxCompactWrapUp_result_e record  
instance QC.Arbitrary GetMessageBoxCompactWrapUp_result where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_success = getMessageBoxCompactWrapUp_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_success = getMessageBoxCompactWrapUp_result_success obj}
    , if obj == default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_e = getMessageBoxCompactWrapUp_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_e = getMessageBoxCompactWrapUp_result_e obj}
    ]
from_GetMessageBoxCompactWrapUp_result :: GetMessageBoxCompactWrapUp_result -> T.ThriftVal
from_GetMessageBoxCompactWrapUp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4533 -> (1, ("e",from_TalkException _v4533))) <$> getMessageBoxCompactWrapUp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4533 -> P.Just (0, ("success",from_TMessageBoxWrapUp _v4533))) $ getMessageBoxCompactWrapUp_result_success record
    , (\_v4533 -> (1, ("e",from_TalkException _v4533))) <$> getMessageBoxCompactWrapUp_result_e record
    ]
    )
write_GetMessageBoxCompactWrapUp_result :: T.Protocol p => p -> GetMessageBoxCompactWrapUp_result -> P.IO ()
write_GetMessageBoxCompactWrapUp_result oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUp_result record
encode_GetMessageBoxCompactWrapUp_result :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUp_result -> LBS.ByteString
encode_GetMessageBoxCompactWrapUp_result oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUp_result record
to_GetMessageBoxCompactWrapUp_result :: T.ThriftVal -> GetMessageBoxCompactWrapUp_result
to_GetMessageBoxCompactWrapUp_result (T.TStruct fields) = GetMessageBoxCompactWrapUp_result{
  getMessageBoxCompactWrapUp_result_success = P.maybe (getMessageBoxCompactWrapUp_result_success default_GetMessageBoxCompactWrapUp_result) (\(_,_val4535) -> (case _val4535 of {T.TStruct _val4536 -> (to_TMessageBoxWrapUp (T.TStruct _val4536)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxCompactWrapUp_result_e = P.maybe (P.Nothing) (\(_,_val4535) -> P.Just (case _val4535 of {T.TStruct _val4537 -> (to_TalkException (T.TStruct _val4537)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxCompactWrapUp_result _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUp_result :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUp_result
read_GetMessageBoxCompactWrapUp_result iprot = to_GetMessageBoxCompactWrapUp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_result)
decode_GetMessageBoxCompactWrapUp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUp_result
decode_GetMessageBoxCompactWrapUp_result iprot bs = to_GetMessageBoxCompactWrapUp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_result) bs
typemap_GetMessageBoxCompactWrapUp_result :: T.TypeMap
typemap_GetMessageBoxCompactWrapUp_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUp))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxCompactWrapUp_result :: GetMessageBoxCompactWrapUp_result
default_GetMessageBoxCompactWrapUp_result = GetMessageBoxCompactWrapUp_result{
  getMessageBoxCompactWrapUp_result_success = default_TMessageBoxWrapUp,
  getMessageBoxCompactWrapUp_result_e = P.Nothing}
data GetMessageBoxCompactWrapUpList_args = GetMessageBoxCompactWrapUpList_args  { getMessageBoxCompactWrapUpList_args_start :: I.Int32
  , getMessageBoxCompactWrapUpList_args_messageBoxCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUpList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUpList_args_start record   `H.hashWithSalt` getMessageBoxCompactWrapUpList_args_messageBoxCount record  
instance QC.Arbitrary GetMessageBoxCompactWrapUpList_args where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUpList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUpList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_start = getMessageBoxCompactWrapUpList_args_start obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_start = getMessageBoxCompactWrapUpList_args_start obj}
    , if obj == default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_messageBoxCount = getMessageBoxCompactWrapUpList_args_messageBoxCount obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_messageBoxCount = getMessageBoxCompactWrapUpList_args_messageBoxCount obj}
    ]
from_GetMessageBoxCompactWrapUpList_args :: GetMessageBoxCompactWrapUpList_args -> T.ThriftVal
from_GetMessageBoxCompactWrapUpList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4540 -> P.Just (2, ("start",T.TI32 _v4540))) $ getMessageBoxCompactWrapUpList_args_start record
  , (\_v4540 -> P.Just (3, ("messageBoxCount",T.TI32 _v4540))) $ getMessageBoxCompactWrapUpList_args_messageBoxCount record
  ]
write_GetMessageBoxCompactWrapUpList_args :: T.Protocol p => p -> GetMessageBoxCompactWrapUpList_args -> P.IO ()
write_GetMessageBoxCompactWrapUpList_args oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUpList_args record
encode_GetMessageBoxCompactWrapUpList_args :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUpList_args -> LBS.ByteString
encode_GetMessageBoxCompactWrapUpList_args oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUpList_args record
to_GetMessageBoxCompactWrapUpList_args :: T.ThriftVal -> GetMessageBoxCompactWrapUpList_args
to_GetMessageBoxCompactWrapUpList_args (T.TStruct fields) = GetMessageBoxCompactWrapUpList_args{
  getMessageBoxCompactWrapUpList_args_start = P.maybe (getMessageBoxCompactWrapUpList_args_start default_GetMessageBoxCompactWrapUpList_args) (\(_,_val4542) -> (case _val4542 of {T.TI32 _val4543 -> _val4543; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxCompactWrapUpList_args_messageBoxCount = P.maybe (getMessageBoxCompactWrapUpList_args_messageBoxCount default_GetMessageBoxCompactWrapUpList_args) (\(_,_val4542) -> (case _val4542 of {T.TI32 _val4544 -> _val4544; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetMessageBoxCompactWrapUpList_args _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUpList_args :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUpList_args
read_GetMessageBoxCompactWrapUpList_args iprot = to_GetMessageBoxCompactWrapUpList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_args)
decode_GetMessageBoxCompactWrapUpList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUpList_args
decode_GetMessageBoxCompactWrapUpList_args iprot bs = to_GetMessageBoxCompactWrapUpList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_args) bs
typemap_GetMessageBoxCompactWrapUpList_args :: T.TypeMap
typemap_GetMessageBoxCompactWrapUpList_args = Map.fromList [(2,("start",T.T_I32)),(3,("messageBoxCount",T.T_I32))]
default_GetMessageBoxCompactWrapUpList_args :: GetMessageBoxCompactWrapUpList_args
default_GetMessageBoxCompactWrapUpList_args = GetMessageBoxCompactWrapUpList_args{
  getMessageBoxCompactWrapUpList_args_start = 0,
  getMessageBoxCompactWrapUpList_args_messageBoxCount = 0}
data GetMessageBoxCompactWrapUpList_result = GetMessageBoxCompactWrapUpList_result  { getMessageBoxCompactWrapUpList_result_success :: TMessageBoxWrapUpResponse
  , getMessageBoxCompactWrapUpList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUpList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUpList_result_success record   `H.hashWithSalt` getMessageBoxCompactWrapUpList_result_e record  
instance QC.Arbitrary GetMessageBoxCompactWrapUpList_result where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUpList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUpList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_success = getMessageBoxCompactWrapUpList_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_success = getMessageBoxCompactWrapUpList_result_success obj}
    , if obj == default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_e = getMessageBoxCompactWrapUpList_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_e = getMessageBoxCompactWrapUpList_result_e obj}
    ]
from_GetMessageBoxCompactWrapUpList_result :: GetMessageBoxCompactWrapUpList_result -> T.ThriftVal
from_GetMessageBoxCompactWrapUpList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4547 -> (1, ("e",from_TalkException _v4547))) <$> getMessageBoxCompactWrapUpList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4547 -> P.Just (0, ("success",from_TMessageBoxWrapUpResponse _v4547))) $ getMessageBoxCompactWrapUpList_result_success record
    , (\_v4547 -> (1, ("e",from_TalkException _v4547))) <$> getMessageBoxCompactWrapUpList_result_e record
    ]
    )
write_GetMessageBoxCompactWrapUpList_result :: T.Protocol p => p -> GetMessageBoxCompactWrapUpList_result -> P.IO ()
write_GetMessageBoxCompactWrapUpList_result oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUpList_result record
encode_GetMessageBoxCompactWrapUpList_result :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUpList_result -> LBS.ByteString
encode_GetMessageBoxCompactWrapUpList_result oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUpList_result record
to_GetMessageBoxCompactWrapUpList_result :: T.ThriftVal -> GetMessageBoxCompactWrapUpList_result
to_GetMessageBoxCompactWrapUpList_result (T.TStruct fields) = GetMessageBoxCompactWrapUpList_result{
  getMessageBoxCompactWrapUpList_result_success = P.maybe (getMessageBoxCompactWrapUpList_result_success default_GetMessageBoxCompactWrapUpList_result) (\(_,_val4549) -> (case _val4549 of {T.TStruct _val4550 -> (to_TMessageBoxWrapUpResponse (T.TStruct _val4550)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxCompactWrapUpList_result_e = P.maybe (P.Nothing) (\(_,_val4549) -> P.Just (case _val4549 of {T.TStruct _val4551 -> (to_TalkException (T.TStruct _val4551)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxCompactWrapUpList_result _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUpList_result :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUpList_result
read_GetMessageBoxCompactWrapUpList_result iprot = to_GetMessageBoxCompactWrapUpList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_result)
decode_GetMessageBoxCompactWrapUpList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUpList_result
decode_GetMessageBoxCompactWrapUpList_result iprot bs = to_GetMessageBoxCompactWrapUpList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_result) bs
typemap_GetMessageBoxCompactWrapUpList_result :: T.TypeMap
typemap_GetMessageBoxCompactWrapUpList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUpResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxCompactWrapUpList_result :: GetMessageBoxCompactWrapUpList_result
default_GetMessageBoxCompactWrapUpList_result = GetMessageBoxCompactWrapUpList_result{
  getMessageBoxCompactWrapUpList_result_success = default_TMessageBoxWrapUpResponse,
  getMessageBoxCompactWrapUpList_result_e = P.Nothing}
data GetMessageBoxList_args = GetMessageBoxList_args  { getMessageBoxList_args_channelId :: LT.Text
  , getMessageBoxList_args_lastMessagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxList_args_channelId record   `H.hashWithSalt` getMessageBoxList_args_lastMessagesCount record  
instance QC.Arbitrary GetMessageBoxList_args where 
  arbitrary = M.liftM GetMessageBoxList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxList_args{getMessageBoxList_args_channelId = getMessageBoxList_args_channelId obj} then P.Nothing else P.Just $ default_GetMessageBoxList_args{getMessageBoxList_args_channelId = getMessageBoxList_args_channelId obj}
    , if obj == default_GetMessageBoxList_args{getMessageBoxList_args_lastMessagesCount = getMessageBoxList_args_lastMessagesCount obj} then P.Nothing else P.Just $ default_GetMessageBoxList_args{getMessageBoxList_args_lastMessagesCount = getMessageBoxList_args_lastMessagesCount obj}
    ]
from_GetMessageBoxList_args :: GetMessageBoxList_args -> T.ThriftVal
from_GetMessageBoxList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4554 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v4554))) $ getMessageBoxList_args_channelId record
  , (\_v4554 -> P.Just (3, ("lastMessagesCount",T.TI32 _v4554))) $ getMessageBoxList_args_lastMessagesCount record
  ]
write_GetMessageBoxList_args :: T.Protocol p => p -> GetMessageBoxList_args -> P.IO ()
write_GetMessageBoxList_args oprot record = T.writeVal oprot $ from_GetMessageBoxList_args record
encode_GetMessageBoxList_args :: T.StatelessProtocol p => p -> GetMessageBoxList_args -> LBS.ByteString
encode_GetMessageBoxList_args oprot record = T.serializeVal oprot $ from_GetMessageBoxList_args record
to_GetMessageBoxList_args :: T.ThriftVal -> GetMessageBoxList_args
to_GetMessageBoxList_args (T.TStruct fields) = GetMessageBoxList_args{
  getMessageBoxList_args_channelId = P.maybe (getMessageBoxList_args_channelId default_GetMessageBoxList_args) (\(_,_val4556) -> (case _val4556 of {T.TString _val4557 -> E.decodeUtf8 _val4557; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxList_args_lastMessagesCount = P.maybe (getMessageBoxList_args_lastMessagesCount default_GetMessageBoxList_args) (\(_,_val4556) -> (case _val4556 of {T.TI32 _val4558 -> _val4558; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetMessageBoxList_args _ = P.error "not a struct"
read_GetMessageBoxList_args :: T.Protocol p => p -> P.IO GetMessageBoxList_args
read_GetMessageBoxList_args iprot = to_GetMessageBoxList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxList_args)
decode_GetMessageBoxList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxList_args
decode_GetMessageBoxList_args iprot bs = to_GetMessageBoxList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxList_args) bs
typemap_GetMessageBoxList_args :: T.TypeMap
typemap_GetMessageBoxList_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("lastMessagesCount",T.T_I32))]
default_GetMessageBoxList_args :: GetMessageBoxList_args
default_GetMessageBoxList_args = GetMessageBoxList_args{
  getMessageBoxList_args_channelId = "",
  getMessageBoxList_args_lastMessagesCount = 0}
data GetMessageBoxList_result = GetMessageBoxList_result  { getMessageBoxList_result_success :: (Vector.Vector TMessageBox)
  , getMessageBoxList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxList_result_success record   `H.hashWithSalt` getMessageBoxList_result_e record  
instance QC.Arbitrary GetMessageBoxList_result where 
  arbitrary = M.liftM GetMessageBoxList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxList_result{getMessageBoxList_result_success = getMessageBoxList_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxList_result{getMessageBoxList_result_success = getMessageBoxList_result_success obj}
    , if obj == default_GetMessageBoxList_result{getMessageBoxList_result_e = getMessageBoxList_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxList_result{getMessageBoxList_result_e = getMessageBoxList_result_e obj}
    ]
from_GetMessageBoxList_result :: GetMessageBoxList_result -> T.ThriftVal
from_GetMessageBoxList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4561 -> (1, ("e",from_TalkException _v4561))) <$> getMessageBoxList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4561 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_TMessageBox) $ P.map (\_v4563 -> from_TMessageBox _v4563) $ Vector.toList _v4561))) $ getMessageBoxList_result_success record
    , (\_v4561 -> (1, ("e",from_TalkException _v4561))) <$> getMessageBoxList_result_e record
    ]
    )
write_GetMessageBoxList_result :: T.Protocol p => p -> GetMessageBoxList_result -> P.IO ()
write_GetMessageBoxList_result oprot record = T.writeVal oprot $ from_GetMessageBoxList_result record
encode_GetMessageBoxList_result :: T.StatelessProtocol p => p -> GetMessageBoxList_result -> LBS.ByteString
encode_GetMessageBoxList_result oprot record = T.serializeVal oprot $ from_GetMessageBoxList_result record
to_GetMessageBoxList_result :: T.ThriftVal -> GetMessageBoxList_result
to_GetMessageBoxList_result (T.TStruct fields) = GetMessageBoxList_result{
  getMessageBoxList_result_success = P.maybe (getMessageBoxList_result_success default_GetMessageBoxList_result) (\(_,_val4565) -> (case _val4565 of {T.TList _ _val4566 -> (Vector.fromList $ P.map (\_v4567 -> (case _v4567 of {T.TStruct _val4568 -> (to_TMessageBox (T.TStruct _val4568)); _ -> P.error "wrong type"})) _val4566); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxList_result_e = P.maybe (P.Nothing) (\(_,_val4565) -> P.Just (case _val4565 of {T.TStruct _val4569 -> (to_TalkException (T.TStruct _val4569)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxList_result _ = P.error "not a struct"
read_GetMessageBoxList_result :: T.Protocol p => p -> P.IO GetMessageBoxList_result
read_GetMessageBoxList_result iprot = to_GetMessageBoxList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxList_result)
decode_GetMessageBoxList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxList_result
decode_GetMessageBoxList_result iprot bs = to_GetMessageBoxList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxList_result) bs
typemap_GetMessageBoxList_result :: T.TypeMap
typemap_GetMessageBoxList_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_TMessageBox)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxList_result :: GetMessageBoxList_result
default_GetMessageBoxList_result = GetMessageBoxList_result{
  getMessageBoxList_result_success = Vector.empty,
  getMessageBoxList_result_e = P.Nothing}
data GetMessageBoxListByStatus_args = GetMessageBoxListByStatus_args  { getMessageBoxListByStatus_args_channelId :: LT.Text
  , getMessageBoxListByStatus_args_lastMessagesCount :: I.Int32
  , getMessageBoxListByStatus_args_status :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxListByStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxListByStatus_args_channelId record   `H.hashWithSalt` getMessageBoxListByStatus_args_lastMessagesCount record   `H.hashWithSalt` getMessageBoxListByStatus_args_status record  
instance QC.Arbitrary GetMessageBoxListByStatus_args where 
  arbitrary = M.liftM GetMessageBoxListByStatus_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxListByStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_channelId = getMessageBoxListByStatus_args_channelId obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_channelId = getMessageBoxListByStatus_args_channelId obj}
    , if obj == default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_lastMessagesCount = getMessageBoxListByStatus_args_lastMessagesCount obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_lastMessagesCount = getMessageBoxListByStatus_args_lastMessagesCount obj}
    , if obj == default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_status = getMessageBoxListByStatus_args_status obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_status = getMessageBoxListByStatus_args_status obj}
    ]
from_GetMessageBoxListByStatus_args :: GetMessageBoxListByStatus_args -> T.ThriftVal
from_GetMessageBoxListByStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4572 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v4572))) $ getMessageBoxListByStatus_args_channelId record
  , (\_v4572 -> P.Just (3, ("lastMessagesCount",T.TI32 _v4572))) $ getMessageBoxListByStatus_args_lastMessagesCount record
  , (\_v4572 -> P.Just (4, ("status",T.TI32 _v4572))) $ getMessageBoxListByStatus_args_status record
  ]
write_GetMessageBoxListByStatus_args :: T.Protocol p => p -> GetMessageBoxListByStatus_args -> P.IO ()
write_GetMessageBoxListByStatus_args oprot record = T.writeVal oprot $ from_GetMessageBoxListByStatus_args record
encode_GetMessageBoxListByStatus_args :: T.StatelessProtocol p => p -> GetMessageBoxListByStatus_args -> LBS.ByteString
encode_GetMessageBoxListByStatus_args oprot record = T.serializeVal oprot $ from_GetMessageBoxListByStatus_args record
to_GetMessageBoxListByStatus_args :: T.ThriftVal -> GetMessageBoxListByStatus_args
to_GetMessageBoxListByStatus_args (T.TStruct fields) = GetMessageBoxListByStatus_args{
  getMessageBoxListByStatus_args_channelId = P.maybe (getMessageBoxListByStatus_args_channelId default_GetMessageBoxListByStatus_args) (\(_,_val4574) -> (case _val4574 of {T.TString _val4575 -> E.decodeUtf8 _val4575; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxListByStatus_args_lastMessagesCount = P.maybe (getMessageBoxListByStatus_args_lastMessagesCount default_GetMessageBoxListByStatus_args) (\(_,_val4574) -> (case _val4574 of {T.TI32 _val4576 -> _val4576; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getMessageBoxListByStatus_args_status = P.maybe (getMessageBoxListByStatus_args_status default_GetMessageBoxListByStatus_args) (\(_,_val4574) -> (case _val4574 of {T.TI32 _val4577 -> _val4577; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetMessageBoxListByStatus_args _ = P.error "not a struct"
read_GetMessageBoxListByStatus_args :: T.Protocol p => p -> P.IO GetMessageBoxListByStatus_args
read_GetMessageBoxListByStatus_args iprot = to_GetMessageBoxListByStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_args)
decode_GetMessageBoxListByStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxListByStatus_args
decode_GetMessageBoxListByStatus_args iprot bs = to_GetMessageBoxListByStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_args) bs
typemap_GetMessageBoxListByStatus_args :: T.TypeMap
typemap_GetMessageBoxListByStatus_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("lastMessagesCount",T.T_I32)),(4,("status",T.T_I32))]
default_GetMessageBoxListByStatus_args :: GetMessageBoxListByStatus_args
default_GetMessageBoxListByStatus_args = GetMessageBoxListByStatus_args{
  getMessageBoxListByStatus_args_channelId = "",
  getMessageBoxListByStatus_args_lastMessagesCount = 0,
  getMessageBoxListByStatus_args_status = 0}
data GetMessageBoxListByStatus_result = GetMessageBoxListByStatus_result  { getMessageBoxListByStatus_result_success :: (Vector.Vector TMessageBox)
  , getMessageBoxListByStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxListByStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxListByStatus_result_success record   `H.hashWithSalt` getMessageBoxListByStatus_result_e record  
instance QC.Arbitrary GetMessageBoxListByStatus_result where 
  arbitrary = M.liftM GetMessageBoxListByStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxListByStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_success = getMessageBoxListByStatus_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_success = getMessageBoxListByStatus_result_success obj}
    , if obj == default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_e = getMessageBoxListByStatus_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_e = getMessageBoxListByStatus_result_e obj}
    ]
from_GetMessageBoxListByStatus_result :: GetMessageBoxListByStatus_result -> T.ThriftVal
from_GetMessageBoxListByStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4580 -> (1, ("e",from_TalkException _v4580))) <$> getMessageBoxListByStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4580 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_TMessageBox) $ P.map (\_v4582 -> from_TMessageBox _v4582) $ Vector.toList _v4580))) $ getMessageBoxListByStatus_result_success record
    , (\_v4580 -> (1, ("e",from_TalkException _v4580))) <$> getMessageBoxListByStatus_result_e record
    ]
    )
write_GetMessageBoxListByStatus_result :: T.Protocol p => p -> GetMessageBoxListByStatus_result -> P.IO ()
write_GetMessageBoxListByStatus_result oprot record = T.writeVal oprot $ from_GetMessageBoxListByStatus_result record
encode_GetMessageBoxListByStatus_result :: T.StatelessProtocol p => p -> GetMessageBoxListByStatus_result -> LBS.ByteString
encode_GetMessageBoxListByStatus_result oprot record = T.serializeVal oprot $ from_GetMessageBoxListByStatus_result record
to_GetMessageBoxListByStatus_result :: T.ThriftVal -> GetMessageBoxListByStatus_result
to_GetMessageBoxListByStatus_result (T.TStruct fields) = GetMessageBoxListByStatus_result{
  getMessageBoxListByStatus_result_success = P.maybe (getMessageBoxListByStatus_result_success default_GetMessageBoxListByStatus_result) (\(_,_val4584) -> (case _val4584 of {T.TList _ _val4585 -> (Vector.fromList $ P.map (\_v4586 -> (case _v4586 of {T.TStruct _val4587 -> (to_TMessageBox (T.TStruct _val4587)); _ -> P.error "wrong type"})) _val4585); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxListByStatus_result_e = P.maybe (P.Nothing) (\(_,_val4584) -> P.Just (case _val4584 of {T.TStruct _val4588 -> (to_TalkException (T.TStruct _val4588)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxListByStatus_result _ = P.error "not a struct"
read_GetMessageBoxListByStatus_result :: T.Protocol p => p -> P.IO GetMessageBoxListByStatus_result
read_GetMessageBoxListByStatus_result iprot = to_GetMessageBoxListByStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_result)
decode_GetMessageBoxListByStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxListByStatus_result
decode_GetMessageBoxListByStatus_result iprot bs = to_GetMessageBoxListByStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_result) bs
typemap_GetMessageBoxListByStatus_result :: T.TypeMap
typemap_GetMessageBoxListByStatus_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_TMessageBox)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxListByStatus_result :: GetMessageBoxListByStatus_result
default_GetMessageBoxListByStatus_result = GetMessageBoxListByStatus_result{
  getMessageBoxListByStatus_result_success = Vector.empty,
  getMessageBoxListByStatus_result_e = P.Nothing}
data GetMessageBoxWrapUp_args = GetMessageBoxWrapUp_args  { getMessageBoxWrapUp_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUp_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUp_args_mid record  
instance QC.Arbitrary GetMessageBoxWrapUp_args where 
  arbitrary = M.liftM GetMessageBoxWrapUp_args (QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUp_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUp_args{getMessageBoxWrapUp_args_mid = getMessageBoxWrapUp_args_mid obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUp_args{getMessageBoxWrapUp_args_mid = getMessageBoxWrapUp_args_mid obj}
    ]
from_GetMessageBoxWrapUp_args :: GetMessageBoxWrapUp_args -> T.ThriftVal
from_GetMessageBoxWrapUp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4591 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v4591))) $ getMessageBoxWrapUp_args_mid record
  ]
write_GetMessageBoxWrapUp_args :: T.Protocol p => p -> GetMessageBoxWrapUp_args -> P.IO ()
write_GetMessageBoxWrapUp_args oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUp_args record
encode_GetMessageBoxWrapUp_args :: T.StatelessProtocol p => p -> GetMessageBoxWrapUp_args -> LBS.ByteString
encode_GetMessageBoxWrapUp_args oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUp_args record
to_GetMessageBoxWrapUp_args :: T.ThriftVal -> GetMessageBoxWrapUp_args
to_GetMessageBoxWrapUp_args (T.TStruct fields) = GetMessageBoxWrapUp_args{
  getMessageBoxWrapUp_args_mid = P.maybe (getMessageBoxWrapUp_args_mid default_GetMessageBoxWrapUp_args) (\(_,_val4593) -> (case _val4593 of {T.TString _val4594 -> E.decodeUtf8 _val4594; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetMessageBoxWrapUp_args _ = P.error "not a struct"
read_GetMessageBoxWrapUp_args :: T.Protocol p => p -> P.IO GetMessageBoxWrapUp_args
read_GetMessageBoxWrapUp_args iprot = to_GetMessageBoxWrapUp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_args)
decode_GetMessageBoxWrapUp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUp_args
decode_GetMessageBoxWrapUp_args iprot bs = to_GetMessageBoxWrapUp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_args) bs
typemap_GetMessageBoxWrapUp_args :: T.TypeMap
typemap_GetMessageBoxWrapUp_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetMessageBoxWrapUp_args :: GetMessageBoxWrapUp_args
default_GetMessageBoxWrapUp_args = GetMessageBoxWrapUp_args{
  getMessageBoxWrapUp_args_mid = ""}
data GetMessageBoxWrapUp_result = GetMessageBoxWrapUp_result  { getMessageBoxWrapUp_result_success :: TMessageBoxWrapUp
  , getMessageBoxWrapUp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUp_result_success record   `H.hashWithSalt` getMessageBoxWrapUp_result_e record  
instance QC.Arbitrary GetMessageBoxWrapUp_result where 
  arbitrary = M.liftM GetMessageBoxWrapUp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_success = getMessageBoxWrapUp_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_success = getMessageBoxWrapUp_result_success obj}
    , if obj == default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_e = getMessageBoxWrapUp_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_e = getMessageBoxWrapUp_result_e obj}
    ]
from_GetMessageBoxWrapUp_result :: GetMessageBoxWrapUp_result -> T.ThriftVal
from_GetMessageBoxWrapUp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4597 -> (1, ("e",from_TalkException _v4597))) <$> getMessageBoxWrapUp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4597 -> P.Just (0, ("success",from_TMessageBoxWrapUp _v4597))) $ getMessageBoxWrapUp_result_success record
    , (\_v4597 -> (1, ("e",from_TalkException _v4597))) <$> getMessageBoxWrapUp_result_e record
    ]
    )
write_GetMessageBoxWrapUp_result :: T.Protocol p => p -> GetMessageBoxWrapUp_result -> P.IO ()
write_GetMessageBoxWrapUp_result oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUp_result record
encode_GetMessageBoxWrapUp_result :: T.StatelessProtocol p => p -> GetMessageBoxWrapUp_result -> LBS.ByteString
encode_GetMessageBoxWrapUp_result oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUp_result record
to_GetMessageBoxWrapUp_result :: T.ThriftVal -> GetMessageBoxWrapUp_result
to_GetMessageBoxWrapUp_result (T.TStruct fields) = GetMessageBoxWrapUp_result{
  getMessageBoxWrapUp_result_success = P.maybe (getMessageBoxWrapUp_result_success default_GetMessageBoxWrapUp_result) (\(_,_val4599) -> (case _val4599 of {T.TStruct _val4600 -> (to_TMessageBoxWrapUp (T.TStruct _val4600)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxWrapUp_result_e = P.maybe (P.Nothing) (\(_,_val4599) -> P.Just (case _val4599 of {T.TStruct _val4601 -> (to_TalkException (T.TStruct _val4601)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxWrapUp_result _ = P.error "not a struct"
read_GetMessageBoxWrapUp_result :: T.Protocol p => p -> P.IO GetMessageBoxWrapUp_result
read_GetMessageBoxWrapUp_result iprot = to_GetMessageBoxWrapUp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_result)
decode_GetMessageBoxWrapUp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUp_result
decode_GetMessageBoxWrapUp_result iprot bs = to_GetMessageBoxWrapUp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_result) bs
typemap_GetMessageBoxWrapUp_result :: T.TypeMap
typemap_GetMessageBoxWrapUp_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUp))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxWrapUp_result :: GetMessageBoxWrapUp_result
default_GetMessageBoxWrapUp_result = GetMessageBoxWrapUp_result{
  getMessageBoxWrapUp_result_success = default_TMessageBoxWrapUp,
  getMessageBoxWrapUp_result_e = P.Nothing}
data GetMessageBoxWrapUpList_args = GetMessageBoxWrapUpList_args  { getMessageBoxWrapUpList_args_start :: I.Int32
  , getMessageBoxWrapUpList_args_messageBoxCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUpList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUpList_args_start record   `H.hashWithSalt` getMessageBoxWrapUpList_args_messageBoxCount record  
instance QC.Arbitrary GetMessageBoxWrapUpList_args where 
  arbitrary = M.liftM GetMessageBoxWrapUpList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUpList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_start = getMessageBoxWrapUpList_args_start obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_start = getMessageBoxWrapUpList_args_start obj}
    , if obj == default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_messageBoxCount = getMessageBoxWrapUpList_args_messageBoxCount obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_messageBoxCount = getMessageBoxWrapUpList_args_messageBoxCount obj}
    ]
from_GetMessageBoxWrapUpList_args :: GetMessageBoxWrapUpList_args -> T.ThriftVal
from_GetMessageBoxWrapUpList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4604 -> P.Just (2, ("start",T.TI32 _v4604))) $ getMessageBoxWrapUpList_args_start record
  , (\_v4604 -> P.Just (3, ("messageBoxCount",T.TI32 _v4604))) $ getMessageBoxWrapUpList_args_messageBoxCount record
  ]
write_GetMessageBoxWrapUpList_args :: T.Protocol p => p -> GetMessageBoxWrapUpList_args -> P.IO ()
write_GetMessageBoxWrapUpList_args oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUpList_args record
encode_GetMessageBoxWrapUpList_args :: T.StatelessProtocol p => p -> GetMessageBoxWrapUpList_args -> LBS.ByteString
encode_GetMessageBoxWrapUpList_args oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUpList_args record
to_GetMessageBoxWrapUpList_args :: T.ThriftVal -> GetMessageBoxWrapUpList_args
to_GetMessageBoxWrapUpList_args (T.TStruct fields) = GetMessageBoxWrapUpList_args{
  getMessageBoxWrapUpList_args_start = P.maybe (getMessageBoxWrapUpList_args_start default_GetMessageBoxWrapUpList_args) (\(_,_val4606) -> (case _val4606 of {T.TI32 _val4607 -> _val4607; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxWrapUpList_args_messageBoxCount = P.maybe (getMessageBoxWrapUpList_args_messageBoxCount default_GetMessageBoxWrapUpList_args) (\(_,_val4606) -> (case _val4606 of {T.TI32 _val4608 -> _val4608; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetMessageBoxWrapUpList_args _ = P.error "not a struct"
read_GetMessageBoxWrapUpList_args :: T.Protocol p => p -> P.IO GetMessageBoxWrapUpList_args
read_GetMessageBoxWrapUpList_args iprot = to_GetMessageBoxWrapUpList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_args)
decode_GetMessageBoxWrapUpList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUpList_args
decode_GetMessageBoxWrapUpList_args iprot bs = to_GetMessageBoxWrapUpList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_args) bs
typemap_GetMessageBoxWrapUpList_args :: T.TypeMap
typemap_GetMessageBoxWrapUpList_args = Map.fromList [(2,("start",T.T_I32)),(3,("messageBoxCount",T.T_I32))]
default_GetMessageBoxWrapUpList_args :: GetMessageBoxWrapUpList_args
default_GetMessageBoxWrapUpList_args = GetMessageBoxWrapUpList_args{
  getMessageBoxWrapUpList_args_start = 0,
  getMessageBoxWrapUpList_args_messageBoxCount = 0}
data GetMessageBoxWrapUpList_result = GetMessageBoxWrapUpList_result  { getMessageBoxWrapUpList_result_success :: TMessageBoxWrapUpResponse
  , getMessageBoxWrapUpList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUpList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUpList_result_success record   `H.hashWithSalt` getMessageBoxWrapUpList_result_e record  
instance QC.Arbitrary GetMessageBoxWrapUpList_result where 
  arbitrary = M.liftM GetMessageBoxWrapUpList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUpList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_success = getMessageBoxWrapUpList_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_success = getMessageBoxWrapUpList_result_success obj}
    , if obj == default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_e = getMessageBoxWrapUpList_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_e = getMessageBoxWrapUpList_result_e obj}
    ]
from_GetMessageBoxWrapUpList_result :: GetMessageBoxWrapUpList_result -> T.ThriftVal
from_GetMessageBoxWrapUpList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4611 -> (1, ("e",from_TalkException _v4611))) <$> getMessageBoxWrapUpList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4611 -> P.Just (0, ("success",from_TMessageBoxWrapUpResponse _v4611))) $ getMessageBoxWrapUpList_result_success record
    , (\_v4611 -> (1, ("e",from_TalkException _v4611))) <$> getMessageBoxWrapUpList_result_e record
    ]
    )
write_GetMessageBoxWrapUpList_result :: T.Protocol p => p -> GetMessageBoxWrapUpList_result -> P.IO ()
write_GetMessageBoxWrapUpList_result oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUpList_result record
encode_GetMessageBoxWrapUpList_result :: T.StatelessProtocol p => p -> GetMessageBoxWrapUpList_result -> LBS.ByteString
encode_GetMessageBoxWrapUpList_result oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUpList_result record
to_GetMessageBoxWrapUpList_result :: T.ThriftVal -> GetMessageBoxWrapUpList_result
to_GetMessageBoxWrapUpList_result (T.TStruct fields) = GetMessageBoxWrapUpList_result{
  getMessageBoxWrapUpList_result_success = P.maybe (getMessageBoxWrapUpList_result_success default_GetMessageBoxWrapUpList_result) (\(_,_val4613) -> (case _val4613 of {T.TStruct _val4614 -> (to_TMessageBoxWrapUpResponse (T.TStruct _val4614)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxWrapUpList_result_e = P.maybe (P.Nothing) (\(_,_val4613) -> P.Just (case _val4613 of {T.TStruct _val4615 -> (to_TalkException (T.TStruct _val4615)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxWrapUpList_result _ = P.error "not a struct"
read_GetMessageBoxWrapUpList_result :: T.Protocol p => p -> P.IO GetMessageBoxWrapUpList_result
read_GetMessageBoxWrapUpList_result iprot = to_GetMessageBoxWrapUpList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_result)
decode_GetMessageBoxWrapUpList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUpList_result
decode_GetMessageBoxWrapUpList_result iprot bs = to_GetMessageBoxWrapUpList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_result) bs
typemap_GetMessageBoxWrapUpList_result :: T.TypeMap
typemap_GetMessageBoxWrapUpList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUpResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxWrapUpList_result :: GetMessageBoxWrapUpList_result
default_GetMessageBoxWrapUpList_result = GetMessageBoxWrapUpList_result{
  getMessageBoxWrapUpList_result_success = default_TMessageBoxWrapUpResponse,
  getMessageBoxWrapUpList_result_e = P.Nothing}
data GetMessagesBySequenceNumber_args = GetMessagesBySequenceNumber_args  { getMessagesBySequenceNumber_args_channelId :: LT.Text
  , getMessagesBySequenceNumber_args_messageBoxId :: LT.Text
  , getMessagesBySequenceNumber_args_startSeq :: I.Int64
  , getMessagesBySequenceNumber_args_endSeq :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessagesBySequenceNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessagesBySequenceNumber_args_channelId record   `H.hashWithSalt` getMessagesBySequenceNumber_args_messageBoxId record   `H.hashWithSalt` getMessagesBySequenceNumber_args_startSeq record   `H.hashWithSalt` getMessagesBySequenceNumber_args_endSeq record  
instance QC.Arbitrary GetMessagesBySequenceNumber_args where 
  arbitrary = M.liftM GetMessagesBySequenceNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessagesBySequenceNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_channelId = getMessagesBySequenceNumber_args_channelId obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_channelId = getMessagesBySequenceNumber_args_channelId obj}
    , if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_messageBoxId = getMessagesBySequenceNumber_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_messageBoxId = getMessagesBySequenceNumber_args_messageBoxId obj}
    , if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_startSeq = getMessagesBySequenceNumber_args_startSeq obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_startSeq = getMessagesBySequenceNumber_args_startSeq obj}
    , if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_endSeq = getMessagesBySequenceNumber_args_endSeq obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_endSeq = getMessagesBySequenceNumber_args_endSeq obj}
    ]
from_GetMessagesBySequenceNumber_args :: GetMessagesBySequenceNumber_args -> T.ThriftVal
from_GetMessagesBySequenceNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4618 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v4618))) $ getMessagesBySequenceNumber_args_channelId record
  , (\_v4618 -> P.Just (3, ("messageBoxId",T.TString $ E.encodeUtf8 _v4618))) $ getMessagesBySequenceNumber_args_messageBoxId record
  , (\_v4618 -> P.Just (4, ("startSeq",T.TI64 _v4618))) $ getMessagesBySequenceNumber_args_startSeq record
  , (\_v4618 -> P.Just (5, ("endSeq",T.TI64 _v4618))) $ getMessagesBySequenceNumber_args_endSeq record
  ]
write_GetMessagesBySequenceNumber_args :: T.Protocol p => p -> GetMessagesBySequenceNumber_args -> P.IO ()
write_GetMessagesBySequenceNumber_args oprot record = T.writeVal oprot $ from_GetMessagesBySequenceNumber_args record
encode_GetMessagesBySequenceNumber_args :: T.StatelessProtocol p => p -> GetMessagesBySequenceNumber_args -> LBS.ByteString
encode_GetMessagesBySequenceNumber_args oprot record = T.serializeVal oprot $ from_GetMessagesBySequenceNumber_args record
to_GetMessagesBySequenceNumber_args :: T.ThriftVal -> GetMessagesBySequenceNumber_args
to_GetMessagesBySequenceNumber_args (T.TStruct fields) = GetMessagesBySequenceNumber_args{
  getMessagesBySequenceNumber_args_channelId = P.maybe (getMessagesBySequenceNumber_args_channelId default_GetMessagesBySequenceNumber_args) (\(_,_val4620) -> (case _val4620 of {T.TString _val4621 -> E.decodeUtf8 _val4621; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessagesBySequenceNumber_args_messageBoxId = P.maybe (getMessagesBySequenceNumber_args_messageBoxId default_GetMessagesBySequenceNumber_args) (\(_,_val4620) -> (case _val4620 of {T.TString _val4622 -> E.decodeUtf8 _val4622; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getMessagesBySequenceNumber_args_startSeq = P.maybe (getMessagesBySequenceNumber_args_startSeq default_GetMessagesBySequenceNumber_args) (\(_,_val4620) -> (case _val4620 of {T.TI64 _val4623 -> _val4623; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getMessagesBySequenceNumber_args_endSeq = P.maybe (getMessagesBySequenceNumber_args_endSeq default_GetMessagesBySequenceNumber_args) (\(_,_val4620) -> (case _val4620 of {T.TI64 _val4624 -> _val4624; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetMessagesBySequenceNumber_args _ = P.error "not a struct"
read_GetMessagesBySequenceNumber_args :: T.Protocol p => p -> P.IO GetMessagesBySequenceNumber_args
read_GetMessagesBySequenceNumber_args iprot = to_GetMessagesBySequenceNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_args)
decode_GetMessagesBySequenceNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessagesBySequenceNumber_args
decode_GetMessagesBySequenceNumber_args iprot bs = to_GetMessagesBySequenceNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_args) bs
typemap_GetMessagesBySequenceNumber_args :: T.TypeMap
typemap_GetMessagesBySequenceNumber_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("messageBoxId",T.T_STRING)),(4,("startSeq",T.T_I64)),(5,("endSeq",T.T_I64))]
default_GetMessagesBySequenceNumber_args :: GetMessagesBySequenceNumber_args
default_GetMessagesBySequenceNumber_args = GetMessagesBySequenceNumber_args{
  getMessagesBySequenceNumber_args_channelId = "",
  getMessagesBySequenceNumber_args_messageBoxId = "",
  getMessagesBySequenceNumber_args_startSeq = 0,
  getMessagesBySequenceNumber_args_endSeq = 0}
data GetMessagesBySequenceNumber_result = GetMessagesBySequenceNumber_result  { getMessagesBySequenceNumber_result_success :: (Vector.Vector Message)
  , getMessagesBySequenceNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessagesBySequenceNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessagesBySequenceNumber_result_success record   `H.hashWithSalt` getMessagesBySequenceNumber_result_e record  
instance QC.Arbitrary GetMessagesBySequenceNumber_result where 
  arbitrary = M.liftM GetMessagesBySequenceNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessagesBySequenceNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_success = getMessagesBySequenceNumber_result_success obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_success = getMessagesBySequenceNumber_result_success obj}
    , if obj == default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_e = getMessagesBySequenceNumber_result_e obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_e = getMessagesBySequenceNumber_result_e obj}
    ]
from_GetMessagesBySequenceNumber_result :: GetMessagesBySequenceNumber_result -> T.ThriftVal
from_GetMessagesBySequenceNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4627 -> (1, ("e",from_TalkException _v4627))) <$> getMessagesBySequenceNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4627 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v4629 -> from_Message _v4629) $ Vector.toList _v4627))) $ getMessagesBySequenceNumber_result_success record
    , (\_v4627 -> (1, ("e",from_TalkException _v4627))) <$> getMessagesBySequenceNumber_result_e record
    ]
    )
write_GetMessagesBySequenceNumber_result :: T.Protocol p => p -> GetMessagesBySequenceNumber_result -> P.IO ()
write_GetMessagesBySequenceNumber_result oprot record = T.writeVal oprot $ from_GetMessagesBySequenceNumber_result record
encode_GetMessagesBySequenceNumber_result :: T.StatelessProtocol p => p -> GetMessagesBySequenceNumber_result -> LBS.ByteString
encode_GetMessagesBySequenceNumber_result oprot record = T.serializeVal oprot $ from_GetMessagesBySequenceNumber_result record
to_GetMessagesBySequenceNumber_result :: T.ThriftVal -> GetMessagesBySequenceNumber_result
to_GetMessagesBySequenceNumber_result (T.TStruct fields) = GetMessagesBySequenceNumber_result{
  getMessagesBySequenceNumber_result_success = P.maybe (getMessagesBySequenceNumber_result_success default_GetMessagesBySequenceNumber_result) (\(_,_val4631) -> (case _val4631 of {T.TList _ _val4632 -> (Vector.fromList $ P.map (\_v4633 -> (case _v4633 of {T.TStruct _val4634 -> (to_Message (T.TStruct _val4634)); _ -> P.error "wrong type"})) _val4632); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessagesBySequenceNumber_result_e = P.maybe (P.Nothing) (\(_,_val4631) -> P.Just (case _val4631 of {T.TStruct _val4635 -> (to_TalkException (T.TStruct _val4635)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessagesBySequenceNumber_result _ = P.error "not a struct"
read_GetMessagesBySequenceNumber_result :: T.Protocol p => p -> P.IO GetMessagesBySequenceNumber_result
read_GetMessagesBySequenceNumber_result iprot = to_GetMessagesBySequenceNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_result)
decode_GetMessagesBySequenceNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessagesBySequenceNumber_result
decode_GetMessagesBySequenceNumber_result iprot bs = to_GetMessagesBySequenceNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_result) bs
typemap_GetMessagesBySequenceNumber_result :: T.TypeMap
typemap_GetMessagesBySequenceNumber_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessagesBySequenceNumber_result :: GetMessagesBySequenceNumber_result
default_GetMessagesBySequenceNumber_result = GetMessagesBySequenceNumber_result{
  getMessagesBySequenceNumber_result_success = Vector.empty,
  getMessagesBySequenceNumber_result_e = P.Nothing}
data GetNextMessages_args = GetNextMessages_args  { getNextMessages_args_messageBoxId :: LT.Text
  , getNextMessages_args_startSeq :: I.Int64
  , getNextMessages_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextMessages_args_messageBoxId record   `H.hashWithSalt` getNextMessages_args_startSeq record   `H.hashWithSalt` getNextMessages_args_messagesCount record  
instance QC.Arbitrary GetNextMessages_args where 
  arbitrary = M.liftM GetNextMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNextMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextMessages_args{getNextMessages_args_messageBoxId = getNextMessages_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetNextMessages_args{getNextMessages_args_messageBoxId = getNextMessages_args_messageBoxId obj}
    , if obj == default_GetNextMessages_args{getNextMessages_args_startSeq = getNextMessages_args_startSeq obj} then P.Nothing else P.Just $ default_GetNextMessages_args{getNextMessages_args_startSeq = getNextMessages_args_startSeq obj}
    , if obj == default_GetNextMessages_args{getNextMessages_args_messagesCount = getNextMessages_args_messagesCount obj} then P.Nothing else P.Just $ default_GetNextMessages_args{getNextMessages_args_messagesCount = getNextMessages_args_messagesCount obj}
    ]
from_GetNextMessages_args :: GetNextMessages_args -> T.ThriftVal
from_GetNextMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4638 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v4638))) $ getNextMessages_args_messageBoxId record
  , (\_v4638 -> P.Just (3, ("startSeq",T.TI64 _v4638))) $ getNextMessages_args_startSeq record
  , (\_v4638 -> P.Just (4, ("messagesCount",T.TI32 _v4638))) $ getNextMessages_args_messagesCount record
  ]
write_GetNextMessages_args :: T.Protocol p => p -> GetNextMessages_args -> P.IO ()
write_GetNextMessages_args oprot record = T.writeVal oprot $ from_GetNextMessages_args record
encode_GetNextMessages_args :: T.StatelessProtocol p => p -> GetNextMessages_args -> LBS.ByteString
encode_GetNextMessages_args oprot record = T.serializeVal oprot $ from_GetNextMessages_args record
to_GetNextMessages_args :: T.ThriftVal -> GetNextMessages_args
to_GetNextMessages_args (T.TStruct fields) = GetNextMessages_args{
  getNextMessages_args_messageBoxId = P.maybe (getNextMessages_args_messageBoxId default_GetNextMessages_args) (\(_,_val4640) -> (case _val4640 of {T.TString _val4641 -> E.decodeUtf8 _val4641; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNextMessages_args_startSeq = P.maybe (getNextMessages_args_startSeq default_GetNextMessages_args) (\(_,_val4640) -> (case _val4640 of {T.TI64 _val4642 -> _val4642; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getNextMessages_args_messagesCount = P.maybe (getNextMessages_args_messagesCount default_GetNextMessages_args) (\(_,_val4640) -> (case _val4640 of {T.TI32 _val4643 -> _val4643; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetNextMessages_args _ = P.error "not a struct"
read_GetNextMessages_args :: T.Protocol p => p -> P.IO GetNextMessages_args
read_GetNextMessages_args iprot = to_GetNextMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNextMessages_args)
decode_GetNextMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNextMessages_args
decode_GetNextMessages_args iprot bs = to_GetNextMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextMessages_args) bs
typemap_GetNextMessages_args :: T.TypeMap
typemap_GetNextMessages_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("startSeq",T.T_I64)),(4,("messagesCount",T.T_I32))]
default_GetNextMessages_args :: GetNextMessages_args
default_GetNextMessages_args = GetNextMessages_args{
  getNextMessages_args_messageBoxId = "",
  getNextMessages_args_startSeq = 0,
  getNextMessages_args_messagesCount = 0}
data GetNextMessages_result = GetNextMessages_result  { getNextMessages_result_success :: (Vector.Vector Message)
  , getNextMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextMessages_result_success record   `H.hashWithSalt` getNextMessages_result_e record  
instance QC.Arbitrary GetNextMessages_result where 
  arbitrary = M.liftM GetNextMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNextMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextMessages_result{getNextMessages_result_success = getNextMessages_result_success obj} then P.Nothing else P.Just $ default_GetNextMessages_result{getNextMessages_result_success = getNextMessages_result_success obj}
    , if obj == default_GetNextMessages_result{getNextMessages_result_e = getNextMessages_result_e obj} then P.Nothing else P.Just $ default_GetNextMessages_result{getNextMessages_result_e = getNextMessages_result_e obj}
    ]
from_GetNextMessages_result :: GetNextMessages_result -> T.ThriftVal
from_GetNextMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4646 -> (1, ("e",from_TalkException _v4646))) <$> getNextMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4646 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v4648 -> from_Message _v4648) $ Vector.toList _v4646))) $ getNextMessages_result_success record
    , (\_v4646 -> (1, ("e",from_TalkException _v4646))) <$> getNextMessages_result_e record
    ]
    )
write_GetNextMessages_result :: T.Protocol p => p -> GetNextMessages_result -> P.IO ()
write_GetNextMessages_result oprot record = T.writeVal oprot $ from_GetNextMessages_result record
encode_GetNextMessages_result :: T.StatelessProtocol p => p -> GetNextMessages_result -> LBS.ByteString
encode_GetNextMessages_result oprot record = T.serializeVal oprot $ from_GetNextMessages_result record
to_GetNextMessages_result :: T.ThriftVal -> GetNextMessages_result
to_GetNextMessages_result (T.TStruct fields) = GetNextMessages_result{
  getNextMessages_result_success = P.maybe (getNextMessages_result_success default_GetNextMessages_result) (\(_,_val4650) -> (case _val4650 of {T.TList _ _val4651 -> (Vector.fromList $ P.map (\_v4652 -> (case _v4652 of {T.TStruct _val4653 -> (to_Message (T.TStruct _val4653)); _ -> P.error "wrong type"})) _val4651); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNextMessages_result_e = P.maybe (P.Nothing) (\(_,_val4650) -> P.Just (case _val4650 of {T.TStruct _val4654 -> (to_TalkException (T.TStruct _val4654)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNextMessages_result _ = P.error "not a struct"
read_GetNextMessages_result :: T.Protocol p => p -> P.IO GetNextMessages_result
read_GetNextMessages_result iprot = to_GetNextMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNextMessages_result)
decode_GetNextMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNextMessages_result
decode_GetNextMessages_result iprot bs = to_GetNextMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextMessages_result) bs
typemap_GetNextMessages_result :: T.TypeMap
typemap_GetNextMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetNextMessages_result :: GetNextMessages_result
default_GetNextMessages_result = GetNextMessages_result{
  getNextMessages_result_success = Vector.empty,
  getNextMessages_result_e = P.Nothing}
data GetNotificationPolicy_args = GetNotificationPolicy_args  { getNotificationPolicy_args_carrier :: CarrierCode
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationPolicy_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationPolicy_args_carrier record  
instance QC.Arbitrary GetNotificationPolicy_args where 
  arbitrary = M.liftM GetNotificationPolicy_args (QC.arbitrary)
  shrink obj | obj == default_GetNotificationPolicy_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationPolicy_args{getNotificationPolicy_args_carrier = getNotificationPolicy_args_carrier obj} then P.Nothing else P.Just $ default_GetNotificationPolicy_args{getNotificationPolicy_args_carrier = getNotificationPolicy_args_carrier obj}
    ]
from_GetNotificationPolicy_args :: GetNotificationPolicy_args -> T.ThriftVal
from_GetNotificationPolicy_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4657 -> P.Just (2, ("carrier",T.TI32 $ P.fromIntegral $ P.fromEnum _v4657))) $ getNotificationPolicy_args_carrier record
  ]
write_GetNotificationPolicy_args :: T.Protocol p => p -> GetNotificationPolicy_args -> P.IO ()
write_GetNotificationPolicy_args oprot record = T.writeVal oprot $ from_GetNotificationPolicy_args record
encode_GetNotificationPolicy_args :: T.StatelessProtocol p => p -> GetNotificationPolicy_args -> LBS.ByteString
encode_GetNotificationPolicy_args oprot record = T.serializeVal oprot $ from_GetNotificationPolicy_args record
to_GetNotificationPolicy_args :: T.ThriftVal -> GetNotificationPolicy_args
to_GetNotificationPolicy_args (T.TStruct fields) = GetNotificationPolicy_args{
  getNotificationPolicy_args_carrier = P.maybe (getNotificationPolicy_args_carrier default_GetNotificationPolicy_args) (\(_,_val4659) -> (case _val4659 of {T.TI32 _val4660 -> P.toEnum $ P.fromIntegral _val4660; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNotificationPolicy_args _ = P.error "not a struct"
read_GetNotificationPolicy_args :: T.Protocol p => p -> P.IO GetNotificationPolicy_args
read_GetNotificationPolicy_args iprot = to_GetNotificationPolicy_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_args)
decode_GetNotificationPolicy_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationPolicy_args
decode_GetNotificationPolicy_args iprot bs = to_GetNotificationPolicy_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_args) bs
typemap_GetNotificationPolicy_args :: T.TypeMap
typemap_GetNotificationPolicy_args = Map.fromList [(2,("carrier",T.T_I32))]
default_GetNotificationPolicy_args :: GetNotificationPolicy_args
default_GetNotificationPolicy_args = GetNotificationPolicy_args{
  getNotificationPolicy_args_carrier = (P.toEnum 0)}
data GetNotificationPolicy_result = GetNotificationPolicy_result  { getNotificationPolicy_result_success :: (Vector.Vector NotificationType)
  , getNotificationPolicy_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationPolicy_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationPolicy_result_success record   `H.hashWithSalt` getNotificationPolicy_result_e record  
instance QC.Arbitrary GetNotificationPolicy_result where 
  arbitrary = M.liftM GetNotificationPolicy_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNotificationPolicy_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationPolicy_result{getNotificationPolicy_result_success = getNotificationPolicy_result_success obj} then P.Nothing else P.Just $ default_GetNotificationPolicy_result{getNotificationPolicy_result_success = getNotificationPolicy_result_success obj}
    , if obj == default_GetNotificationPolicy_result{getNotificationPolicy_result_e = getNotificationPolicy_result_e obj} then P.Nothing else P.Just $ default_GetNotificationPolicy_result{getNotificationPolicy_result_e = getNotificationPolicy_result_e obj}
    ]
from_GetNotificationPolicy_result :: GetNotificationPolicy_result -> T.ThriftVal
from_GetNotificationPolicy_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4663 -> (1, ("e",from_TalkException _v4663))) <$> getNotificationPolicy_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4663 -> P.Just (0, ("success",T.TList T.T_I32 $ P.map (\_v4665 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v4665) $ Vector.toList _v4663))) $ getNotificationPolicy_result_success record
    , (\_v4663 -> (1, ("e",from_TalkException _v4663))) <$> getNotificationPolicy_result_e record
    ]
    )
write_GetNotificationPolicy_result :: T.Protocol p => p -> GetNotificationPolicy_result -> P.IO ()
write_GetNotificationPolicy_result oprot record = T.writeVal oprot $ from_GetNotificationPolicy_result record
encode_GetNotificationPolicy_result :: T.StatelessProtocol p => p -> GetNotificationPolicy_result -> LBS.ByteString
encode_GetNotificationPolicy_result oprot record = T.serializeVal oprot $ from_GetNotificationPolicy_result record
to_GetNotificationPolicy_result :: T.ThriftVal -> GetNotificationPolicy_result
to_GetNotificationPolicy_result (T.TStruct fields) = GetNotificationPolicy_result{
  getNotificationPolicy_result_success = P.maybe (getNotificationPolicy_result_success default_GetNotificationPolicy_result) (\(_,_val4667) -> (case _val4667 of {T.TList _ _val4668 -> (Vector.fromList $ P.map (\_v4669 -> (case _v4669 of {T.TI32 _val4670 -> P.toEnum $ P.fromIntegral _val4670; _ -> P.error "wrong type"})) _val4668); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNotificationPolicy_result_e = P.maybe (P.Nothing) (\(_,_val4667) -> P.Just (case _val4667 of {T.TStruct _val4671 -> (to_TalkException (T.TStruct _val4671)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNotificationPolicy_result _ = P.error "not a struct"
read_GetNotificationPolicy_result :: T.Protocol p => p -> P.IO GetNotificationPolicy_result
read_GetNotificationPolicy_result iprot = to_GetNotificationPolicy_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_result)
decode_GetNotificationPolicy_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationPolicy_result
decode_GetNotificationPolicy_result iprot bs = to_GetNotificationPolicy_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_result) bs
typemap_GetNotificationPolicy_result :: T.TypeMap
typemap_GetNotificationPolicy_result = Map.fromList [(0,("success",(T.T_LIST T.T_I32))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetNotificationPolicy_result :: GetNotificationPolicy_result
default_GetNotificationPolicy_result = GetNotificationPolicy_result{
  getNotificationPolicy_result_success = Vector.empty,
  getNotificationPolicy_result_e = P.Nothing}
data GetPreviousMessages_args = GetPreviousMessages_args  { getPreviousMessages_args_messageBoxId :: LT.Text
  , getPreviousMessages_args_endSeq :: I.Int64
  , getPreviousMessages_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreviousMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreviousMessages_args_messageBoxId record   `H.hashWithSalt` getPreviousMessages_args_endSeq record   `H.hashWithSalt` getPreviousMessages_args_messagesCount record  
instance QC.Arbitrary GetPreviousMessages_args where 
  arbitrary = M.liftM GetPreviousMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPreviousMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreviousMessages_args{getPreviousMessages_args_messageBoxId = getPreviousMessages_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetPreviousMessages_args{getPreviousMessages_args_messageBoxId = getPreviousMessages_args_messageBoxId obj}
    , if obj == default_GetPreviousMessages_args{getPreviousMessages_args_endSeq = getPreviousMessages_args_endSeq obj} then P.Nothing else P.Just $ default_GetPreviousMessages_args{getPreviousMessages_args_endSeq = getPreviousMessages_args_endSeq obj}
    , if obj == default_GetPreviousMessages_args{getPreviousMessages_args_messagesCount = getPreviousMessages_args_messagesCount obj} then P.Nothing else P.Just $ default_GetPreviousMessages_args{getPreviousMessages_args_messagesCount = getPreviousMessages_args_messagesCount obj}
    ]
from_GetPreviousMessages_args :: GetPreviousMessages_args -> T.ThriftVal
from_GetPreviousMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4674 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v4674))) $ getPreviousMessages_args_messageBoxId record
  , (\_v4674 -> P.Just (3, ("endSeq",T.TI64 _v4674))) $ getPreviousMessages_args_endSeq record
  , (\_v4674 -> P.Just (4, ("messagesCount",T.TI32 _v4674))) $ getPreviousMessages_args_messagesCount record
  ]
write_GetPreviousMessages_args :: T.Protocol p => p -> GetPreviousMessages_args -> P.IO ()
write_GetPreviousMessages_args oprot record = T.writeVal oprot $ from_GetPreviousMessages_args record
encode_GetPreviousMessages_args :: T.StatelessProtocol p => p -> GetPreviousMessages_args -> LBS.ByteString
encode_GetPreviousMessages_args oprot record = T.serializeVal oprot $ from_GetPreviousMessages_args record
to_GetPreviousMessages_args :: T.ThriftVal -> GetPreviousMessages_args
to_GetPreviousMessages_args (T.TStruct fields) = GetPreviousMessages_args{
  getPreviousMessages_args_messageBoxId = P.maybe (getPreviousMessages_args_messageBoxId default_GetPreviousMessages_args) (\(_,_val4676) -> (case _val4676 of {T.TString _val4677 -> E.decodeUtf8 _val4677; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPreviousMessages_args_endSeq = P.maybe (getPreviousMessages_args_endSeq default_GetPreviousMessages_args) (\(_,_val4676) -> (case _val4676 of {T.TI64 _val4678 -> _val4678; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPreviousMessages_args_messagesCount = P.maybe (getPreviousMessages_args_messagesCount default_GetPreviousMessages_args) (\(_,_val4676) -> (case _val4676 of {T.TI32 _val4679 -> _val4679; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetPreviousMessages_args _ = P.error "not a struct"
read_GetPreviousMessages_args :: T.Protocol p => p -> P.IO GetPreviousMessages_args
read_GetPreviousMessages_args iprot = to_GetPreviousMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPreviousMessages_args)
decode_GetPreviousMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreviousMessages_args
decode_GetPreviousMessages_args iprot bs = to_GetPreviousMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreviousMessages_args) bs
typemap_GetPreviousMessages_args :: T.TypeMap
typemap_GetPreviousMessages_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("endSeq",T.T_I64)),(4,("messagesCount",T.T_I32))]
default_GetPreviousMessages_args :: GetPreviousMessages_args
default_GetPreviousMessages_args = GetPreviousMessages_args{
  getPreviousMessages_args_messageBoxId = "",
  getPreviousMessages_args_endSeq = 0,
  getPreviousMessages_args_messagesCount = 0}
data GetPreviousMessages_result = GetPreviousMessages_result  { getPreviousMessages_result_success :: (Vector.Vector Message)
  , getPreviousMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreviousMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreviousMessages_result_success record   `H.hashWithSalt` getPreviousMessages_result_e record  
instance QC.Arbitrary GetPreviousMessages_result where 
  arbitrary = M.liftM GetPreviousMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPreviousMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreviousMessages_result{getPreviousMessages_result_success = getPreviousMessages_result_success obj} then P.Nothing else P.Just $ default_GetPreviousMessages_result{getPreviousMessages_result_success = getPreviousMessages_result_success obj}
    , if obj == default_GetPreviousMessages_result{getPreviousMessages_result_e = getPreviousMessages_result_e obj} then P.Nothing else P.Just $ default_GetPreviousMessages_result{getPreviousMessages_result_e = getPreviousMessages_result_e obj}
    ]
from_GetPreviousMessages_result :: GetPreviousMessages_result -> T.ThriftVal
from_GetPreviousMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4682 -> (1, ("e",from_TalkException _v4682))) <$> getPreviousMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4682 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v4684 -> from_Message _v4684) $ Vector.toList _v4682))) $ getPreviousMessages_result_success record
    , (\_v4682 -> (1, ("e",from_TalkException _v4682))) <$> getPreviousMessages_result_e record
    ]
    )
write_GetPreviousMessages_result :: T.Protocol p => p -> GetPreviousMessages_result -> P.IO ()
write_GetPreviousMessages_result oprot record = T.writeVal oprot $ from_GetPreviousMessages_result record
encode_GetPreviousMessages_result :: T.StatelessProtocol p => p -> GetPreviousMessages_result -> LBS.ByteString
encode_GetPreviousMessages_result oprot record = T.serializeVal oprot $ from_GetPreviousMessages_result record
to_GetPreviousMessages_result :: T.ThriftVal -> GetPreviousMessages_result
to_GetPreviousMessages_result (T.TStruct fields) = GetPreviousMessages_result{
  getPreviousMessages_result_success = P.maybe (getPreviousMessages_result_success default_GetPreviousMessages_result) (\(_,_val4686) -> (case _val4686 of {T.TList _ _val4687 -> (Vector.fromList $ P.map (\_v4688 -> (case _v4688 of {T.TStruct _val4689 -> (to_Message (T.TStruct _val4689)); _ -> P.error "wrong type"})) _val4687); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPreviousMessages_result_e = P.maybe (P.Nothing) (\(_,_val4686) -> P.Just (case _val4686 of {T.TStruct _val4690 -> (to_TalkException (T.TStruct _val4690)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPreviousMessages_result _ = P.error "not a struct"
read_GetPreviousMessages_result :: T.Protocol p => p -> P.IO GetPreviousMessages_result
read_GetPreviousMessages_result iprot = to_GetPreviousMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPreviousMessages_result)
decode_GetPreviousMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreviousMessages_result
decode_GetPreviousMessages_result iprot bs = to_GetPreviousMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreviousMessages_result) bs
typemap_GetPreviousMessages_result :: T.TypeMap
typemap_GetPreviousMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPreviousMessages_result :: GetPreviousMessages_result
default_GetPreviousMessages_result = GetPreviousMessages_result{
  getPreviousMessages_result_success = Vector.empty,
  getPreviousMessages_result_e = P.Nothing}
data GetProfile_args = GetProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetProfile_args where 
  arbitrary = QC.elements [GetProfile_args]
from_GetProfile_args :: GetProfile_args -> T.ThriftVal
from_GetProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetProfile_args :: T.Protocol p => p -> GetProfile_args -> P.IO ()
write_GetProfile_args oprot record = T.writeVal oprot $ from_GetProfile_args record
encode_GetProfile_args :: T.StatelessProtocol p => p -> GetProfile_args -> LBS.ByteString
encode_GetProfile_args oprot record = T.serializeVal oprot $ from_GetProfile_args record
to_GetProfile_args :: T.ThriftVal -> GetProfile_args
to_GetProfile_args (T.TStruct fields) = GetProfile_args{

  }
to_GetProfile_args _ = P.error "not a struct"
read_GetProfile_args :: T.Protocol p => p -> P.IO GetProfile_args
read_GetProfile_args iprot = to_GetProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProfile_args)
decode_GetProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfile_args
decode_GetProfile_args iprot bs = to_GetProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfile_args) bs
typemap_GetProfile_args :: T.TypeMap
typemap_GetProfile_args = Map.fromList []
default_GetProfile_args :: GetProfile_args
default_GetProfile_args = GetProfile_args{
}
data GetProfile_result = GetProfile_result  { getProfile_result_success :: Profile
  , getProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProfile_result_success record   `H.hashWithSalt` getProfile_result_e record  
instance QC.Arbitrary GetProfile_result where 
  arbitrary = M.liftM GetProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProfile_result{getProfile_result_success = getProfile_result_success obj} then P.Nothing else P.Just $ default_GetProfile_result{getProfile_result_success = getProfile_result_success obj}
    , if obj == default_GetProfile_result{getProfile_result_e = getProfile_result_e obj} then P.Nothing else P.Just $ default_GetProfile_result{getProfile_result_e = getProfile_result_e obj}
    ]
from_GetProfile_result :: GetProfile_result -> T.ThriftVal
from_GetProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4698 -> (1, ("e",from_TalkException _v4698))) <$> getProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4698 -> P.Just (0, ("success",from_Profile _v4698))) $ getProfile_result_success record
    , (\_v4698 -> (1, ("e",from_TalkException _v4698))) <$> getProfile_result_e record
    ]
    )
write_GetProfile_result :: T.Protocol p => p -> GetProfile_result -> P.IO ()
write_GetProfile_result oprot record = T.writeVal oprot $ from_GetProfile_result record
encode_GetProfile_result :: T.StatelessProtocol p => p -> GetProfile_result -> LBS.ByteString
encode_GetProfile_result oprot record = T.serializeVal oprot $ from_GetProfile_result record
to_GetProfile_result :: T.ThriftVal -> GetProfile_result
to_GetProfile_result (T.TStruct fields) = GetProfile_result{
  getProfile_result_success = P.maybe (getProfile_result_success default_GetProfile_result) (\(_,_val4700) -> (case _val4700 of {T.TStruct _val4701 -> (to_Profile (T.TStruct _val4701)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProfile_result_e = P.maybe (P.Nothing) (\(_,_val4700) -> P.Just (case _val4700 of {T.TStruct _val4702 -> (to_TalkException (T.TStruct _val4702)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProfile_result _ = P.error "not a struct"
read_GetProfile_result :: T.Protocol p => p -> P.IO GetProfile_result
read_GetProfile_result iprot = to_GetProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProfile_result)
decode_GetProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfile_result
decode_GetProfile_result iprot bs = to_GetProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfile_result) bs
typemap_GetProfile_result :: T.TypeMap
typemap_GetProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Profile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProfile_result :: GetProfile_result
default_GetProfile_result = GetProfile_result{
  getProfile_result_success = default_Profile,
  getProfile_result_e = P.Nothing}
data GetProximityMatchCandidateList_args = GetProximityMatchCandidateList_args  { getProximityMatchCandidateList_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidateList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidateList_args_sessionId record  
instance QC.Arbitrary GetProximityMatchCandidateList_args where 
  arbitrary = M.liftM GetProximityMatchCandidateList_args (QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidateList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidateList_args{getProximityMatchCandidateList_args_sessionId = getProximityMatchCandidateList_args_sessionId obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidateList_args{getProximityMatchCandidateList_args_sessionId = getProximityMatchCandidateList_args_sessionId obj}
    ]
from_GetProximityMatchCandidateList_args :: GetProximityMatchCandidateList_args -> T.ThriftVal
from_GetProximityMatchCandidateList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4705 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v4705))) $ getProximityMatchCandidateList_args_sessionId record
  ]
write_GetProximityMatchCandidateList_args :: T.Protocol p => p -> GetProximityMatchCandidateList_args -> P.IO ()
write_GetProximityMatchCandidateList_args oprot record = T.writeVal oprot $ from_GetProximityMatchCandidateList_args record
encode_GetProximityMatchCandidateList_args :: T.StatelessProtocol p => p -> GetProximityMatchCandidateList_args -> LBS.ByteString
encode_GetProximityMatchCandidateList_args oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidateList_args record
to_GetProximityMatchCandidateList_args :: T.ThriftVal -> GetProximityMatchCandidateList_args
to_GetProximityMatchCandidateList_args (T.TStruct fields) = GetProximityMatchCandidateList_args{
  getProximityMatchCandidateList_args_sessionId = P.maybe (getProximityMatchCandidateList_args_sessionId default_GetProximityMatchCandidateList_args) (\(_,_val4707) -> (case _val4707 of {T.TString _val4708 -> E.decodeUtf8 _val4708; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetProximityMatchCandidateList_args _ = P.error "not a struct"
read_GetProximityMatchCandidateList_args :: T.Protocol p => p -> P.IO GetProximityMatchCandidateList_args
read_GetProximityMatchCandidateList_args iprot = to_GetProximityMatchCandidateList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_args)
decode_GetProximityMatchCandidateList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidateList_args
decode_GetProximityMatchCandidateList_args iprot bs = to_GetProximityMatchCandidateList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_args) bs
typemap_GetProximityMatchCandidateList_args :: T.TypeMap
typemap_GetProximityMatchCandidateList_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_GetProximityMatchCandidateList_args :: GetProximityMatchCandidateList_args
default_GetProximityMatchCandidateList_args = GetProximityMatchCandidateList_args{
  getProximityMatchCandidateList_args_sessionId = ""}
data GetProximityMatchCandidateList_result = GetProximityMatchCandidateList_result  { getProximityMatchCandidateList_result_success :: ProximityMatchCandidateResult
  , getProximityMatchCandidateList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidateList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidateList_result_success record   `H.hashWithSalt` getProximityMatchCandidateList_result_e record  
instance QC.Arbitrary GetProximityMatchCandidateList_result where 
  arbitrary = M.liftM GetProximityMatchCandidateList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidateList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_success = getProximityMatchCandidateList_result_success obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_success = getProximityMatchCandidateList_result_success obj}
    , if obj == default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_e = getProximityMatchCandidateList_result_e obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_e = getProximityMatchCandidateList_result_e obj}
    ]
from_GetProximityMatchCandidateList_result :: GetProximityMatchCandidateList_result -> T.ThriftVal
from_GetProximityMatchCandidateList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4711 -> (1, ("e",from_TalkException _v4711))) <$> getProximityMatchCandidateList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4711 -> P.Just (0, ("success",from_ProximityMatchCandidateResult _v4711))) $ getProximityMatchCandidateList_result_success record
    , (\_v4711 -> (1, ("e",from_TalkException _v4711))) <$> getProximityMatchCandidateList_result_e record
    ]
    )
write_GetProximityMatchCandidateList_result :: T.Protocol p => p -> GetProximityMatchCandidateList_result -> P.IO ()
write_GetProximityMatchCandidateList_result oprot record = T.writeVal oprot $ from_GetProximityMatchCandidateList_result record
encode_GetProximityMatchCandidateList_result :: T.StatelessProtocol p => p -> GetProximityMatchCandidateList_result -> LBS.ByteString
encode_GetProximityMatchCandidateList_result oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidateList_result record
to_GetProximityMatchCandidateList_result :: T.ThriftVal -> GetProximityMatchCandidateList_result
to_GetProximityMatchCandidateList_result (T.TStruct fields) = GetProximityMatchCandidateList_result{
  getProximityMatchCandidateList_result_success = P.maybe (getProximityMatchCandidateList_result_success default_GetProximityMatchCandidateList_result) (\(_,_val4713) -> (case _val4713 of {T.TStruct _val4714 -> (to_ProximityMatchCandidateResult (T.TStruct _val4714)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProximityMatchCandidateList_result_e = P.maybe (P.Nothing) (\(_,_val4713) -> P.Just (case _val4713 of {T.TStruct _val4715 -> (to_TalkException (T.TStruct _val4715)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProximityMatchCandidateList_result _ = P.error "not a struct"
read_GetProximityMatchCandidateList_result :: T.Protocol p => p -> P.IO GetProximityMatchCandidateList_result
read_GetProximityMatchCandidateList_result iprot = to_GetProximityMatchCandidateList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_result)
decode_GetProximityMatchCandidateList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidateList_result
decode_GetProximityMatchCandidateList_result iprot bs = to_GetProximityMatchCandidateList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_result) bs
typemap_GetProximityMatchCandidateList_result :: T.TypeMap
typemap_GetProximityMatchCandidateList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProximityMatchCandidateResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProximityMatchCandidateList_result :: GetProximityMatchCandidateList_result
default_GetProximityMatchCandidateList_result = GetProximityMatchCandidateList_result{
  getProximityMatchCandidateList_result_success = default_ProximityMatchCandidateResult,
  getProximityMatchCandidateList_result_e = P.Nothing}
data GetProximityMatchCandidates_args = GetProximityMatchCandidates_args  { getProximityMatchCandidates_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidates_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidates_args_sessionId record  
instance QC.Arbitrary GetProximityMatchCandidates_args where 
  arbitrary = M.liftM GetProximityMatchCandidates_args (QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidates_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidates_args{getProximityMatchCandidates_args_sessionId = getProximityMatchCandidates_args_sessionId obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidates_args{getProximityMatchCandidates_args_sessionId = getProximityMatchCandidates_args_sessionId obj}
    ]
from_GetProximityMatchCandidates_args :: GetProximityMatchCandidates_args -> T.ThriftVal
from_GetProximityMatchCandidates_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4718 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v4718))) $ getProximityMatchCandidates_args_sessionId record
  ]
write_GetProximityMatchCandidates_args :: T.Protocol p => p -> GetProximityMatchCandidates_args -> P.IO ()
write_GetProximityMatchCandidates_args oprot record = T.writeVal oprot $ from_GetProximityMatchCandidates_args record
encode_GetProximityMatchCandidates_args :: T.StatelessProtocol p => p -> GetProximityMatchCandidates_args -> LBS.ByteString
encode_GetProximityMatchCandidates_args oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidates_args record
to_GetProximityMatchCandidates_args :: T.ThriftVal -> GetProximityMatchCandidates_args
to_GetProximityMatchCandidates_args (T.TStruct fields) = GetProximityMatchCandidates_args{
  getProximityMatchCandidates_args_sessionId = P.maybe (getProximityMatchCandidates_args_sessionId default_GetProximityMatchCandidates_args) (\(_,_val4720) -> (case _val4720 of {T.TString _val4721 -> E.decodeUtf8 _val4721; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetProximityMatchCandidates_args _ = P.error "not a struct"
read_GetProximityMatchCandidates_args :: T.Protocol p => p -> P.IO GetProximityMatchCandidates_args
read_GetProximityMatchCandidates_args iprot = to_GetProximityMatchCandidates_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_args)
decode_GetProximityMatchCandidates_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidates_args
decode_GetProximityMatchCandidates_args iprot bs = to_GetProximityMatchCandidates_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_args) bs
typemap_GetProximityMatchCandidates_args :: T.TypeMap
typemap_GetProximityMatchCandidates_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_GetProximityMatchCandidates_args :: GetProximityMatchCandidates_args
default_GetProximityMatchCandidates_args = GetProximityMatchCandidates_args{
  getProximityMatchCandidates_args_sessionId = ""}
data GetProximityMatchCandidates_result = GetProximityMatchCandidates_result  { getProximityMatchCandidates_result_success :: (Set.HashSet Contact)
  , getProximityMatchCandidates_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidates_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidates_result_success record   `H.hashWithSalt` getProximityMatchCandidates_result_e record  
instance QC.Arbitrary GetProximityMatchCandidates_result where 
  arbitrary = M.liftM GetProximityMatchCandidates_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidates_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_success = getProximityMatchCandidates_result_success obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_success = getProximityMatchCandidates_result_success obj}
    , if obj == default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_e = getProximityMatchCandidates_result_e obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_e = getProximityMatchCandidates_result_e obj}
    ]
from_GetProximityMatchCandidates_result :: GetProximityMatchCandidates_result -> T.ThriftVal
from_GetProximityMatchCandidates_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4724 -> (1, ("e",from_TalkException _v4724))) <$> getProximityMatchCandidates_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4724 -> P.Just (0, ("success",T.TSet (T.T_STRUCT typemap_Contact) $ P.map (\_v4726 -> from_Contact _v4726) $ Set.toList _v4724))) $ getProximityMatchCandidates_result_success record
    , (\_v4724 -> (1, ("e",from_TalkException _v4724))) <$> getProximityMatchCandidates_result_e record
    ]
    )
write_GetProximityMatchCandidates_result :: T.Protocol p => p -> GetProximityMatchCandidates_result -> P.IO ()
write_GetProximityMatchCandidates_result oprot record = T.writeVal oprot $ from_GetProximityMatchCandidates_result record
encode_GetProximityMatchCandidates_result :: T.StatelessProtocol p => p -> GetProximityMatchCandidates_result -> LBS.ByteString
encode_GetProximityMatchCandidates_result oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidates_result record
to_GetProximityMatchCandidates_result :: T.ThriftVal -> GetProximityMatchCandidates_result
to_GetProximityMatchCandidates_result (T.TStruct fields) = GetProximityMatchCandidates_result{
  getProximityMatchCandidates_result_success = P.maybe (getProximityMatchCandidates_result_success default_GetProximityMatchCandidates_result) (\(_,_val4728) -> (case _val4728 of {T.TSet _ _val4729 -> (Set.fromList $ P.map (\_v4730 -> (case _v4730 of {T.TStruct _val4731 -> (to_Contact (T.TStruct _val4731)); _ -> P.error "wrong type"})) _val4729); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProximityMatchCandidates_result_e = P.maybe (P.Nothing) (\(_,_val4728) -> P.Just (case _val4728 of {T.TStruct _val4732 -> (to_TalkException (T.TStruct _val4732)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProximityMatchCandidates_result _ = P.error "not a struct"
read_GetProximityMatchCandidates_result :: T.Protocol p => p -> P.IO GetProximityMatchCandidates_result
read_GetProximityMatchCandidates_result iprot = to_GetProximityMatchCandidates_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_result)
decode_GetProximityMatchCandidates_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidates_result
decode_GetProximityMatchCandidates_result iprot bs = to_GetProximityMatchCandidates_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_result) bs
typemap_GetProximityMatchCandidates_result :: T.TypeMap
typemap_GetProximityMatchCandidates_result = Map.fromList [(0,("success",(T.T_SET (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProximityMatchCandidates_result :: GetProximityMatchCandidates_result
default_GetProximityMatchCandidates_result = GetProximityMatchCandidates_result{
  getProximityMatchCandidates_result_success = Set.empty,
  getProximityMatchCandidates_result_e = P.Nothing}
data GetRecentMessages_args = GetRecentMessages_args  { getRecentMessages_args_messageBoxId :: LT.Text
  , getRecentMessages_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecentMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecentMessages_args_messageBoxId record   `H.hashWithSalt` getRecentMessages_args_messagesCount record  
instance QC.Arbitrary GetRecentMessages_args where 
  arbitrary = M.liftM GetRecentMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetRecentMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecentMessages_args{getRecentMessages_args_messageBoxId = getRecentMessages_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetRecentMessages_args{getRecentMessages_args_messageBoxId = getRecentMessages_args_messageBoxId obj}
    , if obj == default_GetRecentMessages_args{getRecentMessages_args_messagesCount = getRecentMessages_args_messagesCount obj} then P.Nothing else P.Just $ default_GetRecentMessages_args{getRecentMessages_args_messagesCount = getRecentMessages_args_messagesCount obj}
    ]
from_GetRecentMessages_args :: GetRecentMessages_args -> T.ThriftVal
from_GetRecentMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4735 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v4735))) $ getRecentMessages_args_messageBoxId record
  , (\_v4735 -> P.Just (3, ("messagesCount",T.TI32 _v4735))) $ getRecentMessages_args_messagesCount record
  ]
write_GetRecentMessages_args :: T.Protocol p => p -> GetRecentMessages_args -> P.IO ()
write_GetRecentMessages_args oprot record = T.writeVal oprot $ from_GetRecentMessages_args record
encode_GetRecentMessages_args :: T.StatelessProtocol p => p -> GetRecentMessages_args -> LBS.ByteString
encode_GetRecentMessages_args oprot record = T.serializeVal oprot $ from_GetRecentMessages_args record
to_GetRecentMessages_args :: T.ThriftVal -> GetRecentMessages_args
to_GetRecentMessages_args (T.TStruct fields) = GetRecentMessages_args{
  getRecentMessages_args_messageBoxId = P.maybe (getRecentMessages_args_messageBoxId default_GetRecentMessages_args) (\(_,_val4737) -> (case _val4737 of {T.TString _val4738 -> E.decodeUtf8 _val4738; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getRecentMessages_args_messagesCount = P.maybe (getRecentMessages_args_messagesCount default_GetRecentMessages_args) (\(_,_val4737) -> (case _val4737 of {T.TI32 _val4739 -> _val4739; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetRecentMessages_args _ = P.error "not a struct"
read_GetRecentMessages_args :: T.Protocol p => p -> P.IO GetRecentMessages_args
read_GetRecentMessages_args iprot = to_GetRecentMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRecentMessages_args)
decode_GetRecentMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecentMessages_args
decode_GetRecentMessages_args iprot bs = to_GetRecentMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecentMessages_args) bs
typemap_GetRecentMessages_args :: T.TypeMap
typemap_GetRecentMessages_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("messagesCount",T.T_I32))]
default_GetRecentMessages_args :: GetRecentMessages_args
default_GetRecentMessages_args = GetRecentMessages_args{
  getRecentMessages_args_messageBoxId = "",
  getRecentMessages_args_messagesCount = 0}
data GetRecentMessages_result = GetRecentMessages_result  { getRecentMessages_result_success :: (Vector.Vector Message)
  , getRecentMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecentMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecentMessages_result_success record   `H.hashWithSalt` getRecentMessages_result_e record  
instance QC.Arbitrary GetRecentMessages_result where 
  arbitrary = M.liftM GetRecentMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRecentMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecentMessages_result{getRecentMessages_result_success = getRecentMessages_result_success obj} then P.Nothing else P.Just $ default_GetRecentMessages_result{getRecentMessages_result_success = getRecentMessages_result_success obj}
    , if obj == default_GetRecentMessages_result{getRecentMessages_result_e = getRecentMessages_result_e obj} then P.Nothing else P.Just $ default_GetRecentMessages_result{getRecentMessages_result_e = getRecentMessages_result_e obj}
    ]
from_GetRecentMessages_result :: GetRecentMessages_result -> T.ThriftVal
from_GetRecentMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4742 -> (1, ("e",from_TalkException _v4742))) <$> getRecentMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4742 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v4744 -> from_Message _v4744) $ Vector.toList _v4742))) $ getRecentMessages_result_success record
    , (\_v4742 -> (1, ("e",from_TalkException _v4742))) <$> getRecentMessages_result_e record
    ]
    )
write_GetRecentMessages_result :: T.Protocol p => p -> GetRecentMessages_result -> P.IO ()
write_GetRecentMessages_result oprot record = T.writeVal oprot $ from_GetRecentMessages_result record
encode_GetRecentMessages_result :: T.StatelessProtocol p => p -> GetRecentMessages_result -> LBS.ByteString
encode_GetRecentMessages_result oprot record = T.serializeVal oprot $ from_GetRecentMessages_result record
to_GetRecentMessages_result :: T.ThriftVal -> GetRecentMessages_result
to_GetRecentMessages_result (T.TStruct fields) = GetRecentMessages_result{
  getRecentMessages_result_success = P.maybe (getRecentMessages_result_success default_GetRecentMessages_result) (\(_,_val4746) -> (case _val4746 of {T.TList _ _val4747 -> (Vector.fromList $ P.map (\_v4748 -> (case _v4748 of {T.TStruct _val4749 -> (to_Message (T.TStruct _val4749)); _ -> P.error "wrong type"})) _val4747); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRecentMessages_result_e = P.maybe (P.Nothing) (\(_,_val4746) -> P.Just (case _val4746 of {T.TStruct _val4750 -> (to_TalkException (T.TStruct _val4750)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRecentMessages_result _ = P.error "not a struct"
read_GetRecentMessages_result :: T.Protocol p => p -> P.IO GetRecentMessages_result
read_GetRecentMessages_result iprot = to_GetRecentMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRecentMessages_result)
decode_GetRecentMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecentMessages_result
decode_GetRecentMessages_result iprot bs = to_GetRecentMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecentMessages_result) bs
typemap_GetRecentMessages_result :: T.TypeMap
typemap_GetRecentMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRecentMessages_result :: GetRecentMessages_result
default_GetRecentMessages_result = GetRecentMessages_result{
  getRecentMessages_result_success = Vector.empty,
  getRecentMessages_result_e = P.Nothing}
data GetRecommendationIds_args = GetRecommendationIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecommendationIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetRecommendationIds_args where 
  arbitrary = QC.elements [GetRecommendationIds_args]
from_GetRecommendationIds_args :: GetRecommendationIds_args -> T.ThriftVal
from_GetRecommendationIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetRecommendationIds_args :: T.Protocol p => p -> GetRecommendationIds_args -> P.IO ()
write_GetRecommendationIds_args oprot record = T.writeVal oprot $ from_GetRecommendationIds_args record
encode_GetRecommendationIds_args :: T.StatelessProtocol p => p -> GetRecommendationIds_args -> LBS.ByteString
encode_GetRecommendationIds_args oprot record = T.serializeVal oprot $ from_GetRecommendationIds_args record
to_GetRecommendationIds_args :: T.ThriftVal -> GetRecommendationIds_args
to_GetRecommendationIds_args (T.TStruct fields) = GetRecommendationIds_args{

  }
to_GetRecommendationIds_args _ = P.error "not a struct"
read_GetRecommendationIds_args :: T.Protocol p => p -> P.IO GetRecommendationIds_args
read_GetRecommendationIds_args iprot = to_GetRecommendationIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRecommendationIds_args)
decode_GetRecommendationIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecommendationIds_args
decode_GetRecommendationIds_args iprot bs = to_GetRecommendationIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecommendationIds_args) bs
typemap_GetRecommendationIds_args :: T.TypeMap
typemap_GetRecommendationIds_args = Map.fromList []
default_GetRecommendationIds_args :: GetRecommendationIds_args
default_GetRecommendationIds_args = GetRecommendationIds_args{
}
data GetRecommendationIds_result = GetRecommendationIds_result  { getRecommendationIds_result_success :: (Vector.Vector LT.Text)
  , getRecommendationIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecommendationIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecommendationIds_result_success record   `H.hashWithSalt` getRecommendationIds_result_e record  
instance QC.Arbitrary GetRecommendationIds_result where 
  arbitrary = M.liftM GetRecommendationIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRecommendationIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecommendationIds_result{getRecommendationIds_result_success = getRecommendationIds_result_success obj} then P.Nothing else P.Just $ default_GetRecommendationIds_result{getRecommendationIds_result_success = getRecommendationIds_result_success obj}
    , if obj == default_GetRecommendationIds_result{getRecommendationIds_result_e = getRecommendationIds_result_e obj} then P.Nothing else P.Just $ default_GetRecommendationIds_result{getRecommendationIds_result_e = getRecommendationIds_result_e obj}
    ]
from_GetRecommendationIds_result :: GetRecommendationIds_result -> T.ThriftVal
from_GetRecommendationIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4758 -> (1, ("e",from_TalkException _v4758))) <$> getRecommendationIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4758 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4760 -> T.TString $ E.encodeUtf8 _v4760) $ Vector.toList _v4758))) $ getRecommendationIds_result_success record
    , (\_v4758 -> (1, ("e",from_TalkException _v4758))) <$> getRecommendationIds_result_e record
    ]
    )
write_GetRecommendationIds_result :: T.Protocol p => p -> GetRecommendationIds_result -> P.IO ()
write_GetRecommendationIds_result oprot record = T.writeVal oprot $ from_GetRecommendationIds_result record
encode_GetRecommendationIds_result :: T.StatelessProtocol p => p -> GetRecommendationIds_result -> LBS.ByteString
encode_GetRecommendationIds_result oprot record = T.serializeVal oprot $ from_GetRecommendationIds_result record
to_GetRecommendationIds_result :: T.ThriftVal -> GetRecommendationIds_result
to_GetRecommendationIds_result (T.TStruct fields) = GetRecommendationIds_result{
  getRecommendationIds_result_success = P.maybe (getRecommendationIds_result_success default_GetRecommendationIds_result) (\(_,_val4762) -> (case _val4762 of {T.TList _ _val4763 -> (Vector.fromList $ P.map (\_v4764 -> (case _v4764 of {T.TString _val4765 -> E.decodeUtf8 _val4765; _ -> P.error "wrong type"})) _val4763); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRecommendationIds_result_e = P.maybe (P.Nothing) (\(_,_val4762) -> P.Just (case _val4762 of {T.TStruct _val4766 -> (to_TalkException (T.TStruct _val4766)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRecommendationIds_result _ = P.error "not a struct"
read_GetRecommendationIds_result :: T.Protocol p => p -> P.IO GetRecommendationIds_result
read_GetRecommendationIds_result iprot = to_GetRecommendationIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRecommendationIds_result)
decode_GetRecommendationIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecommendationIds_result
decode_GetRecommendationIds_result iprot bs = to_GetRecommendationIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecommendationIds_result) bs
typemap_GetRecommendationIds_result :: T.TypeMap
typemap_GetRecommendationIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRecommendationIds_result :: GetRecommendationIds_result
default_GetRecommendationIds_result = GetRecommendationIds_result{
  getRecommendationIds_result_success = Vector.empty,
  getRecommendationIds_result_e = P.Nothing}
data GetRoom_args = GetRoom_args  { getRoom_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoom_args_roomId record  
instance QC.Arbitrary GetRoom_args where 
  arbitrary = M.liftM GetRoom_args (QC.arbitrary)
  shrink obj | obj == default_GetRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoom_args{getRoom_args_roomId = getRoom_args_roomId obj} then P.Nothing else P.Just $ default_GetRoom_args{getRoom_args_roomId = getRoom_args_roomId obj}
    ]
from_GetRoom_args :: GetRoom_args -> T.ThriftVal
from_GetRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4769 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v4769))) $ getRoom_args_roomId record
  ]
write_GetRoom_args :: T.Protocol p => p -> GetRoom_args -> P.IO ()
write_GetRoom_args oprot record = T.writeVal oprot $ from_GetRoom_args record
encode_GetRoom_args :: T.StatelessProtocol p => p -> GetRoom_args -> LBS.ByteString
encode_GetRoom_args oprot record = T.serializeVal oprot $ from_GetRoom_args record
to_GetRoom_args :: T.ThriftVal -> GetRoom_args
to_GetRoom_args (T.TStruct fields) = GetRoom_args{
  getRoom_args_roomId = P.maybe (getRoom_args_roomId default_GetRoom_args) (\(_,_val4771) -> (case _val4771 of {T.TString _val4772 -> E.decodeUtf8 _val4772; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetRoom_args _ = P.error "not a struct"
read_GetRoom_args :: T.Protocol p => p -> P.IO GetRoom_args
read_GetRoom_args iprot = to_GetRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRoom_args)
decode_GetRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoom_args
decode_GetRoom_args iprot bs = to_GetRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoom_args) bs
typemap_GetRoom_args :: T.TypeMap
typemap_GetRoom_args = Map.fromList [(2,("roomId",T.T_STRING))]
default_GetRoom_args :: GetRoom_args
default_GetRoom_args = GetRoom_args{
  getRoom_args_roomId = ""}
data GetRoom_result = GetRoom_result  { getRoom_result_success :: Room
  , getRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoom_result_success record   `H.hashWithSalt` getRoom_result_e record  
instance QC.Arbitrary GetRoom_result where 
  arbitrary = M.liftM GetRoom_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoom_result{getRoom_result_success = getRoom_result_success obj} then P.Nothing else P.Just $ default_GetRoom_result{getRoom_result_success = getRoom_result_success obj}
    , if obj == default_GetRoom_result{getRoom_result_e = getRoom_result_e obj} then P.Nothing else P.Just $ default_GetRoom_result{getRoom_result_e = getRoom_result_e obj}
    ]
from_GetRoom_result :: GetRoom_result -> T.ThriftVal
from_GetRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4775 -> (1, ("e",from_TalkException _v4775))) <$> getRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4775 -> P.Just (0, ("success",from_Room _v4775))) $ getRoom_result_success record
    , (\_v4775 -> (1, ("e",from_TalkException _v4775))) <$> getRoom_result_e record
    ]
    )
write_GetRoom_result :: T.Protocol p => p -> GetRoom_result -> P.IO ()
write_GetRoom_result oprot record = T.writeVal oprot $ from_GetRoom_result record
encode_GetRoom_result :: T.StatelessProtocol p => p -> GetRoom_result -> LBS.ByteString
encode_GetRoom_result oprot record = T.serializeVal oprot $ from_GetRoom_result record
to_GetRoom_result :: T.ThriftVal -> GetRoom_result
to_GetRoom_result (T.TStruct fields) = GetRoom_result{
  getRoom_result_success = P.maybe (getRoom_result_success default_GetRoom_result) (\(_,_val4777) -> (case _val4777 of {T.TStruct _val4778 -> (to_Room (T.TStruct _val4778)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRoom_result_e = P.maybe (P.Nothing) (\(_,_val4777) -> P.Just (case _val4777 of {T.TStruct _val4779 -> (to_TalkException (T.TStruct _val4779)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoom_result _ = P.error "not a struct"
read_GetRoom_result :: T.Protocol p => p -> P.IO GetRoom_result
read_GetRoom_result iprot = to_GetRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRoom_result)
decode_GetRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoom_result
decode_GetRoom_result iprot bs = to_GetRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoom_result) bs
typemap_GetRoom_result :: T.TypeMap
typemap_GetRoom_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRoom_result :: GetRoom_result
default_GetRoom_result = GetRoom_result{
  getRoom_result_success = default_Room,
  getRoom_result_e = P.Nothing}
data GetRSAKeyInfo_args = GetRSAKeyInfo_args  { getRSAKeyInfo_args_provider :: IdentityProvider
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRSAKeyInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRSAKeyInfo_args_provider record  
instance QC.Arbitrary GetRSAKeyInfo_args where 
  arbitrary = M.liftM GetRSAKeyInfo_args (QC.arbitrary)
  shrink obj | obj == default_GetRSAKeyInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRSAKeyInfo_args{getRSAKeyInfo_args_provider = getRSAKeyInfo_args_provider obj} then P.Nothing else P.Just $ default_GetRSAKeyInfo_args{getRSAKeyInfo_args_provider = getRSAKeyInfo_args_provider obj}
    ]
from_GetRSAKeyInfo_args :: GetRSAKeyInfo_args -> T.ThriftVal
from_GetRSAKeyInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4782 -> P.Just (2, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v4782))) $ getRSAKeyInfo_args_provider record
  ]
write_GetRSAKeyInfo_args :: T.Protocol p => p -> GetRSAKeyInfo_args -> P.IO ()
write_GetRSAKeyInfo_args oprot record = T.writeVal oprot $ from_GetRSAKeyInfo_args record
encode_GetRSAKeyInfo_args :: T.StatelessProtocol p => p -> GetRSAKeyInfo_args -> LBS.ByteString
encode_GetRSAKeyInfo_args oprot record = T.serializeVal oprot $ from_GetRSAKeyInfo_args record
to_GetRSAKeyInfo_args :: T.ThriftVal -> GetRSAKeyInfo_args
to_GetRSAKeyInfo_args (T.TStruct fields) = GetRSAKeyInfo_args{
  getRSAKeyInfo_args_provider = P.maybe (getRSAKeyInfo_args_provider default_GetRSAKeyInfo_args) (\(_,_val4784) -> (case _val4784 of {T.TI32 _val4785 -> P.toEnum $ P.fromIntegral _val4785; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetRSAKeyInfo_args _ = P.error "not a struct"
read_GetRSAKeyInfo_args :: T.Protocol p => p -> P.IO GetRSAKeyInfo_args
read_GetRSAKeyInfo_args iprot = to_GetRSAKeyInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_args)
decode_GetRSAKeyInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRSAKeyInfo_args
decode_GetRSAKeyInfo_args iprot bs = to_GetRSAKeyInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_args) bs
typemap_GetRSAKeyInfo_args :: T.TypeMap
typemap_GetRSAKeyInfo_args = Map.fromList [(2,("provider",T.T_I32))]
default_GetRSAKeyInfo_args :: GetRSAKeyInfo_args
default_GetRSAKeyInfo_args = GetRSAKeyInfo_args{
  getRSAKeyInfo_args_provider = (P.toEnum 0)}
data GetRSAKeyInfo_result = GetRSAKeyInfo_result  { getRSAKeyInfo_result_success :: RSAKey
  , getRSAKeyInfo_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRSAKeyInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRSAKeyInfo_result_success record   `H.hashWithSalt` getRSAKeyInfo_result_e record  
instance QC.Arbitrary GetRSAKeyInfo_result where 
  arbitrary = M.liftM GetRSAKeyInfo_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRSAKeyInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRSAKeyInfo_result{getRSAKeyInfo_result_success = getRSAKeyInfo_result_success obj} then P.Nothing else P.Just $ default_GetRSAKeyInfo_result{getRSAKeyInfo_result_success = getRSAKeyInfo_result_success obj}
    , if obj == default_GetRSAKeyInfo_result{getRSAKeyInfo_result_e = getRSAKeyInfo_result_e obj} then P.Nothing else P.Just $ default_GetRSAKeyInfo_result{getRSAKeyInfo_result_e = getRSAKeyInfo_result_e obj}
    ]
from_GetRSAKeyInfo_result :: GetRSAKeyInfo_result -> T.ThriftVal
from_GetRSAKeyInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4788 -> (1, ("e",from_TalkException _v4788))) <$> getRSAKeyInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4788 -> P.Just (0, ("success",from_RSAKey _v4788))) $ getRSAKeyInfo_result_success record
    , (\_v4788 -> (1, ("e",from_TalkException _v4788))) <$> getRSAKeyInfo_result_e record
    ]
    )
write_GetRSAKeyInfo_result :: T.Protocol p => p -> GetRSAKeyInfo_result -> P.IO ()
write_GetRSAKeyInfo_result oprot record = T.writeVal oprot $ from_GetRSAKeyInfo_result record
encode_GetRSAKeyInfo_result :: T.StatelessProtocol p => p -> GetRSAKeyInfo_result -> LBS.ByteString
encode_GetRSAKeyInfo_result oprot record = T.serializeVal oprot $ from_GetRSAKeyInfo_result record
to_GetRSAKeyInfo_result :: T.ThriftVal -> GetRSAKeyInfo_result
to_GetRSAKeyInfo_result (T.TStruct fields) = GetRSAKeyInfo_result{
  getRSAKeyInfo_result_success = P.maybe (getRSAKeyInfo_result_success default_GetRSAKeyInfo_result) (\(_,_val4790) -> (case _val4790 of {T.TStruct _val4791 -> (to_RSAKey (T.TStruct _val4791)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRSAKeyInfo_result_e = P.maybe (P.Nothing) (\(_,_val4790) -> P.Just (case _val4790 of {T.TStruct _val4792 -> (to_TalkException (T.TStruct _val4792)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRSAKeyInfo_result _ = P.error "not a struct"
read_GetRSAKeyInfo_result :: T.Protocol p => p -> P.IO GetRSAKeyInfo_result
read_GetRSAKeyInfo_result iprot = to_GetRSAKeyInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_result)
decode_GetRSAKeyInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRSAKeyInfo_result
decode_GetRSAKeyInfo_result iprot bs = to_GetRSAKeyInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_result) bs
typemap_GetRSAKeyInfo_result :: T.TypeMap
typemap_GetRSAKeyInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RSAKey))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRSAKeyInfo_result :: GetRSAKeyInfo_result
default_GetRSAKeyInfo_result = GetRSAKeyInfo_result{
  getRSAKeyInfo_result_success = default_RSAKey,
  getRSAKeyInfo_result_e = P.Nothing}
data GetServerTime_args = GetServerTime_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetServerTime_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetServerTime_args where 
  arbitrary = QC.elements [GetServerTime_args]
from_GetServerTime_args :: GetServerTime_args -> T.ThriftVal
from_GetServerTime_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetServerTime_args :: T.Protocol p => p -> GetServerTime_args -> P.IO ()
write_GetServerTime_args oprot record = T.writeVal oprot $ from_GetServerTime_args record
encode_GetServerTime_args :: T.StatelessProtocol p => p -> GetServerTime_args -> LBS.ByteString
encode_GetServerTime_args oprot record = T.serializeVal oprot $ from_GetServerTime_args record
to_GetServerTime_args :: T.ThriftVal -> GetServerTime_args
to_GetServerTime_args (T.TStruct fields) = GetServerTime_args{

  }
to_GetServerTime_args _ = P.error "not a struct"
read_GetServerTime_args :: T.Protocol p => p -> P.IO GetServerTime_args
read_GetServerTime_args iprot = to_GetServerTime_args <$> T.readVal iprot (T.T_STRUCT typemap_GetServerTime_args)
decode_GetServerTime_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetServerTime_args
decode_GetServerTime_args iprot bs = to_GetServerTime_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetServerTime_args) bs
typemap_GetServerTime_args :: T.TypeMap
typemap_GetServerTime_args = Map.fromList []
default_GetServerTime_args :: GetServerTime_args
default_GetServerTime_args = GetServerTime_args{
}
data GetServerTime_result = GetServerTime_result  { getServerTime_result_success :: I.Int64
  , getServerTime_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetServerTime_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getServerTime_result_success record   `H.hashWithSalt` getServerTime_result_e record  
instance QC.Arbitrary GetServerTime_result where 
  arbitrary = M.liftM GetServerTime_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetServerTime_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetServerTime_result{getServerTime_result_success = getServerTime_result_success obj} then P.Nothing else P.Just $ default_GetServerTime_result{getServerTime_result_success = getServerTime_result_success obj}
    , if obj == default_GetServerTime_result{getServerTime_result_e = getServerTime_result_e obj} then P.Nothing else P.Just $ default_GetServerTime_result{getServerTime_result_e = getServerTime_result_e obj}
    ]
from_GetServerTime_result :: GetServerTime_result -> T.ThriftVal
from_GetServerTime_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4800 -> (1, ("e",from_TalkException _v4800))) <$> getServerTime_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4800 -> P.Just (0, ("success",T.TI64 _v4800))) $ getServerTime_result_success record
    , (\_v4800 -> (1, ("e",from_TalkException _v4800))) <$> getServerTime_result_e record
    ]
    )
write_GetServerTime_result :: T.Protocol p => p -> GetServerTime_result -> P.IO ()
write_GetServerTime_result oprot record = T.writeVal oprot $ from_GetServerTime_result record
encode_GetServerTime_result :: T.StatelessProtocol p => p -> GetServerTime_result -> LBS.ByteString
encode_GetServerTime_result oprot record = T.serializeVal oprot $ from_GetServerTime_result record
to_GetServerTime_result :: T.ThriftVal -> GetServerTime_result
to_GetServerTime_result (T.TStruct fields) = GetServerTime_result{
  getServerTime_result_success = P.maybe (getServerTime_result_success default_GetServerTime_result) (\(_,_val4802) -> (case _val4802 of {T.TI64 _val4803 -> _val4803; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getServerTime_result_e = P.maybe (P.Nothing) (\(_,_val4802) -> P.Just (case _val4802 of {T.TStruct _val4804 -> (to_TalkException (T.TStruct _val4804)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetServerTime_result _ = P.error "not a struct"
read_GetServerTime_result :: T.Protocol p => p -> P.IO GetServerTime_result
read_GetServerTime_result iprot = to_GetServerTime_result <$> T.readVal iprot (T.T_STRUCT typemap_GetServerTime_result)
decode_GetServerTime_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetServerTime_result
decode_GetServerTime_result iprot bs = to_GetServerTime_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetServerTime_result) bs
typemap_GetServerTime_result :: T.TypeMap
typemap_GetServerTime_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetServerTime_result :: GetServerTime_result
default_GetServerTime_result = GetServerTime_result{
  getServerTime_result_success = 0,
  getServerTime_result_e = P.Nothing}
data GetSessions_args = GetSessions_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSessions_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSessions_args where 
  arbitrary = QC.elements [GetSessions_args]
from_GetSessions_args :: GetSessions_args -> T.ThriftVal
from_GetSessions_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSessions_args :: T.Protocol p => p -> GetSessions_args -> P.IO ()
write_GetSessions_args oprot record = T.writeVal oprot $ from_GetSessions_args record
encode_GetSessions_args :: T.StatelessProtocol p => p -> GetSessions_args -> LBS.ByteString
encode_GetSessions_args oprot record = T.serializeVal oprot $ from_GetSessions_args record
to_GetSessions_args :: T.ThriftVal -> GetSessions_args
to_GetSessions_args (T.TStruct fields) = GetSessions_args{

  }
to_GetSessions_args _ = P.error "not a struct"
read_GetSessions_args :: T.Protocol p => p -> P.IO GetSessions_args
read_GetSessions_args iprot = to_GetSessions_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSessions_args)
decode_GetSessions_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSessions_args
decode_GetSessions_args iprot bs = to_GetSessions_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSessions_args) bs
typemap_GetSessions_args :: T.TypeMap
typemap_GetSessions_args = Map.fromList []
default_GetSessions_args :: GetSessions_args
default_GetSessions_args = GetSessions_args{
}
data GetSessions_result = GetSessions_result  { getSessions_result_success :: (Vector.Vector LoginSession)
  , getSessions_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSessions_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSessions_result_success record   `H.hashWithSalt` getSessions_result_e record  
instance QC.Arbitrary GetSessions_result where 
  arbitrary = M.liftM GetSessions_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSessions_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSessions_result{getSessions_result_success = getSessions_result_success obj} then P.Nothing else P.Just $ default_GetSessions_result{getSessions_result_success = getSessions_result_success obj}
    , if obj == default_GetSessions_result{getSessions_result_e = getSessions_result_e obj} then P.Nothing else P.Just $ default_GetSessions_result{getSessions_result_e = getSessions_result_e obj}
    ]
from_GetSessions_result :: GetSessions_result -> T.ThriftVal
from_GetSessions_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4812 -> (1, ("e",from_TalkException _v4812))) <$> getSessions_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4812 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_LoginSession) $ P.map (\_v4814 -> from_LoginSession _v4814) $ Vector.toList _v4812))) $ getSessions_result_success record
    , (\_v4812 -> (1, ("e",from_TalkException _v4812))) <$> getSessions_result_e record
    ]
    )
write_GetSessions_result :: T.Protocol p => p -> GetSessions_result -> P.IO ()
write_GetSessions_result oprot record = T.writeVal oprot $ from_GetSessions_result record
encode_GetSessions_result :: T.StatelessProtocol p => p -> GetSessions_result -> LBS.ByteString
encode_GetSessions_result oprot record = T.serializeVal oprot $ from_GetSessions_result record
to_GetSessions_result :: T.ThriftVal -> GetSessions_result
to_GetSessions_result (T.TStruct fields) = GetSessions_result{
  getSessions_result_success = P.maybe (getSessions_result_success default_GetSessions_result) (\(_,_val4816) -> (case _val4816 of {T.TList _ _val4817 -> (Vector.fromList $ P.map (\_v4818 -> (case _v4818 of {T.TStruct _val4819 -> (to_LoginSession (T.TStruct _val4819)); _ -> P.error "wrong type"})) _val4817); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSessions_result_e = P.maybe (P.Nothing) (\(_,_val4816) -> P.Just (case _val4816 of {T.TStruct _val4820 -> (to_TalkException (T.TStruct _val4820)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSessions_result _ = P.error "not a struct"
read_GetSessions_result :: T.Protocol p => p -> P.IO GetSessions_result
read_GetSessions_result iprot = to_GetSessions_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSessions_result)
decode_GetSessions_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSessions_result
decode_GetSessions_result iprot bs = to_GetSessions_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSessions_result) bs
typemap_GetSessions_result :: T.TypeMap
typemap_GetSessions_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_LoginSession)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSessions_result :: GetSessions_result
default_GetSessions_result = GetSessions_result{
  getSessions_result_success = Vector.empty,
  getSessions_result_e = P.Nothing}
data GetSettings_args = GetSettings_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettings_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSettings_args where 
  arbitrary = QC.elements [GetSettings_args]
from_GetSettings_args :: GetSettings_args -> T.ThriftVal
from_GetSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSettings_args :: T.Protocol p => p -> GetSettings_args -> P.IO ()
write_GetSettings_args oprot record = T.writeVal oprot $ from_GetSettings_args record
encode_GetSettings_args :: T.StatelessProtocol p => p -> GetSettings_args -> LBS.ByteString
encode_GetSettings_args oprot record = T.serializeVal oprot $ from_GetSettings_args record
to_GetSettings_args :: T.ThriftVal -> GetSettings_args
to_GetSettings_args (T.TStruct fields) = GetSettings_args{

  }
to_GetSettings_args _ = P.error "not a struct"
read_GetSettings_args :: T.Protocol p => p -> P.IO GetSettings_args
read_GetSettings_args iprot = to_GetSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSettings_args)
decode_GetSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettings_args
decode_GetSettings_args iprot bs = to_GetSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettings_args) bs
typemap_GetSettings_args :: T.TypeMap
typemap_GetSettings_args = Map.fromList []
default_GetSettings_args :: GetSettings_args
default_GetSettings_args = GetSettings_args{
}
data GetSettings_result = GetSettings_result  { getSettings_result_success :: Settings
  , getSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSettings_result_success record   `H.hashWithSalt` getSettings_result_e record  
instance QC.Arbitrary GetSettings_result where 
  arbitrary = M.liftM GetSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSettings_result{getSettings_result_success = getSettings_result_success obj} then P.Nothing else P.Just $ default_GetSettings_result{getSettings_result_success = getSettings_result_success obj}
    , if obj == default_GetSettings_result{getSettings_result_e = getSettings_result_e obj} then P.Nothing else P.Just $ default_GetSettings_result{getSettings_result_e = getSettings_result_e obj}
    ]
from_GetSettings_result :: GetSettings_result -> T.ThriftVal
from_GetSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4828 -> (1, ("e",from_TalkException _v4828))) <$> getSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4828 -> P.Just (0, ("success",from_Settings _v4828))) $ getSettings_result_success record
    , (\_v4828 -> (1, ("e",from_TalkException _v4828))) <$> getSettings_result_e record
    ]
    )
write_GetSettings_result :: T.Protocol p => p -> GetSettings_result -> P.IO ()
write_GetSettings_result oprot record = T.writeVal oprot $ from_GetSettings_result record
encode_GetSettings_result :: T.StatelessProtocol p => p -> GetSettings_result -> LBS.ByteString
encode_GetSettings_result oprot record = T.serializeVal oprot $ from_GetSettings_result record
to_GetSettings_result :: T.ThriftVal -> GetSettings_result
to_GetSettings_result (T.TStruct fields) = GetSettings_result{
  getSettings_result_success = P.maybe (getSettings_result_success default_GetSettings_result) (\(_,_val4830) -> (case _val4830 of {T.TStruct _val4831 -> (to_Settings (T.TStruct _val4831)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSettings_result_e = P.maybe (P.Nothing) (\(_,_val4830) -> P.Just (case _val4830 of {T.TStruct _val4832 -> (to_TalkException (T.TStruct _val4832)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSettings_result _ = P.error "not a struct"
read_GetSettings_result :: T.Protocol p => p -> P.IO GetSettings_result
read_GetSettings_result iprot = to_GetSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSettings_result)
decode_GetSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettings_result
decode_GetSettings_result iprot bs = to_GetSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettings_result) bs
typemap_GetSettings_result :: T.TypeMap
typemap_GetSettings_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Settings))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSettings_result :: GetSettings_result
default_GetSettings_result = GetSettings_result{
  getSettings_result_success = default_Settings,
  getSettings_result_e = P.Nothing}
data GetSettingsAttributes_args = GetSettingsAttributes_args  { getSettingsAttributes_args_attrBitset :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettingsAttributes_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSettingsAttributes_args_attrBitset record  
instance QC.Arbitrary GetSettingsAttributes_args where 
  arbitrary = M.liftM GetSettingsAttributes_args (QC.arbitrary)
  shrink obj | obj == default_GetSettingsAttributes_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSettingsAttributes_args{getSettingsAttributes_args_attrBitset = getSettingsAttributes_args_attrBitset obj} then P.Nothing else P.Just $ default_GetSettingsAttributes_args{getSettingsAttributes_args_attrBitset = getSettingsAttributes_args_attrBitset obj}
    ]
from_GetSettingsAttributes_args :: GetSettingsAttributes_args -> T.ThriftVal
from_GetSettingsAttributes_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4835 -> P.Just (2, ("attrBitset",T.TI32 _v4835))) $ getSettingsAttributes_args_attrBitset record
  ]
write_GetSettingsAttributes_args :: T.Protocol p => p -> GetSettingsAttributes_args -> P.IO ()
write_GetSettingsAttributes_args oprot record = T.writeVal oprot $ from_GetSettingsAttributes_args record
encode_GetSettingsAttributes_args :: T.StatelessProtocol p => p -> GetSettingsAttributes_args -> LBS.ByteString
encode_GetSettingsAttributes_args oprot record = T.serializeVal oprot $ from_GetSettingsAttributes_args record
to_GetSettingsAttributes_args :: T.ThriftVal -> GetSettingsAttributes_args
to_GetSettingsAttributes_args (T.TStruct fields) = GetSettingsAttributes_args{
  getSettingsAttributes_args_attrBitset = P.maybe (getSettingsAttributes_args_attrBitset default_GetSettingsAttributes_args) (\(_,_val4837) -> (case _val4837 of {T.TI32 _val4838 -> _val4838; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSettingsAttributes_args _ = P.error "not a struct"
read_GetSettingsAttributes_args :: T.Protocol p => p -> P.IO GetSettingsAttributes_args
read_GetSettingsAttributes_args iprot = to_GetSettingsAttributes_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_args)
decode_GetSettingsAttributes_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettingsAttributes_args
decode_GetSettingsAttributes_args iprot bs = to_GetSettingsAttributes_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_args) bs
typemap_GetSettingsAttributes_args :: T.TypeMap
typemap_GetSettingsAttributes_args = Map.fromList [(2,("attrBitset",T.T_I32))]
default_GetSettingsAttributes_args :: GetSettingsAttributes_args
default_GetSettingsAttributes_args = GetSettingsAttributes_args{
  getSettingsAttributes_args_attrBitset = 0}
data GetSettingsAttributes_result = GetSettingsAttributes_result  { getSettingsAttributes_result_success :: Settings
  , getSettingsAttributes_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettingsAttributes_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSettingsAttributes_result_success record   `H.hashWithSalt` getSettingsAttributes_result_e record  
instance QC.Arbitrary GetSettingsAttributes_result where 
  arbitrary = M.liftM GetSettingsAttributes_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSettingsAttributes_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSettingsAttributes_result{getSettingsAttributes_result_success = getSettingsAttributes_result_success obj} then P.Nothing else P.Just $ default_GetSettingsAttributes_result{getSettingsAttributes_result_success = getSettingsAttributes_result_success obj}
    , if obj == default_GetSettingsAttributes_result{getSettingsAttributes_result_e = getSettingsAttributes_result_e obj} then P.Nothing else P.Just $ default_GetSettingsAttributes_result{getSettingsAttributes_result_e = getSettingsAttributes_result_e obj}
    ]
from_GetSettingsAttributes_result :: GetSettingsAttributes_result -> T.ThriftVal
from_GetSettingsAttributes_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4841 -> (1, ("e",from_TalkException _v4841))) <$> getSettingsAttributes_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4841 -> P.Just (0, ("success",from_Settings _v4841))) $ getSettingsAttributes_result_success record
    , (\_v4841 -> (1, ("e",from_TalkException _v4841))) <$> getSettingsAttributes_result_e record
    ]
    )
write_GetSettingsAttributes_result :: T.Protocol p => p -> GetSettingsAttributes_result -> P.IO ()
write_GetSettingsAttributes_result oprot record = T.writeVal oprot $ from_GetSettingsAttributes_result record
encode_GetSettingsAttributes_result :: T.StatelessProtocol p => p -> GetSettingsAttributes_result -> LBS.ByteString
encode_GetSettingsAttributes_result oprot record = T.serializeVal oprot $ from_GetSettingsAttributes_result record
to_GetSettingsAttributes_result :: T.ThriftVal -> GetSettingsAttributes_result
to_GetSettingsAttributes_result (T.TStruct fields) = GetSettingsAttributes_result{
  getSettingsAttributes_result_success = P.maybe (getSettingsAttributes_result_success default_GetSettingsAttributes_result) (\(_,_val4843) -> (case _val4843 of {T.TStruct _val4844 -> (to_Settings (T.TStruct _val4844)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSettingsAttributes_result_e = P.maybe (P.Nothing) (\(_,_val4843) -> P.Just (case _val4843 of {T.TStruct _val4845 -> (to_TalkException (T.TStruct _val4845)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSettingsAttributes_result _ = P.error "not a struct"
read_GetSettingsAttributes_result :: T.Protocol p => p -> P.IO GetSettingsAttributes_result
read_GetSettingsAttributes_result iprot = to_GetSettingsAttributes_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_result)
decode_GetSettingsAttributes_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettingsAttributes_result
decode_GetSettingsAttributes_result iprot bs = to_GetSettingsAttributes_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_result) bs
typemap_GetSettingsAttributes_result :: T.TypeMap
typemap_GetSettingsAttributes_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Settings))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSettingsAttributes_result :: GetSettingsAttributes_result
default_GetSettingsAttributes_result = GetSettingsAttributes_result{
  getSettingsAttributes_result_success = default_Settings,
  getSettingsAttributes_result_e = P.Nothing}
data GetSystemConfiguration_args = GetSystemConfiguration_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSystemConfiguration_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSystemConfiguration_args where 
  arbitrary = QC.elements [GetSystemConfiguration_args]
from_GetSystemConfiguration_args :: GetSystemConfiguration_args -> T.ThriftVal
from_GetSystemConfiguration_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSystemConfiguration_args :: T.Protocol p => p -> GetSystemConfiguration_args -> P.IO ()
write_GetSystemConfiguration_args oprot record = T.writeVal oprot $ from_GetSystemConfiguration_args record
encode_GetSystemConfiguration_args :: T.StatelessProtocol p => p -> GetSystemConfiguration_args -> LBS.ByteString
encode_GetSystemConfiguration_args oprot record = T.serializeVal oprot $ from_GetSystemConfiguration_args record
to_GetSystemConfiguration_args :: T.ThriftVal -> GetSystemConfiguration_args
to_GetSystemConfiguration_args (T.TStruct fields) = GetSystemConfiguration_args{

  }
to_GetSystemConfiguration_args _ = P.error "not a struct"
read_GetSystemConfiguration_args :: T.Protocol p => p -> P.IO GetSystemConfiguration_args
read_GetSystemConfiguration_args iprot = to_GetSystemConfiguration_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_args)
decode_GetSystemConfiguration_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSystemConfiguration_args
decode_GetSystemConfiguration_args iprot bs = to_GetSystemConfiguration_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_args) bs
typemap_GetSystemConfiguration_args :: T.TypeMap
typemap_GetSystemConfiguration_args = Map.fromList []
default_GetSystemConfiguration_args :: GetSystemConfiguration_args
default_GetSystemConfiguration_args = GetSystemConfiguration_args{
}
data GetSystemConfiguration_result = GetSystemConfiguration_result  { getSystemConfiguration_result_success :: SystemConfiguration
  , getSystemConfiguration_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSystemConfiguration_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSystemConfiguration_result_success record   `H.hashWithSalt` getSystemConfiguration_result_e record  
instance QC.Arbitrary GetSystemConfiguration_result where 
  arbitrary = M.liftM GetSystemConfiguration_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSystemConfiguration_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSystemConfiguration_result{getSystemConfiguration_result_success = getSystemConfiguration_result_success obj} then P.Nothing else P.Just $ default_GetSystemConfiguration_result{getSystemConfiguration_result_success = getSystemConfiguration_result_success obj}
    , if obj == default_GetSystemConfiguration_result{getSystemConfiguration_result_e = getSystemConfiguration_result_e obj} then P.Nothing else P.Just $ default_GetSystemConfiguration_result{getSystemConfiguration_result_e = getSystemConfiguration_result_e obj}
    ]
from_GetSystemConfiguration_result :: GetSystemConfiguration_result -> T.ThriftVal
from_GetSystemConfiguration_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4853 -> (1, ("e",from_TalkException _v4853))) <$> getSystemConfiguration_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4853 -> P.Just (0, ("success",from_SystemConfiguration _v4853))) $ getSystemConfiguration_result_success record
    , (\_v4853 -> (1, ("e",from_TalkException _v4853))) <$> getSystemConfiguration_result_e record
    ]
    )
write_GetSystemConfiguration_result :: T.Protocol p => p -> GetSystemConfiguration_result -> P.IO ()
write_GetSystemConfiguration_result oprot record = T.writeVal oprot $ from_GetSystemConfiguration_result record
encode_GetSystemConfiguration_result :: T.StatelessProtocol p => p -> GetSystemConfiguration_result -> LBS.ByteString
encode_GetSystemConfiguration_result oprot record = T.serializeVal oprot $ from_GetSystemConfiguration_result record
to_GetSystemConfiguration_result :: T.ThriftVal -> GetSystemConfiguration_result
to_GetSystemConfiguration_result (T.TStruct fields) = GetSystemConfiguration_result{
  getSystemConfiguration_result_success = P.maybe (getSystemConfiguration_result_success default_GetSystemConfiguration_result) (\(_,_val4855) -> (case _val4855 of {T.TStruct _val4856 -> (to_SystemConfiguration (T.TStruct _val4856)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSystemConfiguration_result_e = P.maybe (P.Nothing) (\(_,_val4855) -> P.Just (case _val4855 of {T.TStruct _val4857 -> (to_TalkException (T.TStruct _val4857)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSystemConfiguration_result _ = P.error "not a struct"
read_GetSystemConfiguration_result :: T.Protocol p => p -> P.IO GetSystemConfiguration_result
read_GetSystemConfiguration_result iprot = to_GetSystemConfiguration_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_result)
decode_GetSystemConfiguration_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSystemConfiguration_result
decode_GetSystemConfiguration_result iprot bs = to_GetSystemConfiguration_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_result) bs
typemap_GetSystemConfiguration_result :: T.TypeMap
typemap_GetSystemConfiguration_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SystemConfiguration))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSystemConfiguration_result :: GetSystemConfiguration_result
default_GetSystemConfiguration_result = GetSystemConfiguration_result{
  getSystemConfiguration_result_success = default_SystemConfiguration,
  getSystemConfiguration_result_e = P.Nothing}
data GetUserTicket_args = GetUserTicket_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTicket_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserTicket_args where 
  arbitrary = QC.elements [GetUserTicket_args]
from_GetUserTicket_args :: GetUserTicket_args -> T.ThriftVal
from_GetUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserTicket_args :: T.Protocol p => p -> GetUserTicket_args -> P.IO ()
write_GetUserTicket_args oprot record = T.writeVal oprot $ from_GetUserTicket_args record
encode_GetUserTicket_args :: T.StatelessProtocol p => p -> GetUserTicket_args -> LBS.ByteString
encode_GetUserTicket_args oprot record = T.serializeVal oprot $ from_GetUserTicket_args record
to_GetUserTicket_args :: T.ThriftVal -> GetUserTicket_args
to_GetUserTicket_args (T.TStruct fields) = GetUserTicket_args{

  }
to_GetUserTicket_args _ = P.error "not a struct"
read_GetUserTicket_args :: T.Protocol p => p -> P.IO GetUserTicket_args
read_GetUserTicket_args iprot = to_GetUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTicket_args)
decode_GetUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTicket_args
decode_GetUserTicket_args iprot bs = to_GetUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTicket_args) bs
typemap_GetUserTicket_args :: T.TypeMap
typemap_GetUserTicket_args = Map.fromList []
default_GetUserTicket_args :: GetUserTicket_args
default_GetUserTicket_args = GetUserTicket_args{
}
data GetUserTicket_result = GetUserTicket_result  { getUserTicket_result_success :: Ticket
  , getUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserTicket_result_success record   `H.hashWithSalt` getUserTicket_result_e record  
instance QC.Arbitrary GetUserTicket_result where 
  arbitrary = M.liftM GetUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserTicket_result{getUserTicket_result_success = getUserTicket_result_success obj} then P.Nothing else P.Just $ default_GetUserTicket_result{getUserTicket_result_success = getUserTicket_result_success obj}
    , if obj == default_GetUserTicket_result{getUserTicket_result_e = getUserTicket_result_e obj} then P.Nothing else P.Just $ default_GetUserTicket_result{getUserTicket_result_e = getUserTicket_result_e obj}
    ]
from_GetUserTicket_result :: GetUserTicket_result -> T.ThriftVal
from_GetUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4865 -> (1, ("e",from_TalkException _v4865))) <$> getUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4865 -> P.Just (0, ("success",from_Ticket _v4865))) $ getUserTicket_result_success record
    , (\_v4865 -> (1, ("e",from_TalkException _v4865))) <$> getUserTicket_result_e record
    ]
    )
write_GetUserTicket_result :: T.Protocol p => p -> GetUserTicket_result -> P.IO ()
write_GetUserTicket_result oprot record = T.writeVal oprot $ from_GetUserTicket_result record
encode_GetUserTicket_result :: T.StatelessProtocol p => p -> GetUserTicket_result -> LBS.ByteString
encode_GetUserTicket_result oprot record = T.serializeVal oprot $ from_GetUserTicket_result record
to_GetUserTicket_result :: T.ThriftVal -> GetUserTicket_result
to_GetUserTicket_result (T.TStruct fields) = GetUserTicket_result{
  getUserTicket_result_success = P.maybe (getUserTicket_result_success default_GetUserTicket_result) (\(_,_val4867) -> (case _val4867 of {T.TStruct _val4868 -> (to_Ticket (T.TStruct _val4868)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val4867) -> P.Just (case _val4867 of {T.TStruct _val4869 -> (to_TalkException (T.TStruct _val4869)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserTicket_result _ = P.error "not a struct"
read_GetUserTicket_result :: T.Protocol p => p -> P.IO GetUserTicket_result
read_GetUserTicket_result iprot = to_GetUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTicket_result)
decode_GetUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTicket_result
decode_GetUserTicket_result iprot bs = to_GetUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTicket_result) bs
typemap_GetUserTicket_result :: T.TypeMap
typemap_GetUserTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Ticket))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserTicket_result :: GetUserTicket_result
default_GetUserTicket_result = GetUserTicket_result{
  getUserTicket_result_success = default_Ticket,
  getUserTicket_result_e = P.Nothing}
data GetWapInvitation_args = GetWapInvitation_args  { getWapInvitation_args_invitationHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetWapInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getWapInvitation_args_invitationHash record  
instance QC.Arbitrary GetWapInvitation_args where 
  arbitrary = M.liftM GetWapInvitation_args (QC.arbitrary)
  shrink obj | obj == default_GetWapInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetWapInvitation_args{getWapInvitation_args_invitationHash = getWapInvitation_args_invitationHash obj} then P.Nothing else P.Just $ default_GetWapInvitation_args{getWapInvitation_args_invitationHash = getWapInvitation_args_invitationHash obj}
    ]
from_GetWapInvitation_args :: GetWapInvitation_args -> T.ThriftVal
from_GetWapInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4872 -> P.Just (2, ("invitationHash",T.TString $ E.encodeUtf8 _v4872))) $ getWapInvitation_args_invitationHash record
  ]
write_GetWapInvitation_args :: T.Protocol p => p -> GetWapInvitation_args -> P.IO ()
write_GetWapInvitation_args oprot record = T.writeVal oprot $ from_GetWapInvitation_args record
encode_GetWapInvitation_args :: T.StatelessProtocol p => p -> GetWapInvitation_args -> LBS.ByteString
encode_GetWapInvitation_args oprot record = T.serializeVal oprot $ from_GetWapInvitation_args record
to_GetWapInvitation_args :: T.ThriftVal -> GetWapInvitation_args
to_GetWapInvitation_args (T.TStruct fields) = GetWapInvitation_args{
  getWapInvitation_args_invitationHash = P.maybe (getWapInvitation_args_invitationHash default_GetWapInvitation_args) (\(_,_val4874) -> (case _val4874 of {T.TString _val4875 -> E.decodeUtf8 _val4875; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetWapInvitation_args _ = P.error "not a struct"
read_GetWapInvitation_args :: T.Protocol p => p -> P.IO GetWapInvitation_args
read_GetWapInvitation_args iprot = to_GetWapInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetWapInvitation_args)
decode_GetWapInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetWapInvitation_args
decode_GetWapInvitation_args iprot bs = to_GetWapInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetWapInvitation_args) bs
typemap_GetWapInvitation_args :: T.TypeMap
typemap_GetWapInvitation_args = Map.fromList [(2,("invitationHash",T.T_STRING))]
default_GetWapInvitation_args :: GetWapInvitation_args
default_GetWapInvitation_args = GetWapInvitation_args{
  getWapInvitation_args_invitationHash = ""}
data GetWapInvitation_result = GetWapInvitation_result  { getWapInvitation_result_success :: WapInvitation
  , getWapInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetWapInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getWapInvitation_result_success record   `H.hashWithSalt` getWapInvitation_result_e record  
instance QC.Arbitrary GetWapInvitation_result where 
  arbitrary = M.liftM GetWapInvitation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetWapInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetWapInvitation_result{getWapInvitation_result_success = getWapInvitation_result_success obj} then P.Nothing else P.Just $ default_GetWapInvitation_result{getWapInvitation_result_success = getWapInvitation_result_success obj}
    , if obj == default_GetWapInvitation_result{getWapInvitation_result_e = getWapInvitation_result_e obj} then P.Nothing else P.Just $ default_GetWapInvitation_result{getWapInvitation_result_e = getWapInvitation_result_e obj}
    ]
from_GetWapInvitation_result :: GetWapInvitation_result -> T.ThriftVal
from_GetWapInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4878 -> (1, ("e",from_TalkException _v4878))) <$> getWapInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4878 -> P.Just (0, ("success",from_WapInvitation _v4878))) $ getWapInvitation_result_success record
    , (\_v4878 -> (1, ("e",from_TalkException _v4878))) <$> getWapInvitation_result_e record
    ]
    )
write_GetWapInvitation_result :: T.Protocol p => p -> GetWapInvitation_result -> P.IO ()
write_GetWapInvitation_result oprot record = T.writeVal oprot $ from_GetWapInvitation_result record
encode_GetWapInvitation_result :: T.StatelessProtocol p => p -> GetWapInvitation_result -> LBS.ByteString
encode_GetWapInvitation_result oprot record = T.serializeVal oprot $ from_GetWapInvitation_result record
to_GetWapInvitation_result :: T.ThriftVal -> GetWapInvitation_result
to_GetWapInvitation_result (T.TStruct fields) = GetWapInvitation_result{
  getWapInvitation_result_success = P.maybe (getWapInvitation_result_success default_GetWapInvitation_result) (\(_,_val4880) -> (case _val4880 of {T.TStruct _val4881 -> (to_WapInvitation (T.TStruct _val4881)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getWapInvitation_result_e = P.maybe (P.Nothing) (\(_,_val4880) -> P.Just (case _val4880 of {T.TStruct _val4882 -> (to_TalkException (T.TStruct _val4882)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetWapInvitation_result _ = P.error "not a struct"
read_GetWapInvitation_result :: T.Protocol p => p -> P.IO GetWapInvitation_result
read_GetWapInvitation_result iprot = to_GetWapInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetWapInvitation_result)
decode_GetWapInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetWapInvitation_result
decode_GetWapInvitation_result iprot bs = to_GetWapInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetWapInvitation_result) bs
typemap_GetWapInvitation_result :: T.TypeMap
typemap_GetWapInvitation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_WapInvitation))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetWapInvitation_result :: GetWapInvitation_result
default_GetWapInvitation_result = GetWapInvitation_result{
  getWapInvitation_result_success = default_WapInvitation,
  getWapInvitation_result_e = P.Nothing}
data InvalidateUserTicket_args = InvalidateUserTicket_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InvalidateUserTicket_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary InvalidateUserTicket_args where 
  arbitrary = QC.elements [InvalidateUserTicket_args]
from_InvalidateUserTicket_args :: InvalidateUserTicket_args -> T.ThriftVal
from_InvalidateUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_InvalidateUserTicket_args :: T.Protocol p => p -> InvalidateUserTicket_args -> P.IO ()
write_InvalidateUserTicket_args oprot record = T.writeVal oprot $ from_InvalidateUserTicket_args record
encode_InvalidateUserTicket_args :: T.StatelessProtocol p => p -> InvalidateUserTicket_args -> LBS.ByteString
encode_InvalidateUserTicket_args oprot record = T.serializeVal oprot $ from_InvalidateUserTicket_args record
to_InvalidateUserTicket_args :: T.ThriftVal -> InvalidateUserTicket_args
to_InvalidateUserTicket_args (T.TStruct fields) = InvalidateUserTicket_args{

  }
to_InvalidateUserTicket_args _ = P.error "not a struct"
read_InvalidateUserTicket_args :: T.Protocol p => p -> P.IO InvalidateUserTicket_args
read_InvalidateUserTicket_args iprot = to_InvalidateUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_args)
decode_InvalidateUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InvalidateUserTicket_args
decode_InvalidateUserTicket_args iprot bs = to_InvalidateUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_args) bs
typemap_InvalidateUserTicket_args :: T.TypeMap
typemap_InvalidateUserTicket_args = Map.fromList []
default_InvalidateUserTicket_args :: InvalidateUserTicket_args
default_InvalidateUserTicket_args = InvalidateUserTicket_args{
}
data InvalidateUserTicket_result = InvalidateUserTicket_result  { invalidateUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InvalidateUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalidateUserTicket_result_e record  
instance QC.Arbitrary InvalidateUserTicket_result where 
  arbitrary = M.liftM InvalidateUserTicket_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InvalidateUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InvalidateUserTicket_result{invalidateUserTicket_result_e = invalidateUserTicket_result_e obj} then P.Nothing else P.Just $ default_InvalidateUserTicket_result{invalidateUserTicket_result_e = invalidateUserTicket_result_e obj}
    ]
from_InvalidateUserTicket_result :: InvalidateUserTicket_result -> T.ThriftVal
from_InvalidateUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4890 -> (1, ("e",from_TalkException _v4890))) <$> invalidateUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4890 -> (1, ("e",from_TalkException _v4890))) <$> invalidateUserTicket_result_e record
    ]
    )
write_InvalidateUserTicket_result :: T.Protocol p => p -> InvalidateUserTicket_result -> P.IO ()
write_InvalidateUserTicket_result oprot record = T.writeVal oprot $ from_InvalidateUserTicket_result record
encode_InvalidateUserTicket_result :: T.StatelessProtocol p => p -> InvalidateUserTicket_result -> LBS.ByteString
encode_InvalidateUserTicket_result oprot record = T.serializeVal oprot $ from_InvalidateUserTicket_result record
to_InvalidateUserTicket_result :: T.ThriftVal -> InvalidateUserTicket_result
to_InvalidateUserTicket_result (T.TStruct fields) = InvalidateUserTicket_result{
  invalidateUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val4892) -> P.Just (case _val4892 of {T.TStruct _val4893 -> (to_TalkException (T.TStruct _val4893)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InvalidateUserTicket_result _ = P.error "not a struct"
read_InvalidateUserTicket_result :: T.Protocol p => p -> P.IO InvalidateUserTicket_result
read_InvalidateUserTicket_result iprot = to_InvalidateUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_result)
decode_InvalidateUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InvalidateUserTicket_result
decode_InvalidateUserTicket_result iprot bs = to_InvalidateUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_result) bs
typemap_InvalidateUserTicket_result :: T.TypeMap
typemap_InvalidateUserTicket_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InvalidateUserTicket_result :: InvalidateUserTicket_result
default_InvalidateUserTicket_result = InvalidateUserTicket_result{
  invalidateUserTicket_result_e = P.Nothing}
data InviteFriendsBySms_args = InviteFriendsBySms_args  { inviteFriendsBySms_args_phoneNumberList :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteFriendsBySms_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteFriendsBySms_args_phoneNumberList record  
instance QC.Arbitrary InviteFriendsBySms_args where 
  arbitrary = M.liftM InviteFriendsBySms_args (QC.arbitrary)
  shrink obj | obj == default_InviteFriendsBySms_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteFriendsBySms_args{inviteFriendsBySms_args_phoneNumberList = inviteFriendsBySms_args_phoneNumberList obj} then P.Nothing else P.Just $ default_InviteFriendsBySms_args{inviteFriendsBySms_args_phoneNumberList = inviteFriendsBySms_args_phoneNumberList obj}
    ]
from_InviteFriendsBySms_args :: InviteFriendsBySms_args -> T.ThriftVal
from_InviteFriendsBySms_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4896 -> P.Just (2, ("phoneNumberList",T.TList T.T_STRING $ P.map (\_v4898 -> T.TString $ E.encodeUtf8 _v4898) $ Vector.toList _v4896))) $ inviteFriendsBySms_args_phoneNumberList record
  ]
write_InviteFriendsBySms_args :: T.Protocol p => p -> InviteFriendsBySms_args -> P.IO ()
write_InviteFriendsBySms_args oprot record = T.writeVal oprot $ from_InviteFriendsBySms_args record
encode_InviteFriendsBySms_args :: T.StatelessProtocol p => p -> InviteFriendsBySms_args -> LBS.ByteString
encode_InviteFriendsBySms_args oprot record = T.serializeVal oprot $ from_InviteFriendsBySms_args record
to_InviteFriendsBySms_args :: T.ThriftVal -> InviteFriendsBySms_args
to_InviteFriendsBySms_args (T.TStruct fields) = InviteFriendsBySms_args{
  inviteFriendsBySms_args_phoneNumberList = P.maybe (inviteFriendsBySms_args_phoneNumberList default_InviteFriendsBySms_args) (\(_,_val4900) -> (case _val4900 of {T.TList _ _val4901 -> (Vector.fromList $ P.map (\_v4902 -> (case _v4902 of {T.TString _val4903 -> E.decodeUtf8 _val4903; _ -> P.error "wrong type"})) _val4901); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_InviteFriendsBySms_args _ = P.error "not a struct"
read_InviteFriendsBySms_args :: T.Protocol p => p -> P.IO InviteFriendsBySms_args
read_InviteFriendsBySms_args iprot = to_InviteFriendsBySms_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_args)
decode_InviteFriendsBySms_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteFriendsBySms_args
decode_InviteFriendsBySms_args iprot bs = to_InviteFriendsBySms_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_args) bs
typemap_InviteFriendsBySms_args :: T.TypeMap
typemap_InviteFriendsBySms_args = Map.fromList [(2,("phoneNumberList",(T.T_LIST T.T_STRING)))]
default_InviteFriendsBySms_args :: InviteFriendsBySms_args
default_InviteFriendsBySms_args = InviteFriendsBySms_args{
  inviteFriendsBySms_args_phoneNumberList = Vector.empty}
data InviteFriendsBySms_result = InviteFriendsBySms_result  { inviteFriendsBySms_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteFriendsBySms_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteFriendsBySms_result_e record  
instance QC.Arbitrary InviteFriendsBySms_result where 
  arbitrary = M.liftM InviteFriendsBySms_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteFriendsBySms_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteFriendsBySms_result{inviteFriendsBySms_result_e = inviteFriendsBySms_result_e obj} then P.Nothing else P.Just $ default_InviteFriendsBySms_result{inviteFriendsBySms_result_e = inviteFriendsBySms_result_e obj}
    ]
from_InviteFriendsBySms_result :: InviteFriendsBySms_result -> T.ThriftVal
from_InviteFriendsBySms_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4906 -> (1, ("e",from_TalkException _v4906))) <$> inviteFriendsBySms_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4906 -> (1, ("e",from_TalkException _v4906))) <$> inviteFriendsBySms_result_e record
    ]
    )
write_InviteFriendsBySms_result :: T.Protocol p => p -> InviteFriendsBySms_result -> P.IO ()
write_InviteFriendsBySms_result oprot record = T.writeVal oprot $ from_InviteFriendsBySms_result record
encode_InviteFriendsBySms_result :: T.StatelessProtocol p => p -> InviteFriendsBySms_result -> LBS.ByteString
encode_InviteFriendsBySms_result oprot record = T.serializeVal oprot $ from_InviteFriendsBySms_result record
to_InviteFriendsBySms_result :: T.ThriftVal -> InviteFriendsBySms_result
to_InviteFriendsBySms_result (T.TStruct fields) = InviteFriendsBySms_result{
  inviteFriendsBySms_result_e = P.maybe (P.Nothing) (\(_,_val4908) -> P.Just (case _val4908 of {T.TStruct _val4909 -> (to_TalkException (T.TStruct _val4909)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteFriendsBySms_result _ = P.error "not a struct"
read_InviteFriendsBySms_result :: T.Protocol p => p -> P.IO InviteFriendsBySms_result
read_InviteFriendsBySms_result iprot = to_InviteFriendsBySms_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_result)
decode_InviteFriendsBySms_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteFriendsBySms_result
decode_InviteFriendsBySms_result iprot bs = to_InviteFriendsBySms_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_result) bs
typemap_InviteFriendsBySms_result :: T.TypeMap
typemap_InviteFriendsBySms_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteFriendsBySms_result :: InviteFriendsBySms_result
default_InviteFriendsBySms_result = InviteFriendsBySms_result{
  inviteFriendsBySms_result_e = P.Nothing}
data InviteIntoGroup_args = InviteIntoGroup_args  { inviteIntoGroup_args_reqSeq :: I.Int32
  , inviteIntoGroup_args_groupId :: LT.Text
  , inviteIntoGroup_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroup_args_reqSeq record   `H.hashWithSalt` inviteIntoGroup_args_groupId record   `H.hashWithSalt` inviteIntoGroup_args_contactIds record  
instance QC.Arbitrary InviteIntoGroup_args where 
  arbitrary = M.liftM InviteIntoGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroup_args{inviteIntoGroup_args_reqSeq = inviteIntoGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_InviteIntoGroup_args{inviteIntoGroup_args_reqSeq = inviteIntoGroup_args_reqSeq obj}
    , if obj == default_InviteIntoGroup_args{inviteIntoGroup_args_groupId = inviteIntoGroup_args_groupId obj} then P.Nothing else P.Just $ default_InviteIntoGroup_args{inviteIntoGroup_args_groupId = inviteIntoGroup_args_groupId obj}
    , if obj == default_InviteIntoGroup_args{inviteIntoGroup_args_contactIds = inviteIntoGroup_args_contactIds obj} then P.Nothing else P.Just $ default_InviteIntoGroup_args{inviteIntoGroup_args_contactIds = inviteIntoGroup_args_contactIds obj}
    ]
from_InviteIntoGroup_args :: InviteIntoGroup_args -> T.ThriftVal
from_InviteIntoGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4912 -> P.Just (1, ("reqSeq",T.TI32 _v4912))) $ inviteIntoGroup_args_reqSeq record
  , (\_v4912 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v4912))) $ inviteIntoGroup_args_groupId record
  , (\_v4912 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v4914 -> T.TString $ E.encodeUtf8 _v4914) $ Vector.toList _v4912))) $ inviteIntoGroup_args_contactIds record
  ]
write_InviteIntoGroup_args :: T.Protocol p => p -> InviteIntoGroup_args -> P.IO ()
write_InviteIntoGroup_args oprot record = T.writeVal oprot $ from_InviteIntoGroup_args record
encode_InviteIntoGroup_args :: T.StatelessProtocol p => p -> InviteIntoGroup_args -> LBS.ByteString
encode_InviteIntoGroup_args oprot record = T.serializeVal oprot $ from_InviteIntoGroup_args record
to_InviteIntoGroup_args :: T.ThriftVal -> InviteIntoGroup_args
to_InviteIntoGroup_args (T.TStruct fields) = InviteIntoGroup_args{
  inviteIntoGroup_args_reqSeq = P.maybe (inviteIntoGroup_args_reqSeq default_InviteIntoGroup_args) (\(_,_val4916) -> (case _val4916 of {T.TI32 _val4917 -> _val4917; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteIntoGroup_args_groupId = P.maybe (inviteIntoGroup_args_groupId default_InviteIntoGroup_args) (\(_,_val4916) -> (case _val4916 of {T.TString _val4918 -> E.decodeUtf8 _val4918; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteIntoGroup_args_contactIds = P.maybe (inviteIntoGroup_args_contactIds default_InviteIntoGroup_args) (\(_,_val4916) -> (case _val4916 of {T.TList _ _val4919 -> (Vector.fromList $ P.map (\_v4920 -> (case _v4920 of {T.TString _val4921 -> E.decodeUtf8 _val4921; _ -> P.error "wrong type"})) _val4919); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_InviteIntoGroup_args _ = P.error "not a struct"
read_InviteIntoGroup_args :: T.Protocol p => p -> P.IO InviteIntoGroup_args
read_InviteIntoGroup_args iprot = to_InviteIntoGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroup_args)
decode_InviteIntoGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroup_args
decode_InviteIntoGroup_args iprot bs = to_InviteIntoGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroup_args) bs
typemap_InviteIntoGroup_args :: T.TypeMap
typemap_InviteIntoGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_InviteIntoGroup_args :: InviteIntoGroup_args
default_InviteIntoGroup_args = InviteIntoGroup_args{
  inviteIntoGroup_args_reqSeq = 0,
  inviteIntoGroup_args_groupId = "",
  inviteIntoGroup_args_contactIds = Vector.empty}
data InviteIntoGroup_result = InviteIntoGroup_result  { inviteIntoGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroup_result_e record  
instance QC.Arbitrary InviteIntoGroup_result where 
  arbitrary = M.liftM InviteIntoGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroup_result{inviteIntoGroup_result_e = inviteIntoGroup_result_e obj} then P.Nothing else P.Just $ default_InviteIntoGroup_result{inviteIntoGroup_result_e = inviteIntoGroup_result_e obj}
    ]
from_InviteIntoGroup_result :: InviteIntoGroup_result -> T.ThriftVal
from_InviteIntoGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4924 -> (1, ("e",from_TalkException _v4924))) <$> inviteIntoGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4924 -> (1, ("e",from_TalkException _v4924))) <$> inviteIntoGroup_result_e record
    ]
    )
write_InviteIntoGroup_result :: T.Protocol p => p -> InviteIntoGroup_result -> P.IO ()
write_InviteIntoGroup_result oprot record = T.writeVal oprot $ from_InviteIntoGroup_result record
encode_InviteIntoGroup_result :: T.StatelessProtocol p => p -> InviteIntoGroup_result -> LBS.ByteString
encode_InviteIntoGroup_result oprot record = T.serializeVal oprot $ from_InviteIntoGroup_result record
to_InviteIntoGroup_result :: T.ThriftVal -> InviteIntoGroup_result
to_InviteIntoGroup_result (T.TStruct fields) = InviteIntoGroup_result{
  inviteIntoGroup_result_e = P.maybe (P.Nothing) (\(_,_val4926) -> P.Just (case _val4926 of {T.TStruct _val4927 -> (to_TalkException (T.TStruct _val4927)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteIntoGroup_result _ = P.error "not a struct"
read_InviteIntoGroup_result :: T.Protocol p => p -> P.IO InviteIntoGroup_result
read_InviteIntoGroup_result iprot = to_InviteIntoGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroup_result)
decode_InviteIntoGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroup_result
decode_InviteIntoGroup_result iprot bs = to_InviteIntoGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroup_result) bs
typemap_InviteIntoGroup_result :: T.TypeMap
typemap_InviteIntoGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteIntoGroup_result :: InviteIntoGroup_result
default_InviteIntoGroup_result = InviteIntoGroup_result{
  inviteIntoGroup_result_e = P.Nothing}
data InviteIntoRoom_args = InviteIntoRoom_args  { inviteIntoRoom_args_reqSeq :: I.Int32
  , inviteIntoRoom_args_roomId :: LT.Text
  , inviteIntoRoom_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoRoom_args_reqSeq record   `H.hashWithSalt` inviteIntoRoom_args_roomId record   `H.hashWithSalt` inviteIntoRoom_args_contactIds record  
instance QC.Arbitrary InviteIntoRoom_args where 
  arbitrary = M.liftM InviteIntoRoom_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteIntoRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoRoom_args{inviteIntoRoom_args_reqSeq = inviteIntoRoom_args_reqSeq obj} then P.Nothing else P.Just $ default_InviteIntoRoom_args{inviteIntoRoom_args_reqSeq = inviteIntoRoom_args_reqSeq obj}
    , if obj == default_InviteIntoRoom_args{inviteIntoRoom_args_roomId = inviteIntoRoom_args_roomId obj} then P.Nothing else P.Just $ default_InviteIntoRoom_args{inviteIntoRoom_args_roomId = inviteIntoRoom_args_roomId obj}
    , if obj == default_InviteIntoRoom_args{inviteIntoRoom_args_contactIds = inviteIntoRoom_args_contactIds obj} then P.Nothing else P.Just $ default_InviteIntoRoom_args{inviteIntoRoom_args_contactIds = inviteIntoRoom_args_contactIds obj}
    ]
from_InviteIntoRoom_args :: InviteIntoRoom_args -> T.ThriftVal
from_InviteIntoRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4930 -> P.Just (1, ("reqSeq",T.TI32 _v4930))) $ inviteIntoRoom_args_reqSeq record
  , (\_v4930 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v4930))) $ inviteIntoRoom_args_roomId record
  , (\_v4930 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v4932 -> T.TString $ E.encodeUtf8 _v4932) $ Vector.toList _v4930))) $ inviteIntoRoom_args_contactIds record
  ]
write_InviteIntoRoom_args :: T.Protocol p => p -> InviteIntoRoom_args -> P.IO ()
write_InviteIntoRoom_args oprot record = T.writeVal oprot $ from_InviteIntoRoom_args record
encode_InviteIntoRoom_args :: T.StatelessProtocol p => p -> InviteIntoRoom_args -> LBS.ByteString
encode_InviteIntoRoom_args oprot record = T.serializeVal oprot $ from_InviteIntoRoom_args record
to_InviteIntoRoom_args :: T.ThriftVal -> InviteIntoRoom_args
to_InviteIntoRoom_args (T.TStruct fields) = InviteIntoRoom_args{
  inviteIntoRoom_args_reqSeq = P.maybe (inviteIntoRoom_args_reqSeq default_InviteIntoRoom_args) (\(_,_val4934) -> (case _val4934 of {T.TI32 _val4935 -> _val4935; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteIntoRoom_args_roomId = P.maybe (inviteIntoRoom_args_roomId default_InviteIntoRoom_args) (\(_,_val4934) -> (case _val4934 of {T.TString _val4936 -> E.decodeUtf8 _val4936; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteIntoRoom_args_contactIds = P.maybe (inviteIntoRoom_args_contactIds default_InviteIntoRoom_args) (\(_,_val4934) -> (case _val4934 of {T.TList _ _val4937 -> (Vector.fromList $ P.map (\_v4938 -> (case _v4938 of {T.TString _val4939 -> E.decodeUtf8 _val4939; _ -> P.error "wrong type"})) _val4937); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_InviteIntoRoom_args _ = P.error "not a struct"
read_InviteIntoRoom_args :: T.Protocol p => p -> P.IO InviteIntoRoom_args
read_InviteIntoRoom_args iprot = to_InviteIntoRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoRoom_args)
decode_InviteIntoRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoRoom_args
decode_InviteIntoRoom_args iprot bs = to_InviteIntoRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoRoom_args) bs
typemap_InviteIntoRoom_args :: T.TypeMap
typemap_InviteIntoRoom_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("roomId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_InviteIntoRoom_args :: InviteIntoRoom_args
default_InviteIntoRoom_args = InviteIntoRoom_args{
  inviteIntoRoom_args_reqSeq = 0,
  inviteIntoRoom_args_roomId = "",
  inviteIntoRoom_args_contactIds = Vector.empty}
data InviteIntoRoom_result = InviteIntoRoom_result  { inviteIntoRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoRoom_result_e record  
instance QC.Arbitrary InviteIntoRoom_result where 
  arbitrary = M.liftM InviteIntoRoom_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteIntoRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoRoom_result{inviteIntoRoom_result_e = inviteIntoRoom_result_e obj} then P.Nothing else P.Just $ default_InviteIntoRoom_result{inviteIntoRoom_result_e = inviteIntoRoom_result_e obj}
    ]
from_InviteIntoRoom_result :: InviteIntoRoom_result -> T.ThriftVal
from_InviteIntoRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4942 -> (1, ("e",from_TalkException _v4942))) <$> inviteIntoRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4942 -> (1, ("e",from_TalkException _v4942))) <$> inviteIntoRoom_result_e record
    ]
    )
write_InviteIntoRoom_result :: T.Protocol p => p -> InviteIntoRoom_result -> P.IO ()
write_InviteIntoRoom_result oprot record = T.writeVal oprot $ from_InviteIntoRoom_result record
encode_InviteIntoRoom_result :: T.StatelessProtocol p => p -> InviteIntoRoom_result -> LBS.ByteString
encode_InviteIntoRoom_result oprot record = T.serializeVal oprot $ from_InviteIntoRoom_result record
to_InviteIntoRoom_result :: T.ThriftVal -> InviteIntoRoom_result
to_InviteIntoRoom_result (T.TStruct fields) = InviteIntoRoom_result{
  inviteIntoRoom_result_e = P.maybe (P.Nothing) (\(_,_val4944) -> P.Just (case _val4944 of {T.TStruct _val4945 -> (to_TalkException (T.TStruct _val4945)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteIntoRoom_result _ = P.error "not a struct"
read_InviteIntoRoom_result :: T.Protocol p => p -> P.IO InviteIntoRoom_result
read_InviteIntoRoom_result iprot = to_InviteIntoRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoRoom_result)
decode_InviteIntoRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoRoom_result
decode_InviteIntoRoom_result iprot bs = to_InviteIntoRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoRoom_result) bs
typemap_InviteIntoRoom_result :: T.TypeMap
typemap_InviteIntoRoom_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteIntoRoom_result :: InviteIntoRoom_result
default_InviteIntoRoom_result = InviteIntoRoom_result{
  inviteIntoRoom_result_e = P.Nothing}
data InviteViaEmail_args = InviteViaEmail_args  { inviteViaEmail_args_reqSeq :: I.Int32
  , inviteViaEmail_args_email :: LT.Text
  , inviteViaEmail_args_name :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteViaEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteViaEmail_args_reqSeq record   `H.hashWithSalt` inviteViaEmail_args_email record   `H.hashWithSalt` inviteViaEmail_args_name record  
instance QC.Arbitrary InviteViaEmail_args where 
  arbitrary = M.liftM InviteViaEmail_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteViaEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteViaEmail_args{inviteViaEmail_args_reqSeq = inviteViaEmail_args_reqSeq obj} then P.Nothing else P.Just $ default_InviteViaEmail_args{inviteViaEmail_args_reqSeq = inviteViaEmail_args_reqSeq obj}
    , if obj == default_InviteViaEmail_args{inviteViaEmail_args_email = inviteViaEmail_args_email obj} then P.Nothing else P.Just $ default_InviteViaEmail_args{inviteViaEmail_args_email = inviteViaEmail_args_email obj}
    , if obj == default_InviteViaEmail_args{inviteViaEmail_args_name = inviteViaEmail_args_name obj} then P.Nothing else P.Just $ default_InviteViaEmail_args{inviteViaEmail_args_name = inviteViaEmail_args_name obj}
    ]
from_InviteViaEmail_args :: InviteViaEmail_args -> T.ThriftVal
from_InviteViaEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4948 -> P.Just (1, ("reqSeq",T.TI32 _v4948))) $ inviteViaEmail_args_reqSeq record
  , (\_v4948 -> P.Just (2, ("email",T.TString $ E.encodeUtf8 _v4948))) $ inviteViaEmail_args_email record
  , (\_v4948 -> P.Just (3, ("name",T.TString $ E.encodeUtf8 _v4948))) $ inviteViaEmail_args_name record
  ]
write_InviteViaEmail_args :: T.Protocol p => p -> InviteViaEmail_args -> P.IO ()
write_InviteViaEmail_args oprot record = T.writeVal oprot $ from_InviteViaEmail_args record
encode_InviteViaEmail_args :: T.StatelessProtocol p => p -> InviteViaEmail_args -> LBS.ByteString
encode_InviteViaEmail_args oprot record = T.serializeVal oprot $ from_InviteViaEmail_args record
to_InviteViaEmail_args :: T.ThriftVal -> InviteViaEmail_args
to_InviteViaEmail_args (T.TStruct fields) = InviteViaEmail_args{
  inviteViaEmail_args_reqSeq = P.maybe (inviteViaEmail_args_reqSeq default_InviteViaEmail_args) (\(_,_val4950) -> (case _val4950 of {T.TI32 _val4951 -> _val4951; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteViaEmail_args_email = P.maybe (inviteViaEmail_args_email default_InviteViaEmail_args) (\(_,_val4950) -> (case _val4950 of {T.TString _val4952 -> E.decodeUtf8 _val4952; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteViaEmail_args_name = P.maybe (inviteViaEmail_args_name default_InviteViaEmail_args) (\(_,_val4950) -> (case _val4950 of {T.TString _val4953 -> E.decodeUtf8 _val4953; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_InviteViaEmail_args _ = P.error "not a struct"
read_InviteViaEmail_args :: T.Protocol p => p -> P.IO InviteViaEmail_args
read_InviteViaEmail_args iprot = to_InviteViaEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteViaEmail_args)
decode_InviteViaEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteViaEmail_args
decode_InviteViaEmail_args iprot bs = to_InviteViaEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteViaEmail_args) bs
typemap_InviteViaEmail_args :: T.TypeMap
typemap_InviteViaEmail_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("email",T.T_STRING)),(3,("name",T.T_STRING))]
default_InviteViaEmail_args :: InviteViaEmail_args
default_InviteViaEmail_args = InviteViaEmail_args{
  inviteViaEmail_args_reqSeq = 0,
  inviteViaEmail_args_email = "",
  inviteViaEmail_args_name = ""}
data InviteViaEmail_result = InviteViaEmail_result  { inviteViaEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteViaEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteViaEmail_result_e record  
instance QC.Arbitrary InviteViaEmail_result where 
  arbitrary = M.liftM InviteViaEmail_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteViaEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteViaEmail_result{inviteViaEmail_result_e = inviteViaEmail_result_e obj} then P.Nothing else P.Just $ default_InviteViaEmail_result{inviteViaEmail_result_e = inviteViaEmail_result_e obj}
    ]
from_InviteViaEmail_result :: InviteViaEmail_result -> T.ThriftVal
from_InviteViaEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4956 -> (1, ("e",from_TalkException _v4956))) <$> inviteViaEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4956 -> (1, ("e",from_TalkException _v4956))) <$> inviteViaEmail_result_e record
    ]
    )
write_InviteViaEmail_result :: T.Protocol p => p -> InviteViaEmail_result -> P.IO ()
write_InviteViaEmail_result oprot record = T.writeVal oprot $ from_InviteViaEmail_result record
encode_InviteViaEmail_result :: T.StatelessProtocol p => p -> InviteViaEmail_result -> LBS.ByteString
encode_InviteViaEmail_result oprot record = T.serializeVal oprot $ from_InviteViaEmail_result record
to_InviteViaEmail_result :: T.ThriftVal -> InviteViaEmail_result
to_InviteViaEmail_result (T.TStruct fields) = InviteViaEmail_result{
  inviteViaEmail_result_e = P.maybe (P.Nothing) (\(_,_val4958) -> P.Just (case _val4958 of {T.TStruct _val4959 -> (to_TalkException (T.TStruct _val4959)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteViaEmail_result _ = P.error "not a struct"
read_InviteViaEmail_result :: T.Protocol p => p -> P.IO InviteViaEmail_result
read_InviteViaEmail_result iprot = to_InviteViaEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteViaEmail_result)
decode_InviteViaEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteViaEmail_result
decode_InviteViaEmail_result iprot bs = to_InviteViaEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteViaEmail_result) bs
typemap_InviteViaEmail_result :: T.TypeMap
typemap_InviteViaEmail_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteViaEmail_result :: InviteViaEmail_result
default_InviteViaEmail_result = InviteViaEmail_result{
  inviteViaEmail_result_e = P.Nothing}
data IsIdentityIdentifierAvailable_args = IsIdentityIdentifierAvailable_args  { isIdentityIdentifierAvailable_args_provider :: IdentityProvider
  , isIdentityIdentifierAvailable_args_identifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsIdentityIdentifierAvailable_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isIdentityIdentifierAvailable_args_provider record   `H.hashWithSalt` isIdentityIdentifierAvailable_args_identifier record  
instance QC.Arbitrary IsIdentityIdentifierAvailable_args where 
  arbitrary = M.liftM IsIdentityIdentifierAvailable_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IsIdentityIdentifierAvailable_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_provider = isIdentityIdentifierAvailable_args_provider obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_provider = isIdentityIdentifierAvailable_args_provider obj}
    , if obj == default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_identifier = isIdentityIdentifierAvailable_args_identifier obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_identifier = isIdentityIdentifierAvailable_args_identifier obj}
    ]
from_IsIdentityIdentifierAvailable_args :: IsIdentityIdentifierAvailable_args -> T.ThriftVal
from_IsIdentityIdentifierAvailable_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4962 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v4962))) $ isIdentityIdentifierAvailable_args_identifier record
  , (\_v4962 -> P.Just (3, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v4962))) $ isIdentityIdentifierAvailable_args_provider record
  ]
write_IsIdentityIdentifierAvailable_args :: T.Protocol p => p -> IsIdentityIdentifierAvailable_args -> P.IO ()
write_IsIdentityIdentifierAvailable_args oprot record = T.writeVal oprot $ from_IsIdentityIdentifierAvailable_args record
encode_IsIdentityIdentifierAvailable_args :: T.StatelessProtocol p => p -> IsIdentityIdentifierAvailable_args -> LBS.ByteString
encode_IsIdentityIdentifierAvailable_args oprot record = T.serializeVal oprot $ from_IsIdentityIdentifierAvailable_args record
to_IsIdentityIdentifierAvailable_args :: T.ThriftVal -> IsIdentityIdentifierAvailable_args
to_IsIdentityIdentifierAvailable_args (T.TStruct fields) = IsIdentityIdentifierAvailable_args{
  isIdentityIdentifierAvailable_args_provider = P.maybe (isIdentityIdentifierAvailable_args_provider default_IsIdentityIdentifierAvailable_args) (\(_,_val4964) -> (case _val4964 of {T.TI32 _val4965 -> P.toEnum $ P.fromIntegral _val4965; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  isIdentityIdentifierAvailable_args_identifier = P.maybe (isIdentityIdentifierAvailable_args_identifier default_IsIdentityIdentifierAvailable_args) (\(_,_val4964) -> (case _val4964 of {T.TString _val4966 -> E.decodeUtf8 _val4966; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsIdentityIdentifierAvailable_args _ = P.error "not a struct"
read_IsIdentityIdentifierAvailable_args :: T.Protocol p => p -> P.IO IsIdentityIdentifierAvailable_args
read_IsIdentityIdentifierAvailable_args iprot = to_IsIdentityIdentifierAvailable_args <$> T.readVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_args)
decode_IsIdentityIdentifierAvailable_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsIdentityIdentifierAvailable_args
decode_IsIdentityIdentifierAvailable_args iprot bs = to_IsIdentityIdentifierAvailable_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_args) bs
typemap_IsIdentityIdentifierAvailable_args :: T.TypeMap
typemap_IsIdentityIdentifierAvailable_args = Map.fromList [(2,("identifier",T.T_STRING)),(3,("provider",T.T_I32))]
default_IsIdentityIdentifierAvailable_args :: IsIdentityIdentifierAvailable_args
default_IsIdentityIdentifierAvailable_args = IsIdentityIdentifierAvailable_args{
  isIdentityIdentifierAvailable_args_identifier = "",
  isIdentityIdentifierAvailable_args_provider = (P.toEnum 0)}
data IsIdentityIdentifierAvailable_result = IsIdentityIdentifierAvailable_result  { isIdentityIdentifierAvailable_result_success :: P.Bool
  , isIdentityIdentifierAvailable_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsIdentityIdentifierAvailable_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isIdentityIdentifierAvailable_result_success record   `H.hashWithSalt` isIdentityIdentifierAvailable_result_e record  
instance QC.Arbitrary IsIdentityIdentifierAvailable_result where 
  arbitrary = M.liftM IsIdentityIdentifierAvailable_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsIdentityIdentifierAvailable_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_success = isIdentityIdentifierAvailable_result_success obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_success = isIdentityIdentifierAvailable_result_success obj}
    , if obj == default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_e = isIdentityIdentifierAvailable_result_e obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_e = isIdentityIdentifierAvailable_result_e obj}
    ]
from_IsIdentityIdentifierAvailable_result :: IsIdentityIdentifierAvailable_result -> T.ThriftVal
from_IsIdentityIdentifierAvailable_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4969 -> (1, ("e",from_TalkException _v4969))) <$> isIdentityIdentifierAvailable_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4969 -> P.Just (0, ("success",T.TBool _v4969))) $ isIdentityIdentifierAvailable_result_success record
    , (\_v4969 -> (1, ("e",from_TalkException _v4969))) <$> isIdentityIdentifierAvailable_result_e record
    ]
    )
write_IsIdentityIdentifierAvailable_result :: T.Protocol p => p -> IsIdentityIdentifierAvailable_result -> P.IO ()
write_IsIdentityIdentifierAvailable_result oprot record = T.writeVal oprot $ from_IsIdentityIdentifierAvailable_result record
encode_IsIdentityIdentifierAvailable_result :: T.StatelessProtocol p => p -> IsIdentityIdentifierAvailable_result -> LBS.ByteString
encode_IsIdentityIdentifierAvailable_result oprot record = T.serializeVal oprot $ from_IsIdentityIdentifierAvailable_result record
to_IsIdentityIdentifierAvailable_result :: T.ThriftVal -> IsIdentityIdentifierAvailable_result
to_IsIdentityIdentifierAvailable_result (T.TStruct fields) = IsIdentityIdentifierAvailable_result{
  isIdentityIdentifierAvailable_result_success = P.maybe (isIdentityIdentifierAvailable_result_success default_IsIdentityIdentifierAvailable_result) (\(_,_val4971) -> (case _val4971 of {T.TBool _val4972 -> _val4972; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isIdentityIdentifierAvailable_result_e = P.maybe (P.Nothing) (\(_,_val4971) -> P.Just (case _val4971 of {T.TStruct _val4973 -> (to_TalkException (T.TStruct _val4973)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsIdentityIdentifierAvailable_result _ = P.error "not a struct"
read_IsIdentityIdentifierAvailable_result :: T.Protocol p => p -> P.IO IsIdentityIdentifierAvailable_result
read_IsIdentityIdentifierAvailable_result iprot = to_IsIdentityIdentifierAvailable_result <$> T.readVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_result)
decode_IsIdentityIdentifierAvailable_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsIdentityIdentifierAvailable_result
decode_IsIdentityIdentifierAvailable_result iprot bs = to_IsIdentityIdentifierAvailable_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_result) bs
typemap_IsIdentityIdentifierAvailable_result :: T.TypeMap
typemap_IsIdentityIdentifierAvailable_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsIdentityIdentifierAvailable_result :: IsIdentityIdentifierAvailable_result
default_IsIdentityIdentifierAvailable_result = IsIdentityIdentifierAvailable_result{
  isIdentityIdentifierAvailable_result_success = P.False,
  isIdentityIdentifierAvailable_result_e = P.Nothing}
data IsUseridAvailable_args = IsUseridAvailable_args  { isUseridAvailable_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsUseridAvailable_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isUseridAvailable_args_userid record  
instance QC.Arbitrary IsUseridAvailable_args where 
  arbitrary = M.liftM IsUseridAvailable_args (QC.arbitrary)
  shrink obj | obj == default_IsUseridAvailable_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsUseridAvailable_args{isUseridAvailable_args_userid = isUseridAvailable_args_userid obj} then P.Nothing else P.Just $ default_IsUseridAvailable_args{isUseridAvailable_args_userid = isUseridAvailable_args_userid obj}
    ]
from_IsUseridAvailable_args :: IsUseridAvailable_args -> T.ThriftVal
from_IsUseridAvailable_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4976 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v4976))) $ isUseridAvailable_args_userid record
  ]
write_IsUseridAvailable_args :: T.Protocol p => p -> IsUseridAvailable_args -> P.IO ()
write_IsUseridAvailable_args oprot record = T.writeVal oprot $ from_IsUseridAvailable_args record
encode_IsUseridAvailable_args :: T.StatelessProtocol p => p -> IsUseridAvailable_args -> LBS.ByteString
encode_IsUseridAvailable_args oprot record = T.serializeVal oprot $ from_IsUseridAvailable_args record
to_IsUseridAvailable_args :: T.ThriftVal -> IsUseridAvailable_args
to_IsUseridAvailable_args (T.TStruct fields) = IsUseridAvailable_args{
  isUseridAvailable_args_userid = P.maybe (isUseridAvailable_args_userid default_IsUseridAvailable_args) (\(_,_val4978) -> (case _val4978 of {T.TString _val4979 -> E.decodeUtf8 _val4979; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsUseridAvailable_args _ = P.error "not a struct"
read_IsUseridAvailable_args :: T.Protocol p => p -> P.IO IsUseridAvailable_args
read_IsUseridAvailable_args iprot = to_IsUseridAvailable_args <$> T.readVal iprot (T.T_STRUCT typemap_IsUseridAvailable_args)
decode_IsUseridAvailable_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsUseridAvailable_args
decode_IsUseridAvailable_args iprot bs = to_IsUseridAvailable_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsUseridAvailable_args) bs
typemap_IsUseridAvailable_args :: T.TypeMap
typemap_IsUseridAvailable_args = Map.fromList [(2,("userid",T.T_STRING))]
default_IsUseridAvailable_args :: IsUseridAvailable_args
default_IsUseridAvailable_args = IsUseridAvailable_args{
  isUseridAvailable_args_userid = ""}
data IsUseridAvailable_result = IsUseridAvailable_result  { isUseridAvailable_result_success :: P.Bool
  , isUseridAvailable_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsUseridAvailable_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isUseridAvailable_result_success record   `H.hashWithSalt` isUseridAvailable_result_e record  
instance QC.Arbitrary IsUseridAvailable_result where 
  arbitrary = M.liftM IsUseridAvailable_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsUseridAvailable_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsUseridAvailable_result{isUseridAvailable_result_success = isUseridAvailable_result_success obj} then P.Nothing else P.Just $ default_IsUseridAvailable_result{isUseridAvailable_result_success = isUseridAvailable_result_success obj}
    , if obj == default_IsUseridAvailable_result{isUseridAvailable_result_e = isUseridAvailable_result_e obj} then P.Nothing else P.Just $ default_IsUseridAvailable_result{isUseridAvailable_result_e = isUseridAvailable_result_e obj}
    ]
from_IsUseridAvailable_result :: IsUseridAvailable_result -> T.ThriftVal
from_IsUseridAvailable_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4982 -> (1, ("e",from_TalkException _v4982))) <$> isUseridAvailable_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4982 -> P.Just (0, ("success",T.TBool _v4982))) $ isUseridAvailable_result_success record
    , (\_v4982 -> (1, ("e",from_TalkException _v4982))) <$> isUseridAvailable_result_e record
    ]
    )
write_IsUseridAvailable_result :: T.Protocol p => p -> IsUseridAvailable_result -> P.IO ()
write_IsUseridAvailable_result oprot record = T.writeVal oprot $ from_IsUseridAvailable_result record
encode_IsUseridAvailable_result :: T.StatelessProtocol p => p -> IsUseridAvailable_result -> LBS.ByteString
encode_IsUseridAvailable_result oprot record = T.serializeVal oprot $ from_IsUseridAvailable_result record
to_IsUseridAvailable_result :: T.ThriftVal -> IsUseridAvailable_result
to_IsUseridAvailable_result (T.TStruct fields) = IsUseridAvailable_result{
  isUseridAvailable_result_success = P.maybe (isUseridAvailable_result_success default_IsUseridAvailable_result) (\(_,_val4984) -> (case _val4984 of {T.TBool _val4985 -> _val4985; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isUseridAvailable_result_e = P.maybe (P.Nothing) (\(_,_val4984) -> P.Just (case _val4984 of {T.TStruct _val4986 -> (to_TalkException (T.TStruct _val4986)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsUseridAvailable_result _ = P.error "not a struct"
read_IsUseridAvailable_result :: T.Protocol p => p -> P.IO IsUseridAvailable_result
read_IsUseridAvailable_result iprot = to_IsUseridAvailable_result <$> T.readVal iprot (T.T_STRUCT typemap_IsUseridAvailable_result)
decode_IsUseridAvailable_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsUseridAvailable_result
decode_IsUseridAvailable_result iprot bs = to_IsUseridAvailable_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsUseridAvailable_result) bs
typemap_IsUseridAvailable_result :: T.TypeMap
typemap_IsUseridAvailable_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsUseridAvailable_result :: IsUseridAvailable_result
default_IsUseridAvailable_result = IsUseridAvailable_result{
  isUseridAvailable_result_success = P.False,
  isUseridAvailable_result_e = P.Nothing}
data KickoutFromGroup_args = KickoutFromGroup_args  { kickoutFromGroup_args_reqSeq :: I.Int32
  , kickoutFromGroup_args_groupId :: LT.Text
  , kickoutFromGroup_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable KickoutFromGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` kickoutFromGroup_args_reqSeq record   `H.hashWithSalt` kickoutFromGroup_args_groupId record   `H.hashWithSalt` kickoutFromGroup_args_contactIds record  
instance QC.Arbitrary KickoutFromGroup_args where 
  arbitrary = M.liftM KickoutFromGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_KickoutFromGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KickoutFromGroup_args{kickoutFromGroup_args_reqSeq = kickoutFromGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_KickoutFromGroup_args{kickoutFromGroup_args_reqSeq = kickoutFromGroup_args_reqSeq obj}
    , if obj == default_KickoutFromGroup_args{kickoutFromGroup_args_groupId = kickoutFromGroup_args_groupId obj} then P.Nothing else P.Just $ default_KickoutFromGroup_args{kickoutFromGroup_args_groupId = kickoutFromGroup_args_groupId obj}
    , if obj == default_KickoutFromGroup_args{kickoutFromGroup_args_contactIds = kickoutFromGroup_args_contactIds obj} then P.Nothing else P.Just $ default_KickoutFromGroup_args{kickoutFromGroup_args_contactIds = kickoutFromGroup_args_contactIds obj}
    ]
from_KickoutFromGroup_args :: KickoutFromGroup_args -> T.ThriftVal
from_KickoutFromGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4989 -> P.Just (1, ("reqSeq",T.TI32 _v4989))) $ kickoutFromGroup_args_reqSeq record
  , (\_v4989 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v4989))) $ kickoutFromGroup_args_groupId record
  , (\_v4989 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v4991 -> T.TString $ E.encodeUtf8 _v4991) $ Vector.toList _v4989))) $ kickoutFromGroup_args_contactIds record
  ]
write_KickoutFromGroup_args :: T.Protocol p => p -> KickoutFromGroup_args -> P.IO ()
write_KickoutFromGroup_args oprot record = T.writeVal oprot $ from_KickoutFromGroup_args record
encode_KickoutFromGroup_args :: T.StatelessProtocol p => p -> KickoutFromGroup_args -> LBS.ByteString
encode_KickoutFromGroup_args oprot record = T.serializeVal oprot $ from_KickoutFromGroup_args record
to_KickoutFromGroup_args :: T.ThriftVal -> KickoutFromGroup_args
to_KickoutFromGroup_args (T.TStruct fields) = KickoutFromGroup_args{
  kickoutFromGroup_args_reqSeq = P.maybe (kickoutFromGroup_args_reqSeq default_KickoutFromGroup_args) (\(_,_val4993) -> (case _val4993 of {T.TI32 _val4994 -> _val4994; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  kickoutFromGroup_args_groupId = P.maybe (kickoutFromGroup_args_groupId default_KickoutFromGroup_args) (\(_,_val4993) -> (case _val4993 of {T.TString _val4995 -> E.decodeUtf8 _val4995; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  kickoutFromGroup_args_contactIds = P.maybe (kickoutFromGroup_args_contactIds default_KickoutFromGroup_args) (\(_,_val4993) -> (case _val4993 of {T.TList _ _val4996 -> (Vector.fromList $ P.map (\_v4997 -> (case _v4997 of {T.TString _val4998 -> E.decodeUtf8 _val4998; _ -> P.error "wrong type"})) _val4996); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_KickoutFromGroup_args _ = P.error "not a struct"
read_KickoutFromGroup_args :: T.Protocol p => p -> P.IO KickoutFromGroup_args
read_KickoutFromGroup_args iprot = to_KickoutFromGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_KickoutFromGroup_args)
decode_KickoutFromGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> KickoutFromGroup_args
decode_KickoutFromGroup_args iprot bs = to_KickoutFromGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_KickoutFromGroup_args) bs
typemap_KickoutFromGroup_args :: T.TypeMap
typemap_KickoutFromGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_KickoutFromGroup_args :: KickoutFromGroup_args
default_KickoutFromGroup_args = KickoutFromGroup_args{
  kickoutFromGroup_args_reqSeq = 0,
  kickoutFromGroup_args_groupId = "",
  kickoutFromGroup_args_contactIds = Vector.empty}
data KickoutFromGroup_result = KickoutFromGroup_result  { kickoutFromGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable KickoutFromGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` kickoutFromGroup_result_e record  
instance QC.Arbitrary KickoutFromGroup_result where 
  arbitrary = M.liftM KickoutFromGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_KickoutFromGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KickoutFromGroup_result{kickoutFromGroup_result_e = kickoutFromGroup_result_e obj} then P.Nothing else P.Just $ default_KickoutFromGroup_result{kickoutFromGroup_result_e = kickoutFromGroup_result_e obj}
    ]
from_KickoutFromGroup_result :: KickoutFromGroup_result -> T.ThriftVal
from_KickoutFromGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5001 -> (1, ("e",from_TalkException _v5001))) <$> kickoutFromGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5001 -> (1, ("e",from_TalkException _v5001))) <$> kickoutFromGroup_result_e record
    ]
    )
write_KickoutFromGroup_result :: T.Protocol p => p -> KickoutFromGroup_result -> P.IO ()
write_KickoutFromGroup_result oprot record = T.writeVal oprot $ from_KickoutFromGroup_result record
encode_KickoutFromGroup_result :: T.StatelessProtocol p => p -> KickoutFromGroup_result -> LBS.ByteString
encode_KickoutFromGroup_result oprot record = T.serializeVal oprot $ from_KickoutFromGroup_result record
to_KickoutFromGroup_result :: T.ThriftVal -> KickoutFromGroup_result
to_KickoutFromGroup_result (T.TStruct fields) = KickoutFromGroup_result{
  kickoutFromGroup_result_e = P.maybe (P.Nothing) (\(_,_val5003) -> P.Just (case _val5003 of {T.TStruct _val5004 -> (to_TalkException (T.TStruct _val5004)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_KickoutFromGroup_result _ = P.error "not a struct"
read_KickoutFromGroup_result :: T.Protocol p => p -> P.IO KickoutFromGroup_result
read_KickoutFromGroup_result iprot = to_KickoutFromGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_KickoutFromGroup_result)
decode_KickoutFromGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> KickoutFromGroup_result
decode_KickoutFromGroup_result iprot bs = to_KickoutFromGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_KickoutFromGroup_result) bs
typemap_KickoutFromGroup_result :: T.TypeMap
typemap_KickoutFromGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_KickoutFromGroup_result :: KickoutFromGroup_result
default_KickoutFromGroup_result = KickoutFromGroup_result{
  kickoutFromGroup_result_e = P.Nothing}
data LeaveGroup_args = LeaveGroup_args  { leaveGroup_args_reqSeq :: I.Int32
  , leaveGroup_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveGroup_args_reqSeq record   `H.hashWithSalt` leaveGroup_args_groupId record  
instance QC.Arbitrary LeaveGroup_args where 
  arbitrary = M.liftM LeaveGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LeaveGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveGroup_args{leaveGroup_args_reqSeq = leaveGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_LeaveGroup_args{leaveGroup_args_reqSeq = leaveGroup_args_reqSeq obj}
    , if obj == default_LeaveGroup_args{leaveGroup_args_groupId = leaveGroup_args_groupId obj} then P.Nothing else P.Just $ default_LeaveGroup_args{leaveGroup_args_groupId = leaveGroup_args_groupId obj}
    ]
from_LeaveGroup_args :: LeaveGroup_args -> T.ThriftVal
from_LeaveGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5007 -> P.Just (1, ("reqSeq",T.TI32 _v5007))) $ leaveGroup_args_reqSeq record
  , (\_v5007 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v5007))) $ leaveGroup_args_groupId record
  ]
write_LeaveGroup_args :: T.Protocol p => p -> LeaveGroup_args -> P.IO ()
write_LeaveGroup_args oprot record = T.writeVal oprot $ from_LeaveGroup_args record
encode_LeaveGroup_args :: T.StatelessProtocol p => p -> LeaveGroup_args -> LBS.ByteString
encode_LeaveGroup_args oprot record = T.serializeVal oprot $ from_LeaveGroup_args record
to_LeaveGroup_args :: T.ThriftVal -> LeaveGroup_args
to_LeaveGroup_args (T.TStruct fields) = LeaveGroup_args{
  leaveGroup_args_reqSeq = P.maybe (leaveGroup_args_reqSeq default_LeaveGroup_args) (\(_,_val5009) -> (case _val5009 of {T.TI32 _val5010 -> _val5010; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  leaveGroup_args_groupId = P.maybe (leaveGroup_args_groupId default_LeaveGroup_args) (\(_,_val5009) -> (case _val5009 of {T.TString _val5011 -> E.decodeUtf8 _val5011; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LeaveGroup_args _ = P.error "not a struct"
read_LeaveGroup_args :: T.Protocol p => p -> P.IO LeaveGroup_args
read_LeaveGroup_args iprot = to_LeaveGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_LeaveGroup_args)
decode_LeaveGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveGroup_args
decode_LeaveGroup_args iprot bs = to_LeaveGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveGroup_args) bs
typemap_LeaveGroup_args :: T.TypeMap
typemap_LeaveGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING))]
default_LeaveGroup_args :: LeaveGroup_args
default_LeaveGroup_args = LeaveGroup_args{
  leaveGroup_args_reqSeq = 0,
  leaveGroup_args_groupId = ""}
data LeaveGroup_result = LeaveGroup_result  { leaveGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveGroup_result_e record  
instance QC.Arbitrary LeaveGroup_result where 
  arbitrary = M.liftM LeaveGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LeaveGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveGroup_result{leaveGroup_result_e = leaveGroup_result_e obj} then P.Nothing else P.Just $ default_LeaveGroup_result{leaveGroup_result_e = leaveGroup_result_e obj}
    ]
from_LeaveGroup_result :: LeaveGroup_result -> T.ThriftVal
from_LeaveGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5014 -> (1, ("e",from_TalkException _v5014))) <$> leaveGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5014 -> (1, ("e",from_TalkException _v5014))) <$> leaveGroup_result_e record
    ]
    )
write_LeaveGroup_result :: T.Protocol p => p -> LeaveGroup_result -> P.IO ()
write_LeaveGroup_result oprot record = T.writeVal oprot $ from_LeaveGroup_result record
encode_LeaveGroup_result :: T.StatelessProtocol p => p -> LeaveGroup_result -> LBS.ByteString
encode_LeaveGroup_result oprot record = T.serializeVal oprot $ from_LeaveGroup_result record
to_LeaveGroup_result :: T.ThriftVal -> LeaveGroup_result
to_LeaveGroup_result (T.TStruct fields) = LeaveGroup_result{
  leaveGroup_result_e = P.maybe (P.Nothing) (\(_,_val5016) -> P.Just (case _val5016 of {T.TStruct _val5017 -> (to_TalkException (T.TStruct _val5017)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveGroup_result _ = P.error "not a struct"
read_LeaveGroup_result :: T.Protocol p => p -> P.IO LeaveGroup_result
read_LeaveGroup_result iprot = to_LeaveGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_LeaveGroup_result)
decode_LeaveGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveGroup_result
decode_LeaveGroup_result iprot bs = to_LeaveGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveGroup_result) bs
typemap_LeaveGroup_result :: T.TypeMap
typemap_LeaveGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LeaveGroup_result :: LeaveGroup_result
default_LeaveGroup_result = LeaveGroup_result{
  leaveGroup_result_e = P.Nothing}
data LeaveRoom_args = LeaveRoom_args  { leaveRoom_args_reqSeq :: I.Int32
  , leaveRoom_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveRoom_args_reqSeq record   `H.hashWithSalt` leaveRoom_args_roomId record  
instance QC.Arbitrary LeaveRoom_args where 
  arbitrary = M.liftM LeaveRoom_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LeaveRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveRoom_args{leaveRoom_args_reqSeq = leaveRoom_args_reqSeq obj} then P.Nothing else P.Just $ default_LeaveRoom_args{leaveRoom_args_reqSeq = leaveRoom_args_reqSeq obj}
    , if obj == default_LeaveRoom_args{leaveRoom_args_roomId = leaveRoom_args_roomId obj} then P.Nothing else P.Just $ default_LeaveRoom_args{leaveRoom_args_roomId = leaveRoom_args_roomId obj}
    ]
from_LeaveRoom_args :: LeaveRoom_args -> T.ThriftVal
from_LeaveRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5020 -> P.Just (1, ("reqSeq",T.TI32 _v5020))) $ leaveRoom_args_reqSeq record
  , (\_v5020 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v5020))) $ leaveRoom_args_roomId record
  ]
write_LeaveRoom_args :: T.Protocol p => p -> LeaveRoom_args -> P.IO ()
write_LeaveRoom_args oprot record = T.writeVal oprot $ from_LeaveRoom_args record
encode_LeaveRoom_args :: T.StatelessProtocol p => p -> LeaveRoom_args -> LBS.ByteString
encode_LeaveRoom_args oprot record = T.serializeVal oprot $ from_LeaveRoom_args record
to_LeaveRoom_args :: T.ThriftVal -> LeaveRoom_args
to_LeaveRoom_args (T.TStruct fields) = LeaveRoom_args{
  leaveRoom_args_reqSeq = P.maybe (leaveRoom_args_reqSeq default_LeaveRoom_args) (\(_,_val5022) -> (case _val5022 of {T.TI32 _val5023 -> _val5023; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  leaveRoom_args_roomId = P.maybe (leaveRoom_args_roomId default_LeaveRoom_args) (\(_,_val5022) -> (case _val5022 of {T.TString _val5024 -> E.decodeUtf8 _val5024; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LeaveRoom_args _ = P.error "not a struct"
read_LeaveRoom_args :: T.Protocol p => p -> P.IO LeaveRoom_args
read_LeaveRoom_args iprot = to_LeaveRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_LeaveRoom_args)
decode_LeaveRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveRoom_args
decode_LeaveRoom_args iprot bs = to_LeaveRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveRoom_args) bs
typemap_LeaveRoom_args :: T.TypeMap
typemap_LeaveRoom_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("roomId",T.T_STRING))]
default_LeaveRoom_args :: LeaveRoom_args
default_LeaveRoom_args = LeaveRoom_args{
  leaveRoom_args_reqSeq = 0,
  leaveRoom_args_roomId = ""}
data LeaveRoom_result = LeaveRoom_result  { leaveRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveRoom_result_e record  
instance QC.Arbitrary LeaveRoom_result where 
  arbitrary = M.liftM LeaveRoom_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LeaveRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveRoom_result{leaveRoom_result_e = leaveRoom_result_e obj} then P.Nothing else P.Just $ default_LeaveRoom_result{leaveRoom_result_e = leaveRoom_result_e obj}
    ]
from_LeaveRoom_result :: LeaveRoom_result -> T.ThriftVal
from_LeaveRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5027 -> (1, ("e",from_TalkException _v5027))) <$> leaveRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5027 -> (1, ("e",from_TalkException _v5027))) <$> leaveRoom_result_e record
    ]
    )
write_LeaveRoom_result :: T.Protocol p => p -> LeaveRoom_result -> P.IO ()
write_LeaveRoom_result oprot record = T.writeVal oprot $ from_LeaveRoom_result record
encode_LeaveRoom_result :: T.StatelessProtocol p => p -> LeaveRoom_result -> LBS.ByteString
encode_LeaveRoom_result oprot record = T.serializeVal oprot $ from_LeaveRoom_result record
to_LeaveRoom_result :: T.ThriftVal -> LeaveRoom_result
to_LeaveRoom_result (T.TStruct fields) = LeaveRoom_result{
  leaveRoom_result_e = P.maybe (P.Nothing) (\(_,_val5029) -> P.Just (case _val5029 of {T.TStruct _val5030 -> (to_TalkException (T.TStruct _val5030)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveRoom_result _ = P.error "not a struct"
read_LeaveRoom_result :: T.Protocol p => p -> P.IO LeaveRoom_result
read_LeaveRoom_result iprot = to_LeaveRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_LeaveRoom_result)
decode_LeaveRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveRoom_result
decode_LeaveRoom_result iprot bs = to_LeaveRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveRoom_result) bs
typemap_LeaveRoom_result :: T.TypeMap
typemap_LeaveRoom_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LeaveRoom_result :: LeaveRoom_result
default_LeaveRoom_result = LeaveRoom_result{
  leaveRoom_result_e = P.Nothing}
data LoginWithIdentityCredential_args = LoginWithIdentityCredential_args  { loginWithIdentityCredential_args_identityProvider :: IdentityProvider
  , loginWithIdentityCredential_args_identifier :: LT.Text
  , loginWithIdentityCredential_args_password :: LT.Text
  , loginWithIdentityCredential_args_keepLoggedIn :: P.Bool
  , loginWithIdentityCredential_args_accessLocation :: LT.Text
  , loginWithIdentityCredential_args_systemName :: LT.Text
  , loginWithIdentityCredential_args_certificate :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredential_args_identityProvider record   `H.hashWithSalt` loginWithIdentityCredential_args_identifier record   `H.hashWithSalt` loginWithIdentityCredential_args_password record   `H.hashWithSalt` loginWithIdentityCredential_args_keepLoggedIn record   `H.hashWithSalt` loginWithIdentityCredential_args_accessLocation record   `H.hashWithSalt` loginWithIdentityCredential_args_systemName record   `H.hashWithSalt` loginWithIdentityCredential_args_certificate record  
instance QC.Arbitrary LoginWithIdentityCredential_args where 
  arbitrary = M.liftM LoginWithIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identityProvider = loginWithIdentityCredential_args_identityProvider obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identityProvider = loginWithIdentityCredential_args_identityProvider obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identifier = loginWithIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identifier = loginWithIdentityCredential_args_identifier obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_password = loginWithIdentityCredential_args_password obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_password = loginWithIdentityCredential_args_password obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_keepLoggedIn = loginWithIdentityCredential_args_keepLoggedIn obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_keepLoggedIn = loginWithIdentityCredential_args_keepLoggedIn obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_accessLocation = loginWithIdentityCredential_args_accessLocation obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_accessLocation = loginWithIdentityCredential_args_accessLocation obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_systemName = loginWithIdentityCredential_args_systemName obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_systemName = loginWithIdentityCredential_args_systemName obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_certificate = loginWithIdentityCredential_args_certificate obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_certificate = loginWithIdentityCredential_args_certificate obj}
    ]
from_LoginWithIdentityCredential_args :: LoginWithIdentityCredential_args -> T.ThriftVal
from_LoginWithIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5033 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v5033))) $ loginWithIdentityCredential_args_identifier record
  , (\_v5033 -> P.Just (4, ("password",T.TString $ E.encodeUtf8 _v5033))) $ loginWithIdentityCredential_args_password record
  , (\_v5033 -> P.Just (5, ("keepLoggedIn",T.TBool _v5033))) $ loginWithIdentityCredential_args_keepLoggedIn record
  , (\_v5033 -> P.Just (6, ("accessLocation",T.TString $ E.encodeUtf8 _v5033))) $ loginWithIdentityCredential_args_accessLocation record
  , (\_v5033 -> P.Just (7, ("systemName",T.TString $ E.encodeUtf8 _v5033))) $ loginWithIdentityCredential_args_systemName record
  , (\_v5033 -> P.Just (8, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v5033))) $ loginWithIdentityCredential_args_identityProvider record
  , (\_v5033 -> P.Just (9, ("certificate",T.TString $ E.encodeUtf8 _v5033))) $ loginWithIdentityCredential_args_certificate record
  ]
write_LoginWithIdentityCredential_args :: T.Protocol p => p -> LoginWithIdentityCredential_args -> P.IO ()
write_LoginWithIdentityCredential_args oprot record = T.writeVal oprot $ from_LoginWithIdentityCredential_args record
encode_LoginWithIdentityCredential_args :: T.StatelessProtocol p => p -> LoginWithIdentityCredential_args -> LBS.ByteString
encode_LoginWithIdentityCredential_args oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredential_args record
to_LoginWithIdentityCredential_args :: T.ThriftVal -> LoginWithIdentityCredential_args
to_LoginWithIdentityCredential_args (T.TStruct fields) = LoginWithIdentityCredential_args{
  loginWithIdentityCredential_args_identityProvider = P.maybe (loginWithIdentityCredential_args_identityProvider default_LoginWithIdentityCredential_args) (\(_,_val5035) -> (case _val5035 of {T.TI32 _val5036 -> P.toEnum $ P.fromIntegral _val5036; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  loginWithIdentityCredential_args_identifier = P.maybe (loginWithIdentityCredential_args_identifier default_LoginWithIdentityCredential_args) (\(_,_val5035) -> (case _val5035 of {T.TString _val5037 -> E.decodeUtf8 _val5037; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginWithIdentityCredential_args_password = P.maybe (loginWithIdentityCredential_args_password default_LoginWithIdentityCredential_args) (\(_,_val5035) -> (case _val5035 of {T.TString _val5038 -> E.decodeUtf8 _val5038; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  loginWithIdentityCredential_args_keepLoggedIn = P.maybe (loginWithIdentityCredential_args_keepLoggedIn default_LoginWithIdentityCredential_args) (\(_,_val5035) -> (case _val5035 of {T.TBool _val5039 -> _val5039; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  loginWithIdentityCredential_args_accessLocation = P.maybe (loginWithIdentityCredential_args_accessLocation default_LoginWithIdentityCredential_args) (\(_,_val5035) -> (case _val5035 of {T.TString _val5040 -> E.decodeUtf8 _val5040; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  loginWithIdentityCredential_args_systemName = P.maybe (loginWithIdentityCredential_args_systemName default_LoginWithIdentityCredential_args) (\(_,_val5035) -> (case _val5035 of {T.TString _val5041 -> E.decodeUtf8 _val5041; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  loginWithIdentityCredential_args_certificate = P.maybe (loginWithIdentityCredential_args_certificate default_LoginWithIdentityCredential_args) (\(_,_val5035) -> (case _val5035 of {T.TString _val5042 -> E.decodeUtf8 _val5042; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_LoginWithIdentityCredential_args _ = P.error "not a struct"
read_LoginWithIdentityCredential_args :: T.Protocol p => p -> P.IO LoginWithIdentityCredential_args
read_LoginWithIdentityCredential_args iprot = to_LoginWithIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_args)
decode_LoginWithIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredential_args
decode_LoginWithIdentityCredential_args iprot bs = to_LoginWithIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_args) bs
typemap_LoginWithIdentityCredential_args :: T.TypeMap
typemap_LoginWithIdentityCredential_args = Map.fromList [(3,("identifier",T.T_STRING)),(4,("password",T.T_STRING)),(5,("keepLoggedIn",T.T_BOOL)),(6,("accessLocation",T.T_STRING)),(7,("systemName",T.T_STRING)),(8,("identityProvider",T.T_I32)),(9,("certificate",T.T_STRING))]
default_LoginWithIdentityCredential_args :: LoginWithIdentityCredential_args
default_LoginWithIdentityCredential_args = LoginWithIdentityCredential_args{
  loginWithIdentityCredential_args_identifier = "",
  loginWithIdentityCredential_args_password = "",
  loginWithIdentityCredential_args_keepLoggedIn = P.False,
  loginWithIdentityCredential_args_accessLocation = "",
  loginWithIdentityCredential_args_systemName = "",
  loginWithIdentityCredential_args_identityProvider = (P.toEnum 0),
  loginWithIdentityCredential_args_certificate = ""}
data LoginWithIdentityCredential_result = LoginWithIdentityCredential_result  { loginWithIdentityCredential_result_success :: LT.Text
  , loginWithIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredential_result_success record   `H.hashWithSalt` loginWithIdentityCredential_result_e record  
instance QC.Arbitrary LoginWithIdentityCredential_result where 
  arbitrary = M.liftM LoginWithIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_success = loginWithIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_success = loginWithIdentityCredential_result_success obj}
    , if obj == default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_e = loginWithIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_e = loginWithIdentityCredential_result_e obj}
    ]
from_LoginWithIdentityCredential_result :: LoginWithIdentityCredential_result -> T.ThriftVal
from_LoginWithIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5045 -> (1, ("e",from_TalkException _v5045))) <$> loginWithIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5045 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5045))) $ loginWithIdentityCredential_result_success record
    , (\_v5045 -> (1, ("e",from_TalkException _v5045))) <$> loginWithIdentityCredential_result_e record
    ]
    )
write_LoginWithIdentityCredential_result :: T.Protocol p => p -> LoginWithIdentityCredential_result -> P.IO ()
write_LoginWithIdentityCredential_result oprot record = T.writeVal oprot $ from_LoginWithIdentityCredential_result record
encode_LoginWithIdentityCredential_result :: T.StatelessProtocol p => p -> LoginWithIdentityCredential_result -> LBS.ByteString
encode_LoginWithIdentityCredential_result oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredential_result record
to_LoginWithIdentityCredential_result :: T.ThriftVal -> LoginWithIdentityCredential_result
to_LoginWithIdentityCredential_result (T.TStruct fields) = LoginWithIdentityCredential_result{
  loginWithIdentityCredential_result_success = P.maybe (loginWithIdentityCredential_result_success default_LoginWithIdentityCredential_result) (\(_,_val5047) -> (case _val5047 of {T.TString _val5048 -> E.decodeUtf8 _val5048; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val5047) -> P.Just (case _val5047 of {T.TStruct _val5049 -> (to_TalkException (T.TStruct _val5049)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithIdentityCredential_result _ = P.error "not a struct"
read_LoginWithIdentityCredential_result :: T.Protocol p => p -> P.IO LoginWithIdentityCredential_result
read_LoginWithIdentityCredential_result iprot = to_LoginWithIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_result)
decode_LoginWithIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredential_result
decode_LoginWithIdentityCredential_result iprot bs = to_LoginWithIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_result) bs
typemap_LoginWithIdentityCredential_result :: T.TypeMap
typemap_LoginWithIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithIdentityCredential_result :: LoginWithIdentityCredential_result
default_LoginWithIdentityCredential_result = LoginWithIdentityCredential_result{
  loginWithIdentityCredential_result_success = "",
  loginWithIdentityCredential_result_e = P.Nothing}
data LoginWithIdentityCredentialForCertificate_args = LoginWithIdentityCredentialForCertificate_args  { loginWithIdentityCredentialForCertificate_args_identityProvider :: IdentityProvider
  , loginWithIdentityCredentialForCertificate_args_identifier :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_password :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_keepLoggedIn :: P.Bool
  , loginWithIdentityCredentialForCertificate_args_accessLocation :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_systemName :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_certificate :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredentialForCertificate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_identityProvider record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_identifier record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_password record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_keepLoggedIn record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_accessLocation record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_systemName record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_certificate record  
instance QC.Arbitrary LoginWithIdentityCredentialForCertificate_args where 
  arbitrary = M.liftM LoginWithIdentityCredentialForCertificate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredentialForCertificate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identityProvider = loginWithIdentityCredentialForCertificate_args_identityProvider obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identityProvider = loginWithIdentityCredentialForCertificate_args_identityProvider obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identifier = loginWithIdentityCredentialForCertificate_args_identifier obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identifier = loginWithIdentityCredentialForCertificate_args_identifier obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_password = loginWithIdentityCredentialForCertificate_args_password obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_password = loginWithIdentityCredentialForCertificate_args_password obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_keepLoggedIn = loginWithIdentityCredentialForCertificate_args_keepLoggedIn obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_keepLoggedIn = loginWithIdentityCredentialForCertificate_args_keepLoggedIn obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_accessLocation = loginWithIdentityCredentialForCertificate_args_accessLocation obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_accessLocation = loginWithIdentityCredentialForCertificate_args_accessLocation obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_systemName = loginWithIdentityCredentialForCertificate_args_systemName obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_systemName = loginWithIdentityCredentialForCertificate_args_systemName obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_certificate = loginWithIdentityCredentialForCertificate_args_certificate obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_certificate = loginWithIdentityCredentialForCertificate_args_certificate obj}
    ]
from_LoginWithIdentityCredentialForCertificate_args :: LoginWithIdentityCredentialForCertificate_args -> T.ThriftVal
from_LoginWithIdentityCredentialForCertificate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5052 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v5052))) $ loginWithIdentityCredentialForCertificate_args_identifier record
  , (\_v5052 -> P.Just (4, ("password",T.TString $ E.encodeUtf8 _v5052))) $ loginWithIdentityCredentialForCertificate_args_password record
  , (\_v5052 -> P.Just (5, ("keepLoggedIn",T.TBool _v5052))) $ loginWithIdentityCredentialForCertificate_args_keepLoggedIn record
  , (\_v5052 -> P.Just (6, ("accessLocation",T.TString $ E.encodeUtf8 _v5052))) $ loginWithIdentityCredentialForCertificate_args_accessLocation record
  , (\_v5052 -> P.Just (7, ("systemName",T.TString $ E.encodeUtf8 _v5052))) $ loginWithIdentityCredentialForCertificate_args_systemName record
  , (\_v5052 -> P.Just (8, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v5052))) $ loginWithIdentityCredentialForCertificate_args_identityProvider record
  , (\_v5052 -> P.Just (9, ("certificate",T.TString $ E.encodeUtf8 _v5052))) $ loginWithIdentityCredentialForCertificate_args_certificate record
  ]
write_LoginWithIdentityCredentialForCertificate_args :: T.Protocol p => p -> LoginWithIdentityCredentialForCertificate_args -> P.IO ()
write_LoginWithIdentityCredentialForCertificate_args oprot record = T.writeVal oprot $ from_LoginWithIdentityCredentialForCertificate_args record
encode_LoginWithIdentityCredentialForCertificate_args :: T.StatelessProtocol p => p -> LoginWithIdentityCredentialForCertificate_args -> LBS.ByteString
encode_LoginWithIdentityCredentialForCertificate_args oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredentialForCertificate_args record
to_LoginWithIdentityCredentialForCertificate_args :: T.ThriftVal -> LoginWithIdentityCredentialForCertificate_args
to_LoginWithIdentityCredentialForCertificate_args (T.TStruct fields) = LoginWithIdentityCredentialForCertificate_args{
  loginWithIdentityCredentialForCertificate_args_identityProvider = P.maybe (loginWithIdentityCredentialForCertificate_args_identityProvider default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val5054) -> (case _val5054 of {T.TI32 _val5055 -> P.toEnum $ P.fromIntegral _val5055; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  loginWithIdentityCredentialForCertificate_args_identifier = P.maybe (loginWithIdentityCredentialForCertificate_args_identifier default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val5054) -> (case _val5054 of {T.TString _val5056 -> E.decodeUtf8 _val5056; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginWithIdentityCredentialForCertificate_args_password = P.maybe (loginWithIdentityCredentialForCertificate_args_password default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val5054) -> (case _val5054 of {T.TString _val5057 -> E.decodeUtf8 _val5057; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  loginWithIdentityCredentialForCertificate_args_keepLoggedIn = P.maybe (loginWithIdentityCredentialForCertificate_args_keepLoggedIn default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val5054) -> (case _val5054 of {T.TBool _val5058 -> _val5058; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  loginWithIdentityCredentialForCertificate_args_accessLocation = P.maybe (loginWithIdentityCredentialForCertificate_args_accessLocation default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val5054) -> (case _val5054 of {T.TString _val5059 -> E.decodeUtf8 _val5059; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  loginWithIdentityCredentialForCertificate_args_systemName = P.maybe (loginWithIdentityCredentialForCertificate_args_systemName default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val5054) -> (case _val5054 of {T.TString _val5060 -> E.decodeUtf8 _val5060; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  loginWithIdentityCredentialForCertificate_args_certificate = P.maybe (loginWithIdentityCredentialForCertificate_args_certificate default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val5054) -> (case _val5054 of {T.TString _val5061 -> E.decodeUtf8 _val5061; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_LoginWithIdentityCredentialForCertificate_args _ = P.error "not a struct"
read_LoginWithIdentityCredentialForCertificate_args :: T.Protocol p => p -> P.IO LoginWithIdentityCredentialForCertificate_args
read_LoginWithIdentityCredentialForCertificate_args iprot = to_LoginWithIdentityCredentialForCertificate_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_args)
decode_LoginWithIdentityCredentialForCertificate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredentialForCertificate_args
decode_LoginWithIdentityCredentialForCertificate_args iprot bs = to_LoginWithIdentityCredentialForCertificate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_args) bs
typemap_LoginWithIdentityCredentialForCertificate_args :: T.TypeMap
typemap_LoginWithIdentityCredentialForCertificate_args = Map.fromList [(3,("identifier",T.T_STRING)),(4,("password",T.T_STRING)),(5,("keepLoggedIn",T.T_BOOL)),(6,("accessLocation",T.T_STRING)),(7,("systemName",T.T_STRING)),(8,("identityProvider",T.T_I32)),(9,("certificate",T.T_STRING))]
default_LoginWithIdentityCredentialForCertificate_args :: LoginWithIdentityCredentialForCertificate_args
default_LoginWithIdentityCredentialForCertificate_args = LoginWithIdentityCredentialForCertificate_args{
  loginWithIdentityCredentialForCertificate_args_identifier = "",
  loginWithIdentityCredentialForCertificate_args_password = "",
  loginWithIdentityCredentialForCertificate_args_keepLoggedIn = P.False,
  loginWithIdentityCredentialForCertificate_args_accessLocation = "",
  loginWithIdentityCredentialForCertificate_args_systemName = "",
  loginWithIdentityCredentialForCertificate_args_identityProvider = (P.toEnum 0),
  loginWithIdentityCredentialForCertificate_args_certificate = ""}
data LoginWithIdentityCredentialForCertificate_result = LoginWithIdentityCredentialForCertificate_result  { loginWithIdentityCredentialForCertificate_result_success :: LoginResult
  , loginWithIdentityCredentialForCertificate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredentialForCertificate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_result_success record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_result_e record  
instance QC.Arbitrary LoginWithIdentityCredentialForCertificate_result where 
  arbitrary = M.liftM LoginWithIdentityCredentialForCertificate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredentialForCertificate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_success = loginWithIdentityCredentialForCertificate_result_success obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_success = loginWithIdentityCredentialForCertificate_result_success obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_e = loginWithIdentityCredentialForCertificate_result_e obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_e = loginWithIdentityCredentialForCertificate_result_e obj}
    ]
from_LoginWithIdentityCredentialForCertificate_result :: LoginWithIdentityCredentialForCertificate_result -> T.ThriftVal
from_LoginWithIdentityCredentialForCertificate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5064 -> (1, ("e",from_TalkException _v5064))) <$> loginWithIdentityCredentialForCertificate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5064 -> P.Just (0, ("success",from_LoginResult _v5064))) $ loginWithIdentityCredentialForCertificate_result_success record
    , (\_v5064 -> (1, ("e",from_TalkException _v5064))) <$> loginWithIdentityCredentialForCertificate_result_e record
    ]
    )
write_LoginWithIdentityCredentialForCertificate_result :: T.Protocol p => p -> LoginWithIdentityCredentialForCertificate_result -> P.IO ()
write_LoginWithIdentityCredentialForCertificate_result oprot record = T.writeVal oprot $ from_LoginWithIdentityCredentialForCertificate_result record
encode_LoginWithIdentityCredentialForCertificate_result :: T.StatelessProtocol p => p -> LoginWithIdentityCredentialForCertificate_result -> LBS.ByteString
encode_LoginWithIdentityCredentialForCertificate_result oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredentialForCertificate_result record
to_LoginWithIdentityCredentialForCertificate_result :: T.ThriftVal -> LoginWithIdentityCredentialForCertificate_result
to_LoginWithIdentityCredentialForCertificate_result (T.TStruct fields) = LoginWithIdentityCredentialForCertificate_result{
  loginWithIdentityCredentialForCertificate_result_success = P.maybe (loginWithIdentityCredentialForCertificate_result_success default_LoginWithIdentityCredentialForCertificate_result) (\(_,_val5066) -> (case _val5066 of {T.TStruct _val5067 -> (to_LoginResult (T.TStruct _val5067)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithIdentityCredentialForCertificate_result_e = P.maybe (P.Nothing) (\(_,_val5066) -> P.Just (case _val5066 of {T.TStruct _val5068 -> (to_TalkException (T.TStruct _val5068)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithIdentityCredentialForCertificate_result _ = P.error "not a struct"
read_LoginWithIdentityCredentialForCertificate_result :: T.Protocol p => p -> P.IO LoginWithIdentityCredentialForCertificate_result
read_LoginWithIdentityCredentialForCertificate_result iprot = to_LoginWithIdentityCredentialForCertificate_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_result)
decode_LoginWithIdentityCredentialForCertificate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredentialForCertificate_result
decode_LoginWithIdentityCredentialForCertificate_result iprot bs = to_LoginWithIdentityCredentialForCertificate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_result) bs
typemap_LoginWithIdentityCredentialForCertificate_result :: T.TypeMap
typemap_LoginWithIdentityCredentialForCertificate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithIdentityCredentialForCertificate_result :: LoginWithIdentityCredentialForCertificate_result
default_LoginWithIdentityCredentialForCertificate_result = LoginWithIdentityCredentialForCertificate_result{
  loginWithIdentityCredentialForCertificate_result_success = default_LoginResult,
  loginWithIdentityCredentialForCertificate_result_e = P.Nothing}
data LoginWithVerifier_args = LoginWithVerifier_args  { loginWithVerifier_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifier_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifier_args_verifier record  
instance QC.Arbitrary LoginWithVerifier_args where 
  arbitrary = M.liftM LoginWithVerifier_args (QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifier_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifier_args{loginWithVerifier_args_verifier = loginWithVerifier_args_verifier obj} then P.Nothing else P.Just $ default_LoginWithVerifier_args{loginWithVerifier_args_verifier = loginWithVerifier_args_verifier obj}
    ]
from_LoginWithVerifier_args :: LoginWithVerifier_args -> T.ThriftVal
from_LoginWithVerifier_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5071 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v5071))) $ loginWithVerifier_args_verifier record
  ]
write_LoginWithVerifier_args :: T.Protocol p => p -> LoginWithVerifier_args -> P.IO ()
write_LoginWithVerifier_args oprot record = T.writeVal oprot $ from_LoginWithVerifier_args record
encode_LoginWithVerifier_args :: T.StatelessProtocol p => p -> LoginWithVerifier_args -> LBS.ByteString
encode_LoginWithVerifier_args oprot record = T.serializeVal oprot $ from_LoginWithVerifier_args record
to_LoginWithVerifier_args :: T.ThriftVal -> LoginWithVerifier_args
to_LoginWithVerifier_args (T.TStruct fields) = LoginWithVerifier_args{
  loginWithVerifier_args_verifier = P.maybe (loginWithVerifier_args_verifier default_LoginWithVerifier_args) (\(_,_val5073) -> (case _val5073 of {T.TString _val5074 -> E.decodeUtf8 _val5074; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_LoginWithVerifier_args _ = P.error "not a struct"
read_LoginWithVerifier_args :: T.Protocol p => p -> P.IO LoginWithVerifier_args
read_LoginWithVerifier_args iprot = to_LoginWithVerifier_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifier_args)
decode_LoginWithVerifier_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifier_args
decode_LoginWithVerifier_args iprot bs = to_LoginWithVerifier_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifier_args) bs
typemap_LoginWithVerifier_args :: T.TypeMap
typemap_LoginWithVerifier_args = Map.fromList [(3,("verifier",T.T_STRING))]
default_LoginWithVerifier_args :: LoginWithVerifier_args
default_LoginWithVerifier_args = LoginWithVerifier_args{
  loginWithVerifier_args_verifier = ""}
data LoginWithVerifier_result = LoginWithVerifier_result  { loginWithVerifier_result_success :: LT.Text
  , loginWithVerifier_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifier_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifier_result_success record   `H.hashWithSalt` loginWithVerifier_result_e record  
instance QC.Arbitrary LoginWithVerifier_result where 
  arbitrary = M.liftM LoginWithVerifier_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifier_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifier_result{loginWithVerifier_result_success = loginWithVerifier_result_success obj} then P.Nothing else P.Just $ default_LoginWithVerifier_result{loginWithVerifier_result_success = loginWithVerifier_result_success obj}
    , if obj == default_LoginWithVerifier_result{loginWithVerifier_result_e = loginWithVerifier_result_e obj} then P.Nothing else P.Just $ default_LoginWithVerifier_result{loginWithVerifier_result_e = loginWithVerifier_result_e obj}
    ]
from_LoginWithVerifier_result :: LoginWithVerifier_result -> T.ThriftVal
from_LoginWithVerifier_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5077 -> (1, ("e",from_TalkException _v5077))) <$> loginWithVerifier_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5077 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5077))) $ loginWithVerifier_result_success record
    , (\_v5077 -> (1, ("e",from_TalkException _v5077))) <$> loginWithVerifier_result_e record
    ]
    )
write_LoginWithVerifier_result :: T.Protocol p => p -> LoginWithVerifier_result -> P.IO ()
write_LoginWithVerifier_result oprot record = T.writeVal oprot $ from_LoginWithVerifier_result record
encode_LoginWithVerifier_result :: T.StatelessProtocol p => p -> LoginWithVerifier_result -> LBS.ByteString
encode_LoginWithVerifier_result oprot record = T.serializeVal oprot $ from_LoginWithVerifier_result record
to_LoginWithVerifier_result :: T.ThriftVal -> LoginWithVerifier_result
to_LoginWithVerifier_result (T.TStruct fields) = LoginWithVerifier_result{
  loginWithVerifier_result_success = P.maybe (loginWithVerifier_result_success default_LoginWithVerifier_result) (\(_,_val5079) -> (case _val5079 of {T.TString _val5080 -> E.decodeUtf8 _val5080; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithVerifier_result_e = P.maybe (P.Nothing) (\(_,_val5079) -> P.Just (case _val5079 of {T.TStruct _val5081 -> (to_TalkException (T.TStruct _val5081)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithVerifier_result _ = P.error "not a struct"
read_LoginWithVerifier_result :: T.Protocol p => p -> P.IO LoginWithVerifier_result
read_LoginWithVerifier_result iprot = to_LoginWithVerifier_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifier_result)
decode_LoginWithVerifier_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifier_result
decode_LoginWithVerifier_result iprot bs = to_LoginWithVerifier_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifier_result) bs
typemap_LoginWithVerifier_result :: T.TypeMap
typemap_LoginWithVerifier_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithVerifier_result :: LoginWithVerifier_result
default_LoginWithVerifier_result = LoginWithVerifier_result{
  loginWithVerifier_result_success = "",
  loginWithVerifier_result_e = P.Nothing}
data LoginWithVerifierForCerificate_args = LoginWithVerifierForCerificate_args  { loginWithVerifierForCerificate_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCerificate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCerificate_args_verifier record  
instance QC.Arbitrary LoginWithVerifierForCerificate_args where 
  arbitrary = M.liftM LoginWithVerifierForCerificate_args (QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCerificate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCerificate_args{loginWithVerifierForCerificate_args_verifier = loginWithVerifierForCerificate_args_verifier obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCerificate_args{loginWithVerifierForCerificate_args_verifier = loginWithVerifierForCerificate_args_verifier obj}
    ]
from_LoginWithVerifierForCerificate_args :: LoginWithVerifierForCerificate_args -> T.ThriftVal
from_LoginWithVerifierForCerificate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5084 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v5084))) $ loginWithVerifierForCerificate_args_verifier record
  ]
write_LoginWithVerifierForCerificate_args :: T.Protocol p => p -> LoginWithVerifierForCerificate_args -> P.IO ()
write_LoginWithVerifierForCerificate_args oprot record = T.writeVal oprot $ from_LoginWithVerifierForCerificate_args record
encode_LoginWithVerifierForCerificate_args :: T.StatelessProtocol p => p -> LoginWithVerifierForCerificate_args -> LBS.ByteString
encode_LoginWithVerifierForCerificate_args oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCerificate_args record
to_LoginWithVerifierForCerificate_args :: T.ThriftVal -> LoginWithVerifierForCerificate_args
to_LoginWithVerifierForCerificate_args (T.TStruct fields) = LoginWithVerifierForCerificate_args{
  loginWithVerifierForCerificate_args_verifier = P.maybe (loginWithVerifierForCerificate_args_verifier default_LoginWithVerifierForCerificate_args) (\(_,_val5086) -> (case _val5086 of {T.TString _val5087 -> E.decodeUtf8 _val5087; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_LoginWithVerifierForCerificate_args _ = P.error "not a struct"
read_LoginWithVerifierForCerificate_args :: T.Protocol p => p -> P.IO LoginWithVerifierForCerificate_args
read_LoginWithVerifierForCerificate_args iprot = to_LoginWithVerifierForCerificate_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_args)
decode_LoginWithVerifierForCerificate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCerificate_args
decode_LoginWithVerifierForCerificate_args iprot bs = to_LoginWithVerifierForCerificate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_args) bs
typemap_LoginWithVerifierForCerificate_args :: T.TypeMap
typemap_LoginWithVerifierForCerificate_args = Map.fromList [(3,("verifier",T.T_STRING))]
default_LoginWithVerifierForCerificate_args :: LoginWithVerifierForCerificate_args
default_LoginWithVerifierForCerificate_args = LoginWithVerifierForCerificate_args{
  loginWithVerifierForCerificate_args_verifier = ""}
data LoginWithVerifierForCerificate_result = LoginWithVerifierForCerificate_result  { loginWithVerifierForCerificate_result_success :: LoginResult
  , loginWithVerifierForCerificate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCerificate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCerificate_result_success record   `H.hashWithSalt` loginWithVerifierForCerificate_result_e record  
instance QC.Arbitrary LoginWithVerifierForCerificate_result where 
  arbitrary = M.liftM LoginWithVerifierForCerificate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCerificate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_success = loginWithVerifierForCerificate_result_success obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_success = loginWithVerifierForCerificate_result_success obj}
    , if obj == default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_e = loginWithVerifierForCerificate_result_e obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_e = loginWithVerifierForCerificate_result_e obj}
    ]
from_LoginWithVerifierForCerificate_result :: LoginWithVerifierForCerificate_result -> T.ThriftVal
from_LoginWithVerifierForCerificate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5090 -> (1, ("e",from_TalkException _v5090))) <$> loginWithVerifierForCerificate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5090 -> P.Just (0, ("success",from_LoginResult _v5090))) $ loginWithVerifierForCerificate_result_success record
    , (\_v5090 -> (1, ("e",from_TalkException _v5090))) <$> loginWithVerifierForCerificate_result_e record
    ]
    )
write_LoginWithVerifierForCerificate_result :: T.Protocol p => p -> LoginWithVerifierForCerificate_result -> P.IO ()
write_LoginWithVerifierForCerificate_result oprot record = T.writeVal oprot $ from_LoginWithVerifierForCerificate_result record
encode_LoginWithVerifierForCerificate_result :: T.StatelessProtocol p => p -> LoginWithVerifierForCerificate_result -> LBS.ByteString
encode_LoginWithVerifierForCerificate_result oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCerificate_result record
to_LoginWithVerifierForCerificate_result :: T.ThriftVal -> LoginWithVerifierForCerificate_result
to_LoginWithVerifierForCerificate_result (T.TStruct fields) = LoginWithVerifierForCerificate_result{
  loginWithVerifierForCerificate_result_success = P.maybe (loginWithVerifierForCerificate_result_success default_LoginWithVerifierForCerificate_result) (\(_,_val5092) -> (case _val5092 of {T.TStruct _val5093 -> (to_LoginResult (T.TStruct _val5093)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithVerifierForCerificate_result_e = P.maybe (P.Nothing) (\(_,_val5092) -> P.Just (case _val5092 of {T.TStruct _val5094 -> (to_TalkException (T.TStruct _val5094)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithVerifierForCerificate_result _ = P.error "not a struct"
read_LoginWithVerifierForCerificate_result :: T.Protocol p => p -> P.IO LoginWithVerifierForCerificate_result
read_LoginWithVerifierForCerificate_result iprot = to_LoginWithVerifierForCerificate_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_result)
decode_LoginWithVerifierForCerificate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCerificate_result
decode_LoginWithVerifierForCerificate_result iprot bs = to_LoginWithVerifierForCerificate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_result) bs
typemap_LoginWithVerifierForCerificate_result :: T.TypeMap
typemap_LoginWithVerifierForCerificate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithVerifierForCerificate_result :: LoginWithVerifierForCerificate_result
default_LoginWithVerifierForCerificate_result = LoginWithVerifierForCerificate_result{
  loginWithVerifierForCerificate_result_success = default_LoginResult,
  loginWithVerifierForCerificate_result_e = P.Nothing}
data LoginWithVerifierForCertificate_args = LoginWithVerifierForCertificate_args  { loginWithVerifierForCertificate_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCertificate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCertificate_args_verifier record  
instance QC.Arbitrary LoginWithVerifierForCertificate_args where 
  arbitrary = M.liftM LoginWithVerifierForCertificate_args (QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCertificate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCertificate_args{loginWithVerifierForCertificate_args_verifier = loginWithVerifierForCertificate_args_verifier obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCertificate_args{loginWithVerifierForCertificate_args_verifier = loginWithVerifierForCertificate_args_verifier obj}
    ]
from_LoginWithVerifierForCertificate_args :: LoginWithVerifierForCertificate_args -> T.ThriftVal
from_LoginWithVerifierForCertificate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5097 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v5097))) $ loginWithVerifierForCertificate_args_verifier record
  ]
write_LoginWithVerifierForCertificate_args :: T.Protocol p => p -> LoginWithVerifierForCertificate_args -> P.IO ()
write_LoginWithVerifierForCertificate_args oprot record = T.writeVal oprot $ from_LoginWithVerifierForCertificate_args record
encode_LoginWithVerifierForCertificate_args :: T.StatelessProtocol p => p -> LoginWithVerifierForCertificate_args -> LBS.ByteString
encode_LoginWithVerifierForCertificate_args oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCertificate_args record
to_LoginWithVerifierForCertificate_args :: T.ThriftVal -> LoginWithVerifierForCertificate_args
to_LoginWithVerifierForCertificate_args (T.TStruct fields) = LoginWithVerifierForCertificate_args{
  loginWithVerifierForCertificate_args_verifier = P.maybe (loginWithVerifierForCertificate_args_verifier default_LoginWithVerifierForCertificate_args) (\(_,_val5099) -> (case _val5099 of {T.TString _val5100 -> E.decodeUtf8 _val5100; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_LoginWithVerifierForCertificate_args _ = P.error "not a struct"
read_LoginWithVerifierForCertificate_args :: T.Protocol p => p -> P.IO LoginWithVerifierForCertificate_args
read_LoginWithVerifierForCertificate_args iprot = to_LoginWithVerifierForCertificate_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_args)
decode_LoginWithVerifierForCertificate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCertificate_args
decode_LoginWithVerifierForCertificate_args iprot bs = to_LoginWithVerifierForCertificate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_args) bs
typemap_LoginWithVerifierForCertificate_args :: T.TypeMap
typemap_LoginWithVerifierForCertificate_args = Map.fromList [(3,("verifier",T.T_STRING))]
default_LoginWithVerifierForCertificate_args :: LoginWithVerifierForCertificate_args
default_LoginWithVerifierForCertificate_args = LoginWithVerifierForCertificate_args{
  loginWithVerifierForCertificate_args_verifier = ""}
data LoginWithVerifierForCertificate_result = LoginWithVerifierForCertificate_result  { loginWithVerifierForCertificate_result_success :: LoginResult
  , loginWithVerifierForCertificate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCertificate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCertificate_result_success record   `H.hashWithSalt` loginWithVerifierForCertificate_result_e record  
instance QC.Arbitrary LoginWithVerifierForCertificate_result where 
  arbitrary = M.liftM LoginWithVerifierForCertificate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCertificate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_success = loginWithVerifierForCertificate_result_success obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_success = loginWithVerifierForCertificate_result_success obj}
    , if obj == default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_e = loginWithVerifierForCertificate_result_e obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_e = loginWithVerifierForCertificate_result_e obj}
    ]
from_LoginWithVerifierForCertificate_result :: LoginWithVerifierForCertificate_result -> T.ThriftVal
from_LoginWithVerifierForCertificate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5103 -> (1, ("e",from_TalkException _v5103))) <$> loginWithVerifierForCertificate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5103 -> P.Just (0, ("success",from_LoginResult _v5103))) $ loginWithVerifierForCertificate_result_success record
    , (\_v5103 -> (1, ("e",from_TalkException _v5103))) <$> loginWithVerifierForCertificate_result_e record
    ]
    )
write_LoginWithVerifierForCertificate_result :: T.Protocol p => p -> LoginWithVerifierForCertificate_result -> P.IO ()
write_LoginWithVerifierForCertificate_result oprot record = T.writeVal oprot $ from_LoginWithVerifierForCertificate_result record
encode_LoginWithVerifierForCertificate_result :: T.StatelessProtocol p => p -> LoginWithVerifierForCertificate_result -> LBS.ByteString
encode_LoginWithVerifierForCertificate_result oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCertificate_result record
to_LoginWithVerifierForCertificate_result :: T.ThriftVal -> LoginWithVerifierForCertificate_result
to_LoginWithVerifierForCertificate_result (T.TStruct fields) = LoginWithVerifierForCertificate_result{
  loginWithVerifierForCertificate_result_success = P.maybe (loginWithVerifierForCertificate_result_success default_LoginWithVerifierForCertificate_result) (\(_,_val5105) -> (case _val5105 of {T.TStruct _val5106 -> (to_LoginResult (T.TStruct _val5106)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithVerifierForCertificate_result_e = P.maybe (P.Nothing) (\(_,_val5105) -> P.Just (case _val5105 of {T.TStruct _val5107 -> (to_TalkException (T.TStruct _val5107)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithVerifierForCertificate_result _ = P.error "not a struct"
read_LoginWithVerifierForCertificate_result :: T.Protocol p => p -> P.IO LoginWithVerifierForCertificate_result
read_LoginWithVerifierForCertificate_result iprot = to_LoginWithVerifierForCertificate_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_result)
decode_LoginWithVerifierForCertificate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCertificate_result
decode_LoginWithVerifierForCertificate_result iprot bs = to_LoginWithVerifierForCertificate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_result) bs
typemap_LoginWithVerifierForCertificate_result :: T.TypeMap
typemap_LoginWithVerifierForCertificate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithVerifierForCertificate_result :: LoginWithVerifierForCertificate_result
default_LoginWithVerifierForCertificate_result = LoginWithVerifierForCertificate_result{
  loginWithVerifierForCertificate_result_success = default_LoginResult,
  loginWithVerifierForCertificate_result_e = P.Nothing}
data Logout_args = Logout_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Logout_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Logout_args where 
  arbitrary = QC.elements [Logout_args]
from_Logout_args :: Logout_args -> T.ThriftVal
from_Logout_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Logout_args :: T.Protocol p => p -> Logout_args -> P.IO ()
write_Logout_args oprot record = T.writeVal oprot $ from_Logout_args record
encode_Logout_args :: T.StatelessProtocol p => p -> Logout_args -> LBS.ByteString
encode_Logout_args oprot record = T.serializeVal oprot $ from_Logout_args record
to_Logout_args :: T.ThriftVal -> Logout_args
to_Logout_args (T.TStruct fields) = Logout_args{

  }
to_Logout_args _ = P.error "not a struct"
read_Logout_args :: T.Protocol p => p -> P.IO Logout_args
read_Logout_args iprot = to_Logout_args <$> T.readVal iprot (T.T_STRUCT typemap_Logout_args)
decode_Logout_args :: T.StatelessProtocol p => p -> LBS.ByteString -> Logout_args
decode_Logout_args iprot bs = to_Logout_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Logout_args) bs
typemap_Logout_args :: T.TypeMap
typemap_Logout_args = Map.fromList []
default_Logout_args :: Logout_args
default_Logout_args = Logout_args{
}
data Logout_result = Logout_result  { logout_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Logout_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` logout_result_e record  
instance QC.Arbitrary Logout_result where 
  arbitrary = M.liftM Logout_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Logout_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Logout_result{logout_result_e = logout_result_e obj} then P.Nothing else P.Just $ default_Logout_result{logout_result_e = logout_result_e obj}
    ]
from_Logout_result :: Logout_result -> T.ThriftVal
from_Logout_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5115 -> (1, ("e",from_TalkException _v5115))) <$> logout_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5115 -> (1, ("e",from_TalkException _v5115))) <$> logout_result_e record
    ]
    )
write_Logout_result :: T.Protocol p => p -> Logout_result -> P.IO ()
write_Logout_result oprot record = T.writeVal oprot $ from_Logout_result record
encode_Logout_result :: T.StatelessProtocol p => p -> Logout_result -> LBS.ByteString
encode_Logout_result oprot record = T.serializeVal oprot $ from_Logout_result record
to_Logout_result :: T.ThriftVal -> Logout_result
to_Logout_result (T.TStruct fields) = Logout_result{
  logout_result_e = P.maybe (P.Nothing) (\(_,_val5117) -> P.Just (case _val5117 of {T.TStruct _val5118 -> (to_TalkException (T.TStruct _val5118)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Logout_result _ = P.error "not a struct"
read_Logout_result :: T.Protocol p => p -> P.IO Logout_result
read_Logout_result iprot = to_Logout_result <$> T.readVal iprot (T.T_STRUCT typemap_Logout_result)
decode_Logout_result :: T.StatelessProtocol p => p -> LBS.ByteString -> Logout_result
decode_Logout_result iprot bs = to_Logout_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Logout_result) bs
typemap_Logout_result :: T.TypeMap
typemap_Logout_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_Logout_result :: Logout_result
default_Logout_result = Logout_result{
  logout_result_e = P.Nothing}
data LogoutSession_args = LogoutSession_args  { logoutSession_args_tokenKey :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutSession_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` logoutSession_args_tokenKey record  
instance QC.Arbitrary LogoutSession_args where 
  arbitrary = M.liftM LogoutSession_args (QC.arbitrary)
  shrink obj | obj == default_LogoutSession_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LogoutSession_args{logoutSession_args_tokenKey = logoutSession_args_tokenKey obj} then P.Nothing else P.Just $ default_LogoutSession_args{logoutSession_args_tokenKey = logoutSession_args_tokenKey obj}
    ]
from_LogoutSession_args :: LogoutSession_args -> T.ThriftVal
from_LogoutSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5121 -> P.Just (2, ("tokenKey",T.TString $ E.encodeUtf8 _v5121))) $ logoutSession_args_tokenKey record
  ]
write_LogoutSession_args :: T.Protocol p => p -> LogoutSession_args -> P.IO ()
write_LogoutSession_args oprot record = T.writeVal oprot $ from_LogoutSession_args record
encode_LogoutSession_args :: T.StatelessProtocol p => p -> LogoutSession_args -> LBS.ByteString
encode_LogoutSession_args oprot record = T.serializeVal oprot $ from_LogoutSession_args record
to_LogoutSession_args :: T.ThriftVal -> LogoutSession_args
to_LogoutSession_args (T.TStruct fields) = LogoutSession_args{
  logoutSession_args_tokenKey = P.maybe (logoutSession_args_tokenKey default_LogoutSession_args) (\(_,_val5123) -> (case _val5123 of {T.TString _val5124 -> E.decodeUtf8 _val5124; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LogoutSession_args _ = P.error "not a struct"
read_LogoutSession_args :: T.Protocol p => p -> P.IO LogoutSession_args
read_LogoutSession_args iprot = to_LogoutSession_args <$> T.readVal iprot (T.T_STRUCT typemap_LogoutSession_args)
decode_LogoutSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutSession_args
decode_LogoutSession_args iprot bs = to_LogoutSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutSession_args) bs
typemap_LogoutSession_args :: T.TypeMap
typemap_LogoutSession_args = Map.fromList [(2,("tokenKey",T.T_STRING))]
default_LogoutSession_args :: LogoutSession_args
default_LogoutSession_args = LogoutSession_args{
  logoutSession_args_tokenKey = ""}
data LogoutSession_result = LogoutSession_result  { logoutSession_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` logoutSession_result_e record  
instance QC.Arbitrary LogoutSession_result where 
  arbitrary = M.liftM LogoutSession_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LogoutSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LogoutSession_result{logoutSession_result_e = logoutSession_result_e obj} then P.Nothing else P.Just $ default_LogoutSession_result{logoutSession_result_e = logoutSession_result_e obj}
    ]
from_LogoutSession_result :: LogoutSession_result -> T.ThriftVal
from_LogoutSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5127 -> (1, ("e",from_TalkException _v5127))) <$> logoutSession_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5127 -> (1, ("e",from_TalkException _v5127))) <$> logoutSession_result_e record
    ]
    )
write_LogoutSession_result :: T.Protocol p => p -> LogoutSession_result -> P.IO ()
write_LogoutSession_result oprot record = T.writeVal oprot $ from_LogoutSession_result record
encode_LogoutSession_result :: T.StatelessProtocol p => p -> LogoutSession_result -> LBS.ByteString
encode_LogoutSession_result oprot record = T.serializeVal oprot $ from_LogoutSession_result record
to_LogoutSession_result :: T.ThriftVal -> LogoutSession_result
to_LogoutSession_result (T.TStruct fields) = LogoutSession_result{
  logoutSession_result_e = P.maybe (P.Nothing) (\(_,_val5129) -> P.Just (case _val5129 of {T.TStruct _val5130 -> (to_TalkException (T.TStruct _val5130)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LogoutSession_result _ = P.error "not a struct"
read_LogoutSession_result :: T.Protocol p => p -> P.IO LogoutSession_result
read_LogoutSession_result iprot = to_LogoutSession_result <$> T.readVal iprot (T.T_STRUCT typemap_LogoutSession_result)
decode_LogoutSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutSession_result
decode_LogoutSession_result iprot bs = to_LogoutSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutSession_result) bs
typemap_LogoutSession_result :: T.TypeMap
typemap_LogoutSession_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LogoutSession_result :: LogoutSession_result
default_LogoutSession_result = LogoutSession_result{
  logoutSession_result_e = P.Nothing}
data Noop_args = Noop_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Noop_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Noop_args where 
  arbitrary = QC.elements [Noop_args]
from_Noop_args :: Noop_args -> T.ThriftVal
from_Noop_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Noop_args :: T.Protocol p => p -> Noop_args -> P.IO ()
write_Noop_args oprot record = T.writeVal oprot $ from_Noop_args record
encode_Noop_args :: T.StatelessProtocol p => p -> Noop_args -> LBS.ByteString
encode_Noop_args oprot record = T.serializeVal oprot $ from_Noop_args record
to_Noop_args :: T.ThriftVal -> Noop_args
to_Noop_args (T.TStruct fields) = Noop_args{

  }
to_Noop_args _ = P.error "not a struct"
read_Noop_args :: T.Protocol p => p -> P.IO Noop_args
read_Noop_args iprot = to_Noop_args <$> T.readVal iprot (T.T_STRUCT typemap_Noop_args)
decode_Noop_args :: T.StatelessProtocol p => p -> LBS.ByteString -> Noop_args
decode_Noop_args iprot bs = to_Noop_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Noop_args) bs
typemap_Noop_args :: T.TypeMap
typemap_Noop_args = Map.fromList []
default_Noop_args :: Noop_args
default_Noop_args = Noop_args{
}
data Noop_result = Noop_result  { noop_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Noop_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` noop_result_e record  
instance QC.Arbitrary Noop_result where 
  arbitrary = M.liftM Noop_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Noop_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Noop_result{noop_result_e = noop_result_e obj} then P.Nothing else P.Just $ default_Noop_result{noop_result_e = noop_result_e obj}
    ]
from_Noop_result :: Noop_result -> T.ThriftVal
from_Noop_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5138 -> (1, ("e",from_TalkException _v5138))) <$> noop_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5138 -> (1, ("e",from_TalkException _v5138))) <$> noop_result_e record
    ]
    )
write_Noop_result :: T.Protocol p => p -> Noop_result -> P.IO ()
write_Noop_result oprot record = T.writeVal oprot $ from_Noop_result record
encode_Noop_result :: T.StatelessProtocol p => p -> Noop_result -> LBS.ByteString
encode_Noop_result oprot record = T.serializeVal oprot $ from_Noop_result record
to_Noop_result :: T.ThriftVal -> Noop_result
to_Noop_result (T.TStruct fields) = Noop_result{
  noop_result_e = P.maybe (P.Nothing) (\(_,_val5140) -> P.Just (case _val5140 of {T.TStruct _val5141 -> (to_TalkException (T.TStruct _val5141)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Noop_result _ = P.error "not a struct"
read_Noop_result :: T.Protocol p => p -> P.IO Noop_result
read_Noop_result iprot = to_Noop_result <$> T.readVal iprot (T.T_STRUCT typemap_Noop_result)
decode_Noop_result :: T.StatelessProtocol p => p -> LBS.ByteString -> Noop_result
decode_Noop_result iprot bs = to_Noop_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Noop_result) bs
typemap_Noop_result :: T.TypeMap
typemap_Noop_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_Noop_result :: Noop_result
default_Noop_result = Noop_result{
  noop_result_e = P.Nothing}
data NotifiedRedirect_args = NotifiedRedirect_args  { notifiedRedirect_args_paramMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifiedRedirect_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifiedRedirect_args_paramMap record  
instance QC.Arbitrary NotifiedRedirect_args where 
  arbitrary = M.liftM NotifiedRedirect_args (QC.arbitrary)
  shrink obj | obj == default_NotifiedRedirect_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifiedRedirect_args{notifiedRedirect_args_paramMap = notifiedRedirect_args_paramMap obj} then P.Nothing else P.Just $ default_NotifiedRedirect_args{notifiedRedirect_args_paramMap = notifiedRedirect_args_paramMap obj}
    ]
from_NotifiedRedirect_args :: NotifiedRedirect_args -> T.ThriftVal
from_NotifiedRedirect_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5144 -> P.Just (2, ("paramMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k5145,_v5146) -> (T.TString $ E.encodeUtf8 _k5145, T.TString $ E.encodeUtf8 _v5146)) $ Map.toList _v5144))) $ notifiedRedirect_args_paramMap record
  ]
write_NotifiedRedirect_args :: T.Protocol p => p -> NotifiedRedirect_args -> P.IO ()
write_NotifiedRedirect_args oprot record = T.writeVal oprot $ from_NotifiedRedirect_args record
encode_NotifiedRedirect_args :: T.StatelessProtocol p => p -> NotifiedRedirect_args -> LBS.ByteString
encode_NotifiedRedirect_args oprot record = T.serializeVal oprot $ from_NotifiedRedirect_args record
to_NotifiedRedirect_args :: T.ThriftVal -> NotifiedRedirect_args
to_NotifiedRedirect_args (T.TStruct fields) = NotifiedRedirect_args{
  notifiedRedirect_args_paramMap = P.maybe (notifiedRedirect_args_paramMap default_NotifiedRedirect_args) (\(_,_val5148) -> (case _val5148 of {T.TMap _ _ _val5149 -> (Map.fromList $ P.map (\(_k5151,_v5150) -> ((case _k5151 of {T.TString _val5152 -> E.decodeUtf8 _val5152; _ -> P.error "wrong type"}),(case _v5150 of {T.TString _val5153 -> E.decodeUtf8 _val5153; _ -> P.error "wrong type"}))) _val5149); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NotifiedRedirect_args _ = P.error "not a struct"
read_NotifiedRedirect_args :: T.Protocol p => p -> P.IO NotifiedRedirect_args
read_NotifiedRedirect_args iprot = to_NotifiedRedirect_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifiedRedirect_args)
decode_NotifiedRedirect_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifiedRedirect_args
decode_NotifiedRedirect_args iprot bs = to_NotifiedRedirect_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifiedRedirect_args) bs
typemap_NotifiedRedirect_args :: T.TypeMap
typemap_NotifiedRedirect_args = Map.fromList [(2,("paramMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_NotifiedRedirect_args :: NotifiedRedirect_args
default_NotifiedRedirect_args = NotifiedRedirect_args{
  notifiedRedirect_args_paramMap = Map.empty}
data NotifiedRedirect_result = NotifiedRedirect_result  { notifiedRedirect_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifiedRedirect_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifiedRedirect_result_e record  
instance QC.Arbitrary NotifiedRedirect_result where 
  arbitrary = M.liftM NotifiedRedirect_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifiedRedirect_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifiedRedirect_result{notifiedRedirect_result_e = notifiedRedirect_result_e obj} then P.Nothing else P.Just $ default_NotifiedRedirect_result{notifiedRedirect_result_e = notifiedRedirect_result_e obj}
    ]
from_NotifiedRedirect_result :: NotifiedRedirect_result -> T.ThriftVal
from_NotifiedRedirect_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5156 -> (1, ("e",from_TalkException _v5156))) <$> notifiedRedirect_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5156 -> (1, ("e",from_TalkException _v5156))) <$> notifiedRedirect_result_e record
    ]
    )
write_NotifiedRedirect_result :: T.Protocol p => p -> NotifiedRedirect_result -> P.IO ()
write_NotifiedRedirect_result oprot record = T.writeVal oprot $ from_NotifiedRedirect_result record
encode_NotifiedRedirect_result :: T.StatelessProtocol p => p -> NotifiedRedirect_result -> LBS.ByteString
encode_NotifiedRedirect_result oprot record = T.serializeVal oprot $ from_NotifiedRedirect_result record
to_NotifiedRedirect_result :: T.ThriftVal -> NotifiedRedirect_result
to_NotifiedRedirect_result (T.TStruct fields) = NotifiedRedirect_result{
  notifiedRedirect_result_e = P.maybe (P.Nothing) (\(_,_val5158) -> P.Just (case _val5158 of {T.TStruct _val5159 -> (to_TalkException (T.TStruct _val5159)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifiedRedirect_result _ = P.error "not a struct"
read_NotifiedRedirect_result :: T.Protocol p => p -> P.IO NotifiedRedirect_result
read_NotifiedRedirect_result iprot = to_NotifiedRedirect_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifiedRedirect_result)
decode_NotifiedRedirect_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifiedRedirect_result
decode_NotifiedRedirect_result iprot bs = to_NotifiedRedirect_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifiedRedirect_result) bs
typemap_NotifiedRedirect_result :: T.TypeMap
typemap_NotifiedRedirect_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifiedRedirect_result :: NotifiedRedirect_result
default_NotifiedRedirect_result = NotifiedRedirect_result{
  notifiedRedirect_result_e = P.Nothing}
data NotifyBuddyOnAir_args = NotifyBuddyOnAir_args  { notifyBuddyOnAir_args_seq :: I.Int32
  , notifyBuddyOnAir_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyBuddyOnAir_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyBuddyOnAir_args_seq record   `H.hashWithSalt` notifyBuddyOnAir_args_receiverMids record  
instance QC.Arbitrary NotifyBuddyOnAir_args where 
  arbitrary = M.liftM NotifyBuddyOnAir_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyBuddyOnAir_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_seq = notifyBuddyOnAir_args_seq obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_seq = notifyBuddyOnAir_args_seq obj}
    , if obj == default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_receiverMids = notifyBuddyOnAir_args_receiverMids obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_receiverMids = notifyBuddyOnAir_args_receiverMids obj}
    ]
from_NotifyBuddyOnAir_args :: NotifyBuddyOnAir_args -> T.ThriftVal
from_NotifyBuddyOnAir_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5162 -> P.Just (1, ("seq",T.TI32 _v5162))) $ notifyBuddyOnAir_args_seq record
  , (\_v5162 -> P.Just (2, ("receiverMids",T.TList T.T_STRING $ P.map (\_v5164 -> T.TString $ E.encodeUtf8 _v5164) $ Vector.toList _v5162))) $ notifyBuddyOnAir_args_receiverMids record
  ]
write_NotifyBuddyOnAir_args :: T.Protocol p => p -> NotifyBuddyOnAir_args -> P.IO ()
write_NotifyBuddyOnAir_args oprot record = T.writeVal oprot $ from_NotifyBuddyOnAir_args record
encode_NotifyBuddyOnAir_args :: T.StatelessProtocol p => p -> NotifyBuddyOnAir_args -> LBS.ByteString
encode_NotifyBuddyOnAir_args oprot record = T.serializeVal oprot $ from_NotifyBuddyOnAir_args record
to_NotifyBuddyOnAir_args :: T.ThriftVal -> NotifyBuddyOnAir_args
to_NotifyBuddyOnAir_args (T.TStruct fields) = NotifyBuddyOnAir_args{
  notifyBuddyOnAir_args_seq = P.maybe (notifyBuddyOnAir_args_seq default_NotifyBuddyOnAir_args) (\(_,_val5166) -> (case _val5166 of {T.TI32 _val5167 -> _val5167; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notifyBuddyOnAir_args_receiverMids = P.maybe (notifyBuddyOnAir_args_receiverMids default_NotifyBuddyOnAir_args) (\(_,_val5166) -> (case _val5166 of {T.TList _ _val5168 -> (Vector.fromList $ P.map (\_v5169 -> (case _v5169 of {T.TString _val5170 -> E.decodeUtf8 _val5170; _ -> P.error "wrong type"})) _val5168); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NotifyBuddyOnAir_args _ = P.error "not a struct"
read_NotifyBuddyOnAir_args :: T.Protocol p => p -> P.IO NotifyBuddyOnAir_args
read_NotifyBuddyOnAir_args iprot = to_NotifyBuddyOnAir_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_args)
decode_NotifyBuddyOnAir_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyBuddyOnAir_args
decode_NotifyBuddyOnAir_args iprot bs = to_NotifyBuddyOnAir_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_args) bs
typemap_NotifyBuddyOnAir_args :: T.TypeMap
typemap_NotifyBuddyOnAir_args = Map.fromList [(1,("seq",T.T_I32)),(2,("receiverMids",(T.T_LIST T.T_STRING)))]
default_NotifyBuddyOnAir_args :: NotifyBuddyOnAir_args
default_NotifyBuddyOnAir_args = NotifyBuddyOnAir_args{
  notifyBuddyOnAir_args_seq = 0,
  notifyBuddyOnAir_args_receiverMids = Vector.empty}
data NotifyBuddyOnAir_result = NotifyBuddyOnAir_result  { notifyBuddyOnAir_result_success :: (Map.HashMap LT.Text LT.Text)
  , notifyBuddyOnAir_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyBuddyOnAir_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyBuddyOnAir_result_success record   `H.hashWithSalt` notifyBuddyOnAir_result_e record  
instance QC.Arbitrary NotifyBuddyOnAir_result where 
  arbitrary = M.liftM NotifyBuddyOnAir_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyBuddyOnAir_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_success = notifyBuddyOnAir_result_success obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_success = notifyBuddyOnAir_result_success obj}
    , if obj == default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_e = notifyBuddyOnAir_result_e obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_e = notifyBuddyOnAir_result_e obj}
    ]
from_NotifyBuddyOnAir_result :: NotifyBuddyOnAir_result -> T.ThriftVal
from_NotifyBuddyOnAir_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5173 -> (1, ("e",from_TalkException _v5173))) <$> notifyBuddyOnAir_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5173 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k5174,_v5175) -> (T.TString $ E.encodeUtf8 _k5174, T.TString $ E.encodeUtf8 _v5175)) $ Map.toList _v5173))) $ notifyBuddyOnAir_result_success record
    , (\_v5173 -> (1, ("e",from_TalkException _v5173))) <$> notifyBuddyOnAir_result_e record
    ]
    )
write_NotifyBuddyOnAir_result :: T.Protocol p => p -> NotifyBuddyOnAir_result -> P.IO ()
write_NotifyBuddyOnAir_result oprot record = T.writeVal oprot $ from_NotifyBuddyOnAir_result record
encode_NotifyBuddyOnAir_result :: T.StatelessProtocol p => p -> NotifyBuddyOnAir_result -> LBS.ByteString
encode_NotifyBuddyOnAir_result oprot record = T.serializeVal oprot $ from_NotifyBuddyOnAir_result record
to_NotifyBuddyOnAir_result :: T.ThriftVal -> NotifyBuddyOnAir_result
to_NotifyBuddyOnAir_result (T.TStruct fields) = NotifyBuddyOnAir_result{
  notifyBuddyOnAir_result_success = P.maybe (notifyBuddyOnAir_result_success default_NotifyBuddyOnAir_result) (\(_,_val5177) -> (case _val5177 of {T.TMap _ _ _val5178 -> (Map.fromList $ P.map (\(_k5180,_v5179) -> ((case _k5180 of {T.TString _val5181 -> E.decodeUtf8 _val5181; _ -> P.error "wrong type"}),(case _v5179 of {T.TString _val5182 -> E.decodeUtf8 _val5182; _ -> P.error "wrong type"}))) _val5178); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  notifyBuddyOnAir_result_e = P.maybe (P.Nothing) (\(_,_val5177) -> P.Just (case _val5177 of {T.TStruct _val5183 -> (to_TalkException (T.TStruct _val5183)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyBuddyOnAir_result _ = P.error "not a struct"
read_NotifyBuddyOnAir_result :: T.Protocol p => p -> P.IO NotifyBuddyOnAir_result
read_NotifyBuddyOnAir_result iprot = to_NotifyBuddyOnAir_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_result)
decode_NotifyBuddyOnAir_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyBuddyOnAir_result
decode_NotifyBuddyOnAir_result iprot bs = to_NotifyBuddyOnAir_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_result) bs
typemap_NotifyBuddyOnAir_result :: T.TypeMap
typemap_NotifyBuddyOnAir_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyBuddyOnAir_result :: NotifyBuddyOnAir_result
default_NotifyBuddyOnAir_result = NotifyBuddyOnAir_result{
  notifyBuddyOnAir_result_success = Map.empty,
  notifyBuddyOnAir_result_e = P.Nothing}
data NotifyIndividualEvent_args = NotifyIndividualEvent_args  { notifyIndividualEvent_args_notificationStatus :: NotificationStatus
  , notifyIndividualEvent_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyIndividualEvent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyIndividualEvent_args_notificationStatus record   `H.hashWithSalt` notifyIndividualEvent_args_receiverMids record  
instance QC.Arbitrary NotifyIndividualEvent_args where 
  arbitrary = M.liftM NotifyIndividualEvent_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyIndividualEvent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyIndividualEvent_args{notifyIndividualEvent_args_notificationStatus = notifyIndividualEvent_args_notificationStatus obj} then P.Nothing else P.Just $ default_NotifyIndividualEvent_args{notifyIndividualEvent_args_notificationStatus = notifyIndividualEvent_args_notificationStatus obj}
    , if obj == default_NotifyIndividualEvent_args{notifyIndividualEvent_args_receiverMids = notifyIndividualEvent_args_receiverMids obj} then P.Nothing else P.Just $ default_NotifyIndividualEvent_args{notifyIndividualEvent_args_receiverMids = notifyIndividualEvent_args_receiverMids obj}
    ]
from_NotifyIndividualEvent_args :: NotifyIndividualEvent_args -> T.ThriftVal
from_NotifyIndividualEvent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5186 -> P.Just (2, ("notificationStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v5186))) $ notifyIndividualEvent_args_notificationStatus record
  , (\_v5186 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v5188 -> T.TString $ E.encodeUtf8 _v5188) $ Vector.toList _v5186))) $ notifyIndividualEvent_args_receiverMids record
  ]
write_NotifyIndividualEvent_args :: T.Protocol p => p -> NotifyIndividualEvent_args -> P.IO ()
write_NotifyIndividualEvent_args oprot record = T.writeVal oprot $ from_NotifyIndividualEvent_args record
encode_NotifyIndividualEvent_args :: T.StatelessProtocol p => p -> NotifyIndividualEvent_args -> LBS.ByteString
encode_NotifyIndividualEvent_args oprot record = T.serializeVal oprot $ from_NotifyIndividualEvent_args record
to_NotifyIndividualEvent_args :: T.ThriftVal -> NotifyIndividualEvent_args
to_NotifyIndividualEvent_args (T.TStruct fields) = NotifyIndividualEvent_args{
  notifyIndividualEvent_args_notificationStatus = P.maybe (notifyIndividualEvent_args_notificationStatus default_NotifyIndividualEvent_args) (\(_,_val5190) -> (case _val5190 of {T.TI32 _val5191 -> P.toEnum $ P.fromIntegral _val5191; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyIndividualEvent_args_receiverMids = P.maybe (notifyIndividualEvent_args_receiverMids default_NotifyIndividualEvent_args) (\(_,_val5190) -> (case _val5190 of {T.TList _ _val5192 -> (Vector.fromList $ P.map (\_v5193 -> (case _v5193 of {T.TString _val5194 -> E.decodeUtf8 _val5194; _ -> P.error "wrong type"})) _val5192); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyIndividualEvent_args _ = P.error "not a struct"
read_NotifyIndividualEvent_args :: T.Protocol p => p -> P.IO NotifyIndividualEvent_args
read_NotifyIndividualEvent_args iprot = to_NotifyIndividualEvent_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_args)
decode_NotifyIndividualEvent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyIndividualEvent_args
decode_NotifyIndividualEvent_args iprot bs = to_NotifyIndividualEvent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_args) bs
typemap_NotifyIndividualEvent_args :: T.TypeMap
typemap_NotifyIndividualEvent_args = Map.fromList [(2,("notificationStatus",T.T_I32)),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_NotifyIndividualEvent_args :: NotifyIndividualEvent_args
default_NotifyIndividualEvent_args = NotifyIndividualEvent_args{
  notifyIndividualEvent_args_notificationStatus = (P.toEnum 0),
  notifyIndividualEvent_args_receiverMids = Vector.empty}
data NotifyIndividualEvent_result = NotifyIndividualEvent_result  { notifyIndividualEvent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyIndividualEvent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyIndividualEvent_result_e record  
instance QC.Arbitrary NotifyIndividualEvent_result where 
  arbitrary = M.liftM NotifyIndividualEvent_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyIndividualEvent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyIndividualEvent_result{notifyIndividualEvent_result_e = notifyIndividualEvent_result_e obj} then P.Nothing else P.Just $ default_NotifyIndividualEvent_result{notifyIndividualEvent_result_e = notifyIndividualEvent_result_e obj}
    ]
from_NotifyIndividualEvent_result :: NotifyIndividualEvent_result -> T.ThriftVal
from_NotifyIndividualEvent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5197 -> (1, ("e",from_TalkException _v5197))) <$> notifyIndividualEvent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5197 -> (1, ("e",from_TalkException _v5197))) <$> notifyIndividualEvent_result_e record
    ]
    )
write_NotifyIndividualEvent_result :: T.Protocol p => p -> NotifyIndividualEvent_result -> P.IO ()
write_NotifyIndividualEvent_result oprot record = T.writeVal oprot $ from_NotifyIndividualEvent_result record
encode_NotifyIndividualEvent_result :: T.StatelessProtocol p => p -> NotifyIndividualEvent_result -> LBS.ByteString
encode_NotifyIndividualEvent_result oprot record = T.serializeVal oprot $ from_NotifyIndividualEvent_result record
to_NotifyIndividualEvent_result :: T.ThriftVal -> NotifyIndividualEvent_result
to_NotifyIndividualEvent_result (T.TStruct fields) = NotifyIndividualEvent_result{
  notifyIndividualEvent_result_e = P.maybe (P.Nothing) (\(_,_val5199) -> P.Just (case _val5199 of {T.TStruct _val5200 -> (to_TalkException (T.TStruct _val5200)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyIndividualEvent_result _ = P.error "not a struct"
read_NotifyIndividualEvent_result :: T.Protocol p => p -> P.IO NotifyIndividualEvent_result
read_NotifyIndividualEvent_result iprot = to_NotifyIndividualEvent_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_result)
decode_NotifyIndividualEvent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyIndividualEvent_result
decode_NotifyIndividualEvent_result iprot bs = to_NotifyIndividualEvent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_result) bs
typemap_NotifyIndividualEvent_result :: T.TypeMap
typemap_NotifyIndividualEvent_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyIndividualEvent_result :: NotifyIndividualEvent_result
default_NotifyIndividualEvent_result = NotifyIndividualEvent_result{
  notifyIndividualEvent_result_e = P.Nothing}
data NotifyInstalled_args = NotifyInstalled_args  { notifyInstalled_args_udidHash :: LT.Text
  , notifyInstalled_args_applicationTypeWithExtensions :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyInstalled_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyInstalled_args_udidHash record   `H.hashWithSalt` notifyInstalled_args_applicationTypeWithExtensions record  
instance QC.Arbitrary NotifyInstalled_args where 
  arbitrary = M.liftM NotifyInstalled_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyInstalled_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyInstalled_args{notifyInstalled_args_udidHash = notifyInstalled_args_udidHash obj} then P.Nothing else P.Just $ default_NotifyInstalled_args{notifyInstalled_args_udidHash = notifyInstalled_args_udidHash obj}
    , if obj == default_NotifyInstalled_args{notifyInstalled_args_applicationTypeWithExtensions = notifyInstalled_args_applicationTypeWithExtensions obj} then P.Nothing else P.Just $ default_NotifyInstalled_args{notifyInstalled_args_applicationTypeWithExtensions = notifyInstalled_args_applicationTypeWithExtensions obj}
    ]
from_NotifyInstalled_args :: NotifyInstalled_args -> T.ThriftVal
from_NotifyInstalled_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5203 -> P.Just (2, ("udidHash",T.TString $ E.encodeUtf8 _v5203))) $ notifyInstalled_args_udidHash record
  , (\_v5203 -> P.Just (3, ("applicationTypeWithExtensions",T.TString $ E.encodeUtf8 _v5203))) $ notifyInstalled_args_applicationTypeWithExtensions record
  ]
write_NotifyInstalled_args :: T.Protocol p => p -> NotifyInstalled_args -> P.IO ()
write_NotifyInstalled_args oprot record = T.writeVal oprot $ from_NotifyInstalled_args record
encode_NotifyInstalled_args :: T.StatelessProtocol p => p -> NotifyInstalled_args -> LBS.ByteString
encode_NotifyInstalled_args oprot record = T.serializeVal oprot $ from_NotifyInstalled_args record
to_NotifyInstalled_args :: T.ThriftVal -> NotifyInstalled_args
to_NotifyInstalled_args (T.TStruct fields) = NotifyInstalled_args{
  notifyInstalled_args_udidHash = P.maybe (notifyInstalled_args_udidHash default_NotifyInstalled_args) (\(_,_val5205) -> (case _val5205 of {T.TString _val5206 -> E.decodeUtf8 _val5206; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyInstalled_args_applicationTypeWithExtensions = P.maybe (notifyInstalled_args_applicationTypeWithExtensions default_NotifyInstalled_args) (\(_,_val5205) -> (case _val5205 of {T.TString _val5207 -> E.decodeUtf8 _val5207; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyInstalled_args _ = P.error "not a struct"
read_NotifyInstalled_args :: T.Protocol p => p -> P.IO NotifyInstalled_args
read_NotifyInstalled_args iprot = to_NotifyInstalled_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyInstalled_args)
decode_NotifyInstalled_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyInstalled_args
decode_NotifyInstalled_args iprot bs = to_NotifyInstalled_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyInstalled_args) bs
typemap_NotifyInstalled_args :: T.TypeMap
typemap_NotifyInstalled_args = Map.fromList [(2,("udidHash",T.T_STRING)),(3,("applicationTypeWithExtensions",T.T_STRING))]
default_NotifyInstalled_args :: NotifyInstalled_args
default_NotifyInstalled_args = NotifyInstalled_args{
  notifyInstalled_args_udidHash = "",
  notifyInstalled_args_applicationTypeWithExtensions = ""}
data NotifyInstalled_result = NotifyInstalled_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyInstalled_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary NotifyInstalled_result where 
  arbitrary = QC.elements [NotifyInstalled_result]
from_NotifyInstalled_result :: NotifyInstalled_result -> T.ThriftVal
from_NotifyInstalled_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_NotifyInstalled_result :: T.Protocol p => p -> NotifyInstalled_result -> P.IO ()
write_NotifyInstalled_result oprot record = T.writeVal oprot $ from_NotifyInstalled_result record
encode_NotifyInstalled_result :: T.StatelessProtocol p => p -> NotifyInstalled_result -> LBS.ByteString
encode_NotifyInstalled_result oprot record = T.serializeVal oprot $ from_NotifyInstalled_result record
to_NotifyInstalled_result :: T.ThriftVal -> NotifyInstalled_result
to_NotifyInstalled_result (T.TStruct fields) = NotifyInstalled_result{

  }
to_NotifyInstalled_result _ = P.error "not a struct"
read_NotifyInstalled_result :: T.Protocol p => p -> P.IO NotifyInstalled_result
read_NotifyInstalled_result iprot = to_NotifyInstalled_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyInstalled_result)
decode_NotifyInstalled_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyInstalled_result
decode_NotifyInstalled_result iprot bs = to_NotifyInstalled_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyInstalled_result) bs
typemap_NotifyInstalled_result :: T.TypeMap
typemap_NotifyInstalled_result = Map.fromList []
default_NotifyInstalled_result :: NotifyInstalled_result
default_NotifyInstalled_result = NotifyInstalled_result{
}
data NotifyRegistrationComplete_args = NotifyRegistrationComplete_args  { notifyRegistrationComplete_args_udidHash :: LT.Text
  , notifyRegistrationComplete_args_applicationTypeWithExtensions :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyRegistrationComplete_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyRegistrationComplete_args_udidHash record   `H.hashWithSalt` notifyRegistrationComplete_args_applicationTypeWithExtensions record  
instance QC.Arbitrary NotifyRegistrationComplete_args where 
  arbitrary = M.liftM NotifyRegistrationComplete_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyRegistrationComplete_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_udidHash = notifyRegistrationComplete_args_udidHash obj} then P.Nothing else P.Just $ default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_udidHash = notifyRegistrationComplete_args_udidHash obj}
    , if obj == default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_applicationTypeWithExtensions = notifyRegistrationComplete_args_applicationTypeWithExtensions obj} then P.Nothing else P.Just $ default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_applicationTypeWithExtensions = notifyRegistrationComplete_args_applicationTypeWithExtensions obj}
    ]
from_NotifyRegistrationComplete_args :: NotifyRegistrationComplete_args -> T.ThriftVal
from_NotifyRegistrationComplete_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5215 -> P.Just (2, ("udidHash",T.TString $ E.encodeUtf8 _v5215))) $ notifyRegistrationComplete_args_udidHash record
  , (\_v5215 -> P.Just (3, ("applicationTypeWithExtensions",T.TString $ E.encodeUtf8 _v5215))) $ notifyRegistrationComplete_args_applicationTypeWithExtensions record
  ]
write_NotifyRegistrationComplete_args :: T.Protocol p => p -> NotifyRegistrationComplete_args -> P.IO ()
write_NotifyRegistrationComplete_args oprot record = T.writeVal oprot $ from_NotifyRegistrationComplete_args record
encode_NotifyRegistrationComplete_args :: T.StatelessProtocol p => p -> NotifyRegistrationComplete_args -> LBS.ByteString
encode_NotifyRegistrationComplete_args oprot record = T.serializeVal oprot $ from_NotifyRegistrationComplete_args record
to_NotifyRegistrationComplete_args :: T.ThriftVal -> NotifyRegistrationComplete_args
to_NotifyRegistrationComplete_args (T.TStruct fields) = NotifyRegistrationComplete_args{
  notifyRegistrationComplete_args_udidHash = P.maybe (notifyRegistrationComplete_args_udidHash default_NotifyRegistrationComplete_args) (\(_,_val5217) -> (case _val5217 of {T.TString _val5218 -> E.decodeUtf8 _val5218; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyRegistrationComplete_args_applicationTypeWithExtensions = P.maybe (notifyRegistrationComplete_args_applicationTypeWithExtensions default_NotifyRegistrationComplete_args) (\(_,_val5217) -> (case _val5217 of {T.TString _val5219 -> E.decodeUtf8 _val5219; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyRegistrationComplete_args _ = P.error "not a struct"
read_NotifyRegistrationComplete_args :: T.Protocol p => p -> P.IO NotifyRegistrationComplete_args
read_NotifyRegistrationComplete_args iprot = to_NotifyRegistrationComplete_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_args)
decode_NotifyRegistrationComplete_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyRegistrationComplete_args
decode_NotifyRegistrationComplete_args iprot bs = to_NotifyRegistrationComplete_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_args) bs
typemap_NotifyRegistrationComplete_args :: T.TypeMap
typemap_NotifyRegistrationComplete_args = Map.fromList [(2,("udidHash",T.T_STRING)),(3,("applicationTypeWithExtensions",T.T_STRING))]
default_NotifyRegistrationComplete_args :: NotifyRegistrationComplete_args
default_NotifyRegistrationComplete_args = NotifyRegistrationComplete_args{
  notifyRegistrationComplete_args_udidHash = "",
  notifyRegistrationComplete_args_applicationTypeWithExtensions = ""}
data NotifyRegistrationComplete_result = NotifyRegistrationComplete_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyRegistrationComplete_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary NotifyRegistrationComplete_result where 
  arbitrary = QC.elements [NotifyRegistrationComplete_result]
from_NotifyRegistrationComplete_result :: NotifyRegistrationComplete_result -> T.ThriftVal
from_NotifyRegistrationComplete_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_NotifyRegistrationComplete_result :: T.Protocol p => p -> NotifyRegistrationComplete_result -> P.IO ()
write_NotifyRegistrationComplete_result oprot record = T.writeVal oprot $ from_NotifyRegistrationComplete_result record
encode_NotifyRegistrationComplete_result :: T.StatelessProtocol p => p -> NotifyRegistrationComplete_result -> LBS.ByteString
encode_NotifyRegistrationComplete_result oprot record = T.serializeVal oprot $ from_NotifyRegistrationComplete_result record
to_NotifyRegistrationComplete_result :: T.ThriftVal -> NotifyRegistrationComplete_result
to_NotifyRegistrationComplete_result (T.TStruct fields) = NotifyRegistrationComplete_result{

  }
to_NotifyRegistrationComplete_result _ = P.error "not a struct"
read_NotifyRegistrationComplete_result :: T.Protocol p => p -> P.IO NotifyRegistrationComplete_result
read_NotifyRegistrationComplete_result iprot = to_NotifyRegistrationComplete_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_result)
decode_NotifyRegistrationComplete_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyRegistrationComplete_result
decode_NotifyRegistrationComplete_result iprot bs = to_NotifyRegistrationComplete_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_result) bs
typemap_NotifyRegistrationComplete_result :: T.TypeMap
typemap_NotifyRegistrationComplete_result = Map.fromList []
default_NotifyRegistrationComplete_result :: NotifyRegistrationComplete_result
default_NotifyRegistrationComplete_result = NotifyRegistrationComplete_result{
}
data NotifySleep_args = NotifySleep_args  { notifySleep_args_lastRev :: I.Int64
  , notifySleep_args_badge :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifySleep_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifySleep_args_lastRev record   `H.hashWithSalt` notifySleep_args_badge record  
instance QC.Arbitrary NotifySleep_args where 
  arbitrary = M.liftM NotifySleep_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifySleep_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifySleep_args{notifySleep_args_lastRev = notifySleep_args_lastRev obj} then P.Nothing else P.Just $ default_NotifySleep_args{notifySleep_args_lastRev = notifySleep_args_lastRev obj}
    , if obj == default_NotifySleep_args{notifySleep_args_badge = notifySleep_args_badge obj} then P.Nothing else P.Just $ default_NotifySleep_args{notifySleep_args_badge = notifySleep_args_badge obj}
    ]
from_NotifySleep_args :: NotifySleep_args -> T.ThriftVal
from_NotifySleep_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5227 -> P.Just (2, ("lastRev",T.TI64 _v5227))) $ notifySleep_args_lastRev record
  , (\_v5227 -> P.Just (3, ("badge",T.TI32 _v5227))) $ notifySleep_args_badge record
  ]
write_NotifySleep_args :: T.Protocol p => p -> NotifySleep_args -> P.IO ()
write_NotifySleep_args oprot record = T.writeVal oprot $ from_NotifySleep_args record
encode_NotifySleep_args :: T.StatelessProtocol p => p -> NotifySleep_args -> LBS.ByteString
encode_NotifySleep_args oprot record = T.serializeVal oprot $ from_NotifySleep_args record
to_NotifySleep_args :: T.ThriftVal -> NotifySleep_args
to_NotifySleep_args (T.TStruct fields) = NotifySleep_args{
  notifySleep_args_lastRev = P.maybe (notifySleep_args_lastRev default_NotifySleep_args) (\(_,_val5229) -> (case _val5229 of {T.TI64 _val5230 -> _val5230; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifySleep_args_badge = P.maybe (notifySleep_args_badge default_NotifySleep_args) (\(_,_val5229) -> (case _val5229 of {T.TI32 _val5231 -> _val5231; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifySleep_args _ = P.error "not a struct"
read_NotifySleep_args :: T.Protocol p => p -> P.IO NotifySleep_args
read_NotifySleep_args iprot = to_NotifySleep_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifySleep_args)
decode_NotifySleep_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifySleep_args
decode_NotifySleep_args iprot bs = to_NotifySleep_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifySleep_args) bs
typemap_NotifySleep_args :: T.TypeMap
typemap_NotifySleep_args = Map.fromList [(2,("lastRev",T.T_I64)),(3,("badge",T.T_I32))]
default_NotifySleep_args :: NotifySleep_args
default_NotifySleep_args = NotifySleep_args{
  notifySleep_args_lastRev = 0,
  notifySleep_args_badge = 0}
data NotifySleep_result = NotifySleep_result  { notifySleep_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifySleep_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifySleep_result_e record  
instance QC.Arbitrary NotifySleep_result where 
  arbitrary = M.liftM NotifySleep_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifySleep_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifySleep_result{notifySleep_result_e = notifySleep_result_e obj} then P.Nothing else P.Just $ default_NotifySleep_result{notifySleep_result_e = notifySleep_result_e obj}
    ]
from_NotifySleep_result :: NotifySleep_result -> T.ThriftVal
from_NotifySleep_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5234 -> (1, ("e",from_TalkException _v5234))) <$> notifySleep_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5234 -> (1, ("e",from_TalkException _v5234))) <$> notifySleep_result_e record
    ]
    )
write_NotifySleep_result :: T.Protocol p => p -> NotifySleep_result -> P.IO ()
write_NotifySleep_result oprot record = T.writeVal oprot $ from_NotifySleep_result record
encode_NotifySleep_result :: T.StatelessProtocol p => p -> NotifySleep_result -> LBS.ByteString
encode_NotifySleep_result oprot record = T.serializeVal oprot $ from_NotifySleep_result record
to_NotifySleep_result :: T.ThriftVal -> NotifySleep_result
to_NotifySleep_result (T.TStruct fields) = NotifySleep_result{
  notifySleep_result_e = P.maybe (P.Nothing) (\(_,_val5236) -> P.Just (case _val5236 of {T.TStruct _val5237 -> (to_TalkException (T.TStruct _val5237)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifySleep_result _ = P.error "not a struct"
read_NotifySleep_result :: T.Protocol p => p -> P.IO NotifySleep_result
read_NotifySleep_result iprot = to_NotifySleep_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifySleep_result)
decode_NotifySleep_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifySleep_result
decode_NotifySleep_result iprot bs = to_NotifySleep_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifySleep_result) bs
typemap_NotifySleep_result :: T.TypeMap
typemap_NotifySleep_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifySleep_result :: NotifySleep_result
default_NotifySleep_result = NotifySleep_result{
  notifySleep_result_e = P.Nothing}
data NotifyUpdated_args = NotifyUpdated_args  { notifyUpdated_args_lastRev :: I.Int64
  , notifyUpdated_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyUpdated_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyUpdated_args_lastRev record   `H.hashWithSalt` notifyUpdated_args_deviceInfo record  
instance QC.Arbitrary NotifyUpdated_args where 
  arbitrary = M.liftM NotifyUpdated_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyUpdated_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyUpdated_args{notifyUpdated_args_lastRev = notifyUpdated_args_lastRev obj} then P.Nothing else P.Just $ default_NotifyUpdated_args{notifyUpdated_args_lastRev = notifyUpdated_args_lastRev obj}
    , if obj == default_NotifyUpdated_args{notifyUpdated_args_deviceInfo = notifyUpdated_args_deviceInfo obj} then P.Nothing else P.Just $ default_NotifyUpdated_args{notifyUpdated_args_deviceInfo = notifyUpdated_args_deviceInfo obj}
    ]
from_NotifyUpdated_args :: NotifyUpdated_args -> T.ThriftVal
from_NotifyUpdated_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5240 -> P.Just (2, ("lastRev",T.TI64 _v5240))) $ notifyUpdated_args_lastRev record
  , (\_v5240 -> P.Just (3, ("deviceInfo",from_DeviceInfo _v5240))) $ notifyUpdated_args_deviceInfo record
  ]
write_NotifyUpdated_args :: T.Protocol p => p -> NotifyUpdated_args -> P.IO ()
write_NotifyUpdated_args oprot record = T.writeVal oprot $ from_NotifyUpdated_args record
encode_NotifyUpdated_args :: T.StatelessProtocol p => p -> NotifyUpdated_args -> LBS.ByteString
encode_NotifyUpdated_args oprot record = T.serializeVal oprot $ from_NotifyUpdated_args record
to_NotifyUpdated_args :: T.ThriftVal -> NotifyUpdated_args
to_NotifyUpdated_args (T.TStruct fields) = NotifyUpdated_args{
  notifyUpdated_args_lastRev = P.maybe (notifyUpdated_args_lastRev default_NotifyUpdated_args) (\(_,_val5242) -> (case _val5242 of {T.TI64 _val5243 -> _val5243; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyUpdated_args_deviceInfo = P.maybe (notifyUpdated_args_deviceInfo default_NotifyUpdated_args) (\(_,_val5242) -> (case _val5242 of {T.TStruct _val5244 -> (to_DeviceInfo (T.TStruct _val5244)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyUpdated_args _ = P.error "not a struct"
read_NotifyUpdated_args :: T.Protocol p => p -> P.IO NotifyUpdated_args
read_NotifyUpdated_args iprot = to_NotifyUpdated_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyUpdated_args)
decode_NotifyUpdated_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyUpdated_args
decode_NotifyUpdated_args iprot bs = to_NotifyUpdated_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyUpdated_args) bs
typemap_NotifyUpdated_args :: T.TypeMap
typemap_NotifyUpdated_args = Map.fromList [(2,("lastRev",T.T_I64)),(3,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_NotifyUpdated_args :: NotifyUpdated_args
default_NotifyUpdated_args = NotifyUpdated_args{
  notifyUpdated_args_lastRev = 0,
  notifyUpdated_args_deviceInfo = default_DeviceInfo}
data NotifyUpdated_result = NotifyUpdated_result  { notifyUpdated_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyUpdated_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyUpdated_result_e record  
instance QC.Arbitrary NotifyUpdated_result where 
  arbitrary = M.liftM NotifyUpdated_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyUpdated_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyUpdated_result{notifyUpdated_result_e = notifyUpdated_result_e obj} then P.Nothing else P.Just $ default_NotifyUpdated_result{notifyUpdated_result_e = notifyUpdated_result_e obj}
    ]
from_NotifyUpdated_result :: NotifyUpdated_result -> T.ThriftVal
from_NotifyUpdated_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5247 -> (1, ("e",from_TalkException _v5247))) <$> notifyUpdated_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5247 -> (1, ("e",from_TalkException _v5247))) <$> notifyUpdated_result_e record
    ]
    )
write_NotifyUpdated_result :: T.Protocol p => p -> NotifyUpdated_result -> P.IO ()
write_NotifyUpdated_result oprot record = T.writeVal oprot $ from_NotifyUpdated_result record
encode_NotifyUpdated_result :: T.StatelessProtocol p => p -> NotifyUpdated_result -> LBS.ByteString
encode_NotifyUpdated_result oprot record = T.serializeVal oprot $ from_NotifyUpdated_result record
to_NotifyUpdated_result :: T.ThriftVal -> NotifyUpdated_result
to_NotifyUpdated_result (T.TStruct fields) = NotifyUpdated_result{
  notifyUpdated_result_e = P.maybe (P.Nothing) (\(_,_val5249) -> P.Just (case _val5249 of {T.TStruct _val5250 -> (to_TalkException (T.TStruct _val5250)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyUpdated_result _ = P.error "not a struct"
read_NotifyUpdated_result :: T.Protocol p => p -> P.IO NotifyUpdated_result
read_NotifyUpdated_result iprot = to_NotifyUpdated_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyUpdated_result)
decode_NotifyUpdated_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyUpdated_result
decode_NotifyUpdated_result iprot bs = to_NotifyUpdated_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyUpdated_result) bs
typemap_NotifyUpdated_result :: T.TypeMap
typemap_NotifyUpdated_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyUpdated_result :: NotifyUpdated_result
default_NotifyUpdated_result = NotifyUpdated_result{
  notifyUpdated_result_e = P.Nothing}
data OpenProximityMatch_args = OpenProximityMatch_args  { openProximityMatch_args_location :: Location
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OpenProximityMatch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` openProximityMatch_args_location record  
instance QC.Arbitrary OpenProximityMatch_args where 
  arbitrary = M.liftM OpenProximityMatch_args (QC.arbitrary)
  shrink obj | obj == default_OpenProximityMatch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OpenProximityMatch_args{openProximityMatch_args_location = openProximityMatch_args_location obj} then P.Nothing else P.Just $ default_OpenProximityMatch_args{openProximityMatch_args_location = openProximityMatch_args_location obj}
    ]
from_OpenProximityMatch_args :: OpenProximityMatch_args -> T.ThriftVal
from_OpenProximityMatch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5253 -> P.Just (2, ("location",from_Location _v5253))) $ openProximityMatch_args_location record
  ]
write_OpenProximityMatch_args :: T.Protocol p => p -> OpenProximityMatch_args -> P.IO ()
write_OpenProximityMatch_args oprot record = T.writeVal oprot $ from_OpenProximityMatch_args record
encode_OpenProximityMatch_args :: T.StatelessProtocol p => p -> OpenProximityMatch_args -> LBS.ByteString
encode_OpenProximityMatch_args oprot record = T.serializeVal oprot $ from_OpenProximityMatch_args record
to_OpenProximityMatch_args :: T.ThriftVal -> OpenProximityMatch_args
to_OpenProximityMatch_args (T.TStruct fields) = OpenProximityMatch_args{
  openProximityMatch_args_location = P.maybe (openProximityMatch_args_location default_OpenProximityMatch_args) (\(_,_val5255) -> (case _val5255 of {T.TStruct _val5256 -> (to_Location (T.TStruct _val5256)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_OpenProximityMatch_args _ = P.error "not a struct"
read_OpenProximityMatch_args :: T.Protocol p => p -> P.IO OpenProximityMatch_args
read_OpenProximityMatch_args iprot = to_OpenProximityMatch_args <$> T.readVal iprot (T.T_STRUCT typemap_OpenProximityMatch_args)
decode_OpenProximityMatch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> OpenProximityMatch_args
decode_OpenProximityMatch_args iprot bs = to_OpenProximityMatch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_OpenProximityMatch_args) bs
typemap_OpenProximityMatch_args :: T.TypeMap
typemap_OpenProximityMatch_args = Map.fromList [(2,("location",(T.T_STRUCT typemap_Location)))]
default_OpenProximityMatch_args :: OpenProximityMatch_args
default_OpenProximityMatch_args = OpenProximityMatch_args{
  openProximityMatch_args_location = default_Location}
data OpenProximityMatch_result = OpenProximityMatch_result  { openProximityMatch_result_success :: LT.Text
  , openProximityMatch_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OpenProximityMatch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` openProximityMatch_result_success record   `H.hashWithSalt` openProximityMatch_result_e record  
instance QC.Arbitrary OpenProximityMatch_result where 
  arbitrary = M.liftM OpenProximityMatch_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_OpenProximityMatch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OpenProximityMatch_result{openProximityMatch_result_success = openProximityMatch_result_success obj} then P.Nothing else P.Just $ default_OpenProximityMatch_result{openProximityMatch_result_success = openProximityMatch_result_success obj}
    , if obj == default_OpenProximityMatch_result{openProximityMatch_result_e = openProximityMatch_result_e obj} then P.Nothing else P.Just $ default_OpenProximityMatch_result{openProximityMatch_result_e = openProximityMatch_result_e obj}
    ]
from_OpenProximityMatch_result :: OpenProximityMatch_result -> T.ThriftVal
from_OpenProximityMatch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5259 -> (1, ("e",from_TalkException _v5259))) <$> openProximityMatch_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5259 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5259))) $ openProximityMatch_result_success record
    , (\_v5259 -> (1, ("e",from_TalkException _v5259))) <$> openProximityMatch_result_e record
    ]
    )
write_OpenProximityMatch_result :: T.Protocol p => p -> OpenProximityMatch_result -> P.IO ()
write_OpenProximityMatch_result oprot record = T.writeVal oprot $ from_OpenProximityMatch_result record
encode_OpenProximityMatch_result :: T.StatelessProtocol p => p -> OpenProximityMatch_result -> LBS.ByteString
encode_OpenProximityMatch_result oprot record = T.serializeVal oprot $ from_OpenProximityMatch_result record
to_OpenProximityMatch_result :: T.ThriftVal -> OpenProximityMatch_result
to_OpenProximityMatch_result (T.TStruct fields) = OpenProximityMatch_result{
  openProximityMatch_result_success = P.maybe (openProximityMatch_result_success default_OpenProximityMatch_result) (\(_,_val5261) -> (case _val5261 of {T.TString _val5262 -> E.decodeUtf8 _val5262; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  openProximityMatch_result_e = P.maybe (P.Nothing) (\(_,_val5261) -> P.Just (case _val5261 of {T.TStruct _val5263 -> (to_TalkException (T.TStruct _val5263)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_OpenProximityMatch_result _ = P.error "not a struct"
read_OpenProximityMatch_result :: T.Protocol p => p -> P.IO OpenProximityMatch_result
read_OpenProximityMatch_result iprot = to_OpenProximityMatch_result <$> T.readVal iprot (T.T_STRUCT typemap_OpenProximityMatch_result)
decode_OpenProximityMatch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> OpenProximityMatch_result
decode_OpenProximityMatch_result iprot bs = to_OpenProximityMatch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_OpenProximityMatch_result) bs
typemap_OpenProximityMatch_result :: T.TypeMap
typemap_OpenProximityMatch_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_OpenProximityMatch_result :: OpenProximityMatch_result
default_OpenProximityMatch_result = OpenProximityMatch_result{
  openProximityMatch_result_success = "",
  openProximityMatch_result_e = P.Nothing}
data RegisterBuddyUser_args = RegisterBuddyUser_args  { registerBuddyUser_args_buddyId :: LT.Text
  , registerBuddyUser_args_registrarPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUser_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUser_args_buddyId record   `H.hashWithSalt` registerBuddyUser_args_registrarPassword record  
instance QC.Arbitrary RegisterBuddyUser_args where 
  arbitrary = M.liftM RegisterBuddyUser_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUser_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUser_args{registerBuddyUser_args_buddyId = registerBuddyUser_args_buddyId obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_args{registerBuddyUser_args_buddyId = registerBuddyUser_args_buddyId obj}
    , if obj == default_RegisterBuddyUser_args{registerBuddyUser_args_registrarPassword = registerBuddyUser_args_registrarPassword obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_args{registerBuddyUser_args_registrarPassword = registerBuddyUser_args_registrarPassword obj}
    ]
from_RegisterBuddyUser_args :: RegisterBuddyUser_args -> T.ThriftVal
from_RegisterBuddyUser_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5266 -> P.Just (2, ("buddyId",T.TString $ E.encodeUtf8 _v5266))) $ registerBuddyUser_args_buddyId record
  , (\_v5266 -> P.Just (3, ("registrarPassword",T.TString $ E.encodeUtf8 _v5266))) $ registerBuddyUser_args_registrarPassword record
  ]
write_RegisterBuddyUser_args :: T.Protocol p => p -> RegisterBuddyUser_args -> P.IO ()
write_RegisterBuddyUser_args oprot record = T.writeVal oprot $ from_RegisterBuddyUser_args record
encode_RegisterBuddyUser_args :: T.StatelessProtocol p => p -> RegisterBuddyUser_args -> LBS.ByteString
encode_RegisterBuddyUser_args oprot record = T.serializeVal oprot $ from_RegisterBuddyUser_args record
to_RegisterBuddyUser_args :: T.ThriftVal -> RegisterBuddyUser_args
to_RegisterBuddyUser_args (T.TStruct fields) = RegisterBuddyUser_args{
  registerBuddyUser_args_buddyId = P.maybe (registerBuddyUser_args_buddyId default_RegisterBuddyUser_args) (\(_,_val5268) -> (case _val5268 of {T.TString _val5269 -> E.decodeUtf8 _val5269; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerBuddyUser_args_registrarPassword = P.maybe (registerBuddyUser_args_registrarPassword default_RegisterBuddyUser_args) (\(_,_val5268) -> (case _val5268 of {T.TString _val5270 -> E.decodeUtf8 _val5270; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterBuddyUser_args _ = P.error "not a struct"
read_RegisterBuddyUser_args :: T.Protocol p => p -> P.IO RegisterBuddyUser_args
read_RegisterBuddyUser_args iprot = to_RegisterBuddyUser_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_args)
decode_RegisterBuddyUser_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUser_args
decode_RegisterBuddyUser_args iprot bs = to_RegisterBuddyUser_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_args) bs
typemap_RegisterBuddyUser_args :: T.TypeMap
typemap_RegisterBuddyUser_args = Map.fromList [(2,("buddyId",T.T_STRING)),(3,("registrarPassword",T.T_STRING))]
default_RegisterBuddyUser_args :: RegisterBuddyUser_args
default_RegisterBuddyUser_args = RegisterBuddyUser_args{
  registerBuddyUser_args_buddyId = "",
  registerBuddyUser_args_registrarPassword = ""}
data RegisterBuddyUser_result = RegisterBuddyUser_result  { registerBuddyUser_result_success :: LT.Text
  , registerBuddyUser_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUser_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUser_result_success record   `H.hashWithSalt` registerBuddyUser_result_e record  
instance QC.Arbitrary RegisterBuddyUser_result where 
  arbitrary = M.liftM RegisterBuddyUser_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUser_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUser_result{registerBuddyUser_result_success = registerBuddyUser_result_success obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_result{registerBuddyUser_result_success = registerBuddyUser_result_success obj}
    , if obj == default_RegisterBuddyUser_result{registerBuddyUser_result_e = registerBuddyUser_result_e obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_result{registerBuddyUser_result_e = registerBuddyUser_result_e obj}
    ]
from_RegisterBuddyUser_result :: RegisterBuddyUser_result -> T.ThriftVal
from_RegisterBuddyUser_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5273 -> (1, ("e",from_TalkException _v5273))) <$> registerBuddyUser_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5273 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5273))) $ registerBuddyUser_result_success record
    , (\_v5273 -> (1, ("e",from_TalkException _v5273))) <$> registerBuddyUser_result_e record
    ]
    )
write_RegisterBuddyUser_result :: T.Protocol p => p -> RegisterBuddyUser_result -> P.IO ()
write_RegisterBuddyUser_result oprot record = T.writeVal oprot $ from_RegisterBuddyUser_result record
encode_RegisterBuddyUser_result :: T.StatelessProtocol p => p -> RegisterBuddyUser_result -> LBS.ByteString
encode_RegisterBuddyUser_result oprot record = T.serializeVal oprot $ from_RegisterBuddyUser_result record
to_RegisterBuddyUser_result :: T.ThriftVal -> RegisterBuddyUser_result
to_RegisterBuddyUser_result (T.TStruct fields) = RegisterBuddyUser_result{
  registerBuddyUser_result_success = P.maybe (registerBuddyUser_result_success default_RegisterBuddyUser_result) (\(_,_val5275) -> (case _val5275 of {T.TString _val5276 -> E.decodeUtf8 _val5276; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerBuddyUser_result_e = P.maybe (P.Nothing) (\(_,_val5275) -> P.Just (case _val5275 of {T.TStruct _val5277 -> (to_TalkException (T.TStruct _val5277)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterBuddyUser_result _ = P.error "not a struct"
read_RegisterBuddyUser_result :: T.Protocol p => p -> P.IO RegisterBuddyUser_result
read_RegisterBuddyUser_result iprot = to_RegisterBuddyUser_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_result)
decode_RegisterBuddyUser_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUser_result
decode_RegisterBuddyUser_result iprot bs = to_RegisterBuddyUser_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_result) bs
typemap_RegisterBuddyUser_result :: T.TypeMap
typemap_RegisterBuddyUser_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterBuddyUser_result :: RegisterBuddyUser_result
default_RegisterBuddyUser_result = RegisterBuddyUser_result{
  registerBuddyUser_result_success = "",
  registerBuddyUser_result_e = P.Nothing}
data RegisterBuddyUserid_args = RegisterBuddyUserid_args  { registerBuddyUserid_args_seq :: I.Int32
  , registerBuddyUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUserid_args_seq record   `H.hashWithSalt` registerBuddyUserid_args_userid record  
instance QC.Arbitrary RegisterBuddyUserid_args where 
  arbitrary = M.liftM RegisterBuddyUserid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUserid_args{registerBuddyUserid_args_seq = registerBuddyUserid_args_seq obj} then P.Nothing else P.Just $ default_RegisterBuddyUserid_args{registerBuddyUserid_args_seq = registerBuddyUserid_args_seq obj}
    , if obj == default_RegisterBuddyUserid_args{registerBuddyUserid_args_userid = registerBuddyUserid_args_userid obj} then P.Nothing else P.Just $ default_RegisterBuddyUserid_args{registerBuddyUserid_args_userid = registerBuddyUserid_args_userid obj}
    ]
from_RegisterBuddyUserid_args :: RegisterBuddyUserid_args -> T.ThriftVal
from_RegisterBuddyUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5280 -> P.Just (2, ("seq",T.TI32 _v5280))) $ registerBuddyUserid_args_seq record
  , (\_v5280 -> P.Just (3, ("userid",T.TString $ E.encodeUtf8 _v5280))) $ registerBuddyUserid_args_userid record
  ]
write_RegisterBuddyUserid_args :: T.Protocol p => p -> RegisterBuddyUserid_args -> P.IO ()
write_RegisterBuddyUserid_args oprot record = T.writeVal oprot $ from_RegisterBuddyUserid_args record
encode_RegisterBuddyUserid_args :: T.StatelessProtocol p => p -> RegisterBuddyUserid_args -> LBS.ByteString
encode_RegisterBuddyUserid_args oprot record = T.serializeVal oprot $ from_RegisterBuddyUserid_args record
to_RegisterBuddyUserid_args :: T.ThriftVal -> RegisterBuddyUserid_args
to_RegisterBuddyUserid_args (T.TStruct fields) = RegisterBuddyUserid_args{
  registerBuddyUserid_args_seq = P.maybe (registerBuddyUserid_args_seq default_RegisterBuddyUserid_args) (\(_,_val5282) -> (case _val5282 of {T.TI32 _val5283 -> _val5283; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerBuddyUserid_args_userid = P.maybe (registerBuddyUserid_args_userid default_RegisterBuddyUserid_args) (\(_,_val5282) -> (case _val5282 of {T.TString _val5284 -> E.decodeUtf8 _val5284; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterBuddyUserid_args _ = P.error "not a struct"
read_RegisterBuddyUserid_args :: T.Protocol p => p -> P.IO RegisterBuddyUserid_args
read_RegisterBuddyUserid_args iprot = to_RegisterBuddyUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_args)
decode_RegisterBuddyUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUserid_args
decode_RegisterBuddyUserid_args iprot bs = to_RegisterBuddyUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_args) bs
typemap_RegisterBuddyUserid_args :: T.TypeMap
typemap_RegisterBuddyUserid_args = Map.fromList [(2,("seq",T.T_I32)),(3,("userid",T.T_STRING))]
default_RegisterBuddyUserid_args :: RegisterBuddyUserid_args
default_RegisterBuddyUserid_args = RegisterBuddyUserid_args{
  registerBuddyUserid_args_seq = 0,
  registerBuddyUserid_args_userid = ""}
data RegisterBuddyUserid_result = RegisterBuddyUserid_result  { registerBuddyUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUserid_result_e record  
instance QC.Arbitrary RegisterBuddyUserid_result where 
  arbitrary = M.liftM RegisterBuddyUserid_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUserid_result{registerBuddyUserid_result_e = registerBuddyUserid_result_e obj} then P.Nothing else P.Just $ default_RegisterBuddyUserid_result{registerBuddyUserid_result_e = registerBuddyUserid_result_e obj}
    ]
from_RegisterBuddyUserid_result :: RegisterBuddyUserid_result -> T.ThriftVal
from_RegisterBuddyUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5287 -> (1, ("e",from_TalkException _v5287))) <$> registerBuddyUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5287 -> (1, ("e",from_TalkException _v5287))) <$> registerBuddyUserid_result_e record
    ]
    )
write_RegisterBuddyUserid_result :: T.Protocol p => p -> RegisterBuddyUserid_result -> P.IO ()
write_RegisterBuddyUserid_result oprot record = T.writeVal oprot $ from_RegisterBuddyUserid_result record
encode_RegisterBuddyUserid_result :: T.StatelessProtocol p => p -> RegisterBuddyUserid_result -> LBS.ByteString
encode_RegisterBuddyUserid_result oprot record = T.serializeVal oprot $ from_RegisterBuddyUserid_result record
to_RegisterBuddyUserid_result :: T.ThriftVal -> RegisterBuddyUserid_result
to_RegisterBuddyUserid_result (T.TStruct fields) = RegisterBuddyUserid_result{
  registerBuddyUserid_result_e = P.maybe (P.Nothing) (\(_,_val5289) -> P.Just (case _val5289 of {T.TStruct _val5290 -> (to_TalkException (T.TStruct _val5290)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterBuddyUserid_result _ = P.error "not a struct"
read_RegisterBuddyUserid_result :: T.Protocol p => p -> P.IO RegisterBuddyUserid_result
read_RegisterBuddyUserid_result iprot = to_RegisterBuddyUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_result)
decode_RegisterBuddyUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUserid_result
decode_RegisterBuddyUserid_result iprot bs = to_RegisterBuddyUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_result) bs
typemap_RegisterBuddyUserid_result :: T.TypeMap
typemap_RegisterBuddyUserid_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterBuddyUserid_result :: RegisterBuddyUserid_result
default_RegisterBuddyUserid_result = RegisterBuddyUserid_result{
  registerBuddyUserid_result_e = P.Nothing}
data RegisterDevice_args = RegisterDevice_args  { registerDevice_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDevice_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDevice_args_sessionId record  
instance QC.Arbitrary RegisterDevice_args where 
  arbitrary = M.liftM RegisterDevice_args (QC.arbitrary)
  shrink obj | obj == default_RegisterDevice_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDevice_args{registerDevice_args_sessionId = registerDevice_args_sessionId obj} then P.Nothing else P.Just $ default_RegisterDevice_args{registerDevice_args_sessionId = registerDevice_args_sessionId obj}
    ]
from_RegisterDevice_args :: RegisterDevice_args -> T.ThriftVal
from_RegisterDevice_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5293 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v5293))) $ registerDevice_args_sessionId record
  ]
write_RegisterDevice_args :: T.Protocol p => p -> RegisterDevice_args -> P.IO ()
write_RegisterDevice_args oprot record = T.writeVal oprot $ from_RegisterDevice_args record
encode_RegisterDevice_args :: T.StatelessProtocol p => p -> RegisterDevice_args -> LBS.ByteString
encode_RegisterDevice_args oprot record = T.serializeVal oprot $ from_RegisterDevice_args record
to_RegisterDevice_args :: T.ThriftVal -> RegisterDevice_args
to_RegisterDevice_args (T.TStruct fields) = RegisterDevice_args{
  registerDevice_args_sessionId = P.maybe (registerDevice_args_sessionId default_RegisterDevice_args) (\(_,_val5295) -> (case _val5295 of {T.TString _val5296 -> E.decodeUtf8 _val5296; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterDevice_args _ = P.error "not a struct"
read_RegisterDevice_args :: T.Protocol p => p -> P.IO RegisterDevice_args
read_RegisterDevice_args iprot = to_RegisterDevice_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDevice_args)
decode_RegisterDevice_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDevice_args
decode_RegisterDevice_args iprot bs = to_RegisterDevice_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDevice_args) bs
typemap_RegisterDevice_args :: T.TypeMap
typemap_RegisterDevice_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_RegisterDevice_args :: RegisterDevice_args
default_RegisterDevice_args = RegisterDevice_args{
  registerDevice_args_sessionId = ""}
data RegisterDevice_result = RegisterDevice_result  { registerDevice_result_success :: LT.Text
  , registerDevice_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDevice_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDevice_result_success record   `H.hashWithSalt` registerDevice_result_e record  
instance QC.Arbitrary RegisterDevice_result where 
  arbitrary = M.liftM RegisterDevice_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDevice_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDevice_result{registerDevice_result_success = registerDevice_result_success obj} then P.Nothing else P.Just $ default_RegisterDevice_result{registerDevice_result_success = registerDevice_result_success obj}
    , if obj == default_RegisterDevice_result{registerDevice_result_e = registerDevice_result_e obj} then P.Nothing else P.Just $ default_RegisterDevice_result{registerDevice_result_e = registerDevice_result_e obj}
    ]
from_RegisterDevice_result :: RegisterDevice_result -> T.ThriftVal
from_RegisterDevice_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5299 -> (1, ("e",from_TalkException _v5299))) <$> registerDevice_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5299 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5299))) $ registerDevice_result_success record
    , (\_v5299 -> (1, ("e",from_TalkException _v5299))) <$> registerDevice_result_e record
    ]
    )
write_RegisterDevice_result :: T.Protocol p => p -> RegisterDevice_result -> P.IO ()
write_RegisterDevice_result oprot record = T.writeVal oprot $ from_RegisterDevice_result record
encode_RegisterDevice_result :: T.StatelessProtocol p => p -> RegisterDevice_result -> LBS.ByteString
encode_RegisterDevice_result oprot record = T.serializeVal oprot $ from_RegisterDevice_result record
to_RegisterDevice_result :: T.ThriftVal -> RegisterDevice_result
to_RegisterDevice_result (T.TStruct fields) = RegisterDevice_result{
  registerDevice_result_success = P.maybe (registerDevice_result_success default_RegisterDevice_result) (\(_,_val5301) -> (case _val5301 of {T.TString _val5302 -> E.decodeUtf8 _val5302; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDevice_result_e = P.maybe (P.Nothing) (\(_,_val5301) -> P.Just (case _val5301 of {T.TStruct _val5303 -> (to_TalkException (T.TStruct _val5303)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDevice_result _ = P.error "not a struct"
read_RegisterDevice_result :: T.Protocol p => p -> P.IO RegisterDevice_result
read_RegisterDevice_result iprot = to_RegisterDevice_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDevice_result)
decode_RegisterDevice_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDevice_result
decode_RegisterDevice_result iprot bs = to_RegisterDevice_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDevice_result) bs
typemap_RegisterDevice_result :: T.TypeMap
typemap_RegisterDevice_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDevice_result :: RegisterDevice_result
default_RegisterDevice_result = RegisterDevice_result{
  registerDevice_result_success = "",
  registerDevice_result_e = P.Nothing}
data RegisterDeviceWithIdentityCredential_args = RegisterDeviceWithIdentityCredential_args  { registerDeviceWithIdentityCredential_args_sessionId :: LT.Text
  , registerDeviceWithIdentityCredential_args_provider :: IdentityProvider
  , registerDeviceWithIdentityCredential_args_identifier :: LT.Text
  , registerDeviceWithIdentityCredential_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_sessionId record   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_provider record   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_identifier record   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_verifier record  
instance QC.Arbitrary RegisterDeviceWithIdentityCredential_args where 
  arbitrary = M.liftM RegisterDeviceWithIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_sessionId = registerDeviceWithIdentityCredential_args_sessionId obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_sessionId = registerDeviceWithIdentityCredential_args_sessionId obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_provider = registerDeviceWithIdentityCredential_args_provider obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_provider = registerDeviceWithIdentityCredential_args_provider obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_identifier = registerDeviceWithIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_identifier = registerDeviceWithIdentityCredential_args_identifier obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_verifier = registerDeviceWithIdentityCredential_args_verifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_verifier = registerDeviceWithIdentityCredential_args_verifier obj}
    ]
from_RegisterDeviceWithIdentityCredential_args :: RegisterDeviceWithIdentityCredential_args -> T.ThriftVal
from_RegisterDeviceWithIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5306 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v5306))) $ registerDeviceWithIdentityCredential_args_sessionId record
  , (\_v5306 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v5306))) $ registerDeviceWithIdentityCredential_args_identifier record
  , (\_v5306 -> P.Just (4, ("verifier",T.TString $ E.encodeUtf8 _v5306))) $ registerDeviceWithIdentityCredential_args_verifier record
  , (\_v5306 -> P.Just (5, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v5306))) $ registerDeviceWithIdentityCredential_args_provider record
  ]
write_RegisterDeviceWithIdentityCredential_args :: T.Protocol p => p -> RegisterDeviceWithIdentityCredential_args -> P.IO ()
write_RegisterDeviceWithIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterDeviceWithIdentityCredential_args record
encode_RegisterDeviceWithIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterDeviceWithIdentityCredential_args -> LBS.ByteString
encode_RegisterDeviceWithIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterDeviceWithIdentityCredential_args record
to_RegisterDeviceWithIdentityCredential_args :: T.ThriftVal -> RegisterDeviceWithIdentityCredential_args
to_RegisterDeviceWithIdentityCredential_args (T.TStruct fields) = RegisterDeviceWithIdentityCredential_args{
  registerDeviceWithIdentityCredential_args_sessionId = P.maybe (registerDeviceWithIdentityCredential_args_sessionId default_RegisterDeviceWithIdentityCredential_args) (\(_,_val5308) -> (case _val5308 of {T.TString _val5309 -> E.decodeUtf8 _val5309; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerDeviceWithIdentityCredential_args_provider = P.maybe (registerDeviceWithIdentityCredential_args_provider default_RegisterDeviceWithIdentityCredential_args) (\(_,_val5308) -> (case _val5308 of {T.TI32 _val5310 -> P.toEnum $ P.fromIntegral _val5310; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerDeviceWithIdentityCredential_args_identifier = P.maybe (registerDeviceWithIdentityCredential_args_identifier default_RegisterDeviceWithIdentityCredential_args) (\(_,_val5308) -> (case _val5308 of {T.TString _val5311 -> E.decodeUtf8 _val5311; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerDeviceWithIdentityCredential_args_verifier = P.maybe (registerDeviceWithIdentityCredential_args_verifier default_RegisterDeviceWithIdentityCredential_args) (\(_,_val5308) -> (case _val5308 of {T.TString _val5312 -> E.decodeUtf8 _val5312; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RegisterDeviceWithIdentityCredential_args _ = P.error "not a struct"
read_RegisterDeviceWithIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterDeviceWithIdentityCredential_args
read_RegisterDeviceWithIdentityCredential_args iprot = to_RegisterDeviceWithIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_args)
decode_RegisterDeviceWithIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithIdentityCredential_args
decode_RegisterDeviceWithIdentityCredential_args iprot bs = to_RegisterDeviceWithIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_args) bs
typemap_RegisterDeviceWithIdentityCredential_args :: T.TypeMap
typemap_RegisterDeviceWithIdentityCredential_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("identifier",T.T_STRING)),(4,("verifier",T.T_STRING)),(5,("provider",T.T_I32))]
default_RegisterDeviceWithIdentityCredential_args :: RegisterDeviceWithIdentityCredential_args
default_RegisterDeviceWithIdentityCredential_args = RegisterDeviceWithIdentityCredential_args{
  registerDeviceWithIdentityCredential_args_sessionId = "",
  registerDeviceWithIdentityCredential_args_identifier = "",
  registerDeviceWithIdentityCredential_args_verifier = "",
  registerDeviceWithIdentityCredential_args_provider = (P.toEnum 0)}
data RegisterDeviceWithIdentityCredential_result = RegisterDeviceWithIdentityCredential_result  { registerDeviceWithIdentityCredential_result_success :: LT.Text
  , registerDeviceWithIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithIdentityCredential_result_success record   `H.hashWithSalt` registerDeviceWithIdentityCredential_result_e record  
instance QC.Arbitrary RegisterDeviceWithIdentityCredential_result where 
  arbitrary = M.liftM RegisterDeviceWithIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_success = registerDeviceWithIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_success = registerDeviceWithIdentityCredential_result_success obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_e = registerDeviceWithIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_e = registerDeviceWithIdentityCredential_result_e obj}
    ]
from_RegisterDeviceWithIdentityCredential_result :: RegisterDeviceWithIdentityCredential_result -> T.ThriftVal
from_RegisterDeviceWithIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5315 -> (1, ("e",from_TalkException _v5315))) <$> registerDeviceWithIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5315 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5315))) $ registerDeviceWithIdentityCredential_result_success record
    , (\_v5315 -> (1, ("e",from_TalkException _v5315))) <$> registerDeviceWithIdentityCredential_result_e record
    ]
    )
write_RegisterDeviceWithIdentityCredential_result :: T.Protocol p => p -> RegisterDeviceWithIdentityCredential_result -> P.IO ()
write_RegisterDeviceWithIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterDeviceWithIdentityCredential_result record
encode_RegisterDeviceWithIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterDeviceWithIdentityCredential_result -> LBS.ByteString
encode_RegisterDeviceWithIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterDeviceWithIdentityCredential_result record
to_RegisterDeviceWithIdentityCredential_result :: T.ThriftVal -> RegisterDeviceWithIdentityCredential_result
to_RegisterDeviceWithIdentityCredential_result (T.TStruct fields) = RegisterDeviceWithIdentityCredential_result{
  registerDeviceWithIdentityCredential_result_success = P.maybe (registerDeviceWithIdentityCredential_result_success default_RegisterDeviceWithIdentityCredential_result) (\(_,_val5317) -> (case _val5317 of {T.TString _val5318 -> E.decodeUtf8 _val5318; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDeviceWithIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val5317) -> P.Just (case _val5317 of {T.TStruct _val5319 -> (to_TalkException (T.TStruct _val5319)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDeviceWithIdentityCredential_result _ = P.error "not a struct"
read_RegisterDeviceWithIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterDeviceWithIdentityCredential_result
read_RegisterDeviceWithIdentityCredential_result iprot = to_RegisterDeviceWithIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_result)
decode_RegisterDeviceWithIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithIdentityCredential_result
decode_RegisterDeviceWithIdentityCredential_result iprot bs = to_RegisterDeviceWithIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_result) bs
typemap_RegisterDeviceWithIdentityCredential_result :: T.TypeMap
typemap_RegisterDeviceWithIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDeviceWithIdentityCredential_result :: RegisterDeviceWithIdentityCredential_result
default_RegisterDeviceWithIdentityCredential_result = RegisterDeviceWithIdentityCredential_result{
  registerDeviceWithIdentityCredential_result_success = "",
  registerDeviceWithIdentityCredential_result_e = P.Nothing}
data RegisterDeviceWithoutPhoneNumber_args = RegisterDeviceWithoutPhoneNumber_args  { registerDeviceWithoutPhoneNumber_args_region :: LT.Text
  , registerDeviceWithoutPhoneNumber_args_udidHash :: LT.Text
  , registerDeviceWithoutPhoneNumber_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_args_region record   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_args_udidHash record   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_args_deviceInfo record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumber_args where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_region = registerDeviceWithoutPhoneNumber_args_region obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_region = registerDeviceWithoutPhoneNumber_args_region obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_udidHash = registerDeviceWithoutPhoneNumber_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_udidHash = registerDeviceWithoutPhoneNumber_args_udidHash obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_deviceInfo = registerDeviceWithoutPhoneNumber_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_deviceInfo = registerDeviceWithoutPhoneNumber_args_deviceInfo obj}
    ]
from_RegisterDeviceWithoutPhoneNumber_args :: RegisterDeviceWithoutPhoneNumber_args -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5322 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v5322))) $ registerDeviceWithoutPhoneNumber_args_region record
  , (\_v5322 -> P.Just (3, ("udidHash",T.TString $ E.encodeUtf8 _v5322))) $ registerDeviceWithoutPhoneNumber_args_udidHash record
  , (\_v5322 -> P.Just (4, ("deviceInfo",from_DeviceInfo _v5322))) $ registerDeviceWithoutPhoneNumber_args_deviceInfo record
  ]
write_RegisterDeviceWithoutPhoneNumber_args :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumber_args -> P.IO ()
write_RegisterDeviceWithoutPhoneNumber_args oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_args record
encode_RegisterDeviceWithoutPhoneNumber_args :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumber_args -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumber_args oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_args record
to_RegisterDeviceWithoutPhoneNumber_args :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumber_args
to_RegisterDeviceWithoutPhoneNumber_args (T.TStruct fields) = RegisterDeviceWithoutPhoneNumber_args{
  registerDeviceWithoutPhoneNumber_args_region = P.maybe (registerDeviceWithoutPhoneNumber_args_region default_RegisterDeviceWithoutPhoneNumber_args) (\(_,_val5324) -> (case _val5324 of {T.TString _val5325 -> E.decodeUtf8 _val5325; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerDeviceWithoutPhoneNumber_args_udidHash = P.maybe (registerDeviceWithoutPhoneNumber_args_udidHash default_RegisterDeviceWithoutPhoneNumber_args) (\(_,_val5324) -> (case _val5324 of {T.TString _val5326 -> E.decodeUtf8 _val5326; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerDeviceWithoutPhoneNumber_args_deviceInfo = P.maybe (registerDeviceWithoutPhoneNumber_args_deviceInfo default_RegisterDeviceWithoutPhoneNumber_args) (\(_,_val5324) -> (case _val5324 of {T.TStruct _val5327 -> (to_DeviceInfo (T.TStruct _val5327)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RegisterDeviceWithoutPhoneNumber_args _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumber_args :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumber_args
read_RegisterDeviceWithoutPhoneNumber_args iprot = to_RegisterDeviceWithoutPhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_args)
decode_RegisterDeviceWithoutPhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumber_args
decode_RegisterDeviceWithoutPhoneNumber_args iprot bs = to_RegisterDeviceWithoutPhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_args) bs
typemap_RegisterDeviceWithoutPhoneNumber_args :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumber_args = Map.fromList [(2,("region",T.T_STRING)),(3,("udidHash",T.T_STRING)),(4,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterDeviceWithoutPhoneNumber_args :: RegisterDeviceWithoutPhoneNumber_args
default_RegisterDeviceWithoutPhoneNumber_args = RegisterDeviceWithoutPhoneNumber_args{
  registerDeviceWithoutPhoneNumber_args_region = "",
  registerDeviceWithoutPhoneNumber_args_udidHash = "",
  registerDeviceWithoutPhoneNumber_args_deviceInfo = default_DeviceInfo}
data RegisterDeviceWithoutPhoneNumber_result = RegisterDeviceWithoutPhoneNumber_result  { registerDeviceWithoutPhoneNumber_result_success :: LT.Text
  , registerDeviceWithoutPhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_result_success record   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_result_e record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumber_result where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_success = registerDeviceWithoutPhoneNumber_result_success obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_success = registerDeviceWithoutPhoneNumber_result_success obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_e = registerDeviceWithoutPhoneNumber_result_e obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_e = registerDeviceWithoutPhoneNumber_result_e obj}
    ]
from_RegisterDeviceWithoutPhoneNumber_result :: RegisterDeviceWithoutPhoneNumber_result -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5330 -> (1, ("e",from_TalkException _v5330))) <$> registerDeviceWithoutPhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5330 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5330))) $ registerDeviceWithoutPhoneNumber_result_success record
    , (\_v5330 -> (1, ("e",from_TalkException _v5330))) <$> registerDeviceWithoutPhoneNumber_result_e record
    ]
    )
write_RegisterDeviceWithoutPhoneNumber_result :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumber_result -> P.IO ()
write_RegisterDeviceWithoutPhoneNumber_result oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_result record
encode_RegisterDeviceWithoutPhoneNumber_result :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumber_result -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumber_result oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_result record
to_RegisterDeviceWithoutPhoneNumber_result :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumber_result
to_RegisterDeviceWithoutPhoneNumber_result (T.TStruct fields) = RegisterDeviceWithoutPhoneNumber_result{
  registerDeviceWithoutPhoneNumber_result_success = P.maybe (registerDeviceWithoutPhoneNumber_result_success default_RegisterDeviceWithoutPhoneNumber_result) (\(_,_val5332) -> (case _val5332 of {T.TString _val5333 -> E.decodeUtf8 _val5333; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDeviceWithoutPhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val5332) -> P.Just (case _val5332 of {T.TStruct _val5334 -> (to_TalkException (T.TStruct _val5334)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDeviceWithoutPhoneNumber_result _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumber_result :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumber_result
read_RegisterDeviceWithoutPhoneNumber_result iprot = to_RegisterDeviceWithoutPhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_result)
decode_RegisterDeviceWithoutPhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumber_result
decode_RegisterDeviceWithoutPhoneNumber_result iprot bs = to_RegisterDeviceWithoutPhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_result) bs
typemap_RegisterDeviceWithoutPhoneNumber_result :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumber_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDeviceWithoutPhoneNumber_result :: RegisterDeviceWithoutPhoneNumber_result
default_RegisterDeviceWithoutPhoneNumber_result = RegisterDeviceWithoutPhoneNumber_result{
  registerDeviceWithoutPhoneNumber_result_success = "",
  registerDeviceWithoutPhoneNumber_result_e = P.Nothing}
data RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args  { registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo :: DeviceInfo
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider :: IdentityProvider
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid obj}
    ]
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5337 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v5337))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region record
  , (\_v5337 -> P.Just (3, ("udidHash",T.TString $ E.encodeUtf8 _v5337))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash record
  , (\_v5337 -> P.Just (4, ("deviceInfo",from_DeviceInfo _v5337))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo record
  , (\_v5337 -> P.Just (5, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v5337))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider record
  , (\_v5337 -> P.Just (6, ("identifier",T.TString $ E.encodeUtf8 _v5337))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier record
  , (\_v5337 -> P.Just (7, ("verifier",T.TString $ E.encodeUtf8 _v5337))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier record
  , (\_v5337 -> P.Just (8, ("mid",T.TString $ E.encodeUtf8 _v5337))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid record
  ]
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args -> P.IO ()
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args record
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args record
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args (T.TStruct fields) = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val5339) -> (case _val5339 of {T.TString _val5340 -> E.decodeUtf8 _val5340; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val5339) -> (case _val5339 of {T.TString _val5341 -> E.decodeUtf8 _val5341; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val5339) -> (case _val5339 of {T.TStruct _val5342 -> (to_DeviceInfo (T.TStruct _val5342)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val5339) -> (case _val5339 of {T.TI32 _val5343 -> P.toEnum $ P.fromIntegral _val5343; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val5339) -> (case _val5339 of {T.TString _val5344 -> E.decodeUtf8 _val5344; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val5339) -> (case _val5339 of {T.TString _val5345 -> E.decodeUtf8 _val5345; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val5339) -> (case _val5339 of {T.TString _val5346 -> E.decodeUtf8 _val5346; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args iprot = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args)
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args iprot bs = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) bs
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = Map.fromList [(2,("region",T.T_STRING)),(3,("udidHash",T.T_STRING)),(4,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(5,("provider",T.T_I32)),(6,("identifier",T.T_STRING)),(7,("verifier",T.T_STRING)),(8,("mid",T.T_STRING))]
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = default_DeviceInfo,
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = (P.toEnum 0),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = ""}
data RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result  { registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e obj}
    ]
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5349 -> (1, ("e",from_TalkException _v5349))) <$> registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5349 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5349))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success record
    , (\_v5349 -> (1, ("e",from_TalkException _v5349))) <$> registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e record
    ]
    )
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result -> P.IO ()
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result record
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result record
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result (T.TStruct fields) = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result) (\(_,_val5351) -> (case _val5351 of {T.TString _val5352 -> E.decodeUtf8 _val5352; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val5351) -> P.Just (case _val5351 of {T.TStruct _val5353 -> (to_TalkException (T.TStruct _val5353)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result iprot = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result)
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result iprot bs = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result) bs
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = P.Nothing}
data RegisterUserid_args = RegisterUserid_args  { registerUserid_args_reqSeq :: I.Int32
  , registerUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerUserid_args_reqSeq record   `H.hashWithSalt` registerUserid_args_userid record  
instance QC.Arbitrary RegisterUserid_args where 
  arbitrary = M.liftM RegisterUserid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterUserid_args{registerUserid_args_reqSeq = registerUserid_args_reqSeq obj} then P.Nothing else P.Just $ default_RegisterUserid_args{registerUserid_args_reqSeq = registerUserid_args_reqSeq obj}
    , if obj == default_RegisterUserid_args{registerUserid_args_userid = registerUserid_args_userid obj} then P.Nothing else P.Just $ default_RegisterUserid_args{registerUserid_args_userid = registerUserid_args_userid obj}
    ]
from_RegisterUserid_args :: RegisterUserid_args -> T.ThriftVal
from_RegisterUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5356 -> P.Just (1, ("reqSeq",T.TI32 _v5356))) $ registerUserid_args_reqSeq record
  , (\_v5356 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v5356))) $ registerUserid_args_userid record
  ]
write_RegisterUserid_args :: T.Protocol p => p -> RegisterUserid_args -> P.IO ()
write_RegisterUserid_args oprot record = T.writeVal oprot $ from_RegisterUserid_args record
encode_RegisterUserid_args :: T.StatelessProtocol p => p -> RegisterUserid_args -> LBS.ByteString
encode_RegisterUserid_args oprot record = T.serializeVal oprot $ from_RegisterUserid_args record
to_RegisterUserid_args :: T.ThriftVal -> RegisterUserid_args
to_RegisterUserid_args (T.TStruct fields) = RegisterUserid_args{
  registerUserid_args_reqSeq = P.maybe (registerUserid_args_reqSeq default_RegisterUserid_args) (\(_,_val5358) -> (case _val5358 of {T.TI32 _val5359 -> _val5359; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  registerUserid_args_userid = P.maybe (registerUserid_args_userid default_RegisterUserid_args) (\(_,_val5358) -> (case _val5358 of {T.TString _val5360 -> E.decodeUtf8 _val5360; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterUserid_args _ = P.error "not a struct"
read_RegisterUserid_args :: T.Protocol p => p -> P.IO RegisterUserid_args
read_RegisterUserid_args iprot = to_RegisterUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterUserid_args)
decode_RegisterUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterUserid_args
decode_RegisterUserid_args iprot bs = to_RegisterUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterUserid_args) bs
typemap_RegisterUserid_args :: T.TypeMap
typemap_RegisterUserid_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("userid",T.T_STRING))]
default_RegisterUserid_args :: RegisterUserid_args
default_RegisterUserid_args = RegisterUserid_args{
  registerUserid_args_reqSeq = 0,
  registerUserid_args_userid = ""}
data RegisterUserid_result = RegisterUserid_result  { registerUserid_result_success :: P.Bool
  , registerUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerUserid_result_success record   `H.hashWithSalt` registerUserid_result_e record  
instance QC.Arbitrary RegisterUserid_result where 
  arbitrary = M.liftM RegisterUserid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterUserid_result{registerUserid_result_success = registerUserid_result_success obj} then P.Nothing else P.Just $ default_RegisterUserid_result{registerUserid_result_success = registerUserid_result_success obj}
    , if obj == default_RegisterUserid_result{registerUserid_result_e = registerUserid_result_e obj} then P.Nothing else P.Just $ default_RegisterUserid_result{registerUserid_result_e = registerUserid_result_e obj}
    ]
from_RegisterUserid_result :: RegisterUserid_result -> T.ThriftVal
from_RegisterUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5363 -> (1, ("e",from_TalkException _v5363))) <$> registerUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5363 -> P.Just (0, ("success",T.TBool _v5363))) $ registerUserid_result_success record
    , (\_v5363 -> (1, ("e",from_TalkException _v5363))) <$> registerUserid_result_e record
    ]
    )
write_RegisterUserid_result :: T.Protocol p => p -> RegisterUserid_result -> P.IO ()
write_RegisterUserid_result oprot record = T.writeVal oprot $ from_RegisterUserid_result record
encode_RegisterUserid_result :: T.StatelessProtocol p => p -> RegisterUserid_result -> LBS.ByteString
encode_RegisterUserid_result oprot record = T.serializeVal oprot $ from_RegisterUserid_result record
to_RegisterUserid_result :: T.ThriftVal -> RegisterUserid_result
to_RegisterUserid_result (T.TStruct fields) = RegisterUserid_result{
  registerUserid_result_success = P.maybe (registerUserid_result_success default_RegisterUserid_result) (\(_,_val5365) -> (case _val5365 of {T.TBool _val5366 -> _val5366; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerUserid_result_e = P.maybe (P.Nothing) (\(_,_val5365) -> P.Just (case _val5365 of {T.TStruct _val5367 -> (to_TalkException (T.TStruct _val5367)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterUserid_result _ = P.error "not a struct"
read_RegisterUserid_result :: T.Protocol p => p -> P.IO RegisterUserid_result
read_RegisterUserid_result iprot = to_RegisterUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterUserid_result)
decode_RegisterUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterUserid_result
decode_RegisterUserid_result iprot bs = to_RegisterUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterUserid_result) bs
typemap_RegisterUserid_result :: T.TypeMap
typemap_RegisterUserid_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterUserid_result :: RegisterUserid_result
default_RegisterUserid_result = RegisterUserid_result{
  registerUserid_result_success = P.False,
  registerUserid_result_e = P.Nothing}
data RegisterWapDevice_args = RegisterWapDevice_args  { registerWapDevice_args_invitationHash :: LT.Text
  , registerWapDevice_args_guidHash :: LT.Text
  , registerWapDevice_args_email :: LT.Text
  , registerWapDevice_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWapDevice_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWapDevice_args_invitationHash record   `H.hashWithSalt` registerWapDevice_args_guidHash record   `H.hashWithSalt` registerWapDevice_args_email record   `H.hashWithSalt` registerWapDevice_args_deviceInfo record  
instance QC.Arbitrary RegisterWapDevice_args where 
  arbitrary = M.liftM RegisterWapDevice_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWapDevice_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWapDevice_args{registerWapDevice_args_invitationHash = registerWapDevice_args_invitationHash obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_invitationHash = registerWapDevice_args_invitationHash obj}
    , if obj == default_RegisterWapDevice_args{registerWapDevice_args_guidHash = registerWapDevice_args_guidHash obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_guidHash = registerWapDevice_args_guidHash obj}
    , if obj == default_RegisterWapDevice_args{registerWapDevice_args_email = registerWapDevice_args_email obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_email = registerWapDevice_args_email obj}
    , if obj == default_RegisterWapDevice_args{registerWapDevice_args_deviceInfo = registerWapDevice_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_deviceInfo = registerWapDevice_args_deviceInfo obj}
    ]
from_RegisterWapDevice_args :: RegisterWapDevice_args -> T.ThriftVal
from_RegisterWapDevice_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5370 -> P.Just (2, ("invitationHash",T.TString $ E.encodeUtf8 _v5370))) $ registerWapDevice_args_invitationHash record
  , (\_v5370 -> P.Just (3, ("guidHash",T.TString $ E.encodeUtf8 _v5370))) $ registerWapDevice_args_guidHash record
  , (\_v5370 -> P.Just (4, ("email",T.TString $ E.encodeUtf8 _v5370))) $ registerWapDevice_args_email record
  , (\_v5370 -> P.Just (5, ("deviceInfo",from_DeviceInfo _v5370))) $ registerWapDevice_args_deviceInfo record
  ]
write_RegisterWapDevice_args :: T.Protocol p => p -> RegisterWapDevice_args -> P.IO ()
write_RegisterWapDevice_args oprot record = T.writeVal oprot $ from_RegisterWapDevice_args record
encode_RegisterWapDevice_args :: T.StatelessProtocol p => p -> RegisterWapDevice_args -> LBS.ByteString
encode_RegisterWapDevice_args oprot record = T.serializeVal oprot $ from_RegisterWapDevice_args record
to_RegisterWapDevice_args :: T.ThriftVal -> RegisterWapDevice_args
to_RegisterWapDevice_args (T.TStruct fields) = RegisterWapDevice_args{
  registerWapDevice_args_invitationHash = P.maybe (registerWapDevice_args_invitationHash default_RegisterWapDevice_args) (\(_,_val5372) -> (case _val5372 of {T.TString _val5373 -> E.decodeUtf8 _val5373; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWapDevice_args_guidHash = P.maybe (registerWapDevice_args_guidHash default_RegisterWapDevice_args) (\(_,_val5372) -> (case _val5372 of {T.TString _val5374 -> E.decodeUtf8 _val5374; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWapDevice_args_email = P.maybe (registerWapDevice_args_email default_RegisterWapDevice_args) (\(_,_val5372) -> (case _val5372 of {T.TString _val5375 -> E.decodeUtf8 _val5375; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWapDevice_args_deviceInfo = P.maybe (registerWapDevice_args_deviceInfo default_RegisterWapDevice_args) (\(_,_val5372) -> (case _val5372 of {T.TStruct _val5376 -> (to_DeviceInfo (T.TStruct _val5376)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RegisterWapDevice_args _ = P.error "not a struct"
read_RegisterWapDevice_args :: T.Protocol p => p -> P.IO RegisterWapDevice_args
read_RegisterWapDevice_args iprot = to_RegisterWapDevice_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWapDevice_args)
decode_RegisterWapDevice_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWapDevice_args
decode_RegisterWapDevice_args iprot bs = to_RegisterWapDevice_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWapDevice_args) bs
typemap_RegisterWapDevice_args :: T.TypeMap
typemap_RegisterWapDevice_args = Map.fromList [(2,("invitationHash",T.T_STRING)),(3,("guidHash",T.T_STRING)),(4,("email",T.T_STRING)),(5,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterWapDevice_args :: RegisterWapDevice_args
default_RegisterWapDevice_args = RegisterWapDevice_args{
  registerWapDevice_args_invitationHash = "",
  registerWapDevice_args_guidHash = "",
  registerWapDevice_args_email = "",
  registerWapDevice_args_deviceInfo = default_DeviceInfo}
data RegisterWapDevice_result = RegisterWapDevice_result  { registerWapDevice_result_success :: LT.Text
  , registerWapDevice_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWapDevice_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWapDevice_result_success record   `H.hashWithSalt` registerWapDevice_result_e record  
instance QC.Arbitrary RegisterWapDevice_result where 
  arbitrary = M.liftM RegisterWapDevice_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWapDevice_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWapDevice_result{registerWapDevice_result_success = registerWapDevice_result_success obj} then P.Nothing else P.Just $ default_RegisterWapDevice_result{registerWapDevice_result_success = registerWapDevice_result_success obj}
    , if obj == default_RegisterWapDevice_result{registerWapDevice_result_e = registerWapDevice_result_e obj} then P.Nothing else P.Just $ default_RegisterWapDevice_result{registerWapDevice_result_e = registerWapDevice_result_e obj}
    ]
from_RegisterWapDevice_result :: RegisterWapDevice_result -> T.ThriftVal
from_RegisterWapDevice_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5379 -> (1, ("e",from_TalkException _v5379))) <$> registerWapDevice_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5379 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5379))) $ registerWapDevice_result_success record
    , (\_v5379 -> (1, ("e",from_TalkException _v5379))) <$> registerWapDevice_result_e record
    ]
    )
write_RegisterWapDevice_result :: T.Protocol p => p -> RegisterWapDevice_result -> P.IO ()
write_RegisterWapDevice_result oprot record = T.writeVal oprot $ from_RegisterWapDevice_result record
encode_RegisterWapDevice_result :: T.StatelessProtocol p => p -> RegisterWapDevice_result -> LBS.ByteString
encode_RegisterWapDevice_result oprot record = T.serializeVal oprot $ from_RegisterWapDevice_result record
to_RegisterWapDevice_result :: T.ThriftVal -> RegisterWapDevice_result
to_RegisterWapDevice_result (T.TStruct fields) = RegisterWapDevice_result{
  registerWapDevice_result_success = P.maybe (registerWapDevice_result_success default_RegisterWapDevice_result) (\(_,_val5381) -> (case _val5381 of {T.TString _val5382 -> E.decodeUtf8 _val5382; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWapDevice_result_e = P.maybe (P.Nothing) (\(_,_val5381) -> P.Just (case _val5381 of {T.TStruct _val5383 -> (to_TalkException (T.TStruct _val5383)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWapDevice_result _ = P.error "not a struct"
read_RegisterWapDevice_result :: T.Protocol p => p -> P.IO RegisterWapDevice_result
read_RegisterWapDevice_result iprot = to_RegisterWapDevice_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWapDevice_result)
decode_RegisterWapDevice_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWapDevice_result
decode_RegisterWapDevice_result iprot bs = to_RegisterWapDevice_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWapDevice_result) bs
typemap_RegisterWapDevice_result :: T.TypeMap
typemap_RegisterWapDevice_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWapDevice_result :: RegisterWapDevice_result
default_RegisterWapDevice_result = RegisterWapDevice_result{
  registerWapDevice_result_success = "",
  registerWapDevice_result_e = P.Nothing}
data RegisterWithExistingSnsIdAndIdentityCredential_args = RegisterWithExistingSnsIdAndIdentityCredential_args  { registerWithExistingSnsIdAndIdentityCredential_args_identityCredential :: IdentityCredential
  , registerWithExistingSnsIdAndIdentityCredential_args_region :: LT.Text
  , registerWithExistingSnsIdAndIdentityCredential_args_udidHash :: LT.Text
  , registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithExistingSnsIdAndIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_identityCredential record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_region record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_udidHash record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo record  
instance QC.Arbitrary RegisterWithExistingSnsIdAndIdentityCredential_args where 
  arbitrary = M.liftM RegisterWithExistingSnsIdAndIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = registerWithExistingSnsIdAndIdentityCredential_args_identityCredential obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = registerWithExistingSnsIdAndIdentityCredential_args_identityCredential obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_region = registerWithExistingSnsIdAndIdentityCredential_args_region obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_region = registerWithExistingSnsIdAndIdentityCredential_args_region obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_udidHash = registerWithExistingSnsIdAndIdentityCredential_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_udidHash = registerWithExistingSnsIdAndIdentityCredential_args_udidHash obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo obj}
    ]
from_RegisterWithExistingSnsIdAndIdentityCredential_args :: RegisterWithExistingSnsIdAndIdentityCredential_args -> T.ThriftVal
from_RegisterWithExistingSnsIdAndIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5386 -> P.Just (2, ("identityCredential",from_IdentityCredential _v5386))) $ registerWithExistingSnsIdAndIdentityCredential_args_identityCredential record
  , (\_v5386 -> P.Just (3, ("region",T.TString $ E.encodeUtf8 _v5386))) $ registerWithExistingSnsIdAndIdentityCredential_args_region record
  , (\_v5386 -> P.Just (4, ("udidHash",T.TString $ E.encodeUtf8 _v5386))) $ registerWithExistingSnsIdAndIdentityCredential_args_udidHash record
  , (\_v5386 -> P.Just (5, ("deviceInfo",from_DeviceInfo _v5386))) $ registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo record
  ]
write_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.Protocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_args -> P.IO ()
write_RegisterWithExistingSnsIdAndIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_args record
encode_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_args -> LBS.ByteString
encode_RegisterWithExistingSnsIdAndIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_args record
to_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.ThriftVal -> RegisterWithExistingSnsIdAndIdentityCredential_args
to_RegisterWithExistingSnsIdAndIdentityCredential_args (T.TStruct fields) = RegisterWithExistingSnsIdAndIdentityCredential_args{
  registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_identityCredential default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val5388) -> (case _val5388 of {T.TStruct _val5389 -> (to_IdentityCredential (T.TStruct _val5389)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithExistingSnsIdAndIdentityCredential_args_region = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_region default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val5388) -> (case _val5388 of {T.TString _val5390 -> E.decodeUtf8 _val5390; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWithExistingSnsIdAndIdentityCredential_args_udidHash = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_udidHash default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val5388) -> (case _val5388 of {T.TString _val5391 -> E.decodeUtf8 _val5391; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val5388) -> (case _val5388 of {T.TStruct _val5392 -> (to_DeviceInfo (T.TStruct _val5392)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RegisterWithExistingSnsIdAndIdentityCredential_args _ = P.error "not a struct"
read_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterWithExistingSnsIdAndIdentityCredential_args
read_RegisterWithExistingSnsIdAndIdentityCredential_args iprot = to_RegisterWithExistingSnsIdAndIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_args)
decode_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithExistingSnsIdAndIdentityCredential_args
decode_RegisterWithExistingSnsIdAndIdentityCredential_args iprot bs = to_RegisterWithExistingSnsIdAndIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_args) bs
typemap_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.TypeMap
typemap_RegisterWithExistingSnsIdAndIdentityCredential_args = Map.fromList [(2,("identityCredential",(T.T_STRUCT typemap_IdentityCredential))),(3,("region",T.T_STRING)),(4,("udidHash",T.T_STRING)),(5,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterWithExistingSnsIdAndIdentityCredential_args :: RegisterWithExistingSnsIdAndIdentityCredential_args
default_RegisterWithExistingSnsIdAndIdentityCredential_args = RegisterWithExistingSnsIdAndIdentityCredential_args{
  registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = default_IdentityCredential,
  registerWithExistingSnsIdAndIdentityCredential_args_region = "",
  registerWithExistingSnsIdAndIdentityCredential_args_udidHash = "",
  registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = default_DeviceInfo}
data RegisterWithExistingSnsIdAndIdentityCredential_result = RegisterWithExistingSnsIdAndIdentityCredential_result  { registerWithExistingSnsIdAndIdentityCredential_result_success :: LT.Text
  , registerWithExistingSnsIdAndIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithExistingSnsIdAndIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_result_success record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_result_e record  
instance QC.Arbitrary RegisterWithExistingSnsIdAndIdentityCredential_result where 
  arbitrary = M.liftM RegisterWithExistingSnsIdAndIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithExistingSnsIdAndIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_success = registerWithExistingSnsIdAndIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_success = registerWithExistingSnsIdAndIdentityCredential_result_success obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_e = registerWithExistingSnsIdAndIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_e = registerWithExistingSnsIdAndIdentityCredential_result_e obj}
    ]
from_RegisterWithExistingSnsIdAndIdentityCredential_result :: RegisterWithExistingSnsIdAndIdentityCredential_result -> T.ThriftVal
from_RegisterWithExistingSnsIdAndIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5395 -> (1, ("e",from_TalkException _v5395))) <$> registerWithExistingSnsIdAndIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5395 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5395))) $ registerWithExistingSnsIdAndIdentityCredential_result_success record
    , (\_v5395 -> (1, ("e",from_TalkException _v5395))) <$> registerWithExistingSnsIdAndIdentityCredential_result_e record
    ]
    )
write_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.Protocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_result -> P.IO ()
write_RegisterWithExistingSnsIdAndIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_result record
encode_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_result -> LBS.ByteString
encode_RegisterWithExistingSnsIdAndIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_result record
to_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.ThriftVal -> RegisterWithExistingSnsIdAndIdentityCredential_result
to_RegisterWithExistingSnsIdAndIdentityCredential_result (T.TStruct fields) = RegisterWithExistingSnsIdAndIdentityCredential_result{
  registerWithExistingSnsIdAndIdentityCredential_result_success = P.maybe (registerWithExistingSnsIdAndIdentityCredential_result_success default_RegisterWithExistingSnsIdAndIdentityCredential_result) (\(_,_val5397) -> (case _val5397 of {T.TString _val5398 -> E.decodeUtf8 _val5398; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithExistingSnsIdAndIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val5397) -> P.Just (case _val5397 of {T.TStruct _val5399 -> (to_TalkException (T.TStruct _val5399)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithExistingSnsIdAndIdentityCredential_result _ = P.error "not a struct"
read_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterWithExistingSnsIdAndIdentityCredential_result
read_RegisterWithExistingSnsIdAndIdentityCredential_result iprot = to_RegisterWithExistingSnsIdAndIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_result)
decode_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithExistingSnsIdAndIdentityCredential_result
decode_RegisterWithExistingSnsIdAndIdentityCredential_result iprot bs = to_RegisterWithExistingSnsIdAndIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_result) bs
typemap_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.TypeMap
typemap_RegisterWithExistingSnsIdAndIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithExistingSnsIdAndIdentityCredential_result :: RegisterWithExistingSnsIdAndIdentityCredential_result
default_RegisterWithExistingSnsIdAndIdentityCredential_result = RegisterWithExistingSnsIdAndIdentityCredential_result{
  registerWithExistingSnsIdAndIdentityCredential_result_success = "",
  registerWithExistingSnsIdAndIdentityCredential_result_e = P.Nothing}
data RegisterWithSnsId_args = RegisterWithSnsId_args  { registerWithSnsId_args_snsIdType :: SnsIdType
  , registerWithSnsId_args_snsAccessToken :: LT.Text
  , registerWithSnsId_args_region :: LT.Text
  , registerWithSnsId_args_udidHash :: LT.Text
  , registerWithSnsId_args_deviceInfo :: DeviceInfo
  , registerWithSnsId_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsId_args_snsIdType record   `H.hashWithSalt` registerWithSnsId_args_snsAccessToken record   `H.hashWithSalt` registerWithSnsId_args_region record   `H.hashWithSalt` registerWithSnsId_args_udidHash record   `H.hashWithSalt` registerWithSnsId_args_deviceInfo record   `H.hashWithSalt` registerWithSnsId_args_mid record  
instance QC.Arbitrary RegisterWithSnsId_args where 
  arbitrary = M.liftM RegisterWithSnsId_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_snsIdType = registerWithSnsId_args_snsIdType obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_snsIdType = registerWithSnsId_args_snsIdType obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_snsAccessToken = registerWithSnsId_args_snsAccessToken obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_snsAccessToken = registerWithSnsId_args_snsAccessToken obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_region = registerWithSnsId_args_region obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_region = registerWithSnsId_args_region obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_udidHash = registerWithSnsId_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_udidHash = registerWithSnsId_args_udidHash obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_deviceInfo = registerWithSnsId_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_deviceInfo = registerWithSnsId_args_deviceInfo obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_mid = registerWithSnsId_args_mid obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_mid = registerWithSnsId_args_mid obj}
    ]
from_RegisterWithSnsId_args :: RegisterWithSnsId_args -> T.ThriftVal
from_RegisterWithSnsId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5402 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v5402))) $ registerWithSnsId_args_snsIdType record
  , (\_v5402 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v5402))) $ registerWithSnsId_args_snsAccessToken record
  , (\_v5402 -> P.Just (4, ("region",T.TString $ E.encodeUtf8 _v5402))) $ registerWithSnsId_args_region record
  , (\_v5402 -> P.Just (5, ("udidHash",T.TString $ E.encodeUtf8 _v5402))) $ registerWithSnsId_args_udidHash record
  , (\_v5402 -> P.Just (6, ("deviceInfo",from_DeviceInfo _v5402))) $ registerWithSnsId_args_deviceInfo record
  , (\_v5402 -> P.Just (7, ("mid",T.TString $ E.encodeUtf8 _v5402))) $ registerWithSnsId_args_mid record
  ]
write_RegisterWithSnsId_args :: T.Protocol p => p -> RegisterWithSnsId_args -> P.IO ()
write_RegisterWithSnsId_args oprot record = T.writeVal oprot $ from_RegisterWithSnsId_args record
encode_RegisterWithSnsId_args :: T.StatelessProtocol p => p -> RegisterWithSnsId_args -> LBS.ByteString
encode_RegisterWithSnsId_args oprot record = T.serializeVal oprot $ from_RegisterWithSnsId_args record
to_RegisterWithSnsId_args :: T.ThriftVal -> RegisterWithSnsId_args
to_RegisterWithSnsId_args (T.TStruct fields) = RegisterWithSnsId_args{
  registerWithSnsId_args_snsIdType = P.maybe (registerWithSnsId_args_snsIdType default_RegisterWithSnsId_args) (\(_,_val5404) -> (case _val5404 of {T.TI32 _val5405 -> P.toEnum $ P.fromIntegral _val5405; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithSnsId_args_snsAccessToken = P.maybe (registerWithSnsId_args_snsAccessToken default_RegisterWithSnsId_args) (\(_,_val5404) -> (case _val5404 of {T.TString _val5406 -> E.decodeUtf8 _val5406; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWithSnsId_args_region = P.maybe (registerWithSnsId_args_region default_RegisterWithSnsId_args) (\(_,_val5404) -> (case _val5404 of {T.TString _val5407 -> E.decodeUtf8 _val5407; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWithSnsId_args_udidHash = P.maybe (registerWithSnsId_args_udidHash default_RegisterWithSnsId_args) (\(_,_val5404) -> (case _val5404 of {T.TString _val5408 -> E.decodeUtf8 _val5408; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerWithSnsId_args_deviceInfo = P.maybe (registerWithSnsId_args_deviceInfo default_RegisterWithSnsId_args) (\(_,_val5404) -> (case _val5404 of {T.TStruct _val5409 -> (to_DeviceInfo (T.TStruct _val5409)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  registerWithSnsId_args_mid = P.maybe (registerWithSnsId_args_mid default_RegisterWithSnsId_args) (\(_,_val5404) -> (case _val5404 of {T.TString _val5410 -> E.decodeUtf8 _val5410; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_RegisterWithSnsId_args _ = P.error "not a struct"
read_RegisterWithSnsId_args :: T.Protocol p => p -> P.IO RegisterWithSnsId_args
read_RegisterWithSnsId_args iprot = to_RegisterWithSnsId_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_args)
decode_RegisterWithSnsId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsId_args
decode_RegisterWithSnsId_args iprot bs = to_RegisterWithSnsId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_args) bs
typemap_RegisterWithSnsId_args :: T.TypeMap
typemap_RegisterWithSnsId_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING)),(4,("region",T.T_STRING)),(5,("udidHash",T.T_STRING)),(6,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(7,("mid",T.T_STRING))]
default_RegisterWithSnsId_args :: RegisterWithSnsId_args
default_RegisterWithSnsId_args = RegisterWithSnsId_args{
  registerWithSnsId_args_snsIdType = (P.toEnum 0),
  registerWithSnsId_args_snsAccessToken = "",
  registerWithSnsId_args_region = "",
  registerWithSnsId_args_udidHash = "",
  registerWithSnsId_args_deviceInfo = default_DeviceInfo,
  registerWithSnsId_args_mid = ""}
data RegisterWithSnsId_result = RegisterWithSnsId_result  { registerWithSnsId_result_success :: RegisterWithSnsIdResult
  , registerWithSnsId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsId_result_success record   `H.hashWithSalt` registerWithSnsId_result_e record  
instance QC.Arbitrary RegisterWithSnsId_result where 
  arbitrary = M.liftM RegisterWithSnsId_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsId_result{registerWithSnsId_result_success = registerWithSnsId_result_success obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_result{registerWithSnsId_result_success = registerWithSnsId_result_success obj}
    , if obj == default_RegisterWithSnsId_result{registerWithSnsId_result_e = registerWithSnsId_result_e obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_result{registerWithSnsId_result_e = registerWithSnsId_result_e obj}
    ]
from_RegisterWithSnsId_result :: RegisterWithSnsId_result -> T.ThriftVal
from_RegisterWithSnsId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5413 -> (1, ("e",from_TalkException _v5413))) <$> registerWithSnsId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5413 -> P.Just (0, ("success",from_RegisterWithSnsIdResult _v5413))) $ registerWithSnsId_result_success record
    , (\_v5413 -> (1, ("e",from_TalkException _v5413))) <$> registerWithSnsId_result_e record
    ]
    )
write_RegisterWithSnsId_result :: T.Protocol p => p -> RegisterWithSnsId_result -> P.IO ()
write_RegisterWithSnsId_result oprot record = T.writeVal oprot $ from_RegisterWithSnsId_result record
encode_RegisterWithSnsId_result :: T.StatelessProtocol p => p -> RegisterWithSnsId_result -> LBS.ByteString
encode_RegisterWithSnsId_result oprot record = T.serializeVal oprot $ from_RegisterWithSnsId_result record
to_RegisterWithSnsId_result :: T.ThriftVal -> RegisterWithSnsId_result
to_RegisterWithSnsId_result (T.TStruct fields) = RegisterWithSnsId_result{
  registerWithSnsId_result_success = P.maybe (registerWithSnsId_result_success default_RegisterWithSnsId_result) (\(_,_val5415) -> (case _val5415 of {T.TStruct _val5416 -> (to_RegisterWithSnsIdResult (T.TStruct _val5416)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithSnsId_result_e = P.maybe (P.Nothing) (\(_,_val5415) -> P.Just (case _val5415 of {T.TStruct _val5417 -> (to_TalkException (T.TStruct _val5417)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithSnsId_result _ = P.error "not a struct"
read_RegisterWithSnsId_result :: T.Protocol p => p -> P.IO RegisterWithSnsId_result
read_RegisterWithSnsId_result iprot = to_RegisterWithSnsId_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_result)
decode_RegisterWithSnsId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsId_result
decode_RegisterWithSnsId_result iprot bs = to_RegisterWithSnsId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_result) bs
typemap_RegisterWithSnsId_result :: T.TypeMap
typemap_RegisterWithSnsId_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RegisterWithSnsIdResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithSnsId_result :: RegisterWithSnsId_result
default_RegisterWithSnsId_result = RegisterWithSnsId_result{
  registerWithSnsId_result_success = default_RegisterWithSnsIdResult,
  registerWithSnsId_result_e = P.Nothing}
data RegisterWithSnsIdAndIdentityCredential_args = RegisterWithSnsIdAndIdentityCredential_args  { registerWithSnsIdAndIdentityCredential_args_snsIdType :: SnsIdType
  , registerWithSnsIdAndIdentityCredential_args_snsAccessToken :: LT.Text
  , registerWithSnsIdAndIdentityCredential_args_identityCredential :: IdentityCredential
  , registerWithSnsIdAndIdentityCredential_args_region :: LT.Text
  , registerWithSnsIdAndIdentityCredential_args_udidHash :: LT.Text
  , registerWithSnsIdAndIdentityCredential_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsIdAndIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_snsIdType record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_snsAccessToken record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_identityCredential record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_region record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_udidHash record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_deviceInfo record  
instance QC.Arbitrary RegisterWithSnsIdAndIdentityCredential_args where 
  arbitrary = M.liftM RegisterWithSnsIdAndIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsIdAndIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsIdType = registerWithSnsIdAndIdentityCredential_args_snsIdType obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsIdType = registerWithSnsIdAndIdentityCredential_args_snsIdType obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsAccessToken = registerWithSnsIdAndIdentityCredential_args_snsAccessToken obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsAccessToken = registerWithSnsIdAndIdentityCredential_args_snsAccessToken obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_identityCredential = registerWithSnsIdAndIdentityCredential_args_identityCredential obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_identityCredential = registerWithSnsIdAndIdentityCredential_args_identityCredential obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_region = registerWithSnsIdAndIdentityCredential_args_region obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_region = registerWithSnsIdAndIdentityCredential_args_region obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_udidHash = registerWithSnsIdAndIdentityCredential_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_udidHash = registerWithSnsIdAndIdentityCredential_args_udidHash obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_deviceInfo = registerWithSnsIdAndIdentityCredential_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_deviceInfo = registerWithSnsIdAndIdentityCredential_args_deviceInfo obj}
    ]
from_RegisterWithSnsIdAndIdentityCredential_args :: RegisterWithSnsIdAndIdentityCredential_args -> T.ThriftVal
from_RegisterWithSnsIdAndIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5420 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v5420))) $ registerWithSnsIdAndIdentityCredential_args_snsIdType record
  , (\_v5420 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v5420))) $ registerWithSnsIdAndIdentityCredential_args_snsAccessToken record
  , (\_v5420 -> P.Just (4, ("identityCredential",from_IdentityCredential _v5420))) $ registerWithSnsIdAndIdentityCredential_args_identityCredential record
  , (\_v5420 -> P.Just (5, ("region",T.TString $ E.encodeUtf8 _v5420))) $ registerWithSnsIdAndIdentityCredential_args_region record
  , (\_v5420 -> P.Just (6, ("udidHash",T.TString $ E.encodeUtf8 _v5420))) $ registerWithSnsIdAndIdentityCredential_args_udidHash record
  , (\_v5420 -> P.Just (7, ("deviceInfo",from_DeviceInfo _v5420))) $ registerWithSnsIdAndIdentityCredential_args_deviceInfo record
  ]
write_RegisterWithSnsIdAndIdentityCredential_args :: T.Protocol p => p -> RegisterWithSnsIdAndIdentityCredential_args -> P.IO ()
write_RegisterWithSnsIdAndIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_args record
encode_RegisterWithSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterWithSnsIdAndIdentityCredential_args -> LBS.ByteString
encode_RegisterWithSnsIdAndIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_args record
to_RegisterWithSnsIdAndIdentityCredential_args :: T.ThriftVal -> RegisterWithSnsIdAndIdentityCredential_args
to_RegisterWithSnsIdAndIdentityCredential_args (T.TStruct fields) = RegisterWithSnsIdAndIdentityCredential_args{
  registerWithSnsIdAndIdentityCredential_args_snsIdType = P.maybe (registerWithSnsIdAndIdentityCredential_args_snsIdType default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val5422) -> (case _val5422 of {T.TI32 _val5423 -> P.toEnum $ P.fromIntegral _val5423; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithSnsIdAndIdentityCredential_args_snsAccessToken = P.maybe (registerWithSnsIdAndIdentityCredential_args_snsAccessToken default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val5422) -> (case _val5422 of {T.TString _val5424 -> E.decodeUtf8 _val5424; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWithSnsIdAndIdentityCredential_args_identityCredential = P.maybe (registerWithSnsIdAndIdentityCredential_args_identityCredential default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val5422) -> (case _val5422 of {T.TStruct _val5425 -> (to_IdentityCredential (T.TStruct _val5425)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWithSnsIdAndIdentityCredential_args_region = P.maybe (registerWithSnsIdAndIdentityCredential_args_region default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val5422) -> (case _val5422 of {T.TString _val5426 -> E.decodeUtf8 _val5426; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerWithSnsIdAndIdentityCredential_args_udidHash = P.maybe (registerWithSnsIdAndIdentityCredential_args_udidHash default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val5422) -> (case _val5422 of {T.TString _val5427 -> E.decodeUtf8 _val5427; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  registerWithSnsIdAndIdentityCredential_args_deviceInfo = P.maybe (registerWithSnsIdAndIdentityCredential_args_deviceInfo default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val5422) -> (case _val5422 of {T.TStruct _val5428 -> (to_DeviceInfo (T.TStruct _val5428)); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_RegisterWithSnsIdAndIdentityCredential_args _ = P.error "not a struct"
read_RegisterWithSnsIdAndIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterWithSnsIdAndIdentityCredential_args
read_RegisterWithSnsIdAndIdentityCredential_args iprot = to_RegisterWithSnsIdAndIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_args)
decode_RegisterWithSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsIdAndIdentityCredential_args
decode_RegisterWithSnsIdAndIdentityCredential_args iprot bs = to_RegisterWithSnsIdAndIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_args) bs
typemap_RegisterWithSnsIdAndIdentityCredential_args :: T.TypeMap
typemap_RegisterWithSnsIdAndIdentityCredential_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING)),(4,("identityCredential",(T.T_STRUCT typemap_IdentityCredential))),(5,("region",T.T_STRING)),(6,("udidHash",T.T_STRING)),(7,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterWithSnsIdAndIdentityCredential_args :: RegisterWithSnsIdAndIdentityCredential_args
default_RegisterWithSnsIdAndIdentityCredential_args = RegisterWithSnsIdAndIdentityCredential_args{
  registerWithSnsIdAndIdentityCredential_args_snsIdType = (P.toEnum 0),
  registerWithSnsIdAndIdentityCredential_args_snsAccessToken = "",
  registerWithSnsIdAndIdentityCredential_args_identityCredential = default_IdentityCredential,
  registerWithSnsIdAndIdentityCredential_args_region = "",
  registerWithSnsIdAndIdentityCredential_args_udidHash = "",
  registerWithSnsIdAndIdentityCredential_args_deviceInfo = default_DeviceInfo}
data RegisterWithSnsIdAndIdentityCredential_result = RegisterWithSnsIdAndIdentityCredential_result  { registerWithSnsIdAndIdentityCredential_result_success :: LT.Text
  , registerWithSnsIdAndIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsIdAndIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_result_success record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_result_e record  
instance QC.Arbitrary RegisterWithSnsIdAndIdentityCredential_result where 
  arbitrary = M.liftM RegisterWithSnsIdAndIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsIdAndIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_success = registerWithSnsIdAndIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_success = registerWithSnsIdAndIdentityCredential_result_success obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_e = registerWithSnsIdAndIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_e = registerWithSnsIdAndIdentityCredential_result_e obj}
    ]
from_RegisterWithSnsIdAndIdentityCredential_result :: RegisterWithSnsIdAndIdentityCredential_result -> T.ThriftVal
from_RegisterWithSnsIdAndIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5431 -> (1, ("e",from_TalkException _v5431))) <$> registerWithSnsIdAndIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5431 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5431))) $ registerWithSnsIdAndIdentityCredential_result_success record
    , (\_v5431 -> (1, ("e",from_TalkException _v5431))) <$> registerWithSnsIdAndIdentityCredential_result_e record
    ]
    )
write_RegisterWithSnsIdAndIdentityCredential_result :: T.Protocol p => p -> RegisterWithSnsIdAndIdentityCredential_result -> P.IO ()
write_RegisterWithSnsIdAndIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_result record
encode_RegisterWithSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterWithSnsIdAndIdentityCredential_result -> LBS.ByteString
encode_RegisterWithSnsIdAndIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_result record
to_RegisterWithSnsIdAndIdentityCredential_result :: T.ThriftVal -> RegisterWithSnsIdAndIdentityCredential_result
to_RegisterWithSnsIdAndIdentityCredential_result (T.TStruct fields) = RegisterWithSnsIdAndIdentityCredential_result{
  registerWithSnsIdAndIdentityCredential_result_success = P.maybe (registerWithSnsIdAndIdentityCredential_result_success default_RegisterWithSnsIdAndIdentityCredential_result) (\(_,_val5433) -> (case _val5433 of {T.TString _val5434 -> E.decodeUtf8 _val5434; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithSnsIdAndIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val5433) -> P.Just (case _val5433 of {T.TStruct _val5435 -> (to_TalkException (T.TStruct _val5435)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithSnsIdAndIdentityCredential_result _ = P.error "not a struct"
read_RegisterWithSnsIdAndIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterWithSnsIdAndIdentityCredential_result
read_RegisterWithSnsIdAndIdentityCredential_result iprot = to_RegisterWithSnsIdAndIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_result)
decode_RegisterWithSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsIdAndIdentityCredential_result
decode_RegisterWithSnsIdAndIdentityCredential_result iprot bs = to_RegisterWithSnsIdAndIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_result) bs
typemap_RegisterWithSnsIdAndIdentityCredential_result :: T.TypeMap
typemap_RegisterWithSnsIdAndIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithSnsIdAndIdentityCredential_result :: RegisterWithSnsIdAndIdentityCredential_result
default_RegisterWithSnsIdAndIdentityCredential_result = RegisterWithSnsIdAndIdentityCredential_result{
  registerWithSnsIdAndIdentityCredential_result_success = "",
  registerWithSnsIdAndIdentityCredential_result_e = P.Nothing}
data ReissueDeviceCredential_args = ReissueDeviceCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueDeviceCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReissueDeviceCredential_args where 
  arbitrary = QC.elements [ReissueDeviceCredential_args]
from_ReissueDeviceCredential_args :: ReissueDeviceCredential_args -> T.ThriftVal
from_ReissueDeviceCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReissueDeviceCredential_args :: T.Protocol p => p -> ReissueDeviceCredential_args -> P.IO ()
write_ReissueDeviceCredential_args oprot record = T.writeVal oprot $ from_ReissueDeviceCredential_args record
encode_ReissueDeviceCredential_args :: T.StatelessProtocol p => p -> ReissueDeviceCredential_args -> LBS.ByteString
encode_ReissueDeviceCredential_args oprot record = T.serializeVal oprot $ from_ReissueDeviceCredential_args record
to_ReissueDeviceCredential_args :: T.ThriftVal -> ReissueDeviceCredential_args
to_ReissueDeviceCredential_args (T.TStruct fields) = ReissueDeviceCredential_args{

  }
to_ReissueDeviceCredential_args _ = P.error "not a struct"
read_ReissueDeviceCredential_args :: T.Protocol p => p -> P.IO ReissueDeviceCredential_args
read_ReissueDeviceCredential_args iprot = to_ReissueDeviceCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_args)
decode_ReissueDeviceCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueDeviceCredential_args
decode_ReissueDeviceCredential_args iprot bs = to_ReissueDeviceCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_args) bs
typemap_ReissueDeviceCredential_args :: T.TypeMap
typemap_ReissueDeviceCredential_args = Map.fromList []
default_ReissueDeviceCredential_args :: ReissueDeviceCredential_args
default_ReissueDeviceCredential_args = ReissueDeviceCredential_args{
}
data ReissueDeviceCredential_result = ReissueDeviceCredential_result  { reissueDeviceCredential_result_success :: LT.Text
  , reissueDeviceCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueDeviceCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueDeviceCredential_result_success record   `H.hashWithSalt` reissueDeviceCredential_result_e record  
instance QC.Arbitrary ReissueDeviceCredential_result where 
  arbitrary = M.liftM ReissueDeviceCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReissueDeviceCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueDeviceCredential_result{reissueDeviceCredential_result_success = reissueDeviceCredential_result_success obj} then P.Nothing else P.Just $ default_ReissueDeviceCredential_result{reissueDeviceCredential_result_success = reissueDeviceCredential_result_success obj}
    , if obj == default_ReissueDeviceCredential_result{reissueDeviceCredential_result_e = reissueDeviceCredential_result_e obj} then P.Nothing else P.Just $ default_ReissueDeviceCredential_result{reissueDeviceCredential_result_e = reissueDeviceCredential_result_e obj}
    ]
from_ReissueDeviceCredential_result :: ReissueDeviceCredential_result -> T.ThriftVal
from_ReissueDeviceCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5443 -> (1, ("e",from_TalkException _v5443))) <$> reissueDeviceCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5443 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5443))) $ reissueDeviceCredential_result_success record
    , (\_v5443 -> (1, ("e",from_TalkException _v5443))) <$> reissueDeviceCredential_result_e record
    ]
    )
write_ReissueDeviceCredential_result :: T.Protocol p => p -> ReissueDeviceCredential_result -> P.IO ()
write_ReissueDeviceCredential_result oprot record = T.writeVal oprot $ from_ReissueDeviceCredential_result record
encode_ReissueDeviceCredential_result :: T.StatelessProtocol p => p -> ReissueDeviceCredential_result -> LBS.ByteString
encode_ReissueDeviceCredential_result oprot record = T.serializeVal oprot $ from_ReissueDeviceCredential_result record
to_ReissueDeviceCredential_result :: T.ThriftVal -> ReissueDeviceCredential_result
to_ReissueDeviceCredential_result (T.TStruct fields) = ReissueDeviceCredential_result{
  reissueDeviceCredential_result_success = P.maybe (reissueDeviceCredential_result_success default_ReissueDeviceCredential_result) (\(_,_val5445) -> (case _val5445 of {T.TString _val5446 -> E.decodeUtf8 _val5446; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reissueDeviceCredential_result_e = P.maybe (P.Nothing) (\(_,_val5445) -> P.Just (case _val5445 of {T.TStruct _val5447 -> (to_TalkException (T.TStruct _val5447)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReissueDeviceCredential_result _ = P.error "not a struct"
read_ReissueDeviceCredential_result :: T.Protocol p => p -> P.IO ReissueDeviceCredential_result
read_ReissueDeviceCredential_result iprot = to_ReissueDeviceCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_result)
decode_ReissueDeviceCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueDeviceCredential_result
decode_ReissueDeviceCredential_result iprot bs = to_ReissueDeviceCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_result) bs
typemap_ReissueDeviceCredential_result :: T.TypeMap
typemap_ReissueDeviceCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReissueDeviceCredential_result :: ReissueDeviceCredential_result
default_ReissueDeviceCredential_result = ReissueDeviceCredential_result{
  reissueDeviceCredential_result_success = "",
  reissueDeviceCredential_result_e = P.Nothing}
data ReissueUserTicket_args = ReissueUserTicket_args  { reissueUserTicket_args_expirationTime :: I.Int64
  , reissueUserTicket_args_maxUseCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueUserTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueUserTicket_args_expirationTime record   `H.hashWithSalt` reissueUserTicket_args_maxUseCount record  
instance QC.Arbitrary ReissueUserTicket_args where 
  arbitrary = M.liftM ReissueUserTicket_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReissueUserTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueUserTicket_args{reissueUserTicket_args_expirationTime = reissueUserTicket_args_expirationTime obj} then P.Nothing else P.Just $ default_ReissueUserTicket_args{reissueUserTicket_args_expirationTime = reissueUserTicket_args_expirationTime obj}
    , if obj == default_ReissueUserTicket_args{reissueUserTicket_args_maxUseCount = reissueUserTicket_args_maxUseCount obj} then P.Nothing else P.Just $ default_ReissueUserTicket_args{reissueUserTicket_args_maxUseCount = reissueUserTicket_args_maxUseCount obj}
    ]
from_ReissueUserTicket_args :: ReissueUserTicket_args -> T.ThriftVal
from_ReissueUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5450 -> P.Just (3, ("expirationTime",T.TI64 _v5450))) $ reissueUserTicket_args_expirationTime record
  , (\_v5450 -> P.Just (4, ("maxUseCount",T.TI32 _v5450))) $ reissueUserTicket_args_maxUseCount record
  ]
write_ReissueUserTicket_args :: T.Protocol p => p -> ReissueUserTicket_args -> P.IO ()
write_ReissueUserTicket_args oprot record = T.writeVal oprot $ from_ReissueUserTicket_args record
encode_ReissueUserTicket_args :: T.StatelessProtocol p => p -> ReissueUserTicket_args -> LBS.ByteString
encode_ReissueUserTicket_args oprot record = T.serializeVal oprot $ from_ReissueUserTicket_args record
to_ReissueUserTicket_args :: T.ThriftVal -> ReissueUserTicket_args
to_ReissueUserTicket_args (T.TStruct fields) = ReissueUserTicket_args{
  reissueUserTicket_args_expirationTime = P.maybe (reissueUserTicket_args_expirationTime default_ReissueUserTicket_args) (\(_,_val5452) -> (case _val5452 of {T.TI64 _val5453 -> _val5453; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reissueUserTicket_args_maxUseCount = P.maybe (reissueUserTicket_args_maxUseCount default_ReissueUserTicket_args) (\(_,_val5452) -> (case _val5452 of {T.TI32 _val5454 -> _val5454; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ReissueUserTicket_args _ = P.error "not a struct"
read_ReissueUserTicket_args :: T.Protocol p => p -> P.IO ReissueUserTicket_args
read_ReissueUserTicket_args iprot = to_ReissueUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_ReissueUserTicket_args)
decode_ReissueUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueUserTicket_args
decode_ReissueUserTicket_args iprot bs = to_ReissueUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueUserTicket_args) bs
typemap_ReissueUserTicket_args :: T.TypeMap
typemap_ReissueUserTicket_args = Map.fromList [(3,("expirationTime",T.T_I64)),(4,("maxUseCount",T.T_I32))]
default_ReissueUserTicket_args :: ReissueUserTicket_args
default_ReissueUserTicket_args = ReissueUserTicket_args{
  reissueUserTicket_args_expirationTime = 0,
  reissueUserTicket_args_maxUseCount = 0}
data ReissueUserTicket_result = ReissueUserTicket_result  { reissueUserTicket_result_success :: LT.Text
  , reissueUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueUserTicket_result_success record   `H.hashWithSalt` reissueUserTicket_result_e record  
instance QC.Arbitrary ReissueUserTicket_result where 
  arbitrary = M.liftM ReissueUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReissueUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueUserTicket_result{reissueUserTicket_result_success = reissueUserTicket_result_success obj} then P.Nothing else P.Just $ default_ReissueUserTicket_result{reissueUserTicket_result_success = reissueUserTicket_result_success obj}
    , if obj == default_ReissueUserTicket_result{reissueUserTicket_result_e = reissueUserTicket_result_e obj} then P.Nothing else P.Just $ default_ReissueUserTicket_result{reissueUserTicket_result_e = reissueUserTicket_result_e obj}
    ]
from_ReissueUserTicket_result :: ReissueUserTicket_result -> T.ThriftVal
from_ReissueUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5457 -> (1, ("e",from_TalkException _v5457))) <$> reissueUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5457 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5457))) $ reissueUserTicket_result_success record
    , (\_v5457 -> (1, ("e",from_TalkException _v5457))) <$> reissueUserTicket_result_e record
    ]
    )
write_ReissueUserTicket_result :: T.Protocol p => p -> ReissueUserTicket_result -> P.IO ()
write_ReissueUserTicket_result oprot record = T.writeVal oprot $ from_ReissueUserTicket_result record
encode_ReissueUserTicket_result :: T.StatelessProtocol p => p -> ReissueUserTicket_result -> LBS.ByteString
encode_ReissueUserTicket_result oprot record = T.serializeVal oprot $ from_ReissueUserTicket_result record
to_ReissueUserTicket_result :: T.ThriftVal -> ReissueUserTicket_result
to_ReissueUserTicket_result (T.TStruct fields) = ReissueUserTicket_result{
  reissueUserTicket_result_success = P.maybe (reissueUserTicket_result_success default_ReissueUserTicket_result) (\(_,_val5459) -> (case _val5459 of {T.TString _val5460 -> E.decodeUtf8 _val5460; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reissueUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val5459) -> P.Just (case _val5459 of {T.TStruct _val5461 -> (to_TalkException (T.TStruct _val5461)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReissueUserTicket_result _ = P.error "not a struct"
read_ReissueUserTicket_result :: T.Protocol p => p -> P.IO ReissueUserTicket_result
read_ReissueUserTicket_result iprot = to_ReissueUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_ReissueUserTicket_result)
decode_ReissueUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueUserTicket_result
decode_ReissueUserTicket_result iprot bs = to_ReissueUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueUserTicket_result) bs
typemap_ReissueUserTicket_result :: T.TypeMap
typemap_ReissueUserTicket_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReissueUserTicket_result :: ReissueUserTicket_result
default_ReissueUserTicket_result = ReissueUserTicket_result{
  reissueUserTicket_result_success = "",
  reissueUserTicket_result_e = P.Nothing}
data RejectGroupInvitation_args = RejectGroupInvitation_args  { rejectGroupInvitation_args_reqSeq :: I.Int32
  , rejectGroupInvitation_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectGroupInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectGroupInvitation_args_reqSeq record   `H.hashWithSalt` rejectGroupInvitation_args_groupId record  
instance QC.Arbitrary RejectGroupInvitation_args where 
  arbitrary = M.liftM RejectGroupInvitation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RejectGroupInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectGroupInvitation_args{rejectGroupInvitation_args_reqSeq = rejectGroupInvitation_args_reqSeq obj} then P.Nothing else P.Just $ default_RejectGroupInvitation_args{rejectGroupInvitation_args_reqSeq = rejectGroupInvitation_args_reqSeq obj}
    , if obj == default_RejectGroupInvitation_args{rejectGroupInvitation_args_groupId = rejectGroupInvitation_args_groupId obj} then P.Nothing else P.Just $ default_RejectGroupInvitation_args{rejectGroupInvitation_args_groupId = rejectGroupInvitation_args_groupId obj}
    ]
from_RejectGroupInvitation_args :: RejectGroupInvitation_args -> T.ThriftVal
from_RejectGroupInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5464 -> P.Just (1, ("reqSeq",T.TI32 _v5464))) $ rejectGroupInvitation_args_reqSeq record
  , (\_v5464 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v5464))) $ rejectGroupInvitation_args_groupId record
  ]
write_RejectGroupInvitation_args :: T.Protocol p => p -> RejectGroupInvitation_args -> P.IO ()
write_RejectGroupInvitation_args oprot record = T.writeVal oprot $ from_RejectGroupInvitation_args record
encode_RejectGroupInvitation_args :: T.StatelessProtocol p => p -> RejectGroupInvitation_args -> LBS.ByteString
encode_RejectGroupInvitation_args oprot record = T.serializeVal oprot $ from_RejectGroupInvitation_args record
to_RejectGroupInvitation_args :: T.ThriftVal -> RejectGroupInvitation_args
to_RejectGroupInvitation_args (T.TStruct fields) = RejectGroupInvitation_args{
  rejectGroupInvitation_args_reqSeq = P.maybe (rejectGroupInvitation_args_reqSeq default_RejectGroupInvitation_args) (\(_,_val5466) -> (case _val5466 of {T.TI32 _val5467 -> _val5467; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rejectGroupInvitation_args_groupId = P.maybe (rejectGroupInvitation_args_groupId default_RejectGroupInvitation_args) (\(_,_val5466) -> (case _val5466 of {T.TString _val5468 -> E.decodeUtf8 _val5468; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RejectGroupInvitation_args _ = P.error "not a struct"
read_RejectGroupInvitation_args :: T.Protocol p => p -> P.IO RejectGroupInvitation_args
read_RejectGroupInvitation_args iprot = to_RejectGroupInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_args)
decode_RejectGroupInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectGroupInvitation_args
decode_RejectGroupInvitation_args iprot bs = to_RejectGroupInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_args) bs
typemap_RejectGroupInvitation_args :: T.TypeMap
typemap_RejectGroupInvitation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING))]
default_RejectGroupInvitation_args :: RejectGroupInvitation_args
default_RejectGroupInvitation_args = RejectGroupInvitation_args{
  rejectGroupInvitation_args_reqSeq = 0,
  rejectGroupInvitation_args_groupId = ""}
data RejectGroupInvitation_result = RejectGroupInvitation_result  { rejectGroupInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectGroupInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectGroupInvitation_result_e record  
instance QC.Arbitrary RejectGroupInvitation_result where 
  arbitrary = M.liftM RejectGroupInvitation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RejectGroupInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectGroupInvitation_result{rejectGroupInvitation_result_e = rejectGroupInvitation_result_e obj} then P.Nothing else P.Just $ default_RejectGroupInvitation_result{rejectGroupInvitation_result_e = rejectGroupInvitation_result_e obj}
    ]
from_RejectGroupInvitation_result :: RejectGroupInvitation_result -> T.ThriftVal
from_RejectGroupInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5471 -> (1, ("e",from_TalkException _v5471))) <$> rejectGroupInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5471 -> (1, ("e",from_TalkException _v5471))) <$> rejectGroupInvitation_result_e record
    ]
    )
write_RejectGroupInvitation_result :: T.Protocol p => p -> RejectGroupInvitation_result -> P.IO ()
write_RejectGroupInvitation_result oprot record = T.writeVal oprot $ from_RejectGroupInvitation_result record
encode_RejectGroupInvitation_result :: T.StatelessProtocol p => p -> RejectGroupInvitation_result -> LBS.ByteString
encode_RejectGroupInvitation_result oprot record = T.serializeVal oprot $ from_RejectGroupInvitation_result record
to_RejectGroupInvitation_result :: T.ThriftVal -> RejectGroupInvitation_result
to_RejectGroupInvitation_result (T.TStruct fields) = RejectGroupInvitation_result{
  rejectGroupInvitation_result_e = P.maybe (P.Nothing) (\(_,_val5473) -> P.Just (case _val5473 of {T.TStruct _val5474 -> (to_TalkException (T.TStruct _val5474)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RejectGroupInvitation_result _ = P.error "not a struct"
read_RejectGroupInvitation_result :: T.Protocol p => p -> P.IO RejectGroupInvitation_result
read_RejectGroupInvitation_result iprot = to_RejectGroupInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_result)
decode_RejectGroupInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectGroupInvitation_result
decode_RejectGroupInvitation_result iprot bs = to_RejectGroupInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_result) bs
typemap_RejectGroupInvitation_result :: T.TypeMap
typemap_RejectGroupInvitation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RejectGroupInvitation_result :: RejectGroupInvitation_result
default_RejectGroupInvitation_result = RejectGroupInvitation_result{
  rejectGroupInvitation_result_e = P.Nothing}
data ReleaseSession_args = ReleaseSession_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReleaseSession_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReleaseSession_args where 
  arbitrary = QC.elements [ReleaseSession_args]
from_ReleaseSession_args :: ReleaseSession_args -> T.ThriftVal
from_ReleaseSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReleaseSession_args :: T.Protocol p => p -> ReleaseSession_args -> P.IO ()
write_ReleaseSession_args oprot record = T.writeVal oprot $ from_ReleaseSession_args record
encode_ReleaseSession_args :: T.StatelessProtocol p => p -> ReleaseSession_args -> LBS.ByteString
encode_ReleaseSession_args oprot record = T.serializeVal oprot $ from_ReleaseSession_args record
to_ReleaseSession_args :: T.ThriftVal -> ReleaseSession_args
to_ReleaseSession_args (T.TStruct fields) = ReleaseSession_args{

  }
to_ReleaseSession_args _ = P.error "not a struct"
read_ReleaseSession_args :: T.Protocol p => p -> P.IO ReleaseSession_args
read_ReleaseSession_args iprot = to_ReleaseSession_args <$> T.readVal iprot (T.T_STRUCT typemap_ReleaseSession_args)
decode_ReleaseSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReleaseSession_args
decode_ReleaseSession_args iprot bs = to_ReleaseSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReleaseSession_args) bs
typemap_ReleaseSession_args :: T.TypeMap
typemap_ReleaseSession_args = Map.fromList []
default_ReleaseSession_args :: ReleaseSession_args
default_ReleaseSession_args = ReleaseSession_args{
}
data ReleaseSession_result = ReleaseSession_result  { releaseSession_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReleaseSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` releaseSession_result_e record  
instance QC.Arbitrary ReleaseSession_result where 
  arbitrary = M.liftM ReleaseSession_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReleaseSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReleaseSession_result{releaseSession_result_e = releaseSession_result_e obj} then P.Nothing else P.Just $ default_ReleaseSession_result{releaseSession_result_e = releaseSession_result_e obj}
    ]
from_ReleaseSession_result :: ReleaseSession_result -> T.ThriftVal
from_ReleaseSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5482 -> (1, ("e",from_TalkException _v5482))) <$> releaseSession_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5482 -> (1, ("e",from_TalkException _v5482))) <$> releaseSession_result_e record
    ]
    )
write_ReleaseSession_result :: T.Protocol p => p -> ReleaseSession_result -> P.IO ()
write_ReleaseSession_result oprot record = T.writeVal oprot $ from_ReleaseSession_result record
encode_ReleaseSession_result :: T.StatelessProtocol p => p -> ReleaseSession_result -> LBS.ByteString
encode_ReleaseSession_result oprot record = T.serializeVal oprot $ from_ReleaseSession_result record
to_ReleaseSession_result :: T.ThriftVal -> ReleaseSession_result
to_ReleaseSession_result (T.TStruct fields) = ReleaseSession_result{
  releaseSession_result_e = P.maybe (P.Nothing) (\(_,_val5484) -> P.Just (case _val5484 of {T.TStruct _val5485 -> (to_TalkException (T.TStruct _val5485)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReleaseSession_result _ = P.error "not a struct"
read_ReleaseSession_result :: T.Protocol p => p -> P.IO ReleaseSession_result
read_ReleaseSession_result iprot = to_ReleaseSession_result <$> T.readVal iprot (T.T_STRUCT typemap_ReleaseSession_result)
decode_ReleaseSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReleaseSession_result
decode_ReleaseSession_result iprot bs = to_ReleaseSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReleaseSession_result) bs
typemap_ReleaseSession_result :: T.TypeMap
typemap_ReleaseSession_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReleaseSession_result :: ReleaseSession_result
default_ReleaseSession_result = ReleaseSession_result{
  releaseSession_result_e = P.Nothing}
data RemoveAllMessages_args = RemoveAllMessages_args  { removeAllMessages_args_seq :: I.Int32
  , removeAllMessages_args_lastMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveAllMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeAllMessages_args_seq record   `H.hashWithSalt` removeAllMessages_args_lastMessageId record  
instance QC.Arbitrary RemoveAllMessages_args where 
  arbitrary = M.liftM RemoveAllMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RemoveAllMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveAllMessages_args{removeAllMessages_args_seq = removeAllMessages_args_seq obj} then P.Nothing else P.Just $ default_RemoveAllMessages_args{removeAllMessages_args_seq = removeAllMessages_args_seq obj}
    , if obj == default_RemoveAllMessages_args{removeAllMessages_args_lastMessageId = removeAllMessages_args_lastMessageId obj} then P.Nothing else P.Just $ default_RemoveAllMessages_args{removeAllMessages_args_lastMessageId = removeAllMessages_args_lastMessageId obj}
    ]
from_RemoveAllMessages_args :: RemoveAllMessages_args -> T.ThriftVal
from_RemoveAllMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5488 -> P.Just (1, ("seq",T.TI32 _v5488))) $ removeAllMessages_args_seq record
  , (\_v5488 -> P.Just (2, ("lastMessageId",T.TString $ E.encodeUtf8 _v5488))) $ removeAllMessages_args_lastMessageId record
  ]
write_RemoveAllMessages_args :: T.Protocol p => p -> RemoveAllMessages_args -> P.IO ()
write_RemoveAllMessages_args oprot record = T.writeVal oprot $ from_RemoveAllMessages_args record
encode_RemoveAllMessages_args :: T.StatelessProtocol p => p -> RemoveAllMessages_args -> LBS.ByteString
encode_RemoveAllMessages_args oprot record = T.serializeVal oprot $ from_RemoveAllMessages_args record
to_RemoveAllMessages_args :: T.ThriftVal -> RemoveAllMessages_args
to_RemoveAllMessages_args (T.TStruct fields) = RemoveAllMessages_args{
  removeAllMessages_args_seq = P.maybe (removeAllMessages_args_seq default_RemoveAllMessages_args) (\(_,_val5490) -> (case _val5490 of {T.TI32 _val5491 -> _val5491; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  removeAllMessages_args_lastMessageId = P.maybe (removeAllMessages_args_lastMessageId default_RemoveAllMessages_args) (\(_,_val5490) -> (case _val5490 of {T.TString _val5492 -> E.decodeUtf8 _val5492; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveAllMessages_args _ = P.error "not a struct"
read_RemoveAllMessages_args :: T.Protocol p => p -> P.IO RemoveAllMessages_args
read_RemoveAllMessages_args iprot = to_RemoveAllMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveAllMessages_args)
decode_RemoveAllMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveAllMessages_args
decode_RemoveAllMessages_args iprot bs = to_RemoveAllMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveAllMessages_args) bs
typemap_RemoveAllMessages_args :: T.TypeMap
typemap_RemoveAllMessages_args = Map.fromList [(1,("seq",T.T_I32)),(2,("lastMessageId",T.T_STRING))]
default_RemoveAllMessages_args :: RemoveAllMessages_args
default_RemoveAllMessages_args = RemoveAllMessages_args{
  removeAllMessages_args_seq = 0,
  removeAllMessages_args_lastMessageId = ""}
data RemoveAllMessages_result = RemoveAllMessages_result  { removeAllMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveAllMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeAllMessages_result_e record  
instance QC.Arbitrary RemoveAllMessages_result where 
  arbitrary = M.liftM RemoveAllMessages_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveAllMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveAllMessages_result{removeAllMessages_result_e = removeAllMessages_result_e obj} then P.Nothing else P.Just $ default_RemoveAllMessages_result{removeAllMessages_result_e = removeAllMessages_result_e obj}
    ]
from_RemoveAllMessages_result :: RemoveAllMessages_result -> T.ThriftVal
from_RemoveAllMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5495 -> (1, ("e",from_TalkException _v5495))) <$> removeAllMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5495 -> (1, ("e",from_TalkException _v5495))) <$> removeAllMessages_result_e record
    ]
    )
write_RemoveAllMessages_result :: T.Protocol p => p -> RemoveAllMessages_result -> P.IO ()
write_RemoveAllMessages_result oprot record = T.writeVal oprot $ from_RemoveAllMessages_result record
encode_RemoveAllMessages_result :: T.StatelessProtocol p => p -> RemoveAllMessages_result -> LBS.ByteString
encode_RemoveAllMessages_result oprot record = T.serializeVal oprot $ from_RemoveAllMessages_result record
to_RemoveAllMessages_result :: T.ThriftVal -> RemoveAllMessages_result
to_RemoveAllMessages_result (T.TStruct fields) = RemoveAllMessages_result{
  removeAllMessages_result_e = P.maybe (P.Nothing) (\(_,_val5497) -> P.Just (case _val5497 of {T.TStruct _val5498 -> (to_TalkException (T.TStruct _val5498)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveAllMessages_result _ = P.error "not a struct"
read_RemoveAllMessages_result :: T.Protocol p => p -> P.IO RemoveAllMessages_result
read_RemoveAllMessages_result iprot = to_RemoveAllMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveAllMessages_result)
decode_RemoveAllMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveAllMessages_result
decode_RemoveAllMessages_result iprot bs = to_RemoveAllMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveAllMessages_result) bs
typemap_RemoveAllMessages_result :: T.TypeMap
typemap_RemoveAllMessages_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveAllMessages_result :: RemoveAllMessages_result
default_RemoveAllMessages_result = RemoveAllMessages_result{
  removeAllMessages_result_e = P.Nothing}
data RemoveBuddyLocation_args = RemoveBuddyLocation_args  { removeBuddyLocation_args_mid :: LT.Text
  , removeBuddyLocation_args_index :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveBuddyLocation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeBuddyLocation_args_mid record   `H.hashWithSalt` removeBuddyLocation_args_index record  
instance QC.Arbitrary RemoveBuddyLocation_args where 
  arbitrary = M.liftM RemoveBuddyLocation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RemoveBuddyLocation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveBuddyLocation_args{removeBuddyLocation_args_mid = removeBuddyLocation_args_mid obj} then P.Nothing else P.Just $ default_RemoveBuddyLocation_args{removeBuddyLocation_args_mid = removeBuddyLocation_args_mid obj}
    , if obj == default_RemoveBuddyLocation_args{removeBuddyLocation_args_index = removeBuddyLocation_args_index obj} then P.Nothing else P.Just $ default_RemoveBuddyLocation_args{removeBuddyLocation_args_index = removeBuddyLocation_args_index obj}
    ]
from_RemoveBuddyLocation_args :: RemoveBuddyLocation_args -> T.ThriftVal
from_RemoveBuddyLocation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5501 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v5501))) $ removeBuddyLocation_args_mid record
  , (\_v5501 -> P.Just (3, ("index",T.TI32 _v5501))) $ removeBuddyLocation_args_index record
  ]
write_RemoveBuddyLocation_args :: T.Protocol p => p -> RemoveBuddyLocation_args -> P.IO ()
write_RemoveBuddyLocation_args oprot record = T.writeVal oprot $ from_RemoveBuddyLocation_args record
encode_RemoveBuddyLocation_args :: T.StatelessProtocol p => p -> RemoveBuddyLocation_args -> LBS.ByteString
encode_RemoveBuddyLocation_args oprot record = T.serializeVal oprot $ from_RemoveBuddyLocation_args record
to_RemoveBuddyLocation_args :: T.ThriftVal -> RemoveBuddyLocation_args
to_RemoveBuddyLocation_args (T.TStruct fields) = RemoveBuddyLocation_args{
  removeBuddyLocation_args_mid = P.maybe (removeBuddyLocation_args_mid default_RemoveBuddyLocation_args) (\(_,_val5503) -> (case _val5503 of {T.TString _val5504 -> E.decodeUtf8 _val5504; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  removeBuddyLocation_args_index = P.maybe (removeBuddyLocation_args_index default_RemoveBuddyLocation_args) (\(_,_val5503) -> (case _val5503 of {T.TI32 _val5505 -> _val5505; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RemoveBuddyLocation_args _ = P.error "not a struct"
read_RemoveBuddyLocation_args :: T.Protocol p => p -> P.IO RemoveBuddyLocation_args
read_RemoveBuddyLocation_args iprot = to_RemoveBuddyLocation_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_args)
decode_RemoveBuddyLocation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveBuddyLocation_args
decode_RemoveBuddyLocation_args iprot bs = to_RemoveBuddyLocation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_args) bs
typemap_RemoveBuddyLocation_args :: T.TypeMap
typemap_RemoveBuddyLocation_args = Map.fromList [(2,("mid",T.T_STRING)),(3,("index",T.T_I32))]
default_RemoveBuddyLocation_args :: RemoveBuddyLocation_args
default_RemoveBuddyLocation_args = RemoveBuddyLocation_args{
  removeBuddyLocation_args_mid = "",
  removeBuddyLocation_args_index = 0}
data RemoveBuddyLocation_result = RemoveBuddyLocation_result  { removeBuddyLocation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveBuddyLocation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeBuddyLocation_result_e record  
instance QC.Arbitrary RemoveBuddyLocation_result where 
  arbitrary = M.liftM RemoveBuddyLocation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveBuddyLocation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveBuddyLocation_result{removeBuddyLocation_result_e = removeBuddyLocation_result_e obj} then P.Nothing else P.Just $ default_RemoveBuddyLocation_result{removeBuddyLocation_result_e = removeBuddyLocation_result_e obj}
    ]
from_RemoveBuddyLocation_result :: RemoveBuddyLocation_result -> T.ThriftVal
from_RemoveBuddyLocation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5508 -> (1, ("e",from_TalkException _v5508))) <$> removeBuddyLocation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5508 -> (1, ("e",from_TalkException _v5508))) <$> removeBuddyLocation_result_e record
    ]
    )
write_RemoveBuddyLocation_result :: T.Protocol p => p -> RemoveBuddyLocation_result -> P.IO ()
write_RemoveBuddyLocation_result oprot record = T.writeVal oprot $ from_RemoveBuddyLocation_result record
encode_RemoveBuddyLocation_result :: T.StatelessProtocol p => p -> RemoveBuddyLocation_result -> LBS.ByteString
encode_RemoveBuddyLocation_result oprot record = T.serializeVal oprot $ from_RemoveBuddyLocation_result record
to_RemoveBuddyLocation_result :: T.ThriftVal -> RemoveBuddyLocation_result
to_RemoveBuddyLocation_result (T.TStruct fields) = RemoveBuddyLocation_result{
  removeBuddyLocation_result_e = P.maybe (P.Nothing) (\(_,_val5510) -> P.Just (case _val5510 of {T.TStruct _val5511 -> (to_TalkException (T.TStruct _val5511)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveBuddyLocation_result _ = P.error "not a struct"
read_RemoveBuddyLocation_result :: T.Protocol p => p -> P.IO RemoveBuddyLocation_result
read_RemoveBuddyLocation_result iprot = to_RemoveBuddyLocation_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_result)
decode_RemoveBuddyLocation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveBuddyLocation_result
decode_RemoveBuddyLocation_result iprot bs = to_RemoveBuddyLocation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_result) bs
typemap_RemoveBuddyLocation_result :: T.TypeMap
typemap_RemoveBuddyLocation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveBuddyLocation_result :: RemoveBuddyLocation_result
default_RemoveBuddyLocation_result = RemoveBuddyLocation_result{
  removeBuddyLocation_result_e = P.Nothing}
data RemoveMessage_args = RemoveMessage_args  { removeMessage_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessage_args_messageId record  
instance QC.Arbitrary RemoveMessage_args where 
  arbitrary = M.liftM RemoveMessage_args (QC.arbitrary)
  shrink obj | obj == default_RemoveMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessage_args{removeMessage_args_messageId = removeMessage_args_messageId obj} then P.Nothing else P.Just $ default_RemoveMessage_args{removeMessage_args_messageId = removeMessage_args_messageId obj}
    ]
from_RemoveMessage_args :: RemoveMessage_args -> T.ThriftVal
from_RemoveMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5514 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v5514))) $ removeMessage_args_messageId record
  ]
write_RemoveMessage_args :: T.Protocol p => p -> RemoveMessage_args -> P.IO ()
write_RemoveMessage_args oprot record = T.writeVal oprot $ from_RemoveMessage_args record
encode_RemoveMessage_args :: T.StatelessProtocol p => p -> RemoveMessage_args -> LBS.ByteString
encode_RemoveMessage_args oprot record = T.serializeVal oprot $ from_RemoveMessage_args record
to_RemoveMessage_args :: T.ThriftVal -> RemoveMessage_args
to_RemoveMessage_args (T.TStruct fields) = RemoveMessage_args{
  removeMessage_args_messageId = P.maybe (removeMessage_args_messageId default_RemoveMessage_args) (\(_,_val5516) -> (case _val5516 of {T.TString _val5517 -> E.decodeUtf8 _val5517; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveMessage_args _ = P.error "not a struct"
read_RemoveMessage_args :: T.Protocol p => p -> P.IO RemoveMessage_args
read_RemoveMessage_args iprot = to_RemoveMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessage_args)
decode_RemoveMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessage_args
decode_RemoveMessage_args iprot bs = to_RemoveMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessage_args) bs
typemap_RemoveMessage_args :: T.TypeMap
typemap_RemoveMessage_args = Map.fromList [(2,("messageId",T.T_STRING))]
default_RemoveMessage_args :: RemoveMessage_args
default_RemoveMessage_args = RemoveMessage_args{
  removeMessage_args_messageId = ""}
data RemoveMessage_result = RemoveMessage_result  { removeMessage_result_success :: P.Bool
  , removeMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessage_result_success record   `H.hashWithSalt` removeMessage_result_e record  
instance QC.Arbitrary RemoveMessage_result where 
  arbitrary = M.liftM RemoveMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessage_result{removeMessage_result_success = removeMessage_result_success obj} then P.Nothing else P.Just $ default_RemoveMessage_result{removeMessage_result_success = removeMessage_result_success obj}
    , if obj == default_RemoveMessage_result{removeMessage_result_e = removeMessage_result_e obj} then P.Nothing else P.Just $ default_RemoveMessage_result{removeMessage_result_e = removeMessage_result_e obj}
    ]
from_RemoveMessage_result :: RemoveMessage_result -> T.ThriftVal
from_RemoveMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5520 -> (1, ("e",from_TalkException _v5520))) <$> removeMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5520 -> P.Just (0, ("success",T.TBool _v5520))) $ removeMessage_result_success record
    , (\_v5520 -> (1, ("e",from_TalkException _v5520))) <$> removeMessage_result_e record
    ]
    )
write_RemoveMessage_result :: T.Protocol p => p -> RemoveMessage_result -> P.IO ()
write_RemoveMessage_result oprot record = T.writeVal oprot $ from_RemoveMessage_result record
encode_RemoveMessage_result :: T.StatelessProtocol p => p -> RemoveMessage_result -> LBS.ByteString
encode_RemoveMessage_result oprot record = T.serializeVal oprot $ from_RemoveMessage_result record
to_RemoveMessage_result :: T.ThriftVal -> RemoveMessage_result
to_RemoveMessage_result (T.TStruct fields) = RemoveMessage_result{
  removeMessage_result_success = P.maybe (removeMessage_result_success default_RemoveMessage_result) (\(_,_val5522) -> (case _val5522 of {T.TBool _val5523 -> _val5523; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  removeMessage_result_e = P.maybe (P.Nothing) (\(_,_val5522) -> P.Just (case _val5522 of {T.TStruct _val5524 -> (to_TalkException (T.TStruct _val5524)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveMessage_result _ = P.error "not a struct"
read_RemoveMessage_result :: T.Protocol p => p -> P.IO RemoveMessage_result
read_RemoveMessage_result iprot = to_RemoveMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessage_result)
decode_RemoveMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessage_result
decode_RemoveMessage_result iprot bs = to_RemoveMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessage_result) bs
typemap_RemoveMessage_result :: T.TypeMap
typemap_RemoveMessage_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveMessage_result :: RemoveMessage_result
default_RemoveMessage_result = RemoveMessage_result{
  removeMessage_result_success = P.False,
  removeMessage_result_e = P.Nothing}
data RemoveMessageFromMyHome_args = RemoveMessageFromMyHome_args  { removeMessageFromMyHome_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessageFromMyHome_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessageFromMyHome_args_messageId record  
instance QC.Arbitrary RemoveMessageFromMyHome_args where 
  arbitrary = M.liftM RemoveMessageFromMyHome_args (QC.arbitrary)
  shrink obj | obj == default_RemoveMessageFromMyHome_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessageFromMyHome_args{removeMessageFromMyHome_args_messageId = removeMessageFromMyHome_args_messageId obj} then P.Nothing else P.Just $ default_RemoveMessageFromMyHome_args{removeMessageFromMyHome_args_messageId = removeMessageFromMyHome_args_messageId obj}
    ]
from_RemoveMessageFromMyHome_args :: RemoveMessageFromMyHome_args -> T.ThriftVal
from_RemoveMessageFromMyHome_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5527 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v5527))) $ removeMessageFromMyHome_args_messageId record
  ]
write_RemoveMessageFromMyHome_args :: T.Protocol p => p -> RemoveMessageFromMyHome_args -> P.IO ()
write_RemoveMessageFromMyHome_args oprot record = T.writeVal oprot $ from_RemoveMessageFromMyHome_args record
encode_RemoveMessageFromMyHome_args :: T.StatelessProtocol p => p -> RemoveMessageFromMyHome_args -> LBS.ByteString
encode_RemoveMessageFromMyHome_args oprot record = T.serializeVal oprot $ from_RemoveMessageFromMyHome_args record
to_RemoveMessageFromMyHome_args :: T.ThriftVal -> RemoveMessageFromMyHome_args
to_RemoveMessageFromMyHome_args (T.TStruct fields) = RemoveMessageFromMyHome_args{
  removeMessageFromMyHome_args_messageId = P.maybe (removeMessageFromMyHome_args_messageId default_RemoveMessageFromMyHome_args) (\(_,_val5529) -> (case _val5529 of {T.TString _val5530 -> E.decodeUtf8 _val5530; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveMessageFromMyHome_args _ = P.error "not a struct"
read_RemoveMessageFromMyHome_args :: T.Protocol p => p -> P.IO RemoveMessageFromMyHome_args
read_RemoveMessageFromMyHome_args iprot = to_RemoveMessageFromMyHome_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_args)
decode_RemoveMessageFromMyHome_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessageFromMyHome_args
decode_RemoveMessageFromMyHome_args iprot bs = to_RemoveMessageFromMyHome_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_args) bs
typemap_RemoveMessageFromMyHome_args :: T.TypeMap
typemap_RemoveMessageFromMyHome_args = Map.fromList [(2,("messageId",T.T_STRING))]
default_RemoveMessageFromMyHome_args :: RemoveMessageFromMyHome_args
default_RemoveMessageFromMyHome_args = RemoveMessageFromMyHome_args{
  removeMessageFromMyHome_args_messageId = ""}
data RemoveMessageFromMyHome_result = RemoveMessageFromMyHome_result  { removeMessageFromMyHome_result_success :: P.Bool
  , removeMessageFromMyHome_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessageFromMyHome_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessageFromMyHome_result_success record   `H.hashWithSalt` removeMessageFromMyHome_result_e record  
instance QC.Arbitrary RemoveMessageFromMyHome_result where 
  arbitrary = M.liftM RemoveMessageFromMyHome_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveMessageFromMyHome_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_success = removeMessageFromMyHome_result_success obj} then P.Nothing else P.Just $ default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_success = removeMessageFromMyHome_result_success obj}
    , if obj == default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_e = removeMessageFromMyHome_result_e obj} then P.Nothing else P.Just $ default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_e = removeMessageFromMyHome_result_e obj}
    ]
from_RemoveMessageFromMyHome_result :: RemoveMessageFromMyHome_result -> T.ThriftVal
from_RemoveMessageFromMyHome_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5533 -> (1, ("e",from_TalkException _v5533))) <$> removeMessageFromMyHome_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5533 -> P.Just (0, ("success",T.TBool _v5533))) $ removeMessageFromMyHome_result_success record
    , (\_v5533 -> (1, ("e",from_TalkException _v5533))) <$> removeMessageFromMyHome_result_e record
    ]
    )
write_RemoveMessageFromMyHome_result :: T.Protocol p => p -> RemoveMessageFromMyHome_result -> P.IO ()
write_RemoveMessageFromMyHome_result oprot record = T.writeVal oprot $ from_RemoveMessageFromMyHome_result record
encode_RemoveMessageFromMyHome_result :: T.StatelessProtocol p => p -> RemoveMessageFromMyHome_result -> LBS.ByteString
encode_RemoveMessageFromMyHome_result oprot record = T.serializeVal oprot $ from_RemoveMessageFromMyHome_result record
to_RemoveMessageFromMyHome_result :: T.ThriftVal -> RemoveMessageFromMyHome_result
to_RemoveMessageFromMyHome_result (T.TStruct fields) = RemoveMessageFromMyHome_result{
  removeMessageFromMyHome_result_success = P.maybe (removeMessageFromMyHome_result_success default_RemoveMessageFromMyHome_result) (\(_,_val5535) -> (case _val5535 of {T.TBool _val5536 -> _val5536; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  removeMessageFromMyHome_result_e = P.maybe (P.Nothing) (\(_,_val5535) -> P.Just (case _val5535 of {T.TStruct _val5537 -> (to_TalkException (T.TStruct _val5537)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveMessageFromMyHome_result _ = P.error "not a struct"
read_RemoveMessageFromMyHome_result :: T.Protocol p => p -> P.IO RemoveMessageFromMyHome_result
read_RemoveMessageFromMyHome_result iprot = to_RemoveMessageFromMyHome_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_result)
decode_RemoveMessageFromMyHome_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessageFromMyHome_result
decode_RemoveMessageFromMyHome_result iprot bs = to_RemoveMessageFromMyHome_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_result) bs
typemap_RemoveMessageFromMyHome_result :: T.TypeMap
typemap_RemoveMessageFromMyHome_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveMessageFromMyHome_result :: RemoveMessageFromMyHome_result
default_RemoveMessageFromMyHome_result = RemoveMessageFromMyHome_result{
  removeMessageFromMyHome_result_success = P.False,
  removeMessageFromMyHome_result_e = P.Nothing}
data RemoveSnsId_args = RemoveSnsId_args  { removeSnsId_args_snsIdType :: SnsIdType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSnsId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeSnsId_args_snsIdType record  
instance QC.Arbitrary RemoveSnsId_args where 
  arbitrary = M.liftM RemoveSnsId_args (QC.arbitrary)
  shrink obj | obj == default_RemoveSnsId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveSnsId_args{removeSnsId_args_snsIdType = removeSnsId_args_snsIdType obj} then P.Nothing else P.Just $ default_RemoveSnsId_args{removeSnsId_args_snsIdType = removeSnsId_args_snsIdType obj}
    ]
from_RemoveSnsId_args :: RemoveSnsId_args -> T.ThriftVal
from_RemoveSnsId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5540 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v5540))) $ removeSnsId_args_snsIdType record
  ]
write_RemoveSnsId_args :: T.Protocol p => p -> RemoveSnsId_args -> P.IO ()
write_RemoveSnsId_args oprot record = T.writeVal oprot $ from_RemoveSnsId_args record
encode_RemoveSnsId_args :: T.StatelessProtocol p => p -> RemoveSnsId_args -> LBS.ByteString
encode_RemoveSnsId_args oprot record = T.serializeVal oprot $ from_RemoveSnsId_args record
to_RemoveSnsId_args :: T.ThriftVal -> RemoveSnsId_args
to_RemoveSnsId_args (T.TStruct fields) = RemoveSnsId_args{
  removeSnsId_args_snsIdType = P.maybe (removeSnsId_args_snsIdType default_RemoveSnsId_args) (\(_,_val5542) -> (case _val5542 of {T.TI32 _val5543 -> P.toEnum $ P.fromIntegral _val5543; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveSnsId_args _ = P.error "not a struct"
read_RemoveSnsId_args :: T.Protocol p => p -> P.IO RemoveSnsId_args
read_RemoveSnsId_args iprot = to_RemoveSnsId_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSnsId_args)
decode_RemoveSnsId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSnsId_args
decode_RemoveSnsId_args iprot bs = to_RemoveSnsId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSnsId_args) bs
typemap_RemoveSnsId_args :: T.TypeMap
typemap_RemoveSnsId_args = Map.fromList [(2,("snsIdType",T.T_I32))]
default_RemoveSnsId_args :: RemoveSnsId_args
default_RemoveSnsId_args = RemoveSnsId_args{
  removeSnsId_args_snsIdType = (P.toEnum 0)}
data RemoveSnsId_result = RemoveSnsId_result  { removeSnsId_result_success :: LT.Text
  , removeSnsId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSnsId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeSnsId_result_success record   `H.hashWithSalt` removeSnsId_result_e record  
instance QC.Arbitrary RemoveSnsId_result where 
  arbitrary = M.liftM RemoveSnsId_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveSnsId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveSnsId_result{removeSnsId_result_success = removeSnsId_result_success obj} then P.Nothing else P.Just $ default_RemoveSnsId_result{removeSnsId_result_success = removeSnsId_result_success obj}
    , if obj == default_RemoveSnsId_result{removeSnsId_result_e = removeSnsId_result_e obj} then P.Nothing else P.Just $ default_RemoveSnsId_result{removeSnsId_result_e = removeSnsId_result_e obj}
    ]
from_RemoveSnsId_result :: RemoveSnsId_result -> T.ThriftVal
from_RemoveSnsId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5546 -> (1, ("e",from_TalkException _v5546))) <$> removeSnsId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5546 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5546))) $ removeSnsId_result_success record
    , (\_v5546 -> (1, ("e",from_TalkException _v5546))) <$> removeSnsId_result_e record
    ]
    )
write_RemoveSnsId_result :: T.Protocol p => p -> RemoveSnsId_result -> P.IO ()
write_RemoveSnsId_result oprot record = T.writeVal oprot $ from_RemoveSnsId_result record
encode_RemoveSnsId_result :: T.StatelessProtocol p => p -> RemoveSnsId_result -> LBS.ByteString
encode_RemoveSnsId_result oprot record = T.serializeVal oprot $ from_RemoveSnsId_result record
to_RemoveSnsId_result :: T.ThriftVal -> RemoveSnsId_result
to_RemoveSnsId_result (T.TStruct fields) = RemoveSnsId_result{
  removeSnsId_result_success = P.maybe (removeSnsId_result_success default_RemoveSnsId_result) (\(_,_val5548) -> (case _val5548 of {T.TString _val5549 -> E.decodeUtf8 _val5549; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  removeSnsId_result_e = P.maybe (P.Nothing) (\(_,_val5548) -> P.Just (case _val5548 of {T.TStruct _val5550 -> (to_TalkException (T.TStruct _val5550)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveSnsId_result _ = P.error "not a struct"
read_RemoveSnsId_result :: T.Protocol p => p -> P.IO RemoveSnsId_result
read_RemoveSnsId_result iprot = to_RemoveSnsId_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSnsId_result)
decode_RemoveSnsId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSnsId_result
decode_RemoveSnsId_result iprot bs = to_RemoveSnsId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSnsId_result) bs
typemap_RemoveSnsId_result :: T.TypeMap
typemap_RemoveSnsId_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveSnsId_result :: RemoveSnsId_result
default_RemoveSnsId_result = RemoveSnsId_result{
  removeSnsId_result_success = "",
  removeSnsId_result_e = P.Nothing}
data Report_args = Report_args  { report_args_syncOpRevision :: I.Int64
  , report_args_category :: SyncCategory
  , report_args_report :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Report_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` report_args_syncOpRevision record   `H.hashWithSalt` report_args_category record   `H.hashWithSalt` report_args_report record  
instance QC.Arbitrary Report_args where 
  arbitrary = M.liftM Report_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Report_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Report_args{report_args_syncOpRevision = report_args_syncOpRevision obj} then P.Nothing else P.Just $ default_Report_args{report_args_syncOpRevision = report_args_syncOpRevision obj}
    , if obj == default_Report_args{report_args_category = report_args_category obj} then P.Nothing else P.Just $ default_Report_args{report_args_category = report_args_category obj}
    , if obj == default_Report_args{report_args_report = report_args_report obj} then P.Nothing else P.Just $ default_Report_args{report_args_report = report_args_report obj}
    ]
from_Report_args :: Report_args -> T.ThriftVal
from_Report_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5553 -> P.Just (2, ("syncOpRevision",T.TI64 _v5553))) $ report_args_syncOpRevision record
  , (\_v5553 -> P.Just (3, ("category",T.TI32 $ P.fromIntegral $ P.fromEnum _v5553))) $ report_args_category record
  , (\_v5553 -> P.Just (4, ("report",T.TString $ E.encodeUtf8 _v5553))) $ report_args_report record
  ]
write_Report_args :: T.Protocol p => p -> Report_args -> P.IO ()
write_Report_args oprot record = T.writeVal oprot $ from_Report_args record
encode_Report_args :: T.StatelessProtocol p => p -> Report_args -> LBS.ByteString
encode_Report_args oprot record = T.serializeVal oprot $ from_Report_args record
to_Report_args :: T.ThriftVal -> Report_args
to_Report_args (T.TStruct fields) = Report_args{
  report_args_syncOpRevision = P.maybe (report_args_syncOpRevision default_Report_args) (\(_,_val5555) -> (case _val5555 of {T.TI64 _val5556 -> _val5556; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  report_args_category = P.maybe (report_args_category default_Report_args) (\(_,_val5555) -> (case _val5555 of {T.TI32 _val5557 -> P.toEnum $ P.fromIntegral _val5557; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  report_args_report = P.maybe (report_args_report default_Report_args) (\(_,_val5555) -> (case _val5555 of {T.TString _val5558 -> E.decodeUtf8 _val5558; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Report_args _ = P.error "not a struct"
read_Report_args :: T.Protocol p => p -> P.IO Report_args
read_Report_args iprot = to_Report_args <$> T.readVal iprot (T.T_STRUCT typemap_Report_args)
decode_Report_args :: T.StatelessProtocol p => p -> LBS.ByteString -> Report_args
decode_Report_args iprot bs = to_Report_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Report_args) bs
typemap_Report_args :: T.TypeMap
typemap_Report_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("category",T.T_I32)),(4,("report",T.T_STRING))]
default_Report_args :: Report_args
default_Report_args = Report_args{
  report_args_syncOpRevision = 0,
  report_args_category = (P.toEnum 0),
  report_args_report = ""}
data Report_result = Report_result  { report_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Report_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` report_result_e record  
instance QC.Arbitrary Report_result where 
  arbitrary = M.liftM Report_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Report_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Report_result{report_result_e = report_result_e obj} then P.Nothing else P.Just $ default_Report_result{report_result_e = report_result_e obj}
    ]
from_Report_result :: Report_result -> T.ThriftVal
from_Report_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5561 -> (1, ("e",from_TalkException _v5561))) <$> report_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5561 -> (1, ("e",from_TalkException _v5561))) <$> report_result_e record
    ]
    )
write_Report_result :: T.Protocol p => p -> Report_result -> P.IO ()
write_Report_result oprot record = T.writeVal oprot $ from_Report_result record
encode_Report_result :: T.StatelessProtocol p => p -> Report_result -> LBS.ByteString
encode_Report_result oprot record = T.serializeVal oprot $ from_Report_result record
to_Report_result :: T.ThriftVal -> Report_result
to_Report_result (T.TStruct fields) = Report_result{
  report_result_e = P.maybe (P.Nothing) (\(_,_val5563) -> P.Just (case _val5563 of {T.TStruct _val5564 -> (to_TalkException (T.TStruct _val5564)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Report_result _ = P.error "not a struct"
read_Report_result :: T.Protocol p => p -> P.IO Report_result
read_Report_result iprot = to_Report_result <$> T.readVal iprot (T.T_STRUCT typemap_Report_result)
decode_Report_result :: T.StatelessProtocol p => p -> LBS.ByteString -> Report_result
decode_Report_result iprot bs = to_Report_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Report_result) bs
typemap_Report_result :: T.TypeMap
typemap_Report_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_Report_result :: Report_result
default_Report_result = Report_result{
  report_result_e = P.Nothing}
data ReportContacts_args = ReportContacts_args  { reportContacts_args_syncOpRevision :: I.Int64
  , reportContacts_args_category :: SyncCategory
  , reportContacts_args_contactReports :: (Vector.Vector ContactReport)
  , reportContacts_args_actionType :: SyncActionType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportContacts_args_syncOpRevision record   `H.hashWithSalt` reportContacts_args_category record   `H.hashWithSalt` reportContacts_args_contactReports record   `H.hashWithSalt` reportContacts_args_actionType record  
instance QC.Arbitrary ReportContacts_args where 
  arbitrary = M.liftM ReportContacts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportContacts_args{reportContacts_args_syncOpRevision = reportContacts_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_syncOpRevision = reportContacts_args_syncOpRevision obj}
    , if obj == default_ReportContacts_args{reportContacts_args_category = reportContacts_args_category obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_category = reportContacts_args_category obj}
    , if obj == default_ReportContacts_args{reportContacts_args_contactReports = reportContacts_args_contactReports obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_contactReports = reportContacts_args_contactReports obj}
    , if obj == default_ReportContacts_args{reportContacts_args_actionType = reportContacts_args_actionType obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_actionType = reportContacts_args_actionType obj}
    ]
from_ReportContacts_args :: ReportContacts_args -> T.ThriftVal
from_ReportContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5567 -> P.Just (2, ("syncOpRevision",T.TI64 _v5567))) $ reportContacts_args_syncOpRevision record
  , (\_v5567 -> P.Just (3, ("category",T.TI32 $ P.fromIntegral $ P.fromEnum _v5567))) $ reportContacts_args_category record
  , (\_v5567 -> P.Just (4, ("contactReports",T.TList (T.T_STRUCT typemap_ContactReport) $ P.map (\_v5569 -> from_ContactReport _v5569) $ Vector.toList _v5567))) $ reportContacts_args_contactReports record
  , (\_v5567 -> P.Just (5, ("actionType",T.TI32 $ P.fromIntegral $ P.fromEnum _v5567))) $ reportContacts_args_actionType record
  ]
write_ReportContacts_args :: T.Protocol p => p -> ReportContacts_args -> P.IO ()
write_ReportContacts_args oprot record = T.writeVal oprot $ from_ReportContacts_args record
encode_ReportContacts_args :: T.StatelessProtocol p => p -> ReportContacts_args -> LBS.ByteString
encode_ReportContacts_args oprot record = T.serializeVal oprot $ from_ReportContacts_args record
to_ReportContacts_args :: T.ThriftVal -> ReportContacts_args
to_ReportContacts_args (T.TStruct fields) = ReportContacts_args{
  reportContacts_args_syncOpRevision = P.maybe (reportContacts_args_syncOpRevision default_ReportContacts_args) (\(_,_val5571) -> (case _val5571 of {T.TI64 _val5572 -> _val5572; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportContacts_args_category = P.maybe (reportContacts_args_category default_ReportContacts_args) (\(_,_val5571) -> (case _val5571 of {T.TI32 _val5573 -> P.toEnum $ P.fromIntegral _val5573; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportContacts_args_contactReports = P.maybe (reportContacts_args_contactReports default_ReportContacts_args) (\(_,_val5571) -> (case _val5571 of {T.TList _ _val5574 -> (Vector.fromList $ P.map (\_v5575 -> (case _v5575 of {T.TStruct _val5576 -> (to_ContactReport (T.TStruct _val5576)); _ -> P.error "wrong type"})) _val5574); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  reportContacts_args_actionType = P.maybe (reportContacts_args_actionType default_ReportContacts_args) (\(_,_val5571) -> (case _val5571 of {T.TI32 _val5577 -> P.toEnum $ P.fromIntegral _val5577; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ReportContacts_args _ = P.error "not a struct"
read_ReportContacts_args :: T.Protocol p => p -> P.IO ReportContacts_args
read_ReportContacts_args iprot = to_ReportContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportContacts_args)
decode_ReportContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportContacts_args
decode_ReportContacts_args iprot bs = to_ReportContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportContacts_args) bs
typemap_ReportContacts_args :: T.TypeMap
typemap_ReportContacts_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("category",T.T_I32)),(4,("contactReports",(T.T_LIST (T.T_STRUCT typemap_ContactReport)))),(5,("actionType",T.T_I32))]
default_ReportContacts_args :: ReportContacts_args
default_ReportContacts_args = ReportContacts_args{
  reportContacts_args_syncOpRevision = 0,
  reportContacts_args_category = (P.toEnum 0),
  reportContacts_args_contactReports = Vector.empty,
  reportContacts_args_actionType = (P.toEnum 0)}
data ReportContacts_result = ReportContacts_result  { reportContacts_result_success :: (Vector.Vector ContactReportResult)
  , reportContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportContacts_result_success record   `H.hashWithSalt` reportContacts_result_e record  
instance QC.Arbitrary ReportContacts_result where 
  arbitrary = M.liftM ReportContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportContacts_result{reportContacts_result_success = reportContacts_result_success obj} then P.Nothing else P.Just $ default_ReportContacts_result{reportContacts_result_success = reportContacts_result_success obj}
    , if obj == default_ReportContacts_result{reportContacts_result_e = reportContacts_result_e obj} then P.Nothing else P.Just $ default_ReportContacts_result{reportContacts_result_e = reportContacts_result_e obj}
    ]
from_ReportContacts_result :: ReportContacts_result -> T.ThriftVal
from_ReportContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5580 -> (1, ("e",from_TalkException _v5580))) <$> reportContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5580 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_ContactReportResult) $ P.map (\_v5582 -> from_ContactReportResult _v5582) $ Vector.toList _v5580))) $ reportContacts_result_success record
    , (\_v5580 -> (1, ("e",from_TalkException _v5580))) <$> reportContacts_result_e record
    ]
    )
write_ReportContacts_result :: T.Protocol p => p -> ReportContacts_result -> P.IO ()
write_ReportContacts_result oprot record = T.writeVal oprot $ from_ReportContacts_result record
encode_ReportContacts_result :: T.StatelessProtocol p => p -> ReportContacts_result -> LBS.ByteString
encode_ReportContacts_result oprot record = T.serializeVal oprot $ from_ReportContacts_result record
to_ReportContacts_result :: T.ThriftVal -> ReportContacts_result
to_ReportContacts_result (T.TStruct fields) = ReportContacts_result{
  reportContacts_result_success = P.maybe (reportContacts_result_success default_ReportContacts_result) (\(_,_val5584) -> (case _val5584 of {T.TList _ _val5585 -> (Vector.fromList $ P.map (\_v5586 -> (case _v5586 of {T.TStruct _val5587 -> (to_ContactReportResult (T.TStruct _val5587)); _ -> P.error "wrong type"})) _val5585); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reportContacts_result_e = P.maybe (P.Nothing) (\(_,_val5584) -> P.Just (case _val5584 of {T.TStruct _val5588 -> (to_TalkException (T.TStruct _val5588)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportContacts_result _ = P.error "not a struct"
read_ReportContacts_result :: T.Protocol p => p -> P.IO ReportContacts_result
read_ReportContacts_result iprot = to_ReportContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportContacts_result)
decode_ReportContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportContacts_result
decode_ReportContacts_result iprot bs = to_ReportContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportContacts_result) bs
typemap_ReportContacts_result :: T.TypeMap
typemap_ReportContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_ContactReportResult)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportContacts_result :: ReportContacts_result
default_ReportContacts_result = ReportContacts_result{
  reportContacts_result_success = Vector.empty,
  reportContacts_result_e = P.Nothing}
data ReportGroups_args = ReportGroups_args  { reportGroups_args_syncOpRevision :: I.Int64
  , reportGroups_args_groups :: (Vector.Vector Group)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportGroups_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportGroups_args_syncOpRevision record   `H.hashWithSalt` reportGroups_args_groups record  
instance QC.Arbitrary ReportGroups_args where 
  arbitrary = M.liftM ReportGroups_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportGroups_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportGroups_args{reportGroups_args_syncOpRevision = reportGroups_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportGroups_args{reportGroups_args_syncOpRevision = reportGroups_args_syncOpRevision obj}
    , if obj == default_ReportGroups_args{reportGroups_args_groups = reportGroups_args_groups obj} then P.Nothing else P.Just $ default_ReportGroups_args{reportGroups_args_groups = reportGroups_args_groups obj}
    ]
from_ReportGroups_args :: ReportGroups_args -> T.ThriftVal
from_ReportGroups_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5591 -> P.Just (2, ("syncOpRevision",T.TI64 _v5591))) $ reportGroups_args_syncOpRevision record
  , (\_v5591 -> P.Just (3, ("groups",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v5593 -> from_Group _v5593) $ Vector.toList _v5591))) $ reportGroups_args_groups record
  ]
write_ReportGroups_args :: T.Protocol p => p -> ReportGroups_args -> P.IO ()
write_ReportGroups_args oprot record = T.writeVal oprot $ from_ReportGroups_args record
encode_ReportGroups_args :: T.StatelessProtocol p => p -> ReportGroups_args -> LBS.ByteString
encode_ReportGroups_args oprot record = T.serializeVal oprot $ from_ReportGroups_args record
to_ReportGroups_args :: T.ThriftVal -> ReportGroups_args
to_ReportGroups_args (T.TStruct fields) = ReportGroups_args{
  reportGroups_args_syncOpRevision = P.maybe (reportGroups_args_syncOpRevision default_ReportGroups_args) (\(_,_val5595) -> (case _val5595 of {T.TI64 _val5596 -> _val5596; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportGroups_args_groups = P.maybe (reportGroups_args_groups default_ReportGroups_args) (\(_,_val5595) -> (case _val5595 of {T.TList _ _val5597 -> (Vector.fromList $ P.map (\_v5598 -> (case _v5598 of {T.TStruct _val5599 -> (to_Group (T.TStruct _val5599)); _ -> P.error "wrong type"})) _val5597); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportGroups_args _ = P.error "not a struct"
read_ReportGroups_args :: T.Protocol p => p -> P.IO ReportGroups_args
read_ReportGroups_args iprot = to_ReportGroups_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportGroups_args)
decode_ReportGroups_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportGroups_args
decode_ReportGroups_args iprot bs = to_ReportGroups_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportGroups_args) bs
typemap_ReportGroups_args :: T.TypeMap
typemap_ReportGroups_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("groups",(T.T_LIST (T.T_STRUCT typemap_Group))))]
default_ReportGroups_args :: ReportGroups_args
default_ReportGroups_args = ReportGroups_args{
  reportGroups_args_syncOpRevision = 0,
  reportGroups_args_groups = Vector.empty}
data ReportGroups_result = ReportGroups_result  { reportGroups_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportGroups_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportGroups_result_e record  
instance QC.Arbitrary ReportGroups_result where 
  arbitrary = M.liftM ReportGroups_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportGroups_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportGroups_result{reportGroups_result_e = reportGroups_result_e obj} then P.Nothing else P.Just $ default_ReportGroups_result{reportGroups_result_e = reportGroups_result_e obj}
    ]
from_ReportGroups_result :: ReportGroups_result -> T.ThriftVal
from_ReportGroups_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5602 -> (1, ("e",from_TalkException _v5602))) <$> reportGroups_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5602 -> (1, ("e",from_TalkException _v5602))) <$> reportGroups_result_e record
    ]
    )
write_ReportGroups_result :: T.Protocol p => p -> ReportGroups_result -> P.IO ()
write_ReportGroups_result oprot record = T.writeVal oprot $ from_ReportGroups_result record
encode_ReportGroups_result :: T.StatelessProtocol p => p -> ReportGroups_result -> LBS.ByteString
encode_ReportGroups_result oprot record = T.serializeVal oprot $ from_ReportGroups_result record
to_ReportGroups_result :: T.ThriftVal -> ReportGroups_result
to_ReportGroups_result (T.TStruct fields) = ReportGroups_result{
  reportGroups_result_e = P.maybe (P.Nothing) (\(_,_val5604) -> P.Just (case _val5604 of {T.TStruct _val5605 -> (to_TalkException (T.TStruct _val5605)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportGroups_result _ = P.error "not a struct"
read_ReportGroups_result :: T.Protocol p => p -> P.IO ReportGroups_result
read_ReportGroups_result iprot = to_ReportGroups_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportGroups_result)
decode_ReportGroups_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportGroups_result
decode_ReportGroups_result iprot bs = to_ReportGroups_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportGroups_result) bs
typemap_ReportGroups_result :: T.TypeMap
typemap_ReportGroups_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportGroups_result :: ReportGroups_result
default_ReportGroups_result = ReportGroups_result{
  reportGroups_result_e = P.Nothing}
data ReportProfile_args = ReportProfile_args  { reportProfile_args_syncOpRevision :: I.Int64
  , reportProfile_args_profile :: Profile
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportProfile_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportProfile_args_syncOpRevision record   `H.hashWithSalt` reportProfile_args_profile record  
instance QC.Arbitrary ReportProfile_args where 
  arbitrary = M.liftM ReportProfile_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportProfile_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportProfile_args{reportProfile_args_syncOpRevision = reportProfile_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportProfile_args{reportProfile_args_syncOpRevision = reportProfile_args_syncOpRevision obj}
    , if obj == default_ReportProfile_args{reportProfile_args_profile = reportProfile_args_profile obj} then P.Nothing else P.Just $ default_ReportProfile_args{reportProfile_args_profile = reportProfile_args_profile obj}
    ]
from_ReportProfile_args :: ReportProfile_args -> T.ThriftVal
from_ReportProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5608 -> P.Just (2, ("syncOpRevision",T.TI64 _v5608))) $ reportProfile_args_syncOpRevision record
  , (\_v5608 -> P.Just (3, ("profile",from_Profile _v5608))) $ reportProfile_args_profile record
  ]
write_ReportProfile_args :: T.Protocol p => p -> ReportProfile_args -> P.IO ()
write_ReportProfile_args oprot record = T.writeVal oprot $ from_ReportProfile_args record
encode_ReportProfile_args :: T.StatelessProtocol p => p -> ReportProfile_args -> LBS.ByteString
encode_ReportProfile_args oprot record = T.serializeVal oprot $ from_ReportProfile_args record
to_ReportProfile_args :: T.ThriftVal -> ReportProfile_args
to_ReportProfile_args (T.TStruct fields) = ReportProfile_args{
  reportProfile_args_syncOpRevision = P.maybe (reportProfile_args_syncOpRevision default_ReportProfile_args) (\(_,_val5610) -> (case _val5610 of {T.TI64 _val5611 -> _val5611; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportProfile_args_profile = P.maybe (reportProfile_args_profile default_ReportProfile_args) (\(_,_val5610) -> (case _val5610 of {T.TStruct _val5612 -> (to_Profile (T.TStruct _val5612)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportProfile_args _ = P.error "not a struct"
read_ReportProfile_args :: T.Protocol p => p -> P.IO ReportProfile_args
read_ReportProfile_args iprot = to_ReportProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportProfile_args)
decode_ReportProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportProfile_args
decode_ReportProfile_args iprot bs = to_ReportProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportProfile_args) bs
typemap_ReportProfile_args :: T.TypeMap
typemap_ReportProfile_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("profile",(T.T_STRUCT typemap_Profile)))]
default_ReportProfile_args :: ReportProfile_args
default_ReportProfile_args = ReportProfile_args{
  reportProfile_args_syncOpRevision = 0,
  reportProfile_args_profile = default_Profile}
data ReportProfile_result = ReportProfile_result  { reportProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportProfile_result_e record  
instance QC.Arbitrary ReportProfile_result where 
  arbitrary = M.liftM ReportProfile_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportProfile_result{reportProfile_result_e = reportProfile_result_e obj} then P.Nothing else P.Just $ default_ReportProfile_result{reportProfile_result_e = reportProfile_result_e obj}
    ]
from_ReportProfile_result :: ReportProfile_result -> T.ThriftVal
from_ReportProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5615 -> (1, ("e",from_TalkException _v5615))) <$> reportProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5615 -> (1, ("e",from_TalkException _v5615))) <$> reportProfile_result_e record
    ]
    )
write_ReportProfile_result :: T.Protocol p => p -> ReportProfile_result -> P.IO ()
write_ReportProfile_result oprot record = T.writeVal oprot $ from_ReportProfile_result record
encode_ReportProfile_result :: T.StatelessProtocol p => p -> ReportProfile_result -> LBS.ByteString
encode_ReportProfile_result oprot record = T.serializeVal oprot $ from_ReportProfile_result record
to_ReportProfile_result :: T.ThriftVal -> ReportProfile_result
to_ReportProfile_result (T.TStruct fields) = ReportProfile_result{
  reportProfile_result_e = P.maybe (P.Nothing) (\(_,_val5617) -> P.Just (case _val5617 of {T.TStruct _val5618 -> (to_TalkException (T.TStruct _val5618)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportProfile_result _ = P.error "not a struct"
read_ReportProfile_result :: T.Protocol p => p -> P.IO ReportProfile_result
read_ReportProfile_result iprot = to_ReportProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportProfile_result)
decode_ReportProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportProfile_result
decode_ReportProfile_result iprot bs = to_ReportProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportProfile_result) bs
typemap_ReportProfile_result :: T.TypeMap
typemap_ReportProfile_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportProfile_result :: ReportProfile_result
default_ReportProfile_result = ReportProfile_result{
  reportProfile_result_e = P.Nothing}
data ReportRooms_args = ReportRooms_args  { reportRooms_args_syncOpRevision :: I.Int64
  , reportRooms_args_rooms :: (Vector.Vector Room)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportRooms_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportRooms_args_syncOpRevision record   `H.hashWithSalt` reportRooms_args_rooms record  
instance QC.Arbitrary ReportRooms_args where 
  arbitrary = M.liftM ReportRooms_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportRooms_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportRooms_args{reportRooms_args_syncOpRevision = reportRooms_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportRooms_args{reportRooms_args_syncOpRevision = reportRooms_args_syncOpRevision obj}
    , if obj == default_ReportRooms_args{reportRooms_args_rooms = reportRooms_args_rooms obj} then P.Nothing else P.Just $ default_ReportRooms_args{reportRooms_args_rooms = reportRooms_args_rooms obj}
    ]
from_ReportRooms_args :: ReportRooms_args -> T.ThriftVal
from_ReportRooms_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5621 -> P.Just (2, ("syncOpRevision",T.TI64 _v5621))) $ reportRooms_args_syncOpRevision record
  , (\_v5621 -> P.Just (3, ("rooms",T.TList (T.T_STRUCT typemap_Room) $ P.map (\_v5623 -> from_Room _v5623) $ Vector.toList _v5621))) $ reportRooms_args_rooms record
  ]
write_ReportRooms_args :: T.Protocol p => p -> ReportRooms_args -> P.IO ()
write_ReportRooms_args oprot record = T.writeVal oprot $ from_ReportRooms_args record
encode_ReportRooms_args :: T.StatelessProtocol p => p -> ReportRooms_args -> LBS.ByteString
encode_ReportRooms_args oprot record = T.serializeVal oprot $ from_ReportRooms_args record
to_ReportRooms_args :: T.ThriftVal -> ReportRooms_args
to_ReportRooms_args (T.TStruct fields) = ReportRooms_args{
  reportRooms_args_syncOpRevision = P.maybe (reportRooms_args_syncOpRevision default_ReportRooms_args) (\(_,_val5625) -> (case _val5625 of {T.TI64 _val5626 -> _val5626; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportRooms_args_rooms = P.maybe (reportRooms_args_rooms default_ReportRooms_args) (\(_,_val5625) -> (case _val5625 of {T.TList _ _val5627 -> (Vector.fromList $ P.map (\_v5628 -> (case _v5628 of {T.TStruct _val5629 -> (to_Room (T.TStruct _val5629)); _ -> P.error "wrong type"})) _val5627); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportRooms_args _ = P.error "not a struct"
read_ReportRooms_args :: T.Protocol p => p -> P.IO ReportRooms_args
read_ReportRooms_args iprot = to_ReportRooms_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportRooms_args)
decode_ReportRooms_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportRooms_args
decode_ReportRooms_args iprot bs = to_ReportRooms_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportRooms_args) bs
typemap_ReportRooms_args :: T.TypeMap
typemap_ReportRooms_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("rooms",(T.T_LIST (T.T_STRUCT typemap_Room))))]
default_ReportRooms_args :: ReportRooms_args
default_ReportRooms_args = ReportRooms_args{
  reportRooms_args_syncOpRevision = 0,
  reportRooms_args_rooms = Vector.empty}
data ReportRooms_result = ReportRooms_result  { reportRooms_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportRooms_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportRooms_result_e record  
instance QC.Arbitrary ReportRooms_result where 
  arbitrary = M.liftM ReportRooms_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportRooms_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportRooms_result{reportRooms_result_e = reportRooms_result_e obj} then P.Nothing else P.Just $ default_ReportRooms_result{reportRooms_result_e = reportRooms_result_e obj}
    ]
from_ReportRooms_result :: ReportRooms_result -> T.ThriftVal
from_ReportRooms_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5632 -> (1, ("e",from_TalkException _v5632))) <$> reportRooms_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5632 -> (1, ("e",from_TalkException _v5632))) <$> reportRooms_result_e record
    ]
    )
write_ReportRooms_result :: T.Protocol p => p -> ReportRooms_result -> P.IO ()
write_ReportRooms_result oprot record = T.writeVal oprot $ from_ReportRooms_result record
encode_ReportRooms_result :: T.StatelessProtocol p => p -> ReportRooms_result -> LBS.ByteString
encode_ReportRooms_result oprot record = T.serializeVal oprot $ from_ReportRooms_result record
to_ReportRooms_result :: T.ThriftVal -> ReportRooms_result
to_ReportRooms_result (T.TStruct fields) = ReportRooms_result{
  reportRooms_result_e = P.maybe (P.Nothing) (\(_,_val5634) -> P.Just (case _val5634 of {T.TStruct _val5635 -> (to_TalkException (T.TStruct _val5635)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportRooms_result _ = P.error "not a struct"
read_ReportRooms_result :: T.Protocol p => p -> P.IO ReportRooms_result
read_ReportRooms_result iprot = to_ReportRooms_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportRooms_result)
decode_ReportRooms_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportRooms_result
decode_ReportRooms_result iprot bs = to_ReportRooms_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportRooms_result) bs
typemap_ReportRooms_result :: T.TypeMap
typemap_ReportRooms_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportRooms_result :: ReportRooms_result
default_ReportRooms_result = ReportRooms_result{
  reportRooms_result_e = P.Nothing}
data ReportSettings_args = ReportSettings_args  { reportSettings_args_syncOpRevision :: I.Int64
  , reportSettings_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSettings_args_syncOpRevision record   `H.hashWithSalt` reportSettings_args_settings record  
instance QC.Arbitrary ReportSettings_args where 
  arbitrary = M.liftM ReportSettings_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSettings_args{reportSettings_args_syncOpRevision = reportSettings_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportSettings_args{reportSettings_args_syncOpRevision = reportSettings_args_syncOpRevision obj}
    , if obj == default_ReportSettings_args{reportSettings_args_settings = reportSettings_args_settings obj} then P.Nothing else P.Just $ default_ReportSettings_args{reportSettings_args_settings = reportSettings_args_settings obj}
    ]
from_ReportSettings_args :: ReportSettings_args -> T.ThriftVal
from_ReportSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5638 -> P.Just (2, ("syncOpRevision",T.TI64 _v5638))) $ reportSettings_args_syncOpRevision record
  , (\_v5638 -> P.Just (3, ("settings",from_Settings _v5638))) $ reportSettings_args_settings record
  ]
write_ReportSettings_args :: T.Protocol p => p -> ReportSettings_args -> P.IO ()
write_ReportSettings_args oprot record = T.writeVal oprot $ from_ReportSettings_args record
encode_ReportSettings_args :: T.StatelessProtocol p => p -> ReportSettings_args -> LBS.ByteString
encode_ReportSettings_args oprot record = T.serializeVal oprot $ from_ReportSettings_args record
to_ReportSettings_args :: T.ThriftVal -> ReportSettings_args
to_ReportSettings_args (T.TStruct fields) = ReportSettings_args{
  reportSettings_args_syncOpRevision = P.maybe (reportSettings_args_syncOpRevision default_ReportSettings_args) (\(_,_val5640) -> (case _val5640 of {T.TI64 _val5641 -> _val5641; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSettings_args_settings = P.maybe (reportSettings_args_settings default_ReportSettings_args) (\(_,_val5640) -> (case _val5640 of {T.TStruct _val5642 -> (to_Settings (T.TStruct _val5642)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportSettings_args _ = P.error "not a struct"
read_ReportSettings_args :: T.Protocol p => p -> P.IO ReportSettings_args
read_ReportSettings_args iprot = to_ReportSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSettings_args)
decode_ReportSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSettings_args
decode_ReportSettings_args iprot bs = to_ReportSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSettings_args) bs
typemap_ReportSettings_args :: T.TypeMap
typemap_ReportSettings_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("settings",(T.T_STRUCT typemap_Settings)))]
default_ReportSettings_args :: ReportSettings_args
default_ReportSettings_args = ReportSettings_args{
  reportSettings_args_syncOpRevision = 0,
  reportSettings_args_settings = default_Settings}
data ReportSettings_result = ReportSettings_result  { reportSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSettings_result_e record  
instance QC.Arbitrary ReportSettings_result where 
  arbitrary = M.liftM ReportSettings_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSettings_result{reportSettings_result_e = reportSettings_result_e obj} then P.Nothing else P.Just $ default_ReportSettings_result{reportSettings_result_e = reportSettings_result_e obj}
    ]
from_ReportSettings_result :: ReportSettings_result -> T.ThriftVal
from_ReportSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5645 -> (1, ("e",from_TalkException _v5645))) <$> reportSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5645 -> (1, ("e",from_TalkException _v5645))) <$> reportSettings_result_e record
    ]
    )
write_ReportSettings_result :: T.Protocol p => p -> ReportSettings_result -> P.IO ()
write_ReportSettings_result oprot record = T.writeVal oprot $ from_ReportSettings_result record
encode_ReportSettings_result :: T.StatelessProtocol p => p -> ReportSettings_result -> LBS.ByteString
encode_ReportSettings_result oprot record = T.serializeVal oprot $ from_ReportSettings_result record
to_ReportSettings_result :: T.ThriftVal -> ReportSettings_result
to_ReportSettings_result (T.TStruct fields) = ReportSettings_result{
  reportSettings_result_e = P.maybe (P.Nothing) (\(_,_val5647) -> P.Just (case _val5647 of {T.TStruct _val5648 -> (to_TalkException (T.TStruct _val5648)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSettings_result _ = P.error "not a struct"
read_ReportSettings_result :: T.Protocol p => p -> P.IO ReportSettings_result
read_ReportSettings_result iprot = to_ReportSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSettings_result)
decode_ReportSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSettings_result
decode_ReportSettings_result iprot bs = to_ReportSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSettings_result) bs
typemap_ReportSettings_result :: T.TypeMap
typemap_ReportSettings_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportSettings_result :: ReportSettings_result
default_ReportSettings_result = ReportSettings_result{
  reportSettings_result_e = P.Nothing}
data ReportSpammer_args = ReportSpammer_args  { reportSpammer_args_spammerMid :: LT.Text
  , reportSpammer_args_spammerReasons :: (Vector.Vector SpammerReason)
  , reportSpammer_args_spamMessageIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSpammer_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSpammer_args_spammerMid record   `H.hashWithSalt` reportSpammer_args_spammerReasons record   `H.hashWithSalt` reportSpammer_args_spamMessageIds record  
instance QC.Arbitrary ReportSpammer_args where 
  arbitrary = M.liftM ReportSpammer_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSpammer_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSpammer_args{reportSpammer_args_spammerMid = reportSpammer_args_spammerMid obj} then P.Nothing else P.Just $ default_ReportSpammer_args{reportSpammer_args_spammerMid = reportSpammer_args_spammerMid obj}
    , if obj == default_ReportSpammer_args{reportSpammer_args_spammerReasons = reportSpammer_args_spammerReasons obj} then P.Nothing else P.Just $ default_ReportSpammer_args{reportSpammer_args_spammerReasons = reportSpammer_args_spammerReasons obj}
    , if obj == default_ReportSpammer_args{reportSpammer_args_spamMessageIds = reportSpammer_args_spamMessageIds obj} then P.Nothing else P.Just $ default_ReportSpammer_args{reportSpammer_args_spamMessageIds = reportSpammer_args_spamMessageIds obj}
    ]
from_ReportSpammer_args :: ReportSpammer_args -> T.ThriftVal
from_ReportSpammer_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5651 -> P.Just (2, ("spammerMid",T.TString $ E.encodeUtf8 _v5651))) $ reportSpammer_args_spammerMid record
  , (\_v5651 -> P.Just (3, ("spammerReasons",T.TList T.T_I32 $ P.map (\_v5653 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v5653) $ Vector.toList _v5651))) $ reportSpammer_args_spammerReasons record
  , (\_v5651 -> P.Just (4, ("spamMessageIds",T.TList T.T_STRING $ P.map (\_v5655 -> T.TString $ E.encodeUtf8 _v5655) $ Vector.toList _v5651))) $ reportSpammer_args_spamMessageIds record
  ]
write_ReportSpammer_args :: T.Protocol p => p -> ReportSpammer_args -> P.IO ()
write_ReportSpammer_args oprot record = T.writeVal oprot $ from_ReportSpammer_args record
encode_ReportSpammer_args :: T.StatelessProtocol p => p -> ReportSpammer_args -> LBS.ByteString
encode_ReportSpammer_args oprot record = T.serializeVal oprot $ from_ReportSpammer_args record
to_ReportSpammer_args :: T.ThriftVal -> ReportSpammer_args
to_ReportSpammer_args (T.TStruct fields) = ReportSpammer_args{
  reportSpammer_args_spammerMid = P.maybe (reportSpammer_args_spammerMid default_ReportSpammer_args) (\(_,_val5657) -> (case _val5657 of {T.TString _val5658 -> E.decodeUtf8 _val5658; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSpammer_args_spammerReasons = P.maybe (reportSpammer_args_spammerReasons default_ReportSpammer_args) (\(_,_val5657) -> (case _val5657 of {T.TList _ _val5659 -> (Vector.fromList $ P.map (\_v5660 -> (case _v5660 of {T.TI32 _val5661 -> P.toEnum $ P.fromIntegral _val5661; _ -> P.error "wrong type"})) _val5659); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportSpammer_args_spamMessageIds = P.maybe (reportSpammer_args_spamMessageIds default_ReportSpammer_args) (\(_,_val5657) -> (case _val5657 of {T.TList _ _val5662 -> (Vector.fromList $ P.map (\_v5663 -> (case _v5663 of {T.TString _val5664 -> E.decodeUtf8 _val5664; _ -> P.error "wrong type"})) _val5662); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ReportSpammer_args _ = P.error "not a struct"
read_ReportSpammer_args :: T.Protocol p => p -> P.IO ReportSpammer_args
read_ReportSpammer_args iprot = to_ReportSpammer_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSpammer_args)
decode_ReportSpammer_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSpammer_args
decode_ReportSpammer_args iprot bs = to_ReportSpammer_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSpammer_args) bs
typemap_ReportSpammer_args :: T.TypeMap
typemap_ReportSpammer_args = Map.fromList [(2,("spammerMid",T.T_STRING)),(3,("spammerReasons",(T.T_LIST T.T_I32))),(4,("spamMessageIds",(T.T_LIST T.T_STRING)))]
default_ReportSpammer_args :: ReportSpammer_args
default_ReportSpammer_args = ReportSpammer_args{
  reportSpammer_args_spammerMid = "",
  reportSpammer_args_spammerReasons = Vector.empty,
  reportSpammer_args_spamMessageIds = Vector.empty}
data ReportSpammer_result = ReportSpammer_result  { reportSpammer_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSpammer_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSpammer_result_e record  
instance QC.Arbitrary ReportSpammer_result where 
  arbitrary = M.liftM ReportSpammer_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSpammer_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSpammer_result{reportSpammer_result_e = reportSpammer_result_e obj} then P.Nothing else P.Just $ default_ReportSpammer_result{reportSpammer_result_e = reportSpammer_result_e obj}
    ]
from_ReportSpammer_result :: ReportSpammer_result -> T.ThriftVal
from_ReportSpammer_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5667 -> (1, ("e",from_TalkException _v5667))) <$> reportSpammer_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5667 -> (1, ("e",from_TalkException _v5667))) <$> reportSpammer_result_e record
    ]
    )
write_ReportSpammer_result :: T.Protocol p => p -> ReportSpammer_result -> P.IO ()
write_ReportSpammer_result oprot record = T.writeVal oprot $ from_ReportSpammer_result record
encode_ReportSpammer_result :: T.StatelessProtocol p => p -> ReportSpammer_result -> LBS.ByteString
encode_ReportSpammer_result oprot record = T.serializeVal oprot $ from_ReportSpammer_result record
to_ReportSpammer_result :: T.ThriftVal -> ReportSpammer_result
to_ReportSpammer_result (T.TStruct fields) = ReportSpammer_result{
  reportSpammer_result_e = P.maybe (P.Nothing) (\(_,_val5669) -> P.Just (case _val5669 of {T.TStruct _val5670 -> (to_TalkException (T.TStruct _val5670)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSpammer_result _ = P.error "not a struct"
read_ReportSpammer_result :: T.Protocol p => p -> P.IO ReportSpammer_result
read_ReportSpammer_result iprot = to_ReportSpammer_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSpammer_result)
decode_ReportSpammer_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSpammer_result
decode_ReportSpammer_result iprot bs = to_ReportSpammer_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSpammer_result) bs
typemap_ReportSpammer_result :: T.TypeMap
typemap_ReportSpammer_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportSpammer_result :: ReportSpammer_result
default_ReportSpammer_result = ReportSpammer_result{
  reportSpammer_result_e = P.Nothing}
data RequestAccountPasswordReset_args = RequestAccountPasswordReset_args  { requestAccountPasswordReset_args_provider :: IdentityProvider
  , requestAccountPasswordReset_args_identifier :: LT.Text
  , requestAccountPasswordReset_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestAccountPasswordReset_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestAccountPasswordReset_args_provider record   `H.hashWithSalt` requestAccountPasswordReset_args_identifier record   `H.hashWithSalt` requestAccountPasswordReset_args_locale record  
instance QC.Arbitrary RequestAccountPasswordReset_args where 
  arbitrary = M.liftM RequestAccountPasswordReset_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestAccountPasswordReset_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_provider = requestAccountPasswordReset_args_provider obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_provider = requestAccountPasswordReset_args_provider obj}
    , if obj == default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_identifier = requestAccountPasswordReset_args_identifier obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_identifier = requestAccountPasswordReset_args_identifier obj}
    , if obj == default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_locale = requestAccountPasswordReset_args_locale obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_locale = requestAccountPasswordReset_args_locale obj}
    ]
from_RequestAccountPasswordReset_args :: RequestAccountPasswordReset_args -> T.ThriftVal
from_RequestAccountPasswordReset_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5673 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v5673))) $ requestAccountPasswordReset_args_identifier record
  , (\_v5673 -> P.Just (4, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v5673))) $ requestAccountPasswordReset_args_provider record
  , (\_v5673 -> P.Just (5, ("locale",T.TString $ E.encodeUtf8 _v5673))) $ requestAccountPasswordReset_args_locale record
  ]
write_RequestAccountPasswordReset_args :: T.Protocol p => p -> RequestAccountPasswordReset_args -> P.IO ()
write_RequestAccountPasswordReset_args oprot record = T.writeVal oprot $ from_RequestAccountPasswordReset_args record
encode_RequestAccountPasswordReset_args :: T.StatelessProtocol p => p -> RequestAccountPasswordReset_args -> LBS.ByteString
encode_RequestAccountPasswordReset_args oprot record = T.serializeVal oprot $ from_RequestAccountPasswordReset_args record
to_RequestAccountPasswordReset_args :: T.ThriftVal -> RequestAccountPasswordReset_args
to_RequestAccountPasswordReset_args (T.TStruct fields) = RequestAccountPasswordReset_args{
  requestAccountPasswordReset_args_provider = P.maybe (requestAccountPasswordReset_args_provider default_RequestAccountPasswordReset_args) (\(_,_val5675) -> (case _val5675 of {T.TI32 _val5676 -> P.toEnum $ P.fromIntegral _val5676; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  requestAccountPasswordReset_args_identifier = P.maybe (requestAccountPasswordReset_args_identifier default_RequestAccountPasswordReset_args) (\(_,_val5675) -> (case _val5675 of {T.TString _val5677 -> E.decodeUtf8 _val5677; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  requestAccountPasswordReset_args_locale = P.maybe (requestAccountPasswordReset_args_locale default_RequestAccountPasswordReset_args) (\(_,_val5675) -> (case _val5675 of {T.TString _val5678 -> E.decodeUtf8 _val5678; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RequestAccountPasswordReset_args _ = P.error "not a struct"
read_RequestAccountPasswordReset_args :: T.Protocol p => p -> P.IO RequestAccountPasswordReset_args
read_RequestAccountPasswordReset_args iprot = to_RequestAccountPasswordReset_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_args)
decode_RequestAccountPasswordReset_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestAccountPasswordReset_args
decode_RequestAccountPasswordReset_args iprot bs = to_RequestAccountPasswordReset_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_args) bs
typemap_RequestAccountPasswordReset_args :: T.TypeMap
typemap_RequestAccountPasswordReset_args = Map.fromList [(2,("identifier",T.T_STRING)),(4,("provider",T.T_I32)),(5,("locale",T.T_STRING))]
default_RequestAccountPasswordReset_args :: RequestAccountPasswordReset_args
default_RequestAccountPasswordReset_args = RequestAccountPasswordReset_args{
  requestAccountPasswordReset_args_identifier = "",
  requestAccountPasswordReset_args_provider = (P.toEnum 0),
  requestAccountPasswordReset_args_locale = ""}
data RequestAccountPasswordReset_result = RequestAccountPasswordReset_result  { requestAccountPasswordReset_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestAccountPasswordReset_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestAccountPasswordReset_result_e record  
instance QC.Arbitrary RequestAccountPasswordReset_result where 
  arbitrary = M.liftM RequestAccountPasswordReset_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestAccountPasswordReset_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestAccountPasswordReset_result{requestAccountPasswordReset_result_e = requestAccountPasswordReset_result_e obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_result{requestAccountPasswordReset_result_e = requestAccountPasswordReset_result_e obj}
    ]
from_RequestAccountPasswordReset_result :: RequestAccountPasswordReset_result -> T.ThriftVal
from_RequestAccountPasswordReset_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5681 -> (1, ("e",from_TalkException _v5681))) <$> requestAccountPasswordReset_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5681 -> (1, ("e",from_TalkException _v5681))) <$> requestAccountPasswordReset_result_e record
    ]
    )
write_RequestAccountPasswordReset_result :: T.Protocol p => p -> RequestAccountPasswordReset_result -> P.IO ()
write_RequestAccountPasswordReset_result oprot record = T.writeVal oprot $ from_RequestAccountPasswordReset_result record
encode_RequestAccountPasswordReset_result :: T.StatelessProtocol p => p -> RequestAccountPasswordReset_result -> LBS.ByteString
encode_RequestAccountPasswordReset_result oprot record = T.serializeVal oprot $ from_RequestAccountPasswordReset_result record
to_RequestAccountPasswordReset_result :: T.ThriftVal -> RequestAccountPasswordReset_result
to_RequestAccountPasswordReset_result (T.TStruct fields) = RequestAccountPasswordReset_result{
  requestAccountPasswordReset_result_e = P.maybe (P.Nothing) (\(_,_val5683) -> P.Just (case _val5683 of {T.TStruct _val5684 -> (to_TalkException (T.TStruct _val5684)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestAccountPasswordReset_result _ = P.error "not a struct"
read_RequestAccountPasswordReset_result :: T.Protocol p => p -> P.IO RequestAccountPasswordReset_result
read_RequestAccountPasswordReset_result iprot = to_RequestAccountPasswordReset_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_result)
decode_RequestAccountPasswordReset_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestAccountPasswordReset_result
decode_RequestAccountPasswordReset_result iprot bs = to_RequestAccountPasswordReset_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_result) bs
typemap_RequestAccountPasswordReset_result :: T.TypeMap
typemap_RequestAccountPasswordReset_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestAccountPasswordReset_result :: RequestAccountPasswordReset_result
default_RequestAccountPasswordReset_result = RequestAccountPasswordReset_result{
  requestAccountPasswordReset_result_e = P.Nothing}
data RequestEmailConfirmation_args = RequestEmailConfirmation_args  { requestEmailConfirmation_args_emailConfirmation :: EmailConfirmation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestEmailConfirmation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestEmailConfirmation_args_emailConfirmation record  
instance QC.Arbitrary RequestEmailConfirmation_args where 
  arbitrary = M.liftM RequestEmailConfirmation_args (QC.arbitrary)
  shrink obj | obj == default_RequestEmailConfirmation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestEmailConfirmation_args{requestEmailConfirmation_args_emailConfirmation = requestEmailConfirmation_args_emailConfirmation obj} then P.Nothing else P.Just $ default_RequestEmailConfirmation_args{requestEmailConfirmation_args_emailConfirmation = requestEmailConfirmation_args_emailConfirmation obj}
    ]
from_RequestEmailConfirmation_args :: RequestEmailConfirmation_args -> T.ThriftVal
from_RequestEmailConfirmation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5687 -> P.Just (2, ("emailConfirmation",from_EmailConfirmation _v5687))) $ requestEmailConfirmation_args_emailConfirmation record
  ]
write_RequestEmailConfirmation_args :: T.Protocol p => p -> RequestEmailConfirmation_args -> P.IO ()
write_RequestEmailConfirmation_args oprot record = T.writeVal oprot $ from_RequestEmailConfirmation_args record
encode_RequestEmailConfirmation_args :: T.StatelessProtocol p => p -> RequestEmailConfirmation_args -> LBS.ByteString
encode_RequestEmailConfirmation_args oprot record = T.serializeVal oprot $ from_RequestEmailConfirmation_args record
to_RequestEmailConfirmation_args :: T.ThriftVal -> RequestEmailConfirmation_args
to_RequestEmailConfirmation_args (T.TStruct fields) = RequestEmailConfirmation_args{
  requestEmailConfirmation_args_emailConfirmation = P.maybe (requestEmailConfirmation_args_emailConfirmation default_RequestEmailConfirmation_args) (\(_,_val5689) -> (case _val5689 of {T.TStruct _val5690 -> (to_EmailConfirmation (T.TStruct _val5690)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RequestEmailConfirmation_args _ = P.error "not a struct"
read_RequestEmailConfirmation_args :: T.Protocol p => p -> P.IO RequestEmailConfirmation_args
read_RequestEmailConfirmation_args iprot = to_RequestEmailConfirmation_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_args)
decode_RequestEmailConfirmation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestEmailConfirmation_args
decode_RequestEmailConfirmation_args iprot bs = to_RequestEmailConfirmation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_args) bs
typemap_RequestEmailConfirmation_args :: T.TypeMap
typemap_RequestEmailConfirmation_args = Map.fromList [(2,("emailConfirmation",(T.T_STRUCT typemap_EmailConfirmation)))]
default_RequestEmailConfirmation_args :: RequestEmailConfirmation_args
default_RequestEmailConfirmation_args = RequestEmailConfirmation_args{
  requestEmailConfirmation_args_emailConfirmation = default_EmailConfirmation}
data RequestEmailConfirmation_result = RequestEmailConfirmation_result  { requestEmailConfirmation_result_success :: EmailConfirmationSession
  , requestEmailConfirmation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestEmailConfirmation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestEmailConfirmation_result_success record   `H.hashWithSalt` requestEmailConfirmation_result_e record  
instance QC.Arbitrary RequestEmailConfirmation_result where 
  arbitrary = M.liftM RequestEmailConfirmation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestEmailConfirmation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestEmailConfirmation_result{requestEmailConfirmation_result_success = requestEmailConfirmation_result_success obj} then P.Nothing else P.Just $ default_RequestEmailConfirmation_result{requestEmailConfirmation_result_success = requestEmailConfirmation_result_success obj}
    , if obj == default_RequestEmailConfirmation_result{requestEmailConfirmation_result_e = requestEmailConfirmation_result_e obj} then P.Nothing else P.Just $ default_RequestEmailConfirmation_result{requestEmailConfirmation_result_e = requestEmailConfirmation_result_e obj}
    ]
from_RequestEmailConfirmation_result :: RequestEmailConfirmation_result -> T.ThriftVal
from_RequestEmailConfirmation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5693 -> (1, ("e",from_TalkException _v5693))) <$> requestEmailConfirmation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5693 -> P.Just (0, ("success",from_EmailConfirmationSession _v5693))) $ requestEmailConfirmation_result_success record
    , (\_v5693 -> (1, ("e",from_TalkException _v5693))) <$> requestEmailConfirmation_result_e record
    ]
    )
write_RequestEmailConfirmation_result :: T.Protocol p => p -> RequestEmailConfirmation_result -> P.IO ()
write_RequestEmailConfirmation_result oprot record = T.writeVal oprot $ from_RequestEmailConfirmation_result record
encode_RequestEmailConfirmation_result :: T.StatelessProtocol p => p -> RequestEmailConfirmation_result -> LBS.ByteString
encode_RequestEmailConfirmation_result oprot record = T.serializeVal oprot $ from_RequestEmailConfirmation_result record
to_RequestEmailConfirmation_result :: T.ThriftVal -> RequestEmailConfirmation_result
to_RequestEmailConfirmation_result (T.TStruct fields) = RequestEmailConfirmation_result{
  requestEmailConfirmation_result_success = P.maybe (requestEmailConfirmation_result_success default_RequestEmailConfirmation_result) (\(_,_val5695) -> (case _val5695 of {T.TStruct _val5696 -> (to_EmailConfirmationSession (T.TStruct _val5696)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  requestEmailConfirmation_result_e = P.maybe (P.Nothing) (\(_,_val5695) -> P.Just (case _val5695 of {T.TStruct _val5697 -> (to_TalkException (T.TStruct _val5697)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestEmailConfirmation_result _ = P.error "not a struct"
read_RequestEmailConfirmation_result :: T.Protocol p => p -> P.IO RequestEmailConfirmation_result
read_RequestEmailConfirmation_result iprot = to_RequestEmailConfirmation_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_result)
decode_RequestEmailConfirmation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestEmailConfirmation_result
decode_RequestEmailConfirmation_result iprot bs = to_RequestEmailConfirmation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_result) bs
typemap_RequestEmailConfirmation_result :: T.TypeMap
typemap_RequestEmailConfirmation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_EmailConfirmationSession))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestEmailConfirmation_result :: RequestEmailConfirmation_result
default_RequestEmailConfirmation_result = RequestEmailConfirmation_result{
  requestEmailConfirmation_result_success = default_EmailConfirmationSession,
  requestEmailConfirmation_result_e = P.Nothing}
data RequestIdentityUnbind_args = RequestIdentityUnbind_args  { requestIdentityUnbind_args_provider :: IdentityProvider
  , requestIdentityUnbind_args_identifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestIdentityUnbind_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestIdentityUnbind_args_provider record   `H.hashWithSalt` requestIdentityUnbind_args_identifier record  
instance QC.Arbitrary RequestIdentityUnbind_args where 
  arbitrary = M.liftM RequestIdentityUnbind_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestIdentityUnbind_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestIdentityUnbind_args{requestIdentityUnbind_args_provider = requestIdentityUnbind_args_provider obj} then P.Nothing else P.Just $ default_RequestIdentityUnbind_args{requestIdentityUnbind_args_provider = requestIdentityUnbind_args_provider obj}
    , if obj == default_RequestIdentityUnbind_args{requestIdentityUnbind_args_identifier = requestIdentityUnbind_args_identifier obj} then P.Nothing else P.Just $ default_RequestIdentityUnbind_args{requestIdentityUnbind_args_identifier = requestIdentityUnbind_args_identifier obj}
    ]
from_RequestIdentityUnbind_args :: RequestIdentityUnbind_args -> T.ThriftVal
from_RequestIdentityUnbind_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5700 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v5700))) $ requestIdentityUnbind_args_identifier record
  , (\_v5700 -> P.Just (4, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v5700))) $ requestIdentityUnbind_args_provider record
  ]
write_RequestIdentityUnbind_args :: T.Protocol p => p -> RequestIdentityUnbind_args -> P.IO ()
write_RequestIdentityUnbind_args oprot record = T.writeVal oprot $ from_RequestIdentityUnbind_args record
encode_RequestIdentityUnbind_args :: T.StatelessProtocol p => p -> RequestIdentityUnbind_args -> LBS.ByteString
encode_RequestIdentityUnbind_args oprot record = T.serializeVal oprot $ from_RequestIdentityUnbind_args record
to_RequestIdentityUnbind_args :: T.ThriftVal -> RequestIdentityUnbind_args
to_RequestIdentityUnbind_args (T.TStruct fields) = RequestIdentityUnbind_args{
  requestIdentityUnbind_args_provider = P.maybe (requestIdentityUnbind_args_provider default_RequestIdentityUnbind_args) (\(_,_val5702) -> (case _val5702 of {T.TI32 _val5703 -> P.toEnum $ P.fromIntegral _val5703; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  requestIdentityUnbind_args_identifier = P.maybe (requestIdentityUnbind_args_identifier default_RequestIdentityUnbind_args) (\(_,_val5702) -> (case _val5702 of {T.TString _val5704 -> E.decodeUtf8 _val5704; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RequestIdentityUnbind_args _ = P.error "not a struct"
read_RequestIdentityUnbind_args :: T.Protocol p => p -> P.IO RequestIdentityUnbind_args
read_RequestIdentityUnbind_args iprot = to_RequestIdentityUnbind_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_args)
decode_RequestIdentityUnbind_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestIdentityUnbind_args
decode_RequestIdentityUnbind_args iprot bs = to_RequestIdentityUnbind_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_args) bs
typemap_RequestIdentityUnbind_args :: T.TypeMap
typemap_RequestIdentityUnbind_args = Map.fromList [(2,("identifier",T.T_STRING)),(4,("provider",T.T_I32))]
default_RequestIdentityUnbind_args :: RequestIdentityUnbind_args
default_RequestIdentityUnbind_args = RequestIdentityUnbind_args{
  requestIdentityUnbind_args_identifier = "",
  requestIdentityUnbind_args_provider = (P.toEnum 0)}
data RequestIdentityUnbind_result = RequestIdentityUnbind_result  { requestIdentityUnbind_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestIdentityUnbind_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestIdentityUnbind_result_e record  
instance QC.Arbitrary RequestIdentityUnbind_result where 
  arbitrary = M.liftM RequestIdentityUnbind_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestIdentityUnbind_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestIdentityUnbind_result{requestIdentityUnbind_result_e = requestIdentityUnbind_result_e obj} then P.Nothing else P.Just $ default_RequestIdentityUnbind_result{requestIdentityUnbind_result_e = requestIdentityUnbind_result_e obj}
    ]
from_RequestIdentityUnbind_result :: RequestIdentityUnbind_result -> T.ThriftVal
from_RequestIdentityUnbind_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5707 -> (1, ("e",from_TalkException _v5707))) <$> requestIdentityUnbind_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5707 -> (1, ("e",from_TalkException _v5707))) <$> requestIdentityUnbind_result_e record
    ]
    )
write_RequestIdentityUnbind_result :: T.Protocol p => p -> RequestIdentityUnbind_result -> P.IO ()
write_RequestIdentityUnbind_result oprot record = T.writeVal oprot $ from_RequestIdentityUnbind_result record
encode_RequestIdentityUnbind_result :: T.StatelessProtocol p => p -> RequestIdentityUnbind_result -> LBS.ByteString
encode_RequestIdentityUnbind_result oprot record = T.serializeVal oprot $ from_RequestIdentityUnbind_result record
to_RequestIdentityUnbind_result :: T.ThriftVal -> RequestIdentityUnbind_result
to_RequestIdentityUnbind_result (T.TStruct fields) = RequestIdentityUnbind_result{
  requestIdentityUnbind_result_e = P.maybe (P.Nothing) (\(_,_val5709) -> P.Just (case _val5709 of {T.TStruct _val5710 -> (to_TalkException (T.TStruct _val5710)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestIdentityUnbind_result _ = P.error "not a struct"
read_RequestIdentityUnbind_result :: T.Protocol p => p -> P.IO RequestIdentityUnbind_result
read_RequestIdentityUnbind_result iprot = to_RequestIdentityUnbind_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_result)
decode_RequestIdentityUnbind_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestIdentityUnbind_result
decode_RequestIdentityUnbind_result iprot bs = to_RequestIdentityUnbind_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_result) bs
typemap_RequestIdentityUnbind_result :: T.TypeMap
typemap_RequestIdentityUnbind_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestIdentityUnbind_result :: RequestIdentityUnbind_result
default_RequestIdentityUnbind_result = RequestIdentityUnbind_result{
  requestIdentityUnbind_result_e = P.Nothing}
data ResendEmailConfirmation_args = ResendEmailConfirmation_args  { resendEmailConfirmation_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendEmailConfirmation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendEmailConfirmation_args_verifier record  
instance QC.Arbitrary ResendEmailConfirmation_args where 
  arbitrary = M.liftM ResendEmailConfirmation_args (QC.arbitrary)
  shrink obj | obj == default_ResendEmailConfirmation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendEmailConfirmation_args{resendEmailConfirmation_args_verifier = resendEmailConfirmation_args_verifier obj} then P.Nothing else P.Just $ default_ResendEmailConfirmation_args{resendEmailConfirmation_args_verifier = resendEmailConfirmation_args_verifier obj}
    ]
from_ResendEmailConfirmation_args :: ResendEmailConfirmation_args -> T.ThriftVal
from_ResendEmailConfirmation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5713 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v5713))) $ resendEmailConfirmation_args_verifier record
  ]
write_ResendEmailConfirmation_args :: T.Protocol p => p -> ResendEmailConfirmation_args -> P.IO ()
write_ResendEmailConfirmation_args oprot record = T.writeVal oprot $ from_ResendEmailConfirmation_args record
encode_ResendEmailConfirmation_args :: T.StatelessProtocol p => p -> ResendEmailConfirmation_args -> LBS.ByteString
encode_ResendEmailConfirmation_args oprot record = T.serializeVal oprot $ from_ResendEmailConfirmation_args record
to_ResendEmailConfirmation_args :: T.ThriftVal -> ResendEmailConfirmation_args
to_ResendEmailConfirmation_args (T.TStruct fields) = ResendEmailConfirmation_args{
  resendEmailConfirmation_args_verifier = P.maybe (resendEmailConfirmation_args_verifier default_ResendEmailConfirmation_args) (\(_,_val5715) -> (case _val5715 of {T.TString _val5716 -> E.decodeUtf8 _val5716; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ResendEmailConfirmation_args _ = P.error "not a struct"
read_ResendEmailConfirmation_args :: T.Protocol p => p -> P.IO ResendEmailConfirmation_args
read_ResendEmailConfirmation_args iprot = to_ResendEmailConfirmation_args <$> T.readVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_args)
decode_ResendEmailConfirmation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendEmailConfirmation_args
decode_ResendEmailConfirmation_args iprot bs = to_ResendEmailConfirmation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_args) bs
typemap_ResendEmailConfirmation_args :: T.TypeMap
typemap_ResendEmailConfirmation_args = Map.fromList [(2,("verifier",T.T_STRING))]
default_ResendEmailConfirmation_args :: ResendEmailConfirmation_args
default_ResendEmailConfirmation_args = ResendEmailConfirmation_args{
  resendEmailConfirmation_args_verifier = ""}
data ResendEmailConfirmation_result = ResendEmailConfirmation_result  { resendEmailConfirmation_result_success :: EmailConfirmationSession
  , resendEmailConfirmation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendEmailConfirmation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendEmailConfirmation_result_success record   `H.hashWithSalt` resendEmailConfirmation_result_e record  
instance QC.Arbitrary ResendEmailConfirmation_result where 
  arbitrary = M.liftM ResendEmailConfirmation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ResendEmailConfirmation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendEmailConfirmation_result{resendEmailConfirmation_result_success = resendEmailConfirmation_result_success obj} then P.Nothing else P.Just $ default_ResendEmailConfirmation_result{resendEmailConfirmation_result_success = resendEmailConfirmation_result_success obj}
    , if obj == default_ResendEmailConfirmation_result{resendEmailConfirmation_result_e = resendEmailConfirmation_result_e obj} then P.Nothing else P.Just $ default_ResendEmailConfirmation_result{resendEmailConfirmation_result_e = resendEmailConfirmation_result_e obj}
    ]
from_ResendEmailConfirmation_result :: ResendEmailConfirmation_result -> T.ThriftVal
from_ResendEmailConfirmation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5719 -> (1, ("e",from_TalkException _v5719))) <$> resendEmailConfirmation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5719 -> P.Just (0, ("success",from_EmailConfirmationSession _v5719))) $ resendEmailConfirmation_result_success record
    , (\_v5719 -> (1, ("e",from_TalkException _v5719))) <$> resendEmailConfirmation_result_e record
    ]
    )
write_ResendEmailConfirmation_result :: T.Protocol p => p -> ResendEmailConfirmation_result -> P.IO ()
write_ResendEmailConfirmation_result oprot record = T.writeVal oprot $ from_ResendEmailConfirmation_result record
encode_ResendEmailConfirmation_result :: T.StatelessProtocol p => p -> ResendEmailConfirmation_result -> LBS.ByteString
encode_ResendEmailConfirmation_result oprot record = T.serializeVal oprot $ from_ResendEmailConfirmation_result record
to_ResendEmailConfirmation_result :: T.ThriftVal -> ResendEmailConfirmation_result
to_ResendEmailConfirmation_result (T.TStruct fields) = ResendEmailConfirmation_result{
  resendEmailConfirmation_result_success = P.maybe (resendEmailConfirmation_result_success default_ResendEmailConfirmation_result) (\(_,_val5721) -> (case _val5721 of {T.TStruct _val5722 -> (to_EmailConfirmationSession (T.TStruct _val5722)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  resendEmailConfirmation_result_e = P.maybe (P.Nothing) (\(_,_val5721) -> P.Just (case _val5721 of {T.TStruct _val5723 -> (to_TalkException (T.TStruct _val5723)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ResendEmailConfirmation_result _ = P.error "not a struct"
read_ResendEmailConfirmation_result :: T.Protocol p => p -> P.IO ResendEmailConfirmation_result
read_ResendEmailConfirmation_result iprot = to_ResendEmailConfirmation_result <$> T.readVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_result)
decode_ResendEmailConfirmation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendEmailConfirmation_result
decode_ResendEmailConfirmation_result iprot bs = to_ResendEmailConfirmation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_result) bs
typemap_ResendEmailConfirmation_result :: T.TypeMap
typemap_ResendEmailConfirmation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_EmailConfirmationSession))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ResendEmailConfirmation_result :: ResendEmailConfirmation_result
default_ResendEmailConfirmation_result = ResendEmailConfirmation_result{
  resendEmailConfirmation_result_success = default_EmailConfirmationSession,
  resendEmailConfirmation_result_e = P.Nothing}
data ResendPinCode_args = ResendPinCode_args  { resendPinCode_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCode_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCode_args_sessionId record  
instance QC.Arbitrary ResendPinCode_args where 
  arbitrary = M.liftM ResendPinCode_args (QC.arbitrary)
  shrink obj | obj == default_ResendPinCode_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCode_args{resendPinCode_args_sessionId = resendPinCode_args_sessionId obj} then P.Nothing else P.Just $ default_ResendPinCode_args{resendPinCode_args_sessionId = resendPinCode_args_sessionId obj}
    ]
from_ResendPinCode_args :: ResendPinCode_args -> T.ThriftVal
from_ResendPinCode_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5726 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v5726))) $ resendPinCode_args_sessionId record
  ]
write_ResendPinCode_args :: T.Protocol p => p -> ResendPinCode_args -> P.IO ()
write_ResendPinCode_args oprot record = T.writeVal oprot $ from_ResendPinCode_args record
encode_ResendPinCode_args :: T.StatelessProtocol p => p -> ResendPinCode_args -> LBS.ByteString
encode_ResendPinCode_args oprot record = T.serializeVal oprot $ from_ResendPinCode_args record
to_ResendPinCode_args :: T.ThriftVal -> ResendPinCode_args
to_ResendPinCode_args (T.TStruct fields) = ResendPinCode_args{
  resendPinCode_args_sessionId = P.maybe (resendPinCode_args_sessionId default_ResendPinCode_args) (\(_,_val5728) -> (case _val5728 of {T.TString _val5729 -> E.decodeUtf8 _val5729; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ResendPinCode_args _ = P.error "not a struct"
read_ResendPinCode_args :: T.Protocol p => p -> P.IO ResendPinCode_args
read_ResendPinCode_args iprot = to_ResendPinCode_args <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCode_args)
decode_ResendPinCode_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCode_args
decode_ResendPinCode_args iprot bs = to_ResendPinCode_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCode_args) bs
typemap_ResendPinCode_args :: T.TypeMap
typemap_ResendPinCode_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_ResendPinCode_args :: ResendPinCode_args
default_ResendPinCode_args = ResendPinCode_args{
  resendPinCode_args_sessionId = ""}
data ResendPinCode_result = ResendPinCode_result  { resendPinCode_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCode_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCode_result_e record  
instance QC.Arbitrary ResendPinCode_result where 
  arbitrary = M.liftM ResendPinCode_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ResendPinCode_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCode_result{resendPinCode_result_e = resendPinCode_result_e obj} then P.Nothing else P.Just $ default_ResendPinCode_result{resendPinCode_result_e = resendPinCode_result_e obj}
    ]
from_ResendPinCode_result :: ResendPinCode_result -> T.ThriftVal
from_ResendPinCode_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5732 -> (1, ("e",from_TalkException _v5732))) <$> resendPinCode_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5732 -> (1, ("e",from_TalkException _v5732))) <$> resendPinCode_result_e record
    ]
    )
write_ResendPinCode_result :: T.Protocol p => p -> ResendPinCode_result -> P.IO ()
write_ResendPinCode_result oprot record = T.writeVal oprot $ from_ResendPinCode_result record
encode_ResendPinCode_result :: T.StatelessProtocol p => p -> ResendPinCode_result -> LBS.ByteString
encode_ResendPinCode_result oprot record = T.serializeVal oprot $ from_ResendPinCode_result record
to_ResendPinCode_result :: T.ThriftVal -> ResendPinCode_result
to_ResendPinCode_result (T.TStruct fields) = ResendPinCode_result{
  resendPinCode_result_e = P.maybe (P.Nothing) (\(_,_val5734) -> P.Just (case _val5734 of {T.TStruct _val5735 -> (to_TalkException (T.TStruct _val5735)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ResendPinCode_result _ = P.error "not a struct"
read_ResendPinCode_result :: T.Protocol p => p -> P.IO ResendPinCode_result
read_ResendPinCode_result iprot = to_ResendPinCode_result <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCode_result)
decode_ResendPinCode_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCode_result
decode_ResendPinCode_result iprot bs = to_ResendPinCode_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCode_result) bs
typemap_ResendPinCode_result :: T.TypeMap
typemap_ResendPinCode_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ResendPinCode_result :: ResendPinCode_result
default_ResendPinCode_result = ResendPinCode_result{
  resendPinCode_result_e = P.Nothing}
data ResendPinCodeBySMS_args = ResendPinCodeBySMS_args  { resendPinCodeBySMS_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCodeBySMS_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCodeBySMS_args_sessionId record  
instance QC.Arbitrary ResendPinCodeBySMS_args where 
  arbitrary = M.liftM ResendPinCodeBySMS_args (QC.arbitrary)
  shrink obj | obj == default_ResendPinCodeBySMS_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCodeBySMS_args{resendPinCodeBySMS_args_sessionId = resendPinCodeBySMS_args_sessionId obj} then P.Nothing else P.Just $ default_ResendPinCodeBySMS_args{resendPinCodeBySMS_args_sessionId = resendPinCodeBySMS_args_sessionId obj}
    ]
from_ResendPinCodeBySMS_args :: ResendPinCodeBySMS_args -> T.ThriftVal
from_ResendPinCodeBySMS_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5738 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v5738))) $ resendPinCodeBySMS_args_sessionId record
  ]
write_ResendPinCodeBySMS_args :: T.Protocol p => p -> ResendPinCodeBySMS_args -> P.IO ()
write_ResendPinCodeBySMS_args oprot record = T.writeVal oprot $ from_ResendPinCodeBySMS_args record
encode_ResendPinCodeBySMS_args :: T.StatelessProtocol p => p -> ResendPinCodeBySMS_args -> LBS.ByteString
encode_ResendPinCodeBySMS_args oprot record = T.serializeVal oprot $ from_ResendPinCodeBySMS_args record
to_ResendPinCodeBySMS_args :: T.ThriftVal -> ResendPinCodeBySMS_args
to_ResendPinCodeBySMS_args (T.TStruct fields) = ResendPinCodeBySMS_args{
  resendPinCodeBySMS_args_sessionId = P.maybe (resendPinCodeBySMS_args_sessionId default_ResendPinCodeBySMS_args) (\(_,_val5740) -> (case _val5740 of {T.TString _val5741 -> E.decodeUtf8 _val5741; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ResendPinCodeBySMS_args _ = P.error "not a struct"
read_ResendPinCodeBySMS_args :: T.Protocol p => p -> P.IO ResendPinCodeBySMS_args
read_ResendPinCodeBySMS_args iprot = to_ResendPinCodeBySMS_args <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_args)
decode_ResendPinCodeBySMS_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCodeBySMS_args
decode_ResendPinCodeBySMS_args iprot bs = to_ResendPinCodeBySMS_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_args) bs
typemap_ResendPinCodeBySMS_args :: T.TypeMap
typemap_ResendPinCodeBySMS_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_ResendPinCodeBySMS_args :: ResendPinCodeBySMS_args
default_ResendPinCodeBySMS_args = ResendPinCodeBySMS_args{
  resendPinCodeBySMS_args_sessionId = ""}
data ResendPinCodeBySMS_result = ResendPinCodeBySMS_result  { resendPinCodeBySMS_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCodeBySMS_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCodeBySMS_result_e record  
instance QC.Arbitrary ResendPinCodeBySMS_result where 
  arbitrary = M.liftM ResendPinCodeBySMS_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ResendPinCodeBySMS_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCodeBySMS_result{resendPinCodeBySMS_result_e = resendPinCodeBySMS_result_e obj} then P.Nothing else P.Just $ default_ResendPinCodeBySMS_result{resendPinCodeBySMS_result_e = resendPinCodeBySMS_result_e obj}
    ]
from_ResendPinCodeBySMS_result :: ResendPinCodeBySMS_result -> T.ThriftVal
from_ResendPinCodeBySMS_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5744 -> (1, ("e",from_TalkException _v5744))) <$> resendPinCodeBySMS_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5744 -> (1, ("e",from_TalkException _v5744))) <$> resendPinCodeBySMS_result_e record
    ]
    )
write_ResendPinCodeBySMS_result :: T.Protocol p => p -> ResendPinCodeBySMS_result -> P.IO ()
write_ResendPinCodeBySMS_result oprot record = T.writeVal oprot $ from_ResendPinCodeBySMS_result record
encode_ResendPinCodeBySMS_result :: T.StatelessProtocol p => p -> ResendPinCodeBySMS_result -> LBS.ByteString
encode_ResendPinCodeBySMS_result oprot record = T.serializeVal oprot $ from_ResendPinCodeBySMS_result record
to_ResendPinCodeBySMS_result :: T.ThriftVal -> ResendPinCodeBySMS_result
to_ResendPinCodeBySMS_result (T.TStruct fields) = ResendPinCodeBySMS_result{
  resendPinCodeBySMS_result_e = P.maybe (P.Nothing) (\(_,_val5746) -> P.Just (case _val5746 of {T.TStruct _val5747 -> (to_TalkException (T.TStruct _val5747)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ResendPinCodeBySMS_result _ = P.error "not a struct"
read_ResendPinCodeBySMS_result :: T.Protocol p => p -> P.IO ResendPinCodeBySMS_result
read_ResendPinCodeBySMS_result iprot = to_ResendPinCodeBySMS_result <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_result)
decode_ResendPinCodeBySMS_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCodeBySMS_result
decode_ResendPinCodeBySMS_result iprot bs = to_ResendPinCodeBySMS_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_result) bs
typemap_ResendPinCodeBySMS_result :: T.TypeMap
typemap_ResendPinCodeBySMS_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ResendPinCodeBySMS_result :: ResendPinCodeBySMS_result
default_ResendPinCodeBySMS_result = ResendPinCodeBySMS_result{
  resendPinCodeBySMS_result_e = P.Nothing}
data SendChatChecked_args = SendChatChecked_args  { sendChatChecked_args_seq :: I.Int32
  , sendChatChecked_args_consumer :: LT.Text
  , sendChatChecked_args_lastMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatChecked_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatChecked_args_seq record   `H.hashWithSalt` sendChatChecked_args_consumer record   `H.hashWithSalt` sendChatChecked_args_lastMessageId record  
instance QC.Arbitrary SendChatChecked_args where 
  arbitrary = M.liftM SendChatChecked_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendChatChecked_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatChecked_args{sendChatChecked_args_seq = sendChatChecked_args_seq obj} then P.Nothing else P.Just $ default_SendChatChecked_args{sendChatChecked_args_seq = sendChatChecked_args_seq obj}
    , if obj == default_SendChatChecked_args{sendChatChecked_args_consumer = sendChatChecked_args_consumer obj} then P.Nothing else P.Just $ default_SendChatChecked_args{sendChatChecked_args_consumer = sendChatChecked_args_consumer obj}
    , if obj == default_SendChatChecked_args{sendChatChecked_args_lastMessageId = sendChatChecked_args_lastMessageId obj} then P.Nothing else P.Just $ default_SendChatChecked_args{sendChatChecked_args_lastMessageId = sendChatChecked_args_lastMessageId obj}
    ]
from_SendChatChecked_args :: SendChatChecked_args -> T.ThriftVal
from_SendChatChecked_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5750 -> P.Just (1, ("seq",T.TI32 _v5750))) $ sendChatChecked_args_seq record
  , (\_v5750 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v5750))) $ sendChatChecked_args_consumer record
  , (\_v5750 -> P.Just (3, ("lastMessageId",T.TString $ E.encodeUtf8 _v5750))) $ sendChatChecked_args_lastMessageId record
  ]
write_SendChatChecked_args :: T.Protocol p => p -> SendChatChecked_args -> P.IO ()
write_SendChatChecked_args oprot record = T.writeVal oprot $ from_SendChatChecked_args record
encode_SendChatChecked_args :: T.StatelessProtocol p => p -> SendChatChecked_args -> LBS.ByteString
encode_SendChatChecked_args oprot record = T.serializeVal oprot $ from_SendChatChecked_args record
to_SendChatChecked_args :: T.ThriftVal -> SendChatChecked_args
to_SendChatChecked_args (T.TStruct fields) = SendChatChecked_args{
  sendChatChecked_args_seq = P.maybe (sendChatChecked_args_seq default_SendChatChecked_args) (\(_,_val5752) -> (case _val5752 of {T.TI32 _val5753 -> _val5753; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendChatChecked_args_consumer = P.maybe (sendChatChecked_args_consumer default_SendChatChecked_args) (\(_,_val5752) -> (case _val5752 of {T.TString _val5754 -> E.decodeUtf8 _val5754; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendChatChecked_args_lastMessageId = P.maybe (sendChatChecked_args_lastMessageId default_SendChatChecked_args) (\(_,_val5752) -> (case _val5752 of {T.TString _val5755 -> E.decodeUtf8 _val5755; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendChatChecked_args _ = P.error "not a struct"
read_SendChatChecked_args :: T.Protocol p => p -> P.IO SendChatChecked_args
read_SendChatChecked_args iprot = to_SendChatChecked_args <$> T.readVal iprot (T.T_STRUCT typemap_SendChatChecked_args)
decode_SendChatChecked_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatChecked_args
decode_SendChatChecked_args iprot bs = to_SendChatChecked_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatChecked_args) bs
typemap_SendChatChecked_args :: T.TypeMap
typemap_SendChatChecked_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("lastMessageId",T.T_STRING))]
default_SendChatChecked_args :: SendChatChecked_args
default_SendChatChecked_args = SendChatChecked_args{
  sendChatChecked_args_seq = 0,
  sendChatChecked_args_consumer = "",
  sendChatChecked_args_lastMessageId = ""}
data SendChatChecked_result = SendChatChecked_result  { sendChatChecked_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatChecked_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatChecked_result_e record  
instance QC.Arbitrary SendChatChecked_result where 
  arbitrary = M.liftM SendChatChecked_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendChatChecked_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatChecked_result{sendChatChecked_result_e = sendChatChecked_result_e obj} then P.Nothing else P.Just $ default_SendChatChecked_result{sendChatChecked_result_e = sendChatChecked_result_e obj}
    ]
from_SendChatChecked_result :: SendChatChecked_result -> T.ThriftVal
from_SendChatChecked_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5758 -> (1, ("e",from_TalkException _v5758))) <$> sendChatChecked_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5758 -> (1, ("e",from_TalkException _v5758))) <$> sendChatChecked_result_e record
    ]
    )
write_SendChatChecked_result :: T.Protocol p => p -> SendChatChecked_result -> P.IO ()
write_SendChatChecked_result oprot record = T.writeVal oprot $ from_SendChatChecked_result record
encode_SendChatChecked_result :: T.StatelessProtocol p => p -> SendChatChecked_result -> LBS.ByteString
encode_SendChatChecked_result oprot record = T.serializeVal oprot $ from_SendChatChecked_result record
to_SendChatChecked_result :: T.ThriftVal -> SendChatChecked_result
to_SendChatChecked_result (T.TStruct fields) = SendChatChecked_result{
  sendChatChecked_result_e = P.maybe (P.Nothing) (\(_,_val5760) -> P.Just (case _val5760 of {T.TStruct _val5761 -> (to_TalkException (T.TStruct _val5761)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendChatChecked_result _ = P.error "not a struct"
read_SendChatChecked_result :: T.Protocol p => p -> P.IO SendChatChecked_result
read_SendChatChecked_result iprot = to_SendChatChecked_result <$> T.readVal iprot (T.T_STRUCT typemap_SendChatChecked_result)
decode_SendChatChecked_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatChecked_result
decode_SendChatChecked_result iprot bs = to_SendChatChecked_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatChecked_result) bs
typemap_SendChatChecked_result :: T.TypeMap
typemap_SendChatChecked_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendChatChecked_result :: SendChatChecked_result
default_SendChatChecked_result = SendChatChecked_result{
  sendChatChecked_result_e = P.Nothing}
data SendChatRemoved_args = SendChatRemoved_args  { sendChatRemoved_args_seq :: I.Int32
  , sendChatRemoved_args_consumer :: LT.Text
  , sendChatRemoved_args_lastMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatRemoved_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatRemoved_args_seq record   `H.hashWithSalt` sendChatRemoved_args_consumer record   `H.hashWithSalt` sendChatRemoved_args_lastMessageId record  
instance QC.Arbitrary SendChatRemoved_args where 
  arbitrary = M.liftM SendChatRemoved_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendChatRemoved_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatRemoved_args{sendChatRemoved_args_seq = sendChatRemoved_args_seq obj} then P.Nothing else P.Just $ default_SendChatRemoved_args{sendChatRemoved_args_seq = sendChatRemoved_args_seq obj}
    , if obj == default_SendChatRemoved_args{sendChatRemoved_args_consumer = sendChatRemoved_args_consumer obj} then P.Nothing else P.Just $ default_SendChatRemoved_args{sendChatRemoved_args_consumer = sendChatRemoved_args_consumer obj}
    , if obj == default_SendChatRemoved_args{sendChatRemoved_args_lastMessageId = sendChatRemoved_args_lastMessageId obj} then P.Nothing else P.Just $ default_SendChatRemoved_args{sendChatRemoved_args_lastMessageId = sendChatRemoved_args_lastMessageId obj}
    ]
from_SendChatRemoved_args :: SendChatRemoved_args -> T.ThriftVal
from_SendChatRemoved_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5764 -> P.Just (1, ("seq",T.TI32 _v5764))) $ sendChatRemoved_args_seq record
  , (\_v5764 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v5764))) $ sendChatRemoved_args_consumer record
  , (\_v5764 -> P.Just (3, ("lastMessageId",T.TString $ E.encodeUtf8 _v5764))) $ sendChatRemoved_args_lastMessageId record
  ]
write_SendChatRemoved_args :: T.Protocol p => p -> SendChatRemoved_args -> P.IO ()
write_SendChatRemoved_args oprot record = T.writeVal oprot $ from_SendChatRemoved_args record
encode_SendChatRemoved_args :: T.StatelessProtocol p => p -> SendChatRemoved_args -> LBS.ByteString
encode_SendChatRemoved_args oprot record = T.serializeVal oprot $ from_SendChatRemoved_args record
to_SendChatRemoved_args :: T.ThriftVal -> SendChatRemoved_args
to_SendChatRemoved_args (T.TStruct fields) = SendChatRemoved_args{
  sendChatRemoved_args_seq = P.maybe (sendChatRemoved_args_seq default_SendChatRemoved_args) (\(_,_val5766) -> (case _val5766 of {T.TI32 _val5767 -> _val5767; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendChatRemoved_args_consumer = P.maybe (sendChatRemoved_args_consumer default_SendChatRemoved_args) (\(_,_val5766) -> (case _val5766 of {T.TString _val5768 -> E.decodeUtf8 _val5768; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendChatRemoved_args_lastMessageId = P.maybe (sendChatRemoved_args_lastMessageId default_SendChatRemoved_args) (\(_,_val5766) -> (case _val5766 of {T.TString _val5769 -> E.decodeUtf8 _val5769; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendChatRemoved_args _ = P.error "not a struct"
read_SendChatRemoved_args :: T.Protocol p => p -> P.IO SendChatRemoved_args
read_SendChatRemoved_args iprot = to_SendChatRemoved_args <$> T.readVal iprot (T.T_STRUCT typemap_SendChatRemoved_args)
decode_SendChatRemoved_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatRemoved_args
decode_SendChatRemoved_args iprot bs = to_SendChatRemoved_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatRemoved_args) bs
typemap_SendChatRemoved_args :: T.TypeMap
typemap_SendChatRemoved_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("lastMessageId",T.T_STRING))]
default_SendChatRemoved_args :: SendChatRemoved_args
default_SendChatRemoved_args = SendChatRemoved_args{
  sendChatRemoved_args_seq = 0,
  sendChatRemoved_args_consumer = "",
  sendChatRemoved_args_lastMessageId = ""}
data SendChatRemoved_result = SendChatRemoved_result  { sendChatRemoved_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatRemoved_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatRemoved_result_e record  
instance QC.Arbitrary SendChatRemoved_result where 
  arbitrary = M.liftM SendChatRemoved_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendChatRemoved_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatRemoved_result{sendChatRemoved_result_e = sendChatRemoved_result_e obj} then P.Nothing else P.Just $ default_SendChatRemoved_result{sendChatRemoved_result_e = sendChatRemoved_result_e obj}
    ]
from_SendChatRemoved_result :: SendChatRemoved_result -> T.ThriftVal
from_SendChatRemoved_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5772 -> (1, ("e",from_TalkException _v5772))) <$> sendChatRemoved_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5772 -> (1, ("e",from_TalkException _v5772))) <$> sendChatRemoved_result_e record
    ]
    )
write_SendChatRemoved_result :: T.Protocol p => p -> SendChatRemoved_result -> P.IO ()
write_SendChatRemoved_result oprot record = T.writeVal oprot $ from_SendChatRemoved_result record
encode_SendChatRemoved_result :: T.StatelessProtocol p => p -> SendChatRemoved_result -> LBS.ByteString
encode_SendChatRemoved_result oprot record = T.serializeVal oprot $ from_SendChatRemoved_result record
to_SendChatRemoved_result :: T.ThriftVal -> SendChatRemoved_result
to_SendChatRemoved_result (T.TStruct fields) = SendChatRemoved_result{
  sendChatRemoved_result_e = P.maybe (P.Nothing) (\(_,_val5774) -> P.Just (case _val5774 of {T.TStruct _val5775 -> (to_TalkException (T.TStruct _val5775)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendChatRemoved_result _ = P.error "not a struct"
read_SendChatRemoved_result :: T.Protocol p => p -> P.IO SendChatRemoved_result
read_SendChatRemoved_result iprot = to_SendChatRemoved_result <$> T.readVal iprot (T.T_STRUCT typemap_SendChatRemoved_result)
decode_SendChatRemoved_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatRemoved_result
decode_SendChatRemoved_result iprot bs = to_SendChatRemoved_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatRemoved_result) bs
typemap_SendChatRemoved_result :: T.TypeMap
typemap_SendChatRemoved_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendChatRemoved_result :: SendChatRemoved_result
default_SendChatRemoved_result = SendChatRemoved_result{
  sendChatRemoved_result_e = P.Nothing}
data SendContentPreviewUpdated_args = SendContentPreviewUpdated_args  { sendContentPreviewUpdated_args_esq :: I.Int32
  , sendContentPreviewUpdated_args_messageId :: LT.Text
  , sendContentPreviewUpdated_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentPreviewUpdated_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentPreviewUpdated_args_esq record   `H.hashWithSalt` sendContentPreviewUpdated_args_messageId record   `H.hashWithSalt` sendContentPreviewUpdated_args_receiverMids record  
instance QC.Arbitrary SendContentPreviewUpdated_args where 
  arbitrary = M.liftM SendContentPreviewUpdated_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendContentPreviewUpdated_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_esq = sendContentPreviewUpdated_args_esq obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_esq = sendContentPreviewUpdated_args_esq obj}
    , if obj == default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_messageId = sendContentPreviewUpdated_args_messageId obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_messageId = sendContentPreviewUpdated_args_messageId obj}
    , if obj == default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_receiverMids = sendContentPreviewUpdated_args_receiverMids obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_receiverMids = sendContentPreviewUpdated_args_receiverMids obj}
    ]
from_SendContentPreviewUpdated_args :: SendContentPreviewUpdated_args -> T.ThriftVal
from_SendContentPreviewUpdated_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5778 -> P.Just (1, ("esq",T.TI32 _v5778))) $ sendContentPreviewUpdated_args_esq record
  , (\_v5778 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v5778))) $ sendContentPreviewUpdated_args_messageId record
  , (\_v5778 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v5780 -> T.TString $ E.encodeUtf8 _v5780) $ Vector.toList _v5778))) $ sendContentPreviewUpdated_args_receiverMids record
  ]
write_SendContentPreviewUpdated_args :: T.Protocol p => p -> SendContentPreviewUpdated_args -> P.IO ()
write_SendContentPreviewUpdated_args oprot record = T.writeVal oprot $ from_SendContentPreviewUpdated_args record
encode_SendContentPreviewUpdated_args :: T.StatelessProtocol p => p -> SendContentPreviewUpdated_args -> LBS.ByteString
encode_SendContentPreviewUpdated_args oprot record = T.serializeVal oprot $ from_SendContentPreviewUpdated_args record
to_SendContentPreviewUpdated_args :: T.ThriftVal -> SendContentPreviewUpdated_args
to_SendContentPreviewUpdated_args (T.TStruct fields) = SendContentPreviewUpdated_args{
  sendContentPreviewUpdated_args_esq = P.maybe (sendContentPreviewUpdated_args_esq default_SendContentPreviewUpdated_args) (\(_,_val5782) -> (case _val5782 of {T.TI32 _val5783 -> _val5783; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendContentPreviewUpdated_args_messageId = P.maybe (sendContentPreviewUpdated_args_messageId default_SendContentPreviewUpdated_args) (\(_,_val5782) -> (case _val5782 of {T.TString _val5784 -> E.decodeUtf8 _val5784; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendContentPreviewUpdated_args_receiverMids = P.maybe (sendContentPreviewUpdated_args_receiverMids default_SendContentPreviewUpdated_args) (\(_,_val5782) -> (case _val5782 of {T.TList _ _val5785 -> (Vector.fromList $ P.map (\_v5786 -> (case _v5786 of {T.TString _val5787 -> E.decodeUtf8 _val5787; _ -> P.error "wrong type"})) _val5785); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendContentPreviewUpdated_args _ = P.error "not a struct"
read_SendContentPreviewUpdated_args :: T.Protocol p => p -> P.IO SendContentPreviewUpdated_args
read_SendContentPreviewUpdated_args iprot = to_SendContentPreviewUpdated_args <$> T.readVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_args)
decode_SendContentPreviewUpdated_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentPreviewUpdated_args
decode_SendContentPreviewUpdated_args iprot bs = to_SendContentPreviewUpdated_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_args) bs
typemap_SendContentPreviewUpdated_args :: T.TypeMap
typemap_SendContentPreviewUpdated_args = Map.fromList [(1,("esq",T.T_I32)),(2,("messageId",T.T_STRING)),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_SendContentPreviewUpdated_args :: SendContentPreviewUpdated_args
default_SendContentPreviewUpdated_args = SendContentPreviewUpdated_args{
  sendContentPreviewUpdated_args_esq = 0,
  sendContentPreviewUpdated_args_messageId = "",
  sendContentPreviewUpdated_args_receiverMids = Vector.empty}
data SendContentPreviewUpdated_result = SendContentPreviewUpdated_result  { sendContentPreviewUpdated_result_success :: (Map.HashMap LT.Text LT.Text)
  , sendContentPreviewUpdated_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentPreviewUpdated_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentPreviewUpdated_result_success record   `H.hashWithSalt` sendContentPreviewUpdated_result_e record  
instance QC.Arbitrary SendContentPreviewUpdated_result where 
  arbitrary = M.liftM SendContentPreviewUpdated_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendContentPreviewUpdated_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_success = sendContentPreviewUpdated_result_success obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_success = sendContentPreviewUpdated_result_success obj}
    , if obj == default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_e = sendContentPreviewUpdated_result_e obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_e = sendContentPreviewUpdated_result_e obj}
    ]
from_SendContentPreviewUpdated_result :: SendContentPreviewUpdated_result -> T.ThriftVal
from_SendContentPreviewUpdated_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5790 -> (1, ("e",from_TalkException _v5790))) <$> sendContentPreviewUpdated_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5790 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k5791,_v5792) -> (T.TString $ E.encodeUtf8 _k5791, T.TString $ E.encodeUtf8 _v5792)) $ Map.toList _v5790))) $ sendContentPreviewUpdated_result_success record
    , (\_v5790 -> (1, ("e",from_TalkException _v5790))) <$> sendContentPreviewUpdated_result_e record
    ]
    )
write_SendContentPreviewUpdated_result :: T.Protocol p => p -> SendContentPreviewUpdated_result -> P.IO ()
write_SendContentPreviewUpdated_result oprot record = T.writeVal oprot $ from_SendContentPreviewUpdated_result record
encode_SendContentPreviewUpdated_result :: T.StatelessProtocol p => p -> SendContentPreviewUpdated_result -> LBS.ByteString
encode_SendContentPreviewUpdated_result oprot record = T.serializeVal oprot $ from_SendContentPreviewUpdated_result record
to_SendContentPreviewUpdated_result :: T.ThriftVal -> SendContentPreviewUpdated_result
to_SendContentPreviewUpdated_result (T.TStruct fields) = SendContentPreviewUpdated_result{
  sendContentPreviewUpdated_result_success = P.maybe (sendContentPreviewUpdated_result_success default_SendContentPreviewUpdated_result) (\(_,_val5794) -> (case _val5794 of {T.TMap _ _ _val5795 -> (Map.fromList $ P.map (\(_k5797,_v5796) -> ((case _k5797 of {T.TString _val5798 -> E.decodeUtf8 _val5798; _ -> P.error "wrong type"}),(case _v5796 of {T.TString _val5799 -> E.decodeUtf8 _val5799; _ -> P.error "wrong type"}))) _val5795); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendContentPreviewUpdated_result_e = P.maybe (P.Nothing) (\(_,_val5794) -> P.Just (case _val5794 of {T.TStruct _val5800 -> (to_TalkException (T.TStruct _val5800)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendContentPreviewUpdated_result _ = P.error "not a struct"
read_SendContentPreviewUpdated_result :: T.Protocol p => p -> P.IO SendContentPreviewUpdated_result
read_SendContentPreviewUpdated_result iprot = to_SendContentPreviewUpdated_result <$> T.readVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_result)
decode_SendContentPreviewUpdated_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentPreviewUpdated_result
decode_SendContentPreviewUpdated_result iprot bs = to_SendContentPreviewUpdated_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_result) bs
typemap_SendContentPreviewUpdated_result :: T.TypeMap
typemap_SendContentPreviewUpdated_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendContentPreviewUpdated_result :: SendContentPreviewUpdated_result
default_SendContentPreviewUpdated_result = SendContentPreviewUpdated_result{
  sendContentPreviewUpdated_result_success = Map.empty,
  sendContentPreviewUpdated_result_e = P.Nothing}
data SendContentReceipt_args = SendContentReceipt_args  { sendContentReceipt_args_seq :: I.Int32
  , sendContentReceipt_args_consumer :: LT.Text
  , sendContentReceipt_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentReceipt_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentReceipt_args_seq record   `H.hashWithSalt` sendContentReceipt_args_consumer record   `H.hashWithSalt` sendContentReceipt_args_messageId record  
instance QC.Arbitrary SendContentReceipt_args where 
  arbitrary = M.liftM SendContentReceipt_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendContentReceipt_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentReceipt_args{sendContentReceipt_args_seq = sendContentReceipt_args_seq obj} then P.Nothing else P.Just $ default_SendContentReceipt_args{sendContentReceipt_args_seq = sendContentReceipt_args_seq obj}
    , if obj == default_SendContentReceipt_args{sendContentReceipt_args_consumer = sendContentReceipt_args_consumer obj} then P.Nothing else P.Just $ default_SendContentReceipt_args{sendContentReceipt_args_consumer = sendContentReceipt_args_consumer obj}
    , if obj == default_SendContentReceipt_args{sendContentReceipt_args_messageId = sendContentReceipt_args_messageId obj} then P.Nothing else P.Just $ default_SendContentReceipt_args{sendContentReceipt_args_messageId = sendContentReceipt_args_messageId obj}
    ]
from_SendContentReceipt_args :: SendContentReceipt_args -> T.ThriftVal
from_SendContentReceipt_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5803 -> P.Just (1, ("seq",T.TI32 _v5803))) $ sendContentReceipt_args_seq record
  , (\_v5803 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v5803))) $ sendContentReceipt_args_consumer record
  , (\_v5803 -> P.Just (3, ("messageId",T.TString $ E.encodeUtf8 _v5803))) $ sendContentReceipt_args_messageId record
  ]
write_SendContentReceipt_args :: T.Protocol p => p -> SendContentReceipt_args -> P.IO ()
write_SendContentReceipt_args oprot record = T.writeVal oprot $ from_SendContentReceipt_args record
encode_SendContentReceipt_args :: T.StatelessProtocol p => p -> SendContentReceipt_args -> LBS.ByteString
encode_SendContentReceipt_args oprot record = T.serializeVal oprot $ from_SendContentReceipt_args record
to_SendContentReceipt_args :: T.ThriftVal -> SendContentReceipt_args
to_SendContentReceipt_args (T.TStruct fields) = SendContentReceipt_args{
  sendContentReceipt_args_seq = P.maybe (sendContentReceipt_args_seq default_SendContentReceipt_args) (\(_,_val5805) -> (case _val5805 of {T.TI32 _val5806 -> _val5806; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendContentReceipt_args_consumer = P.maybe (sendContentReceipt_args_consumer default_SendContentReceipt_args) (\(_,_val5805) -> (case _val5805 of {T.TString _val5807 -> E.decodeUtf8 _val5807; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendContentReceipt_args_messageId = P.maybe (sendContentReceipt_args_messageId default_SendContentReceipt_args) (\(_,_val5805) -> (case _val5805 of {T.TString _val5808 -> E.decodeUtf8 _val5808; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendContentReceipt_args _ = P.error "not a struct"
read_SendContentReceipt_args :: T.Protocol p => p -> P.IO SendContentReceipt_args
read_SendContentReceipt_args iprot = to_SendContentReceipt_args <$> T.readVal iprot (T.T_STRUCT typemap_SendContentReceipt_args)
decode_SendContentReceipt_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentReceipt_args
decode_SendContentReceipt_args iprot bs = to_SendContentReceipt_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentReceipt_args) bs
typemap_SendContentReceipt_args :: T.TypeMap
typemap_SendContentReceipt_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("messageId",T.T_STRING))]
default_SendContentReceipt_args :: SendContentReceipt_args
default_SendContentReceipt_args = SendContentReceipt_args{
  sendContentReceipt_args_seq = 0,
  sendContentReceipt_args_consumer = "",
  sendContentReceipt_args_messageId = ""}
data SendContentReceipt_result = SendContentReceipt_result  { sendContentReceipt_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentReceipt_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentReceipt_result_e record  
instance QC.Arbitrary SendContentReceipt_result where 
  arbitrary = M.liftM SendContentReceipt_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendContentReceipt_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentReceipt_result{sendContentReceipt_result_e = sendContentReceipt_result_e obj} then P.Nothing else P.Just $ default_SendContentReceipt_result{sendContentReceipt_result_e = sendContentReceipt_result_e obj}
    ]
from_SendContentReceipt_result :: SendContentReceipt_result -> T.ThriftVal
from_SendContentReceipt_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5811 -> (1, ("e",from_TalkException _v5811))) <$> sendContentReceipt_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5811 -> (1, ("e",from_TalkException _v5811))) <$> sendContentReceipt_result_e record
    ]
    )
write_SendContentReceipt_result :: T.Protocol p => p -> SendContentReceipt_result -> P.IO ()
write_SendContentReceipt_result oprot record = T.writeVal oprot $ from_SendContentReceipt_result record
encode_SendContentReceipt_result :: T.StatelessProtocol p => p -> SendContentReceipt_result -> LBS.ByteString
encode_SendContentReceipt_result oprot record = T.serializeVal oprot $ from_SendContentReceipt_result record
to_SendContentReceipt_result :: T.ThriftVal -> SendContentReceipt_result
to_SendContentReceipt_result (T.TStruct fields) = SendContentReceipt_result{
  sendContentReceipt_result_e = P.maybe (P.Nothing) (\(_,_val5813) -> P.Just (case _val5813 of {T.TStruct _val5814 -> (to_TalkException (T.TStruct _val5814)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendContentReceipt_result _ = P.error "not a struct"
read_SendContentReceipt_result :: T.Protocol p => p -> P.IO SendContentReceipt_result
read_SendContentReceipt_result iprot = to_SendContentReceipt_result <$> T.readVal iprot (T.T_STRUCT typemap_SendContentReceipt_result)
decode_SendContentReceipt_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentReceipt_result
decode_SendContentReceipt_result iprot bs = to_SendContentReceipt_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentReceipt_result) bs
typemap_SendContentReceipt_result :: T.TypeMap
typemap_SendContentReceipt_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendContentReceipt_result :: SendContentReceipt_result
default_SendContentReceipt_result = SendContentReceipt_result{
  sendContentReceipt_result_e = P.Nothing}
data SendDummyPush_args = SendDummyPush_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendDummyPush_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary SendDummyPush_args where 
  arbitrary = QC.elements [SendDummyPush_args]
from_SendDummyPush_args :: SendDummyPush_args -> T.ThriftVal
from_SendDummyPush_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_SendDummyPush_args :: T.Protocol p => p -> SendDummyPush_args -> P.IO ()
write_SendDummyPush_args oprot record = T.writeVal oprot $ from_SendDummyPush_args record
encode_SendDummyPush_args :: T.StatelessProtocol p => p -> SendDummyPush_args -> LBS.ByteString
encode_SendDummyPush_args oprot record = T.serializeVal oprot $ from_SendDummyPush_args record
to_SendDummyPush_args :: T.ThriftVal -> SendDummyPush_args
to_SendDummyPush_args (T.TStruct fields) = SendDummyPush_args{

  }
to_SendDummyPush_args _ = P.error "not a struct"
read_SendDummyPush_args :: T.Protocol p => p -> P.IO SendDummyPush_args
read_SendDummyPush_args iprot = to_SendDummyPush_args <$> T.readVal iprot (T.T_STRUCT typemap_SendDummyPush_args)
decode_SendDummyPush_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendDummyPush_args
decode_SendDummyPush_args iprot bs = to_SendDummyPush_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendDummyPush_args) bs
typemap_SendDummyPush_args :: T.TypeMap
typemap_SendDummyPush_args = Map.fromList []
default_SendDummyPush_args :: SendDummyPush_args
default_SendDummyPush_args = SendDummyPush_args{
}
data SendDummyPush_result = SendDummyPush_result  { sendDummyPush_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendDummyPush_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendDummyPush_result_e record  
instance QC.Arbitrary SendDummyPush_result where 
  arbitrary = M.liftM SendDummyPush_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendDummyPush_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendDummyPush_result{sendDummyPush_result_e = sendDummyPush_result_e obj} then P.Nothing else P.Just $ default_SendDummyPush_result{sendDummyPush_result_e = sendDummyPush_result_e obj}
    ]
from_SendDummyPush_result :: SendDummyPush_result -> T.ThriftVal
from_SendDummyPush_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5822 -> (1, ("e",from_TalkException _v5822))) <$> sendDummyPush_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5822 -> (1, ("e",from_TalkException _v5822))) <$> sendDummyPush_result_e record
    ]
    )
write_SendDummyPush_result :: T.Protocol p => p -> SendDummyPush_result -> P.IO ()
write_SendDummyPush_result oprot record = T.writeVal oprot $ from_SendDummyPush_result record
encode_SendDummyPush_result :: T.StatelessProtocol p => p -> SendDummyPush_result -> LBS.ByteString
encode_SendDummyPush_result oprot record = T.serializeVal oprot $ from_SendDummyPush_result record
to_SendDummyPush_result :: T.ThriftVal -> SendDummyPush_result
to_SendDummyPush_result (T.TStruct fields) = SendDummyPush_result{
  sendDummyPush_result_e = P.maybe (P.Nothing) (\(_,_val5824) -> P.Just (case _val5824 of {T.TStruct _val5825 -> (to_TalkException (T.TStruct _val5825)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendDummyPush_result _ = P.error "not a struct"
read_SendDummyPush_result :: T.Protocol p => p -> P.IO SendDummyPush_result
read_SendDummyPush_result iprot = to_SendDummyPush_result <$> T.readVal iprot (T.T_STRUCT typemap_SendDummyPush_result)
decode_SendDummyPush_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendDummyPush_result
decode_SendDummyPush_result iprot bs = to_SendDummyPush_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendDummyPush_result) bs
typemap_SendDummyPush_result :: T.TypeMap
typemap_SendDummyPush_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendDummyPush_result :: SendDummyPush_result
default_SendDummyPush_result = SendDummyPush_result{
  sendDummyPush_result_e = P.Nothing}
data SendEvent_args = SendEvent_args  { sendEvent_args_seq :: I.Int32
  , sendEvent_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendEvent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendEvent_args_seq record   `H.hashWithSalt` sendEvent_args_message record  
instance QC.Arbitrary SendEvent_args where 
  arbitrary = M.liftM SendEvent_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendEvent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendEvent_args{sendEvent_args_seq = sendEvent_args_seq obj} then P.Nothing else P.Just $ default_SendEvent_args{sendEvent_args_seq = sendEvent_args_seq obj}
    , if obj == default_SendEvent_args{sendEvent_args_message = sendEvent_args_message obj} then P.Nothing else P.Just $ default_SendEvent_args{sendEvent_args_message = sendEvent_args_message obj}
    ]
from_SendEvent_args :: SendEvent_args -> T.ThriftVal
from_SendEvent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5828 -> P.Just (1, ("seq",T.TI32 _v5828))) $ sendEvent_args_seq record
  , (\_v5828 -> P.Just (2, ("message",from_Message _v5828))) $ sendEvent_args_message record
  ]
write_SendEvent_args :: T.Protocol p => p -> SendEvent_args -> P.IO ()
write_SendEvent_args oprot record = T.writeVal oprot $ from_SendEvent_args record
encode_SendEvent_args :: T.StatelessProtocol p => p -> SendEvent_args -> LBS.ByteString
encode_SendEvent_args oprot record = T.serializeVal oprot $ from_SendEvent_args record
to_SendEvent_args :: T.ThriftVal -> SendEvent_args
to_SendEvent_args (T.TStruct fields) = SendEvent_args{
  sendEvent_args_seq = P.maybe (sendEvent_args_seq default_SendEvent_args) (\(_,_val5830) -> (case _val5830 of {T.TI32 _val5831 -> _val5831; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendEvent_args_message = P.maybe (sendEvent_args_message default_SendEvent_args) (\(_,_val5830) -> (case _val5830 of {T.TStruct _val5832 -> (to_Message (T.TStruct _val5832)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendEvent_args _ = P.error "not a struct"
read_SendEvent_args :: T.Protocol p => p -> P.IO SendEvent_args
read_SendEvent_args iprot = to_SendEvent_args <$> T.readVal iprot (T.T_STRUCT typemap_SendEvent_args)
decode_SendEvent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendEvent_args
decode_SendEvent_args iprot bs = to_SendEvent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendEvent_args) bs
typemap_SendEvent_args :: T.TypeMap
typemap_SendEvent_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendEvent_args :: SendEvent_args
default_SendEvent_args = SendEvent_args{
  sendEvent_args_seq = 0,
  sendEvent_args_message = default_Message}
data SendEvent_result = SendEvent_result  { sendEvent_result_success :: Message
  , sendEvent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendEvent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendEvent_result_success record   `H.hashWithSalt` sendEvent_result_e record  
instance QC.Arbitrary SendEvent_result where 
  arbitrary = M.liftM SendEvent_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendEvent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendEvent_result{sendEvent_result_success = sendEvent_result_success obj} then P.Nothing else P.Just $ default_SendEvent_result{sendEvent_result_success = sendEvent_result_success obj}
    , if obj == default_SendEvent_result{sendEvent_result_e = sendEvent_result_e obj} then P.Nothing else P.Just $ default_SendEvent_result{sendEvent_result_e = sendEvent_result_e obj}
    ]
from_SendEvent_result :: SendEvent_result -> T.ThriftVal
from_SendEvent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5835 -> (1, ("e",from_TalkException _v5835))) <$> sendEvent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5835 -> P.Just (0, ("success",from_Message _v5835))) $ sendEvent_result_success record
    , (\_v5835 -> (1, ("e",from_TalkException _v5835))) <$> sendEvent_result_e record
    ]
    )
write_SendEvent_result :: T.Protocol p => p -> SendEvent_result -> P.IO ()
write_SendEvent_result oprot record = T.writeVal oprot $ from_SendEvent_result record
encode_SendEvent_result :: T.StatelessProtocol p => p -> SendEvent_result -> LBS.ByteString
encode_SendEvent_result oprot record = T.serializeVal oprot $ from_SendEvent_result record
to_SendEvent_result :: T.ThriftVal -> SendEvent_result
to_SendEvent_result (T.TStruct fields) = SendEvent_result{
  sendEvent_result_success = P.maybe (sendEvent_result_success default_SendEvent_result) (\(_,_val5837) -> (case _val5837 of {T.TStruct _val5838 -> (to_Message (T.TStruct _val5838)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendEvent_result_e = P.maybe (P.Nothing) (\(_,_val5837) -> P.Just (case _val5837 of {T.TStruct _val5839 -> (to_TalkException (T.TStruct _val5839)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendEvent_result _ = P.error "not a struct"
read_SendEvent_result :: T.Protocol p => p -> P.IO SendEvent_result
read_SendEvent_result iprot = to_SendEvent_result <$> T.readVal iprot (T.T_STRUCT typemap_SendEvent_result)
decode_SendEvent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendEvent_result
decode_SendEvent_result iprot bs = to_SendEvent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendEvent_result) bs
typemap_SendEvent_result :: T.TypeMap
typemap_SendEvent_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendEvent_result :: SendEvent_result
default_SendEvent_result = SendEvent_result{
  sendEvent_result_success = default_Message,
  sendEvent_result_e = P.Nothing}
data SendMessage_args = SendMessage_args  { sendMessage_args_seq :: I.Int32
  , sendMessage_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessage_args_seq record   `H.hashWithSalt` sendMessage_args_message record  
instance QC.Arbitrary SendMessage_args where 
  arbitrary = M.liftM SendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessage_args{sendMessage_args_seq = sendMessage_args_seq obj} then P.Nothing else P.Just $ default_SendMessage_args{sendMessage_args_seq = sendMessage_args_seq obj}
    , if obj == default_SendMessage_args{sendMessage_args_message = sendMessage_args_message obj} then P.Nothing else P.Just $ default_SendMessage_args{sendMessage_args_message = sendMessage_args_message obj}
    ]
from_SendMessage_args :: SendMessage_args -> T.ThriftVal
from_SendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5842 -> P.Just (1, ("seq",T.TI32 _v5842))) $ sendMessage_args_seq record
  , (\_v5842 -> P.Just (2, ("message",from_Message _v5842))) $ sendMessage_args_message record
  ]
write_SendMessage_args :: T.Protocol p => p -> SendMessage_args -> P.IO ()
write_SendMessage_args oprot record = T.writeVal oprot $ from_SendMessage_args record
encode_SendMessage_args :: T.StatelessProtocol p => p -> SendMessage_args -> LBS.ByteString
encode_SendMessage_args oprot record = T.serializeVal oprot $ from_SendMessage_args record
to_SendMessage_args :: T.ThriftVal -> SendMessage_args
to_SendMessage_args (T.TStruct fields) = SendMessage_args{
  sendMessage_args_seq = P.maybe (sendMessage_args_seq default_SendMessage_args) (\(_,_val5844) -> (case _val5844 of {T.TI32 _val5845 -> _val5845; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessage_args_message = P.maybe (sendMessage_args_message default_SendMessage_args) (\(_,_val5844) -> (case _val5844 of {T.TStruct _val5846 -> (to_Message (T.TStruct _val5846)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessage_args _ = P.error "not a struct"
read_SendMessage_args :: T.Protocol p => p -> P.IO SendMessage_args
read_SendMessage_args iprot = to_SendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessage_args)
decode_SendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessage_args
decode_SendMessage_args iprot bs = to_SendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessage_args) bs
typemap_SendMessage_args :: T.TypeMap
typemap_SendMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessage_args :: SendMessage_args
default_SendMessage_args = SendMessage_args{
  sendMessage_args_seq = 0,
  sendMessage_args_message = default_Message}
data SendMessage_result = SendMessage_result  { sendMessage_result_success :: Message
  , sendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessage_result_success record   `H.hashWithSalt` sendMessage_result_e record  
instance QC.Arbitrary SendMessage_result where 
  arbitrary = M.liftM SendMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessage_result{sendMessage_result_success = sendMessage_result_success obj} then P.Nothing else P.Just $ default_SendMessage_result{sendMessage_result_success = sendMessage_result_success obj}
    , if obj == default_SendMessage_result{sendMessage_result_e = sendMessage_result_e obj} then P.Nothing else P.Just $ default_SendMessage_result{sendMessage_result_e = sendMessage_result_e obj}
    ]
from_SendMessage_result :: SendMessage_result -> T.ThriftVal
from_SendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5849 -> (1, ("e",from_TalkException _v5849))) <$> sendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5849 -> P.Just (0, ("success",from_Message _v5849))) $ sendMessage_result_success record
    , (\_v5849 -> (1, ("e",from_TalkException _v5849))) <$> sendMessage_result_e record
    ]
    )
write_SendMessage_result :: T.Protocol p => p -> SendMessage_result -> P.IO ()
write_SendMessage_result oprot record = T.writeVal oprot $ from_SendMessage_result record
encode_SendMessage_result :: T.StatelessProtocol p => p -> SendMessage_result -> LBS.ByteString
encode_SendMessage_result oprot record = T.serializeVal oprot $ from_SendMessage_result record
to_SendMessage_result :: T.ThriftVal -> SendMessage_result
to_SendMessage_result (T.TStruct fields) = SendMessage_result{
  sendMessage_result_success = P.maybe (sendMessage_result_success default_SendMessage_result) (\(_,_val5851) -> (case _val5851 of {T.TStruct _val5852 -> (to_Message (T.TStruct _val5852)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessage_result_e = P.maybe (P.Nothing) (\(_,_val5851) -> P.Just (case _val5851 of {T.TStruct _val5853 -> (to_TalkException (T.TStruct _val5853)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessage_result _ = P.error "not a struct"
read_SendMessage_result :: T.Protocol p => p -> P.IO SendMessage_result
read_SendMessage_result iprot = to_SendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessage_result)
decode_SendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessage_result
decode_SendMessage_result iprot bs = to_SendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessage_result) bs
typemap_SendMessage_result :: T.TypeMap
typemap_SendMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessage_result :: SendMessage_result
default_SendMessage_result = SendMessage_result{
  sendMessage_result_success = default_Message,
  sendMessage_result_e = P.Nothing}
data SendMessageIgnored_args = SendMessageIgnored_args  { sendMessageIgnored_args_seq :: I.Int32
  , sendMessageIgnored_args_consumer :: LT.Text
  , sendMessageIgnored_args_messageIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageIgnored_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageIgnored_args_seq record   `H.hashWithSalt` sendMessageIgnored_args_consumer record   `H.hashWithSalt` sendMessageIgnored_args_messageIds record  
instance QC.Arbitrary SendMessageIgnored_args where 
  arbitrary = M.liftM SendMessageIgnored_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageIgnored_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageIgnored_args{sendMessageIgnored_args_seq = sendMessageIgnored_args_seq obj} then P.Nothing else P.Just $ default_SendMessageIgnored_args{sendMessageIgnored_args_seq = sendMessageIgnored_args_seq obj}
    , if obj == default_SendMessageIgnored_args{sendMessageIgnored_args_consumer = sendMessageIgnored_args_consumer obj} then P.Nothing else P.Just $ default_SendMessageIgnored_args{sendMessageIgnored_args_consumer = sendMessageIgnored_args_consumer obj}
    , if obj == default_SendMessageIgnored_args{sendMessageIgnored_args_messageIds = sendMessageIgnored_args_messageIds obj} then P.Nothing else P.Just $ default_SendMessageIgnored_args{sendMessageIgnored_args_messageIds = sendMessageIgnored_args_messageIds obj}
    ]
from_SendMessageIgnored_args :: SendMessageIgnored_args -> T.ThriftVal
from_SendMessageIgnored_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5856 -> P.Just (1, ("seq",T.TI32 _v5856))) $ sendMessageIgnored_args_seq record
  , (\_v5856 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v5856))) $ sendMessageIgnored_args_consumer record
  , (\_v5856 -> P.Just (3, ("messageIds",T.TList T.T_STRING $ P.map (\_v5858 -> T.TString $ E.encodeUtf8 _v5858) $ Vector.toList _v5856))) $ sendMessageIgnored_args_messageIds record
  ]
write_SendMessageIgnored_args :: T.Protocol p => p -> SendMessageIgnored_args -> P.IO ()
write_SendMessageIgnored_args oprot record = T.writeVal oprot $ from_SendMessageIgnored_args record
encode_SendMessageIgnored_args :: T.StatelessProtocol p => p -> SendMessageIgnored_args -> LBS.ByteString
encode_SendMessageIgnored_args oprot record = T.serializeVal oprot $ from_SendMessageIgnored_args record
to_SendMessageIgnored_args :: T.ThriftVal -> SendMessageIgnored_args
to_SendMessageIgnored_args (T.TStruct fields) = SendMessageIgnored_args{
  sendMessageIgnored_args_seq = P.maybe (sendMessageIgnored_args_seq default_SendMessageIgnored_args) (\(_,_val5860) -> (case _val5860 of {T.TI32 _val5861 -> _val5861; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageIgnored_args_consumer = P.maybe (sendMessageIgnored_args_consumer default_SendMessageIgnored_args) (\(_,_val5860) -> (case _val5860 of {T.TString _val5862 -> E.decodeUtf8 _val5862; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendMessageIgnored_args_messageIds = P.maybe (sendMessageIgnored_args_messageIds default_SendMessageIgnored_args) (\(_,_val5860) -> (case _val5860 of {T.TList _ _val5863 -> (Vector.fromList $ P.map (\_v5864 -> (case _v5864 of {T.TString _val5865 -> E.decodeUtf8 _val5865; _ -> P.error "wrong type"})) _val5863); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendMessageIgnored_args _ = P.error "not a struct"
read_SendMessageIgnored_args :: T.Protocol p => p -> P.IO SendMessageIgnored_args
read_SendMessageIgnored_args iprot = to_SendMessageIgnored_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageIgnored_args)
decode_SendMessageIgnored_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageIgnored_args
decode_SendMessageIgnored_args iprot bs = to_SendMessageIgnored_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageIgnored_args) bs
typemap_SendMessageIgnored_args :: T.TypeMap
typemap_SendMessageIgnored_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("messageIds",(T.T_LIST T.T_STRING)))]
default_SendMessageIgnored_args :: SendMessageIgnored_args
default_SendMessageIgnored_args = SendMessageIgnored_args{
  sendMessageIgnored_args_seq = 0,
  sendMessageIgnored_args_consumer = "",
  sendMessageIgnored_args_messageIds = Vector.empty}
data SendMessageIgnored_result = SendMessageIgnored_result  { sendMessageIgnored_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageIgnored_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageIgnored_result_e record  
instance QC.Arbitrary SendMessageIgnored_result where 
  arbitrary = M.liftM SendMessageIgnored_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageIgnored_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageIgnored_result{sendMessageIgnored_result_e = sendMessageIgnored_result_e obj} then P.Nothing else P.Just $ default_SendMessageIgnored_result{sendMessageIgnored_result_e = sendMessageIgnored_result_e obj}
    ]
from_SendMessageIgnored_result :: SendMessageIgnored_result -> T.ThriftVal
from_SendMessageIgnored_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5868 -> (1, ("e",from_TalkException _v5868))) <$> sendMessageIgnored_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5868 -> (1, ("e",from_TalkException _v5868))) <$> sendMessageIgnored_result_e record
    ]
    )
write_SendMessageIgnored_result :: T.Protocol p => p -> SendMessageIgnored_result -> P.IO ()
write_SendMessageIgnored_result oprot record = T.writeVal oprot $ from_SendMessageIgnored_result record
encode_SendMessageIgnored_result :: T.StatelessProtocol p => p -> SendMessageIgnored_result -> LBS.ByteString
encode_SendMessageIgnored_result oprot record = T.serializeVal oprot $ from_SendMessageIgnored_result record
to_SendMessageIgnored_result :: T.ThriftVal -> SendMessageIgnored_result
to_SendMessageIgnored_result (T.TStruct fields) = SendMessageIgnored_result{
  sendMessageIgnored_result_e = P.maybe (P.Nothing) (\(_,_val5870) -> P.Just (case _val5870 of {T.TStruct _val5871 -> (to_TalkException (T.TStruct _val5871)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageIgnored_result _ = P.error "not a struct"
read_SendMessageIgnored_result :: T.Protocol p => p -> P.IO SendMessageIgnored_result
read_SendMessageIgnored_result iprot = to_SendMessageIgnored_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageIgnored_result)
decode_SendMessageIgnored_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageIgnored_result
decode_SendMessageIgnored_result iprot bs = to_SendMessageIgnored_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageIgnored_result) bs
typemap_SendMessageIgnored_result :: T.TypeMap
typemap_SendMessageIgnored_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageIgnored_result :: SendMessageIgnored_result
default_SendMessageIgnored_result = SendMessageIgnored_result{
  sendMessageIgnored_result_e = P.Nothing}
data SendMessageReceipt_args = SendMessageReceipt_args  { sendMessageReceipt_args_seq :: I.Int32
  , sendMessageReceipt_args_consumer :: LT.Text
  , sendMessageReceipt_args_messageIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageReceipt_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageReceipt_args_seq record   `H.hashWithSalt` sendMessageReceipt_args_consumer record   `H.hashWithSalt` sendMessageReceipt_args_messageIds record  
instance QC.Arbitrary SendMessageReceipt_args where 
  arbitrary = M.liftM SendMessageReceipt_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageReceipt_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageReceipt_args{sendMessageReceipt_args_seq = sendMessageReceipt_args_seq obj} then P.Nothing else P.Just $ default_SendMessageReceipt_args{sendMessageReceipt_args_seq = sendMessageReceipt_args_seq obj}
    , if obj == default_SendMessageReceipt_args{sendMessageReceipt_args_consumer = sendMessageReceipt_args_consumer obj} then P.Nothing else P.Just $ default_SendMessageReceipt_args{sendMessageReceipt_args_consumer = sendMessageReceipt_args_consumer obj}
    , if obj == default_SendMessageReceipt_args{sendMessageReceipt_args_messageIds = sendMessageReceipt_args_messageIds obj} then P.Nothing else P.Just $ default_SendMessageReceipt_args{sendMessageReceipt_args_messageIds = sendMessageReceipt_args_messageIds obj}
    ]
from_SendMessageReceipt_args :: SendMessageReceipt_args -> T.ThriftVal
from_SendMessageReceipt_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5874 -> P.Just (1, ("seq",T.TI32 _v5874))) $ sendMessageReceipt_args_seq record
  , (\_v5874 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v5874))) $ sendMessageReceipt_args_consumer record
  , (\_v5874 -> P.Just (3, ("messageIds",T.TList T.T_STRING $ P.map (\_v5876 -> T.TString $ E.encodeUtf8 _v5876) $ Vector.toList _v5874))) $ sendMessageReceipt_args_messageIds record
  ]
write_SendMessageReceipt_args :: T.Protocol p => p -> SendMessageReceipt_args -> P.IO ()
write_SendMessageReceipt_args oprot record = T.writeVal oprot $ from_SendMessageReceipt_args record
encode_SendMessageReceipt_args :: T.StatelessProtocol p => p -> SendMessageReceipt_args -> LBS.ByteString
encode_SendMessageReceipt_args oprot record = T.serializeVal oprot $ from_SendMessageReceipt_args record
to_SendMessageReceipt_args :: T.ThriftVal -> SendMessageReceipt_args
to_SendMessageReceipt_args (T.TStruct fields) = SendMessageReceipt_args{
  sendMessageReceipt_args_seq = P.maybe (sendMessageReceipt_args_seq default_SendMessageReceipt_args) (\(_,_val5878) -> (case _val5878 of {T.TI32 _val5879 -> _val5879; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageReceipt_args_consumer = P.maybe (sendMessageReceipt_args_consumer default_SendMessageReceipt_args) (\(_,_val5878) -> (case _val5878 of {T.TString _val5880 -> E.decodeUtf8 _val5880; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendMessageReceipt_args_messageIds = P.maybe (sendMessageReceipt_args_messageIds default_SendMessageReceipt_args) (\(_,_val5878) -> (case _val5878 of {T.TList _ _val5881 -> (Vector.fromList $ P.map (\_v5882 -> (case _v5882 of {T.TString _val5883 -> E.decodeUtf8 _val5883; _ -> P.error "wrong type"})) _val5881); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendMessageReceipt_args _ = P.error "not a struct"
read_SendMessageReceipt_args :: T.Protocol p => p -> P.IO SendMessageReceipt_args
read_SendMessageReceipt_args iprot = to_SendMessageReceipt_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageReceipt_args)
decode_SendMessageReceipt_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageReceipt_args
decode_SendMessageReceipt_args iprot bs = to_SendMessageReceipt_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageReceipt_args) bs
typemap_SendMessageReceipt_args :: T.TypeMap
typemap_SendMessageReceipt_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("messageIds",(T.T_LIST T.T_STRING)))]
default_SendMessageReceipt_args :: SendMessageReceipt_args
default_SendMessageReceipt_args = SendMessageReceipt_args{
  sendMessageReceipt_args_seq = 0,
  sendMessageReceipt_args_consumer = "",
  sendMessageReceipt_args_messageIds = Vector.empty}
data SendMessageReceipt_result = SendMessageReceipt_result  { sendMessageReceipt_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageReceipt_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageReceipt_result_e record  
instance QC.Arbitrary SendMessageReceipt_result where 
  arbitrary = M.liftM SendMessageReceipt_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageReceipt_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageReceipt_result{sendMessageReceipt_result_e = sendMessageReceipt_result_e obj} then P.Nothing else P.Just $ default_SendMessageReceipt_result{sendMessageReceipt_result_e = sendMessageReceipt_result_e obj}
    ]
from_SendMessageReceipt_result :: SendMessageReceipt_result -> T.ThriftVal
from_SendMessageReceipt_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5886 -> (1, ("e",from_TalkException _v5886))) <$> sendMessageReceipt_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5886 -> (1, ("e",from_TalkException _v5886))) <$> sendMessageReceipt_result_e record
    ]
    )
write_SendMessageReceipt_result :: T.Protocol p => p -> SendMessageReceipt_result -> P.IO ()
write_SendMessageReceipt_result oprot record = T.writeVal oprot $ from_SendMessageReceipt_result record
encode_SendMessageReceipt_result :: T.StatelessProtocol p => p -> SendMessageReceipt_result -> LBS.ByteString
encode_SendMessageReceipt_result oprot record = T.serializeVal oprot $ from_SendMessageReceipt_result record
to_SendMessageReceipt_result :: T.ThriftVal -> SendMessageReceipt_result
to_SendMessageReceipt_result (T.TStruct fields) = SendMessageReceipt_result{
  sendMessageReceipt_result_e = P.maybe (P.Nothing) (\(_,_val5888) -> P.Just (case _val5888 of {T.TStruct _val5889 -> (to_TalkException (T.TStruct _val5889)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageReceipt_result _ = P.error "not a struct"
read_SendMessageReceipt_result :: T.Protocol p => p -> P.IO SendMessageReceipt_result
read_SendMessageReceipt_result iprot = to_SendMessageReceipt_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageReceipt_result)
decode_SendMessageReceipt_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageReceipt_result
decode_SendMessageReceipt_result iprot bs = to_SendMessageReceipt_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageReceipt_result) bs
typemap_SendMessageReceipt_result :: T.TypeMap
typemap_SendMessageReceipt_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageReceipt_result :: SendMessageReceipt_result
default_SendMessageReceipt_result = SendMessageReceipt_result{
  sendMessageReceipt_result_e = P.Nothing}
data SendMessageToMyHome_args = SendMessageToMyHome_args  { sendMessageToMyHome_args_seq :: I.Int32
  , sendMessageToMyHome_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageToMyHome_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageToMyHome_args_seq record   `H.hashWithSalt` sendMessageToMyHome_args_message record  
instance QC.Arbitrary SendMessageToMyHome_args where 
  arbitrary = M.liftM SendMessageToMyHome_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageToMyHome_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageToMyHome_args{sendMessageToMyHome_args_seq = sendMessageToMyHome_args_seq obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_args{sendMessageToMyHome_args_seq = sendMessageToMyHome_args_seq obj}
    , if obj == default_SendMessageToMyHome_args{sendMessageToMyHome_args_message = sendMessageToMyHome_args_message obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_args{sendMessageToMyHome_args_message = sendMessageToMyHome_args_message obj}
    ]
from_SendMessageToMyHome_args :: SendMessageToMyHome_args -> T.ThriftVal
from_SendMessageToMyHome_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5892 -> P.Just (1, ("seq",T.TI32 _v5892))) $ sendMessageToMyHome_args_seq record
  , (\_v5892 -> P.Just (2, ("message",from_Message _v5892))) $ sendMessageToMyHome_args_message record
  ]
write_SendMessageToMyHome_args :: T.Protocol p => p -> SendMessageToMyHome_args -> P.IO ()
write_SendMessageToMyHome_args oprot record = T.writeVal oprot $ from_SendMessageToMyHome_args record
encode_SendMessageToMyHome_args :: T.StatelessProtocol p => p -> SendMessageToMyHome_args -> LBS.ByteString
encode_SendMessageToMyHome_args oprot record = T.serializeVal oprot $ from_SendMessageToMyHome_args record
to_SendMessageToMyHome_args :: T.ThriftVal -> SendMessageToMyHome_args
to_SendMessageToMyHome_args (T.TStruct fields) = SendMessageToMyHome_args{
  sendMessageToMyHome_args_seq = P.maybe (sendMessageToMyHome_args_seq default_SendMessageToMyHome_args) (\(_,_val5894) -> (case _val5894 of {T.TI32 _val5895 -> _val5895; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageToMyHome_args_message = P.maybe (sendMessageToMyHome_args_message default_SendMessageToMyHome_args) (\(_,_val5894) -> (case _val5894 of {T.TStruct _val5896 -> (to_Message (T.TStruct _val5896)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageToMyHome_args _ = P.error "not a struct"
read_SendMessageToMyHome_args :: T.Protocol p => p -> P.IO SendMessageToMyHome_args
read_SendMessageToMyHome_args iprot = to_SendMessageToMyHome_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_args)
decode_SendMessageToMyHome_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageToMyHome_args
decode_SendMessageToMyHome_args iprot bs = to_SendMessageToMyHome_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_args) bs
typemap_SendMessageToMyHome_args :: T.TypeMap
typemap_SendMessageToMyHome_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageToMyHome_args :: SendMessageToMyHome_args
default_SendMessageToMyHome_args = SendMessageToMyHome_args{
  sendMessageToMyHome_args_seq = 0,
  sendMessageToMyHome_args_message = default_Message}
data SendMessageToMyHome_result = SendMessageToMyHome_result  { sendMessageToMyHome_result_success :: Message
  , sendMessageToMyHome_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageToMyHome_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageToMyHome_result_success record   `H.hashWithSalt` sendMessageToMyHome_result_e record  
instance QC.Arbitrary SendMessageToMyHome_result where 
  arbitrary = M.liftM SendMessageToMyHome_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageToMyHome_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageToMyHome_result{sendMessageToMyHome_result_success = sendMessageToMyHome_result_success obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_result{sendMessageToMyHome_result_success = sendMessageToMyHome_result_success obj}
    , if obj == default_SendMessageToMyHome_result{sendMessageToMyHome_result_e = sendMessageToMyHome_result_e obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_result{sendMessageToMyHome_result_e = sendMessageToMyHome_result_e obj}
    ]
from_SendMessageToMyHome_result :: SendMessageToMyHome_result -> T.ThriftVal
from_SendMessageToMyHome_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5899 -> (1, ("e",from_TalkException _v5899))) <$> sendMessageToMyHome_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5899 -> P.Just (0, ("success",from_Message _v5899))) $ sendMessageToMyHome_result_success record
    , (\_v5899 -> (1, ("e",from_TalkException _v5899))) <$> sendMessageToMyHome_result_e record
    ]
    )
write_SendMessageToMyHome_result :: T.Protocol p => p -> SendMessageToMyHome_result -> P.IO ()
write_SendMessageToMyHome_result oprot record = T.writeVal oprot $ from_SendMessageToMyHome_result record
encode_SendMessageToMyHome_result :: T.StatelessProtocol p => p -> SendMessageToMyHome_result -> LBS.ByteString
encode_SendMessageToMyHome_result oprot record = T.serializeVal oprot $ from_SendMessageToMyHome_result record
to_SendMessageToMyHome_result :: T.ThriftVal -> SendMessageToMyHome_result
to_SendMessageToMyHome_result (T.TStruct fields) = SendMessageToMyHome_result{
  sendMessageToMyHome_result_success = P.maybe (sendMessageToMyHome_result_success default_SendMessageToMyHome_result) (\(_,_val5901) -> (case _val5901 of {T.TStruct _val5902 -> (to_Message (T.TStruct _val5902)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageToMyHome_result_e = P.maybe (P.Nothing) (\(_,_val5901) -> P.Just (case _val5901 of {T.TStruct _val5903 -> (to_TalkException (T.TStruct _val5903)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageToMyHome_result _ = P.error "not a struct"
read_SendMessageToMyHome_result :: T.Protocol p => p -> P.IO SendMessageToMyHome_result
read_SendMessageToMyHome_result iprot = to_SendMessageToMyHome_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_result)
decode_SendMessageToMyHome_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageToMyHome_result
decode_SendMessageToMyHome_result iprot bs = to_SendMessageToMyHome_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_result) bs
typemap_SendMessageToMyHome_result :: T.TypeMap
typemap_SendMessageToMyHome_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageToMyHome_result :: SendMessageToMyHome_result
default_SendMessageToMyHome_result = SendMessageToMyHome_result{
  sendMessageToMyHome_result_success = default_Message,
  sendMessageToMyHome_result_e = P.Nothing}
data SetBuddyLocation_args = SetBuddyLocation_args  { setBuddyLocation_args_mid :: LT.Text
  , setBuddyLocation_args_index :: I.Int32
  , setBuddyLocation_args_location :: Geolocation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetBuddyLocation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setBuddyLocation_args_mid record   `H.hashWithSalt` setBuddyLocation_args_index record   `H.hashWithSalt` setBuddyLocation_args_location record  
instance QC.Arbitrary SetBuddyLocation_args where 
  arbitrary = M.liftM SetBuddyLocation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetBuddyLocation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetBuddyLocation_args{setBuddyLocation_args_mid = setBuddyLocation_args_mid obj} then P.Nothing else P.Just $ default_SetBuddyLocation_args{setBuddyLocation_args_mid = setBuddyLocation_args_mid obj}
    , if obj == default_SetBuddyLocation_args{setBuddyLocation_args_index = setBuddyLocation_args_index obj} then P.Nothing else P.Just $ default_SetBuddyLocation_args{setBuddyLocation_args_index = setBuddyLocation_args_index obj}
    , if obj == default_SetBuddyLocation_args{setBuddyLocation_args_location = setBuddyLocation_args_location obj} then P.Nothing else P.Just $ default_SetBuddyLocation_args{setBuddyLocation_args_location = setBuddyLocation_args_location obj}
    ]
from_SetBuddyLocation_args :: SetBuddyLocation_args -> T.ThriftVal
from_SetBuddyLocation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5906 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v5906))) $ setBuddyLocation_args_mid record
  , (\_v5906 -> P.Just (3, ("index",T.TI32 _v5906))) $ setBuddyLocation_args_index record
  , (\_v5906 -> P.Just (4, ("location",from_Geolocation _v5906))) $ setBuddyLocation_args_location record
  ]
write_SetBuddyLocation_args :: T.Protocol p => p -> SetBuddyLocation_args -> P.IO ()
write_SetBuddyLocation_args oprot record = T.writeVal oprot $ from_SetBuddyLocation_args record
encode_SetBuddyLocation_args :: T.StatelessProtocol p => p -> SetBuddyLocation_args -> LBS.ByteString
encode_SetBuddyLocation_args oprot record = T.serializeVal oprot $ from_SetBuddyLocation_args record
to_SetBuddyLocation_args :: T.ThriftVal -> SetBuddyLocation_args
to_SetBuddyLocation_args (T.TStruct fields) = SetBuddyLocation_args{
  setBuddyLocation_args_mid = P.maybe (setBuddyLocation_args_mid default_SetBuddyLocation_args) (\(_,_val5908) -> (case _val5908 of {T.TString _val5909 -> E.decodeUtf8 _val5909; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setBuddyLocation_args_index = P.maybe (setBuddyLocation_args_index default_SetBuddyLocation_args) (\(_,_val5908) -> (case _val5908 of {T.TI32 _val5910 -> _val5910; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setBuddyLocation_args_location = P.maybe (setBuddyLocation_args_location default_SetBuddyLocation_args) (\(_,_val5908) -> (case _val5908 of {T.TStruct _val5911 -> (to_Geolocation (T.TStruct _val5911)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SetBuddyLocation_args _ = P.error "not a struct"
read_SetBuddyLocation_args :: T.Protocol p => p -> P.IO SetBuddyLocation_args
read_SetBuddyLocation_args iprot = to_SetBuddyLocation_args <$> T.readVal iprot (T.T_STRUCT typemap_SetBuddyLocation_args)
decode_SetBuddyLocation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetBuddyLocation_args
decode_SetBuddyLocation_args iprot bs = to_SetBuddyLocation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetBuddyLocation_args) bs
typemap_SetBuddyLocation_args :: T.TypeMap
typemap_SetBuddyLocation_args = Map.fromList [(2,("mid",T.T_STRING)),(3,("index",T.T_I32)),(4,("location",(T.T_STRUCT typemap_Geolocation)))]
default_SetBuddyLocation_args :: SetBuddyLocation_args
default_SetBuddyLocation_args = SetBuddyLocation_args{
  setBuddyLocation_args_mid = "",
  setBuddyLocation_args_index = 0,
  setBuddyLocation_args_location = default_Geolocation}
data SetBuddyLocation_result = SetBuddyLocation_result  { setBuddyLocation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetBuddyLocation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setBuddyLocation_result_e record  
instance QC.Arbitrary SetBuddyLocation_result where 
  arbitrary = M.liftM SetBuddyLocation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetBuddyLocation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetBuddyLocation_result{setBuddyLocation_result_e = setBuddyLocation_result_e obj} then P.Nothing else P.Just $ default_SetBuddyLocation_result{setBuddyLocation_result_e = setBuddyLocation_result_e obj}
    ]
from_SetBuddyLocation_result :: SetBuddyLocation_result -> T.ThriftVal
from_SetBuddyLocation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5914 -> (1, ("e",from_TalkException _v5914))) <$> setBuddyLocation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5914 -> (1, ("e",from_TalkException _v5914))) <$> setBuddyLocation_result_e record
    ]
    )
write_SetBuddyLocation_result :: T.Protocol p => p -> SetBuddyLocation_result -> P.IO ()
write_SetBuddyLocation_result oprot record = T.writeVal oprot $ from_SetBuddyLocation_result record
encode_SetBuddyLocation_result :: T.StatelessProtocol p => p -> SetBuddyLocation_result -> LBS.ByteString
encode_SetBuddyLocation_result oprot record = T.serializeVal oprot $ from_SetBuddyLocation_result record
to_SetBuddyLocation_result :: T.ThriftVal -> SetBuddyLocation_result
to_SetBuddyLocation_result (T.TStruct fields) = SetBuddyLocation_result{
  setBuddyLocation_result_e = P.maybe (P.Nothing) (\(_,_val5916) -> P.Just (case _val5916 of {T.TStruct _val5917 -> (to_TalkException (T.TStruct _val5917)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetBuddyLocation_result _ = P.error "not a struct"
read_SetBuddyLocation_result :: T.Protocol p => p -> P.IO SetBuddyLocation_result
read_SetBuddyLocation_result iprot = to_SetBuddyLocation_result <$> T.readVal iprot (T.T_STRUCT typemap_SetBuddyLocation_result)
decode_SetBuddyLocation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetBuddyLocation_result
decode_SetBuddyLocation_result iprot bs = to_SetBuddyLocation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetBuddyLocation_result) bs
typemap_SetBuddyLocation_result :: T.TypeMap
typemap_SetBuddyLocation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SetBuddyLocation_result :: SetBuddyLocation_result
default_SetBuddyLocation_result = SetBuddyLocation_result{
  setBuddyLocation_result_e = P.Nothing}
data SetIdentityCredential_args = SetIdentityCredential_args  { setIdentityCredential_args_provider :: IdentityProvider
  , setIdentityCredential_args_identifier :: LT.Text
  , setIdentityCredential_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setIdentityCredential_args_provider record   `H.hashWithSalt` setIdentityCredential_args_identifier record   `H.hashWithSalt` setIdentityCredential_args_verifier record  
instance QC.Arbitrary SetIdentityCredential_args where 
  arbitrary = M.liftM SetIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetIdentityCredential_args{setIdentityCredential_args_provider = setIdentityCredential_args_provider obj} then P.Nothing else P.Just $ default_SetIdentityCredential_args{setIdentityCredential_args_provider = setIdentityCredential_args_provider obj}
    , if obj == default_SetIdentityCredential_args{setIdentityCredential_args_identifier = setIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_SetIdentityCredential_args{setIdentityCredential_args_identifier = setIdentityCredential_args_identifier obj}
    , if obj == default_SetIdentityCredential_args{setIdentityCredential_args_verifier = setIdentityCredential_args_verifier obj} then P.Nothing else P.Just $ default_SetIdentityCredential_args{setIdentityCredential_args_verifier = setIdentityCredential_args_verifier obj}
    ]
from_SetIdentityCredential_args :: SetIdentityCredential_args -> T.ThriftVal
from_SetIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5920 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v5920))) $ setIdentityCredential_args_identifier record
  , (\_v5920 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v5920))) $ setIdentityCredential_args_verifier record
  , (\_v5920 -> P.Just (4, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v5920))) $ setIdentityCredential_args_provider record
  ]
write_SetIdentityCredential_args :: T.Protocol p => p -> SetIdentityCredential_args -> P.IO ()
write_SetIdentityCredential_args oprot record = T.writeVal oprot $ from_SetIdentityCredential_args record
encode_SetIdentityCredential_args :: T.StatelessProtocol p => p -> SetIdentityCredential_args -> LBS.ByteString
encode_SetIdentityCredential_args oprot record = T.serializeVal oprot $ from_SetIdentityCredential_args record
to_SetIdentityCredential_args :: T.ThriftVal -> SetIdentityCredential_args
to_SetIdentityCredential_args (T.TStruct fields) = SetIdentityCredential_args{
  setIdentityCredential_args_provider = P.maybe (setIdentityCredential_args_provider default_SetIdentityCredential_args) (\(_,_val5922) -> (case _val5922 of {T.TI32 _val5923 -> P.toEnum $ P.fromIntegral _val5923; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  setIdentityCredential_args_identifier = P.maybe (setIdentityCredential_args_identifier default_SetIdentityCredential_args) (\(_,_val5922) -> (case _val5922 of {T.TString _val5924 -> E.decodeUtf8 _val5924; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setIdentityCredential_args_verifier = P.maybe (setIdentityCredential_args_verifier default_SetIdentityCredential_args) (\(_,_val5922) -> (case _val5922 of {T.TString _val5925 -> E.decodeUtf8 _val5925; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SetIdentityCredential_args _ = P.error "not a struct"
read_SetIdentityCredential_args :: T.Protocol p => p -> P.IO SetIdentityCredential_args
read_SetIdentityCredential_args iprot = to_SetIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_SetIdentityCredential_args)
decode_SetIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetIdentityCredential_args
decode_SetIdentityCredential_args iprot bs = to_SetIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetIdentityCredential_args) bs
typemap_SetIdentityCredential_args :: T.TypeMap
typemap_SetIdentityCredential_args = Map.fromList [(2,("identifier",T.T_STRING)),(3,("verifier",T.T_STRING)),(4,("provider",T.T_I32))]
default_SetIdentityCredential_args :: SetIdentityCredential_args
default_SetIdentityCredential_args = SetIdentityCredential_args{
  setIdentityCredential_args_identifier = "",
  setIdentityCredential_args_verifier = "",
  setIdentityCredential_args_provider = (P.toEnum 0)}
data SetIdentityCredential_result = SetIdentityCredential_result  { setIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setIdentityCredential_result_e record  
instance QC.Arbitrary SetIdentityCredential_result where 
  arbitrary = M.liftM SetIdentityCredential_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetIdentityCredential_result{setIdentityCredential_result_e = setIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_SetIdentityCredential_result{setIdentityCredential_result_e = setIdentityCredential_result_e obj}
    ]
from_SetIdentityCredential_result :: SetIdentityCredential_result -> T.ThriftVal
from_SetIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5928 -> (1, ("e",from_TalkException _v5928))) <$> setIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5928 -> (1, ("e",from_TalkException _v5928))) <$> setIdentityCredential_result_e record
    ]
    )
write_SetIdentityCredential_result :: T.Protocol p => p -> SetIdentityCredential_result -> P.IO ()
write_SetIdentityCredential_result oprot record = T.writeVal oprot $ from_SetIdentityCredential_result record
encode_SetIdentityCredential_result :: T.StatelessProtocol p => p -> SetIdentityCredential_result -> LBS.ByteString
encode_SetIdentityCredential_result oprot record = T.serializeVal oprot $ from_SetIdentityCredential_result record
to_SetIdentityCredential_result :: T.ThriftVal -> SetIdentityCredential_result
to_SetIdentityCredential_result (T.TStruct fields) = SetIdentityCredential_result{
  setIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val5930) -> P.Just (case _val5930 of {T.TStruct _val5931 -> (to_TalkException (T.TStruct _val5931)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetIdentityCredential_result _ = P.error "not a struct"
read_SetIdentityCredential_result :: T.Protocol p => p -> P.IO SetIdentityCredential_result
read_SetIdentityCredential_result iprot = to_SetIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_SetIdentityCredential_result)
decode_SetIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetIdentityCredential_result
decode_SetIdentityCredential_result iprot bs = to_SetIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetIdentityCredential_result) bs
typemap_SetIdentityCredential_result :: T.TypeMap
typemap_SetIdentityCredential_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SetIdentityCredential_result :: SetIdentityCredential_result
default_SetIdentityCredential_result = SetIdentityCredential_result{
  setIdentityCredential_result_e = P.Nothing}
data SetNotificationsEnabled_args = SetNotificationsEnabled_args  { setNotificationsEnabled_args_reqSeq :: I.Int32
  , setNotificationsEnabled_args_type :: MIDType
  , setNotificationsEnabled_args_target :: LT.Text
  , setNotificationsEnabled_args_enablement :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNotificationsEnabled_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNotificationsEnabled_args_reqSeq record   `H.hashWithSalt` setNotificationsEnabled_args_type record   `H.hashWithSalt` setNotificationsEnabled_args_target record   `H.hashWithSalt` setNotificationsEnabled_args_enablement record  
instance QC.Arbitrary SetNotificationsEnabled_args where 
  arbitrary = M.liftM SetNotificationsEnabled_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetNotificationsEnabled_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_reqSeq = setNotificationsEnabled_args_reqSeq obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_reqSeq = setNotificationsEnabled_args_reqSeq obj}
    , if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_type = setNotificationsEnabled_args_type obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_type = setNotificationsEnabled_args_type obj}
    , if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_target = setNotificationsEnabled_args_target obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_target = setNotificationsEnabled_args_target obj}
    , if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_enablement = setNotificationsEnabled_args_enablement obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_enablement = setNotificationsEnabled_args_enablement obj}
    ]
from_SetNotificationsEnabled_args :: SetNotificationsEnabled_args -> T.ThriftVal
from_SetNotificationsEnabled_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5934 -> P.Just (1, ("reqSeq",T.TI32 _v5934))) $ setNotificationsEnabled_args_reqSeq record
  , (\_v5934 -> P.Just (2, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v5934))) $ setNotificationsEnabled_args_type record
  , (\_v5934 -> P.Just (3, ("target",T.TString $ E.encodeUtf8 _v5934))) $ setNotificationsEnabled_args_target record
  , (\_v5934 -> P.Just (4, ("enablement",T.TBool _v5934))) $ setNotificationsEnabled_args_enablement record
  ]
write_SetNotificationsEnabled_args :: T.Protocol p => p -> SetNotificationsEnabled_args -> P.IO ()
write_SetNotificationsEnabled_args oprot record = T.writeVal oprot $ from_SetNotificationsEnabled_args record
encode_SetNotificationsEnabled_args :: T.StatelessProtocol p => p -> SetNotificationsEnabled_args -> LBS.ByteString
encode_SetNotificationsEnabled_args oprot record = T.serializeVal oprot $ from_SetNotificationsEnabled_args record
to_SetNotificationsEnabled_args :: T.ThriftVal -> SetNotificationsEnabled_args
to_SetNotificationsEnabled_args (T.TStruct fields) = SetNotificationsEnabled_args{
  setNotificationsEnabled_args_reqSeq = P.maybe (setNotificationsEnabled_args_reqSeq default_SetNotificationsEnabled_args) (\(_,_val5936) -> (case _val5936 of {T.TI32 _val5937 -> _val5937; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setNotificationsEnabled_args_type = P.maybe (setNotificationsEnabled_args_type default_SetNotificationsEnabled_args) (\(_,_val5936) -> (case _val5936 of {T.TI32 _val5938 -> P.toEnum $ P.fromIntegral _val5938; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setNotificationsEnabled_args_target = P.maybe (setNotificationsEnabled_args_target default_SetNotificationsEnabled_args) (\(_,_val5936) -> (case _val5936 of {T.TString _val5939 -> E.decodeUtf8 _val5939; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setNotificationsEnabled_args_enablement = P.maybe (setNotificationsEnabled_args_enablement default_SetNotificationsEnabled_args) (\(_,_val5936) -> (case _val5936 of {T.TBool _val5940 -> _val5940; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SetNotificationsEnabled_args _ = P.error "not a struct"
read_SetNotificationsEnabled_args :: T.Protocol p => p -> P.IO SetNotificationsEnabled_args
read_SetNotificationsEnabled_args iprot = to_SetNotificationsEnabled_args <$> T.readVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_args)
decode_SetNotificationsEnabled_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNotificationsEnabled_args
decode_SetNotificationsEnabled_args iprot bs = to_SetNotificationsEnabled_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_args) bs
typemap_SetNotificationsEnabled_args :: T.TypeMap
typemap_SetNotificationsEnabled_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("type",T.T_I32)),(3,("target",T.T_STRING)),(4,("enablement",T.T_BOOL))]
default_SetNotificationsEnabled_args :: SetNotificationsEnabled_args
default_SetNotificationsEnabled_args = SetNotificationsEnabled_args{
  setNotificationsEnabled_args_reqSeq = 0,
  setNotificationsEnabled_args_type = (P.toEnum 0),
  setNotificationsEnabled_args_target = "",
  setNotificationsEnabled_args_enablement = P.False}
data SetNotificationsEnabled_result = SetNotificationsEnabled_result  { setNotificationsEnabled_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNotificationsEnabled_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNotificationsEnabled_result_e record  
instance QC.Arbitrary SetNotificationsEnabled_result where 
  arbitrary = M.liftM SetNotificationsEnabled_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetNotificationsEnabled_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNotificationsEnabled_result{setNotificationsEnabled_result_e = setNotificationsEnabled_result_e obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_result{setNotificationsEnabled_result_e = setNotificationsEnabled_result_e obj}
    ]
from_SetNotificationsEnabled_result :: SetNotificationsEnabled_result -> T.ThriftVal
from_SetNotificationsEnabled_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5943 -> (1, ("e",from_TalkException _v5943))) <$> setNotificationsEnabled_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5943 -> (1, ("e",from_TalkException _v5943))) <$> setNotificationsEnabled_result_e record
    ]
    )
write_SetNotificationsEnabled_result :: T.Protocol p => p -> SetNotificationsEnabled_result -> P.IO ()
write_SetNotificationsEnabled_result oprot record = T.writeVal oprot $ from_SetNotificationsEnabled_result record
encode_SetNotificationsEnabled_result :: T.StatelessProtocol p => p -> SetNotificationsEnabled_result -> LBS.ByteString
encode_SetNotificationsEnabled_result oprot record = T.serializeVal oprot $ from_SetNotificationsEnabled_result record
to_SetNotificationsEnabled_result :: T.ThriftVal -> SetNotificationsEnabled_result
to_SetNotificationsEnabled_result (T.TStruct fields) = SetNotificationsEnabled_result{
  setNotificationsEnabled_result_e = P.maybe (P.Nothing) (\(_,_val5945) -> P.Just (case _val5945 of {T.TStruct _val5946 -> (to_TalkException (T.TStruct _val5946)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetNotificationsEnabled_result _ = P.error "not a struct"
read_SetNotificationsEnabled_result :: T.Protocol p => p -> P.IO SetNotificationsEnabled_result
read_SetNotificationsEnabled_result iprot = to_SetNotificationsEnabled_result <$> T.readVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_result)
decode_SetNotificationsEnabled_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNotificationsEnabled_result
decode_SetNotificationsEnabled_result iprot bs = to_SetNotificationsEnabled_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_result) bs
typemap_SetNotificationsEnabled_result :: T.TypeMap
typemap_SetNotificationsEnabled_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SetNotificationsEnabled_result :: SetNotificationsEnabled_result
default_SetNotificationsEnabled_result = SetNotificationsEnabled_result{
  setNotificationsEnabled_result_e = P.Nothing}
data StartUpdateVerification_args = StartUpdateVerification_args  { startUpdateVerification_args_region :: LT.Text
  , startUpdateVerification_args_carrier :: CarrierCode
  , startUpdateVerification_args_phone :: LT.Text
  , startUpdateVerification_args_udidHash :: LT.Text
  , startUpdateVerification_args_deviceInfo :: DeviceInfo
  , startUpdateVerification_args_networkCode :: LT.Text
  , startUpdateVerification_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartUpdateVerification_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startUpdateVerification_args_region record   `H.hashWithSalt` startUpdateVerification_args_carrier record   `H.hashWithSalt` startUpdateVerification_args_phone record   `H.hashWithSalt` startUpdateVerification_args_udidHash record   `H.hashWithSalt` startUpdateVerification_args_deviceInfo record   `H.hashWithSalt` startUpdateVerification_args_networkCode record   `H.hashWithSalt` startUpdateVerification_args_locale record  
instance QC.Arbitrary StartUpdateVerification_args where 
  arbitrary = M.liftM StartUpdateVerification_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartUpdateVerification_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartUpdateVerification_args{startUpdateVerification_args_region = startUpdateVerification_args_region obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_region = startUpdateVerification_args_region obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_carrier = startUpdateVerification_args_carrier obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_carrier = startUpdateVerification_args_carrier obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_phone = startUpdateVerification_args_phone obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_phone = startUpdateVerification_args_phone obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_udidHash = startUpdateVerification_args_udidHash obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_udidHash = startUpdateVerification_args_udidHash obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_deviceInfo = startUpdateVerification_args_deviceInfo obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_deviceInfo = startUpdateVerification_args_deviceInfo obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_networkCode = startUpdateVerification_args_networkCode obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_networkCode = startUpdateVerification_args_networkCode obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_locale = startUpdateVerification_args_locale obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_locale = startUpdateVerification_args_locale obj}
    ]
from_StartUpdateVerification_args :: StartUpdateVerification_args -> T.ThriftVal
from_StartUpdateVerification_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5949 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v5949))) $ startUpdateVerification_args_region record
  , (\_v5949 -> P.Just (3, ("carrier",T.TI32 $ P.fromIntegral $ P.fromEnum _v5949))) $ startUpdateVerification_args_carrier record
  , (\_v5949 -> P.Just (4, ("phone",T.TString $ E.encodeUtf8 _v5949))) $ startUpdateVerification_args_phone record
  , (\_v5949 -> P.Just (5, ("udidHash",T.TString $ E.encodeUtf8 _v5949))) $ startUpdateVerification_args_udidHash record
  , (\_v5949 -> P.Just (6, ("deviceInfo",from_DeviceInfo _v5949))) $ startUpdateVerification_args_deviceInfo record
  , (\_v5949 -> P.Just (7, ("networkCode",T.TString $ E.encodeUtf8 _v5949))) $ startUpdateVerification_args_networkCode record
  , (\_v5949 -> P.Just (8, ("locale",T.TString $ E.encodeUtf8 _v5949))) $ startUpdateVerification_args_locale record
  ]
write_StartUpdateVerification_args :: T.Protocol p => p -> StartUpdateVerification_args -> P.IO ()
write_StartUpdateVerification_args oprot record = T.writeVal oprot $ from_StartUpdateVerification_args record
encode_StartUpdateVerification_args :: T.StatelessProtocol p => p -> StartUpdateVerification_args -> LBS.ByteString
encode_StartUpdateVerification_args oprot record = T.serializeVal oprot $ from_StartUpdateVerification_args record
to_StartUpdateVerification_args :: T.ThriftVal -> StartUpdateVerification_args
to_StartUpdateVerification_args (T.TStruct fields) = StartUpdateVerification_args{
  startUpdateVerification_args_region = P.maybe (startUpdateVerification_args_region default_StartUpdateVerification_args) (\(_,_val5951) -> (case _val5951 of {T.TString _val5952 -> E.decodeUtf8 _val5952; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  startUpdateVerification_args_carrier = P.maybe (startUpdateVerification_args_carrier default_StartUpdateVerification_args) (\(_,_val5951) -> (case _val5951 of {T.TI32 _val5953 -> P.toEnum $ P.fromIntegral _val5953; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  startUpdateVerification_args_phone = P.maybe (startUpdateVerification_args_phone default_StartUpdateVerification_args) (\(_,_val5951) -> (case _val5951 of {T.TString _val5954 -> E.decodeUtf8 _val5954; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  startUpdateVerification_args_udidHash = P.maybe (startUpdateVerification_args_udidHash default_StartUpdateVerification_args) (\(_,_val5951) -> (case _val5951 of {T.TString _val5955 -> E.decodeUtf8 _val5955; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  startUpdateVerification_args_deviceInfo = P.maybe (startUpdateVerification_args_deviceInfo default_StartUpdateVerification_args) (\(_,_val5951) -> (case _val5951 of {T.TStruct _val5956 -> (to_DeviceInfo (T.TStruct _val5956)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  startUpdateVerification_args_networkCode = P.maybe (startUpdateVerification_args_networkCode default_StartUpdateVerification_args) (\(_,_val5951) -> (case _val5951 of {T.TString _val5957 -> E.decodeUtf8 _val5957; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  startUpdateVerification_args_locale = P.maybe (startUpdateVerification_args_locale default_StartUpdateVerification_args) (\(_,_val5951) -> (case _val5951 of {T.TString _val5958 -> E.decodeUtf8 _val5958; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_StartUpdateVerification_args _ = P.error "not a struct"
read_StartUpdateVerification_args :: T.Protocol p => p -> P.IO StartUpdateVerification_args
read_StartUpdateVerification_args iprot = to_StartUpdateVerification_args <$> T.readVal iprot (T.T_STRUCT typemap_StartUpdateVerification_args)
decode_StartUpdateVerification_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StartUpdateVerification_args
decode_StartUpdateVerification_args iprot bs = to_StartUpdateVerification_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartUpdateVerification_args) bs
typemap_StartUpdateVerification_args :: T.TypeMap
typemap_StartUpdateVerification_args = Map.fromList [(2,("region",T.T_STRING)),(3,("carrier",T.T_I32)),(4,("phone",T.T_STRING)),(5,("udidHash",T.T_STRING)),(6,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(7,("networkCode",T.T_STRING)),(8,("locale",T.T_STRING))]
default_StartUpdateVerification_args :: StartUpdateVerification_args
default_StartUpdateVerification_args = StartUpdateVerification_args{
  startUpdateVerification_args_region = "",
  startUpdateVerification_args_carrier = (P.toEnum 0),
  startUpdateVerification_args_phone = "",
  startUpdateVerification_args_udidHash = "",
  startUpdateVerification_args_deviceInfo = default_DeviceInfo,
  startUpdateVerification_args_networkCode = "",
  startUpdateVerification_args_locale = ""}
data StartUpdateVerification_result = StartUpdateVerification_result  { startUpdateVerification_result_success :: VerificationSessionData
  , startUpdateVerification_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartUpdateVerification_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startUpdateVerification_result_success record   `H.hashWithSalt` startUpdateVerification_result_e record  
instance QC.Arbitrary StartUpdateVerification_result where 
  arbitrary = M.liftM StartUpdateVerification_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StartUpdateVerification_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartUpdateVerification_result{startUpdateVerification_result_success = startUpdateVerification_result_success obj} then P.Nothing else P.Just $ default_StartUpdateVerification_result{startUpdateVerification_result_success = startUpdateVerification_result_success obj}
    , if obj == default_StartUpdateVerification_result{startUpdateVerification_result_e = startUpdateVerification_result_e obj} then P.Nothing else P.Just $ default_StartUpdateVerification_result{startUpdateVerification_result_e = startUpdateVerification_result_e obj}
    ]
from_StartUpdateVerification_result :: StartUpdateVerification_result -> T.ThriftVal
from_StartUpdateVerification_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5961 -> (1, ("e",from_TalkException _v5961))) <$> startUpdateVerification_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5961 -> P.Just (0, ("success",from_VerificationSessionData _v5961))) $ startUpdateVerification_result_success record
    , (\_v5961 -> (1, ("e",from_TalkException _v5961))) <$> startUpdateVerification_result_e record
    ]
    )
write_StartUpdateVerification_result :: T.Protocol p => p -> StartUpdateVerification_result -> P.IO ()
write_StartUpdateVerification_result oprot record = T.writeVal oprot $ from_StartUpdateVerification_result record
encode_StartUpdateVerification_result :: T.StatelessProtocol p => p -> StartUpdateVerification_result -> LBS.ByteString
encode_StartUpdateVerification_result oprot record = T.serializeVal oprot $ from_StartUpdateVerification_result record
to_StartUpdateVerification_result :: T.ThriftVal -> StartUpdateVerification_result
to_StartUpdateVerification_result (T.TStruct fields) = StartUpdateVerification_result{
  startUpdateVerification_result_success = P.maybe (startUpdateVerification_result_success default_StartUpdateVerification_result) (\(_,_val5963) -> (case _val5963 of {T.TStruct _val5964 -> (to_VerificationSessionData (T.TStruct _val5964)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  startUpdateVerification_result_e = P.maybe (P.Nothing) (\(_,_val5963) -> P.Just (case _val5963 of {T.TStruct _val5965 -> (to_TalkException (T.TStruct _val5965)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartUpdateVerification_result _ = P.error "not a struct"
read_StartUpdateVerification_result :: T.Protocol p => p -> P.IO StartUpdateVerification_result
read_StartUpdateVerification_result iprot = to_StartUpdateVerification_result <$> T.readVal iprot (T.T_STRUCT typemap_StartUpdateVerification_result)
decode_StartUpdateVerification_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StartUpdateVerification_result
decode_StartUpdateVerification_result iprot bs = to_StartUpdateVerification_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartUpdateVerification_result) bs
typemap_StartUpdateVerification_result :: T.TypeMap
typemap_StartUpdateVerification_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_VerificationSessionData))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_StartUpdateVerification_result :: StartUpdateVerification_result
default_StartUpdateVerification_result = StartUpdateVerification_result{
  startUpdateVerification_result_success = default_VerificationSessionData,
  startUpdateVerification_result_e = P.Nothing}
data StartVerification_args = StartVerification_args  { startVerification_args_region :: LT.Text
  , startVerification_args_carrier :: CarrierCode
  , startVerification_args_phone :: LT.Text
  , startVerification_args_udidHash :: LT.Text
  , startVerification_args_deviceInfo :: DeviceInfo
  , startVerification_args_networkCode :: LT.Text
  , startVerification_args_mid :: LT.Text
  , startVerification_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartVerification_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startVerification_args_region record   `H.hashWithSalt` startVerification_args_carrier record   `H.hashWithSalt` startVerification_args_phone record   `H.hashWithSalt` startVerification_args_udidHash record   `H.hashWithSalt` startVerification_args_deviceInfo record   `H.hashWithSalt` startVerification_args_networkCode record   `H.hashWithSalt` startVerification_args_mid record   `H.hashWithSalt` startVerification_args_locale record  
instance QC.Arbitrary StartVerification_args where 
  arbitrary = M.liftM StartVerification_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartVerification_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartVerification_args{startVerification_args_region = startVerification_args_region obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_region = startVerification_args_region obj}
    , if obj == default_StartVerification_args{startVerification_args_carrier = startVerification_args_carrier obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_carrier = startVerification_args_carrier obj}
    , if obj == default_StartVerification_args{startVerification_args_phone = startVerification_args_phone obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_phone = startVerification_args_phone obj}
    , if obj == default_StartVerification_args{startVerification_args_udidHash = startVerification_args_udidHash obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_udidHash = startVerification_args_udidHash obj}
    , if obj == default_StartVerification_args{startVerification_args_deviceInfo = startVerification_args_deviceInfo obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_deviceInfo = startVerification_args_deviceInfo obj}
    , if obj == default_StartVerification_args{startVerification_args_networkCode = startVerification_args_networkCode obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_networkCode = startVerification_args_networkCode obj}
    , if obj == default_StartVerification_args{startVerification_args_mid = startVerification_args_mid obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_mid = startVerification_args_mid obj}
    , if obj == default_StartVerification_args{startVerification_args_locale = startVerification_args_locale obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_locale = startVerification_args_locale obj}
    ]
from_StartVerification_args :: StartVerification_args -> T.ThriftVal
from_StartVerification_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5968 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v5968))) $ startVerification_args_region record
  , (\_v5968 -> P.Just (3, ("carrier",T.TI32 $ P.fromIntegral $ P.fromEnum _v5968))) $ startVerification_args_carrier record
  , (\_v5968 -> P.Just (4, ("phone",T.TString $ E.encodeUtf8 _v5968))) $ startVerification_args_phone record
  , (\_v5968 -> P.Just (5, ("udidHash",T.TString $ E.encodeUtf8 _v5968))) $ startVerification_args_udidHash record
  , (\_v5968 -> P.Just (6, ("deviceInfo",from_DeviceInfo _v5968))) $ startVerification_args_deviceInfo record
  , (\_v5968 -> P.Just (7, ("networkCode",T.TString $ E.encodeUtf8 _v5968))) $ startVerification_args_networkCode record
  , (\_v5968 -> P.Just (8, ("mid",T.TString $ E.encodeUtf8 _v5968))) $ startVerification_args_mid record
  , (\_v5968 -> P.Just (9, ("locale",T.TString $ E.encodeUtf8 _v5968))) $ startVerification_args_locale record
  ]
write_StartVerification_args :: T.Protocol p => p -> StartVerification_args -> P.IO ()
write_StartVerification_args oprot record = T.writeVal oprot $ from_StartVerification_args record
encode_StartVerification_args :: T.StatelessProtocol p => p -> StartVerification_args -> LBS.ByteString
encode_StartVerification_args oprot record = T.serializeVal oprot $ from_StartVerification_args record
to_StartVerification_args :: T.ThriftVal -> StartVerification_args
to_StartVerification_args (T.TStruct fields) = StartVerification_args{
  startVerification_args_region = P.maybe (startVerification_args_region default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TString _val5971 -> E.decodeUtf8 _val5971; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  startVerification_args_carrier = P.maybe (startVerification_args_carrier default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TI32 _val5972 -> P.toEnum $ P.fromIntegral _val5972; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  startVerification_args_phone = P.maybe (startVerification_args_phone default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TString _val5973 -> E.decodeUtf8 _val5973; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  startVerification_args_udidHash = P.maybe (startVerification_args_udidHash default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TString _val5974 -> E.decodeUtf8 _val5974; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  startVerification_args_deviceInfo = P.maybe (startVerification_args_deviceInfo default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TStruct _val5975 -> (to_DeviceInfo (T.TStruct _val5975)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  startVerification_args_networkCode = P.maybe (startVerification_args_networkCode default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TString _val5976 -> E.decodeUtf8 _val5976; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  startVerification_args_mid = P.maybe (startVerification_args_mid default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TString _val5977 -> E.decodeUtf8 _val5977; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  startVerification_args_locale = P.maybe (startVerification_args_locale default_StartVerification_args) (\(_,_val5970) -> (case _val5970 of {T.TString _val5978 -> E.decodeUtf8 _val5978; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_StartVerification_args _ = P.error "not a struct"
read_StartVerification_args :: T.Protocol p => p -> P.IO StartVerification_args
read_StartVerification_args iprot = to_StartVerification_args <$> T.readVal iprot (T.T_STRUCT typemap_StartVerification_args)
decode_StartVerification_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StartVerification_args
decode_StartVerification_args iprot bs = to_StartVerification_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartVerification_args) bs
typemap_StartVerification_args :: T.TypeMap
typemap_StartVerification_args = Map.fromList [(2,("region",T.T_STRING)),(3,("carrier",T.T_I32)),(4,("phone",T.T_STRING)),(5,("udidHash",T.T_STRING)),(6,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(7,("networkCode",T.T_STRING)),(8,("mid",T.T_STRING)),(9,("locale",T.T_STRING))]
default_StartVerification_args :: StartVerification_args
default_StartVerification_args = StartVerification_args{
  startVerification_args_region = "",
  startVerification_args_carrier = (P.toEnum 0),
  startVerification_args_phone = "",
  startVerification_args_udidHash = "",
  startVerification_args_deviceInfo = default_DeviceInfo,
  startVerification_args_networkCode = "",
  startVerification_args_mid = "",
  startVerification_args_locale = ""}
data StartVerification_result = StartVerification_result  { startVerification_result_success :: VerificationSessionData
  , startVerification_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartVerification_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startVerification_result_success record   `H.hashWithSalt` startVerification_result_e record  
instance QC.Arbitrary StartVerification_result where 
  arbitrary = M.liftM StartVerification_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StartVerification_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartVerification_result{startVerification_result_success = startVerification_result_success obj} then P.Nothing else P.Just $ default_StartVerification_result{startVerification_result_success = startVerification_result_success obj}
    , if obj == default_StartVerification_result{startVerification_result_e = startVerification_result_e obj} then P.Nothing else P.Just $ default_StartVerification_result{startVerification_result_e = startVerification_result_e obj}
    ]
from_StartVerification_result :: StartVerification_result -> T.ThriftVal
from_StartVerification_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5981 -> (1, ("e",from_TalkException _v5981))) <$> startVerification_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5981 -> P.Just (0, ("success",from_VerificationSessionData _v5981))) $ startVerification_result_success record
    , (\_v5981 -> (1, ("e",from_TalkException _v5981))) <$> startVerification_result_e record
    ]
    )
write_StartVerification_result :: T.Protocol p => p -> StartVerification_result -> P.IO ()
write_StartVerification_result oprot record = T.writeVal oprot $ from_StartVerification_result record
encode_StartVerification_result :: T.StatelessProtocol p => p -> StartVerification_result -> LBS.ByteString
encode_StartVerification_result oprot record = T.serializeVal oprot $ from_StartVerification_result record
to_StartVerification_result :: T.ThriftVal -> StartVerification_result
to_StartVerification_result (T.TStruct fields) = StartVerification_result{
  startVerification_result_success = P.maybe (startVerification_result_success default_StartVerification_result) (\(_,_val5983) -> (case _val5983 of {T.TStruct _val5984 -> (to_VerificationSessionData (T.TStruct _val5984)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  startVerification_result_e = P.maybe (P.Nothing) (\(_,_val5983) -> P.Just (case _val5983 of {T.TStruct _val5985 -> (to_TalkException (T.TStruct _val5985)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartVerification_result _ = P.error "not a struct"
read_StartVerification_result :: T.Protocol p => p -> P.IO StartVerification_result
read_StartVerification_result iprot = to_StartVerification_result <$> T.readVal iprot (T.T_STRUCT typemap_StartVerification_result)
decode_StartVerification_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StartVerification_result
decode_StartVerification_result iprot bs = to_StartVerification_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartVerification_result) bs
typemap_StartVerification_result :: T.TypeMap
typemap_StartVerification_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_VerificationSessionData))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_StartVerification_result :: StartVerification_result
default_StartVerification_result = StartVerification_result{
  startVerification_result_success = default_VerificationSessionData,
  startVerification_result_e = P.Nothing}
data StoreUpdateProfileAttribute_args = StoreUpdateProfileAttribute_args  { storeUpdateProfileAttribute_args_seq :: I.Int32
  , storeUpdateProfileAttribute_args_profileAttribute :: ProfileAttribute
  , storeUpdateProfileAttribute_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StoreUpdateProfileAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` storeUpdateProfileAttribute_args_seq record   `H.hashWithSalt` storeUpdateProfileAttribute_args_profileAttribute record   `H.hashWithSalt` storeUpdateProfileAttribute_args_value record  
instance QC.Arbitrary StoreUpdateProfileAttribute_args where 
  arbitrary = M.liftM StoreUpdateProfileAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StoreUpdateProfileAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_seq = storeUpdateProfileAttribute_args_seq obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_seq = storeUpdateProfileAttribute_args_seq obj}
    , if obj == default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_profileAttribute = storeUpdateProfileAttribute_args_profileAttribute obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_profileAttribute = storeUpdateProfileAttribute_args_profileAttribute obj}
    , if obj == default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_value = storeUpdateProfileAttribute_args_value obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_value = storeUpdateProfileAttribute_args_value obj}
    ]
from_StoreUpdateProfileAttribute_args :: StoreUpdateProfileAttribute_args -> T.ThriftVal
from_StoreUpdateProfileAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5988 -> P.Just (1, ("seq",T.TI32 _v5988))) $ storeUpdateProfileAttribute_args_seq record
  , (\_v5988 -> P.Just (2, ("profileAttribute",T.TI32 $ P.fromIntegral $ P.fromEnum _v5988))) $ storeUpdateProfileAttribute_args_profileAttribute record
  , (\_v5988 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v5988))) $ storeUpdateProfileAttribute_args_value record
  ]
write_StoreUpdateProfileAttribute_args :: T.Protocol p => p -> StoreUpdateProfileAttribute_args -> P.IO ()
write_StoreUpdateProfileAttribute_args oprot record = T.writeVal oprot $ from_StoreUpdateProfileAttribute_args record
encode_StoreUpdateProfileAttribute_args :: T.StatelessProtocol p => p -> StoreUpdateProfileAttribute_args -> LBS.ByteString
encode_StoreUpdateProfileAttribute_args oprot record = T.serializeVal oprot $ from_StoreUpdateProfileAttribute_args record
to_StoreUpdateProfileAttribute_args :: T.ThriftVal -> StoreUpdateProfileAttribute_args
to_StoreUpdateProfileAttribute_args (T.TStruct fields) = StoreUpdateProfileAttribute_args{
  storeUpdateProfileAttribute_args_seq = P.maybe (storeUpdateProfileAttribute_args_seq default_StoreUpdateProfileAttribute_args) (\(_,_val5990) -> (case _val5990 of {T.TI32 _val5991 -> _val5991; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  storeUpdateProfileAttribute_args_profileAttribute = P.maybe (storeUpdateProfileAttribute_args_profileAttribute default_StoreUpdateProfileAttribute_args) (\(_,_val5990) -> (case _val5990 of {T.TI32 _val5992 -> P.toEnum $ P.fromIntegral _val5992; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  storeUpdateProfileAttribute_args_value = P.maybe (storeUpdateProfileAttribute_args_value default_StoreUpdateProfileAttribute_args) (\(_,_val5990) -> (case _val5990 of {T.TString _val5993 -> E.decodeUtf8 _val5993; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_StoreUpdateProfileAttribute_args _ = P.error "not a struct"
read_StoreUpdateProfileAttribute_args :: T.Protocol p => p -> P.IO StoreUpdateProfileAttribute_args
read_StoreUpdateProfileAttribute_args iprot = to_StoreUpdateProfileAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_args)
decode_StoreUpdateProfileAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StoreUpdateProfileAttribute_args
decode_StoreUpdateProfileAttribute_args iprot bs = to_StoreUpdateProfileAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_args) bs
typemap_StoreUpdateProfileAttribute_args :: T.TypeMap
typemap_StoreUpdateProfileAttribute_args = Map.fromList [(1,("seq",T.T_I32)),(2,("profileAttribute",T.T_I32)),(3,("value",T.T_STRING))]
default_StoreUpdateProfileAttribute_args :: StoreUpdateProfileAttribute_args
default_StoreUpdateProfileAttribute_args = StoreUpdateProfileAttribute_args{
  storeUpdateProfileAttribute_args_seq = 0,
  storeUpdateProfileAttribute_args_profileAttribute = (P.toEnum 0),
  storeUpdateProfileAttribute_args_value = ""}
data StoreUpdateProfileAttribute_result = StoreUpdateProfileAttribute_result  { storeUpdateProfileAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StoreUpdateProfileAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` storeUpdateProfileAttribute_result_e record  
instance QC.Arbitrary StoreUpdateProfileAttribute_result where 
  arbitrary = M.liftM StoreUpdateProfileAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StoreUpdateProfileAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StoreUpdateProfileAttribute_result{storeUpdateProfileAttribute_result_e = storeUpdateProfileAttribute_result_e obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_result{storeUpdateProfileAttribute_result_e = storeUpdateProfileAttribute_result_e obj}
    ]
from_StoreUpdateProfileAttribute_result :: StoreUpdateProfileAttribute_result -> T.ThriftVal
from_StoreUpdateProfileAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5996 -> (1, ("e",from_TalkException _v5996))) <$> storeUpdateProfileAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5996 -> (1, ("e",from_TalkException _v5996))) <$> storeUpdateProfileAttribute_result_e record
    ]
    )
write_StoreUpdateProfileAttribute_result :: T.Protocol p => p -> StoreUpdateProfileAttribute_result -> P.IO ()
write_StoreUpdateProfileAttribute_result oprot record = T.writeVal oprot $ from_StoreUpdateProfileAttribute_result record
encode_StoreUpdateProfileAttribute_result :: T.StatelessProtocol p => p -> StoreUpdateProfileAttribute_result -> LBS.ByteString
encode_StoreUpdateProfileAttribute_result oprot record = T.serializeVal oprot $ from_StoreUpdateProfileAttribute_result record
to_StoreUpdateProfileAttribute_result :: T.ThriftVal -> StoreUpdateProfileAttribute_result
to_StoreUpdateProfileAttribute_result (T.TStruct fields) = StoreUpdateProfileAttribute_result{
  storeUpdateProfileAttribute_result_e = P.maybe (P.Nothing) (\(_,_val5998) -> P.Just (case _val5998 of {T.TStruct _val5999 -> (to_TalkException (T.TStruct _val5999)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StoreUpdateProfileAttribute_result _ = P.error "not a struct"
read_StoreUpdateProfileAttribute_result :: T.Protocol p => p -> P.IO StoreUpdateProfileAttribute_result
read_StoreUpdateProfileAttribute_result iprot = to_StoreUpdateProfileAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_result)
decode_StoreUpdateProfileAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StoreUpdateProfileAttribute_result
decode_StoreUpdateProfileAttribute_result iprot bs = to_StoreUpdateProfileAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_result) bs
typemap_StoreUpdateProfileAttribute_result :: T.TypeMap
typemap_StoreUpdateProfileAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_StoreUpdateProfileAttribute_result :: StoreUpdateProfileAttribute_result
default_StoreUpdateProfileAttribute_result = StoreUpdateProfileAttribute_result{
  storeUpdateProfileAttribute_result_e = P.Nothing}
data SyncContactBySnsIds_args = SyncContactBySnsIds_args  { syncContactBySnsIds_args_reqSeq :: I.Int32
  , syncContactBySnsIds_args_modifications :: (Vector.Vector SnsFriendModification)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContactBySnsIds_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContactBySnsIds_args_reqSeq record   `H.hashWithSalt` syncContactBySnsIds_args_modifications record  
instance QC.Arbitrary SyncContactBySnsIds_args where 
  arbitrary = M.liftM SyncContactBySnsIds_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncContactBySnsIds_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContactBySnsIds_args{syncContactBySnsIds_args_reqSeq = syncContactBySnsIds_args_reqSeq obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_args{syncContactBySnsIds_args_reqSeq = syncContactBySnsIds_args_reqSeq obj}
    , if obj == default_SyncContactBySnsIds_args{syncContactBySnsIds_args_modifications = syncContactBySnsIds_args_modifications obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_args{syncContactBySnsIds_args_modifications = syncContactBySnsIds_args_modifications obj}
    ]
from_SyncContactBySnsIds_args :: SyncContactBySnsIds_args -> T.ThriftVal
from_SyncContactBySnsIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6002 -> P.Just (1, ("reqSeq",T.TI32 _v6002))) $ syncContactBySnsIds_args_reqSeq record
  , (\_v6002 -> P.Just (2, ("modifications",T.TList (T.T_STRUCT typemap_SnsFriendModification) $ P.map (\_v6004 -> from_SnsFriendModification _v6004) $ Vector.toList _v6002))) $ syncContactBySnsIds_args_modifications record
  ]
write_SyncContactBySnsIds_args :: T.Protocol p => p -> SyncContactBySnsIds_args -> P.IO ()
write_SyncContactBySnsIds_args oprot record = T.writeVal oprot $ from_SyncContactBySnsIds_args record
encode_SyncContactBySnsIds_args :: T.StatelessProtocol p => p -> SyncContactBySnsIds_args -> LBS.ByteString
encode_SyncContactBySnsIds_args oprot record = T.serializeVal oprot $ from_SyncContactBySnsIds_args record
to_SyncContactBySnsIds_args :: T.ThriftVal -> SyncContactBySnsIds_args
to_SyncContactBySnsIds_args (T.TStruct fields) = SyncContactBySnsIds_args{
  syncContactBySnsIds_args_reqSeq = P.maybe (syncContactBySnsIds_args_reqSeq default_SyncContactBySnsIds_args) (\(_,_val6006) -> (case _val6006 of {T.TI32 _val6007 -> _val6007; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncContactBySnsIds_args_modifications = P.maybe (syncContactBySnsIds_args_modifications default_SyncContactBySnsIds_args) (\(_,_val6006) -> (case _val6006 of {T.TList _ _val6008 -> (Vector.fromList $ P.map (\_v6009 -> (case _v6009 of {T.TStruct _val6010 -> (to_SnsFriendModification (T.TStruct _val6010)); _ -> P.error "wrong type"})) _val6008); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SyncContactBySnsIds_args _ = P.error "not a struct"
read_SyncContactBySnsIds_args :: T.Protocol p => p -> P.IO SyncContactBySnsIds_args
read_SyncContactBySnsIds_args iprot = to_SyncContactBySnsIds_args <$> T.readVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_args)
decode_SyncContactBySnsIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContactBySnsIds_args
decode_SyncContactBySnsIds_args iprot bs = to_SyncContactBySnsIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_args) bs
typemap_SyncContactBySnsIds_args :: T.TypeMap
typemap_SyncContactBySnsIds_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("modifications",(T.T_LIST (T.T_STRUCT typemap_SnsFriendModification))))]
default_SyncContactBySnsIds_args :: SyncContactBySnsIds_args
default_SyncContactBySnsIds_args = SyncContactBySnsIds_args{
  syncContactBySnsIds_args_reqSeq = 0,
  syncContactBySnsIds_args_modifications = Vector.empty}
data SyncContactBySnsIds_result = SyncContactBySnsIds_result  { syncContactBySnsIds_result_success :: (Vector.Vector SnsFriendContactRegistration)
  , syncContactBySnsIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContactBySnsIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContactBySnsIds_result_success record   `H.hashWithSalt` syncContactBySnsIds_result_e record  
instance QC.Arbitrary SyncContactBySnsIds_result where 
  arbitrary = M.liftM SyncContactBySnsIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncContactBySnsIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContactBySnsIds_result{syncContactBySnsIds_result_success = syncContactBySnsIds_result_success obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_result{syncContactBySnsIds_result_success = syncContactBySnsIds_result_success obj}
    , if obj == default_SyncContactBySnsIds_result{syncContactBySnsIds_result_e = syncContactBySnsIds_result_e obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_result{syncContactBySnsIds_result_e = syncContactBySnsIds_result_e obj}
    ]
from_SyncContactBySnsIds_result :: SyncContactBySnsIds_result -> T.ThriftVal
from_SyncContactBySnsIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6013 -> (1, ("e",from_TalkException _v6013))) <$> syncContactBySnsIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6013 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SnsFriendContactRegistration) $ P.map (\_v6015 -> from_SnsFriendContactRegistration _v6015) $ Vector.toList _v6013))) $ syncContactBySnsIds_result_success record
    , (\_v6013 -> (1, ("e",from_TalkException _v6013))) <$> syncContactBySnsIds_result_e record
    ]
    )
write_SyncContactBySnsIds_result :: T.Protocol p => p -> SyncContactBySnsIds_result -> P.IO ()
write_SyncContactBySnsIds_result oprot record = T.writeVal oprot $ from_SyncContactBySnsIds_result record
encode_SyncContactBySnsIds_result :: T.StatelessProtocol p => p -> SyncContactBySnsIds_result -> LBS.ByteString
encode_SyncContactBySnsIds_result oprot record = T.serializeVal oprot $ from_SyncContactBySnsIds_result record
to_SyncContactBySnsIds_result :: T.ThriftVal -> SyncContactBySnsIds_result
to_SyncContactBySnsIds_result (T.TStruct fields) = SyncContactBySnsIds_result{
  syncContactBySnsIds_result_success = P.maybe (syncContactBySnsIds_result_success default_SyncContactBySnsIds_result) (\(_,_val6017) -> (case _val6017 of {T.TList _ _val6018 -> (Vector.fromList $ P.map (\_v6019 -> (case _v6019 of {T.TStruct _val6020 -> (to_SnsFriendContactRegistration (T.TStruct _val6020)); _ -> P.error "wrong type"})) _val6018); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  syncContactBySnsIds_result_e = P.maybe (P.Nothing) (\(_,_val6017) -> P.Just (case _val6017 of {T.TStruct _val6021 -> (to_TalkException (T.TStruct _val6021)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SyncContactBySnsIds_result _ = P.error "not a struct"
read_SyncContactBySnsIds_result :: T.Protocol p => p -> P.IO SyncContactBySnsIds_result
read_SyncContactBySnsIds_result iprot = to_SyncContactBySnsIds_result <$> T.readVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_result)
decode_SyncContactBySnsIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContactBySnsIds_result
decode_SyncContactBySnsIds_result iprot bs = to_SyncContactBySnsIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_result) bs
typemap_SyncContactBySnsIds_result :: T.TypeMap
typemap_SyncContactBySnsIds_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SnsFriendContactRegistration)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SyncContactBySnsIds_result :: SyncContactBySnsIds_result
default_SyncContactBySnsIds_result = SyncContactBySnsIds_result{
  syncContactBySnsIds_result_success = Vector.empty,
  syncContactBySnsIds_result_e = P.Nothing}
data SyncContacts_args = SyncContacts_args  { syncContacts_args_reqSeq :: I.Int32
  , syncContacts_args_localContacts :: (Vector.Vector ContactModification)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContacts_args_reqSeq record   `H.hashWithSalt` syncContacts_args_localContacts record  
instance QC.Arbitrary SyncContacts_args where 
  arbitrary = M.liftM SyncContacts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContacts_args{syncContacts_args_reqSeq = syncContacts_args_reqSeq obj} then P.Nothing else P.Just $ default_SyncContacts_args{syncContacts_args_reqSeq = syncContacts_args_reqSeq obj}
    , if obj == default_SyncContacts_args{syncContacts_args_localContacts = syncContacts_args_localContacts obj} then P.Nothing else P.Just $ default_SyncContacts_args{syncContacts_args_localContacts = syncContacts_args_localContacts obj}
    ]
from_SyncContacts_args :: SyncContacts_args -> T.ThriftVal
from_SyncContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6024 -> P.Just (1, ("reqSeq",T.TI32 _v6024))) $ syncContacts_args_reqSeq record
  , (\_v6024 -> P.Just (2, ("localContacts",T.TList (T.T_STRUCT typemap_ContactModification) $ P.map (\_v6026 -> from_ContactModification _v6026) $ Vector.toList _v6024))) $ syncContacts_args_localContacts record
  ]
write_SyncContacts_args :: T.Protocol p => p -> SyncContacts_args -> P.IO ()
write_SyncContacts_args oprot record = T.writeVal oprot $ from_SyncContacts_args record
encode_SyncContacts_args :: T.StatelessProtocol p => p -> SyncContacts_args -> LBS.ByteString
encode_SyncContacts_args oprot record = T.serializeVal oprot $ from_SyncContacts_args record
to_SyncContacts_args :: T.ThriftVal -> SyncContacts_args
to_SyncContacts_args (T.TStruct fields) = SyncContacts_args{
  syncContacts_args_reqSeq = P.maybe (syncContacts_args_reqSeq default_SyncContacts_args) (\(_,_val6028) -> (case _val6028 of {T.TI32 _val6029 -> _val6029; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncContacts_args_localContacts = P.maybe (syncContacts_args_localContacts default_SyncContacts_args) (\(_,_val6028) -> (case _val6028 of {T.TList _ _val6030 -> (Vector.fromList $ P.map (\_v6031 -> (case _v6031 of {T.TStruct _val6032 -> (to_ContactModification (T.TStruct _val6032)); _ -> P.error "wrong type"})) _val6030); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SyncContacts_args _ = P.error "not a struct"
read_SyncContacts_args :: T.Protocol p => p -> P.IO SyncContacts_args
read_SyncContacts_args iprot = to_SyncContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_SyncContacts_args)
decode_SyncContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContacts_args
decode_SyncContacts_args iprot bs = to_SyncContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContacts_args) bs
typemap_SyncContacts_args :: T.TypeMap
typemap_SyncContacts_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("localContacts",(T.T_LIST (T.T_STRUCT typemap_ContactModification))))]
default_SyncContacts_args :: SyncContacts_args
default_SyncContacts_args = SyncContacts_args{
  syncContacts_args_reqSeq = 0,
  syncContacts_args_localContacts = Vector.empty}
data SyncContacts_result = SyncContacts_result  { syncContacts_result_success :: (Map.HashMap LT.Text ContactRegistration)
  , syncContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContacts_result_success record   `H.hashWithSalt` syncContacts_result_e record  
instance QC.Arbitrary SyncContacts_result where 
  arbitrary = M.liftM SyncContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContacts_result{syncContacts_result_success = syncContacts_result_success obj} then P.Nothing else P.Just $ default_SyncContacts_result{syncContacts_result_success = syncContacts_result_success obj}
    , if obj == default_SyncContacts_result{syncContacts_result_e = syncContacts_result_e obj} then P.Nothing else P.Just $ default_SyncContacts_result{syncContacts_result_e = syncContacts_result_e obj}
    ]
from_SyncContacts_result :: SyncContacts_result -> T.ThriftVal
from_SyncContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6035 -> (1, ("e",from_TalkException _v6035))) <$> syncContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6035 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_ContactRegistration) $ P.map (\(_k6036,_v6037) -> (T.TString $ E.encodeUtf8 _k6036, from_ContactRegistration _v6037)) $ Map.toList _v6035))) $ syncContacts_result_success record
    , (\_v6035 -> (1, ("e",from_TalkException _v6035))) <$> syncContacts_result_e record
    ]
    )
write_SyncContacts_result :: T.Protocol p => p -> SyncContacts_result -> P.IO ()
write_SyncContacts_result oprot record = T.writeVal oprot $ from_SyncContacts_result record
encode_SyncContacts_result :: T.StatelessProtocol p => p -> SyncContacts_result -> LBS.ByteString
encode_SyncContacts_result oprot record = T.serializeVal oprot $ from_SyncContacts_result record
to_SyncContacts_result :: T.ThriftVal -> SyncContacts_result
to_SyncContacts_result (T.TStruct fields) = SyncContacts_result{
  syncContacts_result_success = P.maybe (syncContacts_result_success default_SyncContacts_result) (\(_,_val6039) -> (case _val6039 of {T.TMap _ _ _val6040 -> (Map.fromList $ P.map (\(_k6042,_v6041) -> ((case _k6042 of {T.TString _val6043 -> E.decodeUtf8 _val6043; _ -> P.error "wrong type"}),(case _v6041 of {T.TStruct _val6044 -> (to_ContactRegistration (T.TStruct _val6044)); _ -> P.error "wrong type"}))) _val6040); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  syncContacts_result_e = P.maybe (P.Nothing) (\(_,_val6039) -> P.Just (case _val6039 of {T.TStruct _val6045 -> (to_TalkException (T.TStruct _val6045)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SyncContacts_result _ = P.error "not a struct"
read_SyncContacts_result :: T.Protocol p => p -> P.IO SyncContacts_result
read_SyncContacts_result iprot = to_SyncContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_SyncContacts_result)
decode_SyncContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContacts_result
decode_SyncContacts_result iprot bs = to_SyncContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContacts_result) bs
typemap_SyncContacts_result :: T.TypeMap
typemap_SyncContacts_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_ContactRegistration)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SyncContacts_result :: SyncContacts_result
default_SyncContacts_result = SyncContacts_result{
  syncContacts_result_success = Map.empty,
  syncContacts_result_e = P.Nothing}
data TrySendMessage_args = TrySendMessage_args  { trySendMessage_args_seq :: I.Int32
  , trySendMessage_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TrySendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` trySendMessage_args_seq record   `H.hashWithSalt` trySendMessage_args_message record  
instance QC.Arbitrary TrySendMessage_args where 
  arbitrary = M.liftM TrySendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TrySendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TrySendMessage_args{trySendMessage_args_seq = trySendMessage_args_seq obj} then P.Nothing else P.Just $ default_TrySendMessage_args{trySendMessage_args_seq = trySendMessage_args_seq obj}
    , if obj == default_TrySendMessage_args{trySendMessage_args_message = trySendMessage_args_message obj} then P.Nothing else P.Just $ default_TrySendMessage_args{trySendMessage_args_message = trySendMessage_args_message obj}
    ]
from_TrySendMessage_args :: TrySendMessage_args -> T.ThriftVal
from_TrySendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6048 -> P.Just (1, ("seq",T.TI32 _v6048))) $ trySendMessage_args_seq record
  , (\_v6048 -> P.Just (2, ("message",from_Message _v6048))) $ trySendMessage_args_message record
  ]
write_TrySendMessage_args :: T.Protocol p => p -> TrySendMessage_args -> P.IO ()
write_TrySendMessage_args oprot record = T.writeVal oprot $ from_TrySendMessage_args record
encode_TrySendMessage_args :: T.StatelessProtocol p => p -> TrySendMessage_args -> LBS.ByteString
encode_TrySendMessage_args oprot record = T.serializeVal oprot $ from_TrySendMessage_args record
to_TrySendMessage_args :: T.ThriftVal -> TrySendMessage_args
to_TrySendMessage_args (T.TStruct fields) = TrySendMessage_args{
  trySendMessage_args_seq = P.maybe (trySendMessage_args_seq default_TrySendMessage_args) (\(_,_val6050) -> (case _val6050 of {T.TI32 _val6051 -> _val6051; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  trySendMessage_args_message = P.maybe (trySendMessage_args_message default_TrySendMessage_args) (\(_,_val6050) -> (case _val6050 of {T.TStruct _val6052 -> (to_Message (T.TStruct _val6052)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TrySendMessage_args _ = P.error "not a struct"
read_TrySendMessage_args :: T.Protocol p => p -> P.IO TrySendMessage_args
read_TrySendMessage_args iprot = to_TrySendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_TrySendMessage_args)
decode_TrySendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> TrySendMessage_args
decode_TrySendMessage_args iprot bs = to_TrySendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TrySendMessage_args) bs
typemap_TrySendMessage_args :: T.TypeMap
typemap_TrySendMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_TrySendMessage_args :: TrySendMessage_args
default_TrySendMessage_args = TrySendMessage_args{
  trySendMessage_args_seq = 0,
  trySendMessage_args_message = default_Message}
data TrySendMessage_result = TrySendMessage_result  { trySendMessage_result_success :: Message
  , trySendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TrySendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` trySendMessage_result_success record   `H.hashWithSalt` trySendMessage_result_e record  
instance QC.Arbitrary TrySendMessage_result where 
  arbitrary = M.liftM TrySendMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TrySendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TrySendMessage_result{trySendMessage_result_success = trySendMessage_result_success obj} then P.Nothing else P.Just $ default_TrySendMessage_result{trySendMessage_result_success = trySendMessage_result_success obj}
    , if obj == default_TrySendMessage_result{trySendMessage_result_e = trySendMessage_result_e obj} then P.Nothing else P.Just $ default_TrySendMessage_result{trySendMessage_result_e = trySendMessage_result_e obj}
    ]
from_TrySendMessage_result :: TrySendMessage_result -> T.ThriftVal
from_TrySendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6055 -> (1, ("e",from_TalkException _v6055))) <$> trySendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6055 -> P.Just (0, ("success",from_Message _v6055))) $ trySendMessage_result_success record
    , (\_v6055 -> (1, ("e",from_TalkException _v6055))) <$> trySendMessage_result_e record
    ]
    )
write_TrySendMessage_result :: T.Protocol p => p -> TrySendMessage_result -> P.IO ()
write_TrySendMessage_result oprot record = T.writeVal oprot $ from_TrySendMessage_result record
encode_TrySendMessage_result :: T.StatelessProtocol p => p -> TrySendMessage_result -> LBS.ByteString
encode_TrySendMessage_result oprot record = T.serializeVal oprot $ from_TrySendMessage_result record
to_TrySendMessage_result :: T.ThriftVal -> TrySendMessage_result
to_TrySendMessage_result (T.TStruct fields) = TrySendMessage_result{
  trySendMessage_result_success = P.maybe (trySendMessage_result_success default_TrySendMessage_result) (\(_,_val6057) -> (case _val6057 of {T.TStruct _val6058 -> (to_Message (T.TStruct _val6058)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  trySendMessage_result_e = P.maybe (P.Nothing) (\(_,_val6057) -> P.Just (case _val6057 of {T.TStruct _val6059 -> (to_TalkException (T.TStruct _val6059)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TrySendMessage_result _ = P.error "not a struct"
read_TrySendMessage_result :: T.Protocol p => p -> P.IO TrySendMessage_result
read_TrySendMessage_result iprot = to_TrySendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_TrySendMessage_result)
decode_TrySendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> TrySendMessage_result
decode_TrySendMessage_result iprot bs = to_TrySendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TrySendMessage_result) bs
typemap_TrySendMessage_result :: T.TypeMap
typemap_TrySendMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_TrySendMessage_result :: TrySendMessage_result
default_TrySendMessage_result = TrySendMessage_result{
  trySendMessage_result_success = default_Message,
  trySendMessage_result_e = P.Nothing}
data UnblockContact_args = UnblockContact_args  { unblockContact_args_reqSeq :: I.Int32
  , unblockContact_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockContact_args_reqSeq record   `H.hashWithSalt` unblockContact_args_id record  
instance QC.Arbitrary UnblockContact_args where 
  arbitrary = M.liftM UnblockContact_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UnblockContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockContact_args{unblockContact_args_reqSeq = unblockContact_args_reqSeq obj} then P.Nothing else P.Just $ default_UnblockContact_args{unblockContact_args_reqSeq = unblockContact_args_reqSeq obj}
    , if obj == default_UnblockContact_args{unblockContact_args_id = unblockContact_args_id obj} then P.Nothing else P.Just $ default_UnblockContact_args{unblockContact_args_id = unblockContact_args_id obj}
    ]
from_UnblockContact_args :: UnblockContact_args -> T.ThriftVal
from_UnblockContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6062 -> P.Just (1, ("reqSeq",T.TI32 _v6062))) $ unblockContact_args_reqSeq record
  , (\_v6062 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v6062))) $ unblockContact_args_id record
  ]
write_UnblockContact_args :: T.Protocol p => p -> UnblockContact_args -> P.IO ()
write_UnblockContact_args oprot record = T.writeVal oprot $ from_UnblockContact_args record
encode_UnblockContact_args :: T.StatelessProtocol p => p -> UnblockContact_args -> LBS.ByteString
encode_UnblockContact_args oprot record = T.serializeVal oprot $ from_UnblockContact_args record
to_UnblockContact_args :: T.ThriftVal -> UnblockContact_args
to_UnblockContact_args (T.TStruct fields) = UnblockContact_args{
  unblockContact_args_reqSeq = P.maybe (unblockContact_args_reqSeq default_UnblockContact_args) (\(_,_val6064) -> (case _val6064 of {T.TI32 _val6065 -> _val6065; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unblockContact_args_id = P.maybe (unblockContact_args_id default_UnblockContact_args) (\(_,_val6064) -> (case _val6064 of {T.TString _val6066 -> E.decodeUtf8 _val6066; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UnblockContact_args _ = P.error "not a struct"
read_UnblockContact_args :: T.Protocol p => p -> P.IO UnblockContact_args
read_UnblockContact_args iprot = to_UnblockContact_args <$> T.readVal iprot (T.T_STRUCT typemap_UnblockContact_args)
decode_UnblockContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockContact_args
decode_UnblockContact_args iprot bs = to_UnblockContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockContact_args) bs
typemap_UnblockContact_args :: T.TypeMap
typemap_UnblockContact_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_UnblockContact_args :: UnblockContact_args
default_UnblockContact_args = UnblockContact_args{
  unblockContact_args_reqSeq = 0,
  unblockContact_args_id = ""}
data UnblockContact_result = UnblockContact_result  { unblockContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockContact_result_e record  
instance QC.Arbitrary UnblockContact_result where 
  arbitrary = M.liftM UnblockContact_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnblockContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockContact_result{unblockContact_result_e = unblockContact_result_e obj} then P.Nothing else P.Just $ default_UnblockContact_result{unblockContact_result_e = unblockContact_result_e obj}
    ]
from_UnblockContact_result :: UnblockContact_result -> T.ThriftVal
from_UnblockContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6069 -> (1, ("e",from_TalkException _v6069))) <$> unblockContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6069 -> (1, ("e",from_TalkException _v6069))) <$> unblockContact_result_e record
    ]
    )
write_UnblockContact_result :: T.Protocol p => p -> UnblockContact_result -> P.IO ()
write_UnblockContact_result oprot record = T.writeVal oprot $ from_UnblockContact_result record
encode_UnblockContact_result :: T.StatelessProtocol p => p -> UnblockContact_result -> LBS.ByteString
encode_UnblockContact_result oprot record = T.serializeVal oprot $ from_UnblockContact_result record
to_UnblockContact_result :: T.ThriftVal -> UnblockContact_result
to_UnblockContact_result (T.TStruct fields) = UnblockContact_result{
  unblockContact_result_e = P.maybe (P.Nothing) (\(_,_val6071) -> P.Just (case _val6071 of {T.TStruct _val6072 -> (to_TalkException (T.TStruct _val6072)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnblockContact_result _ = P.error "not a struct"
read_UnblockContact_result :: T.Protocol p => p -> P.IO UnblockContact_result
read_UnblockContact_result iprot = to_UnblockContact_result <$> T.readVal iprot (T.T_STRUCT typemap_UnblockContact_result)
decode_UnblockContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockContact_result
decode_UnblockContact_result iprot bs = to_UnblockContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockContact_result) bs
typemap_UnblockContact_result :: T.TypeMap
typemap_UnblockContact_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnblockContact_result :: UnblockContact_result
default_UnblockContact_result = UnblockContact_result{
  unblockContact_result_e = P.Nothing}
data UnblockRecommendation_args = UnblockRecommendation_args  { unblockRecommendation_args_reqSeq :: I.Int32
  , unblockRecommendation_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockRecommendation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockRecommendation_args_reqSeq record   `H.hashWithSalt` unblockRecommendation_args_id record  
instance QC.Arbitrary UnblockRecommendation_args where 
  arbitrary = M.liftM UnblockRecommendation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UnblockRecommendation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockRecommendation_args{unblockRecommendation_args_reqSeq = unblockRecommendation_args_reqSeq obj} then P.Nothing else P.Just $ default_UnblockRecommendation_args{unblockRecommendation_args_reqSeq = unblockRecommendation_args_reqSeq obj}
    , if obj == default_UnblockRecommendation_args{unblockRecommendation_args_id = unblockRecommendation_args_id obj} then P.Nothing else P.Just $ default_UnblockRecommendation_args{unblockRecommendation_args_id = unblockRecommendation_args_id obj}
    ]
from_UnblockRecommendation_args :: UnblockRecommendation_args -> T.ThriftVal
from_UnblockRecommendation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6075 -> P.Just (1, ("reqSeq",T.TI32 _v6075))) $ unblockRecommendation_args_reqSeq record
  , (\_v6075 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v6075))) $ unblockRecommendation_args_id record
  ]
write_UnblockRecommendation_args :: T.Protocol p => p -> UnblockRecommendation_args -> P.IO ()
write_UnblockRecommendation_args oprot record = T.writeVal oprot $ from_UnblockRecommendation_args record
encode_UnblockRecommendation_args :: T.StatelessProtocol p => p -> UnblockRecommendation_args -> LBS.ByteString
encode_UnblockRecommendation_args oprot record = T.serializeVal oprot $ from_UnblockRecommendation_args record
to_UnblockRecommendation_args :: T.ThriftVal -> UnblockRecommendation_args
to_UnblockRecommendation_args (T.TStruct fields) = UnblockRecommendation_args{
  unblockRecommendation_args_reqSeq = P.maybe (unblockRecommendation_args_reqSeq default_UnblockRecommendation_args) (\(_,_val6077) -> (case _val6077 of {T.TI32 _val6078 -> _val6078; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unblockRecommendation_args_id = P.maybe (unblockRecommendation_args_id default_UnblockRecommendation_args) (\(_,_val6077) -> (case _val6077 of {T.TString _val6079 -> E.decodeUtf8 _val6079; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UnblockRecommendation_args _ = P.error "not a struct"
read_UnblockRecommendation_args :: T.Protocol p => p -> P.IO UnblockRecommendation_args
read_UnblockRecommendation_args iprot = to_UnblockRecommendation_args <$> T.readVal iprot (T.T_STRUCT typemap_UnblockRecommendation_args)
decode_UnblockRecommendation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockRecommendation_args
decode_UnblockRecommendation_args iprot bs = to_UnblockRecommendation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockRecommendation_args) bs
typemap_UnblockRecommendation_args :: T.TypeMap
typemap_UnblockRecommendation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_UnblockRecommendation_args :: UnblockRecommendation_args
default_UnblockRecommendation_args = UnblockRecommendation_args{
  unblockRecommendation_args_reqSeq = 0,
  unblockRecommendation_args_id = ""}
data UnblockRecommendation_result = UnblockRecommendation_result  { unblockRecommendation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockRecommendation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockRecommendation_result_e record  
instance QC.Arbitrary UnblockRecommendation_result where 
  arbitrary = M.liftM UnblockRecommendation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnblockRecommendation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockRecommendation_result{unblockRecommendation_result_e = unblockRecommendation_result_e obj} then P.Nothing else P.Just $ default_UnblockRecommendation_result{unblockRecommendation_result_e = unblockRecommendation_result_e obj}
    ]
from_UnblockRecommendation_result :: UnblockRecommendation_result -> T.ThriftVal
from_UnblockRecommendation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6082 -> (1, ("e",from_TalkException _v6082))) <$> unblockRecommendation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6082 -> (1, ("e",from_TalkException _v6082))) <$> unblockRecommendation_result_e record
    ]
    )
write_UnblockRecommendation_result :: T.Protocol p => p -> UnblockRecommendation_result -> P.IO ()
write_UnblockRecommendation_result oprot record = T.writeVal oprot $ from_UnblockRecommendation_result record
encode_UnblockRecommendation_result :: T.StatelessProtocol p => p -> UnblockRecommendation_result -> LBS.ByteString
encode_UnblockRecommendation_result oprot record = T.serializeVal oprot $ from_UnblockRecommendation_result record
to_UnblockRecommendation_result :: T.ThriftVal -> UnblockRecommendation_result
to_UnblockRecommendation_result (T.TStruct fields) = UnblockRecommendation_result{
  unblockRecommendation_result_e = P.maybe (P.Nothing) (\(_,_val6084) -> P.Just (case _val6084 of {T.TStruct _val6085 -> (to_TalkException (T.TStruct _val6085)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnblockRecommendation_result _ = P.error "not a struct"
read_UnblockRecommendation_result :: T.Protocol p => p -> P.IO UnblockRecommendation_result
read_UnblockRecommendation_result iprot = to_UnblockRecommendation_result <$> T.readVal iprot (T.T_STRUCT typemap_UnblockRecommendation_result)
decode_UnblockRecommendation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockRecommendation_result
decode_UnblockRecommendation_result iprot bs = to_UnblockRecommendation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockRecommendation_result) bs
typemap_UnblockRecommendation_result :: T.TypeMap
typemap_UnblockRecommendation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnblockRecommendation_result :: UnblockRecommendation_result
default_UnblockRecommendation_result = UnblockRecommendation_result{
  unblockRecommendation_result_e = P.Nothing}
data UnregisterUserAndDevice_args = UnregisterUserAndDevice_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnregisterUserAndDevice_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary UnregisterUserAndDevice_args where 
  arbitrary = QC.elements [UnregisterUserAndDevice_args]
from_UnregisterUserAndDevice_args :: UnregisterUserAndDevice_args -> T.ThriftVal
from_UnregisterUserAndDevice_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_UnregisterUserAndDevice_args :: T.Protocol p => p -> UnregisterUserAndDevice_args -> P.IO ()
write_UnregisterUserAndDevice_args oprot record = T.writeVal oprot $ from_UnregisterUserAndDevice_args record
encode_UnregisterUserAndDevice_args :: T.StatelessProtocol p => p -> UnregisterUserAndDevice_args -> LBS.ByteString
encode_UnregisterUserAndDevice_args oprot record = T.serializeVal oprot $ from_UnregisterUserAndDevice_args record
to_UnregisterUserAndDevice_args :: T.ThriftVal -> UnregisterUserAndDevice_args
to_UnregisterUserAndDevice_args (T.TStruct fields) = UnregisterUserAndDevice_args{

  }
to_UnregisterUserAndDevice_args _ = P.error "not a struct"
read_UnregisterUserAndDevice_args :: T.Protocol p => p -> P.IO UnregisterUserAndDevice_args
read_UnregisterUserAndDevice_args iprot = to_UnregisterUserAndDevice_args <$> T.readVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_args)
decode_UnregisterUserAndDevice_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnregisterUserAndDevice_args
decode_UnregisterUserAndDevice_args iprot bs = to_UnregisterUserAndDevice_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_args) bs
typemap_UnregisterUserAndDevice_args :: T.TypeMap
typemap_UnregisterUserAndDevice_args = Map.fromList []
default_UnregisterUserAndDevice_args :: UnregisterUserAndDevice_args
default_UnregisterUserAndDevice_args = UnregisterUserAndDevice_args{
}
data UnregisterUserAndDevice_result = UnregisterUserAndDevice_result  { unregisterUserAndDevice_result_success :: LT.Text
  , unregisterUserAndDevice_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnregisterUserAndDevice_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unregisterUserAndDevice_result_success record   `H.hashWithSalt` unregisterUserAndDevice_result_e record  
instance QC.Arbitrary UnregisterUserAndDevice_result where 
  arbitrary = M.liftM UnregisterUserAndDevice_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnregisterUserAndDevice_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_success = unregisterUserAndDevice_result_success obj} then P.Nothing else P.Just $ default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_success = unregisterUserAndDevice_result_success obj}
    , if obj == default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_e = unregisterUserAndDevice_result_e obj} then P.Nothing else P.Just $ default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_e = unregisterUserAndDevice_result_e obj}
    ]
from_UnregisterUserAndDevice_result :: UnregisterUserAndDevice_result -> T.ThriftVal
from_UnregisterUserAndDevice_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6093 -> (1, ("e",from_TalkException _v6093))) <$> unregisterUserAndDevice_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6093 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6093))) $ unregisterUserAndDevice_result_success record
    , (\_v6093 -> (1, ("e",from_TalkException _v6093))) <$> unregisterUserAndDevice_result_e record
    ]
    )
write_UnregisterUserAndDevice_result :: T.Protocol p => p -> UnregisterUserAndDevice_result -> P.IO ()
write_UnregisterUserAndDevice_result oprot record = T.writeVal oprot $ from_UnregisterUserAndDevice_result record
encode_UnregisterUserAndDevice_result :: T.StatelessProtocol p => p -> UnregisterUserAndDevice_result -> LBS.ByteString
encode_UnregisterUserAndDevice_result oprot record = T.serializeVal oprot $ from_UnregisterUserAndDevice_result record
to_UnregisterUserAndDevice_result :: T.ThriftVal -> UnregisterUserAndDevice_result
to_UnregisterUserAndDevice_result (T.TStruct fields) = UnregisterUserAndDevice_result{
  unregisterUserAndDevice_result_success = P.maybe (unregisterUserAndDevice_result_success default_UnregisterUserAndDevice_result) (\(_,_val6095) -> (case _val6095 of {T.TString _val6096 -> E.decodeUtf8 _val6096; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  unregisterUserAndDevice_result_e = P.maybe (P.Nothing) (\(_,_val6095) -> P.Just (case _val6095 of {T.TStruct _val6097 -> (to_TalkException (T.TStruct _val6097)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnregisterUserAndDevice_result _ = P.error "not a struct"
read_UnregisterUserAndDevice_result :: T.Protocol p => p -> P.IO UnregisterUserAndDevice_result
read_UnregisterUserAndDevice_result iprot = to_UnregisterUserAndDevice_result <$> T.readVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_result)
decode_UnregisterUserAndDevice_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnregisterUserAndDevice_result
decode_UnregisterUserAndDevice_result iprot bs = to_UnregisterUserAndDevice_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_result) bs
typemap_UnregisterUserAndDevice_result :: T.TypeMap
typemap_UnregisterUserAndDevice_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnregisterUserAndDevice_result :: UnregisterUserAndDevice_result
default_UnregisterUserAndDevice_result = UnregisterUserAndDevice_result{
  unregisterUserAndDevice_result_success = "",
  unregisterUserAndDevice_result_e = P.Nothing}
data UpdateApnsDeviceToken_args = UpdateApnsDeviceToken_args  { updateApnsDeviceToken_args_apnsDeviceToken :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateApnsDeviceToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateApnsDeviceToken_args_apnsDeviceToken record  
instance QC.Arbitrary UpdateApnsDeviceToken_args where 
  arbitrary = M.liftM UpdateApnsDeviceToken_args (QC.arbitrary)
  shrink obj | obj == default_UpdateApnsDeviceToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateApnsDeviceToken_args{updateApnsDeviceToken_args_apnsDeviceToken = updateApnsDeviceToken_args_apnsDeviceToken obj} then P.Nothing else P.Just $ default_UpdateApnsDeviceToken_args{updateApnsDeviceToken_args_apnsDeviceToken = updateApnsDeviceToken_args_apnsDeviceToken obj}
    ]
from_UpdateApnsDeviceToken_args :: UpdateApnsDeviceToken_args -> T.ThriftVal
from_UpdateApnsDeviceToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6100 -> P.Just (2, ("apnsDeviceToken",T.TBinary _v6100))) $ updateApnsDeviceToken_args_apnsDeviceToken record
  ]
write_UpdateApnsDeviceToken_args :: T.Protocol p => p -> UpdateApnsDeviceToken_args -> P.IO ()
write_UpdateApnsDeviceToken_args oprot record = T.writeVal oprot $ from_UpdateApnsDeviceToken_args record
encode_UpdateApnsDeviceToken_args :: T.StatelessProtocol p => p -> UpdateApnsDeviceToken_args -> LBS.ByteString
encode_UpdateApnsDeviceToken_args oprot record = T.serializeVal oprot $ from_UpdateApnsDeviceToken_args record
to_UpdateApnsDeviceToken_args :: T.ThriftVal -> UpdateApnsDeviceToken_args
to_UpdateApnsDeviceToken_args (T.TStruct fields) = UpdateApnsDeviceToken_args{
  updateApnsDeviceToken_args_apnsDeviceToken = P.maybe (updateApnsDeviceToken_args_apnsDeviceToken default_UpdateApnsDeviceToken_args) (\(_,_val6102) -> (case _val6102 of {T.TBinary _val6103 -> _val6103; T.TString _val6103 -> _val6103; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateApnsDeviceToken_args _ = P.error "not a struct"
read_UpdateApnsDeviceToken_args :: T.Protocol p => p -> P.IO UpdateApnsDeviceToken_args
read_UpdateApnsDeviceToken_args iprot = to_UpdateApnsDeviceToken_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_args)
decode_UpdateApnsDeviceToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateApnsDeviceToken_args
decode_UpdateApnsDeviceToken_args iprot bs = to_UpdateApnsDeviceToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_args) bs
typemap_UpdateApnsDeviceToken_args :: T.TypeMap
typemap_UpdateApnsDeviceToken_args = Map.fromList [(2,("apnsDeviceToken",T.T_BINARY))]
default_UpdateApnsDeviceToken_args :: UpdateApnsDeviceToken_args
default_UpdateApnsDeviceToken_args = UpdateApnsDeviceToken_args{
  updateApnsDeviceToken_args_apnsDeviceToken = ""}
data UpdateApnsDeviceToken_result = UpdateApnsDeviceToken_result  { updateApnsDeviceToken_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateApnsDeviceToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateApnsDeviceToken_result_e record  
instance QC.Arbitrary UpdateApnsDeviceToken_result where 
  arbitrary = M.liftM UpdateApnsDeviceToken_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateApnsDeviceToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateApnsDeviceToken_result{updateApnsDeviceToken_result_e = updateApnsDeviceToken_result_e obj} then P.Nothing else P.Just $ default_UpdateApnsDeviceToken_result{updateApnsDeviceToken_result_e = updateApnsDeviceToken_result_e obj}
    ]
from_UpdateApnsDeviceToken_result :: UpdateApnsDeviceToken_result -> T.ThriftVal
from_UpdateApnsDeviceToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6106 -> (1, ("e",from_TalkException _v6106))) <$> updateApnsDeviceToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6106 -> (1, ("e",from_TalkException _v6106))) <$> updateApnsDeviceToken_result_e record
    ]
    )
write_UpdateApnsDeviceToken_result :: T.Protocol p => p -> UpdateApnsDeviceToken_result -> P.IO ()
write_UpdateApnsDeviceToken_result oprot record = T.writeVal oprot $ from_UpdateApnsDeviceToken_result record
encode_UpdateApnsDeviceToken_result :: T.StatelessProtocol p => p -> UpdateApnsDeviceToken_result -> LBS.ByteString
encode_UpdateApnsDeviceToken_result oprot record = T.serializeVal oprot $ from_UpdateApnsDeviceToken_result record
to_UpdateApnsDeviceToken_result :: T.ThriftVal -> UpdateApnsDeviceToken_result
to_UpdateApnsDeviceToken_result (T.TStruct fields) = UpdateApnsDeviceToken_result{
  updateApnsDeviceToken_result_e = P.maybe (P.Nothing) (\(_,_val6108) -> P.Just (case _val6108 of {T.TStruct _val6109 -> (to_TalkException (T.TStruct _val6109)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateApnsDeviceToken_result _ = P.error "not a struct"
read_UpdateApnsDeviceToken_result :: T.Protocol p => p -> P.IO UpdateApnsDeviceToken_result
read_UpdateApnsDeviceToken_result iprot = to_UpdateApnsDeviceToken_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_result)
decode_UpdateApnsDeviceToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateApnsDeviceToken_result
decode_UpdateApnsDeviceToken_result iprot bs = to_UpdateApnsDeviceToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_result) bs
typemap_UpdateApnsDeviceToken_result :: T.TypeMap
typemap_UpdateApnsDeviceToken_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateApnsDeviceToken_result :: UpdateApnsDeviceToken_result
default_UpdateApnsDeviceToken_result = UpdateApnsDeviceToken_result{
  updateApnsDeviceToken_result_e = P.Nothing}
data UpdateBuddySetting_args = UpdateBuddySetting_args  { updateBuddySetting_args_key :: LT.Text
  , updateBuddySetting_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBuddySetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBuddySetting_args_key record   `H.hashWithSalt` updateBuddySetting_args_value record  
instance QC.Arbitrary UpdateBuddySetting_args where 
  arbitrary = M.liftM UpdateBuddySetting_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateBuddySetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBuddySetting_args{updateBuddySetting_args_key = updateBuddySetting_args_key obj} then P.Nothing else P.Just $ default_UpdateBuddySetting_args{updateBuddySetting_args_key = updateBuddySetting_args_key obj}
    , if obj == default_UpdateBuddySetting_args{updateBuddySetting_args_value = updateBuddySetting_args_value obj} then P.Nothing else P.Just $ default_UpdateBuddySetting_args{updateBuddySetting_args_value = updateBuddySetting_args_value obj}
    ]
from_UpdateBuddySetting_args :: UpdateBuddySetting_args -> T.ThriftVal
from_UpdateBuddySetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6112 -> P.Just (2, ("key",T.TString $ E.encodeUtf8 _v6112))) $ updateBuddySetting_args_key record
  , (\_v6112 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v6112))) $ updateBuddySetting_args_value record
  ]
write_UpdateBuddySetting_args :: T.Protocol p => p -> UpdateBuddySetting_args -> P.IO ()
write_UpdateBuddySetting_args oprot record = T.writeVal oprot $ from_UpdateBuddySetting_args record
encode_UpdateBuddySetting_args :: T.StatelessProtocol p => p -> UpdateBuddySetting_args -> LBS.ByteString
encode_UpdateBuddySetting_args oprot record = T.serializeVal oprot $ from_UpdateBuddySetting_args record
to_UpdateBuddySetting_args :: T.ThriftVal -> UpdateBuddySetting_args
to_UpdateBuddySetting_args (T.TStruct fields) = UpdateBuddySetting_args{
  updateBuddySetting_args_key = P.maybe (updateBuddySetting_args_key default_UpdateBuddySetting_args) (\(_,_val6114) -> (case _val6114 of {T.TString _val6115 -> E.decodeUtf8 _val6115; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateBuddySetting_args_value = P.maybe (updateBuddySetting_args_value default_UpdateBuddySetting_args) (\(_,_val6114) -> (case _val6114 of {T.TString _val6116 -> E.decodeUtf8 _val6116; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateBuddySetting_args _ = P.error "not a struct"
read_UpdateBuddySetting_args :: T.Protocol p => p -> P.IO UpdateBuddySetting_args
read_UpdateBuddySetting_args iprot = to_UpdateBuddySetting_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_args)
decode_UpdateBuddySetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBuddySetting_args
decode_UpdateBuddySetting_args iprot bs = to_UpdateBuddySetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_args) bs
typemap_UpdateBuddySetting_args :: T.TypeMap
typemap_UpdateBuddySetting_args = Map.fromList [(2,("key",T.T_STRING)),(3,("value",T.T_STRING))]
default_UpdateBuddySetting_args :: UpdateBuddySetting_args
default_UpdateBuddySetting_args = UpdateBuddySetting_args{
  updateBuddySetting_args_key = "",
  updateBuddySetting_args_value = ""}
data UpdateBuddySetting_result = UpdateBuddySetting_result  { updateBuddySetting_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBuddySetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBuddySetting_result_e record  
instance QC.Arbitrary UpdateBuddySetting_result where 
  arbitrary = M.liftM UpdateBuddySetting_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateBuddySetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBuddySetting_result{updateBuddySetting_result_e = updateBuddySetting_result_e obj} then P.Nothing else P.Just $ default_UpdateBuddySetting_result{updateBuddySetting_result_e = updateBuddySetting_result_e obj}
    ]
from_UpdateBuddySetting_result :: UpdateBuddySetting_result -> T.ThriftVal
from_UpdateBuddySetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6119 -> (1, ("e",from_TalkException _v6119))) <$> updateBuddySetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6119 -> (1, ("e",from_TalkException _v6119))) <$> updateBuddySetting_result_e record
    ]
    )
write_UpdateBuddySetting_result :: T.Protocol p => p -> UpdateBuddySetting_result -> P.IO ()
write_UpdateBuddySetting_result oprot record = T.writeVal oprot $ from_UpdateBuddySetting_result record
encode_UpdateBuddySetting_result :: T.StatelessProtocol p => p -> UpdateBuddySetting_result -> LBS.ByteString
encode_UpdateBuddySetting_result oprot record = T.serializeVal oprot $ from_UpdateBuddySetting_result record
to_UpdateBuddySetting_result :: T.ThriftVal -> UpdateBuddySetting_result
to_UpdateBuddySetting_result (T.TStruct fields) = UpdateBuddySetting_result{
  updateBuddySetting_result_e = P.maybe (P.Nothing) (\(_,_val6121) -> P.Just (case _val6121 of {T.TStruct _val6122 -> (to_TalkException (T.TStruct _val6122)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateBuddySetting_result _ = P.error "not a struct"
read_UpdateBuddySetting_result :: T.Protocol p => p -> P.IO UpdateBuddySetting_result
read_UpdateBuddySetting_result iprot = to_UpdateBuddySetting_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_result)
decode_UpdateBuddySetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBuddySetting_result
decode_UpdateBuddySetting_result iprot bs = to_UpdateBuddySetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_result) bs
typemap_UpdateBuddySetting_result :: T.TypeMap
typemap_UpdateBuddySetting_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateBuddySetting_result :: UpdateBuddySetting_result
default_UpdateBuddySetting_result = UpdateBuddySetting_result{
  updateBuddySetting_result_e = P.Nothing}
data UpdateC2DMRegistrationId_args = UpdateC2DMRegistrationId_args  { updateC2DMRegistrationId_args_registrationId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateC2DMRegistrationId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateC2DMRegistrationId_args_registrationId record  
instance QC.Arbitrary UpdateC2DMRegistrationId_args where 
  arbitrary = M.liftM UpdateC2DMRegistrationId_args (QC.arbitrary)
  shrink obj | obj == default_UpdateC2DMRegistrationId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateC2DMRegistrationId_args{updateC2DMRegistrationId_args_registrationId = updateC2DMRegistrationId_args_registrationId obj} then P.Nothing else P.Just $ default_UpdateC2DMRegistrationId_args{updateC2DMRegistrationId_args_registrationId = updateC2DMRegistrationId_args_registrationId obj}
    ]
from_UpdateC2DMRegistrationId_args :: UpdateC2DMRegistrationId_args -> T.ThriftVal
from_UpdateC2DMRegistrationId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6125 -> P.Just (2, ("registrationId",T.TString $ E.encodeUtf8 _v6125))) $ updateC2DMRegistrationId_args_registrationId record
  ]
write_UpdateC2DMRegistrationId_args :: T.Protocol p => p -> UpdateC2DMRegistrationId_args -> P.IO ()
write_UpdateC2DMRegistrationId_args oprot record = T.writeVal oprot $ from_UpdateC2DMRegistrationId_args record
encode_UpdateC2DMRegistrationId_args :: T.StatelessProtocol p => p -> UpdateC2DMRegistrationId_args -> LBS.ByteString
encode_UpdateC2DMRegistrationId_args oprot record = T.serializeVal oprot $ from_UpdateC2DMRegistrationId_args record
to_UpdateC2DMRegistrationId_args :: T.ThriftVal -> UpdateC2DMRegistrationId_args
to_UpdateC2DMRegistrationId_args (T.TStruct fields) = UpdateC2DMRegistrationId_args{
  updateC2DMRegistrationId_args_registrationId = P.maybe (updateC2DMRegistrationId_args_registrationId default_UpdateC2DMRegistrationId_args) (\(_,_val6127) -> (case _val6127 of {T.TString _val6128 -> E.decodeUtf8 _val6128; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateC2DMRegistrationId_args _ = P.error "not a struct"
read_UpdateC2DMRegistrationId_args :: T.Protocol p => p -> P.IO UpdateC2DMRegistrationId_args
read_UpdateC2DMRegistrationId_args iprot = to_UpdateC2DMRegistrationId_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_args)
decode_UpdateC2DMRegistrationId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateC2DMRegistrationId_args
decode_UpdateC2DMRegistrationId_args iprot bs = to_UpdateC2DMRegistrationId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_args) bs
typemap_UpdateC2DMRegistrationId_args :: T.TypeMap
typemap_UpdateC2DMRegistrationId_args = Map.fromList [(2,("registrationId",T.T_STRING))]
default_UpdateC2DMRegistrationId_args :: UpdateC2DMRegistrationId_args
default_UpdateC2DMRegistrationId_args = UpdateC2DMRegistrationId_args{
  updateC2DMRegistrationId_args_registrationId = ""}
data UpdateC2DMRegistrationId_result = UpdateC2DMRegistrationId_result  { updateC2DMRegistrationId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateC2DMRegistrationId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateC2DMRegistrationId_result_e record  
instance QC.Arbitrary UpdateC2DMRegistrationId_result where 
  arbitrary = M.liftM UpdateC2DMRegistrationId_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateC2DMRegistrationId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateC2DMRegistrationId_result{updateC2DMRegistrationId_result_e = updateC2DMRegistrationId_result_e obj} then P.Nothing else P.Just $ default_UpdateC2DMRegistrationId_result{updateC2DMRegistrationId_result_e = updateC2DMRegistrationId_result_e obj}
    ]
from_UpdateC2DMRegistrationId_result :: UpdateC2DMRegistrationId_result -> T.ThriftVal
from_UpdateC2DMRegistrationId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6131 -> (1, ("e",from_TalkException _v6131))) <$> updateC2DMRegistrationId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6131 -> (1, ("e",from_TalkException _v6131))) <$> updateC2DMRegistrationId_result_e record
    ]
    )
write_UpdateC2DMRegistrationId_result :: T.Protocol p => p -> UpdateC2DMRegistrationId_result -> P.IO ()
write_UpdateC2DMRegistrationId_result oprot record = T.writeVal oprot $ from_UpdateC2DMRegistrationId_result record
encode_UpdateC2DMRegistrationId_result :: T.StatelessProtocol p => p -> UpdateC2DMRegistrationId_result -> LBS.ByteString
encode_UpdateC2DMRegistrationId_result oprot record = T.serializeVal oprot $ from_UpdateC2DMRegistrationId_result record
to_UpdateC2DMRegistrationId_result :: T.ThriftVal -> UpdateC2DMRegistrationId_result
to_UpdateC2DMRegistrationId_result (T.TStruct fields) = UpdateC2DMRegistrationId_result{
  updateC2DMRegistrationId_result_e = P.maybe (P.Nothing) (\(_,_val6133) -> P.Just (case _val6133 of {T.TStruct _val6134 -> (to_TalkException (T.TStruct _val6134)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateC2DMRegistrationId_result _ = P.error "not a struct"
read_UpdateC2DMRegistrationId_result :: T.Protocol p => p -> P.IO UpdateC2DMRegistrationId_result
read_UpdateC2DMRegistrationId_result iprot = to_UpdateC2DMRegistrationId_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_result)
decode_UpdateC2DMRegistrationId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateC2DMRegistrationId_result
decode_UpdateC2DMRegistrationId_result iprot bs = to_UpdateC2DMRegistrationId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_result) bs
typemap_UpdateC2DMRegistrationId_result :: T.TypeMap
typemap_UpdateC2DMRegistrationId_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateC2DMRegistrationId_result :: UpdateC2DMRegistrationId_result
default_UpdateC2DMRegistrationId_result = UpdateC2DMRegistrationId_result{
  updateC2DMRegistrationId_result_e = P.Nothing}
data UpdateContactSetting_args = UpdateContactSetting_args  { updateContactSetting_args_reqSeq :: I.Int32
  , updateContactSetting_args_mid :: LT.Text
  , updateContactSetting_args_flag :: ContactSetting
  , updateContactSetting_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateContactSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateContactSetting_args_reqSeq record   `H.hashWithSalt` updateContactSetting_args_mid record   `H.hashWithSalt` updateContactSetting_args_flag record   `H.hashWithSalt` updateContactSetting_args_value record  
instance QC.Arbitrary UpdateContactSetting_args where 
  arbitrary = M.liftM UpdateContactSetting_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateContactSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateContactSetting_args{updateContactSetting_args_reqSeq = updateContactSetting_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_reqSeq = updateContactSetting_args_reqSeq obj}
    , if obj == default_UpdateContactSetting_args{updateContactSetting_args_mid = updateContactSetting_args_mid obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_mid = updateContactSetting_args_mid obj}
    , if obj == default_UpdateContactSetting_args{updateContactSetting_args_flag = updateContactSetting_args_flag obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_flag = updateContactSetting_args_flag obj}
    , if obj == default_UpdateContactSetting_args{updateContactSetting_args_value = updateContactSetting_args_value obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_value = updateContactSetting_args_value obj}
    ]
from_UpdateContactSetting_args :: UpdateContactSetting_args -> T.ThriftVal
from_UpdateContactSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6137 -> P.Just (1, ("reqSeq",T.TI32 _v6137))) $ updateContactSetting_args_reqSeq record
  , (\_v6137 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v6137))) $ updateContactSetting_args_mid record
  , (\_v6137 -> P.Just (3, ("flag",T.TI32 $ P.fromIntegral $ P.fromEnum _v6137))) $ updateContactSetting_args_flag record
  , (\_v6137 -> P.Just (4, ("value",T.TString $ E.encodeUtf8 _v6137))) $ updateContactSetting_args_value record
  ]
write_UpdateContactSetting_args :: T.Protocol p => p -> UpdateContactSetting_args -> P.IO ()
write_UpdateContactSetting_args oprot record = T.writeVal oprot $ from_UpdateContactSetting_args record
encode_UpdateContactSetting_args :: T.StatelessProtocol p => p -> UpdateContactSetting_args -> LBS.ByteString
encode_UpdateContactSetting_args oprot record = T.serializeVal oprot $ from_UpdateContactSetting_args record
to_UpdateContactSetting_args :: T.ThriftVal -> UpdateContactSetting_args
to_UpdateContactSetting_args (T.TStruct fields) = UpdateContactSetting_args{
  updateContactSetting_args_reqSeq = P.maybe (updateContactSetting_args_reqSeq default_UpdateContactSetting_args) (\(_,_val6139) -> (case _val6139 of {T.TI32 _val6140 -> _val6140; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateContactSetting_args_mid = P.maybe (updateContactSetting_args_mid default_UpdateContactSetting_args) (\(_,_val6139) -> (case _val6139 of {T.TString _val6141 -> E.decodeUtf8 _val6141; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateContactSetting_args_flag = P.maybe (updateContactSetting_args_flag default_UpdateContactSetting_args) (\(_,_val6139) -> (case _val6139 of {T.TI32 _val6142 -> P.toEnum $ P.fromIntegral _val6142; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateContactSetting_args_value = P.maybe (updateContactSetting_args_value default_UpdateContactSetting_args) (\(_,_val6139) -> (case _val6139 of {T.TString _val6143 -> E.decodeUtf8 _val6143; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_UpdateContactSetting_args _ = P.error "not a struct"
read_UpdateContactSetting_args :: T.Protocol p => p -> P.IO UpdateContactSetting_args
read_UpdateContactSetting_args iprot = to_UpdateContactSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateContactSetting_args)
decode_UpdateContactSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateContactSetting_args
decode_UpdateContactSetting_args iprot bs = to_UpdateContactSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateContactSetting_args) bs
typemap_UpdateContactSetting_args :: T.TypeMap
typemap_UpdateContactSetting_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("mid",T.T_STRING)),(3,("flag",T.T_I32)),(4,("value",T.T_STRING))]
default_UpdateContactSetting_args :: UpdateContactSetting_args
default_UpdateContactSetting_args = UpdateContactSetting_args{
  updateContactSetting_args_reqSeq = 0,
  updateContactSetting_args_mid = "",
  updateContactSetting_args_flag = (P.toEnum 0),
  updateContactSetting_args_value = ""}
data UpdateContactSetting_result = UpdateContactSetting_result  { updateContactSetting_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateContactSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateContactSetting_result_e record  
instance QC.Arbitrary UpdateContactSetting_result where 
  arbitrary = M.liftM UpdateContactSetting_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateContactSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateContactSetting_result{updateContactSetting_result_e = updateContactSetting_result_e obj} then P.Nothing else P.Just $ default_UpdateContactSetting_result{updateContactSetting_result_e = updateContactSetting_result_e obj}
    ]
from_UpdateContactSetting_result :: UpdateContactSetting_result -> T.ThriftVal
from_UpdateContactSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6146 -> (1, ("e",from_TalkException _v6146))) <$> updateContactSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6146 -> (1, ("e",from_TalkException _v6146))) <$> updateContactSetting_result_e record
    ]
    )
write_UpdateContactSetting_result :: T.Protocol p => p -> UpdateContactSetting_result -> P.IO ()
write_UpdateContactSetting_result oprot record = T.writeVal oprot $ from_UpdateContactSetting_result record
encode_UpdateContactSetting_result :: T.StatelessProtocol p => p -> UpdateContactSetting_result -> LBS.ByteString
encode_UpdateContactSetting_result oprot record = T.serializeVal oprot $ from_UpdateContactSetting_result record
to_UpdateContactSetting_result :: T.ThriftVal -> UpdateContactSetting_result
to_UpdateContactSetting_result (T.TStruct fields) = UpdateContactSetting_result{
  updateContactSetting_result_e = P.maybe (P.Nothing) (\(_,_val6148) -> P.Just (case _val6148 of {T.TStruct _val6149 -> (to_TalkException (T.TStruct _val6149)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateContactSetting_result _ = P.error "not a struct"
read_UpdateContactSetting_result :: T.Protocol p => p -> P.IO UpdateContactSetting_result
read_UpdateContactSetting_result iprot = to_UpdateContactSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateContactSetting_result)
decode_UpdateContactSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateContactSetting_result
decode_UpdateContactSetting_result iprot bs = to_UpdateContactSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateContactSetting_result) bs
typemap_UpdateContactSetting_result :: T.TypeMap
typemap_UpdateContactSetting_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateContactSetting_result :: UpdateContactSetting_result
default_UpdateContactSetting_result = UpdateContactSetting_result{
  updateContactSetting_result_e = P.Nothing}
data UpdateCustomModeSettings_args = UpdateCustomModeSettings_args  { updateCustomModeSettings_args_customMode :: CustomMode
  , updateCustomModeSettings_args_paramMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateCustomModeSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateCustomModeSettings_args_customMode record   `H.hashWithSalt` updateCustomModeSettings_args_paramMap record  
instance QC.Arbitrary UpdateCustomModeSettings_args where 
  arbitrary = M.liftM UpdateCustomModeSettings_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateCustomModeSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_customMode = updateCustomModeSettings_args_customMode obj} then P.Nothing else P.Just $ default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_customMode = updateCustomModeSettings_args_customMode obj}
    , if obj == default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_paramMap = updateCustomModeSettings_args_paramMap obj} then P.Nothing else P.Just $ default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_paramMap = updateCustomModeSettings_args_paramMap obj}
    ]
from_UpdateCustomModeSettings_args :: UpdateCustomModeSettings_args -> T.ThriftVal
from_UpdateCustomModeSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6152 -> P.Just (2, ("customMode",T.TI32 $ P.fromIntegral $ P.fromEnum _v6152))) $ updateCustomModeSettings_args_customMode record
  , (\_v6152 -> P.Just (3, ("paramMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k6153,_v6154) -> (T.TString $ E.encodeUtf8 _k6153, T.TString $ E.encodeUtf8 _v6154)) $ Map.toList _v6152))) $ updateCustomModeSettings_args_paramMap record
  ]
write_UpdateCustomModeSettings_args :: T.Protocol p => p -> UpdateCustomModeSettings_args -> P.IO ()
write_UpdateCustomModeSettings_args oprot record = T.writeVal oprot $ from_UpdateCustomModeSettings_args record
encode_UpdateCustomModeSettings_args :: T.StatelessProtocol p => p -> UpdateCustomModeSettings_args -> LBS.ByteString
encode_UpdateCustomModeSettings_args oprot record = T.serializeVal oprot $ from_UpdateCustomModeSettings_args record
to_UpdateCustomModeSettings_args :: T.ThriftVal -> UpdateCustomModeSettings_args
to_UpdateCustomModeSettings_args (T.TStruct fields) = UpdateCustomModeSettings_args{
  updateCustomModeSettings_args_customMode = P.maybe (updateCustomModeSettings_args_customMode default_UpdateCustomModeSettings_args) (\(_,_val6156) -> (case _val6156 of {T.TI32 _val6157 -> P.toEnum $ P.fromIntegral _val6157; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateCustomModeSettings_args_paramMap = P.maybe (updateCustomModeSettings_args_paramMap default_UpdateCustomModeSettings_args) (\(_,_val6156) -> (case _val6156 of {T.TMap _ _ _val6158 -> (Map.fromList $ P.map (\(_k6160,_v6159) -> ((case _k6160 of {T.TString _val6161 -> E.decodeUtf8 _val6161; _ -> P.error "wrong type"}),(case _v6159 of {T.TString _val6162 -> E.decodeUtf8 _val6162; _ -> P.error "wrong type"}))) _val6158); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateCustomModeSettings_args _ = P.error "not a struct"
read_UpdateCustomModeSettings_args :: T.Protocol p => p -> P.IO UpdateCustomModeSettings_args
read_UpdateCustomModeSettings_args iprot = to_UpdateCustomModeSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_args)
decode_UpdateCustomModeSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateCustomModeSettings_args
decode_UpdateCustomModeSettings_args iprot bs = to_UpdateCustomModeSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_args) bs
typemap_UpdateCustomModeSettings_args :: T.TypeMap
typemap_UpdateCustomModeSettings_args = Map.fromList [(2,("customMode",T.T_I32)),(3,("paramMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_UpdateCustomModeSettings_args :: UpdateCustomModeSettings_args
default_UpdateCustomModeSettings_args = UpdateCustomModeSettings_args{
  updateCustomModeSettings_args_customMode = (P.toEnum 0),
  updateCustomModeSettings_args_paramMap = Map.empty}
data UpdateCustomModeSettings_result = UpdateCustomModeSettings_result  { updateCustomModeSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateCustomModeSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateCustomModeSettings_result_e record  
instance QC.Arbitrary UpdateCustomModeSettings_result where 
  arbitrary = M.liftM UpdateCustomModeSettings_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateCustomModeSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateCustomModeSettings_result{updateCustomModeSettings_result_e = updateCustomModeSettings_result_e obj} then P.Nothing else P.Just $ default_UpdateCustomModeSettings_result{updateCustomModeSettings_result_e = updateCustomModeSettings_result_e obj}
    ]
from_UpdateCustomModeSettings_result :: UpdateCustomModeSettings_result -> T.ThriftVal
from_UpdateCustomModeSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6165 -> (1, ("e",from_TalkException _v6165))) <$> updateCustomModeSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6165 -> (1, ("e",from_TalkException _v6165))) <$> updateCustomModeSettings_result_e record
    ]
    )
write_UpdateCustomModeSettings_result :: T.Protocol p => p -> UpdateCustomModeSettings_result -> P.IO ()
write_UpdateCustomModeSettings_result oprot record = T.writeVal oprot $ from_UpdateCustomModeSettings_result record
encode_UpdateCustomModeSettings_result :: T.StatelessProtocol p => p -> UpdateCustomModeSettings_result -> LBS.ByteString
encode_UpdateCustomModeSettings_result oprot record = T.serializeVal oprot $ from_UpdateCustomModeSettings_result record
to_UpdateCustomModeSettings_result :: T.ThriftVal -> UpdateCustomModeSettings_result
to_UpdateCustomModeSettings_result (T.TStruct fields) = UpdateCustomModeSettings_result{
  updateCustomModeSettings_result_e = P.maybe (P.Nothing) (\(_,_val6167) -> P.Just (case _val6167 of {T.TStruct _val6168 -> (to_TalkException (T.TStruct _val6168)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateCustomModeSettings_result _ = P.error "not a struct"
read_UpdateCustomModeSettings_result :: T.Protocol p => p -> P.IO UpdateCustomModeSettings_result
read_UpdateCustomModeSettings_result iprot = to_UpdateCustomModeSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_result)
decode_UpdateCustomModeSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateCustomModeSettings_result
decode_UpdateCustomModeSettings_result iprot bs = to_UpdateCustomModeSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_result) bs
typemap_UpdateCustomModeSettings_result :: T.TypeMap
typemap_UpdateCustomModeSettings_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateCustomModeSettings_result :: UpdateCustomModeSettings_result
default_UpdateCustomModeSettings_result = UpdateCustomModeSettings_result{
  updateCustomModeSettings_result_e = P.Nothing}
data UpdateDeviceInfo_args = UpdateDeviceInfo_args  { updateDeviceInfo_args_deviceUid :: LT.Text
  , updateDeviceInfo_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateDeviceInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateDeviceInfo_args_deviceUid record   `H.hashWithSalt` updateDeviceInfo_args_deviceInfo record  
instance QC.Arbitrary UpdateDeviceInfo_args where 
  arbitrary = M.liftM UpdateDeviceInfo_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateDeviceInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceUid = updateDeviceInfo_args_deviceUid obj} then P.Nothing else P.Just $ default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceUid = updateDeviceInfo_args_deviceUid obj}
    , if obj == default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceInfo = updateDeviceInfo_args_deviceInfo obj} then P.Nothing else P.Just $ default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceInfo = updateDeviceInfo_args_deviceInfo obj}
    ]
from_UpdateDeviceInfo_args :: UpdateDeviceInfo_args -> T.ThriftVal
from_UpdateDeviceInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6171 -> P.Just (2, ("deviceUid",T.TString $ E.encodeUtf8 _v6171))) $ updateDeviceInfo_args_deviceUid record
  , (\_v6171 -> P.Just (3, ("deviceInfo",from_DeviceInfo _v6171))) $ updateDeviceInfo_args_deviceInfo record
  ]
write_UpdateDeviceInfo_args :: T.Protocol p => p -> UpdateDeviceInfo_args -> P.IO ()
write_UpdateDeviceInfo_args oprot record = T.writeVal oprot $ from_UpdateDeviceInfo_args record
encode_UpdateDeviceInfo_args :: T.StatelessProtocol p => p -> UpdateDeviceInfo_args -> LBS.ByteString
encode_UpdateDeviceInfo_args oprot record = T.serializeVal oprot $ from_UpdateDeviceInfo_args record
to_UpdateDeviceInfo_args :: T.ThriftVal -> UpdateDeviceInfo_args
to_UpdateDeviceInfo_args (T.TStruct fields) = UpdateDeviceInfo_args{
  updateDeviceInfo_args_deviceUid = P.maybe (updateDeviceInfo_args_deviceUid default_UpdateDeviceInfo_args) (\(_,_val6173) -> (case _val6173 of {T.TString _val6174 -> E.decodeUtf8 _val6174; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateDeviceInfo_args_deviceInfo = P.maybe (updateDeviceInfo_args_deviceInfo default_UpdateDeviceInfo_args) (\(_,_val6173) -> (case _val6173 of {T.TStruct _val6175 -> (to_DeviceInfo (T.TStruct _val6175)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateDeviceInfo_args _ = P.error "not a struct"
read_UpdateDeviceInfo_args :: T.Protocol p => p -> P.IO UpdateDeviceInfo_args
read_UpdateDeviceInfo_args iprot = to_UpdateDeviceInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_args)
decode_UpdateDeviceInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateDeviceInfo_args
decode_UpdateDeviceInfo_args iprot bs = to_UpdateDeviceInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_args) bs
typemap_UpdateDeviceInfo_args :: T.TypeMap
typemap_UpdateDeviceInfo_args = Map.fromList [(2,("deviceUid",T.T_STRING)),(3,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_UpdateDeviceInfo_args :: UpdateDeviceInfo_args
default_UpdateDeviceInfo_args = UpdateDeviceInfo_args{
  updateDeviceInfo_args_deviceUid = "",
  updateDeviceInfo_args_deviceInfo = default_DeviceInfo}
data UpdateDeviceInfo_result = UpdateDeviceInfo_result  { updateDeviceInfo_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateDeviceInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateDeviceInfo_result_e record  
instance QC.Arbitrary UpdateDeviceInfo_result where 
  arbitrary = M.liftM UpdateDeviceInfo_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateDeviceInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateDeviceInfo_result{updateDeviceInfo_result_e = updateDeviceInfo_result_e obj} then P.Nothing else P.Just $ default_UpdateDeviceInfo_result{updateDeviceInfo_result_e = updateDeviceInfo_result_e obj}
    ]
from_UpdateDeviceInfo_result :: UpdateDeviceInfo_result -> T.ThriftVal
from_UpdateDeviceInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6178 -> (1, ("e",from_TalkException _v6178))) <$> updateDeviceInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6178 -> (1, ("e",from_TalkException _v6178))) <$> updateDeviceInfo_result_e record
    ]
    )
write_UpdateDeviceInfo_result :: T.Protocol p => p -> UpdateDeviceInfo_result -> P.IO ()
write_UpdateDeviceInfo_result oprot record = T.writeVal oprot $ from_UpdateDeviceInfo_result record
encode_UpdateDeviceInfo_result :: T.StatelessProtocol p => p -> UpdateDeviceInfo_result -> LBS.ByteString
encode_UpdateDeviceInfo_result oprot record = T.serializeVal oprot $ from_UpdateDeviceInfo_result record
to_UpdateDeviceInfo_result :: T.ThriftVal -> UpdateDeviceInfo_result
to_UpdateDeviceInfo_result (T.TStruct fields) = UpdateDeviceInfo_result{
  updateDeviceInfo_result_e = P.maybe (P.Nothing) (\(_,_val6180) -> P.Just (case _val6180 of {T.TStruct _val6181 -> (to_TalkException (T.TStruct _val6181)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateDeviceInfo_result _ = P.error "not a struct"
read_UpdateDeviceInfo_result :: T.Protocol p => p -> P.IO UpdateDeviceInfo_result
read_UpdateDeviceInfo_result iprot = to_UpdateDeviceInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_result)
decode_UpdateDeviceInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateDeviceInfo_result
decode_UpdateDeviceInfo_result iprot bs = to_UpdateDeviceInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_result) bs
typemap_UpdateDeviceInfo_result :: T.TypeMap
typemap_UpdateDeviceInfo_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateDeviceInfo_result :: UpdateDeviceInfo_result
default_UpdateDeviceInfo_result = UpdateDeviceInfo_result{
  updateDeviceInfo_result_e = P.Nothing}
data UpdateGroup_args = UpdateGroup_args  { updateGroup_args_reqSeq :: I.Int32
  , updateGroup_args_group :: Group
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateGroup_args_reqSeq record   `H.hashWithSalt` updateGroup_args_group record  
instance QC.Arbitrary UpdateGroup_args where 
  arbitrary = M.liftM UpdateGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateGroup_args{updateGroup_args_reqSeq = updateGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateGroup_args{updateGroup_args_reqSeq = updateGroup_args_reqSeq obj}
    , if obj == default_UpdateGroup_args{updateGroup_args_group = updateGroup_args_group obj} then P.Nothing else P.Just $ default_UpdateGroup_args{updateGroup_args_group = updateGroup_args_group obj}
    ]
from_UpdateGroup_args :: UpdateGroup_args -> T.ThriftVal
from_UpdateGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6184 -> P.Just (1, ("reqSeq",T.TI32 _v6184))) $ updateGroup_args_reqSeq record
  , (\_v6184 -> P.Just (2, ("group",from_Group _v6184))) $ updateGroup_args_group record
  ]
write_UpdateGroup_args :: T.Protocol p => p -> UpdateGroup_args -> P.IO ()
write_UpdateGroup_args oprot record = T.writeVal oprot $ from_UpdateGroup_args record
encode_UpdateGroup_args :: T.StatelessProtocol p => p -> UpdateGroup_args -> LBS.ByteString
encode_UpdateGroup_args oprot record = T.serializeVal oprot $ from_UpdateGroup_args record
to_UpdateGroup_args :: T.ThriftVal -> UpdateGroup_args
to_UpdateGroup_args (T.TStruct fields) = UpdateGroup_args{
  updateGroup_args_reqSeq = P.maybe (updateGroup_args_reqSeq default_UpdateGroup_args) (\(_,_val6186) -> (case _val6186 of {T.TI32 _val6187 -> _val6187; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateGroup_args_group = P.maybe (updateGroup_args_group default_UpdateGroup_args) (\(_,_val6186) -> (case _val6186 of {T.TStruct _val6188 -> (to_Group (T.TStruct _val6188)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateGroup_args _ = P.error "not a struct"
read_UpdateGroup_args :: T.Protocol p => p -> P.IO UpdateGroup_args
read_UpdateGroup_args iprot = to_UpdateGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateGroup_args)
decode_UpdateGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateGroup_args
decode_UpdateGroup_args iprot bs = to_UpdateGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateGroup_args) bs
typemap_UpdateGroup_args :: T.TypeMap
typemap_UpdateGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("group",(T.T_STRUCT typemap_Group)))]
default_UpdateGroup_args :: UpdateGroup_args
default_UpdateGroup_args = UpdateGroup_args{
  updateGroup_args_reqSeq = 0,
  updateGroup_args_group = default_Group}
data UpdateGroup_result = UpdateGroup_result  { updateGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateGroup_result_e record  
instance QC.Arbitrary UpdateGroup_result where 
  arbitrary = M.liftM UpdateGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateGroup_result{updateGroup_result_e = updateGroup_result_e obj} then P.Nothing else P.Just $ default_UpdateGroup_result{updateGroup_result_e = updateGroup_result_e obj}
    ]
from_UpdateGroup_result :: UpdateGroup_result -> T.ThriftVal
from_UpdateGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6191 -> (1, ("e",from_TalkException _v6191))) <$> updateGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6191 -> (1, ("e",from_TalkException _v6191))) <$> updateGroup_result_e record
    ]
    )
write_UpdateGroup_result :: T.Protocol p => p -> UpdateGroup_result -> P.IO ()
write_UpdateGroup_result oprot record = T.writeVal oprot $ from_UpdateGroup_result record
encode_UpdateGroup_result :: T.StatelessProtocol p => p -> UpdateGroup_result -> LBS.ByteString
encode_UpdateGroup_result oprot record = T.serializeVal oprot $ from_UpdateGroup_result record
to_UpdateGroup_result :: T.ThriftVal -> UpdateGroup_result
to_UpdateGroup_result (T.TStruct fields) = UpdateGroup_result{
  updateGroup_result_e = P.maybe (P.Nothing) (\(_,_val6193) -> P.Just (case _val6193 of {T.TStruct _val6194 -> (to_TalkException (T.TStruct _val6194)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateGroup_result _ = P.error "not a struct"
read_UpdateGroup_result :: T.Protocol p => p -> P.IO UpdateGroup_result
read_UpdateGroup_result iprot = to_UpdateGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateGroup_result)
decode_UpdateGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateGroup_result
decode_UpdateGroup_result iprot bs = to_UpdateGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateGroup_result) bs
typemap_UpdateGroup_result :: T.TypeMap
typemap_UpdateGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateGroup_result :: UpdateGroup_result
default_UpdateGroup_result = UpdateGroup_result{
  updateGroup_result_e = P.Nothing}
data UpdateNotificationToken_args = UpdateNotificationToken_args  { updateNotificationToken_args_type :: NotificationType
  , updateNotificationToken_args_token :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationToken_args_type record   `H.hashWithSalt` updateNotificationToken_args_token record  
instance QC.Arbitrary UpdateNotificationToken_args where 
  arbitrary = M.liftM UpdateNotificationToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationToken_args{updateNotificationToken_args_type = updateNotificationToken_args_type obj} then P.Nothing else P.Just $ default_UpdateNotificationToken_args{updateNotificationToken_args_type = updateNotificationToken_args_type obj}
    , if obj == default_UpdateNotificationToken_args{updateNotificationToken_args_token = updateNotificationToken_args_token obj} then P.Nothing else P.Just $ default_UpdateNotificationToken_args{updateNotificationToken_args_token = updateNotificationToken_args_token obj}
    ]
from_UpdateNotificationToken_args :: UpdateNotificationToken_args -> T.ThriftVal
from_UpdateNotificationToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6197 -> P.Just (2, ("token",T.TString $ E.encodeUtf8 _v6197))) $ updateNotificationToken_args_token record
  , (\_v6197 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v6197))) $ updateNotificationToken_args_type record
  ]
write_UpdateNotificationToken_args :: T.Protocol p => p -> UpdateNotificationToken_args -> P.IO ()
write_UpdateNotificationToken_args oprot record = T.writeVal oprot $ from_UpdateNotificationToken_args record
encode_UpdateNotificationToken_args :: T.StatelessProtocol p => p -> UpdateNotificationToken_args -> LBS.ByteString
encode_UpdateNotificationToken_args oprot record = T.serializeVal oprot $ from_UpdateNotificationToken_args record
to_UpdateNotificationToken_args :: T.ThriftVal -> UpdateNotificationToken_args
to_UpdateNotificationToken_args (T.TStruct fields) = UpdateNotificationToken_args{
  updateNotificationToken_args_type = P.maybe (updateNotificationToken_args_type default_UpdateNotificationToken_args) (\(_,_val6199) -> (case _val6199 of {T.TI32 _val6200 -> P.toEnum $ P.fromIntegral _val6200; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateNotificationToken_args_token = P.maybe (updateNotificationToken_args_token default_UpdateNotificationToken_args) (\(_,_val6199) -> (case _val6199 of {T.TString _val6201 -> E.decodeUtf8 _val6201; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNotificationToken_args _ = P.error "not a struct"
read_UpdateNotificationToken_args :: T.Protocol p => p -> P.IO UpdateNotificationToken_args
read_UpdateNotificationToken_args iprot = to_UpdateNotificationToken_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_args)
decode_UpdateNotificationToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationToken_args
decode_UpdateNotificationToken_args iprot bs = to_UpdateNotificationToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_args) bs
typemap_UpdateNotificationToken_args :: T.TypeMap
typemap_UpdateNotificationToken_args = Map.fromList [(2,("token",T.T_STRING)),(3,("type",T.T_I32))]
default_UpdateNotificationToken_args :: UpdateNotificationToken_args
default_UpdateNotificationToken_args = UpdateNotificationToken_args{
  updateNotificationToken_args_token = "",
  updateNotificationToken_args_type = (P.toEnum 0)}
data UpdateNotificationToken_result = UpdateNotificationToken_result  { updateNotificationToken_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationToken_result_e record  
instance QC.Arbitrary UpdateNotificationToken_result where 
  arbitrary = M.liftM UpdateNotificationToken_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationToken_result{updateNotificationToken_result_e = updateNotificationToken_result_e obj} then P.Nothing else P.Just $ default_UpdateNotificationToken_result{updateNotificationToken_result_e = updateNotificationToken_result_e obj}
    ]
from_UpdateNotificationToken_result :: UpdateNotificationToken_result -> T.ThriftVal
from_UpdateNotificationToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6204 -> (1, ("e",from_TalkException _v6204))) <$> updateNotificationToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6204 -> (1, ("e",from_TalkException _v6204))) <$> updateNotificationToken_result_e record
    ]
    )
write_UpdateNotificationToken_result :: T.Protocol p => p -> UpdateNotificationToken_result -> P.IO ()
write_UpdateNotificationToken_result oprot record = T.writeVal oprot $ from_UpdateNotificationToken_result record
encode_UpdateNotificationToken_result :: T.StatelessProtocol p => p -> UpdateNotificationToken_result -> LBS.ByteString
encode_UpdateNotificationToken_result oprot record = T.serializeVal oprot $ from_UpdateNotificationToken_result record
to_UpdateNotificationToken_result :: T.ThriftVal -> UpdateNotificationToken_result
to_UpdateNotificationToken_result (T.TStruct fields) = UpdateNotificationToken_result{
  updateNotificationToken_result_e = P.maybe (P.Nothing) (\(_,_val6206) -> P.Just (case _val6206 of {T.TStruct _val6207 -> (to_TalkException (T.TStruct _val6207)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateNotificationToken_result _ = P.error "not a struct"
read_UpdateNotificationToken_result :: T.Protocol p => p -> P.IO UpdateNotificationToken_result
read_UpdateNotificationToken_result iprot = to_UpdateNotificationToken_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_result)
decode_UpdateNotificationToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationToken_result
decode_UpdateNotificationToken_result iprot bs = to_UpdateNotificationToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_result) bs
typemap_UpdateNotificationToken_result :: T.TypeMap
typemap_UpdateNotificationToken_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateNotificationToken_result :: UpdateNotificationToken_result
default_UpdateNotificationToken_result = UpdateNotificationToken_result{
  updateNotificationToken_result_e = P.Nothing}
data UpdateNotificationTokenWithBytes_args = UpdateNotificationTokenWithBytes_args  { updateNotificationTokenWithBytes_args_type :: NotificationType
  , updateNotificationTokenWithBytes_args_token :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationTokenWithBytes_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationTokenWithBytes_args_type record   `H.hashWithSalt` updateNotificationTokenWithBytes_args_token record  
instance QC.Arbitrary UpdateNotificationTokenWithBytes_args where 
  arbitrary = M.liftM UpdateNotificationTokenWithBytes_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationTokenWithBytes_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_type = updateNotificationTokenWithBytes_args_type obj} then P.Nothing else P.Just $ default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_type = updateNotificationTokenWithBytes_args_type obj}
    , if obj == default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_token = updateNotificationTokenWithBytes_args_token obj} then P.Nothing else P.Just $ default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_token = updateNotificationTokenWithBytes_args_token obj}
    ]
from_UpdateNotificationTokenWithBytes_args :: UpdateNotificationTokenWithBytes_args -> T.ThriftVal
from_UpdateNotificationTokenWithBytes_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6210 -> P.Just (2, ("token",T.TBinary _v6210))) $ updateNotificationTokenWithBytes_args_token record
  , (\_v6210 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v6210))) $ updateNotificationTokenWithBytes_args_type record
  ]
write_UpdateNotificationTokenWithBytes_args :: T.Protocol p => p -> UpdateNotificationTokenWithBytes_args -> P.IO ()
write_UpdateNotificationTokenWithBytes_args oprot record = T.writeVal oprot $ from_UpdateNotificationTokenWithBytes_args record
encode_UpdateNotificationTokenWithBytes_args :: T.StatelessProtocol p => p -> UpdateNotificationTokenWithBytes_args -> LBS.ByteString
encode_UpdateNotificationTokenWithBytes_args oprot record = T.serializeVal oprot $ from_UpdateNotificationTokenWithBytes_args record
to_UpdateNotificationTokenWithBytes_args :: T.ThriftVal -> UpdateNotificationTokenWithBytes_args
to_UpdateNotificationTokenWithBytes_args (T.TStruct fields) = UpdateNotificationTokenWithBytes_args{
  updateNotificationTokenWithBytes_args_type = P.maybe (updateNotificationTokenWithBytes_args_type default_UpdateNotificationTokenWithBytes_args) (\(_,_val6212) -> (case _val6212 of {T.TI32 _val6213 -> P.toEnum $ P.fromIntegral _val6213; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateNotificationTokenWithBytes_args_token = P.maybe (updateNotificationTokenWithBytes_args_token default_UpdateNotificationTokenWithBytes_args) (\(_,_val6212) -> (case _val6212 of {T.TBinary _val6214 -> _val6214; T.TString _val6214 -> _val6214; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNotificationTokenWithBytes_args _ = P.error "not a struct"
read_UpdateNotificationTokenWithBytes_args :: T.Protocol p => p -> P.IO UpdateNotificationTokenWithBytes_args
read_UpdateNotificationTokenWithBytes_args iprot = to_UpdateNotificationTokenWithBytes_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_args)
decode_UpdateNotificationTokenWithBytes_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationTokenWithBytes_args
decode_UpdateNotificationTokenWithBytes_args iprot bs = to_UpdateNotificationTokenWithBytes_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_args) bs
typemap_UpdateNotificationTokenWithBytes_args :: T.TypeMap
typemap_UpdateNotificationTokenWithBytes_args = Map.fromList [(2,("token",T.T_BINARY)),(3,("type",T.T_I32))]
default_UpdateNotificationTokenWithBytes_args :: UpdateNotificationTokenWithBytes_args
default_UpdateNotificationTokenWithBytes_args = UpdateNotificationTokenWithBytes_args{
  updateNotificationTokenWithBytes_args_token = "",
  updateNotificationTokenWithBytes_args_type = (P.toEnum 0)}
data UpdateNotificationTokenWithBytes_result = UpdateNotificationTokenWithBytes_result  { updateNotificationTokenWithBytes_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationTokenWithBytes_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationTokenWithBytes_result_e record  
instance QC.Arbitrary UpdateNotificationTokenWithBytes_result where 
  arbitrary = M.liftM UpdateNotificationTokenWithBytes_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationTokenWithBytes_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationTokenWithBytes_result{updateNotificationTokenWithBytes_result_e = updateNotificationTokenWithBytes_result_e obj} then P.Nothing else P.Just $ default_UpdateNotificationTokenWithBytes_result{updateNotificationTokenWithBytes_result_e = updateNotificationTokenWithBytes_result_e obj}
    ]
from_UpdateNotificationTokenWithBytes_result :: UpdateNotificationTokenWithBytes_result -> T.ThriftVal
from_UpdateNotificationTokenWithBytes_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6217 -> (1, ("e",from_TalkException _v6217))) <$> updateNotificationTokenWithBytes_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6217 -> (1, ("e",from_TalkException _v6217))) <$> updateNotificationTokenWithBytes_result_e record
    ]
    )
write_UpdateNotificationTokenWithBytes_result :: T.Protocol p => p -> UpdateNotificationTokenWithBytes_result -> P.IO ()
write_UpdateNotificationTokenWithBytes_result oprot record = T.writeVal oprot $ from_UpdateNotificationTokenWithBytes_result record
encode_UpdateNotificationTokenWithBytes_result :: T.StatelessProtocol p => p -> UpdateNotificationTokenWithBytes_result -> LBS.ByteString
encode_UpdateNotificationTokenWithBytes_result oprot record = T.serializeVal oprot $ from_UpdateNotificationTokenWithBytes_result record
to_UpdateNotificationTokenWithBytes_result :: T.ThriftVal -> UpdateNotificationTokenWithBytes_result
to_UpdateNotificationTokenWithBytes_result (T.TStruct fields) = UpdateNotificationTokenWithBytes_result{
  updateNotificationTokenWithBytes_result_e = P.maybe (P.Nothing) (\(_,_val6219) -> P.Just (case _val6219 of {T.TStruct _val6220 -> (to_TalkException (T.TStruct _val6220)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateNotificationTokenWithBytes_result _ = P.error "not a struct"
read_UpdateNotificationTokenWithBytes_result :: T.Protocol p => p -> P.IO UpdateNotificationTokenWithBytes_result
read_UpdateNotificationTokenWithBytes_result iprot = to_UpdateNotificationTokenWithBytes_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_result)
decode_UpdateNotificationTokenWithBytes_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationTokenWithBytes_result
decode_UpdateNotificationTokenWithBytes_result iprot bs = to_UpdateNotificationTokenWithBytes_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_result) bs
typemap_UpdateNotificationTokenWithBytes_result :: T.TypeMap
typemap_UpdateNotificationTokenWithBytes_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateNotificationTokenWithBytes_result :: UpdateNotificationTokenWithBytes_result
default_UpdateNotificationTokenWithBytes_result = UpdateNotificationTokenWithBytes_result{
  updateNotificationTokenWithBytes_result_e = P.Nothing}
data UpdateProfile_args = UpdateProfile_args  { updateProfile_args_reqSeq :: I.Int32
  , updateProfile_args_profile :: Profile
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfile_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfile_args_reqSeq record   `H.hashWithSalt` updateProfile_args_profile record  
instance QC.Arbitrary UpdateProfile_args where 
  arbitrary = M.liftM UpdateProfile_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfile_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfile_args{updateProfile_args_reqSeq = updateProfile_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateProfile_args{updateProfile_args_reqSeq = updateProfile_args_reqSeq obj}
    , if obj == default_UpdateProfile_args{updateProfile_args_profile = updateProfile_args_profile obj} then P.Nothing else P.Just $ default_UpdateProfile_args{updateProfile_args_profile = updateProfile_args_profile obj}
    ]
from_UpdateProfile_args :: UpdateProfile_args -> T.ThriftVal
from_UpdateProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6223 -> P.Just (1, ("reqSeq",T.TI32 _v6223))) $ updateProfile_args_reqSeq record
  , (\_v6223 -> P.Just (2, ("profile",from_Profile _v6223))) $ updateProfile_args_profile record
  ]
write_UpdateProfile_args :: T.Protocol p => p -> UpdateProfile_args -> P.IO ()
write_UpdateProfile_args oprot record = T.writeVal oprot $ from_UpdateProfile_args record
encode_UpdateProfile_args :: T.StatelessProtocol p => p -> UpdateProfile_args -> LBS.ByteString
encode_UpdateProfile_args oprot record = T.serializeVal oprot $ from_UpdateProfile_args record
to_UpdateProfile_args :: T.ThriftVal -> UpdateProfile_args
to_UpdateProfile_args (T.TStruct fields) = UpdateProfile_args{
  updateProfile_args_reqSeq = P.maybe (updateProfile_args_reqSeq default_UpdateProfile_args) (\(_,_val6225) -> (case _val6225 of {T.TI32 _val6226 -> _val6226; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateProfile_args_profile = P.maybe (updateProfile_args_profile default_UpdateProfile_args) (\(_,_val6225) -> (case _val6225 of {T.TStruct _val6227 -> (to_Profile (T.TStruct _val6227)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateProfile_args _ = P.error "not a struct"
read_UpdateProfile_args :: T.Protocol p => p -> P.IO UpdateProfile_args
read_UpdateProfile_args iprot = to_UpdateProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfile_args)
decode_UpdateProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfile_args
decode_UpdateProfile_args iprot bs = to_UpdateProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfile_args) bs
typemap_UpdateProfile_args :: T.TypeMap
typemap_UpdateProfile_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("profile",(T.T_STRUCT typemap_Profile)))]
default_UpdateProfile_args :: UpdateProfile_args
default_UpdateProfile_args = UpdateProfile_args{
  updateProfile_args_reqSeq = 0,
  updateProfile_args_profile = default_Profile}
data UpdateProfile_result = UpdateProfile_result  { updateProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfile_result_e record  
instance QC.Arbitrary UpdateProfile_result where 
  arbitrary = M.liftM UpdateProfile_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfile_result{updateProfile_result_e = updateProfile_result_e obj} then P.Nothing else P.Just $ default_UpdateProfile_result{updateProfile_result_e = updateProfile_result_e obj}
    ]
from_UpdateProfile_result :: UpdateProfile_result -> T.ThriftVal
from_UpdateProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6230 -> (1, ("e",from_TalkException _v6230))) <$> updateProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6230 -> (1, ("e",from_TalkException _v6230))) <$> updateProfile_result_e record
    ]
    )
write_UpdateProfile_result :: T.Protocol p => p -> UpdateProfile_result -> P.IO ()
write_UpdateProfile_result oprot record = T.writeVal oprot $ from_UpdateProfile_result record
encode_UpdateProfile_result :: T.StatelessProtocol p => p -> UpdateProfile_result -> LBS.ByteString
encode_UpdateProfile_result oprot record = T.serializeVal oprot $ from_UpdateProfile_result record
to_UpdateProfile_result :: T.ThriftVal -> UpdateProfile_result
to_UpdateProfile_result (T.TStruct fields) = UpdateProfile_result{
  updateProfile_result_e = P.maybe (P.Nothing) (\(_,_val6232) -> P.Just (case _val6232 of {T.TStruct _val6233 -> (to_TalkException (T.TStruct _val6233)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfile_result _ = P.error "not a struct"
read_UpdateProfile_result :: T.Protocol p => p -> P.IO UpdateProfile_result
read_UpdateProfile_result iprot = to_UpdateProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfile_result)
decode_UpdateProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfile_result
decode_UpdateProfile_result iprot bs = to_UpdateProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfile_result) bs
typemap_UpdateProfile_result :: T.TypeMap
typemap_UpdateProfile_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfile_result :: UpdateProfile_result
default_UpdateProfile_result = UpdateProfile_result{
  updateProfile_result_e = P.Nothing}
data UpdateProfileAttribute_args = UpdateProfileAttribute_args  { updateProfileAttribute_args_reqSeq :: I.Int32
  , updateProfileAttribute_args_attr :: ProfileAttribute
  , updateProfileAttribute_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttribute_args_reqSeq record   `H.hashWithSalt` updateProfileAttribute_args_attr record   `H.hashWithSalt` updateProfileAttribute_args_value record  
instance QC.Arbitrary UpdateProfileAttribute_args where 
  arbitrary = M.liftM UpdateProfileAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttribute_args{updateProfileAttribute_args_reqSeq = updateProfileAttribute_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_args{updateProfileAttribute_args_reqSeq = updateProfileAttribute_args_reqSeq obj}
    , if obj == default_UpdateProfileAttribute_args{updateProfileAttribute_args_attr = updateProfileAttribute_args_attr obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_args{updateProfileAttribute_args_attr = updateProfileAttribute_args_attr obj}
    , if obj == default_UpdateProfileAttribute_args{updateProfileAttribute_args_value = updateProfileAttribute_args_value obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_args{updateProfileAttribute_args_value = updateProfileAttribute_args_value obj}
    ]
from_UpdateProfileAttribute_args :: UpdateProfileAttribute_args -> T.ThriftVal
from_UpdateProfileAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6236 -> P.Just (1, ("reqSeq",T.TI32 _v6236))) $ updateProfileAttribute_args_reqSeq record
  , (\_v6236 -> P.Just (2, ("attr",T.TI32 $ P.fromIntegral $ P.fromEnum _v6236))) $ updateProfileAttribute_args_attr record
  , (\_v6236 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v6236))) $ updateProfileAttribute_args_value record
  ]
write_UpdateProfileAttribute_args :: T.Protocol p => p -> UpdateProfileAttribute_args -> P.IO ()
write_UpdateProfileAttribute_args oprot record = T.writeVal oprot $ from_UpdateProfileAttribute_args record
encode_UpdateProfileAttribute_args :: T.StatelessProtocol p => p -> UpdateProfileAttribute_args -> LBS.ByteString
encode_UpdateProfileAttribute_args oprot record = T.serializeVal oprot $ from_UpdateProfileAttribute_args record
to_UpdateProfileAttribute_args :: T.ThriftVal -> UpdateProfileAttribute_args
to_UpdateProfileAttribute_args (T.TStruct fields) = UpdateProfileAttribute_args{
  updateProfileAttribute_args_reqSeq = P.maybe (updateProfileAttribute_args_reqSeq default_UpdateProfileAttribute_args) (\(_,_val6238) -> (case _val6238 of {T.TI32 _val6239 -> _val6239; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateProfileAttribute_args_attr = P.maybe (updateProfileAttribute_args_attr default_UpdateProfileAttribute_args) (\(_,_val6238) -> (case _val6238 of {T.TI32 _val6240 -> P.toEnum $ P.fromIntegral _val6240; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateProfileAttribute_args_value = P.maybe (updateProfileAttribute_args_value default_UpdateProfileAttribute_args) (\(_,_val6238) -> (case _val6238 of {T.TString _val6241 -> E.decodeUtf8 _val6241; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateProfileAttribute_args _ = P.error "not a struct"
read_UpdateProfileAttribute_args :: T.Protocol p => p -> P.IO UpdateProfileAttribute_args
read_UpdateProfileAttribute_args iprot = to_UpdateProfileAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_args)
decode_UpdateProfileAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttribute_args
decode_UpdateProfileAttribute_args iprot bs = to_UpdateProfileAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_args) bs
typemap_UpdateProfileAttribute_args :: T.TypeMap
typemap_UpdateProfileAttribute_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("attr",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateProfileAttribute_args :: UpdateProfileAttribute_args
default_UpdateProfileAttribute_args = UpdateProfileAttribute_args{
  updateProfileAttribute_args_reqSeq = 0,
  updateProfileAttribute_args_attr = (P.toEnum 0),
  updateProfileAttribute_args_value = ""}
data UpdateProfileAttribute_result = UpdateProfileAttribute_result  { updateProfileAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttribute_result_e record  
instance QC.Arbitrary UpdateProfileAttribute_result where 
  arbitrary = M.liftM UpdateProfileAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttribute_result{updateProfileAttribute_result_e = updateProfileAttribute_result_e obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_result{updateProfileAttribute_result_e = updateProfileAttribute_result_e obj}
    ]
from_UpdateProfileAttribute_result :: UpdateProfileAttribute_result -> T.ThriftVal
from_UpdateProfileAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6244 -> (1, ("e",from_TalkException _v6244))) <$> updateProfileAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6244 -> (1, ("e",from_TalkException _v6244))) <$> updateProfileAttribute_result_e record
    ]
    )
write_UpdateProfileAttribute_result :: T.Protocol p => p -> UpdateProfileAttribute_result -> P.IO ()
write_UpdateProfileAttribute_result oprot record = T.writeVal oprot $ from_UpdateProfileAttribute_result record
encode_UpdateProfileAttribute_result :: T.StatelessProtocol p => p -> UpdateProfileAttribute_result -> LBS.ByteString
encode_UpdateProfileAttribute_result oprot record = T.serializeVal oprot $ from_UpdateProfileAttribute_result record
to_UpdateProfileAttribute_result :: T.ThriftVal -> UpdateProfileAttribute_result
to_UpdateProfileAttribute_result (T.TStruct fields) = UpdateProfileAttribute_result{
  updateProfileAttribute_result_e = P.maybe (P.Nothing) (\(_,_val6246) -> P.Just (case _val6246 of {T.TStruct _val6247 -> (to_TalkException (T.TStruct _val6247)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfileAttribute_result _ = P.error "not a struct"
read_UpdateProfileAttribute_result :: T.Protocol p => p -> P.IO UpdateProfileAttribute_result
read_UpdateProfileAttribute_result iprot = to_UpdateProfileAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_result)
decode_UpdateProfileAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttribute_result
decode_UpdateProfileAttribute_result iprot bs = to_UpdateProfileAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_result) bs
typemap_UpdateProfileAttribute_result :: T.TypeMap
typemap_UpdateProfileAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfileAttribute_result :: UpdateProfileAttribute_result
default_UpdateProfileAttribute_result = UpdateProfileAttribute_result{
  updateProfileAttribute_result_e = P.Nothing}
data UpdateRegion_args = UpdateRegion_args  { updateRegion_args_region :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateRegion_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateRegion_args_region record  
instance QC.Arbitrary UpdateRegion_args where 
  arbitrary = M.liftM UpdateRegion_args (QC.arbitrary)
  shrink obj | obj == default_UpdateRegion_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateRegion_args{updateRegion_args_region = updateRegion_args_region obj} then P.Nothing else P.Just $ default_UpdateRegion_args{updateRegion_args_region = updateRegion_args_region obj}
    ]
from_UpdateRegion_args :: UpdateRegion_args -> T.ThriftVal
from_UpdateRegion_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6250 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v6250))) $ updateRegion_args_region record
  ]
write_UpdateRegion_args :: T.Protocol p => p -> UpdateRegion_args -> P.IO ()
write_UpdateRegion_args oprot record = T.writeVal oprot $ from_UpdateRegion_args record
encode_UpdateRegion_args :: T.StatelessProtocol p => p -> UpdateRegion_args -> LBS.ByteString
encode_UpdateRegion_args oprot record = T.serializeVal oprot $ from_UpdateRegion_args record
to_UpdateRegion_args :: T.ThriftVal -> UpdateRegion_args
to_UpdateRegion_args (T.TStruct fields) = UpdateRegion_args{
  updateRegion_args_region = P.maybe (updateRegion_args_region default_UpdateRegion_args) (\(_,_val6252) -> (case _val6252 of {T.TString _val6253 -> E.decodeUtf8 _val6253; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateRegion_args _ = P.error "not a struct"
read_UpdateRegion_args :: T.Protocol p => p -> P.IO UpdateRegion_args
read_UpdateRegion_args iprot = to_UpdateRegion_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateRegion_args)
decode_UpdateRegion_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateRegion_args
decode_UpdateRegion_args iprot bs = to_UpdateRegion_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateRegion_args) bs
typemap_UpdateRegion_args :: T.TypeMap
typemap_UpdateRegion_args = Map.fromList [(2,("region",T.T_STRING))]
default_UpdateRegion_args :: UpdateRegion_args
default_UpdateRegion_args = UpdateRegion_args{
  updateRegion_args_region = ""}
data UpdateRegion_result = UpdateRegion_result  { updateRegion_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateRegion_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateRegion_result_e record  
instance QC.Arbitrary UpdateRegion_result where 
  arbitrary = M.liftM UpdateRegion_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateRegion_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateRegion_result{updateRegion_result_e = updateRegion_result_e obj} then P.Nothing else P.Just $ default_UpdateRegion_result{updateRegion_result_e = updateRegion_result_e obj}
    ]
from_UpdateRegion_result :: UpdateRegion_result -> T.ThriftVal
from_UpdateRegion_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6256 -> (1, ("e",from_TalkException _v6256))) <$> updateRegion_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6256 -> (1, ("e",from_TalkException _v6256))) <$> updateRegion_result_e record
    ]
    )
write_UpdateRegion_result :: T.Protocol p => p -> UpdateRegion_result -> P.IO ()
write_UpdateRegion_result oprot record = T.writeVal oprot $ from_UpdateRegion_result record
encode_UpdateRegion_result :: T.StatelessProtocol p => p -> UpdateRegion_result -> LBS.ByteString
encode_UpdateRegion_result oprot record = T.serializeVal oprot $ from_UpdateRegion_result record
to_UpdateRegion_result :: T.ThriftVal -> UpdateRegion_result
to_UpdateRegion_result (T.TStruct fields) = UpdateRegion_result{
  updateRegion_result_e = P.maybe (P.Nothing) (\(_,_val6258) -> P.Just (case _val6258 of {T.TStruct _val6259 -> (to_TalkException (T.TStruct _val6259)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateRegion_result _ = P.error "not a struct"
read_UpdateRegion_result :: T.Protocol p => p -> P.IO UpdateRegion_result
read_UpdateRegion_result iprot = to_UpdateRegion_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateRegion_result)
decode_UpdateRegion_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateRegion_result
decode_UpdateRegion_result iprot bs = to_UpdateRegion_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateRegion_result) bs
typemap_UpdateRegion_result :: T.TypeMap
typemap_UpdateRegion_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateRegion_result :: UpdateRegion_result
default_UpdateRegion_result = UpdateRegion_result{
  updateRegion_result_e = P.Nothing}
data UpdateSettings_args = UpdateSettings_args  { updateSettings_args_reqSeq :: I.Int32
  , updateSettings_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings_args_reqSeq record   `H.hashWithSalt` updateSettings_args_settings record  
instance QC.Arbitrary UpdateSettings_args where 
  arbitrary = M.liftM UpdateSettings_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings_args{updateSettings_args_reqSeq = updateSettings_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettings_args{updateSettings_args_reqSeq = updateSettings_args_reqSeq obj}
    , if obj == default_UpdateSettings_args{updateSettings_args_settings = updateSettings_args_settings obj} then P.Nothing else P.Just $ default_UpdateSettings_args{updateSettings_args_settings = updateSettings_args_settings obj}
    ]
from_UpdateSettings_args :: UpdateSettings_args -> T.ThriftVal
from_UpdateSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6262 -> P.Just (1, ("reqSeq",T.TI32 _v6262))) $ updateSettings_args_reqSeq record
  , (\_v6262 -> P.Just (2, ("settings",from_Settings _v6262))) $ updateSettings_args_settings record
  ]
write_UpdateSettings_args :: T.Protocol p => p -> UpdateSettings_args -> P.IO ()
write_UpdateSettings_args oprot record = T.writeVal oprot $ from_UpdateSettings_args record
encode_UpdateSettings_args :: T.StatelessProtocol p => p -> UpdateSettings_args -> LBS.ByteString
encode_UpdateSettings_args oprot record = T.serializeVal oprot $ from_UpdateSettings_args record
to_UpdateSettings_args :: T.ThriftVal -> UpdateSettings_args
to_UpdateSettings_args (T.TStruct fields) = UpdateSettings_args{
  updateSettings_args_reqSeq = P.maybe (updateSettings_args_reqSeq default_UpdateSettings_args) (\(_,_val6264) -> (case _val6264 of {T.TI32 _val6265 -> _val6265; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettings_args_settings = P.maybe (updateSettings_args_settings default_UpdateSettings_args) (\(_,_val6264) -> (case _val6264 of {T.TStruct _val6266 -> (to_Settings (T.TStruct _val6266)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSettings_args _ = P.error "not a struct"
read_UpdateSettings_args :: T.Protocol p => p -> P.IO UpdateSettings_args
read_UpdateSettings_args iprot = to_UpdateSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings_args)
decode_UpdateSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings_args
decode_UpdateSettings_args iprot bs = to_UpdateSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings_args) bs
typemap_UpdateSettings_args :: T.TypeMap
typemap_UpdateSettings_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("settings",(T.T_STRUCT typemap_Settings)))]
default_UpdateSettings_args :: UpdateSettings_args
default_UpdateSettings_args = UpdateSettings_args{
  updateSettings_args_reqSeq = 0,
  updateSettings_args_settings = default_Settings}
data UpdateSettings_result = UpdateSettings_result  { updateSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings_result_e record  
instance QC.Arbitrary UpdateSettings_result where 
  arbitrary = M.liftM UpdateSettings_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings_result{updateSettings_result_e = updateSettings_result_e obj} then P.Nothing else P.Just $ default_UpdateSettings_result{updateSettings_result_e = updateSettings_result_e obj}
    ]
from_UpdateSettings_result :: UpdateSettings_result -> T.ThriftVal
from_UpdateSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6269 -> (1, ("e",from_TalkException _v6269))) <$> updateSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6269 -> (1, ("e",from_TalkException _v6269))) <$> updateSettings_result_e record
    ]
    )
write_UpdateSettings_result :: T.Protocol p => p -> UpdateSettings_result -> P.IO ()
write_UpdateSettings_result oprot record = T.writeVal oprot $ from_UpdateSettings_result record
encode_UpdateSettings_result :: T.StatelessProtocol p => p -> UpdateSettings_result -> LBS.ByteString
encode_UpdateSettings_result oprot record = T.serializeVal oprot $ from_UpdateSettings_result record
to_UpdateSettings_result :: T.ThriftVal -> UpdateSettings_result
to_UpdateSettings_result (T.TStruct fields) = UpdateSettings_result{
  updateSettings_result_e = P.maybe (P.Nothing) (\(_,_val6271) -> P.Just (case _val6271 of {T.TStruct _val6272 -> (to_TalkException (T.TStruct _val6272)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettings_result _ = P.error "not a struct"
read_UpdateSettings_result :: T.Protocol p => p -> P.IO UpdateSettings_result
read_UpdateSettings_result iprot = to_UpdateSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings_result)
decode_UpdateSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings_result
decode_UpdateSettings_result iprot bs = to_UpdateSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings_result) bs
typemap_UpdateSettings_result :: T.TypeMap
typemap_UpdateSettings_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettings_result :: UpdateSettings_result
default_UpdateSettings_result = UpdateSettings_result{
  updateSettings_result_e = P.Nothing}
data UpdateSettings2_args = UpdateSettings2_args  { updateSettings2_args_reqSeq :: I.Int32
  , updateSettings2_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings2_args_reqSeq record   `H.hashWithSalt` updateSettings2_args_settings record  
instance QC.Arbitrary UpdateSettings2_args where 
  arbitrary = M.liftM UpdateSettings2_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettings2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings2_args{updateSettings2_args_reqSeq = updateSettings2_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettings2_args{updateSettings2_args_reqSeq = updateSettings2_args_reqSeq obj}
    , if obj == default_UpdateSettings2_args{updateSettings2_args_settings = updateSettings2_args_settings obj} then P.Nothing else P.Just $ default_UpdateSettings2_args{updateSettings2_args_settings = updateSettings2_args_settings obj}
    ]
from_UpdateSettings2_args :: UpdateSettings2_args -> T.ThriftVal
from_UpdateSettings2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6275 -> P.Just (1, ("reqSeq",T.TI32 _v6275))) $ updateSettings2_args_reqSeq record
  , (\_v6275 -> P.Just (2, ("settings",from_Settings _v6275))) $ updateSettings2_args_settings record
  ]
write_UpdateSettings2_args :: T.Protocol p => p -> UpdateSettings2_args -> P.IO ()
write_UpdateSettings2_args oprot record = T.writeVal oprot $ from_UpdateSettings2_args record
encode_UpdateSettings2_args :: T.StatelessProtocol p => p -> UpdateSettings2_args -> LBS.ByteString
encode_UpdateSettings2_args oprot record = T.serializeVal oprot $ from_UpdateSettings2_args record
to_UpdateSettings2_args :: T.ThriftVal -> UpdateSettings2_args
to_UpdateSettings2_args (T.TStruct fields) = UpdateSettings2_args{
  updateSettings2_args_reqSeq = P.maybe (updateSettings2_args_reqSeq default_UpdateSettings2_args) (\(_,_val6277) -> (case _val6277 of {T.TI32 _val6278 -> _val6278; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettings2_args_settings = P.maybe (updateSettings2_args_settings default_UpdateSettings2_args) (\(_,_val6277) -> (case _val6277 of {T.TStruct _val6279 -> (to_Settings (T.TStruct _val6279)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSettings2_args _ = P.error "not a struct"
read_UpdateSettings2_args :: T.Protocol p => p -> P.IO UpdateSettings2_args
read_UpdateSettings2_args iprot = to_UpdateSettings2_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings2_args)
decode_UpdateSettings2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings2_args
decode_UpdateSettings2_args iprot bs = to_UpdateSettings2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings2_args) bs
typemap_UpdateSettings2_args :: T.TypeMap
typemap_UpdateSettings2_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("settings",(T.T_STRUCT typemap_Settings)))]
default_UpdateSettings2_args :: UpdateSettings2_args
default_UpdateSettings2_args = UpdateSettings2_args{
  updateSettings2_args_reqSeq = 0,
  updateSettings2_args_settings = default_Settings}
data UpdateSettings2_result = UpdateSettings2_result  { updateSettings2_result_success :: I.Int32
  , updateSettings2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings2_result_success record   `H.hashWithSalt` updateSettings2_result_e record  
instance QC.Arbitrary UpdateSettings2_result where 
  arbitrary = M.liftM UpdateSettings2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettings2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings2_result{updateSettings2_result_success = updateSettings2_result_success obj} then P.Nothing else P.Just $ default_UpdateSettings2_result{updateSettings2_result_success = updateSettings2_result_success obj}
    , if obj == default_UpdateSettings2_result{updateSettings2_result_e = updateSettings2_result_e obj} then P.Nothing else P.Just $ default_UpdateSettings2_result{updateSettings2_result_e = updateSettings2_result_e obj}
    ]
from_UpdateSettings2_result :: UpdateSettings2_result -> T.ThriftVal
from_UpdateSettings2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6282 -> (1, ("e",from_TalkException _v6282))) <$> updateSettings2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6282 -> P.Just (0, ("success",T.TI32 _v6282))) $ updateSettings2_result_success record
    , (\_v6282 -> (1, ("e",from_TalkException _v6282))) <$> updateSettings2_result_e record
    ]
    )
write_UpdateSettings2_result :: T.Protocol p => p -> UpdateSettings2_result -> P.IO ()
write_UpdateSettings2_result oprot record = T.writeVal oprot $ from_UpdateSettings2_result record
encode_UpdateSettings2_result :: T.StatelessProtocol p => p -> UpdateSettings2_result -> LBS.ByteString
encode_UpdateSettings2_result oprot record = T.serializeVal oprot $ from_UpdateSettings2_result record
to_UpdateSettings2_result :: T.ThriftVal -> UpdateSettings2_result
to_UpdateSettings2_result (T.TStruct fields) = UpdateSettings2_result{
  updateSettings2_result_success = P.maybe (updateSettings2_result_success default_UpdateSettings2_result) (\(_,_val6284) -> (case _val6284 of {T.TI32 _val6285 -> _val6285; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSettings2_result_e = P.maybe (P.Nothing) (\(_,_val6284) -> P.Just (case _val6284 of {T.TStruct _val6286 -> (to_TalkException (T.TStruct _val6286)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettings2_result _ = P.error "not a struct"
read_UpdateSettings2_result :: T.Protocol p => p -> P.IO UpdateSettings2_result
read_UpdateSettings2_result iprot = to_UpdateSettings2_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings2_result)
decode_UpdateSettings2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings2_result
decode_UpdateSettings2_result iprot bs = to_UpdateSettings2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings2_result) bs
typemap_UpdateSettings2_result :: T.TypeMap
typemap_UpdateSettings2_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettings2_result :: UpdateSettings2_result
default_UpdateSettings2_result = UpdateSettings2_result{
  updateSettings2_result_success = 0,
  updateSettings2_result_e = P.Nothing}
data UpdateSettingsAttribute_args = UpdateSettingsAttribute_args  { updateSettingsAttribute_args_reqSeq :: I.Int32
  , updateSettingsAttribute_args_attr :: SettingsAttribute
  , updateSettingsAttribute_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttribute_args_reqSeq record   `H.hashWithSalt` updateSettingsAttribute_args_attr record   `H.hashWithSalt` updateSettingsAttribute_args_value record  
instance QC.Arbitrary UpdateSettingsAttribute_args where 
  arbitrary = M.liftM UpdateSettingsAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_reqSeq = updateSettingsAttribute_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_reqSeq = updateSettingsAttribute_args_reqSeq obj}
    , if obj == default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_attr = updateSettingsAttribute_args_attr obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_attr = updateSettingsAttribute_args_attr obj}
    , if obj == default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_value = updateSettingsAttribute_args_value obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_value = updateSettingsAttribute_args_value obj}
    ]
from_UpdateSettingsAttribute_args :: UpdateSettingsAttribute_args -> T.ThriftVal
from_UpdateSettingsAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6289 -> P.Just (1, ("reqSeq",T.TI32 _v6289))) $ updateSettingsAttribute_args_reqSeq record
  , (\_v6289 -> P.Just (2, ("attr",T.TI32 $ P.fromIntegral $ P.fromEnum _v6289))) $ updateSettingsAttribute_args_attr record
  , (\_v6289 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v6289))) $ updateSettingsAttribute_args_value record
  ]
write_UpdateSettingsAttribute_args :: T.Protocol p => p -> UpdateSettingsAttribute_args -> P.IO ()
write_UpdateSettingsAttribute_args oprot record = T.writeVal oprot $ from_UpdateSettingsAttribute_args record
encode_UpdateSettingsAttribute_args :: T.StatelessProtocol p => p -> UpdateSettingsAttribute_args -> LBS.ByteString
encode_UpdateSettingsAttribute_args oprot record = T.serializeVal oprot $ from_UpdateSettingsAttribute_args record
to_UpdateSettingsAttribute_args :: T.ThriftVal -> UpdateSettingsAttribute_args
to_UpdateSettingsAttribute_args (T.TStruct fields) = UpdateSettingsAttribute_args{
  updateSettingsAttribute_args_reqSeq = P.maybe (updateSettingsAttribute_args_reqSeq default_UpdateSettingsAttribute_args) (\(_,_val6291) -> (case _val6291 of {T.TI32 _val6292 -> _val6292; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettingsAttribute_args_attr = P.maybe (updateSettingsAttribute_args_attr default_UpdateSettingsAttribute_args) (\(_,_val6291) -> (case _val6291 of {T.TI32 _val6293 -> P.toEnum $ P.fromIntegral _val6293; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSettingsAttribute_args_value = P.maybe (updateSettingsAttribute_args_value default_UpdateSettingsAttribute_args) (\(_,_val6291) -> (case _val6291 of {T.TString _val6294 -> E.decodeUtf8 _val6294; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSettingsAttribute_args _ = P.error "not a struct"
read_UpdateSettingsAttribute_args :: T.Protocol p => p -> P.IO UpdateSettingsAttribute_args
read_UpdateSettingsAttribute_args iprot = to_UpdateSettingsAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_args)
decode_UpdateSettingsAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttribute_args
decode_UpdateSettingsAttribute_args iprot bs = to_UpdateSettingsAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_args) bs
typemap_UpdateSettingsAttribute_args :: T.TypeMap
typemap_UpdateSettingsAttribute_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("attr",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateSettingsAttribute_args :: UpdateSettingsAttribute_args
default_UpdateSettingsAttribute_args = UpdateSettingsAttribute_args{
  updateSettingsAttribute_args_reqSeq = 0,
  updateSettingsAttribute_args_attr = (P.toEnum 0),
  updateSettingsAttribute_args_value = ""}
data UpdateSettingsAttribute_result = UpdateSettingsAttribute_result  { updateSettingsAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttribute_result_e record  
instance QC.Arbitrary UpdateSettingsAttribute_result where 
  arbitrary = M.liftM UpdateSettingsAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttribute_result{updateSettingsAttribute_result_e = updateSettingsAttribute_result_e obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_result{updateSettingsAttribute_result_e = updateSettingsAttribute_result_e obj}
    ]
from_UpdateSettingsAttribute_result :: UpdateSettingsAttribute_result -> T.ThriftVal
from_UpdateSettingsAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6297 -> (1, ("e",from_TalkException _v6297))) <$> updateSettingsAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6297 -> (1, ("e",from_TalkException _v6297))) <$> updateSettingsAttribute_result_e record
    ]
    )
write_UpdateSettingsAttribute_result :: T.Protocol p => p -> UpdateSettingsAttribute_result -> P.IO ()
write_UpdateSettingsAttribute_result oprot record = T.writeVal oprot $ from_UpdateSettingsAttribute_result record
encode_UpdateSettingsAttribute_result :: T.StatelessProtocol p => p -> UpdateSettingsAttribute_result -> LBS.ByteString
encode_UpdateSettingsAttribute_result oprot record = T.serializeVal oprot $ from_UpdateSettingsAttribute_result record
to_UpdateSettingsAttribute_result :: T.ThriftVal -> UpdateSettingsAttribute_result
to_UpdateSettingsAttribute_result (T.TStruct fields) = UpdateSettingsAttribute_result{
  updateSettingsAttribute_result_e = P.maybe (P.Nothing) (\(_,_val6299) -> P.Just (case _val6299 of {T.TStruct _val6300 -> (to_TalkException (T.TStruct _val6300)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettingsAttribute_result _ = P.error "not a struct"
read_UpdateSettingsAttribute_result :: T.Protocol p => p -> P.IO UpdateSettingsAttribute_result
read_UpdateSettingsAttribute_result iprot = to_UpdateSettingsAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_result)
decode_UpdateSettingsAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttribute_result
decode_UpdateSettingsAttribute_result iprot bs = to_UpdateSettingsAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_result) bs
typemap_UpdateSettingsAttribute_result :: T.TypeMap
typemap_UpdateSettingsAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettingsAttribute_result :: UpdateSettingsAttribute_result
default_UpdateSettingsAttribute_result = UpdateSettingsAttribute_result{
  updateSettingsAttribute_result_e = P.Nothing}
data UpdateSettingsAttributes_args = UpdateSettingsAttributes_args  { updateSettingsAttributes_args_reqSeq :: I.Int32
  , updateSettingsAttributes_args_attrBitset :: I.Int32
  , updateSettingsAttributes_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttributes_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttributes_args_reqSeq record   `H.hashWithSalt` updateSettingsAttributes_args_attrBitset record   `H.hashWithSalt` updateSettingsAttributes_args_settings record  
instance QC.Arbitrary UpdateSettingsAttributes_args where 
  arbitrary = M.liftM UpdateSettingsAttributes_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttributes_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_reqSeq = updateSettingsAttributes_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_reqSeq = updateSettingsAttributes_args_reqSeq obj}
    , if obj == default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_attrBitset = updateSettingsAttributes_args_attrBitset obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_attrBitset = updateSettingsAttributes_args_attrBitset obj}
    , if obj == default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_settings = updateSettingsAttributes_args_settings obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_settings = updateSettingsAttributes_args_settings obj}
    ]
from_UpdateSettingsAttributes_args :: UpdateSettingsAttributes_args -> T.ThriftVal
from_UpdateSettingsAttributes_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6303 -> P.Just (1, ("reqSeq",T.TI32 _v6303))) $ updateSettingsAttributes_args_reqSeq record
  , (\_v6303 -> P.Just (2, ("attrBitset",T.TI32 _v6303))) $ updateSettingsAttributes_args_attrBitset record
  , (\_v6303 -> P.Just (3, ("settings",from_Settings _v6303))) $ updateSettingsAttributes_args_settings record
  ]
write_UpdateSettingsAttributes_args :: T.Protocol p => p -> UpdateSettingsAttributes_args -> P.IO ()
write_UpdateSettingsAttributes_args oprot record = T.writeVal oprot $ from_UpdateSettingsAttributes_args record
encode_UpdateSettingsAttributes_args :: T.StatelessProtocol p => p -> UpdateSettingsAttributes_args -> LBS.ByteString
encode_UpdateSettingsAttributes_args oprot record = T.serializeVal oprot $ from_UpdateSettingsAttributes_args record
to_UpdateSettingsAttributes_args :: T.ThriftVal -> UpdateSettingsAttributes_args
to_UpdateSettingsAttributes_args (T.TStruct fields) = UpdateSettingsAttributes_args{
  updateSettingsAttributes_args_reqSeq = P.maybe (updateSettingsAttributes_args_reqSeq default_UpdateSettingsAttributes_args) (\(_,_val6305) -> (case _val6305 of {T.TI32 _val6306 -> _val6306; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettingsAttributes_args_attrBitset = P.maybe (updateSettingsAttributes_args_attrBitset default_UpdateSettingsAttributes_args) (\(_,_val6305) -> (case _val6305 of {T.TI32 _val6307 -> _val6307; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSettingsAttributes_args_settings = P.maybe (updateSettingsAttributes_args_settings default_UpdateSettingsAttributes_args) (\(_,_val6305) -> (case _val6305 of {T.TStruct _val6308 -> (to_Settings (T.TStruct _val6308)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSettingsAttributes_args _ = P.error "not a struct"
read_UpdateSettingsAttributes_args :: T.Protocol p => p -> P.IO UpdateSettingsAttributes_args
read_UpdateSettingsAttributes_args iprot = to_UpdateSettingsAttributes_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_args)
decode_UpdateSettingsAttributes_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttributes_args
decode_UpdateSettingsAttributes_args iprot bs = to_UpdateSettingsAttributes_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_args) bs
typemap_UpdateSettingsAttributes_args :: T.TypeMap
typemap_UpdateSettingsAttributes_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("attrBitset",T.T_I32)),(3,("settings",(T.T_STRUCT typemap_Settings)))]
default_UpdateSettingsAttributes_args :: UpdateSettingsAttributes_args
default_UpdateSettingsAttributes_args = UpdateSettingsAttributes_args{
  updateSettingsAttributes_args_reqSeq = 0,
  updateSettingsAttributes_args_attrBitset = 0,
  updateSettingsAttributes_args_settings = default_Settings}
data UpdateSettingsAttributes_result = UpdateSettingsAttributes_result  { updateSettingsAttributes_result_success :: I.Int32
  , updateSettingsAttributes_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttributes_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttributes_result_success record   `H.hashWithSalt` updateSettingsAttributes_result_e record  
instance QC.Arbitrary UpdateSettingsAttributes_result where 
  arbitrary = M.liftM UpdateSettingsAttributes_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttributes_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_success = updateSettingsAttributes_result_success obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_success = updateSettingsAttributes_result_success obj}
    , if obj == default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_e = updateSettingsAttributes_result_e obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_e = updateSettingsAttributes_result_e obj}
    ]
from_UpdateSettingsAttributes_result :: UpdateSettingsAttributes_result -> T.ThriftVal
from_UpdateSettingsAttributes_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6311 -> (1, ("e",from_TalkException _v6311))) <$> updateSettingsAttributes_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6311 -> P.Just (0, ("success",T.TI32 _v6311))) $ updateSettingsAttributes_result_success record
    , (\_v6311 -> (1, ("e",from_TalkException _v6311))) <$> updateSettingsAttributes_result_e record
    ]
    )
write_UpdateSettingsAttributes_result :: T.Protocol p => p -> UpdateSettingsAttributes_result -> P.IO ()
write_UpdateSettingsAttributes_result oprot record = T.writeVal oprot $ from_UpdateSettingsAttributes_result record
encode_UpdateSettingsAttributes_result :: T.StatelessProtocol p => p -> UpdateSettingsAttributes_result -> LBS.ByteString
encode_UpdateSettingsAttributes_result oprot record = T.serializeVal oprot $ from_UpdateSettingsAttributes_result record
to_UpdateSettingsAttributes_result :: T.ThriftVal -> UpdateSettingsAttributes_result
to_UpdateSettingsAttributes_result (T.TStruct fields) = UpdateSettingsAttributes_result{
  updateSettingsAttributes_result_success = P.maybe (updateSettingsAttributes_result_success default_UpdateSettingsAttributes_result) (\(_,_val6313) -> (case _val6313 of {T.TI32 _val6314 -> _val6314; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSettingsAttributes_result_e = P.maybe (P.Nothing) (\(_,_val6313) -> P.Just (case _val6313 of {T.TStruct _val6315 -> (to_TalkException (T.TStruct _val6315)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettingsAttributes_result _ = P.error "not a struct"
read_UpdateSettingsAttributes_result :: T.Protocol p => p -> P.IO UpdateSettingsAttributes_result
read_UpdateSettingsAttributes_result iprot = to_UpdateSettingsAttributes_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_result)
decode_UpdateSettingsAttributes_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttributes_result
decode_UpdateSettingsAttributes_result iprot bs = to_UpdateSettingsAttributes_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_result) bs
typemap_UpdateSettingsAttributes_result :: T.TypeMap
typemap_UpdateSettingsAttributes_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettingsAttributes_result :: UpdateSettingsAttributes_result
default_UpdateSettingsAttributes_result = UpdateSettingsAttributes_result{
  updateSettingsAttributes_result_success = 0,
  updateSettingsAttributes_result_e = P.Nothing}
data VerifyIdentityCredential_args = VerifyIdentityCredential_args  { verifyIdentityCredential_args_identityProvider :: IdentityProvider
  , verifyIdentityCredential_args_identifier :: LT.Text
  , verifyIdentityCredential_args_password :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredential_args_identityProvider record   `H.hashWithSalt` verifyIdentityCredential_args_identifier record   `H.hashWithSalt` verifyIdentityCredential_args_password record  
instance QC.Arbitrary VerifyIdentityCredential_args where 
  arbitrary = M.liftM VerifyIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identityProvider = verifyIdentityCredential_args_identityProvider obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identityProvider = verifyIdentityCredential_args_identityProvider obj}
    , if obj == default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identifier = verifyIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identifier = verifyIdentityCredential_args_identifier obj}
    , if obj == default_VerifyIdentityCredential_args{verifyIdentityCredential_args_password = verifyIdentityCredential_args_password obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_args{verifyIdentityCredential_args_password = verifyIdentityCredential_args_password obj}
    ]
from_VerifyIdentityCredential_args :: VerifyIdentityCredential_args -> T.ThriftVal
from_VerifyIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6318 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v6318))) $ verifyIdentityCredential_args_identifier record
  , (\_v6318 -> P.Just (4, ("password",T.TString $ E.encodeUtf8 _v6318))) $ verifyIdentityCredential_args_password record
  , (\_v6318 -> P.Just (8, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v6318))) $ verifyIdentityCredential_args_identityProvider record
  ]
write_VerifyIdentityCredential_args :: T.Protocol p => p -> VerifyIdentityCredential_args -> P.IO ()
write_VerifyIdentityCredential_args oprot record = T.writeVal oprot $ from_VerifyIdentityCredential_args record
encode_VerifyIdentityCredential_args :: T.StatelessProtocol p => p -> VerifyIdentityCredential_args -> LBS.ByteString
encode_VerifyIdentityCredential_args oprot record = T.serializeVal oprot $ from_VerifyIdentityCredential_args record
to_VerifyIdentityCredential_args :: T.ThriftVal -> VerifyIdentityCredential_args
to_VerifyIdentityCredential_args (T.TStruct fields) = VerifyIdentityCredential_args{
  verifyIdentityCredential_args_identityProvider = P.maybe (verifyIdentityCredential_args_identityProvider default_VerifyIdentityCredential_args) (\(_,_val6320) -> (case _val6320 of {T.TI32 _val6321 -> P.toEnum $ P.fromIntegral _val6321; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  verifyIdentityCredential_args_identifier = P.maybe (verifyIdentityCredential_args_identifier default_VerifyIdentityCredential_args) (\(_,_val6320) -> (case _val6320 of {T.TString _val6322 -> E.decodeUtf8 _val6322; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyIdentityCredential_args_password = P.maybe (verifyIdentityCredential_args_password default_VerifyIdentityCredential_args) (\(_,_val6320) -> (case _val6320 of {T.TString _val6323 -> E.decodeUtf8 _val6323; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_VerifyIdentityCredential_args _ = P.error "not a struct"
read_VerifyIdentityCredential_args :: T.Protocol p => p -> P.IO VerifyIdentityCredential_args
read_VerifyIdentityCredential_args iprot = to_VerifyIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_args)
decode_VerifyIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredential_args
decode_VerifyIdentityCredential_args iprot bs = to_VerifyIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_args) bs
typemap_VerifyIdentityCredential_args :: T.TypeMap
typemap_VerifyIdentityCredential_args = Map.fromList [(3,("identifier",T.T_STRING)),(4,("password",T.T_STRING)),(8,("identityProvider",T.T_I32))]
default_VerifyIdentityCredential_args :: VerifyIdentityCredential_args
default_VerifyIdentityCredential_args = VerifyIdentityCredential_args{
  verifyIdentityCredential_args_identifier = "",
  verifyIdentityCredential_args_password = "",
  verifyIdentityCredential_args_identityProvider = (P.toEnum 0)}
data VerifyIdentityCredential_result = VerifyIdentityCredential_result  { verifyIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredential_result_e record  
instance QC.Arbitrary VerifyIdentityCredential_result where 
  arbitrary = M.liftM VerifyIdentityCredential_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredential_result{verifyIdentityCredential_result_e = verifyIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_result{verifyIdentityCredential_result_e = verifyIdentityCredential_result_e obj}
    ]
from_VerifyIdentityCredential_result :: VerifyIdentityCredential_result -> T.ThriftVal
from_VerifyIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6326 -> (1, ("e",from_TalkException _v6326))) <$> verifyIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6326 -> (1, ("e",from_TalkException _v6326))) <$> verifyIdentityCredential_result_e record
    ]
    )
write_VerifyIdentityCredential_result :: T.Protocol p => p -> VerifyIdentityCredential_result -> P.IO ()
write_VerifyIdentityCredential_result oprot record = T.writeVal oprot $ from_VerifyIdentityCredential_result record
encode_VerifyIdentityCredential_result :: T.StatelessProtocol p => p -> VerifyIdentityCredential_result -> LBS.ByteString
encode_VerifyIdentityCredential_result oprot record = T.serializeVal oprot $ from_VerifyIdentityCredential_result record
to_VerifyIdentityCredential_result :: T.ThriftVal -> VerifyIdentityCredential_result
to_VerifyIdentityCredential_result (T.TStruct fields) = VerifyIdentityCredential_result{
  verifyIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val6328) -> P.Just (case _val6328 of {T.TStruct _val6329 -> (to_TalkException (T.TStruct _val6329)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyIdentityCredential_result _ = P.error "not a struct"
read_VerifyIdentityCredential_result :: T.Protocol p => p -> P.IO VerifyIdentityCredential_result
read_VerifyIdentityCredential_result iprot = to_VerifyIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_result)
decode_VerifyIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredential_result
decode_VerifyIdentityCredential_result iprot bs = to_VerifyIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_result) bs
typemap_VerifyIdentityCredential_result :: T.TypeMap
typemap_VerifyIdentityCredential_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyIdentityCredential_result :: VerifyIdentityCredential_result
default_VerifyIdentityCredential_result = VerifyIdentityCredential_result{
  verifyIdentityCredential_result_e = P.Nothing}
data VerifyIdentityCredentialWithResult_args = VerifyIdentityCredentialWithResult_args  { verifyIdentityCredentialWithResult_args_identityCredential :: IdentityCredential
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredentialWithResult_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredentialWithResult_args_identityCredential record  
instance QC.Arbitrary VerifyIdentityCredentialWithResult_args where 
  arbitrary = M.liftM VerifyIdentityCredentialWithResult_args (QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredentialWithResult_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredentialWithResult_args{verifyIdentityCredentialWithResult_args_identityCredential = verifyIdentityCredentialWithResult_args_identityCredential obj} then P.Nothing else P.Just $ default_VerifyIdentityCredentialWithResult_args{verifyIdentityCredentialWithResult_args_identityCredential = verifyIdentityCredentialWithResult_args_identityCredential obj}
    ]
from_VerifyIdentityCredentialWithResult_args :: VerifyIdentityCredentialWithResult_args -> T.ThriftVal
from_VerifyIdentityCredentialWithResult_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6332 -> P.Just (2, ("identityCredential",from_IdentityCredential _v6332))) $ verifyIdentityCredentialWithResult_args_identityCredential record
  ]
write_VerifyIdentityCredentialWithResult_args :: T.Protocol p => p -> VerifyIdentityCredentialWithResult_args -> P.IO ()
write_VerifyIdentityCredentialWithResult_args oprot record = T.writeVal oprot $ from_VerifyIdentityCredentialWithResult_args record
encode_VerifyIdentityCredentialWithResult_args :: T.StatelessProtocol p => p -> VerifyIdentityCredentialWithResult_args -> LBS.ByteString
encode_VerifyIdentityCredentialWithResult_args oprot record = T.serializeVal oprot $ from_VerifyIdentityCredentialWithResult_args record
to_VerifyIdentityCredentialWithResult_args :: T.ThriftVal -> VerifyIdentityCredentialWithResult_args
to_VerifyIdentityCredentialWithResult_args (T.TStruct fields) = VerifyIdentityCredentialWithResult_args{
  verifyIdentityCredentialWithResult_args_identityCredential = P.maybe (verifyIdentityCredentialWithResult_args_identityCredential default_VerifyIdentityCredentialWithResult_args) (\(_,_val6334) -> (case _val6334 of {T.TStruct _val6335 -> (to_IdentityCredential (T.TStruct _val6335)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_VerifyIdentityCredentialWithResult_args _ = P.error "not a struct"
read_VerifyIdentityCredentialWithResult_args :: T.Protocol p => p -> P.IO VerifyIdentityCredentialWithResult_args
read_VerifyIdentityCredentialWithResult_args iprot = to_VerifyIdentityCredentialWithResult_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_args)
decode_VerifyIdentityCredentialWithResult_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredentialWithResult_args
decode_VerifyIdentityCredentialWithResult_args iprot bs = to_VerifyIdentityCredentialWithResult_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_args) bs
typemap_VerifyIdentityCredentialWithResult_args :: T.TypeMap
typemap_VerifyIdentityCredentialWithResult_args = Map.fromList [(2,("identityCredential",(T.T_STRUCT typemap_IdentityCredential)))]
default_VerifyIdentityCredentialWithResult_args :: VerifyIdentityCredentialWithResult_args
default_VerifyIdentityCredentialWithResult_args = VerifyIdentityCredentialWithResult_args{
  verifyIdentityCredentialWithResult_args_identityCredential = default_IdentityCredential}
data VerifyIdentityCredentialWithResult_result = VerifyIdentityCredentialWithResult_result  { verifyIdentityCredentialWithResult_result_success :: UserAuthStatus
  , verifyIdentityCredentialWithResult_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredentialWithResult_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredentialWithResult_result_success record   `H.hashWithSalt` verifyIdentityCredentialWithResult_result_e record  
instance QC.Arbitrary VerifyIdentityCredentialWithResult_result where 
  arbitrary = M.liftM VerifyIdentityCredentialWithResult_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredentialWithResult_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_success = verifyIdentityCredentialWithResult_result_success obj} then P.Nothing else P.Just $ default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_success = verifyIdentityCredentialWithResult_result_success obj}
    , if obj == default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_e = verifyIdentityCredentialWithResult_result_e obj} then P.Nothing else P.Just $ default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_e = verifyIdentityCredentialWithResult_result_e obj}
    ]
from_VerifyIdentityCredentialWithResult_result :: VerifyIdentityCredentialWithResult_result -> T.ThriftVal
from_VerifyIdentityCredentialWithResult_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6338 -> (1, ("e",from_TalkException _v6338))) <$> verifyIdentityCredentialWithResult_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6338 -> P.Just (0, ("success",from_UserAuthStatus _v6338))) $ verifyIdentityCredentialWithResult_result_success record
    , (\_v6338 -> (1, ("e",from_TalkException _v6338))) <$> verifyIdentityCredentialWithResult_result_e record
    ]
    )
write_VerifyIdentityCredentialWithResult_result :: T.Protocol p => p -> VerifyIdentityCredentialWithResult_result -> P.IO ()
write_VerifyIdentityCredentialWithResult_result oprot record = T.writeVal oprot $ from_VerifyIdentityCredentialWithResult_result record
encode_VerifyIdentityCredentialWithResult_result :: T.StatelessProtocol p => p -> VerifyIdentityCredentialWithResult_result -> LBS.ByteString
encode_VerifyIdentityCredentialWithResult_result oprot record = T.serializeVal oprot $ from_VerifyIdentityCredentialWithResult_result record
to_VerifyIdentityCredentialWithResult_result :: T.ThriftVal -> VerifyIdentityCredentialWithResult_result
to_VerifyIdentityCredentialWithResult_result (T.TStruct fields) = VerifyIdentityCredentialWithResult_result{
  verifyIdentityCredentialWithResult_result_success = P.maybe (verifyIdentityCredentialWithResult_result_success default_VerifyIdentityCredentialWithResult_result) (\(_,_val6340) -> (case _val6340 of {T.TStruct _val6341 -> (to_UserAuthStatus (T.TStruct _val6341)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyIdentityCredentialWithResult_result_e = P.maybe (P.Nothing) (\(_,_val6340) -> P.Just (case _val6340 of {T.TStruct _val6342 -> (to_TalkException (T.TStruct _val6342)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyIdentityCredentialWithResult_result _ = P.error "not a struct"
read_VerifyIdentityCredentialWithResult_result :: T.Protocol p => p -> P.IO VerifyIdentityCredentialWithResult_result
read_VerifyIdentityCredentialWithResult_result iprot = to_VerifyIdentityCredentialWithResult_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_result)
decode_VerifyIdentityCredentialWithResult_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredentialWithResult_result
decode_VerifyIdentityCredentialWithResult_result iprot bs = to_VerifyIdentityCredentialWithResult_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_result) bs
typemap_VerifyIdentityCredentialWithResult_result :: T.TypeMap
typemap_VerifyIdentityCredentialWithResult_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UserAuthStatus))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyIdentityCredentialWithResult_result :: VerifyIdentityCredentialWithResult_result
default_VerifyIdentityCredentialWithResult_result = VerifyIdentityCredentialWithResult_result{
  verifyIdentityCredentialWithResult_result_success = default_UserAuthStatus,
  verifyIdentityCredentialWithResult_result_e = P.Nothing}
data VerifyPhone_args = VerifyPhone_args  { verifyPhone_args_sessionId :: LT.Text
  , verifyPhone_args_pinCode :: LT.Text
  , verifyPhone_args_udidHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhone_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhone_args_sessionId record   `H.hashWithSalt` verifyPhone_args_pinCode record   `H.hashWithSalt` verifyPhone_args_udidHash record  
instance QC.Arbitrary VerifyPhone_args where 
  arbitrary = M.liftM VerifyPhone_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyPhone_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhone_args{verifyPhone_args_sessionId = verifyPhone_args_sessionId obj} then P.Nothing else P.Just $ default_VerifyPhone_args{verifyPhone_args_sessionId = verifyPhone_args_sessionId obj}
    , if obj == default_VerifyPhone_args{verifyPhone_args_pinCode = verifyPhone_args_pinCode obj} then P.Nothing else P.Just $ default_VerifyPhone_args{verifyPhone_args_pinCode = verifyPhone_args_pinCode obj}
    , if obj == default_VerifyPhone_args{verifyPhone_args_udidHash = verifyPhone_args_udidHash obj} then P.Nothing else P.Just $ default_VerifyPhone_args{verifyPhone_args_udidHash = verifyPhone_args_udidHash obj}
    ]
from_VerifyPhone_args :: VerifyPhone_args -> T.ThriftVal
from_VerifyPhone_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6345 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6345))) $ verifyPhone_args_sessionId record
  , (\_v6345 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v6345))) $ verifyPhone_args_pinCode record
  , (\_v6345 -> P.Just (4, ("udidHash",T.TString $ E.encodeUtf8 _v6345))) $ verifyPhone_args_udidHash record
  ]
write_VerifyPhone_args :: T.Protocol p => p -> VerifyPhone_args -> P.IO ()
write_VerifyPhone_args oprot record = T.writeVal oprot $ from_VerifyPhone_args record
encode_VerifyPhone_args :: T.StatelessProtocol p => p -> VerifyPhone_args -> LBS.ByteString
encode_VerifyPhone_args oprot record = T.serializeVal oprot $ from_VerifyPhone_args record
to_VerifyPhone_args :: T.ThriftVal -> VerifyPhone_args
to_VerifyPhone_args (T.TStruct fields) = VerifyPhone_args{
  verifyPhone_args_sessionId = P.maybe (verifyPhone_args_sessionId default_VerifyPhone_args) (\(_,_val6347) -> (case _val6347 of {T.TString _val6348 -> E.decodeUtf8 _val6348; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyPhone_args_pinCode = P.maybe (verifyPhone_args_pinCode default_VerifyPhone_args) (\(_,_val6347) -> (case _val6347 of {T.TString _val6349 -> E.decodeUtf8 _val6349; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyPhone_args_udidHash = P.maybe (verifyPhone_args_udidHash default_VerifyPhone_args) (\(_,_val6347) -> (case _val6347 of {T.TString _val6350 -> E.decodeUtf8 _val6350; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_VerifyPhone_args _ = P.error "not a struct"
read_VerifyPhone_args :: T.Protocol p => p -> P.IO VerifyPhone_args
read_VerifyPhone_args iprot = to_VerifyPhone_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhone_args)
decode_VerifyPhone_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhone_args
decode_VerifyPhone_args iprot bs = to_VerifyPhone_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhone_args) bs
typemap_VerifyPhone_args :: T.TypeMap
typemap_VerifyPhone_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("pinCode",T.T_STRING)),(4,("udidHash",T.T_STRING))]
default_VerifyPhone_args :: VerifyPhone_args
default_VerifyPhone_args = VerifyPhone_args{
  verifyPhone_args_sessionId = "",
  verifyPhone_args_pinCode = "",
  verifyPhone_args_udidHash = ""}
data VerifyPhone_result = VerifyPhone_result  { verifyPhone_result_success :: VerificationResult
  , verifyPhone_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhone_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhone_result_success record   `H.hashWithSalt` verifyPhone_result_e record  
instance QC.Arbitrary VerifyPhone_result where 
  arbitrary = M.liftM VerifyPhone_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyPhone_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhone_result{verifyPhone_result_success = verifyPhone_result_success obj} then P.Nothing else P.Just $ default_VerifyPhone_result{verifyPhone_result_success = verifyPhone_result_success obj}
    , if obj == default_VerifyPhone_result{verifyPhone_result_e = verifyPhone_result_e obj} then P.Nothing else P.Just $ default_VerifyPhone_result{verifyPhone_result_e = verifyPhone_result_e obj}
    ]
from_VerifyPhone_result :: VerifyPhone_result -> T.ThriftVal
from_VerifyPhone_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6353 -> (1, ("e",from_TalkException _v6353))) <$> verifyPhone_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6353 -> P.Just (0, ("success",T.TI32 $ P.fromIntegral $ P.fromEnum _v6353))) $ verifyPhone_result_success record
    , (\_v6353 -> (1, ("e",from_TalkException _v6353))) <$> verifyPhone_result_e record
    ]
    )
write_VerifyPhone_result :: T.Protocol p => p -> VerifyPhone_result -> P.IO ()
write_VerifyPhone_result oprot record = T.writeVal oprot $ from_VerifyPhone_result record
encode_VerifyPhone_result :: T.StatelessProtocol p => p -> VerifyPhone_result -> LBS.ByteString
encode_VerifyPhone_result oprot record = T.serializeVal oprot $ from_VerifyPhone_result record
to_VerifyPhone_result :: T.ThriftVal -> VerifyPhone_result
to_VerifyPhone_result (T.TStruct fields) = VerifyPhone_result{
  verifyPhone_result_success = P.maybe (verifyPhone_result_success default_VerifyPhone_result) (\(_,_val6355) -> (case _val6355 of {T.TI32 _val6356 -> P.toEnum $ P.fromIntegral _val6356; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyPhone_result_e = P.maybe (P.Nothing) (\(_,_val6355) -> P.Just (case _val6355 of {T.TStruct _val6357 -> (to_TalkException (T.TStruct _val6357)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyPhone_result _ = P.error "not a struct"
read_VerifyPhone_result :: T.Protocol p => p -> P.IO VerifyPhone_result
read_VerifyPhone_result iprot = to_VerifyPhone_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhone_result)
decode_VerifyPhone_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhone_result
decode_VerifyPhone_result iprot bs = to_VerifyPhone_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhone_result) bs
typemap_VerifyPhone_result :: T.TypeMap
typemap_VerifyPhone_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyPhone_result :: VerifyPhone_result
default_VerifyPhone_result = VerifyPhone_result{
  verifyPhone_result_success = (P.toEnum 0),
  verifyPhone_result_e = P.Nothing}
data VerifyQrcode_args = VerifyQrcode_args  { verifyQrcode_args_verifier :: LT.Text
  , verifyQrcode_args_pinCode :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcode_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcode_args_verifier record   `H.hashWithSalt` verifyQrcode_args_pinCode record  
instance QC.Arbitrary VerifyQrcode_args where 
  arbitrary = M.liftM VerifyQrcode_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyQrcode_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcode_args{verifyQrcode_args_verifier = verifyQrcode_args_verifier obj} then P.Nothing else P.Just $ default_VerifyQrcode_args{verifyQrcode_args_verifier = verifyQrcode_args_verifier obj}
    , if obj == default_VerifyQrcode_args{verifyQrcode_args_pinCode = verifyQrcode_args_pinCode obj} then P.Nothing else P.Just $ default_VerifyQrcode_args{verifyQrcode_args_pinCode = verifyQrcode_args_pinCode obj}
    ]
from_VerifyQrcode_args :: VerifyQrcode_args -> T.ThriftVal
from_VerifyQrcode_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6360 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v6360))) $ verifyQrcode_args_verifier record
  , (\_v6360 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v6360))) $ verifyQrcode_args_pinCode record
  ]
write_VerifyQrcode_args :: T.Protocol p => p -> VerifyQrcode_args -> P.IO ()
write_VerifyQrcode_args oprot record = T.writeVal oprot $ from_VerifyQrcode_args record
encode_VerifyQrcode_args :: T.StatelessProtocol p => p -> VerifyQrcode_args -> LBS.ByteString
encode_VerifyQrcode_args oprot record = T.serializeVal oprot $ from_VerifyQrcode_args record
to_VerifyQrcode_args :: T.ThriftVal -> VerifyQrcode_args
to_VerifyQrcode_args (T.TStruct fields) = VerifyQrcode_args{
  verifyQrcode_args_verifier = P.maybe (verifyQrcode_args_verifier default_VerifyQrcode_args) (\(_,_val6362) -> (case _val6362 of {T.TString _val6363 -> E.decodeUtf8 _val6363; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyQrcode_args_pinCode = P.maybe (verifyQrcode_args_pinCode default_VerifyQrcode_args) (\(_,_val6362) -> (case _val6362 of {T.TString _val6364 -> E.decodeUtf8 _val6364; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_VerifyQrcode_args _ = P.error "not a struct"
read_VerifyQrcode_args :: T.Protocol p => p -> P.IO VerifyQrcode_args
read_VerifyQrcode_args iprot = to_VerifyQrcode_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcode_args)
decode_VerifyQrcode_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcode_args
decode_VerifyQrcode_args iprot bs = to_VerifyQrcode_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcode_args) bs
typemap_VerifyQrcode_args :: T.TypeMap
typemap_VerifyQrcode_args = Map.fromList [(2,("verifier",T.T_STRING)),(3,("pinCode",T.T_STRING))]
default_VerifyQrcode_args :: VerifyQrcode_args
default_VerifyQrcode_args = VerifyQrcode_args{
  verifyQrcode_args_verifier = "",
  verifyQrcode_args_pinCode = ""}
data VerifyQrcode_result = VerifyQrcode_result  { verifyQrcode_result_success :: LT.Text
  , verifyQrcode_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcode_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcode_result_success record   `H.hashWithSalt` verifyQrcode_result_e record  
instance QC.Arbitrary VerifyQrcode_result where 
  arbitrary = M.liftM VerifyQrcode_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyQrcode_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcode_result{verifyQrcode_result_success = verifyQrcode_result_success obj} then P.Nothing else P.Just $ default_VerifyQrcode_result{verifyQrcode_result_success = verifyQrcode_result_success obj}
    , if obj == default_VerifyQrcode_result{verifyQrcode_result_e = verifyQrcode_result_e obj} then P.Nothing else P.Just $ default_VerifyQrcode_result{verifyQrcode_result_e = verifyQrcode_result_e obj}
    ]
from_VerifyQrcode_result :: VerifyQrcode_result -> T.ThriftVal
from_VerifyQrcode_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6367 -> (1, ("e",from_TalkException _v6367))) <$> verifyQrcode_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6367 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6367))) $ verifyQrcode_result_success record
    , (\_v6367 -> (1, ("e",from_TalkException _v6367))) <$> verifyQrcode_result_e record
    ]
    )
write_VerifyQrcode_result :: T.Protocol p => p -> VerifyQrcode_result -> P.IO ()
write_VerifyQrcode_result oprot record = T.writeVal oprot $ from_VerifyQrcode_result record
encode_VerifyQrcode_result :: T.StatelessProtocol p => p -> VerifyQrcode_result -> LBS.ByteString
encode_VerifyQrcode_result oprot record = T.serializeVal oprot $ from_VerifyQrcode_result record
to_VerifyQrcode_result :: T.ThriftVal -> VerifyQrcode_result
to_VerifyQrcode_result (T.TStruct fields) = VerifyQrcode_result{
  verifyQrcode_result_success = P.maybe (verifyQrcode_result_success default_VerifyQrcode_result) (\(_,_val6369) -> (case _val6369 of {T.TString _val6370 -> E.decodeUtf8 _val6370; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyQrcode_result_e = P.maybe (P.Nothing) (\(_,_val6369) -> P.Just (case _val6369 of {T.TStruct _val6371 -> (to_TalkException (T.TStruct _val6371)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyQrcode_result _ = P.error "not a struct"
read_VerifyQrcode_result :: T.Protocol p => p -> P.IO VerifyQrcode_result
read_VerifyQrcode_result iprot = to_VerifyQrcode_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcode_result)
decode_VerifyQrcode_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcode_result
decode_VerifyQrcode_result iprot bs = to_VerifyQrcode_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcode_result) bs
typemap_VerifyQrcode_result :: T.TypeMap
typemap_VerifyQrcode_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyQrcode_result :: VerifyQrcode_result
default_VerifyQrcode_result = VerifyQrcode_result{
  verifyQrcode_result_success = "",
  verifyQrcode_result_e = P.Nothing}
process_acceptGroupInvitation (seqid, iprot, oprot, handler) = do
  args <- read_AcceptGroupInvitation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.acceptGroupInvitation handler (acceptGroupInvitation_args_reqSeq args) (acceptGroupInvitation_args_groupId args)
        let res = default_AcceptGroupInvitation_result
        T.writeMessage oprot ("acceptGroupInvitation", T.M_REPLY, seqid) $
          write_AcceptGroupInvitation_result oprot res)
      (\e  -> do
        let res = default_AcceptGroupInvitation_result{acceptGroupInvitation_result_e = P.Just e}
        T.writeMessage oprot ("acceptGroupInvitation", T.M_REPLY, seqid) $
          write_AcceptGroupInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acceptGroupInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acceptProximityMatches (seqid, iprot, oprot, handler) = do
  args <- read_AcceptProximityMatches_args iprot
  (X.catch
    (X.catch
      (do
        Iface.acceptProximityMatches handler (acceptProximityMatches_args_sessionId args) (acceptProximityMatches_args_ids args)
        let res = default_AcceptProximityMatches_result
        T.writeMessage oprot ("acceptProximityMatches", T.M_REPLY, seqid) $
          write_AcceptProximityMatches_result oprot res)
      (\e  -> do
        let res = default_AcceptProximityMatches_result{acceptProximityMatches_result_e = P.Just e}
        T.writeMessage oprot ("acceptProximityMatches", T.M_REPLY, seqid) $
          write_AcceptProximityMatches_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acceptProximityMatches", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireCallRoute (seqid, iprot, oprot, handler) = do
  args <- read_AcquireCallRoute_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireCallRoute handler (acquireCallRoute_args_to args)
        let res = default_AcquireCallRoute_result{acquireCallRoute_result_success = val}
        T.writeMessage oprot ("acquireCallRoute", T.M_REPLY, seqid) $
          write_AcquireCallRoute_result oprot res)
      (\e  -> do
        let res = default_AcquireCallRoute_result{acquireCallRoute_result_e = P.Just e}
        T.writeMessage oprot ("acquireCallRoute", T.M_REPLY, seqid) $
          write_AcquireCallRoute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireCallRoute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireCallTicket (seqid, iprot, oprot, handler) = do
  args <- read_AcquireCallTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireCallTicket handler (acquireCallTicket_args_to args)
        let res = default_AcquireCallTicket_result{acquireCallTicket_result_success = val}
        T.writeMessage oprot ("acquireCallTicket", T.M_REPLY, seqid) $
          write_AcquireCallTicket_result oprot res)
      (\e  -> do
        let res = default_AcquireCallTicket_result{acquireCallTicket_result_e = P.Just e}
        T.writeMessage oprot ("acquireCallTicket", T.M_REPLY, seqid) $
          write_AcquireCallTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireCallTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireEncryptedAccessToken (seqid, iprot, oprot, handler) = do
  args <- read_AcquireEncryptedAccessToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireEncryptedAccessToken handler (acquireEncryptedAccessToken_args_featureType args)
        let res = default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_success = val}
        T.writeMessage oprot ("acquireEncryptedAccessToken", T.M_REPLY, seqid) $
          write_AcquireEncryptedAccessToken_result oprot res)
      (\e  -> do
        let res = default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_e = P.Just e}
        T.writeMessage oprot ("acquireEncryptedAccessToken", T.M_REPLY, seqid) $
          write_AcquireEncryptedAccessToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireEncryptedAccessToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addSnsId (seqid, iprot, oprot, handler) = do
  args <- read_AddSnsId_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.addSnsId handler (addSnsId_args_snsIdType args) (addSnsId_args_snsAccessToken args)
        let res = default_AddSnsId_result{addSnsId_result_success = val}
        T.writeMessage oprot ("addSnsId", T.M_REPLY, seqid) $
          write_AddSnsId_result oprot res)
      (\e  -> do
        let res = default_AddSnsId_result{addSnsId_result_e = P.Just e}
        T.writeMessage oprot ("addSnsId", T.M_REPLY, seqid) $
          write_AddSnsId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addSnsId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_blockContact (seqid, iprot, oprot, handler) = do
  args <- read_BlockContact_args iprot
  (X.catch
    (X.catch
      (do
        Iface.blockContact handler (blockContact_args_reqSeq args) (blockContact_args_id args)
        let res = default_BlockContact_result
        T.writeMessage oprot ("blockContact", T.M_REPLY, seqid) $
          write_BlockContact_result oprot res)
      (\e  -> do
        let res = default_BlockContact_result{blockContact_result_e = P.Just e}
        T.writeMessage oprot ("blockContact", T.M_REPLY, seqid) $
          write_BlockContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("blockContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_blockRecommendation (seqid, iprot, oprot, handler) = do
  args <- read_BlockRecommendation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.blockRecommendation handler (blockRecommendation_args_reqSeq args) (blockRecommendation_args_id args)
        let res = default_BlockRecommendation_result
        T.writeMessage oprot ("blockRecommendation", T.M_REPLY, seqid) $
          write_BlockRecommendation_result oprot res)
      (\e  -> do
        let res = default_BlockRecommendation_result{blockRecommendation_result_e = P.Just e}
        T.writeMessage oprot ("blockRecommendation", T.M_REPLY, seqid) $
          write_BlockRecommendation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("blockRecommendation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_cancelGroupInvitation (seqid, iprot, oprot, handler) = do
  args <- read_CancelGroupInvitation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.cancelGroupInvitation handler (cancelGroupInvitation_args_reqSeq args) (cancelGroupInvitation_args_groupId args) (cancelGroupInvitation_args_contactIds args)
        let res = default_CancelGroupInvitation_result
        T.writeMessage oprot ("cancelGroupInvitation", T.M_REPLY, seqid) $
          write_CancelGroupInvitation_result oprot res)
      (\e  -> do
        let res = default_CancelGroupInvitation_result{cancelGroupInvitation_result_e = P.Just e}
        T.writeMessage oprot ("cancelGroupInvitation", T.M_REPLY, seqid) $
          write_CancelGroupInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("cancelGroupInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_changeVerificationMethod (seqid, iprot, oprot, handler) = do
  args <- read_ChangeVerificationMethod_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.changeVerificationMethod handler (changeVerificationMethod_args_sessionId args) (changeVerificationMethod_args_method args)
        let res = default_ChangeVerificationMethod_result{changeVerificationMethod_result_success = val}
        T.writeMessage oprot ("changeVerificationMethod", T.M_REPLY, seqid) $
          write_ChangeVerificationMethod_result oprot res)
      (\e  -> do
        let res = default_ChangeVerificationMethod_result{changeVerificationMethod_result_e = P.Just e}
        T.writeMessage oprot ("changeVerificationMethod", T.M_REPLY, seqid) $
          write_ChangeVerificationMethod_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("changeVerificationMethod", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_clearIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_ClearIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        Iface.clearIdentityCredential handler
        let res = default_ClearIdentityCredential_result
        T.writeMessage oprot ("clearIdentityCredential", T.M_REPLY, seqid) $
          write_ClearIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_ClearIdentityCredential_result{clearIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("clearIdentityCredential", T.M_REPLY, seqid) $
          write_ClearIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("clearIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_clearMessageBox (seqid, iprot, oprot, handler) = do
  args <- read_ClearMessageBox_args iprot
  (X.catch
    (X.catch
      (do
        Iface.clearMessageBox handler (clearMessageBox_args_channelId args) (clearMessageBox_args_messageBoxId args)
        let res = default_ClearMessageBox_result
        T.writeMessage oprot ("clearMessageBox", T.M_REPLY, seqid) $
          write_ClearMessageBox_result oprot res)
      (\e  -> do
        let res = default_ClearMessageBox_result{clearMessageBox_result_e = P.Just e}
        T.writeMessage oprot ("clearMessageBox", T.M_REPLY, seqid) $
          write_ClearMessageBox_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("clearMessageBox", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_closeProximityMatch (seqid, iprot, oprot, handler) = do
  args <- read_CloseProximityMatch_args iprot
  (X.catch
    (X.catch
      (do
        Iface.closeProximityMatch handler (closeProximityMatch_args_sessionId args)
        let res = default_CloseProximityMatch_result
        T.writeMessage oprot ("closeProximityMatch", T.M_REPLY, seqid) $
          write_CloseProximityMatch_result oprot res)
      (\e  -> do
        let res = default_CloseProximityMatch_result{closeProximityMatch_result_e = P.Just e}
        T.writeMessage oprot ("closeProximityMatch", T.M_REPLY, seqid) $
          write_CloseProximityMatch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("closeProximityMatch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_commitSendMessage (seqid, iprot, oprot, handler) = do
  args <- read_CommitSendMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.commitSendMessage handler (commitSendMessage_args_seq args) (commitSendMessage_args_messageId args) (commitSendMessage_args_receiverMids args)
        let res = default_CommitSendMessage_result{commitSendMessage_result_success = val}
        T.writeMessage oprot ("commitSendMessage", T.M_REPLY, seqid) $
          write_CommitSendMessage_result oprot res)
      (\e  -> do
        let res = default_CommitSendMessage_result{commitSendMessage_result_e = P.Just e}
        T.writeMessage oprot ("commitSendMessage", T.M_REPLY, seqid) $
          write_CommitSendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("commitSendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_commitSendMessages (seqid, iprot, oprot, handler) = do
  args <- read_CommitSendMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.commitSendMessages handler (commitSendMessages_args_seq args) (commitSendMessages_args_messageIds args) (commitSendMessages_args_receiverMids args)
        let res = default_CommitSendMessages_result{commitSendMessages_result_success = val}
        T.writeMessage oprot ("commitSendMessages", T.M_REPLY, seqid) $
          write_CommitSendMessages_result oprot res)
      (\e  -> do
        let res = default_CommitSendMessages_result{commitSendMessages_result_e = P.Just e}
        T.writeMessage oprot ("commitSendMessages", T.M_REPLY, seqid) $
          write_CommitSendMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("commitSendMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_commitUpdateProfile (seqid, iprot, oprot, handler) = do
  args <- read_CommitUpdateProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.commitUpdateProfile handler (commitUpdateProfile_args_seq args) (commitUpdateProfile_args_attrs args) (commitUpdateProfile_args_receiverMids args)
        let res = default_CommitUpdateProfile_result{commitUpdateProfile_result_success = val}
        T.writeMessage oprot ("commitUpdateProfile", T.M_REPLY, seqid) $
          write_CommitUpdateProfile_result oprot res)
      (\e  -> do
        let res = default_CommitUpdateProfile_result{commitUpdateProfile_result_e = P.Just e}
        T.writeMessage oprot ("commitUpdateProfile", T.M_REPLY, seqid) $
          write_CommitUpdateProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("commitUpdateProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_confirmEmail (seqid, iprot, oprot, handler) = do
  args <- read_ConfirmEmail_args iprot
  (X.catch
    (X.catch
      (do
        Iface.confirmEmail handler (confirmEmail_args_verifier args) (confirmEmail_args_pinCode args)
        let res = default_ConfirmEmail_result
        T.writeMessage oprot ("confirmEmail", T.M_REPLY, seqid) $
          write_ConfirmEmail_result oprot res)
      (\e  -> do
        let res = default_ConfirmEmail_result{confirmEmail_result_e = P.Just e}
        T.writeMessage oprot ("confirmEmail", T.M_REPLY, seqid) $
          write_ConfirmEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("confirmEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createGroup (seqid, iprot, oprot, handler) = do
  args <- read_CreateGroup_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createGroup handler (createGroup_args_seq args) (createGroup_args_name args) (createGroup_args_contactIds args)
        let res = default_CreateGroup_result{createGroup_result_success = val}
        T.writeMessage oprot ("createGroup", T.M_REPLY, seqid) $
          write_CreateGroup_result oprot res)
      (\e  -> do
        let res = default_CreateGroup_result{createGroup_result_e = P.Just e}
        T.writeMessage oprot ("createGroup", T.M_REPLY, seqid) $
          write_CreateGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createQrcodeBase64Image (seqid, iprot, oprot, handler) = do
  args <- read_CreateQrcodeBase64Image_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createQrcodeBase64Image handler (createQrcodeBase64Image_args_url args) (createQrcodeBase64Image_args_characterSet args) (createQrcodeBase64Image_args_imageSize args) (createQrcodeBase64Image_args_x args) (createQrcodeBase64Image_args_y args) (createQrcodeBase64Image_args_width args) (createQrcodeBase64Image_args_height args)
        let res = default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_success = val}
        T.writeMessage oprot ("createQrcodeBase64Image", T.M_REPLY, seqid) $
          write_CreateQrcodeBase64Image_result oprot res)
      (\e  -> do
        let res = default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_e = P.Just e}
        T.writeMessage oprot ("createQrcodeBase64Image", T.M_REPLY, seqid) $
          write_CreateQrcodeBase64Image_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createQrcodeBase64Image", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createRoom (seqid, iprot, oprot, handler) = do
  args <- read_CreateRoom_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createRoom handler (createRoom_args_reqSeq args) (createRoom_args_contactIds args)
        let res = default_CreateRoom_result{createRoom_result_success = val}
        T.writeMessage oprot ("createRoom", T.M_REPLY, seqid) $
          write_CreateRoom_result oprot res)
      (\e  -> do
        let res = default_CreateRoom_result{createRoom_result_e = P.Just e}
        T.writeMessage oprot ("createRoom", T.M_REPLY, seqid) $
          write_CreateRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createSession (seqid, iprot, oprot, handler) = do
  args <- read_CreateSession_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createSession handler
        let res = default_CreateSession_result{createSession_result_success = val}
        T.writeMessage oprot ("createSession", T.M_REPLY, seqid) $
          write_CreateSession_result oprot res)
      (\e  -> do
        let res = default_CreateSession_result{createSession_result_e = P.Just e}
        T.writeMessage oprot ("createSession", T.M_REPLY, seqid) $
          write_CreateSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchAnnouncements (seqid, iprot, oprot, handler) = do
  args <- read_FetchAnnouncements_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchAnnouncements handler (fetchAnnouncements_args_lastFetchedIndex args)
        let res = default_FetchAnnouncements_result{fetchAnnouncements_result_success = val}
        T.writeMessage oprot ("fetchAnnouncements", T.M_REPLY, seqid) $
          write_FetchAnnouncements_result oprot res)
      (\e  -> do
        let res = default_FetchAnnouncements_result{fetchAnnouncements_result_e = P.Just e}
        T.writeMessage oprot ("fetchAnnouncements", T.M_REPLY, seqid) $
          write_FetchAnnouncements_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchAnnouncements", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchMessages (seqid, iprot, oprot, handler) = do
  args <- read_FetchMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchMessages handler (fetchMessages_args_localTs args) (fetchMessages_args_count args)
        let res = default_FetchMessages_result{fetchMessages_result_success = val}
        T.writeMessage oprot ("fetchMessages", T.M_REPLY, seqid) $
          write_FetchMessages_result oprot res)
      (\e  -> do
        let res = default_FetchMessages_result{fetchMessages_result_e = P.Just e}
        T.writeMessage oprot ("fetchMessages", T.M_REPLY, seqid) $
          write_FetchMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchOperations (seqid, iprot, oprot, handler) = do
  args <- read_FetchOperations_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchOperations handler (fetchOperations_args_localRev args) (fetchOperations_args_count args)
        let res = default_FetchOperations_result{fetchOperations_result_success = val}
        T.writeMessage oprot ("fetchOperations", T.M_REPLY, seqid) $
          write_FetchOperations_result oprot res)
      (\e  -> do
        let res = default_FetchOperations_result{fetchOperations_result_e = P.Just e}
        T.writeMessage oprot ("fetchOperations", T.M_REPLY, seqid) $
          write_FetchOperations_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchOperations", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchOps (seqid, iprot, oprot, handler) = do
  args <- read_FetchOps_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchOps handler (fetchOps_args_localRev args) (fetchOps_args_count args) (fetchOps_args_globalRev args) (fetchOps_args_individualRev args)
        let res = default_FetchOps_result{fetchOps_result_success = val}
        T.writeMessage oprot ("fetchOps", T.M_REPLY, seqid) $
          write_FetchOps_result oprot res)
      (\e  -> do
        let res = default_FetchOps_result{fetchOps_result_e = P.Just e}
        T.writeMessage oprot ("fetchOps", T.M_REPLY, seqid) $
          write_FetchOps_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchOps", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByEmail (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByEmail_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByEmail handler (findAndAddContactsByEmail_args_reqSeq args) (findAndAddContactsByEmail_args_emails args)
        let res = default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByEmail", T.M_REPLY, seqid) $
          write_FindAndAddContactsByEmail_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByEmail", T.M_REPLY, seqid) $
          write_FindAndAddContactsByEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByMid (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByMid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByMid handler (findAndAddContactsByMid_args_reqSeq args) (findAndAddContactsByMid_args_mid args)
        let res = default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByMid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByMid_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByMid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByMid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByMid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByPhone (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByPhone_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByPhone handler (findAndAddContactsByPhone_args_reqSeq args) (findAndAddContactsByPhone_args_phones args)
        let res = default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByPhone", T.M_REPLY, seqid) $
          write_FindAndAddContactsByPhone_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByPhone", T.M_REPLY, seqid) $
          write_FindAndAddContactsByPhone_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByPhone", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByUserid (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByUserid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByUserid handler (findAndAddContactsByUserid_args_reqSeq args) (findAndAddContactsByUserid_args_userid args)
        let res = default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByUserid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByUserid_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByUserid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUserid (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUserid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUserid handler (findContactByUserid_args_userid args)
        let res = default_FindContactByUserid_result{findContactByUserid_result_success = val}
        T.writeMessage oprot ("findContactByUserid", T.M_REPLY, seqid) $
          write_FindContactByUserid_result oprot res)
      (\e  -> do
        let res = default_FindContactByUserid_result{findContactByUserid_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUserid", T.M_REPLY, seqid) $
          write_FindContactByUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUserTicket handler (findContactByUserTicket_args_ticketId args)
        let res = default_FindContactByUserTicket_result{findContactByUserTicket_result_success = val}
        T.writeMessage oprot ("findContactByUserTicket", T.M_REPLY, seqid) $
          write_FindContactByUserTicket_result oprot res)
      (\e  -> do
        let res = default_FindContactByUserTicket_result{findContactByUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUserTicket", T.M_REPLY, seqid) $
          write_FindContactByUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactsByEmail (seqid, iprot, oprot, handler) = do
  args <- read_FindContactsByEmail_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactsByEmail handler (findContactsByEmail_args_emails args)
        let res = default_FindContactsByEmail_result{findContactsByEmail_result_success = val}
        T.writeMessage oprot ("findContactsByEmail", T.M_REPLY, seqid) $
          write_FindContactsByEmail_result oprot res)
      (\e  -> do
        let res = default_FindContactsByEmail_result{findContactsByEmail_result_e = P.Just e}
        T.writeMessage oprot ("findContactsByEmail", T.M_REPLY, seqid) $
          write_FindContactsByEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactsByEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactsByPhone (seqid, iprot, oprot, handler) = do
  args <- read_FindContactsByPhone_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactsByPhone handler (findContactsByPhone_args_phones args)
        let res = default_FindContactsByPhone_result{findContactsByPhone_result_success = val}
        T.writeMessage oprot ("findContactsByPhone", T.M_REPLY, seqid) $
          write_FindContactsByPhone_result oprot res)
      (\e  -> do
        let res = default_FindContactsByPhone_result{findContactsByPhone_result_e = P.Just e}
        T.writeMessage oprot ("findContactsByPhone", T.M_REPLY, seqid) $
          write_FindContactsByPhone_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactsByPhone", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findSnsIdUserStatus (seqid, iprot, oprot, handler) = do
  args <- read_FindSnsIdUserStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findSnsIdUserStatus handler (findSnsIdUserStatus_args_snsIdType args) (findSnsIdUserStatus_args_snsAccessToken args) (findSnsIdUserStatus_args_udidHash args)
        let res = default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_success = val}
        T.writeMessage oprot ("findSnsIdUserStatus", T.M_REPLY, seqid) $
          write_FindSnsIdUserStatus_result oprot res)
      (\e  -> do
        let res = default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_e = P.Just e}
        T.writeMessage oprot ("findSnsIdUserStatus", T.M_REPLY, seqid) $
          write_FindSnsIdUserStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findSnsIdUserStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_finishUpdateVerification (seqid, iprot, oprot, handler) = do
  args <- read_FinishUpdateVerification_args iprot
  (X.catch
    (X.catch
      (do
        Iface.finishUpdateVerification handler (finishUpdateVerification_args_sessionId args)
        let res = default_FinishUpdateVerification_result
        T.writeMessage oprot ("finishUpdateVerification", T.M_REPLY, seqid) $
          write_FinishUpdateVerification_result oprot res)
      (\e  -> do
        let res = default_FinishUpdateVerification_result{finishUpdateVerification_result_e = P.Just e}
        T.writeMessage oprot ("finishUpdateVerification", T.M_REPLY, seqid) $
          write_FinishUpdateVerification_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("finishUpdateVerification", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_generateUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_GenerateUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.generateUserTicket handler (generateUserTicket_args_expirationTime args) (generateUserTicket_args_maxUseCount args)
        let res = default_GenerateUserTicket_result{generateUserTicket_result_success = val}
        T.writeMessage oprot ("generateUserTicket", T.M_REPLY, seqid) $
          write_GenerateUserTicket_result oprot res)
      (\e  -> do
        let res = default_GenerateUserTicket_result{generateUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("generateUserTicket", T.M_REPLY, seqid) $
          write_GenerateUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("generateUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAcceptedProximityMatches (seqid, iprot, oprot, handler) = do
  args <- read_GetAcceptedProximityMatches_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAcceptedProximityMatches handler (getAcceptedProximityMatches_args_sessionId args)
        let res = default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_success = val}
        T.writeMessage oprot ("getAcceptedProximityMatches", T.M_REPLY, seqid) $
          write_GetAcceptedProximityMatches_result oprot res)
      (\e  -> do
        let res = default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_e = P.Just e}
        T.writeMessage oprot ("getAcceptedProximityMatches", T.M_REPLY, seqid) $
          write_GetAcceptedProximityMatches_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAcceptedProximityMatches", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getActiveBuddySubscriberIds (seqid, iprot, oprot, handler) = do
  args <- read_GetActiveBuddySubscriberIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getActiveBuddySubscriberIds handler
        let res = default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_success = val}
        T.writeMessage oprot ("getActiveBuddySubscriberIds", T.M_REPLY, seqid) $
          write_GetActiveBuddySubscriberIds_result oprot res)
      (\e  -> do
        let res = default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_e = P.Just e}
        T.writeMessage oprot ("getActiveBuddySubscriberIds", T.M_REPLY, seqid) $
          write_GetActiveBuddySubscriberIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getActiveBuddySubscriberIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllContactIds (seqid, iprot, oprot, handler) = do
  args <- read_GetAllContactIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllContactIds handler
        let res = default_GetAllContactIds_result{getAllContactIds_result_success = val}
        T.writeMessage oprot ("getAllContactIds", T.M_REPLY, seqid) $
          write_GetAllContactIds_result oprot res)
      (\e  -> do
        let res = default_GetAllContactIds_result{getAllContactIds_result_e = P.Just e}
        T.writeMessage oprot ("getAllContactIds", T.M_REPLY, seqid) $
          write_GetAllContactIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllContactIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAuthQrcode (seqid, iprot, oprot, handler) = do
  args <- read_GetAuthQrcode_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAuthQrcode handler (getAuthQrcode_args_keepLoggedIn args) (getAuthQrcode_args_systemName args)
        let res = default_GetAuthQrcode_result{getAuthQrcode_result_success = val}
        T.writeMessage oprot ("getAuthQrcode", T.M_REPLY, seqid) $
          write_GetAuthQrcode_result oprot res)
      (\e  -> do
        let res = default_GetAuthQrcode_result{getAuthQrcode_result_e = P.Just e}
        T.writeMessage oprot ("getAuthQrcode", T.M_REPLY, seqid) $
          write_GetAuthQrcode_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAuthQrcode", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBlockedContactIds (seqid, iprot, oprot, handler) = do
  args <- read_GetBlockedContactIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBlockedContactIds handler
        let res = default_GetBlockedContactIds_result{getBlockedContactIds_result_success = val}
        T.writeMessage oprot ("getBlockedContactIds", T.M_REPLY, seqid) $
          write_GetBlockedContactIds_result oprot res)
      (\e  -> do
        let res = default_GetBlockedContactIds_result{getBlockedContactIds_result_e = P.Just e}
        T.writeMessage oprot ("getBlockedContactIds", T.M_REPLY, seqid) $
          write_GetBlockedContactIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBlockedContactIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBlockedContactIdsByRange (seqid, iprot, oprot, handler) = do
  args <- read_GetBlockedContactIdsByRange_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBlockedContactIdsByRange handler (getBlockedContactIdsByRange_args_start args) (getBlockedContactIdsByRange_args_count args)
        let res = default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_success = val}
        T.writeMessage oprot ("getBlockedContactIdsByRange", T.M_REPLY, seqid) $
          write_GetBlockedContactIdsByRange_result oprot res)
      (\e  -> do
        let res = default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_e = P.Just e}
        T.writeMessage oprot ("getBlockedContactIdsByRange", T.M_REPLY, seqid) $
          write_GetBlockedContactIdsByRange_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBlockedContactIdsByRange", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBlockedRecommendationIds (seqid, iprot, oprot, handler) = do
  args <- read_GetBlockedRecommendationIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBlockedRecommendationIds handler
        let res = default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_success = val}
        T.writeMessage oprot ("getBlockedRecommendationIds", T.M_REPLY, seqid) $
          write_GetBlockedRecommendationIds_result oprot res)
      (\e  -> do
        let res = default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_e = P.Just e}
        T.writeMessage oprot ("getBlockedRecommendationIds", T.M_REPLY, seqid) $
          write_GetBlockedRecommendationIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBlockedRecommendationIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBuddyBlockerIds (seqid, iprot, oprot, handler) = do
  args <- read_GetBuddyBlockerIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBuddyBlockerIds handler
        let res = default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_success = val}
        T.writeMessage oprot ("getBuddyBlockerIds", T.M_REPLY, seqid) $
          write_GetBuddyBlockerIds_result oprot res)
      (\e  -> do
        let res = default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_e = P.Just e}
        T.writeMessage oprot ("getBuddyBlockerIds", T.M_REPLY, seqid) $
          write_GetBuddyBlockerIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBuddyBlockerIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBuddyLocation (seqid, iprot, oprot, handler) = do
  args <- read_GetBuddyLocation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBuddyLocation handler (getBuddyLocation_args_mid args) (getBuddyLocation_args_index args)
        let res = default_GetBuddyLocation_result{getBuddyLocation_result_success = val}
        T.writeMessage oprot ("getBuddyLocation", T.M_REPLY, seqid) $
          write_GetBuddyLocation_result oprot res)
      (\e  -> do
        let res = default_GetBuddyLocation_result{getBuddyLocation_result_e = P.Just e}
        T.writeMessage oprot ("getBuddyLocation", T.M_REPLY, seqid) $
          write_GetBuddyLocation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBuddyLocation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactContactsModifiedSince (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactContactsModifiedSince_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactContactsModifiedSince handler (getCompactContactsModifiedSince_args_timestamp args)
        let res = default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_success = val}
        T.writeMessage oprot ("getCompactContactsModifiedSince", T.M_REPLY, seqid) $
          write_GetCompactContactsModifiedSince_result oprot res)
      (\e  -> do
        let res = default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_e = P.Just e}
        T.writeMessage oprot ("getCompactContactsModifiedSince", T.M_REPLY, seqid) $
          write_GetCompactContactsModifiedSince_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactContactsModifiedSince", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactGroup (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactGroup_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactGroup handler (getCompactGroup_args_groupId args)
        let res = default_GetCompactGroup_result{getCompactGroup_result_success = val}
        T.writeMessage oprot ("getCompactGroup", T.M_REPLY, seqid) $
          write_GetCompactGroup_result oprot res)
      (\e  -> do
        let res = default_GetCompactGroup_result{getCompactGroup_result_e = P.Just e}
        T.writeMessage oprot ("getCompactGroup", T.M_REPLY, seqid) $
          write_GetCompactGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactRoom (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactRoom_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactRoom handler (getCompactRoom_args_roomId args)
        let res = default_GetCompactRoom_result{getCompactRoom_result_success = val}
        T.writeMessage oprot ("getCompactRoom", T.M_REPLY, seqid) $
          write_GetCompactRoom_result oprot res)
      (\e  -> do
        let res = default_GetCompactRoom_result{getCompactRoom_result_e = P.Just e}
        T.writeMessage oprot ("getCompactRoom", T.M_REPLY, seqid) $
          write_GetCompactRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContact (seqid, iprot, oprot, handler) = do
  args <- read_GetContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContact handler (getContact_args_id args)
        let res = default_GetContact_result{getContact_result_success = val}
        T.writeMessage oprot ("getContact", T.M_REPLY, seqid) $
          write_GetContact_result oprot res)
      (\e  -> do
        let res = default_GetContact_result{getContact_result_e = P.Just e}
        T.writeMessage oprot ("getContact", T.M_REPLY, seqid) $
          write_GetContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContacts handler (getContacts_args_ids args)
        let res = default_GetContacts_result{getContacts_result_success = val}
        T.writeMessage oprot ("getContacts", T.M_REPLY, seqid) $
          write_GetContacts_result oprot res)
      (\e  -> do
        let res = default_GetContacts_result{getContacts_result_e = P.Just e}
        T.writeMessage oprot ("getContacts", T.M_REPLY, seqid) $
          write_GetContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCountryWithRequestIp (seqid, iprot, oprot, handler) = do
  args <- read_GetCountryWithRequestIp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCountryWithRequestIp handler
        let res = default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_success = val}
        T.writeMessage oprot ("getCountryWithRequestIp", T.M_REPLY, seqid) $
          write_GetCountryWithRequestIp_result oprot res)
      (\e  -> do
        let res = default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_e = P.Just e}
        T.writeMessage oprot ("getCountryWithRequestIp", T.M_REPLY, seqid) $
          write_GetCountryWithRequestIp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCountryWithRequestIp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteMids (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteMids handler
        let res = default_GetFavoriteMids_result{getFavoriteMids_result_success = val}
        T.writeMessage oprot ("getFavoriteMids", T.M_REPLY, seqid) $
          write_GetFavoriteMids_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteMids_result{getFavoriteMids_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteMids", T.M_REPLY, seqid) $
          write_GetFavoriteMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroup (seqid, iprot, oprot, handler) = do
  args <- read_GetGroup_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroup handler (getGroup_args_groupId args)
        let res = default_GetGroup_result{getGroup_result_success = val}
        T.writeMessage oprot ("getGroup", T.M_REPLY, seqid) $
          write_GetGroup_result oprot res)
      (\e  -> do
        let res = default_GetGroup_result{getGroup_result_e = P.Just e}
        T.writeMessage oprot ("getGroup", T.M_REPLY, seqid) $
          write_GetGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupIdsInvited (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupIdsInvited_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupIdsInvited handler
        let res = default_GetGroupIdsInvited_result{getGroupIdsInvited_result_success = val}
        T.writeMessage oprot ("getGroupIdsInvited", T.M_REPLY, seqid) $
          write_GetGroupIdsInvited_result oprot res)
      (\e  -> do
        let res = default_GetGroupIdsInvited_result{getGroupIdsInvited_result_e = P.Just e}
        T.writeMessage oprot ("getGroupIdsInvited", T.M_REPLY, seqid) $
          write_GetGroupIdsInvited_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupIdsInvited", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupIdsJoined (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupIdsJoined_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupIdsJoined handler
        let res = default_GetGroupIdsJoined_result{getGroupIdsJoined_result_success = val}
        T.writeMessage oprot ("getGroupIdsJoined", T.M_REPLY, seqid) $
          write_GetGroupIdsJoined_result oprot res)
      (\e  -> do
        let res = default_GetGroupIdsJoined_result{getGroupIdsJoined_result_e = P.Just e}
        T.writeMessage oprot ("getGroupIdsJoined", T.M_REPLY, seqid) $
          write_GetGroupIdsJoined_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupIdsJoined", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroups (seqid, iprot, oprot, handler) = do
  args <- read_GetGroups_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroups handler (getGroups_args_groupIds args)
        let res = default_GetGroups_result{getGroups_result_success = val}
        T.writeMessage oprot ("getGroups", T.M_REPLY, seqid) $
          write_GetGroups_result oprot res)
      (\e  -> do
        let res = default_GetGroups_result{getGroups_result_e = P.Just e}
        T.writeMessage oprot ("getGroups", T.M_REPLY, seqid) $
          write_GetGroups_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroups", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getHiddenContactMids (seqid, iprot, oprot, handler) = do
  args <- read_GetHiddenContactMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getHiddenContactMids handler
        let res = default_GetHiddenContactMids_result{getHiddenContactMids_result_success = val}
        T.writeMessage oprot ("getHiddenContactMids", T.M_REPLY, seqid) $
          write_GetHiddenContactMids_result oprot res)
      (\e  -> do
        let res = default_GetHiddenContactMids_result{getHiddenContactMids_result_e = P.Just e}
        T.writeMessage oprot ("getHiddenContactMids", T.M_REPLY, seqid) $
          write_GetHiddenContactMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getHiddenContactMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getIdentityIdentifier (seqid, iprot, oprot, handler) = do
  args <- read_GetIdentityIdentifier_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getIdentityIdentifier handler
        let res = default_GetIdentityIdentifier_result{getIdentityIdentifier_result_success = val}
        T.writeMessage oprot ("getIdentityIdentifier", T.M_REPLY, seqid) $
          write_GetIdentityIdentifier_result oprot res)
      (\e  -> do
        let res = default_GetIdentityIdentifier_result{getIdentityIdentifier_result_e = P.Just e}
        T.writeMessage oprot ("getIdentityIdentifier", T.M_REPLY, seqid) $
          write_GetIdentityIdentifier_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getIdentityIdentifier", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLastAnnouncementIndex (seqid, iprot, oprot, handler) = do
  args <- read_GetLastAnnouncementIndex_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getLastAnnouncementIndex handler
        let res = default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_success = val}
        T.writeMessage oprot ("getLastAnnouncementIndex", T.M_REPLY, seqid) $
          write_GetLastAnnouncementIndex_result oprot res)
      (\e  -> do
        let res = default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_e = P.Just e}
        T.writeMessage oprot ("getLastAnnouncementIndex", T.M_REPLY, seqid) $
          write_GetLastAnnouncementIndex_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLastAnnouncementIndex", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLastOpRevision (seqid, iprot, oprot, handler) = do
  args <- read_GetLastOpRevision_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getLastOpRevision handler
        let res = default_GetLastOpRevision_result{getLastOpRevision_result_success = val}
        T.writeMessage oprot ("getLastOpRevision", T.M_REPLY, seqid) $
          write_GetLastOpRevision_result oprot res)
      (\e  -> do
        let res = default_GetLastOpRevision_result{getLastOpRevision_result_e = P.Just e}
        T.writeMessage oprot ("getLastOpRevision", T.M_REPLY, seqid) $
          write_GetLastOpRevision_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLastOpRevision", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBox (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBox_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBox handler (getMessageBox_args_channelId args) (getMessageBox_args_messageBoxId args) (getMessageBox_args_lastMessagesCount args)
        let res = default_GetMessageBox_result{getMessageBox_result_success = val}
        T.writeMessage oprot ("getMessageBox", T.M_REPLY, seqid) $
          write_GetMessageBox_result oprot res)
      (\e  -> do
        let res = default_GetMessageBox_result{getMessageBox_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBox", T.M_REPLY, seqid) $
          write_GetMessageBox_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBox", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxCompactWrapUp (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxCompactWrapUp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxCompactWrapUp handler (getMessageBoxCompactWrapUp_args_mid args)
        let res = default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_success = val}
        T.writeMessage oprot ("getMessageBoxCompactWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUp_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxCompactWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxCompactWrapUp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxCompactWrapUpList (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxCompactWrapUpList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxCompactWrapUpList handler (getMessageBoxCompactWrapUpList_args_start args) (getMessageBoxCompactWrapUpList_args_messageBoxCount args)
        let res = default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_success = val}
        T.writeMessage oprot ("getMessageBoxCompactWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUpList_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxCompactWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUpList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxCompactWrapUpList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxList (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxList handler (getMessageBoxList_args_channelId args) (getMessageBoxList_args_lastMessagesCount args)
        let res = default_GetMessageBoxList_result{getMessageBoxList_result_success = val}
        T.writeMessage oprot ("getMessageBoxList", T.M_REPLY, seqid) $
          write_GetMessageBoxList_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxList_result{getMessageBoxList_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxList", T.M_REPLY, seqid) $
          write_GetMessageBoxList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxListByStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxListByStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxListByStatus handler (getMessageBoxListByStatus_args_channelId args) (getMessageBoxListByStatus_args_lastMessagesCount args) (getMessageBoxListByStatus_args_status args)
        let res = default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_success = val}
        T.writeMessage oprot ("getMessageBoxListByStatus", T.M_REPLY, seqid) $
          write_GetMessageBoxListByStatus_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxListByStatus", T.M_REPLY, seqid) $
          write_GetMessageBoxListByStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxListByStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxWrapUp (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxWrapUp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxWrapUp handler (getMessageBoxWrapUp_args_mid args)
        let res = default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_success = val}
        T.writeMessage oprot ("getMessageBoxWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUp_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxWrapUp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxWrapUpList (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxWrapUpList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxWrapUpList handler (getMessageBoxWrapUpList_args_start args) (getMessageBoxWrapUpList_args_messageBoxCount args)
        let res = default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_success = val}
        T.writeMessage oprot ("getMessageBoxWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUpList_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUpList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxWrapUpList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessagesBySequenceNumber (seqid, iprot, oprot, handler) = do
  args <- read_GetMessagesBySequenceNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessagesBySequenceNumber handler (getMessagesBySequenceNumber_args_channelId args) (getMessagesBySequenceNumber_args_messageBoxId args) (getMessagesBySequenceNumber_args_startSeq args) (getMessagesBySequenceNumber_args_endSeq args)
        let res = default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_success = val}
        T.writeMessage oprot ("getMessagesBySequenceNumber", T.M_REPLY, seqid) $
          write_GetMessagesBySequenceNumber_result oprot res)
      (\e  -> do
        let res = default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_e = P.Just e}
        T.writeMessage oprot ("getMessagesBySequenceNumber", T.M_REPLY, seqid) $
          write_GetMessagesBySequenceNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessagesBySequenceNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNextMessages (seqid, iprot, oprot, handler) = do
  args <- read_GetNextMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNextMessages handler (getNextMessages_args_messageBoxId args) (getNextMessages_args_startSeq args) (getNextMessages_args_messagesCount args)
        let res = default_GetNextMessages_result{getNextMessages_result_success = val}
        T.writeMessage oprot ("getNextMessages", T.M_REPLY, seqid) $
          write_GetNextMessages_result oprot res)
      (\e  -> do
        let res = default_GetNextMessages_result{getNextMessages_result_e = P.Just e}
        T.writeMessage oprot ("getNextMessages", T.M_REPLY, seqid) $
          write_GetNextMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNextMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNotificationPolicy (seqid, iprot, oprot, handler) = do
  args <- read_GetNotificationPolicy_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNotificationPolicy handler (getNotificationPolicy_args_carrier args)
        let res = default_GetNotificationPolicy_result{getNotificationPolicy_result_success = val}
        T.writeMessage oprot ("getNotificationPolicy", T.M_REPLY, seqid) $
          write_GetNotificationPolicy_result oprot res)
      (\e  -> do
        let res = default_GetNotificationPolicy_result{getNotificationPolicy_result_e = P.Just e}
        T.writeMessage oprot ("getNotificationPolicy", T.M_REPLY, seqid) $
          write_GetNotificationPolicy_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNotificationPolicy", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPreviousMessages (seqid, iprot, oprot, handler) = do
  args <- read_GetPreviousMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPreviousMessages handler (getPreviousMessages_args_messageBoxId args) (getPreviousMessages_args_endSeq args) (getPreviousMessages_args_messagesCount args)
        let res = default_GetPreviousMessages_result{getPreviousMessages_result_success = val}
        T.writeMessage oprot ("getPreviousMessages", T.M_REPLY, seqid) $
          write_GetPreviousMessages_result oprot res)
      (\e  -> do
        let res = default_GetPreviousMessages_result{getPreviousMessages_result_e = P.Just e}
        T.writeMessage oprot ("getPreviousMessages", T.M_REPLY, seqid) $
          write_GetPreviousMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPreviousMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProfile handler
        let res = default_GetProfile_result{getProfile_result_success = val}
        T.writeMessage oprot ("getProfile", T.M_REPLY, seqid) $
          write_GetProfile_result oprot res)
      (\e  -> do
        let res = default_GetProfile_result{getProfile_result_e = P.Just e}
        T.writeMessage oprot ("getProfile", T.M_REPLY, seqid) $
          write_GetProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProximityMatchCandidateList (seqid, iprot, oprot, handler) = do
  args <- read_GetProximityMatchCandidateList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProximityMatchCandidateList handler (getProximityMatchCandidateList_args_sessionId args)
        let res = default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_success = val}
        T.writeMessage oprot ("getProximityMatchCandidateList", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidateList_result oprot res)
      (\e  -> do
        let res = default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_e = P.Just e}
        T.writeMessage oprot ("getProximityMatchCandidateList", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidateList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProximityMatchCandidateList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProximityMatchCandidates (seqid, iprot, oprot, handler) = do
  args <- read_GetProximityMatchCandidates_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProximityMatchCandidates handler (getProximityMatchCandidates_args_sessionId args)
        let res = default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_success = val}
        T.writeMessage oprot ("getProximityMatchCandidates", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidates_result oprot res)
      (\e  -> do
        let res = default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_e = P.Just e}
        T.writeMessage oprot ("getProximityMatchCandidates", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidates_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProximityMatchCandidates", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRecentMessages (seqid, iprot, oprot, handler) = do
  args <- read_GetRecentMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRecentMessages handler (getRecentMessages_args_messageBoxId args) (getRecentMessages_args_messagesCount args)
        let res = default_GetRecentMessages_result{getRecentMessages_result_success = val}
        T.writeMessage oprot ("getRecentMessages", T.M_REPLY, seqid) $
          write_GetRecentMessages_result oprot res)
      (\e  -> do
        let res = default_GetRecentMessages_result{getRecentMessages_result_e = P.Just e}
        T.writeMessage oprot ("getRecentMessages", T.M_REPLY, seqid) $
          write_GetRecentMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRecentMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRecommendationIds (seqid, iprot, oprot, handler) = do
  args <- read_GetRecommendationIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRecommendationIds handler
        let res = default_GetRecommendationIds_result{getRecommendationIds_result_success = val}
        T.writeMessage oprot ("getRecommendationIds", T.M_REPLY, seqid) $
          write_GetRecommendationIds_result oprot res)
      (\e  -> do
        let res = default_GetRecommendationIds_result{getRecommendationIds_result_e = P.Just e}
        T.writeMessage oprot ("getRecommendationIds", T.M_REPLY, seqid) $
          write_GetRecommendationIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRecommendationIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRoom (seqid, iprot, oprot, handler) = do
  args <- read_GetRoom_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRoom handler (getRoom_args_roomId args)
        let res = default_GetRoom_result{getRoom_result_success = val}
        T.writeMessage oprot ("getRoom", T.M_REPLY, seqid) $
          write_GetRoom_result oprot res)
      (\e  -> do
        let res = default_GetRoom_result{getRoom_result_e = P.Just e}
        T.writeMessage oprot ("getRoom", T.M_REPLY, seqid) $
          write_GetRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRSAKeyInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetRSAKeyInfo_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRSAKeyInfo handler (getRSAKeyInfo_args_provider args)
        let res = default_GetRSAKeyInfo_result{getRSAKeyInfo_result_success = val}
        T.writeMessage oprot ("getRSAKeyInfo", T.M_REPLY, seqid) $
          write_GetRSAKeyInfo_result oprot res)
      (\e  -> do
        let res = default_GetRSAKeyInfo_result{getRSAKeyInfo_result_e = P.Just e}
        T.writeMessage oprot ("getRSAKeyInfo", T.M_REPLY, seqid) $
          write_GetRSAKeyInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRSAKeyInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getServerTime (seqid, iprot, oprot, handler) = do
  args <- read_GetServerTime_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getServerTime handler
        let res = default_GetServerTime_result{getServerTime_result_success = val}
        T.writeMessage oprot ("getServerTime", T.M_REPLY, seqid) $
          write_GetServerTime_result oprot res)
      (\e  -> do
        let res = default_GetServerTime_result{getServerTime_result_e = P.Just e}
        T.writeMessage oprot ("getServerTime", T.M_REPLY, seqid) $
          write_GetServerTime_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getServerTime", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSessions (seqid, iprot, oprot, handler) = do
  args <- read_GetSessions_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSessions handler
        let res = default_GetSessions_result{getSessions_result_success = val}
        T.writeMessage oprot ("getSessions", T.M_REPLY, seqid) $
          write_GetSessions_result oprot res)
      (\e  -> do
        let res = default_GetSessions_result{getSessions_result_e = P.Just e}
        T.writeMessage oprot ("getSessions", T.M_REPLY, seqid) $
          write_GetSessions_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSessions", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSettings (seqid, iprot, oprot, handler) = do
  args <- read_GetSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSettings handler
        let res = default_GetSettings_result{getSettings_result_success = val}
        T.writeMessage oprot ("getSettings", T.M_REPLY, seqid) $
          write_GetSettings_result oprot res)
      (\e  -> do
        let res = default_GetSettings_result{getSettings_result_e = P.Just e}
        T.writeMessage oprot ("getSettings", T.M_REPLY, seqid) $
          write_GetSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSettingsAttributes (seqid, iprot, oprot, handler) = do
  args <- read_GetSettingsAttributes_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSettingsAttributes handler (getSettingsAttributes_args_attrBitset args)
        let res = default_GetSettingsAttributes_result{getSettingsAttributes_result_success = val}
        T.writeMessage oprot ("getSettingsAttributes", T.M_REPLY, seqid) $
          write_GetSettingsAttributes_result oprot res)
      (\e  -> do
        let res = default_GetSettingsAttributes_result{getSettingsAttributes_result_e = P.Just e}
        T.writeMessage oprot ("getSettingsAttributes", T.M_REPLY, seqid) $
          write_GetSettingsAttributes_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSettingsAttributes", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSystemConfiguration (seqid, iprot, oprot, handler) = do
  args <- read_GetSystemConfiguration_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSystemConfiguration handler
        let res = default_GetSystemConfiguration_result{getSystemConfiguration_result_success = val}
        T.writeMessage oprot ("getSystemConfiguration", T.M_REPLY, seqid) $
          write_GetSystemConfiguration_result oprot res)
      (\e  -> do
        let res = default_GetSystemConfiguration_result{getSystemConfiguration_result_e = P.Just e}
        T.writeMessage oprot ("getSystemConfiguration", T.M_REPLY, seqid) $
          write_GetSystemConfiguration_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSystemConfiguration", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_GetUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserTicket handler
        let res = default_GetUserTicket_result{getUserTicket_result_success = val}
        T.writeMessage oprot ("getUserTicket", T.M_REPLY, seqid) $
          write_GetUserTicket_result oprot res)
      (\e  -> do
        let res = default_GetUserTicket_result{getUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("getUserTicket", T.M_REPLY, seqid) $
          write_GetUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getWapInvitation (seqid, iprot, oprot, handler) = do
  args <- read_GetWapInvitation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getWapInvitation handler (getWapInvitation_args_invitationHash args)
        let res = default_GetWapInvitation_result{getWapInvitation_result_success = val}
        T.writeMessage oprot ("getWapInvitation", T.M_REPLY, seqid) $
          write_GetWapInvitation_result oprot res)
      (\e  -> do
        let res = default_GetWapInvitation_result{getWapInvitation_result_e = P.Just e}
        T.writeMessage oprot ("getWapInvitation", T.M_REPLY, seqid) $
          write_GetWapInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getWapInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_invalidateUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_InvalidateUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        Iface.invalidateUserTicket handler
        let res = default_InvalidateUserTicket_result
        T.writeMessage oprot ("invalidateUserTicket", T.M_REPLY, seqid) $
          write_InvalidateUserTicket_result oprot res)
      (\e  -> do
        let res = default_InvalidateUserTicket_result{invalidateUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("invalidateUserTicket", T.M_REPLY, seqid) $
          write_InvalidateUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("invalidateUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteFriendsBySms (seqid, iprot, oprot, handler) = do
  args <- read_InviteFriendsBySms_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteFriendsBySms handler (inviteFriendsBySms_args_phoneNumberList args)
        let res = default_InviteFriendsBySms_result
        T.writeMessage oprot ("inviteFriendsBySms", T.M_REPLY, seqid) $
          write_InviteFriendsBySms_result oprot res)
      (\e  -> do
        let res = default_InviteFriendsBySms_result{inviteFriendsBySms_result_e = P.Just e}
        T.writeMessage oprot ("inviteFriendsBySms", T.M_REPLY, seqid) $
          write_InviteFriendsBySms_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteFriendsBySms", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteIntoGroup (seqid, iprot, oprot, handler) = do
  args <- read_InviteIntoGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteIntoGroup handler (inviteIntoGroup_args_reqSeq args) (inviteIntoGroup_args_groupId args) (inviteIntoGroup_args_contactIds args)
        let res = default_InviteIntoGroup_result
        T.writeMessage oprot ("inviteIntoGroup", T.M_REPLY, seqid) $
          write_InviteIntoGroup_result oprot res)
      (\e  -> do
        let res = default_InviteIntoGroup_result{inviteIntoGroup_result_e = P.Just e}
        T.writeMessage oprot ("inviteIntoGroup", T.M_REPLY, seqid) $
          write_InviteIntoGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteIntoGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteIntoRoom (seqid, iprot, oprot, handler) = do
  args <- read_InviteIntoRoom_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteIntoRoom handler (inviteIntoRoom_args_reqSeq args) (inviteIntoRoom_args_roomId args) (inviteIntoRoom_args_contactIds args)
        let res = default_InviteIntoRoom_result
        T.writeMessage oprot ("inviteIntoRoom", T.M_REPLY, seqid) $
          write_InviteIntoRoom_result oprot res)
      (\e  -> do
        let res = default_InviteIntoRoom_result{inviteIntoRoom_result_e = P.Just e}
        T.writeMessage oprot ("inviteIntoRoom", T.M_REPLY, seqid) $
          write_InviteIntoRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteIntoRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteViaEmail (seqid, iprot, oprot, handler) = do
  args <- read_InviteViaEmail_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteViaEmail handler (inviteViaEmail_args_reqSeq args) (inviteViaEmail_args_email args) (inviteViaEmail_args_name args)
        let res = default_InviteViaEmail_result
        T.writeMessage oprot ("inviteViaEmail", T.M_REPLY, seqid) $
          write_InviteViaEmail_result oprot res)
      (\e  -> do
        let res = default_InviteViaEmail_result{inviteViaEmail_result_e = P.Just e}
        T.writeMessage oprot ("inviteViaEmail", T.M_REPLY, seqid) $
          write_InviteViaEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteViaEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isIdentityIdentifierAvailable (seqid, iprot, oprot, handler) = do
  args <- read_IsIdentityIdentifierAvailable_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isIdentityIdentifierAvailable handler (isIdentityIdentifierAvailable_args_provider args) (isIdentityIdentifierAvailable_args_identifier args)
        let res = default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_success = val}
        T.writeMessage oprot ("isIdentityIdentifierAvailable", T.M_REPLY, seqid) $
          write_IsIdentityIdentifierAvailable_result oprot res)
      (\e  -> do
        let res = default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_e = P.Just e}
        T.writeMessage oprot ("isIdentityIdentifierAvailable", T.M_REPLY, seqid) $
          write_IsIdentityIdentifierAvailable_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isIdentityIdentifierAvailable", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isUseridAvailable (seqid, iprot, oprot, handler) = do
  args <- read_IsUseridAvailable_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isUseridAvailable handler (isUseridAvailable_args_userid args)
        let res = default_IsUseridAvailable_result{isUseridAvailable_result_success = val}
        T.writeMessage oprot ("isUseridAvailable", T.M_REPLY, seqid) $
          write_IsUseridAvailable_result oprot res)
      (\e  -> do
        let res = default_IsUseridAvailable_result{isUseridAvailable_result_e = P.Just e}
        T.writeMessage oprot ("isUseridAvailable", T.M_REPLY, seqid) $
          write_IsUseridAvailable_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isUseridAvailable", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_kickoutFromGroup (seqid, iprot, oprot, handler) = do
  args <- read_KickoutFromGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.kickoutFromGroup handler (kickoutFromGroup_args_reqSeq args) (kickoutFromGroup_args_groupId args) (kickoutFromGroup_args_contactIds args)
        let res = default_KickoutFromGroup_result
        T.writeMessage oprot ("kickoutFromGroup", T.M_REPLY, seqid) $
          write_KickoutFromGroup_result oprot res)
      (\e  -> do
        let res = default_KickoutFromGroup_result{kickoutFromGroup_result_e = P.Just e}
        T.writeMessage oprot ("kickoutFromGroup", T.M_REPLY, seqid) $
          write_KickoutFromGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("kickoutFromGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_leaveGroup (seqid, iprot, oprot, handler) = do
  args <- read_LeaveGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.leaveGroup handler (leaveGroup_args_reqSeq args) (leaveGroup_args_groupId args)
        let res = default_LeaveGroup_result
        T.writeMessage oprot ("leaveGroup", T.M_REPLY, seqid) $
          write_LeaveGroup_result oprot res)
      (\e  -> do
        let res = default_LeaveGroup_result{leaveGroup_result_e = P.Just e}
        T.writeMessage oprot ("leaveGroup", T.M_REPLY, seqid) $
          write_LeaveGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("leaveGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_leaveRoom (seqid, iprot, oprot, handler) = do
  args <- read_LeaveRoom_args iprot
  (X.catch
    (X.catch
      (do
        Iface.leaveRoom handler (leaveRoom_args_reqSeq args) (leaveRoom_args_roomId args)
        let res = default_LeaveRoom_result
        T.writeMessage oprot ("leaveRoom", T.M_REPLY, seqid) $
          write_LeaveRoom_result oprot res)
      (\e  -> do
        let res = default_LeaveRoom_result{leaveRoom_result_e = P.Just e}
        T.writeMessage oprot ("leaveRoom", T.M_REPLY, seqid) $
          write_LeaveRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("leaveRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithIdentityCredential handler (loginWithIdentityCredential_args_identityProvider args) (loginWithIdentityCredential_args_identifier args) (loginWithIdentityCredential_args_password args) (loginWithIdentityCredential_args_keepLoggedIn args) (loginWithIdentityCredential_args_accessLocation args) (loginWithIdentityCredential_args_systemName args) (loginWithIdentityCredential_args_certificate args)
        let res = default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_success = val}
        T.writeMessage oprot ("loginWithIdentityCredential", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("loginWithIdentityCredential", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithIdentityCredentialForCertificate (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithIdentityCredentialForCertificate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithIdentityCredentialForCertificate handler (loginWithIdentityCredentialForCertificate_args_identityProvider args) (loginWithIdentityCredentialForCertificate_args_identifier args) (loginWithIdentityCredentialForCertificate_args_password args) (loginWithIdentityCredentialForCertificate_args_keepLoggedIn args) (loginWithIdentityCredentialForCertificate_args_accessLocation args) (loginWithIdentityCredentialForCertificate_args_systemName args) (loginWithIdentityCredentialForCertificate_args_certificate args)
        let res = default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_success = val}
        T.writeMessage oprot ("loginWithIdentityCredentialForCertificate", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredentialForCertificate_result oprot res)
      (\e  -> do
        let res = default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_e = P.Just e}
        T.writeMessage oprot ("loginWithIdentityCredentialForCertificate", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredentialForCertificate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithIdentityCredentialForCertificate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithVerifier (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithVerifier_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithVerifier handler (loginWithVerifier_args_verifier args)
        let res = default_LoginWithVerifier_result{loginWithVerifier_result_success = val}
        T.writeMessage oprot ("loginWithVerifier", T.M_REPLY, seqid) $
          write_LoginWithVerifier_result oprot res)
      (\e  -> do
        let res = default_LoginWithVerifier_result{loginWithVerifier_result_e = P.Just e}
        T.writeMessage oprot ("loginWithVerifier", T.M_REPLY, seqid) $
          write_LoginWithVerifier_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithVerifier", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithVerifierForCerificate (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithVerifierForCerificate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithVerifierForCerificate handler (loginWithVerifierForCerificate_args_verifier args)
        let res = default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_success = val}
        T.writeMessage oprot ("loginWithVerifierForCerificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCerificate_result oprot res)
      (\e  -> do
        let res = default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_e = P.Just e}
        T.writeMessage oprot ("loginWithVerifierForCerificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCerificate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithVerifierForCerificate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithVerifierForCertificate (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithVerifierForCertificate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithVerifierForCertificate handler (loginWithVerifierForCertificate_args_verifier args)
        let res = default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_success = val}
        T.writeMessage oprot ("loginWithVerifierForCertificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCertificate_result oprot res)
      (\e  -> do
        let res = default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_e = P.Just e}
        T.writeMessage oprot ("loginWithVerifierForCertificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCertificate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithVerifierForCertificate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_logout (seqid, iprot, oprot, handler) = do
  args <- read_Logout_args iprot
  (X.catch
    (X.catch
      (do
        Iface.logout handler
        let res = default_Logout_result
        T.writeMessage oprot ("logout", T.M_REPLY, seqid) $
          write_Logout_result oprot res)
      (\e  -> do
        let res = default_Logout_result{logout_result_e = P.Just e}
        T.writeMessage oprot ("logout", T.M_REPLY, seqid) $
          write_Logout_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("logout", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_logoutSession (seqid, iprot, oprot, handler) = do
  args <- read_LogoutSession_args iprot
  (X.catch
    (X.catch
      (do
        Iface.logoutSession handler (logoutSession_args_tokenKey args)
        let res = default_LogoutSession_result
        T.writeMessage oprot ("logoutSession", T.M_REPLY, seqid) $
          write_LogoutSession_result oprot res)
      (\e  -> do
        let res = default_LogoutSession_result{logoutSession_result_e = P.Just e}
        T.writeMessage oprot ("logoutSession", T.M_REPLY, seqid) $
          write_LogoutSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("logoutSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_noop (seqid, iprot, oprot, handler) = do
  args <- read_Noop_args iprot
  (X.catch
    (X.catch
      (do
        Iface.noop handler
        let res = default_Noop_result
        T.writeMessage oprot ("noop", T.M_REPLY, seqid) $
          write_Noop_result oprot res)
      (\e  -> do
        let res = default_Noop_result{noop_result_e = P.Just e}
        T.writeMessage oprot ("noop", T.M_REPLY, seqid) $
          write_Noop_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("noop", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifiedRedirect (seqid, iprot, oprot, handler) = do
  args <- read_NotifiedRedirect_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifiedRedirect handler (notifiedRedirect_args_paramMap args)
        let res = default_NotifiedRedirect_result
        T.writeMessage oprot ("notifiedRedirect", T.M_REPLY, seqid) $
          write_NotifiedRedirect_result oprot res)
      (\e  -> do
        let res = default_NotifiedRedirect_result{notifiedRedirect_result_e = P.Just e}
        T.writeMessage oprot ("notifiedRedirect", T.M_REPLY, seqid) $
          write_NotifiedRedirect_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifiedRedirect", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyBuddyOnAir (seqid, iprot, oprot, handler) = do
  args <- read_NotifyBuddyOnAir_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.notifyBuddyOnAir handler (notifyBuddyOnAir_args_seq args) (notifyBuddyOnAir_args_receiverMids args)
        let res = default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_success = val}
        T.writeMessage oprot ("notifyBuddyOnAir", T.M_REPLY, seqid) $
          write_NotifyBuddyOnAir_result oprot res)
      (\e  -> do
        let res = default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_e = P.Just e}
        T.writeMessage oprot ("notifyBuddyOnAir", T.M_REPLY, seqid) $
          write_NotifyBuddyOnAir_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyBuddyOnAir", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyIndividualEvent (seqid, iprot, oprot, handler) = do
  args <- read_NotifyIndividualEvent_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyIndividualEvent handler (notifyIndividualEvent_args_notificationStatus args) (notifyIndividualEvent_args_receiverMids args)
        let res = default_NotifyIndividualEvent_result
        T.writeMessage oprot ("notifyIndividualEvent", T.M_REPLY, seqid) $
          write_NotifyIndividualEvent_result oprot res)
      (\e  -> do
        let res = default_NotifyIndividualEvent_result{notifyIndividualEvent_result_e = P.Just e}
        T.writeMessage oprot ("notifyIndividualEvent", T.M_REPLY, seqid) $
          write_NotifyIndividualEvent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyIndividualEvent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyInstalled (seqid, iprot, oprot, handler) = do
  args <- read_NotifyInstalled_args iprot
  (X.catch
    (do
      Iface.notifyInstalled handler (notifyInstalled_args_udidHash args) (notifyInstalled_args_applicationTypeWithExtensions args)
      let res = default_NotifyInstalled_result
      T.writeMessage oprot ("notifyInstalled", T.M_REPLY, seqid) $
        write_NotifyInstalled_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("notifyInstalled", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyRegistrationComplete (seqid, iprot, oprot, handler) = do
  args <- read_NotifyRegistrationComplete_args iprot
  (X.catch
    (do
      Iface.notifyRegistrationComplete handler (notifyRegistrationComplete_args_udidHash args) (notifyRegistrationComplete_args_applicationTypeWithExtensions args)
      let res = default_NotifyRegistrationComplete_result
      T.writeMessage oprot ("notifyRegistrationComplete", T.M_REPLY, seqid) $
        write_NotifyRegistrationComplete_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("notifyRegistrationComplete", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifySleep (seqid, iprot, oprot, handler) = do
  args <- read_NotifySleep_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifySleep handler (notifySleep_args_lastRev args) (notifySleep_args_badge args)
        let res = default_NotifySleep_result
        T.writeMessage oprot ("notifySleep", T.M_REPLY, seqid) $
          write_NotifySleep_result oprot res)
      (\e  -> do
        let res = default_NotifySleep_result{notifySleep_result_e = P.Just e}
        T.writeMessage oprot ("notifySleep", T.M_REPLY, seqid) $
          write_NotifySleep_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifySleep", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyUpdated (seqid, iprot, oprot, handler) = do
  args <- read_NotifyUpdated_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyUpdated handler (notifyUpdated_args_lastRev args) (notifyUpdated_args_deviceInfo args)
        let res = default_NotifyUpdated_result
        T.writeMessage oprot ("notifyUpdated", T.M_REPLY, seqid) $
          write_NotifyUpdated_result oprot res)
      (\e  -> do
        let res = default_NotifyUpdated_result{notifyUpdated_result_e = P.Just e}
        T.writeMessage oprot ("notifyUpdated", T.M_REPLY, seqid) $
          write_NotifyUpdated_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyUpdated", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_openProximityMatch (seqid, iprot, oprot, handler) = do
  args <- read_OpenProximityMatch_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.openProximityMatch handler (openProximityMatch_args_location args)
        let res = default_OpenProximityMatch_result{openProximityMatch_result_success = val}
        T.writeMessage oprot ("openProximityMatch", T.M_REPLY, seqid) $
          write_OpenProximityMatch_result oprot res)
      (\e  -> do
        let res = default_OpenProximityMatch_result{openProximityMatch_result_e = P.Just e}
        T.writeMessage oprot ("openProximityMatch", T.M_REPLY, seqid) $
          write_OpenProximityMatch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("openProximityMatch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerBuddyUser (seqid, iprot, oprot, handler) = do
  args <- read_RegisterBuddyUser_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerBuddyUser handler (registerBuddyUser_args_buddyId args) (registerBuddyUser_args_registrarPassword args)
        let res = default_RegisterBuddyUser_result{registerBuddyUser_result_success = val}
        T.writeMessage oprot ("registerBuddyUser", T.M_REPLY, seqid) $
          write_RegisterBuddyUser_result oprot res)
      (\e  -> do
        let res = default_RegisterBuddyUser_result{registerBuddyUser_result_e = P.Just e}
        T.writeMessage oprot ("registerBuddyUser", T.M_REPLY, seqid) $
          write_RegisterBuddyUser_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerBuddyUser", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerBuddyUserid (seqid, iprot, oprot, handler) = do
  args <- read_RegisterBuddyUserid_args iprot
  (X.catch
    (X.catch
      (do
        Iface.registerBuddyUserid handler (registerBuddyUserid_args_seq args) (registerBuddyUserid_args_userid args)
        let res = default_RegisterBuddyUserid_result
        T.writeMessage oprot ("registerBuddyUserid", T.M_REPLY, seqid) $
          write_RegisterBuddyUserid_result oprot res)
      (\e  -> do
        let res = default_RegisterBuddyUserid_result{registerBuddyUserid_result_e = P.Just e}
        T.writeMessage oprot ("registerBuddyUserid", T.M_REPLY, seqid) $
          write_RegisterBuddyUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerBuddyUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDevice (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDevice_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDevice handler (registerDevice_args_sessionId args)
        let res = default_RegisterDevice_result{registerDevice_result_success = val}
        T.writeMessage oprot ("registerDevice", T.M_REPLY, seqid) $
          write_RegisterDevice_result oprot res)
      (\e  -> do
        let res = default_RegisterDevice_result{registerDevice_result_e = P.Just e}
        T.writeMessage oprot ("registerDevice", T.M_REPLY, seqid) $
          write_RegisterDevice_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDevice", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDeviceWithIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDeviceWithIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDeviceWithIdentityCredential handler (registerDeviceWithIdentityCredential_args_sessionId args) (registerDeviceWithIdentityCredential_args_provider args) (registerDeviceWithIdentityCredential_args_identifier args) (registerDeviceWithIdentityCredential_args_verifier args)
        let res = default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerDeviceWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerDeviceWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDeviceWithIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDeviceWithoutPhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDeviceWithoutPhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDeviceWithoutPhoneNumber handler (registerDeviceWithoutPhoneNumber_args_region args) (registerDeviceWithoutPhoneNumber_args_udidHash args) (registerDeviceWithoutPhoneNumber_args_deviceInfo args)
        let res = default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_success = val}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumber", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumber_result oprot res)
      (\e  -> do
        let res = default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumber", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDeviceWithoutPhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDeviceWithoutPhoneNumberWithIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDeviceWithoutPhoneNumberWithIdentityCredential handler (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid args)
        let res = default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumberWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumberWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDeviceWithoutPhoneNumberWithIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerUserid (seqid, iprot, oprot, handler) = do
  args <- read_RegisterUserid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerUserid handler (registerUserid_args_reqSeq args) (registerUserid_args_userid args)
        let res = default_RegisterUserid_result{registerUserid_result_success = val}
        T.writeMessage oprot ("registerUserid", T.M_REPLY, seqid) $
          write_RegisterUserid_result oprot res)
      (\e  -> do
        let res = default_RegisterUserid_result{registerUserid_result_e = P.Just e}
        T.writeMessage oprot ("registerUserid", T.M_REPLY, seqid) $
          write_RegisterUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWapDevice (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWapDevice_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWapDevice handler (registerWapDevice_args_invitationHash args) (registerWapDevice_args_guidHash args) (registerWapDevice_args_email args) (registerWapDevice_args_deviceInfo args)
        let res = default_RegisterWapDevice_result{registerWapDevice_result_success = val}
        T.writeMessage oprot ("registerWapDevice", T.M_REPLY, seqid) $
          write_RegisterWapDevice_result oprot res)
      (\e  -> do
        let res = default_RegisterWapDevice_result{registerWapDevice_result_e = P.Just e}
        T.writeMessage oprot ("registerWapDevice", T.M_REPLY, seqid) $
          write_RegisterWapDevice_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWapDevice", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithExistingSnsIdAndIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithExistingSnsIdAndIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithExistingSnsIdAndIdentityCredential handler (registerWithExistingSnsIdAndIdentityCredential_args_identityCredential args) (registerWithExistingSnsIdAndIdentityCredential_args_region args) (registerWithExistingSnsIdAndIdentityCredential_args_udidHash args) (registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo args)
        let res = default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerWithExistingSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithExistingSnsIdAndIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerWithExistingSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithExistingSnsIdAndIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithExistingSnsIdAndIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithSnsId (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithSnsId_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithSnsId handler (registerWithSnsId_args_snsIdType args) (registerWithSnsId_args_snsAccessToken args) (registerWithSnsId_args_region args) (registerWithSnsId_args_udidHash args) (registerWithSnsId_args_deviceInfo args) (registerWithSnsId_args_mid args)
        let res = default_RegisterWithSnsId_result{registerWithSnsId_result_success = val}
        T.writeMessage oprot ("registerWithSnsId", T.M_REPLY, seqid) $
          write_RegisterWithSnsId_result oprot res)
      (\e  -> do
        let res = default_RegisterWithSnsId_result{registerWithSnsId_result_e = P.Just e}
        T.writeMessage oprot ("registerWithSnsId", T.M_REPLY, seqid) $
          write_RegisterWithSnsId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithSnsId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithSnsIdAndIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithSnsIdAndIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithSnsIdAndIdentityCredential handler (registerWithSnsIdAndIdentityCredential_args_snsIdType args) (registerWithSnsIdAndIdentityCredential_args_snsAccessToken args) (registerWithSnsIdAndIdentityCredential_args_identityCredential args) (registerWithSnsIdAndIdentityCredential_args_region args) (registerWithSnsIdAndIdentityCredential_args_udidHash args) (registerWithSnsIdAndIdentityCredential_args_deviceInfo args)
        let res = default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerWithSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithSnsIdAndIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerWithSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithSnsIdAndIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithSnsIdAndIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reissueDeviceCredential (seqid, iprot, oprot, handler) = do
  args <- read_ReissueDeviceCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reissueDeviceCredential handler
        let res = default_ReissueDeviceCredential_result{reissueDeviceCredential_result_success = val}
        T.writeMessage oprot ("reissueDeviceCredential", T.M_REPLY, seqid) $
          write_ReissueDeviceCredential_result oprot res)
      (\e  -> do
        let res = default_ReissueDeviceCredential_result{reissueDeviceCredential_result_e = P.Just e}
        T.writeMessage oprot ("reissueDeviceCredential", T.M_REPLY, seqid) $
          write_ReissueDeviceCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reissueDeviceCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reissueUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_ReissueUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reissueUserTicket handler (reissueUserTicket_args_expirationTime args) (reissueUserTicket_args_maxUseCount args)
        let res = default_ReissueUserTicket_result{reissueUserTicket_result_success = val}
        T.writeMessage oprot ("reissueUserTicket", T.M_REPLY, seqid) $
          write_ReissueUserTicket_result oprot res)
      (\e  -> do
        let res = default_ReissueUserTicket_result{reissueUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("reissueUserTicket", T.M_REPLY, seqid) $
          write_ReissueUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reissueUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_rejectGroupInvitation (seqid, iprot, oprot, handler) = do
  args <- read_RejectGroupInvitation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.rejectGroupInvitation handler (rejectGroupInvitation_args_reqSeq args) (rejectGroupInvitation_args_groupId args)
        let res = default_RejectGroupInvitation_result
        T.writeMessage oprot ("rejectGroupInvitation", T.M_REPLY, seqid) $
          write_RejectGroupInvitation_result oprot res)
      (\e  -> do
        let res = default_RejectGroupInvitation_result{rejectGroupInvitation_result_e = P.Just e}
        T.writeMessage oprot ("rejectGroupInvitation", T.M_REPLY, seqid) $
          write_RejectGroupInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("rejectGroupInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_releaseSession (seqid, iprot, oprot, handler) = do
  args <- read_ReleaseSession_args iprot
  (X.catch
    (X.catch
      (do
        Iface.releaseSession handler
        let res = default_ReleaseSession_result
        T.writeMessage oprot ("releaseSession", T.M_REPLY, seqid) $
          write_ReleaseSession_result oprot res)
      (\e  -> do
        let res = default_ReleaseSession_result{releaseSession_result_e = P.Just e}
        T.writeMessage oprot ("releaseSession", T.M_REPLY, seqid) $
          write_ReleaseSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("releaseSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeAllMessages (seqid, iprot, oprot, handler) = do
  args <- read_RemoveAllMessages_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeAllMessages handler (removeAllMessages_args_seq args) (removeAllMessages_args_lastMessageId args)
        let res = default_RemoveAllMessages_result
        T.writeMessage oprot ("removeAllMessages", T.M_REPLY, seqid) $
          write_RemoveAllMessages_result oprot res)
      (\e  -> do
        let res = default_RemoveAllMessages_result{removeAllMessages_result_e = P.Just e}
        T.writeMessage oprot ("removeAllMessages", T.M_REPLY, seqid) $
          write_RemoveAllMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeAllMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeBuddyLocation (seqid, iprot, oprot, handler) = do
  args <- read_RemoveBuddyLocation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeBuddyLocation handler (removeBuddyLocation_args_mid args) (removeBuddyLocation_args_index args)
        let res = default_RemoveBuddyLocation_result
        T.writeMessage oprot ("removeBuddyLocation", T.M_REPLY, seqid) $
          write_RemoveBuddyLocation_result oprot res)
      (\e  -> do
        let res = default_RemoveBuddyLocation_result{removeBuddyLocation_result_e = P.Just e}
        T.writeMessage oprot ("removeBuddyLocation", T.M_REPLY, seqid) $
          write_RemoveBuddyLocation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeBuddyLocation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeMessage (seqid, iprot, oprot, handler) = do
  args <- read_RemoveMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.removeMessage handler (removeMessage_args_messageId args)
        let res = default_RemoveMessage_result{removeMessage_result_success = val}
        T.writeMessage oprot ("removeMessage", T.M_REPLY, seqid) $
          write_RemoveMessage_result oprot res)
      (\e  -> do
        let res = default_RemoveMessage_result{removeMessage_result_e = P.Just e}
        T.writeMessage oprot ("removeMessage", T.M_REPLY, seqid) $
          write_RemoveMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeMessageFromMyHome (seqid, iprot, oprot, handler) = do
  args <- read_RemoveMessageFromMyHome_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.removeMessageFromMyHome handler (removeMessageFromMyHome_args_messageId args)
        let res = default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_success = val}
        T.writeMessage oprot ("removeMessageFromMyHome", T.M_REPLY, seqid) $
          write_RemoveMessageFromMyHome_result oprot res)
      (\e  -> do
        let res = default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_e = P.Just e}
        T.writeMessage oprot ("removeMessageFromMyHome", T.M_REPLY, seqid) $
          write_RemoveMessageFromMyHome_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeMessageFromMyHome", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeSnsId (seqid, iprot, oprot, handler) = do
  args <- read_RemoveSnsId_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.removeSnsId handler (removeSnsId_args_snsIdType args)
        let res = default_RemoveSnsId_result{removeSnsId_result_success = val}
        T.writeMessage oprot ("removeSnsId", T.M_REPLY, seqid) $
          write_RemoveSnsId_result oprot res)
      (\e  -> do
        let res = default_RemoveSnsId_result{removeSnsId_result_e = P.Just e}
        T.writeMessage oprot ("removeSnsId", T.M_REPLY, seqid) $
          write_RemoveSnsId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeSnsId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_report (seqid, iprot, oprot, handler) = do
  args <- read_Report_args iprot
  (X.catch
    (X.catch
      (do
        Iface.report handler (report_args_syncOpRevision args) (report_args_category args) (report_args_report args)
        let res = default_Report_result
        T.writeMessage oprot ("report", T.M_REPLY, seqid) $
          write_Report_result oprot res)
      (\e  -> do
        let res = default_Report_result{report_result_e = P.Just e}
        T.writeMessage oprot ("report", T.M_REPLY, seqid) $
          write_Report_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("report", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportContacts (seqid, iprot, oprot, handler) = do
  args <- read_ReportContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reportContacts handler (reportContacts_args_syncOpRevision args) (reportContacts_args_category args) (reportContacts_args_contactReports args) (reportContacts_args_actionType args)
        let res = default_ReportContacts_result{reportContacts_result_success = val}
        T.writeMessage oprot ("reportContacts", T.M_REPLY, seqid) $
          write_ReportContacts_result oprot res)
      (\e  -> do
        let res = default_ReportContacts_result{reportContacts_result_e = P.Just e}
        T.writeMessage oprot ("reportContacts", T.M_REPLY, seqid) $
          write_ReportContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportGroups (seqid, iprot, oprot, handler) = do
  args <- read_ReportGroups_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportGroups handler (reportGroups_args_syncOpRevision args) (reportGroups_args_groups args)
        let res = default_ReportGroups_result
        T.writeMessage oprot ("reportGroups", T.M_REPLY, seqid) $
          write_ReportGroups_result oprot res)
      (\e  -> do
        let res = default_ReportGroups_result{reportGroups_result_e = P.Just e}
        T.writeMessage oprot ("reportGroups", T.M_REPLY, seqid) $
          write_ReportGroups_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportGroups", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportProfile (seqid, iprot, oprot, handler) = do
  args <- read_ReportProfile_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportProfile handler (reportProfile_args_syncOpRevision args) (reportProfile_args_profile args)
        let res = default_ReportProfile_result
        T.writeMessage oprot ("reportProfile", T.M_REPLY, seqid) $
          write_ReportProfile_result oprot res)
      (\e  -> do
        let res = default_ReportProfile_result{reportProfile_result_e = P.Just e}
        T.writeMessage oprot ("reportProfile", T.M_REPLY, seqid) $
          write_ReportProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportRooms (seqid, iprot, oprot, handler) = do
  args <- read_ReportRooms_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportRooms handler (reportRooms_args_syncOpRevision args) (reportRooms_args_rooms args)
        let res = default_ReportRooms_result
        T.writeMessage oprot ("reportRooms", T.M_REPLY, seqid) $
          write_ReportRooms_result oprot res)
      (\e  -> do
        let res = default_ReportRooms_result{reportRooms_result_e = P.Just e}
        T.writeMessage oprot ("reportRooms", T.M_REPLY, seqid) $
          write_ReportRooms_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportRooms", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSettings (seqid, iprot, oprot, handler) = do
  args <- read_ReportSettings_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportSettings handler (reportSettings_args_syncOpRevision args) (reportSettings_args_settings args)
        let res = default_ReportSettings_result
        T.writeMessage oprot ("reportSettings", T.M_REPLY, seqid) $
          write_ReportSettings_result oprot res)
      (\e  -> do
        let res = default_ReportSettings_result{reportSettings_result_e = P.Just e}
        T.writeMessage oprot ("reportSettings", T.M_REPLY, seqid) $
          write_ReportSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSpammer (seqid, iprot, oprot, handler) = do
  args <- read_ReportSpammer_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportSpammer handler (reportSpammer_args_spammerMid args) (reportSpammer_args_spammerReasons args) (reportSpammer_args_spamMessageIds args)
        let res = default_ReportSpammer_result
        T.writeMessage oprot ("reportSpammer", T.M_REPLY, seqid) $
          write_ReportSpammer_result oprot res)
      (\e  -> do
        let res = default_ReportSpammer_result{reportSpammer_result_e = P.Just e}
        T.writeMessage oprot ("reportSpammer", T.M_REPLY, seqid) $
          write_ReportSpammer_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSpammer", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestAccountPasswordReset (seqid, iprot, oprot, handler) = do
  args <- read_RequestAccountPasswordReset_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestAccountPasswordReset handler (requestAccountPasswordReset_args_provider args) (requestAccountPasswordReset_args_identifier args) (requestAccountPasswordReset_args_locale args)
        let res = default_RequestAccountPasswordReset_result
        T.writeMessage oprot ("requestAccountPasswordReset", T.M_REPLY, seqid) $
          write_RequestAccountPasswordReset_result oprot res)
      (\e  -> do
        let res = default_RequestAccountPasswordReset_result{requestAccountPasswordReset_result_e = P.Just e}
        T.writeMessage oprot ("requestAccountPasswordReset", T.M_REPLY, seqid) $
          write_RequestAccountPasswordReset_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestAccountPasswordReset", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestEmailConfirmation (seqid, iprot, oprot, handler) = do
  args <- read_RequestEmailConfirmation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.requestEmailConfirmation handler (requestEmailConfirmation_args_emailConfirmation args)
        let res = default_RequestEmailConfirmation_result{requestEmailConfirmation_result_success = val}
        T.writeMessage oprot ("requestEmailConfirmation", T.M_REPLY, seqid) $
          write_RequestEmailConfirmation_result oprot res)
      (\e  -> do
        let res = default_RequestEmailConfirmation_result{requestEmailConfirmation_result_e = P.Just e}
        T.writeMessage oprot ("requestEmailConfirmation", T.M_REPLY, seqid) $
          write_RequestEmailConfirmation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestEmailConfirmation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestIdentityUnbind (seqid, iprot, oprot, handler) = do
  args <- read_RequestIdentityUnbind_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestIdentityUnbind handler (requestIdentityUnbind_args_provider args) (requestIdentityUnbind_args_identifier args)
        let res = default_RequestIdentityUnbind_result
        T.writeMessage oprot ("requestIdentityUnbind", T.M_REPLY, seqid) $
          write_RequestIdentityUnbind_result oprot res)
      (\e  -> do
        let res = default_RequestIdentityUnbind_result{requestIdentityUnbind_result_e = P.Just e}
        T.writeMessage oprot ("requestIdentityUnbind", T.M_REPLY, seqid) $
          write_RequestIdentityUnbind_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestIdentityUnbind", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_resendEmailConfirmation (seqid, iprot, oprot, handler) = do
  args <- read_ResendEmailConfirmation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.resendEmailConfirmation handler (resendEmailConfirmation_args_verifier args)
        let res = default_ResendEmailConfirmation_result{resendEmailConfirmation_result_success = val}
        T.writeMessage oprot ("resendEmailConfirmation", T.M_REPLY, seqid) $
          write_ResendEmailConfirmation_result oprot res)
      (\e  -> do
        let res = default_ResendEmailConfirmation_result{resendEmailConfirmation_result_e = P.Just e}
        T.writeMessage oprot ("resendEmailConfirmation", T.M_REPLY, seqid) $
          write_ResendEmailConfirmation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("resendEmailConfirmation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_resendPinCode (seqid, iprot, oprot, handler) = do
  args <- read_ResendPinCode_args iprot
  (X.catch
    (X.catch
      (do
        Iface.resendPinCode handler (resendPinCode_args_sessionId args)
        let res = default_ResendPinCode_result
        T.writeMessage oprot ("resendPinCode", T.M_REPLY, seqid) $
          write_ResendPinCode_result oprot res)
      (\e  -> do
        let res = default_ResendPinCode_result{resendPinCode_result_e = P.Just e}
        T.writeMessage oprot ("resendPinCode", T.M_REPLY, seqid) $
          write_ResendPinCode_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("resendPinCode", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_resendPinCodeBySMS (seqid, iprot, oprot, handler) = do
  args <- read_ResendPinCodeBySMS_args iprot
  (X.catch
    (X.catch
      (do
        Iface.resendPinCodeBySMS handler (resendPinCodeBySMS_args_sessionId args)
        let res = default_ResendPinCodeBySMS_result
        T.writeMessage oprot ("resendPinCodeBySMS", T.M_REPLY, seqid) $
          write_ResendPinCodeBySMS_result oprot res)
      (\e  -> do
        let res = default_ResendPinCodeBySMS_result{resendPinCodeBySMS_result_e = P.Just e}
        T.writeMessage oprot ("resendPinCodeBySMS", T.M_REPLY, seqid) $
          write_ResendPinCodeBySMS_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("resendPinCodeBySMS", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendChatChecked (seqid, iprot, oprot, handler) = do
  args <- read_SendChatChecked_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendChatChecked handler (sendChatChecked_args_seq args) (sendChatChecked_args_consumer args) (sendChatChecked_args_lastMessageId args)
        let res = default_SendChatChecked_result
        T.writeMessage oprot ("sendChatChecked", T.M_REPLY, seqid) $
          write_SendChatChecked_result oprot res)
      (\e  -> do
        let res = default_SendChatChecked_result{sendChatChecked_result_e = P.Just e}
        T.writeMessage oprot ("sendChatChecked", T.M_REPLY, seqid) $
          write_SendChatChecked_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendChatChecked", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendChatRemoved (seqid, iprot, oprot, handler) = do
  args <- read_SendChatRemoved_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendChatRemoved handler (sendChatRemoved_args_seq args) (sendChatRemoved_args_consumer args) (sendChatRemoved_args_lastMessageId args)
        let res = default_SendChatRemoved_result
        T.writeMessage oprot ("sendChatRemoved", T.M_REPLY, seqid) $
          write_SendChatRemoved_result oprot res)
      (\e  -> do
        let res = default_SendChatRemoved_result{sendChatRemoved_result_e = P.Just e}
        T.writeMessage oprot ("sendChatRemoved", T.M_REPLY, seqid) $
          write_SendChatRemoved_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendChatRemoved", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendContentPreviewUpdated (seqid, iprot, oprot, handler) = do
  args <- read_SendContentPreviewUpdated_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendContentPreviewUpdated handler (sendContentPreviewUpdated_args_esq args) (sendContentPreviewUpdated_args_messageId args) (sendContentPreviewUpdated_args_receiverMids args)
        let res = default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_success = val}
        T.writeMessage oprot ("sendContentPreviewUpdated", T.M_REPLY, seqid) $
          write_SendContentPreviewUpdated_result oprot res)
      (\e  -> do
        let res = default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_e = P.Just e}
        T.writeMessage oprot ("sendContentPreviewUpdated", T.M_REPLY, seqid) $
          write_SendContentPreviewUpdated_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendContentPreviewUpdated", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendContentReceipt (seqid, iprot, oprot, handler) = do
  args <- read_SendContentReceipt_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendContentReceipt handler (sendContentReceipt_args_seq args) (sendContentReceipt_args_consumer args) (sendContentReceipt_args_messageId args)
        let res = default_SendContentReceipt_result
        T.writeMessage oprot ("sendContentReceipt", T.M_REPLY, seqid) $
          write_SendContentReceipt_result oprot res)
      (\e  -> do
        let res = default_SendContentReceipt_result{sendContentReceipt_result_e = P.Just e}
        T.writeMessage oprot ("sendContentReceipt", T.M_REPLY, seqid) $
          write_SendContentReceipt_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendContentReceipt", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendDummyPush (seqid, iprot, oprot, handler) = do
  args <- read_SendDummyPush_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendDummyPush handler
        let res = default_SendDummyPush_result
        T.writeMessage oprot ("sendDummyPush", T.M_REPLY, seqid) $
          write_SendDummyPush_result oprot res)
      (\e  -> do
        let res = default_SendDummyPush_result{sendDummyPush_result_e = P.Just e}
        T.writeMessage oprot ("sendDummyPush", T.M_REPLY, seqid) $
          write_SendDummyPush_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendDummyPush", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendEvent (seqid, iprot, oprot, handler) = do
  args <- read_SendEvent_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendEvent handler (sendEvent_args_seq args) (sendEvent_args_message args)
        let res = default_SendEvent_result{sendEvent_result_success = val}
        T.writeMessage oprot ("sendEvent", T.M_REPLY, seqid) $
          write_SendEvent_result oprot res)
      (\e  -> do
        let res = default_SendEvent_result{sendEvent_result_e = P.Just e}
        T.writeMessage oprot ("sendEvent", T.M_REPLY, seqid) $
          write_SendEvent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendEvent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessage (seqid, iprot, oprot, handler) = do
  args <- read_SendMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessage handler (sendMessage_args_seq args) (sendMessage_args_message args)
        let res = default_SendMessage_result{sendMessage_result_success = val}
        T.writeMessage oprot ("sendMessage", T.M_REPLY, seqid) $
          write_SendMessage_result oprot res)
      (\e  -> do
        let res = default_SendMessage_result{sendMessage_result_e = P.Just e}
        T.writeMessage oprot ("sendMessage", T.M_REPLY, seqid) $
          write_SendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageIgnored (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageIgnored_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendMessageIgnored handler (sendMessageIgnored_args_seq args) (sendMessageIgnored_args_consumer args) (sendMessageIgnored_args_messageIds args)
        let res = default_SendMessageIgnored_result
        T.writeMessage oprot ("sendMessageIgnored", T.M_REPLY, seqid) $
          write_SendMessageIgnored_result oprot res)
      (\e  -> do
        let res = default_SendMessageIgnored_result{sendMessageIgnored_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageIgnored", T.M_REPLY, seqid) $
          write_SendMessageIgnored_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageIgnored", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageReceipt (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageReceipt_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendMessageReceipt handler (sendMessageReceipt_args_seq args) (sendMessageReceipt_args_consumer args) (sendMessageReceipt_args_messageIds args)
        let res = default_SendMessageReceipt_result
        T.writeMessage oprot ("sendMessageReceipt", T.M_REPLY, seqid) $
          write_SendMessageReceipt_result oprot res)
      (\e  -> do
        let res = default_SendMessageReceipt_result{sendMessageReceipt_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageReceipt", T.M_REPLY, seqid) $
          write_SendMessageReceipt_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageReceipt", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageToMyHome (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageToMyHome_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageToMyHome handler (sendMessageToMyHome_args_seq args) (sendMessageToMyHome_args_message args)
        let res = default_SendMessageToMyHome_result{sendMessageToMyHome_result_success = val}
        T.writeMessage oprot ("sendMessageToMyHome", T.M_REPLY, seqid) $
          write_SendMessageToMyHome_result oprot res)
      (\e  -> do
        let res = default_SendMessageToMyHome_result{sendMessageToMyHome_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageToMyHome", T.M_REPLY, seqid) $
          write_SendMessageToMyHome_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageToMyHome", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setBuddyLocation (seqid, iprot, oprot, handler) = do
  args <- read_SetBuddyLocation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.setBuddyLocation handler (setBuddyLocation_args_mid args) (setBuddyLocation_args_index args) (setBuddyLocation_args_location args)
        let res = default_SetBuddyLocation_result
        T.writeMessage oprot ("setBuddyLocation", T.M_REPLY, seqid) $
          write_SetBuddyLocation_result oprot res)
      (\e  -> do
        let res = default_SetBuddyLocation_result{setBuddyLocation_result_e = P.Just e}
        T.writeMessage oprot ("setBuddyLocation", T.M_REPLY, seqid) $
          write_SetBuddyLocation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setBuddyLocation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_SetIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        Iface.setIdentityCredential handler (setIdentityCredential_args_provider args) (setIdentityCredential_args_identifier args) (setIdentityCredential_args_verifier args)
        let res = default_SetIdentityCredential_result
        T.writeMessage oprot ("setIdentityCredential", T.M_REPLY, seqid) $
          write_SetIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_SetIdentityCredential_result{setIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("setIdentityCredential", T.M_REPLY, seqid) $
          write_SetIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setNotificationsEnabled (seqid, iprot, oprot, handler) = do
  args <- read_SetNotificationsEnabled_args iprot
  (X.catch
    (X.catch
      (do
        Iface.setNotificationsEnabled handler (setNotificationsEnabled_args_reqSeq args) (setNotificationsEnabled_args_type args) (setNotificationsEnabled_args_target args) (setNotificationsEnabled_args_enablement args)
        let res = default_SetNotificationsEnabled_result
        T.writeMessage oprot ("setNotificationsEnabled", T.M_REPLY, seqid) $
          write_SetNotificationsEnabled_result oprot res)
      (\e  -> do
        let res = default_SetNotificationsEnabled_result{setNotificationsEnabled_result_e = P.Just e}
        T.writeMessage oprot ("setNotificationsEnabled", T.M_REPLY, seqid) $
          write_SetNotificationsEnabled_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setNotificationsEnabled", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_startUpdateVerification (seqid, iprot, oprot, handler) = do
  args <- read_StartUpdateVerification_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.startUpdateVerification handler (startUpdateVerification_args_region args) (startUpdateVerification_args_carrier args) (startUpdateVerification_args_phone args) (startUpdateVerification_args_udidHash args) (startUpdateVerification_args_deviceInfo args) (startUpdateVerification_args_networkCode args) (startUpdateVerification_args_locale args)
        let res = default_StartUpdateVerification_result{startUpdateVerification_result_success = val}
        T.writeMessage oprot ("startUpdateVerification", T.M_REPLY, seqid) $
          write_StartUpdateVerification_result oprot res)
      (\e  -> do
        let res = default_StartUpdateVerification_result{startUpdateVerification_result_e = P.Just e}
        T.writeMessage oprot ("startUpdateVerification", T.M_REPLY, seqid) $
          write_StartUpdateVerification_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("startUpdateVerification", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_startVerification (seqid, iprot, oprot, handler) = do
  args <- read_StartVerification_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.startVerification handler (startVerification_args_region args) (startVerification_args_carrier args) (startVerification_args_phone args) (startVerification_args_udidHash args) (startVerification_args_deviceInfo args) (startVerification_args_networkCode args) (startVerification_args_mid args) (startVerification_args_locale args)
        let res = default_StartVerification_result{startVerification_result_success = val}
        T.writeMessage oprot ("startVerification", T.M_REPLY, seqid) $
          write_StartVerification_result oprot res)
      (\e  -> do
        let res = default_StartVerification_result{startVerification_result_e = P.Just e}
        T.writeMessage oprot ("startVerification", T.M_REPLY, seqid) $
          write_StartVerification_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("startVerification", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_storeUpdateProfileAttribute (seqid, iprot, oprot, handler) = do
  args <- read_StoreUpdateProfileAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.storeUpdateProfileAttribute handler (storeUpdateProfileAttribute_args_seq args) (storeUpdateProfileAttribute_args_profileAttribute args) (storeUpdateProfileAttribute_args_value args)
        let res = default_StoreUpdateProfileAttribute_result
        T.writeMessage oprot ("storeUpdateProfileAttribute", T.M_REPLY, seqid) $
          write_StoreUpdateProfileAttribute_result oprot res)
      (\e  -> do
        let res = default_StoreUpdateProfileAttribute_result{storeUpdateProfileAttribute_result_e = P.Just e}
        T.writeMessage oprot ("storeUpdateProfileAttribute", T.M_REPLY, seqid) $
          write_StoreUpdateProfileAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("storeUpdateProfileAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_syncContactBySnsIds (seqid, iprot, oprot, handler) = do
  args <- read_SyncContactBySnsIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.syncContactBySnsIds handler (syncContactBySnsIds_args_reqSeq args) (syncContactBySnsIds_args_modifications args)
        let res = default_SyncContactBySnsIds_result{syncContactBySnsIds_result_success = val}
        T.writeMessage oprot ("syncContactBySnsIds", T.M_REPLY, seqid) $
          write_SyncContactBySnsIds_result oprot res)
      (\e  -> do
        let res = default_SyncContactBySnsIds_result{syncContactBySnsIds_result_e = P.Just e}
        T.writeMessage oprot ("syncContactBySnsIds", T.M_REPLY, seqid) $
          write_SyncContactBySnsIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("syncContactBySnsIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_syncContacts (seqid, iprot, oprot, handler) = do
  args <- read_SyncContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.syncContacts handler (syncContacts_args_reqSeq args) (syncContacts_args_localContacts args)
        let res = default_SyncContacts_result{syncContacts_result_success = val}
        T.writeMessage oprot ("syncContacts", T.M_REPLY, seqid) $
          write_SyncContacts_result oprot res)
      (\e  -> do
        let res = default_SyncContacts_result{syncContacts_result_e = P.Just e}
        T.writeMessage oprot ("syncContacts", T.M_REPLY, seqid) $
          write_SyncContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("syncContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_trySendMessage (seqid, iprot, oprot, handler) = do
  args <- read_TrySendMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.trySendMessage handler (trySendMessage_args_seq args) (trySendMessage_args_message args)
        let res = default_TrySendMessage_result{trySendMessage_result_success = val}
        T.writeMessage oprot ("trySendMessage", T.M_REPLY, seqid) $
          write_TrySendMessage_result oprot res)
      (\e  -> do
        let res = default_TrySendMessage_result{trySendMessage_result_e = P.Just e}
        T.writeMessage oprot ("trySendMessage", T.M_REPLY, seqid) $
          write_TrySendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("trySendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unblockContact (seqid, iprot, oprot, handler) = do
  args <- read_UnblockContact_args iprot
  (X.catch
    (X.catch
      (do
        Iface.unblockContact handler (unblockContact_args_reqSeq args) (unblockContact_args_id args)
        let res = default_UnblockContact_result
        T.writeMessage oprot ("unblockContact", T.M_REPLY, seqid) $
          write_UnblockContact_result oprot res)
      (\e  -> do
        let res = default_UnblockContact_result{unblockContact_result_e = P.Just e}
        T.writeMessage oprot ("unblockContact", T.M_REPLY, seqid) $
          write_UnblockContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unblockContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unblockRecommendation (seqid, iprot, oprot, handler) = do
  args <- read_UnblockRecommendation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.unblockRecommendation handler (unblockRecommendation_args_reqSeq args) (unblockRecommendation_args_id args)
        let res = default_UnblockRecommendation_result
        T.writeMessage oprot ("unblockRecommendation", T.M_REPLY, seqid) $
          write_UnblockRecommendation_result oprot res)
      (\e  -> do
        let res = default_UnblockRecommendation_result{unblockRecommendation_result_e = P.Just e}
        T.writeMessage oprot ("unblockRecommendation", T.M_REPLY, seqid) $
          write_UnblockRecommendation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unblockRecommendation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unregisterUserAndDevice (seqid, iprot, oprot, handler) = do
  args <- read_UnregisterUserAndDevice_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.unregisterUserAndDevice handler
        let res = default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_success = val}
        T.writeMessage oprot ("unregisterUserAndDevice", T.M_REPLY, seqid) $
          write_UnregisterUserAndDevice_result oprot res)
      (\e  -> do
        let res = default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_e = P.Just e}
        T.writeMessage oprot ("unregisterUserAndDevice", T.M_REPLY, seqid) $
          write_UnregisterUserAndDevice_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unregisterUserAndDevice", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateApnsDeviceToken (seqid, iprot, oprot, handler) = do
  args <- read_UpdateApnsDeviceToken_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateApnsDeviceToken handler (updateApnsDeviceToken_args_apnsDeviceToken args)
        let res = default_UpdateApnsDeviceToken_result
        T.writeMessage oprot ("updateApnsDeviceToken", T.M_REPLY, seqid) $
          write_UpdateApnsDeviceToken_result oprot res)
      (\e  -> do
        let res = default_UpdateApnsDeviceToken_result{updateApnsDeviceToken_result_e = P.Just e}
        T.writeMessage oprot ("updateApnsDeviceToken", T.M_REPLY, seqid) $
          write_UpdateApnsDeviceToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateApnsDeviceToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateBuddySetting (seqid, iprot, oprot, handler) = do
  args <- read_UpdateBuddySetting_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateBuddySetting handler (updateBuddySetting_args_key args) (updateBuddySetting_args_value args)
        let res = default_UpdateBuddySetting_result
        T.writeMessage oprot ("updateBuddySetting", T.M_REPLY, seqid) $
          write_UpdateBuddySetting_result oprot res)
      (\e  -> do
        let res = default_UpdateBuddySetting_result{updateBuddySetting_result_e = P.Just e}
        T.writeMessage oprot ("updateBuddySetting", T.M_REPLY, seqid) $
          write_UpdateBuddySetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateBuddySetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateC2DMRegistrationId (seqid, iprot, oprot, handler) = do
  args <- read_UpdateC2DMRegistrationId_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateC2DMRegistrationId handler (updateC2DMRegistrationId_args_registrationId args)
        let res = default_UpdateC2DMRegistrationId_result
        T.writeMessage oprot ("updateC2DMRegistrationId", T.M_REPLY, seqid) $
          write_UpdateC2DMRegistrationId_result oprot res)
      (\e  -> do
        let res = default_UpdateC2DMRegistrationId_result{updateC2DMRegistrationId_result_e = P.Just e}
        T.writeMessage oprot ("updateC2DMRegistrationId", T.M_REPLY, seqid) $
          write_UpdateC2DMRegistrationId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateC2DMRegistrationId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateContactSetting (seqid, iprot, oprot, handler) = do
  args <- read_UpdateContactSetting_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateContactSetting handler (updateContactSetting_args_reqSeq args) (updateContactSetting_args_mid args) (updateContactSetting_args_flag args) (updateContactSetting_args_value args)
        let res = default_UpdateContactSetting_result
        T.writeMessage oprot ("updateContactSetting", T.M_REPLY, seqid) $
          write_UpdateContactSetting_result oprot res)
      (\e  -> do
        let res = default_UpdateContactSetting_result{updateContactSetting_result_e = P.Just e}
        T.writeMessage oprot ("updateContactSetting", T.M_REPLY, seqid) $
          write_UpdateContactSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateContactSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateCustomModeSettings (seqid, iprot, oprot, handler) = do
  args <- read_UpdateCustomModeSettings_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateCustomModeSettings handler (updateCustomModeSettings_args_customMode args) (updateCustomModeSettings_args_paramMap args)
        let res = default_UpdateCustomModeSettings_result
        T.writeMessage oprot ("updateCustomModeSettings", T.M_REPLY, seqid) $
          write_UpdateCustomModeSettings_result oprot res)
      (\e  -> do
        let res = default_UpdateCustomModeSettings_result{updateCustomModeSettings_result_e = P.Just e}
        T.writeMessage oprot ("updateCustomModeSettings", T.M_REPLY, seqid) $
          write_UpdateCustomModeSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateCustomModeSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateDeviceInfo (seqid, iprot, oprot, handler) = do
  args <- read_UpdateDeviceInfo_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateDeviceInfo handler (updateDeviceInfo_args_deviceUid args) (updateDeviceInfo_args_deviceInfo args)
        let res = default_UpdateDeviceInfo_result
        T.writeMessage oprot ("updateDeviceInfo", T.M_REPLY, seqid) $
          write_UpdateDeviceInfo_result oprot res)
      (\e  -> do
        let res = default_UpdateDeviceInfo_result{updateDeviceInfo_result_e = P.Just e}
        T.writeMessage oprot ("updateDeviceInfo", T.M_REPLY, seqid) $
          write_UpdateDeviceInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateDeviceInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateGroup (seqid, iprot, oprot, handler) = do
  args <- read_UpdateGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateGroup handler (updateGroup_args_reqSeq args) (updateGroup_args_group args)
        let res = default_UpdateGroup_result
        T.writeMessage oprot ("updateGroup", T.M_REPLY, seqid) $
          write_UpdateGroup_result oprot res)
      (\e  -> do
        let res = default_UpdateGroup_result{updateGroup_result_e = P.Just e}
        T.writeMessage oprot ("updateGroup", T.M_REPLY, seqid) $
          write_UpdateGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateNotificationToken (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNotificationToken_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateNotificationToken handler (updateNotificationToken_args_type args) (updateNotificationToken_args_token args)
        let res = default_UpdateNotificationToken_result
        T.writeMessage oprot ("updateNotificationToken", T.M_REPLY, seqid) $
          write_UpdateNotificationToken_result oprot res)
      (\e  -> do
        let res = default_UpdateNotificationToken_result{updateNotificationToken_result_e = P.Just e}
        T.writeMessage oprot ("updateNotificationToken", T.M_REPLY, seqid) $
          write_UpdateNotificationToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateNotificationToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateNotificationTokenWithBytes (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNotificationTokenWithBytes_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateNotificationTokenWithBytes handler (updateNotificationTokenWithBytes_args_type args) (updateNotificationTokenWithBytes_args_token args)
        let res = default_UpdateNotificationTokenWithBytes_result
        T.writeMessage oprot ("updateNotificationTokenWithBytes", T.M_REPLY, seqid) $
          write_UpdateNotificationTokenWithBytes_result oprot res)
      (\e  -> do
        let res = default_UpdateNotificationTokenWithBytes_result{updateNotificationTokenWithBytes_result_e = P.Just e}
        T.writeMessage oprot ("updateNotificationTokenWithBytes", T.M_REPLY, seqid) $
          write_UpdateNotificationTokenWithBytes_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateNotificationTokenWithBytes", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfile (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfile_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfile handler (updateProfile_args_reqSeq args) (updateProfile_args_profile args)
        let res = default_UpdateProfile_result
        T.writeMessage oprot ("updateProfile", T.M_REPLY, seqid) $
          write_UpdateProfile_result oprot res)
      (\e  -> do
        let res = default_UpdateProfile_result{updateProfile_result_e = P.Just e}
        T.writeMessage oprot ("updateProfile", T.M_REPLY, seqid) $
          write_UpdateProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfileAttribute (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfileAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfileAttribute handler (updateProfileAttribute_args_reqSeq args) (updateProfileAttribute_args_attr args) (updateProfileAttribute_args_value args)
        let res = default_UpdateProfileAttribute_result
        T.writeMessage oprot ("updateProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateProfileAttribute_result oprot res)
      (\e  -> do
        let res = default_UpdateProfileAttribute_result{updateProfileAttribute_result_e = P.Just e}
        T.writeMessage oprot ("updateProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateProfileAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfileAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateRegion (seqid, iprot, oprot, handler) = do
  args <- read_UpdateRegion_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateRegion handler (updateRegion_args_region args)
        let res = default_UpdateRegion_result
        T.writeMessage oprot ("updateRegion", T.M_REPLY, seqid) $
          write_UpdateRegion_result oprot res)
      (\e  -> do
        let res = default_UpdateRegion_result{updateRegion_result_e = P.Just e}
        T.writeMessage oprot ("updateRegion", T.M_REPLY, seqid) $
          write_UpdateRegion_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateRegion", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettings (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettings_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateSettings handler (updateSettings_args_reqSeq args) (updateSettings_args_settings args)
        let res = default_UpdateSettings_result
        T.writeMessage oprot ("updateSettings", T.M_REPLY, seqid) $
          write_UpdateSettings_result oprot res)
      (\e  -> do
        let res = default_UpdateSettings_result{updateSettings_result_e = P.Just e}
        T.writeMessage oprot ("updateSettings", T.M_REPLY, seqid) $
          write_UpdateSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettings2 (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettings2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSettings2 handler (updateSettings2_args_reqSeq args) (updateSettings2_args_settings args)
        let res = default_UpdateSettings2_result{updateSettings2_result_success = val}
        T.writeMessage oprot ("updateSettings2", T.M_REPLY, seqid) $
          write_UpdateSettings2_result oprot res)
      (\e  -> do
        let res = default_UpdateSettings2_result{updateSettings2_result_e = P.Just e}
        T.writeMessage oprot ("updateSettings2", T.M_REPLY, seqid) $
          write_UpdateSettings2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettings2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettingsAttribute (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettingsAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateSettingsAttribute handler (updateSettingsAttribute_args_reqSeq args) (updateSettingsAttribute_args_attr args) (updateSettingsAttribute_args_value args)
        let res = default_UpdateSettingsAttribute_result
        T.writeMessage oprot ("updateSettingsAttribute", T.M_REPLY, seqid) $
          write_UpdateSettingsAttribute_result oprot res)
      (\e  -> do
        let res = default_UpdateSettingsAttribute_result{updateSettingsAttribute_result_e = P.Just e}
        T.writeMessage oprot ("updateSettingsAttribute", T.M_REPLY, seqid) $
          write_UpdateSettingsAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettingsAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettingsAttributes (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettingsAttributes_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSettingsAttributes handler (updateSettingsAttributes_args_reqSeq args) (updateSettingsAttributes_args_attrBitset args) (updateSettingsAttributes_args_settings args)
        let res = default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_success = val}
        T.writeMessage oprot ("updateSettingsAttributes", T.M_REPLY, seqid) $
          write_UpdateSettingsAttributes_result oprot res)
      (\e  -> do
        let res = default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_e = P.Just e}
        T.writeMessage oprot ("updateSettingsAttributes", T.M_REPLY, seqid) $
          write_UpdateSettingsAttributes_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettingsAttributes", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_VerifyIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        Iface.verifyIdentityCredential handler (verifyIdentityCredential_args_identityProvider args) (verifyIdentityCredential_args_identifier args) (verifyIdentityCredential_args_password args)
        let res = default_VerifyIdentityCredential_result
        T.writeMessage oprot ("verifyIdentityCredential", T.M_REPLY, seqid) $
          write_VerifyIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_VerifyIdentityCredential_result{verifyIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("verifyIdentityCredential", T.M_REPLY, seqid) $
          write_VerifyIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyIdentityCredentialWithResult (seqid, iprot, oprot, handler) = do
  args <- read_VerifyIdentityCredentialWithResult_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyIdentityCredentialWithResult handler (verifyIdentityCredentialWithResult_args_identityCredential args)
        let res = default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_success = val}
        T.writeMessage oprot ("verifyIdentityCredentialWithResult", T.M_REPLY, seqid) $
          write_VerifyIdentityCredentialWithResult_result oprot res)
      (\e  -> do
        let res = default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_e = P.Just e}
        T.writeMessage oprot ("verifyIdentityCredentialWithResult", T.M_REPLY, seqid) $
          write_VerifyIdentityCredentialWithResult_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyIdentityCredentialWithResult", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyPhone (seqid, iprot, oprot, handler) = do
  args <- read_VerifyPhone_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyPhone handler (verifyPhone_args_sessionId args) (verifyPhone_args_pinCode args) (verifyPhone_args_udidHash args)
        let res = default_VerifyPhone_result{verifyPhone_result_success = val}
        T.writeMessage oprot ("verifyPhone", T.M_REPLY, seqid) $
          write_VerifyPhone_result oprot res)
      (\e  -> do
        let res = default_VerifyPhone_result{verifyPhone_result_e = P.Just e}
        T.writeMessage oprot ("verifyPhone", T.M_REPLY, seqid) $
          write_VerifyPhone_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyPhone", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyQrcode (seqid, iprot, oprot, handler) = do
  args <- read_VerifyQrcode_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyQrcode handler (verifyQrcode_args_verifier args) (verifyQrcode_args_pinCode args)
        let res = default_VerifyQrcode_result{verifyQrcode_result_success = val}
        T.writeMessage oprot ("verifyQrcode", T.M_REPLY, seqid) $
          write_VerifyQrcode_result oprot res)
      (\e  -> do
        let res = default_VerifyQrcode_result{verifyQrcode_result_e = P.Just e}
        T.writeMessage oprot ("verifyQrcode", T.M_REPLY, seqid) $
          write_VerifyQrcode_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyQrcode", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "acceptGroupInvitation" -> process_acceptGroupInvitation (seqid,iprot,oprot,handler)
  "acceptProximityMatches" -> process_acceptProximityMatches (seqid,iprot,oprot,handler)
  "acquireCallRoute" -> process_acquireCallRoute (seqid,iprot,oprot,handler)
  "acquireCallTicket" -> process_acquireCallTicket (seqid,iprot,oprot,handler)
  "acquireEncryptedAccessToken" -> process_acquireEncryptedAccessToken (seqid,iprot,oprot,handler)
  "addSnsId" -> process_addSnsId (seqid,iprot,oprot,handler)
  "blockContact" -> process_blockContact (seqid,iprot,oprot,handler)
  "blockRecommendation" -> process_blockRecommendation (seqid,iprot,oprot,handler)
  "cancelGroupInvitation" -> process_cancelGroupInvitation (seqid,iprot,oprot,handler)
  "changeVerificationMethod" -> process_changeVerificationMethod (seqid,iprot,oprot,handler)
  "clearIdentityCredential" -> process_clearIdentityCredential (seqid,iprot,oprot,handler)
  "clearMessageBox" -> process_clearMessageBox (seqid,iprot,oprot,handler)
  "closeProximityMatch" -> process_closeProximityMatch (seqid,iprot,oprot,handler)
  "commitSendMessage" -> process_commitSendMessage (seqid,iprot,oprot,handler)
  "commitSendMessages" -> process_commitSendMessages (seqid,iprot,oprot,handler)
  "commitUpdateProfile" -> process_commitUpdateProfile (seqid,iprot,oprot,handler)
  "confirmEmail" -> process_confirmEmail (seqid,iprot,oprot,handler)
  "createGroup" -> process_createGroup (seqid,iprot,oprot,handler)
  "createQrcodeBase64Image" -> process_createQrcodeBase64Image (seqid,iprot,oprot,handler)
  "createRoom" -> process_createRoom (seqid,iprot,oprot,handler)
  "createSession" -> process_createSession (seqid,iprot,oprot,handler)
  "fetchAnnouncements" -> process_fetchAnnouncements (seqid,iprot,oprot,handler)
  "fetchMessages" -> process_fetchMessages (seqid,iprot,oprot,handler)
  "fetchOperations" -> process_fetchOperations (seqid,iprot,oprot,handler)
  "fetchOps" -> process_fetchOps (seqid,iprot,oprot,handler)
  "findAndAddContactsByEmail" -> process_findAndAddContactsByEmail (seqid,iprot,oprot,handler)
  "findAndAddContactsByMid" -> process_findAndAddContactsByMid (seqid,iprot,oprot,handler)
  "findAndAddContactsByPhone" -> process_findAndAddContactsByPhone (seqid,iprot,oprot,handler)
  "findAndAddContactsByUserid" -> process_findAndAddContactsByUserid (seqid,iprot,oprot,handler)
  "findContactByUserid" -> process_findContactByUserid (seqid,iprot,oprot,handler)
  "findContactByUserTicket" -> process_findContactByUserTicket (seqid,iprot,oprot,handler)
  "findContactsByEmail" -> process_findContactsByEmail (seqid,iprot,oprot,handler)
  "findContactsByPhone" -> process_findContactsByPhone (seqid,iprot,oprot,handler)
  "findSnsIdUserStatus" -> process_findSnsIdUserStatus (seqid,iprot,oprot,handler)
  "finishUpdateVerification" -> process_finishUpdateVerification (seqid,iprot,oprot,handler)
  "generateUserTicket" -> process_generateUserTicket (seqid,iprot,oprot,handler)
  "getAcceptedProximityMatches" -> process_getAcceptedProximityMatches (seqid,iprot,oprot,handler)
  "getActiveBuddySubscriberIds" -> process_getActiveBuddySubscriberIds (seqid,iprot,oprot,handler)
  "getAllContactIds" -> process_getAllContactIds (seqid,iprot,oprot,handler)
  "getAuthQrcode" -> process_getAuthQrcode (seqid,iprot,oprot,handler)
  "getBlockedContactIds" -> process_getBlockedContactIds (seqid,iprot,oprot,handler)
  "getBlockedContactIdsByRange" -> process_getBlockedContactIdsByRange (seqid,iprot,oprot,handler)
  "getBlockedRecommendationIds" -> process_getBlockedRecommendationIds (seqid,iprot,oprot,handler)
  "getBuddyBlockerIds" -> process_getBuddyBlockerIds (seqid,iprot,oprot,handler)
  "getBuddyLocation" -> process_getBuddyLocation (seqid,iprot,oprot,handler)
  "getCompactContactsModifiedSince" -> process_getCompactContactsModifiedSince (seqid,iprot,oprot,handler)
  "getCompactGroup" -> process_getCompactGroup (seqid,iprot,oprot,handler)
  "getCompactRoom" -> process_getCompactRoom (seqid,iprot,oprot,handler)
  "getContact" -> process_getContact (seqid,iprot,oprot,handler)
  "getContacts" -> process_getContacts (seqid,iprot,oprot,handler)
  "getCountryWithRequestIp" -> process_getCountryWithRequestIp (seqid,iprot,oprot,handler)
  "getFavoriteMids" -> process_getFavoriteMids (seqid,iprot,oprot,handler)
  "getGroup" -> process_getGroup (seqid,iprot,oprot,handler)
  "getGroupIdsInvited" -> process_getGroupIdsInvited (seqid,iprot,oprot,handler)
  "getGroupIdsJoined" -> process_getGroupIdsJoined (seqid,iprot,oprot,handler)
  "getGroups" -> process_getGroups (seqid,iprot,oprot,handler)
  "getHiddenContactMids" -> process_getHiddenContactMids (seqid,iprot,oprot,handler)
  "getIdentityIdentifier" -> process_getIdentityIdentifier (seqid,iprot,oprot,handler)
  "getLastAnnouncementIndex" -> process_getLastAnnouncementIndex (seqid,iprot,oprot,handler)
  "getLastOpRevision" -> process_getLastOpRevision (seqid,iprot,oprot,handler)
  "getMessageBox" -> process_getMessageBox (seqid,iprot,oprot,handler)
  "getMessageBoxCompactWrapUp" -> process_getMessageBoxCompactWrapUp (seqid,iprot,oprot,handler)
  "getMessageBoxCompactWrapUpList" -> process_getMessageBoxCompactWrapUpList (seqid,iprot,oprot,handler)
  "getMessageBoxList" -> process_getMessageBoxList (seqid,iprot,oprot,handler)
  "getMessageBoxListByStatus" -> process_getMessageBoxListByStatus (seqid,iprot,oprot,handler)
  "getMessageBoxWrapUp" -> process_getMessageBoxWrapUp (seqid,iprot,oprot,handler)
  "getMessageBoxWrapUpList" -> process_getMessageBoxWrapUpList (seqid,iprot,oprot,handler)
  "getMessagesBySequenceNumber" -> process_getMessagesBySequenceNumber (seqid,iprot,oprot,handler)
  "getNextMessages" -> process_getNextMessages (seqid,iprot,oprot,handler)
  "getNotificationPolicy" -> process_getNotificationPolicy (seqid,iprot,oprot,handler)
  "getPreviousMessages" -> process_getPreviousMessages (seqid,iprot,oprot,handler)
  "getProfile" -> process_getProfile (seqid,iprot,oprot,handler)
  "getProximityMatchCandidateList" -> process_getProximityMatchCandidateList (seqid,iprot,oprot,handler)
  "getProximityMatchCandidates" -> process_getProximityMatchCandidates (seqid,iprot,oprot,handler)
  "getRecentMessages" -> process_getRecentMessages (seqid,iprot,oprot,handler)
  "getRecommendationIds" -> process_getRecommendationIds (seqid,iprot,oprot,handler)
  "getRoom" -> process_getRoom (seqid,iprot,oprot,handler)
  "getRSAKeyInfo" -> process_getRSAKeyInfo (seqid,iprot,oprot,handler)
  "getServerTime" -> process_getServerTime (seqid,iprot,oprot,handler)
  "getSessions" -> process_getSessions (seqid,iprot,oprot,handler)
  "getSettings" -> process_getSettings (seqid,iprot,oprot,handler)
  "getSettingsAttributes" -> process_getSettingsAttributes (seqid,iprot,oprot,handler)
  "getSystemConfiguration" -> process_getSystemConfiguration (seqid,iprot,oprot,handler)
  "getUserTicket" -> process_getUserTicket (seqid,iprot,oprot,handler)
  "getWapInvitation" -> process_getWapInvitation (seqid,iprot,oprot,handler)
  "invalidateUserTicket" -> process_invalidateUserTicket (seqid,iprot,oprot,handler)
  "inviteFriendsBySms" -> process_inviteFriendsBySms (seqid,iprot,oprot,handler)
  "inviteIntoGroup" -> process_inviteIntoGroup (seqid,iprot,oprot,handler)
  "inviteIntoRoom" -> process_inviteIntoRoom (seqid,iprot,oprot,handler)
  "inviteViaEmail" -> process_inviteViaEmail (seqid,iprot,oprot,handler)
  "isIdentityIdentifierAvailable" -> process_isIdentityIdentifierAvailable (seqid,iprot,oprot,handler)
  "isUseridAvailable" -> process_isUseridAvailable (seqid,iprot,oprot,handler)
  "kickoutFromGroup" -> process_kickoutFromGroup (seqid,iprot,oprot,handler)
  "leaveGroup" -> process_leaveGroup (seqid,iprot,oprot,handler)
  "leaveRoom" -> process_leaveRoom (seqid,iprot,oprot,handler)
  "loginWithIdentityCredential" -> process_loginWithIdentityCredential (seqid,iprot,oprot,handler)
  "loginWithIdentityCredentialForCertificate" -> process_loginWithIdentityCredentialForCertificate (seqid,iprot,oprot,handler)
  "loginWithVerifier" -> process_loginWithVerifier (seqid,iprot,oprot,handler)
  "loginWithVerifierForCerificate" -> process_loginWithVerifierForCerificate (seqid,iprot,oprot,handler)
  "loginWithVerifierForCertificate" -> process_loginWithVerifierForCertificate (seqid,iprot,oprot,handler)
  "logout" -> process_logout (seqid,iprot,oprot,handler)
  "logoutSession" -> process_logoutSession (seqid,iprot,oprot,handler)
  "noop" -> process_noop (seqid,iprot,oprot,handler)
  "notifiedRedirect" -> process_notifiedRedirect (seqid,iprot,oprot,handler)
  "notifyBuddyOnAir" -> process_notifyBuddyOnAir (seqid,iprot,oprot,handler)
  "notifyIndividualEvent" -> process_notifyIndividualEvent (seqid,iprot,oprot,handler)
  "notifyInstalled" -> process_notifyInstalled (seqid,iprot,oprot,handler)
  "notifyRegistrationComplete" -> process_notifyRegistrationComplete (seqid,iprot,oprot,handler)
  "notifySleep" -> process_notifySleep (seqid,iprot,oprot,handler)
  "notifyUpdated" -> process_notifyUpdated (seqid,iprot,oprot,handler)
  "openProximityMatch" -> process_openProximityMatch (seqid,iprot,oprot,handler)
  "registerBuddyUser" -> process_registerBuddyUser (seqid,iprot,oprot,handler)
  "registerBuddyUserid" -> process_registerBuddyUserid (seqid,iprot,oprot,handler)
  "registerDevice" -> process_registerDevice (seqid,iprot,oprot,handler)
  "registerDeviceWithIdentityCredential" -> process_registerDeviceWithIdentityCredential (seqid,iprot,oprot,handler)
  "registerDeviceWithoutPhoneNumber" -> process_registerDeviceWithoutPhoneNumber (seqid,iprot,oprot,handler)
  "registerDeviceWithoutPhoneNumberWithIdentityCredential" -> process_registerDeviceWithoutPhoneNumberWithIdentityCredential (seqid,iprot,oprot,handler)
  "registerUserid" -> process_registerUserid (seqid,iprot,oprot,handler)
  "registerWapDevice" -> process_registerWapDevice (seqid,iprot,oprot,handler)
  "registerWithExistingSnsIdAndIdentityCredential" -> process_registerWithExistingSnsIdAndIdentityCredential (seqid,iprot,oprot,handler)
  "registerWithSnsId" -> process_registerWithSnsId (seqid,iprot,oprot,handler)
  "registerWithSnsIdAndIdentityCredential" -> process_registerWithSnsIdAndIdentityCredential (seqid,iprot,oprot,handler)
  "reissueDeviceCredential" -> process_reissueDeviceCredential (seqid,iprot,oprot,handler)
  "reissueUserTicket" -> process_reissueUserTicket (seqid,iprot,oprot,handler)
  "rejectGroupInvitation" -> process_rejectGroupInvitation (seqid,iprot,oprot,handler)
  "releaseSession" -> process_releaseSession (seqid,iprot,oprot,handler)
  "removeAllMessages" -> process_removeAllMessages (seqid,iprot,oprot,handler)
  "removeBuddyLocation" -> process_removeBuddyLocation (seqid,iprot,oprot,handler)
  "removeMessage" -> process_removeMessage (seqid,iprot,oprot,handler)
  "removeMessageFromMyHome" -> process_removeMessageFromMyHome (seqid,iprot,oprot,handler)
  "removeSnsId" -> process_removeSnsId (seqid,iprot,oprot,handler)
  "report" -> process_report (seqid,iprot,oprot,handler)
  "reportContacts" -> process_reportContacts (seqid,iprot,oprot,handler)
  "reportGroups" -> process_reportGroups (seqid,iprot,oprot,handler)
  "reportProfile" -> process_reportProfile (seqid,iprot,oprot,handler)
  "reportRooms" -> process_reportRooms (seqid,iprot,oprot,handler)
  "reportSettings" -> process_reportSettings (seqid,iprot,oprot,handler)
  "reportSpammer" -> process_reportSpammer (seqid,iprot,oprot,handler)
  "requestAccountPasswordReset" -> process_requestAccountPasswordReset (seqid,iprot,oprot,handler)
  "requestEmailConfirmation" -> process_requestEmailConfirmation (seqid,iprot,oprot,handler)
  "requestIdentityUnbind" -> process_requestIdentityUnbind (seqid,iprot,oprot,handler)
  "resendEmailConfirmation" -> process_resendEmailConfirmation (seqid,iprot,oprot,handler)
  "resendPinCode" -> process_resendPinCode (seqid,iprot,oprot,handler)
  "resendPinCodeBySMS" -> process_resendPinCodeBySMS (seqid,iprot,oprot,handler)
  "sendChatChecked" -> process_sendChatChecked (seqid,iprot,oprot,handler)
  "sendChatRemoved" -> process_sendChatRemoved (seqid,iprot,oprot,handler)
  "sendContentPreviewUpdated" -> process_sendContentPreviewUpdated (seqid,iprot,oprot,handler)
  "sendContentReceipt" -> process_sendContentReceipt (seqid,iprot,oprot,handler)
  "sendDummyPush" -> process_sendDummyPush (seqid,iprot,oprot,handler)
  "sendEvent" -> process_sendEvent (seqid,iprot,oprot,handler)
  "sendMessage" -> process_sendMessage (seqid,iprot,oprot,handler)
  "sendMessageIgnored" -> process_sendMessageIgnored (seqid,iprot,oprot,handler)
  "sendMessageReceipt" -> process_sendMessageReceipt (seqid,iprot,oprot,handler)
  "sendMessageToMyHome" -> process_sendMessageToMyHome (seqid,iprot,oprot,handler)
  "setBuddyLocation" -> process_setBuddyLocation (seqid,iprot,oprot,handler)
  "setIdentityCredential" -> process_setIdentityCredential (seqid,iprot,oprot,handler)
  "setNotificationsEnabled" -> process_setNotificationsEnabled (seqid,iprot,oprot,handler)
  "startUpdateVerification" -> process_startUpdateVerification (seqid,iprot,oprot,handler)
  "startVerification" -> process_startVerification (seqid,iprot,oprot,handler)
  "storeUpdateProfileAttribute" -> process_storeUpdateProfileAttribute (seqid,iprot,oprot,handler)
  "syncContactBySnsIds" -> process_syncContactBySnsIds (seqid,iprot,oprot,handler)
  "syncContacts" -> process_syncContacts (seqid,iprot,oprot,handler)
  "trySendMessage" -> process_trySendMessage (seqid,iprot,oprot,handler)
  "unblockContact" -> process_unblockContact (seqid,iprot,oprot,handler)
  "unblockRecommendation" -> process_unblockRecommendation (seqid,iprot,oprot,handler)
  "unregisterUserAndDevice" -> process_unregisterUserAndDevice (seqid,iprot,oprot,handler)
  "updateApnsDeviceToken" -> process_updateApnsDeviceToken (seqid,iprot,oprot,handler)
  "updateBuddySetting" -> process_updateBuddySetting (seqid,iprot,oprot,handler)
  "updateC2DMRegistrationId" -> process_updateC2DMRegistrationId (seqid,iprot,oprot,handler)
  "updateContactSetting" -> process_updateContactSetting (seqid,iprot,oprot,handler)
  "updateCustomModeSettings" -> process_updateCustomModeSettings (seqid,iprot,oprot,handler)
  "updateDeviceInfo" -> process_updateDeviceInfo (seqid,iprot,oprot,handler)
  "updateGroup" -> process_updateGroup (seqid,iprot,oprot,handler)
  "updateNotificationToken" -> process_updateNotificationToken (seqid,iprot,oprot,handler)
  "updateNotificationTokenWithBytes" -> process_updateNotificationTokenWithBytes (seqid,iprot,oprot,handler)
  "updateProfile" -> process_updateProfile (seqid,iprot,oprot,handler)
  "updateProfileAttribute" -> process_updateProfileAttribute (seqid,iprot,oprot,handler)
  "updateRegion" -> process_updateRegion (seqid,iprot,oprot,handler)
  "updateSettings" -> process_updateSettings (seqid,iprot,oprot,handler)
  "updateSettings2" -> process_updateSettings2 (seqid,iprot,oprot,handler)
  "updateSettingsAttribute" -> process_updateSettingsAttribute (seqid,iprot,oprot,handler)
  "updateSettingsAttributes" -> process_updateSettingsAttributes (seqid,iprot,oprot,handler)
  "verifyIdentityCredential" -> process_verifyIdentityCredential (seqid,iprot,oprot,handler)
  "verifyIdentityCredentialWithResult" -> process_verifyIdentityCredentialWithResult (seqid,iprot,oprot,handler)
  "verifyPhone" -> process_verifyPhone (seqid,iprot,oprot,handler)
  "verifyQrcode" -> process_verifyQrcode (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
