--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'Thrift'
require 'line_ttypes'

TalkServiceClient = __TObject.new(__TClient, {
  __type = 'TalkServiceClient'
})

function TalkServiceClient:acceptGroupInvitation(reqSeq, groupId)
  self:send_acceptGroupInvitation(reqSeq, groupId)
  self:recv_acceptGroupInvitation(reqSeq, groupId)
end

function TalkServiceClient:send_acceptGroupInvitation(reqSeq, groupId)
  self.oprot:writeMessageBegin('acceptGroupInvitation', TMessageType.CALL, self._seqid)
  local args = acceptGroupInvitation_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acceptGroupInvitation(reqSeq, groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acceptGroupInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:acceptProximityMatches(sessionId, ids)
  self:send_acceptProximityMatches(sessionId, ids)
  self:recv_acceptProximityMatches(sessionId, ids)
end

function TalkServiceClient:send_acceptProximityMatches(sessionId, ids)
  self.oprot:writeMessageBegin('acceptProximityMatches', TMessageType.CALL, self._seqid)
  local args = acceptProximityMatches_args:new{}
  args.sessionId = sessionId
  args.ids = ids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acceptProximityMatches(sessionId, ids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acceptProximityMatches_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:acquireCallRoute(to)
  self:send_acquireCallRoute(to)
  return self:recv_acquireCallRoute(to)
end

function TalkServiceClient:send_acquireCallRoute(to)
  self.oprot:writeMessageBegin('acquireCallRoute', TMessageType.CALL, self._seqid)
  local args = acquireCallRoute_args:new{}
  args.to = to
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acquireCallRoute(to)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acquireCallRoute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:acquireCallTicket(to)
  self:send_acquireCallTicket(to)
  return self:recv_acquireCallTicket(to)
end

function TalkServiceClient:send_acquireCallTicket(to)
  self.oprot:writeMessageBegin('acquireCallTicket', TMessageType.CALL, self._seqid)
  local args = acquireCallTicket_args:new{}
  args.to = to
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acquireCallTicket(to)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acquireCallTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:acquireEncryptedAccessToken(featureType)
  self:send_acquireEncryptedAccessToken(featureType)
  return self:recv_acquireEncryptedAccessToken(featureType)
end

function TalkServiceClient:send_acquireEncryptedAccessToken(featureType)
  self.oprot:writeMessageBegin('acquireEncryptedAccessToken', TMessageType.CALL, self._seqid)
  local args = acquireEncryptedAccessToken_args:new{}
  args.featureType = featureType
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acquireEncryptedAccessToken(featureType)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acquireEncryptedAccessToken_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:addSnsId(snsIdType, snsAccessToken)
  self:send_addSnsId(snsIdType, snsAccessToken)
  return self:recv_addSnsId(snsIdType, snsAccessToken)
end

function TalkServiceClient:send_addSnsId(snsIdType, snsAccessToken)
  self.oprot:writeMessageBegin('addSnsId', TMessageType.CALL, self._seqid)
  local args = addSnsId_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_addSnsId(snsIdType, snsAccessToken)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = addSnsId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:blockContact(reqSeq, id)
  self:send_blockContact(reqSeq, id)
  self:recv_blockContact(reqSeq, id)
end

function TalkServiceClient:send_blockContact(reqSeq, id)
  self.oprot:writeMessageBegin('blockContact', TMessageType.CALL, self._seqid)
  local args = blockContact_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_blockContact(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = blockContact_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:blockRecommendation(reqSeq, id)
  self:send_blockRecommendation(reqSeq, id)
  self:recv_blockRecommendation(reqSeq, id)
end

function TalkServiceClient:send_blockRecommendation(reqSeq, id)
  self.oprot:writeMessageBegin('blockRecommendation', TMessageType.CALL, self._seqid)
  local args = blockRecommendation_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_blockRecommendation(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = blockRecommendation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:cancelGroupInvitation(reqSeq, groupId, contactIds)
  self:send_cancelGroupInvitation(reqSeq, groupId, contactIds)
  self:recv_cancelGroupInvitation(reqSeq, groupId, contactIds)
end

function TalkServiceClient:send_cancelGroupInvitation(reqSeq, groupId, contactIds)
  self.oprot:writeMessageBegin('cancelGroupInvitation', TMessageType.CALL, self._seqid)
  local args = cancelGroupInvitation_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_cancelGroupInvitation(reqSeq, groupId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = cancelGroupInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:changeVerificationMethod(sessionId, method)
  self:send_changeVerificationMethod(sessionId, method)
  return self:recv_changeVerificationMethod(sessionId, method)
end

function TalkServiceClient:send_changeVerificationMethod(sessionId, method)
  self.oprot:writeMessageBegin('changeVerificationMethod', TMessageType.CALL, self._seqid)
  local args = changeVerificationMethod_args:new{}
  args.sessionId = sessionId
  args.method = method
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_changeVerificationMethod(sessionId, method)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = changeVerificationMethod_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:clearIdentityCredential()
  self:send_clearIdentityCredential()
  self:recv_clearIdentityCredential()
end

function TalkServiceClient:send_clearIdentityCredential()
  self.oprot:writeMessageBegin('clearIdentityCredential', TMessageType.CALL, self._seqid)
  local args = clearIdentityCredential_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_clearIdentityCredential()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = clearIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:clearMessageBox(channelId, messageBoxId)
  self:send_clearMessageBox(channelId, messageBoxId)
  self:recv_clearMessageBox(channelId, messageBoxId)
end

function TalkServiceClient:send_clearMessageBox(channelId, messageBoxId)
  self.oprot:writeMessageBegin('clearMessageBox', TMessageType.CALL, self._seqid)
  local args = clearMessageBox_args:new{}
  args.channelId = channelId
  args.messageBoxId = messageBoxId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_clearMessageBox(channelId, messageBoxId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = clearMessageBox_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:closeProximityMatch(sessionId)
  self:send_closeProximityMatch(sessionId)
  self:recv_closeProximityMatch(sessionId)
end

function TalkServiceClient:send_closeProximityMatch(sessionId)
  self.oprot:writeMessageBegin('closeProximityMatch', TMessageType.CALL, self._seqid)
  local args = closeProximityMatch_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_closeProximityMatch(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = closeProximityMatch_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:commitSendMessage(seq, messageId, receiverMids)
  self:send_commitSendMessage(seq, messageId, receiverMids)
  return self:recv_commitSendMessage(seq, messageId, receiverMids)
end

function TalkServiceClient:send_commitSendMessage(seq, messageId, receiverMids)
  self.oprot:writeMessageBegin('commitSendMessage', TMessageType.CALL, self._seqid)
  local args = commitSendMessage_args:new{}
  args.seq = seq
  args.messageId = messageId
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_commitSendMessage(seq, messageId, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = commitSendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:commitSendMessages(seq, messageIds, receiverMids)
  self:send_commitSendMessages(seq, messageIds, receiverMids)
  return self:recv_commitSendMessages(seq, messageIds, receiverMids)
end

function TalkServiceClient:send_commitSendMessages(seq, messageIds, receiverMids)
  self.oprot:writeMessageBegin('commitSendMessages', TMessageType.CALL, self._seqid)
  local args = commitSendMessages_args:new{}
  args.seq = seq
  args.messageIds = messageIds
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_commitSendMessages(seq, messageIds, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = commitSendMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:commitUpdateProfile(seq, attrs, receiverMids)
  self:send_commitUpdateProfile(seq, attrs, receiverMids)
  return self:recv_commitUpdateProfile(seq, attrs, receiverMids)
end

function TalkServiceClient:send_commitUpdateProfile(seq, attrs, receiverMids)
  self.oprot:writeMessageBegin('commitUpdateProfile', TMessageType.CALL, self._seqid)
  local args = commitUpdateProfile_args:new{}
  args.seq = seq
  args.attrs = attrs
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_commitUpdateProfile(seq, attrs, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = commitUpdateProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:confirmEmail(verifier, pinCode)
  self:send_confirmEmail(verifier, pinCode)
  self:recv_confirmEmail(verifier, pinCode)
end

function TalkServiceClient:send_confirmEmail(verifier, pinCode)
  self.oprot:writeMessageBegin('confirmEmail', TMessageType.CALL, self._seqid)
  local args = confirmEmail_args:new{}
  args.verifier = verifier
  args.pinCode = pinCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_confirmEmail(verifier, pinCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = confirmEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:createGroup(seq, name, contactIds)
  self:send_createGroup(seq, name, contactIds)
  return self:recv_createGroup(seq, name, contactIds)
end

function TalkServiceClient:send_createGroup(seq, name, contactIds)
  self.oprot:writeMessageBegin('createGroup', TMessageType.CALL, self._seqid)
  local args = createGroup_args:new{}
  args.seq = seq
  args.name = name
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createGroup(seq, name, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  self:send_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  return self:recv_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
end

function TalkServiceClient:send_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  self.oprot:writeMessageBegin('createQrcodeBase64Image', TMessageType.CALL, self._seqid)
  local args = createQrcodeBase64Image_args:new{}
  args.url = url
  args.characterSet = characterSet
  args.imageSize = imageSize
  args.x = x
  args.y = y
  args.width = width
  args.height = height
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createQrcodeBase64Image_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:createRoom(reqSeq, contactIds)
  self:send_createRoom(reqSeq, contactIds)
  return self:recv_createRoom(reqSeq, contactIds)
end

function TalkServiceClient:send_createRoom(reqSeq, contactIds)
  self.oprot:writeMessageBegin('createRoom', TMessageType.CALL, self._seqid)
  local args = createRoom_args:new{}
  args.reqSeq = reqSeq
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createRoom(reqSeq, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:createSession()
  self:send_createSession()
  return self:recv_createSession()
end

function TalkServiceClient:send_createSession()
  self.oprot:writeMessageBegin('createSession', TMessageType.CALL, self._seqid)
  local args = createSession_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createSession()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createSession_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchAnnouncements(lastFetchedIndex)
  self:send_fetchAnnouncements(lastFetchedIndex)
  return self:recv_fetchAnnouncements(lastFetchedIndex)
end

function TalkServiceClient:send_fetchAnnouncements(lastFetchedIndex)
  self.oprot:writeMessageBegin('fetchAnnouncements', TMessageType.CALL, self._seqid)
  local args = fetchAnnouncements_args:new{}
  args.lastFetchedIndex = lastFetchedIndex
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchAnnouncements(lastFetchedIndex)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchAnnouncements_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchMessages(localTs, count)
  self:send_fetchMessages(localTs, count)
  return self:recv_fetchMessages(localTs, count)
end

function TalkServiceClient:send_fetchMessages(localTs, count)
  self.oprot:writeMessageBegin('fetchMessages', TMessageType.CALL, self._seqid)
  local args = fetchMessages_args:new{}
  args.localTs = localTs
  args.count = count
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchMessages(localTs, count)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchOperations(localRev, count)
  self:send_fetchOperations(localRev, count)
  return self:recv_fetchOperations(localRev, count)
end

function TalkServiceClient:send_fetchOperations(localRev, count)
  self.oprot:writeMessageBegin('fetchOperations', TMessageType.CALL, self._seqid)
  local args = fetchOperations_args:new{}
  args.localRev = localRev
  args.count = count
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchOperations(localRev, count)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchOperations_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchOps(localRev, count, globalRev, individualRev)
  self:send_fetchOps(localRev, count, globalRev, individualRev)
  return self:recv_fetchOps(localRev, count, globalRev, individualRev)
end

function TalkServiceClient:send_fetchOps(localRev, count, globalRev, individualRev)
  self.oprot:writeMessageBegin('fetchOps', TMessageType.CALL, self._seqid)
  local args = fetchOps_args:new{}
  args.localRev = localRev
  args.count = count
  args.globalRev = globalRev
  args.individualRev = individualRev
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchOps(localRev, count, globalRev, individualRev)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchOps_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findAndAddContactsByEmail(reqSeq, emails)
  self:send_findAndAddContactsByEmail(reqSeq, emails)
  return self:recv_findAndAddContactsByEmail(reqSeq, emails)
end

function TalkServiceClient:send_findAndAddContactsByEmail(reqSeq, emails)
  self.oprot:writeMessageBegin('findAndAddContactsByEmail', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByEmail_args:new{}
  args.reqSeq = reqSeq
  args.emails = emails
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByEmail(reqSeq, emails)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findAndAddContactsByMid(reqSeq, mid)
  self:send_findAndAddContactsByMid(reqSeq, mid)
  return self:recv_findAndAddContactsByMid(reqSeq, mid)
end

function TalkServiceClient:send_findAndAddContactsByMid(reqSeq, mid)
  self.oprot:writeMessageBegin('findAndAddContactsByMid', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByMid_args:new{}
  args.reqSeq = reqSeq
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByMid(reqSeq, mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByMid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findAndAddContactsByPhone(reqSeq, phones)
  self:send_findAndAddContactsByPhone(reqSeq, phones)
  return self:recv_findAndAddContactsByPhone(reqSeq, phones)
end

function TalkServiceClient:send_findAndAddContactsByPhone(reqSeq, phones)
  self.oprot:writeMessageBegin('findAndAddContactsByPhone', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByPhone_args:new{}
  args.reqSeq = reqSeq
  args.phones = phones
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByPhone(reqSeq, phones)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByPhone_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findAndAddContactsByUserid(reqSeq, userid)
  self:send_findAndAddContactsByUserid(reqSeq, userid)
  return self:recv_findAndAddContactsByUserid(reqSeq, userid)
end

function TalkServiceClient:send_findAndAddContactsByUserid(reqSeq, userid)
  self.oprot:writeMessageBegin('findAndAddContactsByUserid', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByUserid_args:new{}
  args.reqSeq = reqSeq
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByUserid(reqSeq, userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactByUserid(userid)
  self:send_findContactByUserid(userid)
  return self:recv_findContactByUserid(userid)
end

function TalkServiceClient:send_findContactByUserid(userid)
  self.oprot:writeMessageBegin('findContactByUserid', TMessageType.CALL, self._seqid)
  local args = findContactByUserid_args:new{}
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactByUserid(userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactByUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactByUserTicket(ticketId)
  self:send_findContactByUserTicket(ticketId)
  return self:recv_findContactByUserTicket(ticketId)
end

function TalkServiceClient:send_findContactByUserTicket(ticketId)
  self.oprot:writeMessageBegin('findContactByUserTicket', TMessageType.CALL, self._seqid)
  local args = findContactByUserTicket_args:new{}
  args.ticketId = ticketId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactByUserTicket(ticketId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactByUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactsByEmail(emails)
  self:send_findContactsByEmail(emails)
  return self:recv_findContactsByEmail(emails)
end

function TalkServiceClient:send_findContactsByEmail(emails)
  self.oprot:writeMessageBegin('findContactsByEmail', TMessageType.CALL, self._seqid)
  local args = findContactsByEmail_args:new{}
  args.emails = emails
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactsByEmail(emails)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactsByEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactsByPhone(phones)
  self:send_findContactsByPhone(phones)
  return self:recv_findContactsByPhone(phones)
end

function TalkServiceClient:send_findContactsByPhone(phones)
  self.oprot:writeMessageBegin('findContactsByPhone', TMessageType.CALL, self._seqid)
  local args = findContactsByPhone_args:new{}
  args.phones = phones
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactsByPhone(phones)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactsByPhone_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  self:send_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  return self:recv_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
end

function TalkServiceClient:send_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  self.oprot:writeMessageBegin('findSnsIdUserStatus', TMessageType.CALL, self._seqid)
  local args = findSnsIdUserStatus_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args.udidHash = udidHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findSnsIdUserStatus_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:finishUpdateVerification(sessionId)
  self:send_finishUpdateVerification(sessionId)
  self:recv_finishUpdateVerification(sessionId)
end

function TalkServiceClient:send_finishUpdateVerification(sessionId)
  self.oprot:writeMessageBegin('finishUpdateVerification', TMessageType.CALL, self._seqid)
  local args = finishUpdateVerification_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_finishUpdateVerification(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = finishUpdateVerification_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:generateUserTicket(expirationTime, maxUseCount)
  self:send_generateUserTicket(expirationTime, maxUseCount)
  return self:recv_generateUserTicket(expirationTime, maxUseCount)
end

function TalkServiceClient:send_generateUserTicket(expirationTime, maxUseCount)
  self.oprot:writeMessageBegin('generateUserTicket', TMessageType.CALL, self._seqid)
  local args = generateUserTicket_args:new{}
  args.expirationTime = expirationTime
  args.maxUseCount = maxUseCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_generateUserTicket(expirationTime, maxUseCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = generateUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getAcceptedProximityMatches(sessionId)
  self:send_getAcceptedProximityMatches(sessionId)
  return self:recv_getAcceptedProximityMatches(sessionId)
end

function TalkServiceClient:send_getAcceptedProximityMatches(sessionId)
  self.oprot:writeMessageBegin('getAcceptedProximityMatches', TMessageType.CALL, self._seqid)
  local args = getAcceptedProximityMatches_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getAcceptedProximityMatches(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getAcceptedProximityMatches_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getActiveBuddySubscriberIds()
  self:send_getActiveBuddySubscriberIds()
  return self:recv_getActiveBuddySubscriberIds()
end

function TalkServiceClient:send_getActiveBuddySubscriberIds()
  self.oprot:writeMessageBegin('getActiveBuddySubscriberIds', TMessageType.CALL, self._seqid)
  local args = getActiveBuddySubscriberIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getActiveBuddySubscriberIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getActiveBuddySubscriberIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getAllContactIds()
  self:send_getAllContactIds()
  return self:recv_getAllContactIds()
end

function TalkServiceClient:send_getAllContactIds()
  self.oprot:writeMessageBegin('getAllContactIds', TMessageType.CALL, self._seqid)
  local args = getAllContactIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getAllContactIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getAllContactIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getAuthQrcode(keepLoggedIn, systemName)
  self:send_getAuthQrcode(keepLoggedIn, systemName)
  return self:recv_getAuthQrcode(keepLoggedIn, systemName)
end

function TalkServiceClient:send_getAuthQrcode(keepLoggedIn, systemName)
  self.oprot:writeMessageBegin('getAuthQrcode', TMessageType.CALL, self._seqid)
  local args = getAuthQrcode_args:new{}
  args.keepLoggedIn = keepLoggedIn
  args.systemName = systemName
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getAuthQrcode(keepLoggedIn, systemName)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getAuthQrcode_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBlockedContactIds()
  self:send_getBlockedContactIds()
  return self:recv_getBlockedContactIds()
end

function TalkServiceClient:send_getBlockedContactIds()
  self.oprot:writeMessageBegin('getBlockedContactIds', TMessageType.CALL, self._seqid)
  local args = getBlockedContactIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBlockedContactIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBlockedContactIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBlockedContactIdsByRange(start, count)
  self:send_getBlockedContactIdsByRange(start, count)
  return self:recv_getBlockedContactIdsByRange(start, count)
end

function TalkServiceClient:send_getBlockedContactIdsByRange(start, count)
  self.oprot:writeMessageBegin('getBlockedContactIdsByRange', TMessageType.CALL, self._seqid)
  local args = getBlockedContactIdsByRange_args:new{}
  args.start = start
  args.count = count
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBlockedContactIdsByRange(start, count)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBlockedContactIdsByRange_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBlockedRecommendationIds()
  self:send_getBlockedRecommendationIds()
  return self:recv_getBlockedRecommendationIds()
end

function TalkServiceClient:send_getBlockedRecommendationIds()
  self.oprot:writeMessageBegin('getBlockedRecommendationIds', TMessageType.CALL, self._seqid)
  local args = getBlockedRecommendationIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBlockedRecommendationIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBlockedRecommendationIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBuddyBlockerIds()
  self:send_getBuddyBlockerIds()
  return self:recv_getBuddyBlockerIds()
end

function TalkServiceClient:send_getBuddyBlockerIds()
  self.oprot:writeMessageBegin('getBuddyBlockerIds', TMessageType.CALL, self._seqid)
  local args = getBuddyBlockerIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBuddyBlockerIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBuddyBlockerIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBuddyLocation(mid, index)
  self:send_getBuddyLocation(mid, index)
  return self:recv_getBuddyLocation(mid, index)
end

function TalkServiceClient:send_getBuddyLocation(mid, index)
  self.oprot:writeMessageBegin('getBuddyLocation', TMessageType.CALL, self._seqid)
  local args = getBuddyLocation_args:new{}
  args.mid = mid
  args.index = index
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBuddyLocation(mid, index)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBuddyLocation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCompactContactsModifiedSince(timestamp)
  self:send_getCompactContactsModifiedSince(timestamp)
  return self:recv_getCompactContactsModifiedSince(timestamp)
end

function TalkServiceClient:send_getCompactContactsModifiedSince(timestamp)
  self.oprot:writeMessageBegin('getCompactContactsModifiedSince', TMessageType.CALL, self._seqid)
  local args = getCompactContactsModifiedSince_args:new{}
  args.timestamp = timestamp
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCompactContactsModifiedSince(timestamp)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCompactContactsModifiedSince_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCompactGroup(groupId)
  self:send_getCompactGroup(groupId)
  return self:recv_getCompactGroup(groupId)
end

function TalkServiceClient:send_getCompactGroup(groupId)
  self.oprot:writeMessageBegin('getCompactGroup', TMessageType.CALL, self._seqid)
  local args = getCompactGroup_args:new{}
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCompactGroup(groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCompactGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCompactRoom(roomId)
  self:send_getCompactRoom(roomId)
  return self:recv_getCompactRoom(roomId)
end

function TalkServiceClient:send_getCompactRoom(roomId)
  self.oprot:writeMessageBegin('getCompactRoom', TMessageType.CALL, self._seqid)
  local args = getCompactRoom_args:new{}
  args.roomId = roomId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCompactRoom(roomId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCompactRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getContact(id)
  self:send_getContact(id)
  return self:recv_getContact(id)
end

function TalkServiceClient:send_getContact(id)
  self.oprot:writeMessageBegin('getContact', TMessageType.CALL, self._seqid)
  local args = getContact_args:new{}
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getContact(id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getContact_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getContacts(ids)
  self:send_getContacts(ids)
  return self:recv_getContacts(ids)
end

function TalkServiceClient:send_getContacts(ids)
  self.oprot:writeMessageBegin('getContacts', TMessageType.CALL, self._seqid)
  local args = getContacts_args:new{}
  args.ids = ids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getContacts(ids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getContacts_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCountryWithRequestIp()
  self:send_getCountryWithRequestIp()
  return self:recv_getCountryWithRequestIp()
end

function TalkServiceClient:send_getCountryWithRequestIp()
  self.oprot:writeMessageBegin('getCountryWithRequestIp', TMessageType.CALL, self._seqid)
  local args = getCountryWithRequestIp_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCountryWithRequestIp()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCountryWithRequestIp_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getFavoriteMids()
  self:send_getFavoriteMids()
  return self:recv_getFavoriteMids()
end

function TalkServiceClient:send_getFavoriteMids()
  self.oprot:writeMessageBegin('getFavoriteMids', TMessageType.CALL, self._seqid)
  local args = getFavoriteMids_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getFavoriteMids()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getFavoriteMids_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroup(groupId)
  self:send_getGroup(groupId)
  return self:recv_getGroup(groupId)
end

function TalkServiceClient:send_getGroup(groupId)
  self.oprot:writeMessageBegin('getGroup', TMessageType.CALL, self._seqid)
  local args = getGroup_args:new{}
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroup(groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroupIdsInvited()
  self:send_getGroupIdsInvited()
  return self:recv_getGroupIdsInvited()
end

function TalkServiceClient:send_getGroupIdsInvited()
  self.oprot:writeMessageBegin('getGroupIdsInvited', TMessageType.CALL, self._seqid)
  local args = getGroupIdsInvited_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroupIdsInvited()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroupIdsInvited_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroupIdsJoined()
  self:send_getGroupIdsJoined()
  return self:recv_getGroupIdsJoined()
end

function TalkServiceClient:send_getGroupIdsJoined()
  self.oprot:writeMessageBegin('getGroupIdsJoined', TMessageType.CALL, self._seqid)
  local args = getGroupIdsJoined_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroupIdsJoined()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroupIdsJoined_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroups(groupIds)
  self:send_getGroups(groupIds)
  return self:recv_getGroups(groupIds)
end

function TalkServiceClient:send_getGroups(groupIds)
  self.oprot:writeMessageBegin('getGroups', TMessageType.CALL, self._seqid)
  local args = getGroups_args:new{}
  args.groupIds = groupIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroups(groupIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroups_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getHiddenContactMids()
  self:send_getHiddenContactMids()
  return self:recv_getHiddenContactMids()
end

function TalkServiceClient:send_getHiddenContactMids()
  self.oprot:writeMessageBegin('getHiddenContactMids', TMessageType.CALL, self._seqid)
  local args = getHiddenContactMids_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getHiddenContactMids()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getHiddenContactMids_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getIdentityIdentifier()
  self:send_getIdentityIdentifier()
  return self:recv_getIdentityIdentifier()
end

function TalkServiceClient:send_getIdentityIdentifier()
  self.oprot:writeMessageBegin('getIdentityIdentifier', TMessageType.CALL, self._seqid)
  local args = getIdentityIdentifier_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getIdentityIdentifier()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getIdentityIdentifier_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getLastAnnouncementIndex()
  self:send_getLastAnnouncementIndex()
  return self:recv_getLastAnnouncementIndex()
end

function TalkServiceClient:send_getLastAnnouncementIndex()
  self.oprot:writeMessageBegin('getLastAnnouncementIndex', TMessageType.CALL, self._seqid)
  local args = getLastAnnouncementIndex_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getLastAnnouncementIndex()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getLastAnnouncementIndex_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getLastOpRevision()
  self:send_getLastOpRevision()
  return self:recv_getLastOpRevision()
end

function TalkServiceClient:send_getLastOpRevision()
  self.oprot:writeMessageBegin('getLastOpRevision', TMessageType.CALL, self._seqid)
  local args = getLastOpRevision_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getLastOpRevision()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getLastOpRevision_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBox(channelId, messageBoxId, lastMessagesCount)
  self:send_getMessageBox(channelId, messageBoxId, lastMessagesCount)
  return self:recv_getMessageBox(channelId, messageBoxId, lastMessagesCount)
end

function TalkServiceClient:send_getMessageBox(channelId, messageBoxId, lastMessagesCount)
  self.oprot:writeMessageBegin('getMessageBox', TMessageType.CALL, self._seqid)
  local args = getMessageBox_args:new{}
  args.channelId = channelId
  args.messageBoxId = messageBoxId
  args.lastMessagesCount = lastMessagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBox(channelId, messageBoxId, lastMessagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBox_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxCompactWrapUp(mid)
  self:send_getMessageBoxCompactWrapUp(mid)
  return self:recv_getMessageBoxCompactWrapUp(mid)
end

function TalkServiceClient:send_getMessageBoxCompactWrapUp(mid)
  self.oprot:writeMessageBegin('getMessageBoxCompactWrapUp', TMessageType.CALL, self._seqid)
  local args = getMessageBoxCompactWrapUp_args:new{}
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxCompactWrapUp(mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxCompactWrapUp_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxCompactWrapUpList(start, messageBoxCount)
  self:send_getMessageBoxCompactWrapUpList(start, messageBoxCount)
  return self:recv_getMessageBoxCompactWrapUpList(start, messageBoxCount)
end

function TalkServiceClient:send_getMessageBoxCompactWrapUpList(start, messageBoxCount)
  self.oprot:writeMessageBegin('getMessageBoxCompactWrapUpList', TMessageType.CALL, self._seqid)
  local args = getMessageBoxCompactWrapUpList_args:new{}
  args.start = start
  args.messageBoxCount = messageBoxCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxCompactWrapUpList(start, messageBoxCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxCompactWrapUpList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxList(channelId, lastMessagesCount)
  self:send_getMessageBoxList(channelId, lastMessagesCount)
  return self:recv_getMessageBoxList(channelId, lastMessagesCount)
end

function TalkServiceClient:send_getMessageBoxList(channelId, lastMessagesCount)
  self.oprot:writeMessageBegin('getMessageBoxList', TMessageType.CALL, self._seqid)
  local args = getMessageBoxList_args:new{}
  args.channelId = channelId
  args.lastMessagesCount = lastMessagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxList(channelId, lastMessagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  self:send_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  return self:recv_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
end

function TalkServiceClient:send_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  self.oprot:writeMessageBegin('getMessageBoxListByStatus', TMessageType.CALL, self._seqid)
  local args = getMessageBoxListByStatus_args:new{}
  args.channelId = channelId
  args.lastMessagesCount = lastMessagesCount
  args.status = status
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxListByStatus_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxWrapUp(mid)
  self:send_getMessageBoxWrapUp(mid)
  return self:recv_getMessageBoxWrapUp(mid)
end

function TalkServiceClient:send_getMessageBoxWrapUp(mid)
  self.oprot:writeMessageBegin('getMessageBoxWrapUp', TMessageType.CALL, self._seqid)
  local args = getMessageBoxWrapUp_args:new{}
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxWrapUp(mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxWrapUp_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxWrapUpList(start, messageBoxCount)
  self:send_getMessageBoxWrapUpList(start, messageBoxCount)
  return self:recv_getMessageBoxWrapUpList(start, messageBoxCount)
end

function TalkServiceClient:send_getMessageBoxWrapUpList(start, messageBoxCount)
  self.oprot:writeMessageBegin('getMessageBoxWrapUpList', TMessageType.CALL, self._seqid)
  local args = getMessageBoxWrapUpList_args:new{}
  args.start = start
  args.messageBoxCount = messageBoxCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxWrapUpList(start, messageBoxCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxWrapUpList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  self:send_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  return self:recv_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
end

function TalkServiceClient:send_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  self.oprot:writeMessageBegin('getMessagesBySequenceNumber', TMessageType.CALL, self._seqid)
  local args = getMessagesBySequenceNumber_args:new{}
  args.channelId = channelId
  args.messageBoxId = messageBoxId
  args.startSeq = startSeq
  args.endSeq = endSeq
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessagesBySequenceNumber_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getNextMessages(messageBoxId, startSeq, messagesCount)
  self:send_getNextMessages(messageBoxId, startSeq, messagesCount)
  return self:recv_getNextMessages(messageBoxId, startSeq, messagesCount)
end

function TalkServiceClient:send_getNextMessages(messageBoxId, startSeq, messagesCount)
  self.oprot:writeMessageBegin('getNextMessages', TMessageType.CALL, self._seqid)
  local args = getNextMessages_args:new{}
  args.messageBoxId = messageBoxId
  args.startSeq = startSeq
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getNextMessages(messageBoxId, startSeq, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getNextMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getNotificationPolicy(carrier)
  self:send_getNotificationPolicy(carrier)
  return self:recv_getNotificationPolicy(carrier)
end

function TalkServiceClient:send_getNotificationPolicy(carrier)
  self.oprot:writeMessageBegin('getNotificationPolicy', TMessageType.CALL, self._seqid)
  local args = getNotificationPolicy_args:new{}
  args.carrier = carrier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getNotificationPolicy(carrier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getNotificationPolicy_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getPreviousMessages(messageBoxId, endSeq, messagesCount)
  self:send_getPreviousMessages(messageBoxId, endSeq, messagesCount)
  return self:recv_getPreviousMessages(messageBoxId, endSeq, messagesCount)
end

function TalkServiceClient:send_getPreviousMessages(messageBoxId, endSeq, messagesCount)
  self.oprot:writeMessageBegin('getPreviousMessages', TMessageType.CALL, self._seqid)
  local args = getPreviousMessages_args:new{}
  args.messageBoxId = messageBoxId
  args.endSeq = endSeq
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getPreviousMessages(messageBoxId, endSeq, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getPreviousMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getProfile()
  self:send_getProfile()
  return self:recv_getProfile()
end

function TalkServiceClient:send_getProfile()
  self.oprot:writeMessageBegin('getProfile', TMessageType.CALL, self._seqid)
  local args = getProfile_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getProfile()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getProximityMatchCandidateList(sessionId)
  self:send_getProximityMatchCandidateList(sessionId)
  return self:recv_getProximityMatchCandidateList(sessionId)
end

function TalkServiceClient:send_getProximityMatchCandidateList(sessionId)
  self.oprot:writeMessageBegin('getProximityMatchCandidateList', TMessageType.CALL, self._seqid)
  local args = getProximityMatchCandidateList_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getProximityMatchCandidateList(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProximityMatchCandidateList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getProximityMatchCandidates(sessionId)
  self:send_getProximityMatchCandidates(sessionId)
  return self:recv_getProximityMatchCandidates(sessionId)
end

function TalkServiceClient:send_getProximityMatchCandidates(sessionId)
  self.oprot:writeMessageBegin('getProximityMatchCandidates', TMessageType.CALL, self._seqid)
  local args = getProximityMatchCandidates_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getProximityMatchCandidates(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProximityMatchCandidates_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRecentMessages(messageBoxId, messagesCount)
  self:send_getRecentMessages(messageBoxId, messagesCount)
  return self:recv_getRecentMessages(messageBoxId, messagesCount)
end

function TalkServiceClient:send_getRecentMessages(messageBoxId, messagesCount)
  self.oprot:writeMessageBegin('getRecentMessages', TMessageType.CALL, self._seqid)
  local args = getRecentMessages_args:new{}
  args.messageBoxId = messageBoxId
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRecentMessages(messageBoxId, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRecentMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRecommendationIds()
  self:send_getRecommendationIds()
  return self:recv_getRecommendationIds()
end

function TalkServiceClient:send_getRecommendationIds()
  self.oprot:writeMessageBegin('getRecommendationIds', TMessageType.CALL, self._seqid)
  local args = getRecommendationIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRecommendationIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRecommendationIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRoom(roomId)
  self:send_getRoom(roomId)
  return self:recv_getRoom(roomId)
end

function TalkServiceClient:send_getRoom(roomId)
  self.oprot:writeMessageBegin('getRoom', TMessageType.CALL, self._seqid)
  local args = getRoom_args:new{}
  args.roomId = roomId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRoom(roomId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRSAKeyInfo(provider)
  self:send_getRSAKeyInfo(provider)
  return self:recv_getRSAKeyInfo(provider)
end

function TalkServiceClient:send_getRSAKeyInfo(provider)
  self.oprot:writeMessageBegin('getRSAKeyInfo', TMessageType.CALL, self._seqid)
  local args = getRSAKeyInfo_args:new{}
  args.provider = provider
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRSAKeyInfo(provider)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRSAKeyInfo_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getServerTime()
  self:send_getServerTime()
  return self:recv_getServerTime()
end

function TalkServiceClient:send_getServerTime()
  self.oprot:writeMessageBegin('getServerTime', TMessageType.CALL, self._seqid)
  local args = getServerTime_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getServerTime()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getServerTime_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSessions()
  self:send_getSessions()
  return self:recv_getSessions()
end

function TalkServiceClient:send_getSessions()
  self.oprot:writeMessageBegin('getSessions', TMessageType.CALL, self._seqid)
  local args = getSessions_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSessions()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSessions_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSettings()
  self:send_getSettings()
  return self:recv_getSettings()
end

function TalkServiceClient:send_getSettings()
  self.oprot:writeMessageBegin('getSettings', TMessageType.CALL, self._seqid)
  local args = getSettings_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSettings()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSettingsAttributes(attrBitset)
  self:send_getSettingsAttributes(attrBitset)
  return self:recv_getSettingsAttributes(attrBitset)
end

function TalkServiceClient:send_getSettingsAttributes(attrBitset)
  self.oprot:writeMessageBegin('getSettingsAttributes', TMessageType.CALL, self._seqid)
  local args = getSettingsAttributes_args:new{}
  args.attrBitset = attrBitset
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSettingsAttributes(attrBitset)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSettingsAttributes_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSystemConfiguration()
  self:send_getSystemConfiguration()
  return self:recv_getSystemConfiguration()
end

function TalkServiceClient:send_getSystemConfiguration()
  self.oprot:writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
  local args = getSystemConfiguration_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSystemConfiguration()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSystemConfiguration_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getUserTicket()
  self:send_getUserTicket()
  return self:recv_getUserTicket()
end

function TalkServiceClient:send_getUserTicket()
  self.oprot:writeMessageBegin('getUserTicket', TMessageType.CALL, self._seqid)
  local args = getUserTicket_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getUserTicket()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getWapInvitation(invitationHash)
  self:send_getWapInvitation(invitationHash)
  return self:recv_getWapInvitation(invitationHash)
end

function TalkServiceClient:send_getWapInvitation(invitationHash)
  self.oprot:writeMessageBegin('getWapInvitation', TMessageType.CALL, self._seqid)
  local args = getWapInvitation_args:new{}
  args.invitationHash = invitationHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getWapInvitation(invitationHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getWapInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:invalidateUserTicket()
  self:send_invalidateUserTicket()
  self:recv_invalidateUserTicket()
end

function TalkServiceClient:send_invalidateUserTicket()
  self.oprot:writeMessageBegin('invalidateUserTicket', TMessageType.CALL, self._seqid)
  local args = invalidateUserTicket_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_invalidateUserTicket()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = invalidateUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteFriendsBySms(phoneNumberList)
  self:send_inviteFriendsBySms(phoneNumberList)
  self:recv_inviteFriendsBySms(phoneNumberList)
end

function TalkServiceClient:send_inviteFriendsBySms(phoneNumberList)
  self.oprot:writeMessageBegin('inviteFriendsBySms', TMessageType.CALL, self._seqid)
  local args = inviteFriendsBySms_args:new{}
  args.phoneNumberList = phoneNumberList
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteFriendsBySms(phoneNumberList)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteFriendsBySms_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteIntoGroup(reqSeq, groupId, contactIds)
  self:send_inviteIntoGroup(reqSeq, groupId, contactIds)
  self:recv_inviteIntoGroup(reqSeq, groupId, contactIds)
end

function TalkServiceClient:send_inviteIntoGroup(reqSeq, groupId, contactIds)
  self.oprot:writeMessageBegin('inviteIntoGroup', TMessageType.CALL, self._seqid)
  local args = inviteIntoGroup_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteIntoGroup(reqSeq, groupId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteIntoGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteIntoRoom(reqSeq, roomId, contactIds)
  self:send_inviteIntoRoom(reqSeq, roomId, contactIds)
  self:recv_inviteIntoRoom(reqSeq, roomId, contactIds)
end

function TalkServiceClient:send_inviteIntoRoom(reqSeq, roomId, contactIds)
  self.oprot:writeMessageBegin('inviteIntoRoom', TMessageType.CALL, self._seqid)
  local args = inviteIntoRoom_args:new{}
  args.reqSeq = reqSeq
  args.roomId = roomId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteIntoRoom(reqSeq, roomId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteIntoRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteViaEmail(reqSeq, email, name)
  self:send_inviteViaEmail(reqSeq, email, name)
  self:recv_inviteViaEmail(reqSeq, email, name)
end

function TalkServiceClient:send_inviteViaEmail(reqSeq, email, name)
  self.oprot:writeMessageBegin('inviteViaEmail', TMessageType.CALL, self._seqid)
  local args = inviteViaEmail_args:new{}
  args.reqSeq = reqSeq
  args.email = email
  args.name = name
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteViaEmail(reqSeq, email, name)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteViaEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:isIdentityIdentifierAvailable(provider, identifier)
  self:send_isIdentityIdentifierAvailable(provider, identifier)
  return self:recv_isIdentityIdentifierAvailable(provider, identifier)
end

function TalkServiceClient:send_isIdentityIdentifierAvailable(provider, identifier)
  self.oprot:writeMessageBegin('isIdentityIdentifierAvailable', TMessageType.CALL, self._seqid)
  local args = isIdentityIdentifierAvailable_args:new{}
  args.provider = provider
  args.identifier = identifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_isIdentityIdentifierAvailable(provider, identifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = isIdentityIdentifierAvailable_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:isUseridAvailable(userid)
  self:send_isUseridAvailable(userid)
  return self:recv_isUseridAvailable(userid)
end

function TalkServiceClient:send_isUseridAvailable(userid)
  self.oprot:writeMessageBegin('isUseridAvailable', TMessageType.CALL, self._seqid)
  local args = isUseridAvailable_args:new{}
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_isUseridAvailable(userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = isUseridAvailable_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:kickoutFromGroup(reqSeq, groupId, contactIds)
  self:send_kickoutFromGroup(reqSeq, groupId, contactIds)
  self:recv_kickoutFromGroup(reqSeq, groupId, contactIds)
end

function TalkServiceClient:send_kickoutFromGroup(reqSeq, groupId, contactIds)
  self.oprot:writeMessageBegin('kickoutFromGroup', TMessageType.CALL, self._seqid)
  local args = kickoutFromGroup_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_kickoutFromGroup(reqSeq, groupId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = kickoutFromGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:leaveGroup(reqSeq, groupId)
  self:send_leaveGroup(reqSeq, groupId)
  self:recv_leaveGroup(reqSeq, groupId)
end

function TalkServiceClient:send_leaveGroup(reqSeq, groupId)
  self.oprot:writeMessageBegin('leaveGroup', TMessageType.CALL, self._seqid)
  local args = leaveGroup_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_leaveGroup(reqSeq, groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = leaveGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:leaveRoom(reqSeq, roomId)
  self:send_leaveRoom(reqSeq, roomId)
  self:recv_leaveRoom(reqSeq, roomId)
end

function TalkServiceClient:send_leaveRoom(reqSeq, roomId)
  self.oprot:writeMessageBegin('leaveRoom', TMessageType.CALL, self._seqid)
  local args = leaveRoom_args:new{}
  args.reqSeq = reqSeq
  args.roomId = roomId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_leaveRoom(reqSeq, roomId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = leaveRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self:send_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  return self:recv_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
end

function TalkServiceClient:send_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self.oprot:writeMessageBegin('loginWithIdentityCredential', TMessageType.CALL, self._seqid)
  local args = loginWithIdentityCredential_args:new{}
  args.identityProvider = identityProvider
  args.identifier = identifier
  args.password = password
  args.keepLoggedIn = keepLoggedIn
  args.accessLocation = accessLocation
  args.systemName = systemName
  args.certificate = certificate
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self:send_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  return self:recv_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
end

function TalkServiceClient:send_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self.oprot:writeMessageBegin('loginWithIdentityCredentialForCertificate', TMessageType.CALL, self._seqid)
  local args = loginWithIdentityCredentialForCertificate_args:new{}
  args.identityProvider = identityProvider
  args.identifier = identifier
  args.password = password
  args.keepLoggedIn = keepLoggedIn
  args.accessLocation = accessLocation
  args.systemName = systemName
  args.certificate = certificate
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithIdentityCredentialForCertificate_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithVerifier(verifier)
  self:send_loginWithVerifier(verifier)
  return self:recv_loginWithVerifier(verifier)
end

function TalkServiceClient:send_loginWithVerifier(verifier)
  self.oprot:writeMessageBegin('loginWithVerifier', TMessageType.CALL, self._seqid)
  local args = loginWithVerifier_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithVerifier(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithVerifier_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithVerifierForCerificate(verifier)
  self:send_loginWithVerifierForCerificate(verifier)
  return self:recv_loginWithVerifierForCerificate(verifier)
end

function TalkServiceClient:send_loginWithVerifierForCerificate(verifier)
  self.oprot:writeMessageBegin('loginWithVerifierForCerificate', TMessageType.CALL, self._seqid)
  local args = loginWithVerifierForCerificate_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithVerifierForCerificate(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithVerifierForCerificate_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithVerifierForCertificate(verifier)
  self:send_loginWithVerifierForCertificate(verifier)
  return self:recv_loginWithVerifierForCertificate(verifier)
end

function TalkServiceClient:send_loginWithVerifierForCertificate(verifier)
  self.oprot:writeMessageBegin('loginWithVerifierForCertificate', TMessageType.CALL, self._seqid)
  local args = loginWithVerifierForCertificate_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithVerifierForCertificate(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithVerifierForCertificate_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:logout()
  self:send_logout()
  self:recv_logout()
end

function TalkServiceClient:send_logout()
  self.oprot:writeMessageBegin('logout', TMessageType.CALL, self._seqid)
  local args = logout_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_logout()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = logout_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:logoutSession(tokenKey)
  self:send_logoutSession(tokenKey)
  self:recv_logoutSession(tokenKey)
end

function TalkServiceClient:send_logoutSession(tokenKey)
  self.oprot:writeMessageBegin('logoutSession', TMessageType.CALL, self._seqid)
  local args = logoutSession_args:new{}
  args.tokenKey = tokenKey
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_logoutSession(tokenKey)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = logoutSession_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:noop()
  self:send_noop()
  self:recv_noop()
end

function TalkServiceClient:send_noop()
  self.oprot:writeMessageBegin('noop', TMessageType.CALL, self._seqid)
  local args = noop_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_noop()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = noop_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifiedRedirect(paramMap)
  self:send_notifiedRedirect(paramMap)
  self:recv_notifiedRedirect(paramMap)
end

function TalkServiceClient:send_notifiedRedirect(paramMap)
  self.oprot:writeMessageBegin('notifiedRedirect', TMessageType.CALL, self._seqid)
  local args = notifiedRedirect_args:new{}
  args.paramMap = paramMap
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifiedRedirect(paramMap)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifiedRedirect_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyBuddyOnAir(seq, receiverMids)
  self:send_notifyBuddyOnAir(seq, receiverMids)
  return self:recv_notifyBuddyOnAir(seq, receiverMids)
end

function TalkServiceClient:send_notifyBuddyOnAir(seq, receiverMids)
  self.oprot:writeMessageBegin('notifyBuddyOnAir', TMessageType.CALL, self._seqid)
  local args = notifyBuddyOnAir_args:new{}
  args.seq = seq
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyBuddyOnAir(seq, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyBuddyOnAir_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:notifyIndividualEvent(notificationStatus, receiverMids)
  self:send_notifyIndividualEvent(notificationStatus, receiverMids)
  self:recv_notifyIndividualEvent(notificationStatus, receiverMids)
end

function TalkServiceClient:send_notifyIndividualEvent(notificationStatus, receiverMids)
  self.oprot:writeMessageBegin('notifyIndividualEvent', TMessageType.CALL, self._seqid)
  local args = notifyIndividualEvent_args:new{}
  args.notificationStatus = notificationStatus
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyIndividualEvent(notificationStatus, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyIndividualEvent_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyInstalled(udidHash, applicationTypeWithExtensions)
  self:send_notifyInstalled(udidHash, applicationTypeWithExtensions)
  self:recv_notifyInstalled(udidHash, applicationTypeWithExtensions)
end

function TalkServiceClient:send_notifyInstalled(udidHash, applicationTypeWithExtensions)
  self.oprot:writeMessageBegin('notifyInstalled', TMessageType.CALL, self._seqid)
  local args = notifyInstalled_args:new{}
  args.udidHash = udidHash
  args.applicationTypeWithExtensions = applicationTypeWithExtensions
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyInstalled(udidHash, applicationTypeWithExtensions)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyInstalled_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  self:send_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  self:recv_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
end

function TalkServiceClient:send_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  self.oprot:writeMessageBegin('notifyRegistrationComplete', TMessageType.CALL, self._seqid)
  local args = notifyRegistrationComplete_args:new{}
  args.udidHash = udidHash
  args.applicationTypeWithExtensions = applicationTypeWithExtensions
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyRegistrationComplete_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifySleep(lastRev, badge)
  self:send_notifySleep(lastRev, badge)
  self:recv_notifySleep(lastRev, badge)
end

function TalkServiceClient:send_notifySleep(lastRev, badge)
  self.oprot:writeMessageBegin('notifySleep', TMessageType.CALL, self._seqid)
  local args = notifySleep_args:new{}
  args.lastRev = lastRev
  args.badge = badge
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifySleep(lastRev, badge)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifySleep_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyUpdated(lastRev, deviceInfo)
  self:send_notifyUpdated(lastRev, deviceInfo)
  self:recv_notifyUpdated(lastRev, deviceInfo)
end

function TalkServiceClient:send_notifyUpdated(lastRev, deviceInfo)
  self.oprot:writeMessageBegin('notifyUpdated', TMessageType.CALL, self._seqid)
  local args = notifyUpdated_args:new{}
  args.lastRev = lastRev
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyUpdated(lastRev, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyUpdated_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:openProximityMatch(location)
  self:send_openProximityMatch(location)
  return self:recv_openProximityMatch(location)
end

function TalkServiceClient:send_openProximityMatch(location)
  self.oprot:writeMessageBegin('openProximityMatch', TMessageType.CALL, self._seqid)
  local args = openProximityMatch_args:new{}
  args.location = location
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_openProximityMatch(location)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = openProximityMatch_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerBuddyUser(buddyId, registrarPassword)
  self:send_registerBuddyUser(buddyId, registrarPassword)
  return self:recv_registerBuddyUser(buddyId, registrarPassword)
end

function TalkServiceClient:send_registerBuddyUser(buddyId, registrarPassword)
  self.oprot:writeMessageBegin('registerBuddyUser', TMessageType.CALL, self._seqid)
  local args = registerBuddyUser_args:new{}
  args.buddyId = buddyId
  args.registrarPassword = registrarPassword
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerBuddyUser(buddyId, registrarPassword)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerBuddyUser_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerBuddyUserid(seq, userid)
  self:send_registerBuddyUserid(seq, userid)
  self:recv_registerBuddyUserid(seq, userid)
end

function TalkServiceClient:send_registerBuddyUserid(seq, userid)
  self.oprot:writeMessageBegin('registerBuddyUserid', TMessageType.CALL, self._seqid)
  local args = registerBuddyUserid_args:new{}
  args.seq = seq
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerBuddyUserid(seq, userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerBuddyUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:registerDevice(sessionId)
  self:send_registerDevice(sessionId)
  return self:recv_registerDevice(sessionId)
end

function TalkServiceClient:send_registerDevice(sessionId)
  self.oprot:writeMessageBegin('registerDevice', TMessageType.CALL, self._seqid)
  local args = registerDevice_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDevice(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDevice_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  self:send_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  return self:recv_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
end

function TalkServiceClient:send_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  self.oprot:writeMessageBegin('registerDeviceWithIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerDeviceWithIdentityCredential_args:new{}
  args.sessionId = sessionId
  args.provider = provider
  args.identifier = identifier
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDeviceWithIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  self:send_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  return self:recv_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
end

function TalkServiceClient:send_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  self.oprot:writeMessageBegin('registerDeviceWithoutPhoneNumber', TMessageType.CALL, self._seqid)
  local args = registerDeviceWithoutPhoneNumber_args:new{}
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDeviceWithoutPhoneNumber_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid)
  self:send_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid)
  return self:recv_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid)
end

function TalkServiceClient:send_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid)
  self.oprot:writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerDeviceWithoutPhoneNumberWithIdentityCredential_args:new{}
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.provider = provider
  args.identifier = identifier
  args.verifier = verifier
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDeviceWithoutPhoneNumberWithIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerUserid(reqSeq, userid)
  self:send_registerUserid(reqSeq, userid)
  return self:recv_registerUserid(reqSeq, userid)
end

function TalkServiceClient:send_registerUserid(reqSeq, userid)
  self.oprot:writeMessageBegin('registerUserid', TMessageType.CALL, self._seqid)
  local args = registerUserid_args:new{}
  args.reqSeq = reqSeq
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerUserid(reqSeq, userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  self:send_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  return self:recv_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
end

function TalkServiceClient:send_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  self.oprot:writeMessageBegin('registerWapDevice', TMessageType.CALL, self._seqid)
  local args = registerWapDevice_args:new{}
  args.invitationHash = invitationHash
  args.guidHash = guidHash
  args.email = email
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWapDevice_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  self:send_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  return self:recv_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
end

function TalkServiceClient:send_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  self.oprot:writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerWithExistingSnsIdAndIdentityCredential_args:new{}
  args.identityCredential = identityCredential
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithExistingSnsIdAndIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  self:send_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  return self:recv_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
end

function TalkServiceClient:send_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  self.oprot:writeMessageBegin('registerWithSnsId', TMessageType.CALL, self._seqid)
  local args = registerWithSnsId_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithSnsId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  self:send_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  return self:recv_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
end

function TalkServiceClient:send_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  self.oprot:writeMessageBegin('registerWithSnsIdAndIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerWithSnsIdAndIdentityCredential_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args.identityCredential = identityCredential
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithSnsIdAndIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reissueDeviceCredential()
  self:send_reissueDeviceCredential()
  return self:recv_reissueDeviceCredential()
end

function TalkServiceClient:send_reissueDeviceCredential()
  self.oprot:writeMessageBegin('reissueDeviceCredential', TMessageType.CALL, self._seqid)
  local args = reissueDeviceCredential_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reissueDeviceCredential()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reissueDeviceCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reissueUserTicket(expirationTime, maxUseCount)
  self:send_reissueUserTicket(expirationTime, maxUseCount)
  return self:recv_reissueUserTicket(expirationTime, maxUseCount)
end

function TalkServiceClient:send_reissueUserTicket(expirationTime, maxUseCount)
  self.oprot:writeMessageBegin('reissueUserTicket', TMessageType.CALL, self._seqid)
  local args = reissueUserTicket_args:new{}
  args.expirationTime = expirationTime
  args.maxUseCount = maxUseCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reissueUserTicket(expirationTime, maxUseCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reissueUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:rejectGroupInvitation(reqSeq, groupId)
  self:send_rejectGroupInvitation(reqSeq, groupId)
  self:recv_rejectGroupInvitation(reqSeq, groupId)
end

function TalkServiceClient:send_rejectGroupInvitation(reqSeq, groupId)
  self.oprot:writeMessageBegin('rejectGroupInvitation', TMessageType.CALL, self._seqid)
  local args = rejectGroupInvitation_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_rejectGroupInvitation(reqSeq, groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = rejectGroupInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:releaseSession()
  self:send_releaseSession()
  self:recv_releaseSession()
end

function TalkServiceClient:send_releaseSession()
  self.oprot:writeMessageBegin('releaseSession', TMessageType.CALL, self._seqid)
  local args = releaseSession_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_releaseSession()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = releaseSession_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:removeAllMessages(seq, lastMessageId)
  self:send_removeAllMessages(seq, lastMessageId)
  self:recv_removeAllMessages(seq, lastMessageId)
end

function TalkServiceClient:send_removeAllMessages(seq, lastMessageId)
  self.oprot:writeMessageBegin('removeAllMessages', TMessageType.CALL, self._seqid)
  local args = removeAllMessages_args:new{}
  args.seq = seq
  args.lastMessageId = lastMessageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeAllMessages(seq, lastMessageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeAllMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:removeBuddyLocation(mid, index)
  self:send_removeBuddyLocation(mid, index)
  self:recv_removeBuddyLocation(mid, index)
end

function TalkServiceClient:send_removeBuddyLocation(mid, index)
  self.oprot:writeMessageBegin('removeBuddyLocation', TMessageType.CALL, self._seqid)
  local args = removeBuddyLocation_args:new{}
  args.mid = mid
  args.index = index
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeBuddyLocation(mid, index)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeBuddyLocation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:removeMessage(messageId)
  self:send_removeMessage(messageId)
  return self:recv_removeMessage(messageId)
end

function TalkServiceClient:send_removeMessage(messageId)
  self.oprot:writeMessageBegin('removeMessage', TMessageType.CALL, self._seqid)
  local args = removeMessage_args:new{}
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeMessage(messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:removeMessageFromMyHome(messageId)
  self:send_removeMessageFromMyHome(messageId)
  return self:recv_removeMessageFromMyHome(messageId)
end

function TalkServiceClient:send_removeMessageFromMyHome(messageId)
  self.oprot:writeMessageBegin('removeMessageFromMyHome', TMessageType.CALL, self._seqid)
  local args = removeMessageFromMyHome_args:new{}
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeMessageFromMyHome(messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeMessageFromMyHome_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:removeSnsId(snsIdType)
  self:send_removeSnsId(snsIdType)
  return self:recv_removeSnsId(snsIdType)
end

function TalkServiceClient:send_removeSnsId(snsIdType)
  self.oprot:writeMessageBegin('removeSnsId', TMessageType.CALL, self._seqid)
  local args = removeSnsId_args:new{}
  args.snsIdType = snsIdType
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeSnsId(snsIdType)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeSnsId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:report(syncOpRevision, category, report)
  self:send_report(syncOpRevision, category, report)
  self:recv_report(syncOpRevision, category, report)
end

function TalkServiceClient:send_report(syncOpRevision, category, report)
  self.oprot:writeMessageBegin('report', TMessageType.CALL, self._seqid)
  local args = report_args:new{}
  args.syncOpRevision = syncOpRevision
  args.category = category
  args.report = report
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_report(syncOpRevision, category, report)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = report_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportContacts(syncOpRevision, category, contactReports, actionType)
  self:send_reportContacts(syncOpRevision, category, contactReports, actionType)
  return self:recv_reportContacts(syncOpRevision, category, contactReports, actionType)
end

function TalkServiceClient:send_reportContacts(syncOpRevision, category, contactReports, actionType)
  self.oprot:writeMessageBegin('reportContacts', TMessageType.CALL, self._seqid)
  local args = reportContacts_args:new{}
  args.syncOpRevision = syncOpRevision
  args.category = category
  args.contactReports = contactReports
  args.actionType = actionType
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportContacts(syncOpRevision, category, contactReports, actionType)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportContacts_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reportGroups(syncOpRevision, groups)
  self:send_reportGroups(syncOpRevision, groups)
  self:recv_reportGroups(syncOpRevision, groups)
end

function TalkServiceClient:send_reportGroups(syncOpRevision, groups)
  self.oprot:writeMessageBegin('reportGroups', TMessageType.CALL, self._seqid)
  local args = reportGroups_args:new{}
  args.syncOpRevision = syncOpRevision
  args.groups = groups
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportGroups(syncOpRevision, groups)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportGroups_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportProfile(syncOpRevision, profile)
  self:send_reportProfile(syncOpRevision, profile)
  self:recv_reportProfile(syncOpRevision, profile)
end

function TalkServiceClient:send_reportProfile(syncOpRevision, profile)
  self.oprot:writeMessageBegin('reportProfile', TMessageType.CALL, self._seqid)
  local args = reportProfile_args:new{}
  args.syncOpRevision = syncOpRevision
  args.profile = profile
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportProfile(syncOpRevision, profile)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportRooms(syncOpRevision, rooms)
  self:send_reportRooms(syncOpRevision, rooms)
  self:recv_reportRooms(syncOpRevision, rooms)
end

function TalkServiceClient:send_reportRooms(syncOpRevision, rooms)
  self.oprot:writeMessageBegin('reportRooms', TMessageType.CALL, self._seqid)
  local args = reportRooms_args:new{}
  args.syncOpRevision = syncOpRevision
  args.rooms = rooms
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportRooms(syncOpRevision, rooms)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportRooms_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportSettings(syncOpRevision, settings)
  self:send_reportSettings(syncOpRevision, settings)
  self:recv_reportSettings(syncOpRevision, settings)
end

function TalkServiceClient:send_reportSettings(syncOpRevision, settings)
  self.oprot:writeMessageBegin('reportSettings', TMessageType.CALL, self._seqid)
  local args = reportSettings_args:new{}
  args.syncOpRevision = syncOpRevision
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportSettings(syncOpRevision, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  self:send_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  self:recv_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
end

function TalkServiceClient:send_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  self.oprot:writeMessageBegin('reportSpammer', TMessageType.CALL, self._seqid)
  local args = reportSpammer_args:new{}
  args.spammerMid = spammerMid
  args.spammerReasons = spammerReasons
  args.spamMessageIds = spamMessageIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportSpammer_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:requestAccountPasswordReset(provider, identifier, locale)
  self:send_requestAccountPasswordReset(provider, identifier, locale)
  self:recv_requestAccountPasswordReset(provider, identifier, locale)
end

function TalkServiceClient:send_requestAccountPasswordReset(provider, identifier, locale)
  self.oprot:writeMessageBegin('requestAccountPasswordReset', TMessageType.CALL, self._seqid)
  local args = requestAccountPasswordReset_args:new{}
  args.provider = provider
  args.identifier = identifier
  args.locale = locale
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestAccountPasswordReset(provider, identifier, locale)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestAccountPasswordReset_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:requestEmailConfirmation(emailConfirmation)
  self:send_requestEmailConfirmation(emailConfirmation)
  return self:recv_requestEmailConfirmation(emailConfirmation)
end

function TalkServiceClient:send_requestEmailConfirmation(emailConfirmation)
  self.oprot:writeMessageBegin('requestEmailConfirmation', TMessageType.CALL, self._seqid)
  local args = requestEmailConfirmation_args:new{}
  args.emailConfirmation = emailConfirmation
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestEmailConfirmation(emailConfirmation)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestEmailConfirmation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:requestIdentityUnbind(provider, identifier)
  self:send_requestIdentityUnbind(provider, identifier)
  self:recv_requestIdentityUnbind(provider, identifier)
end

function TalkServiceClient:send_requestIdentityUnbind(provider, identifier)
  self.oprot:writeMessageBegin('requestIdentityUnbind', TMessageType.CALL, self._seqid)
  local args = requestIdentityUnbind_args:new{}
  args.provider = provider
  args.identifier = identifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestIdentityUnbind(provider, identifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestIdentityUnbind_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:resendEmailConfirmation(verifier)
  self:send_resendEmailConfirmation(verifier)
  return self:recv_resendEmailConfirmation(verifier)
end

function TalkServiceClient:send_resendEmailConfirmation(verifier)
  self.oprot:writeMessageBegin('resendEmailConfirmation', TMessageType.CALL, self._seqid)
  local args = resendEmailConfirmation_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_resendEmailConfirmation(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = resendEmailConfirmation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:resendPinCode(sessionId)
  self:send_resendPinCode(sessionId)
  self:recv_resendPinCode(sessionId)
end

function TalkServiceClient:send_resendPinCode(sessionId)
  self.oprot:writeMessageBegin('resendPinCode', TMessageType.CALL, self._seqid)
  local args = resendPinCode_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_resendPinCode(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = resendPinCode_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:resendPinCodeBySMS(sessionId)
  self:send_resendPinCodeBySMS(sessionId)
  self:recv_resendPinCodeBySMS(sessionId)
end

function TalkServiceClient:send_resendPinCodeBySMS(sessionId)
  self.oprot:writeMessageBegin('resendPinCodeBySMS', TMessageType.CALL, self._seqid)
  local args = resendPinCodeBySMS_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_resendPinCodeBySMS(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = resendPinCodeBySMS_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendChatChecked(seq, consumer, lastMessageId)
  self:send_sendChatChecked(seq, consumer, lastMessageId)
  self:recv_sendChatChecked(seq, consumer, lastMessageId)
end

function TalkServiceClient:send_sendChatChecked(seq, consumer, lastMessageId)
  self.oprot:writeMessageBegin('sendChatChecked', TMessageType.CALL, self._seqid)
  local args = sendChatChecked_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.lastMessageId = lastMessageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendChatChecked(seq, consumer, lastMessageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendChatChecked_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendChatRemoved(seq, consumer, lastMessageId)
  self:send_sendChatRemoved(seq, consumer, lastMessageId)
  self:recv_sendChatRemoved(seq, consumer, lastMessageId)
end

function TalkServiceClient:send_sendChatRemoved(seq, consumer, lastMessageId)
  self.oprot:writeMessageBegin('sendChatRemoved', TMessageType.CALL, self._seqid)
  local args = sendChatRemoved_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.lastMessageId = lastMessageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendChatRemoved(seq, consumer, lastMessageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendChatRemoved_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendContentPreviewUpdated(esq, messageId, receiverMids)
  self:send_sendContentPreviewUpdated(esq, messageId, receiverMids)
  return self:recv_sendContentPreviewUpdated(esq, messageId, receiverMids)
end

function TalkServiceClient:send_sendContentPreviewUpdated(esq, messageId, receiverMids)
  self.oprot:writeMessageBegin('sendContentPreviewUpdated', TMessageType.CALL, self._seqid)
  local args = sendContentPreviewUpdated_args:new{}
  args.esq = esq
  args.messageId = messageId
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendContentPreviewUpdated(esq, messageId, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendContentPreviewUpdated_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendContentReceipt(seq, consumer, messageId)
  self:send_sendContentReceipt(seq, consumer, messageId)
  self:recv_sendContentReceipt(seq, consumer, messageId)
end

function TalkServiceClient:send_sendContentReceipt(seq, consumer, messageId)
  self.oprot:writeMessageBegin('sendContentReceipt', TMessageType.CALL, self._seqid)
  local args = sendContentReceipt_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendContentReceipt(seq, consumer, messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendContentReceipt_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendDummyPush()
  self:send_sendDummyPush()
  self:recv_sendDummyPush()
end

function TalkServiceClient:send_sendDummyPush()
  self.oprot:writeMessageBegin('sendDummyPush', TMessageType.CALL, self._seqid)
  local args = sendDummyPush_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendDummyPush()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendDummyPush_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendEvent(seq, message)
  self:send_sendEvent(seq, message)
  return self:recv_sendEvent(seq, message)
end

function TalkServiceClient:send_sendEvent(seq, message)
  self.oprot:writeMessageBegin('sendEvent', TMessageType.CALL, self._seqid)
  local args = sendEvent_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendEvent(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendEvent_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendMessage(seq, message)
  self:send_sendMessage(seq, message)
  return self:recv_sendMessage(seq, message)
end

function TalkServiceClient:send_sendMessage(seq, message)
  self.oprot:writeMessageBegin('sendMessage', TMessageType.CALL, self._seqid)
  local args = sendMessage_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessage(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendMessageIgnored(seq, consumer, messageIds)
  self:send_sendMessageIgnored(seq, consumer, messageIds)
  self:recv_sendMessageIgnored(seq, consumer, messageIds)
end

function TalkServiceClient:send_sendMessageIgnored(seq, consumer, messageIds)
  self.oprot:writeMessageBegin('sendMessageIgnored', TMessageType.CALL, self._seqid)
  local args = sendMessageIgnored_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.messageIds = messageIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessageIgnored(seq, consumer, messageIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessageIgnored_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendMessageReceipt(seq, consumer, messageIds)
  self:send_sendMessageReceipt(seq, consumer, messageIds)
  self:recv_sendMessageReceipt(seq, consumer, messageIds)
end

function TalkServiceClient:send_sendMessageReceipt(seq, consumer, messageIds)
  self.oprot:writeMessageBegin('sendMessageReceipt', TMessageType.CALL, self._seqid)
  local args = sendMessageReceipt_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.messageIds = messageIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessageReceipt(seq, consumer, messageIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessageReceipt_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendMessageToMyHome(seq, message)
  self:send_sendMessageToMyHome(seq, message)
  return self:recv_sendMessageToMyHome(seq, message)
end

function TalkServiceClient:send_sendMessageToMyHome(seq, message)
  self.oprot:writeMessageBegin('sendMessageToMyHome', TMessageType.CALL, self._seqid)
  local args = sendMessageToMyHome_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessageToMyHome(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessageToMyHome_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:setBuddyLocation(mid, index, location)
  self:send_setBuddyLocation(mid, index, location)
  self:recv_setBuddyLocation(mid, index, location)
end

function TalkServiceClient:send_setBuddyLocation(mid, index, location)
  self.oprot:writeMessageBegin('setBuddyLocation', TMessageType.CALL, self._seqid)
  local args = setBuddyLocation_args:new{}
  args.mid = mid
  args.index = index
  args.location = location
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_setBuddyLocation(mid, index, location)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = setBuddyLocation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:setIdentityCredential(provider, identifier, verifier)
  self:send_setIdentityCredential(provider, identifier, verifier)
  self:recv_setIdentityCredential(provider, identifier, verifier)
end

function TalkServiceClient:send_setIdentityCredential(provider, identifier, verifier)
  self.oprot:writeMessageBegin('setIdentityCredential', TMessageType.CALL, self._seqid)
  local args = setIdentityCredential_args:new{}
  args.provider = provider
  args.identifier = identifier
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_setIdentityCredential(provider, identifier, verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = setIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:setNotificationsEnabled(reqSeq, type, target, enablement)
  self:send_setNotificationsEnabled(reqSeq, type, target, enablement)
  self:recv_setNotificationsEnabled(reqSeq, type, target, enablement)
end

function TalkServiceClient:send_setNotificationsEnabled(reqSeq, type, target, enablement)
  self.oprot:writeMessageBegin('setNotificationsEnabled', TMessageType.CALL, self._seqid)
  local args = setNotificationsEnabled_args:new{}
  args.reqSeq = reqSeq
  args.type = type
  args.target = target
  args.enablement = enablement
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_setNotificationsEnabled(reqSeq, type, target, enablement)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = setNotificationsEnabled_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  self:send_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  return self:recv_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
end

function TalkServiceClient:send_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  self.oprot:writeMessageBegin('startUpdateVerification', TMessageType.CALL, self._seqid)
  local args = startUpdateVerification_args:new{}
  args.region = region
  args.carrier = carrier
  args.phone = phone
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.networkCode = networkCode
  args.locale = locale
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = startUpdateVerification_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale)
  self:send_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale)
  return self:recv_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale)
end

function TalkServiceClient:send_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale)
  self.oprot:writeMessageBegin('startVerification', TMessageType.CALL, self._seqid)
  local args = startVerification_args:new{}
  args.region = region
  args.carrier = carrier
  args.phone = phone
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.networkCode = networkCode
  args.mid = mid
  args.locale = locale
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = startVerification_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:storeUpdateProfileAttribute(seq, profileAttribute, value)
  self:send_storeUpdateProfileAttribute(seq, profileAttribute, value)
  self:recv_storeUpdateProfileAttribute(seq, profileAttribute, value)
end

function TalkServiceClient:send_storeUpdateProfileAttribute(seq, profileAttribute, value)
  self.oprot:writeMessageBegin('storeUpdateProfileAttribute', TMessageType.CALL, self._seqid)
  local args = storeUpdateProfileAttribute_args:new{}
  args.seq = seq
  args.profileAttribute = profileAttribute
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_storeUpdateProfileAttribute(seq, profileAttribute, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = storeUpdateProfileAttribute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:syncContactBySnsIds(reqSeq, modifications)
  self:send_syncContactBySnsIds(reqSeq, modifications)
  return self:recv_syncContactBySnsIds(reqSeq, modifications)
end

function TalkServiceClient:send_syncContactBySnsIds(reqSeq, modifications)
  self.oprot:writeMessageBegin('syncContactBySnsIds', TMessageType.CALL, self._seqid)
  local args = syncContactBySnsIds_args:new{}
  args.reqSeq = reqSeq
  args.modifications = modifications
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_syncContactBySnsIds(reqSeq, modifications)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = syncContactBySnsIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:syncContacts(reqSeq, localContacts)
  self:send_syncContacts(reqSeq, localContacts)
  return self:recv_syncContacts(reqSeq, localContacts)
end

function TalkServiceClient:send_syncContacts(reqSeq, localContacts)
  self.oprot:writeMessageBegin('syncContacts', TMessageType.CALL, self._seqid)
  local args = syncContacts_args:new{}
  args.reqSeq = reqSeq
  args.localContacts = localContacts
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_syncContacts(reqSeq, localContacts)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = syncContacts_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:trySendMessage(seq, message)
  self:send_trySendMessage(seq, message)
  return self:recv_trySendMessage(seq, message)
end

function TalkServiceClient:send_trySendMessage(seq, message)
  self.oprot:writeMessageBegin('trySendMessage', TMessageType.CALL, self._seqid)
  local args = trySendMessage_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_trySendMessage(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = trySendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:unblockContact(reqSeq, id)
  self:send_unblockContact(reqSeq, id)
  self:recv_unblockContact(reqSeq, id)
end

function TalkServiceClient:send_unblockContact(reqSeq, id)
  self.oprot:writeMessageBegin('unblockContact', TMessageType.CALL, self._seqid)
  local args = unblockContact_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_unblockContact(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = unblockContact_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:unblockRecommendation(reqSeq, id)
  self:send_unblockRecommendation(reqSeq, id)
  self:recv_unblockRecommendation(reqSeq, id)
end

function TalkServiceClient:send_unblockRecommendation(reqSeq, id)
  self.oprot:writeMessageBegin('unblockRecommendation', TMessageType.CALL, self._seqid)
  local args = unblockRecommendation_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_unblockRecommendation(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = unblockRecommendation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:unregisterUserAndDevice()
  self:send_unregisterUserAndDevice()
  return self:recv_unregisterUserAndDevice()
end

function TalkServiceClient:send_unregisterUserAndDevice()
  self.oprot:writeMessageBegin('unregisterUserAndDevice', TMessageType.CALL, self._seqid)
  local args = unregisterUserAndDevice_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_unregisterUserAndDevice()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = unregisterUserAndDevice_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:updateApnsDeviceToken(apnsDeviceToken)
  self:send_updateApnsDeviceToken(apnsDeviceToken)
  self:recv_updateApnsDeviceToken(apnsDeviceToken)
end

function TalkServiceClient:send_updateApnsDeviceToken(apnsDeviceToken)
  self.oprot:writeMessageBegin('updateApnsDeviceToken', TMessageType.CALL, self._seqid)
  local args = updateApnsDeviceToken_args:new{}
  args.apnsDeviceToken = apnsDeviceToken
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateApnsDeviceToken(apnsDeviceToken)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateApnsDeviceToken_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateBuddySetting(key, value)
  self:send_updateBuddySetting(key, value)
  self:recv_updateBuddySetting(key, value)
end

function TalkServiceClient:send_updateBuddySetting(key, value)
  self.oprot:writeMessageBegin('updateBuddySetting', TMessageType.CALL, self._seqid)
  local args = updateBuddySetting_args:new{}
  args.key = key
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateBuddySetting(key, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateBuddySetting_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateC2DMRegistrationId(registrationId)
  self:send_updateC2DMRegistrationId(registrationId)
  self:recv_updateC2DMRegistrationId(registrationId)
end

function TalkServiceClient:send_updateC2DMRegistrationId(registrationId)
  self.oprot:writeMessageBegin('updateC2DMRegistrationId', TMessageType.CALL, self._seqid)
  local args = updateC2DMRegistrationId_args:new{}
  args.registrationId = registrationId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateC2DMRegistrationId(registrationId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateC2DMRegistrationId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateContactSetting(reqSeq, mid, flag, value)
  self:send_updateContactSetting(reqSeq, mid, flag, value)
  self:recv_updateContactSetting(reqSeq, mid, flag, value)
end

function TalkServiceClient:send_updateContactSetting(reqSeq, mid, flag, value)
  self.oprot:writeMessageBegin('updateContactSetting', TMessageType.CALL, self._seqid)
  local args = updateContactSetting_args:new{}
  args.reqSeq = reqSeq
  args.mid = mid
  args.flag = flag
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateContactSetting(reqSeq, mid, flag, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateContactSetting_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateCustomModeSettings(customMode, paramMap)
  self:send_updateCustomModeSettings(customMode, paramMap)
  self:recv_updateCustomModeSettings(customMode, paramMap)
end

function TalkServiceClient:send_updateCustomModeSettings(customMode, paramMap)
  self.oprot:writeMessageBegin('updateCustomModeSettings', TMessageType.CALL, self._seqid)
  local args = updateCustomModeSettings_args:new{}
  args.customMode = customMode
  args.paramMap = paramMap
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateCustomModeSettings(customMode, paramMap)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateCustomModeSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateDeviceInfo(deviceUid, deviceInfo)
  self:send_updateDeviceInfo(deviceUid, deviceInfo)
  self:recv_updateDeviceInfo(deviceUid, deviceInfo)
end

function TalkServiceClient:send_updateDeviceInfo(deviceUid, deviceInfo)
  self.oprot:writeMessageBegin('updateDeviceInfo', TMessageType.CALL, self._seqid)
  local args = updateDeviceInfo_args:new{}
  args.deviceUid = deviceUid
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateDeviceInfo(deviceUid, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateDeviceInfo_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateGroup(reqSeq, group)
  self:send_updateGroup(reqSeq, group)
  self:recv_updateGroup(reqSeq, group)
end

function TalkServiceClient:send_updateGroup(reqSeq, group)
  self.oprot:writeMessageBegin('updateGroup', TMessageType.CALL, self._seqid)
  local args = updateGroup_args:new{}
  args.reqSeq = reqSeq
  args.group = group
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateGroup(reqSeq, group)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateNotificationToken(type, token)
  self:send_updateNotificationToken(type, token)
  self:recv_updateNotificationToken(type, token)
end

function TalkServiceClient:send_updateNotificationToken(type, token)
  self.oprot:writeMessageBegin('updateNotificationToken', TMessageType.CALL, self._seqid)
  local args = updateNotificationToken_args:new{}
  args.type = type
  args.token = token
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateNotificationToken(type, token)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateNotificationToken_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateNotificationTokenWithBytes(type, token)
  self:send_updateNotificationTokenWithBytes(type, token)
  self:recv_updateNotificationTokenWithBytes(type, token)
end

function TalkServiceClient:send_updateNotificationTokenWithBytes(type, token)
  self.oprot:writeMessageBegin('updateNotificationTokenWithBytes', TMessageType.CALL, self._seqid)
  local args = updateNotificationTokenWithBytes_args:new{}
  args.type = type
  args.token = token
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateNotificationTokenWithBytes(type, token)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateNotificationTokenWithBytes_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateProfile(reqSeq, profile)
  self:send_updateProfile(reqSeq, profile)
  self:recv_updateProfile(reqSeq, profile)
end

function TalkServiceClient:send_updateProfile(reqSeq, profile)
  self.oprot:writeMessageBegin('updateProfile', TMessageType.CALL, self._seqid)
  local args = updateProfile_args:new{}
  args.reqSeq = reqSeq
  args.profile = profile
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateProfile(reqSeq, profile)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateProfileAttribute(reqSeq, attr, value)
  self:send_updateProfileAttribute(reqSeq, attr, value)
  self:recv_updateProfileAttribute(reqSeq, attr, value)
end

function TalkServiceClient:send_updateProfileAttribute(reqSeq, attr, value)
  self.oprot:writeMessageBegin('updateProfileAttribute', TMessageType.CALL, self._seqid)
  local args = updateProfileAttribute_args:new{}
  args.reqSeq = reqSeq
  args.attr = attr
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateProfileAttribute(reqSeq, attr, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateProfileAttribute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateRegion(region)
  self:send_updateRegion(region)
  self:recv_updateRegion(region)
end

function TalkServiceClient:send_updateRegion(region)
  self.oprot:writeMessageBegin('updateRegion', TMessageType.CALL, self._seqid)
  local args = updateRegion_args:new{}
  args.region = region
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateRegion(region)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateRegion_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateSettings(reqSeq, settings)
  self:send_updateSettings(reqSeq, settings)
  self:recv_updateSettings(reqSeq, settings)
end

function TalkServiceClient:send_updateSettings(reqSeq, settings)
  self.oprot:writeMessageBegin('updateSettings', TMessageType.CALL, self._seqid)
  local args = updateSettings_args:new{}
  args.reqSeq = reqSeq
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettings(reqSeq, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateSettings2(reqSeq, settings)
  self:send_updateSettings2(reqSeq, settings)
  return self:recv_updateSettings2(reqSeq, settings)
end

function TalkServiceClient:send_updateSettings2(reqSeq, settings)
  self.oprot:writeMessageBegin('updateSettings2', TMessageType.CALL, self._seqid)
  local args = updateSettings2_args:new{}
  args.reqSeq = reqSeq
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettings2(reqSeq, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettings2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:updateSettingsAttribute(reqSeq, attr, value)
  self:send_updateSettingsAttribute(reqSeq, attr, value)
  self:recv_updateSettingsAttribute(reqSeq, attr, value)
end

function TalkServiceClient:send_updateSettingsAttribute(reqSeq, attr, value)
  self.oprot:writeMessageBegin('updateSettingsAttribute', TMessageType.CALL, self._seqid)
  local args = updateSettingsAttribute_args:new{}
  args.reqSeq = reqSeq
  args.attr = attr
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettingsAttribute(reqSeq, attr, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettingsAttribute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateSettingsAttributes(reqSeq, attrBitset, settings)
  self:send_updateSettingsAttributes(reqSeq, attrBitset, settings)
  return self:recv_updateSettingsAttributes(reqSeq, attrBitset, settings)
end

function TalkServiceClient:send_updateSettingsAttributes(reqSeq, attrBitset, settings)
  self.oprot:writeMessageBegin('updateSettingsAttributes', TMessageType.CALL, self._seqid)
  local args = updateSettingsAttributes_args:new{}
  args.reqSeq = reqSeq
  args.attrBitset = attrBitset
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettingsAttributes(reqSeq, attrBitset, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettingsAttributes_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:verifyIdentityCredential(identityProvider, identifier, password)
  self:send_verifyIdentityCredential(identityProvider, identifier, password)
  self:recv_verifyIdentityCredential(identityProvider, identifier, password)
end

function TalkServiceClient:send_verifyIdentityCredential(identityProvider, identifier, password)
  self.oprot:writeMessageBegin('verifyIdentityCredential', TMessageType.CALL, self._seqid)
  local args = verifyIdentityCredential_args:new{}
  args.identityProvider = identityProvider
  args.identifier = identifier
  args.password = password
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyIdentityCredential(identityProvider, identifier, password)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:verifyIdentityCredentialWithResult(identityCredential)
  self:send_verifyIdentityCredentialWithResult(identityCredential)
  return self:recv_verifyIdentityCredentialWithResult(identityCredential)
end

function TalkServiceClient:send_verifyIdentityCredentialWithResult(identityCredential)
  self.oprot:writeMessageBegin('verifyIdentityCredentialWithResult', TMessageType.CALL, self._seqid)
  local args = verifyIdentityCredentialWithResult_args:new{}
  args.identityCredential = identityCredential
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyIdentityCredentialWithResult(identityCredential)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyIdentityCredentialWithResult_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:verifyPhone(sessionId, pinCode, udidHash)
  self:send_verifyPhone(sessionId, pinCode, udidHash)
  return self:recv_verifyPhone(sessionId, pinCode, udidHash)
end

function TalkServiceClient:send_verifyPhone(sessionId, pinCode, udidHash)
  self.oprot:writeMessageBegin('verifyPhone', TMessageType.CALL, self._seqid)
  local args = verifyPhone_args:new{}
  args.sessionId = sessionId
  args.pinCode = pinCode
  args.udidHash = udidHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyPhone(sessionId, pinCode, udidHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyPhone_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:verifyQrcode(verifier, pinCode)
  self:send_verifyQrcode(verifier, pinCode)
  return self:recv_verifyQrcode(verifier, pinCode)
end

function TalkServiceClient:send_verifyQrcode(verifier, pinCode)
  self.oprot:writeMessageBegin('verifyQrcode', TMessageType.CALL, self._seqid)
  local args = verifyQrcode_args:new{}
  args.verifier = verifier
  args.pinCode = pinCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyQrcode(verifier, pinCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyQrcode_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end
TalkServiceIface = __TObject:new{
  __type = 'TalkServiceIface'
}


TalkServiceProcessor = __TObject.new(__TProcessor
, {
 __type = 'TalkServiceProcessor'
})

function TalkServiceProcessor:process(iprot, oprot, server_ctx)
  local name, mtype, seqid = iprot:readMessageBegin()
  local func_name = 'process_' .. name
  if not self[func_name] or ttype(self[func_name]) ~= 'function' then
    iprot:skip(TType.STRUCT)
    iprot:readMessageEnd()
    x = TApplicationException:new{
      errorCode = TApplicationException.UNKNOWN_METHOD
    }
    oprot:writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
    x:write(oprot)
    oprot:writeMessageEnd()
    oprot.trans:flush()
  else
    self[func_name](self, seqid, iprot, oprot, server_ctx)
  end
end

function TalkServiceProcessor:process_acceptGroupInvitation(seqid, iprot, oprot, server_ctx)
  local args = acceptGroupInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acceptGroupInvitation_result:new{}
  local status, res = pcall(self.handler.acceptGroupInvitation, self.handler, args.reqSeq, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acceptGroupInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acceptProximityMatches(seqid, iprot, oprot, server_ctx)
  local args = acceptProximityMatches_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acceptProximityMatches_result:new{}
  local status, res = pcall(self.handler.acceptProximityMatches, self.handler, args.sessionId, args.ids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acceptProximityMatches', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acquireCallRoute(seqid, iprot, oprot, server_ctx)
  local args = acquireCallRoute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acquireCallRoute_result:new{}
  local status, res = pcall(self.handler.acquireCallRoute, self.handler, args.to)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acquireCallRoute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acquireCallTicket(seqid, iprot, oprot, server_ctx)
  local args = acquireCallTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acquireCallTicket_result:new{}
  local status, res = pcall(self.handler.acquireCallTicket, self.handler, args.to)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acquireCallTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acquireEncryptedAccessToken(seqid, iprot, oprot, server_ctx)
  local args = acquireEncryptedAccessToken_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acquireEncryptedAccessToken_result:new{}
  local status, res = pcall(self.handler.acquireEncryptedAccessToken, self.handler, args.featureType)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acquireEncryptedAccessToken', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_addSnsId(seqid, iprot, oprot, server_ctx)
  local args = addSnsId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = addSnsId_result:new{}
  local status, res = pcall(self.handler.addSnsId, self.handler, args.snsIdType, args.snsAccessToken)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('addSnsId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_blockContact(seqid, iprot, oprot, server_ctx)
  local args = blockContact_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = blockContact_result:new{}
  local status, res = pcall(self.handler.blockContact, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('blockContact', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_blockRecommendation(seqid, iprot, oprot, server_ctx)
  local args = blockRecommendation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = blockRecommendation_result:new{}
  local status, res = pcall(self.handler.blockRecommendation, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('blockRecommendation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_cancelGroupInvitation(seqid, iprot, oprot, server_ctx)
  local args = cancelGroupInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = cancelGroupInvitation_result:new{}
  local status, res = pcall(self.handler.cancelGroupInvitation, self.handler, args.reqSeq, args.groupId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('cancelGroupInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_changeVerificationMethod(seqid, iprot, oprot, server_ctx)
  local args = changeVerificationMethod_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = changeVerificationMethod_result:new{}
  local status, res = pcall(self.handler.changeVerificationMethod, self.handler, args.sessionId, args.method)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('changeVerificationMethod', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_clearIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = clearIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = clearIdentityCredential_result:new{}
  local status, res = pcall(self.handler.clearIdentityCredential, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('clearIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_clearMessageBox(seqid, iprot, oprot, server_ctx)
  local args = clearMessageBox_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = clearMessageBox_result:new{}
  local status, res = pcall(self.handler.clearMessageBox, self.handler, args.channelId, args.messageBoxId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('clearMessageBox', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_closeProximityMatch(seqid, iprot, oprot, server_ctx)
  local args = closeProximityMatch_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = closeProximityMatch_result:new{}
  local status, res = pcall(self.handler.closeProximityMatch, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('closeProximityMatch', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_commitSendMessage(seqid, iprot, oprot, server_ctx)
  local args = commitSendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = commitSendMessage_result:new{}
  local status, res = pcall(self.handler.commitSendMessage, self.handler, args.seq, args.messageId, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('commitSendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_commitSendMessages(seqid, iprot, oprot, server_ctx)
  local args = commitSendMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = commitSendMessages_result:new{}
  local status, res = pcall(self.handler.commitSendMessages, self.handler, args.seq, args.messageIds, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('commitSendMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_commitUpdateProfile(seqid, iprot, oprot, server_ctx)
  local args = commitUpdateProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = commitUpdateProfile_result:new{}
  local status, res = pcall(self.handler.commitUpdateProfile, self.handler, args.seq, args.attrs, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('commitUpdateProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_confirmEmail(seqid, iprot, oprot, server_ctx)
  local args = confirmEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = confirmEmail_result:new{}
  local status, res = pcall(self.handler.confirmEmail, self.handler, args.verifier, args.pinCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('confirmEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createGroup(seqid, iprot, oprot, server_ctx)
  local args = createGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createGroup_result:new{}
  local status, res = pcall(self.handler.createGroup, self.handler, args.seq, args.name, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createQrcodeBase64Image(seqid, iprot, oprot, server_ctx)
  local args = createQrcodeBase64Image_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createQrcodeBase64Image_result:new{}
  local status, res = pcall(self.handler.createQrcodeBase64Image, self.handler, args.url, args.characterSet, args.imageSize, args.x, args.y, args.width, args.height)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createQrcodeBase64Image', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createRoom(seqid, iprot, oprot, server_ctx)
  local args = createRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createRoom_result:new{}
  local status, res = pcall(self.handler.createRoom, self.handler, args.reqSeq, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createSession(seqid, iprot, oprot, server_ctx)
  local args = createSession_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createSession_result:new{}
  local status, res = pcall(self.handler.createSession, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createSession', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchAnnouncements(seqid, iprot, oprot, server_ctx)
  local args = fetchAnnouncements_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchAnnouncements_result:new{}
  local status, res = pcall(self.handler.fetchAnnouncements, self.handler, args.lastFetchedIndex)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchAnnouncements', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchMessages(seqid, iprot, oprot, server_ctx)
  local args = fetchMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchMessages_result:new{}
  local status, res = pcall(self.handler.fetchMessages, self.handler, args.localTs, args.count)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchOperations(seqid, iprot, oprot, server_ctx)
  local args = fetchOperations_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchOperations_result:new{}
  local status, res = pcall(self.handler.fetchOperations, self.handler, args.localRev, args.count)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchOperations', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchOps(seqid, iprot, oprot, server_ctx)
  local args = fetchOps_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchOps_result:new{}
  local status, res = pcall(self.handler.fetchOps, self.handler, args.localRev, args.count, args.globalRev, args.individualRev)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchOps', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByEmail(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByEmail_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByEmail, self.handler, args.reqSeq, args.emails)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByMid(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByMid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByMid_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByMid, self.handler, args.reqSeq, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByMid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByPhone(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByPhone_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByPhone_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByPhone, self.handler, args.reqSeq, args.phones)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByPhone', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByUserid(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByUserid_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByUserid, self.handler, args.reqSeq, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactByUserid(seqid, iprot, oprot, server_ctx)
  local args = findContactByUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactByUserid_result:new{}
  local status, res = pcall(self.handler.findContactByUserid, self.handler, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactByUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactByUserTicket(seqid, iprot, oprot, server_ctx)
  local args = findContactByUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactByUserTicket_result:new{}
  local status, res = pcall(self.handler.findContactByUserTicket, self.handler, args.ticketId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactByUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactsByEmail(seqid, iprot, oprot, server_ctx)
  local args = findContactsByEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactsByEmail_result:new{}
  local status, res = pcall(self.handler.findContactsByEmail, self.handler, args.emails)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactsByEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactsByPhone(seqid, iprot, oprot, server_ctx)
  local args = findContactsByPhone_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactsByPhone_result:new{}
  local status, res = pcall(self.handler.findContactsByPhone, self.handler, args.phones)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactsByPhone', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findSnsIdUserStatus(seqid, iprot, oprot, server_ctx)
  local args = findSnsIdUserStatus_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findSnsIdUserStatus_result:new{}
  local status, res = pcall(self.handler.findSnsIdUserStatus, self.handler, args.snsIdType, args.snsAccessToken, args.udidHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findSnsIdUserStatus', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_finishUpdateVerification(seqid, iprot, oprot, server_ctx)
  local args = finishUpdateVerification_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = finishUpdateVerification_result:new{}
  local status, res = pcall(self.handler.finishUpdateVerification, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('finishUpdateVerification', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_generateUserTicket(seqid, iprot, oprot, server_ctx)
  local args = generateUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = generateUserTicket_result:new{}
  local status, res = pcall(self.handler.generateUserTicket, self.handler, args.expirationTime, args.maxUseCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('generateUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getAcceptedProximityMatches(seqid, iprot, oprot, server_ctx)
  local args = getAcceptedProximityMatches_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getAcceptedProximityMatches_result:new{}
  local status, res = pcall(self.handler.getAcceptedProximityMatches, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getAcceptedProximityMatches', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getActiveBuddySubscriberIds(seqid, iprot, oprot, server_ctx)
  local args = getActiveBuddySubscriberIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getActiveBuddySubscriberIds_result:new{}
  local status, res = pcall(self.handler.getActiveBuddySubscriberIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getActiveBuddySubscriberIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getAllContactIds(seqid, iprot, oprot, server_ctx)
  local args = getAllContactIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getAllContactIds_result:new{}
  local status, res = pcall(self.handler.getAllContactIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getAllContactIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getAuthQrcode(seqid, iprot, oprot, server_ctx)
  local args = getAuthQrcode_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getAuthQrcode_result:new{}
  local status, res = pcall(self.handler.getAuthQrcode, self.handler, args.keepLoggedIn, args.systemName)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getAuthQrcode', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBlockedContactIds(seqid, iprot, oprot, server_ctx)
  local args = getBlockedContactIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBlockedContactIds_result:new{}
  local status, res = pcall(self.handler.getBlockedContactIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBlockedContactIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBlockedContactIdsByRange(seqid, iprot, oprot, server_ctx)
  local args = getBlockedContactIdsByRange_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBlockedContactIdsByRange_result:new{}
  local status, res = pcall(self.handler.getBlockedContactIdsByRange, self.handler, args.start, args.count)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBlockedContactIdsByRange', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBlockedRecommendationIds(seqid, iprot, oprot, server_ctx)
  local args = getBlockedRecommendationIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBlockedRecommendationIds_result:new{}
  local status, res = pcall(self.handler.getBlockedRecommendationIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBlockedRecommendationIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBuddyBlockerIds(seqid, iprot, oprot, server_ctx)
  local args = getBuddyBlockerIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBuddyBlockerIds_result:new{}
  local status, res = pcall(self.handler.getBuddyBlockerIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBuddyBlockerIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBuddyLocation(seqid, iprot, oprot, server_ctx)
  local args = getBuddyLocation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBuddyLocation_result:new{}
  local status, res = pcall(self.handler.getBuddyLocation, self.handler, args.mid, args.index)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBuddyLocation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCompactContactsModifiedSince(seqid, iprot, oprot, server_ctx)
  local args = getCompactContactsModifiedSince_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCompactContactsModifiedSince_result:new{}
  local status, res = pcall(self.handler.getCompactContactsModifiedSince, self.handler, args.timestamp)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCompactContactsModifiedSince', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCompactGroup(seqid, iprot, oprot, server_ctx)
  local args = getCompactGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCompactGroup_result:new{}
  local status, res = pcall(self.handler.getCompactGroup, self.handler, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCompactGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCompactRoom(seqid, iprot, oprot, server_ctx)
  local args = getCompactRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCompactRoom_result:new{}
  local status, res = pcall(self.handler.getCompactRoom, self.handler, args.roomId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCompactRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getContact(seqid, iprot, oprot, server_ctx)
  local args = getContact_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getContact_result:new{}
  local status, res = pcall(self.handler.getContact, self.handler, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getContact', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getContacts(seqid, iprot, oprot, server_ctx)
  local args = getContacts_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getContacts_result:new{}
  local status, res = pcall(self.handler.getContacts, self.handler, args.ids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getContacts', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCountryWithRequestIp(seqid, iprot, oprot, server_ctx)
  local args = getCountryWithRequestIp_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCountryWithRequestIp_result:new{}
  local status, res = pcall(self.handler.getCountryWithRequestIp, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCountryWithRequestIp', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getFavoriteMids(seqid, iprot, oprot, server_ctx)
  local args = getFavoriteMids_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getFavoriteMids_result:new{}
  local status, res = pcall(self.handler.getFavoriteMids, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getFavoriteMids', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroup(seqid, iprot, oprot, server_ctx)
  local args = getGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroup_result:new{}
  local status, res = pcall(self.handler.getGroup, self.handler, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroupIdsInvited(seqid, iprot, oprot, server_ctx)
  local args = getGroupIdsInvited_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroupIdsInvited_result:new{}
  local status, res = pcall(self.handler.getGroupIdsInvited, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroupIdsInvited', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroupIdsJoined(seqid, iprot, oprot, server_ctx)
  local args = getGroupIdsJoined_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroupIdsJoined_result:new{}
  local status, res = pcall(self.handler.getGroupIdsJoined, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroupIdsJoined', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroups(seqid, iprot, oprot, server_ctx)
  local args = getGroups_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroups_result:new{}
  local status, res = pcall(self.handler.getGroups, self.handler, args.groupIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroups', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getHiddenContactMids(seqid, iprot, oprot, server_ctx)
  local args = getHiddenContactMids_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getHiddenContactMids_result:new{}
  local status, res = pcall(self.handler.getHiddenContactMids, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getHiddenContactMids', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getIdentityIdentifier(seqid, iprot, oprot, server_ctx)
  local args = getIdentityIdentifier_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getIdentityIdentifier_result:new{}
  local status, res = pcall(self.handler.getIdentityIdentifier, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getIdentityIdentifier', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getLastAnnouncementIndex(seqid, iprot, oprot, server_ctx)
  local args = getLastAnnouncementIndex_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getLastAnnouncementIndex_result:new{}
  local status, res = pcall(self.handler.getLastAnnouncementIndex, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getLastAnnouncementIndex', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getLastOpRevision(seqid, iprot, oprot, server_ctx)
  local args = getLastOpRevision_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getLastOpRevision_result:new{}
  local status, res = pcall(self.handler.getLastOpRevision, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getLastOpRevision', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBox(seqid, iprot, oprot, server_ctx)
  local args = getMessageBox_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBox_result:new{}
  local status, res = pcall(self.handler.getMessageBox, self.handler, args.channelId, args.messageBoxId, args.lastMessagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBox', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxCompactWrapUp(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxCompactWrapUp_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxCompactWrapUp_result:new{}
  local status, res = pcall(self.handler.getMessageBoxCompactWrapUp, self.handler, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxCompactWrapUp', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxCompactWrapUpList(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxCompactWrapUpList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxCompactWrapUpList_result:new{}
  local status, res = pcall(self.handler.getMessageBoxCompactWrapUpList, self.handler, args.start, args.messageBoxCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxCompactWrapUpList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxList(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxList_result:new{}
  local status, res = pcall(self.handler.getMessageBoxList, self.handler, args.channelId, args.lastMessagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxListByStatus(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxListByStatus_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxListByStatus_result:new{}
  local status, res = pcall(self.handler.getMessageBoxListByStatus, self.handler, args.channelId, args.lastMessagesCount, args.status)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxListByStatus', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxWrapUp(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxWrapUp_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxWrapUp_result:new{}
  local status, res = pcall(self.handler.getMessageBoxWrapUp, self.handler, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxWrapUp', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxWrapUpList(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxWrapUpList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxWrapUpList_result:new{}
  local status, res = pcall(self.handler.getMessageBoxWrapUpList, self.handler, args.start, args.messageBoxCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxWrapUpList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessagesBySequenceNumber(seqid, iprot, oprot, server_ctx)
  local args = getMessagesBySequenceNumber_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessagesBySequenceNumber_result:new{}
  local status, res = pcall(self.handler.getMessagesBySequenceNumber, self.handler, args.channelId, args.messageBoxId, args.startSeq, args.endSeq)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessagesBySequenceNumber', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getNextMessages(seqid, iprot, oprot, server_ctx)
  local args = getNextMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getNextMessages_result:new{}
  local status, res = pcall(self.handler.getNextMessages, self.handler, args.messageBoxId, args.startSeq, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getNextMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getNotificationPolicy(seqid, iprot, oprot, server_ctx)
  local args = getNotificationPolicy_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getNotificationPolicy_result:new{}
  local status, res = pcall(self.handler.getNotificationPolicy, self.handler, args.carrier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getNotificationPolicy', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getPreviousMessages(seqid, iprot, oprot, server_ctx)
  local args = getPreviousMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getPreviousMessages_result:new{}
  local status, res = pcall(self.handler.getPreviousMessages, self.handler, args.messageBoxId, args.endSeq, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getPreviousMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getProfile(seqid, iprot, oprot, server_ctx)
  local args = getProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProfile_result:new{}
  local status, res = pcall(self.handler.getProfile, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getProximityMatchCandidateList(seqid, iprot, oprot, server_ctx)
  local args = getProximityMatchCandidateList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProximityMatchCandidateList_result:new{}
  local status, res = pcall(self.handler.getProximityMatchCandidateList, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProximityMatchCandidateList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getProximityMatchCandidates(seqid, iprot, oprot, server_ctx)
  local args = getProximityMatchCandidates_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProximityMatchCandidates_result:new{}
  local status, res = pcall(self.handler.getProximityMatchCandidates, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProximityMatchCandidates', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRecentMessages(seqid, iprot, oprot, server_ctx)
  local args = getRecentMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRecentMessages_result:new{}
  local status, res = pcall(self.handler.getRecentMessages, self.handler, args.messageBoxId, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRecentMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRecommendationIds(seqid, iprot, oprot, server_ctx)
  local args = getRecommendationIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRecommendationIds_result:new{}
  local status, res = pcall(self.handler.getRecommendationIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRecommendationIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRoom(seqid, iprot, oprot, server_ctx)
  local args = getRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRoom_result:new{}
  local status, res = pcall(self.handler.getRoom, self.handler, args.roomId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRSAKeyInfo(seqid, iprot, oprot, server_ctx)
  local args = getRSAKeyInfo_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRSAKeyInfo_result:new{}
  local status, res = pcall(self.handler.getRSAKeyInfo, self.handler, args.provider)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRSAKeyInfo', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getServerTime(seqid, iprot, oprot, server_ctx)
  local args = getServerTime_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getServerTime_result:new{}
  local status, res = pcall(self.handler.getServerTime, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getServerTime', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSessions(seqid, iprot, oprot, server_ctx)
  local args = getSessions_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSessions_result:new{}
  local status, res = pcall(self.handler.getSessions, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSessions', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSettings(seqid, iprot, oprot, server_ctx)
  local args = getSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSettings_result:new{}
  local status, res = pcall(self.handler.getSettings, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSettingsAttributes(seqid, iprot, oprot, server_ctx)
  local args = getSettingsAttributes_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSettingsAttributes_result:new{}
  local status, res = pcall(self.handler.getSettingsAttributes, self.handler, args.attrBitset)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSettingsAttributes', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSystemConfiguration(seqid, iprot, oprot, server_ctx)
  local args = getSystemConfiguration_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSystemConfiguration_result:new{}
  local status, res = pcall(self.handler.getSystemConfiguration, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSystemConfiguration', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getUserTicket(seqid, iprot, oprot, server_ctx)
  local args = getUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getUserTicket_result:new{}
  local status, res = pcall(self.handler.getUserTicket, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getWapInvitation(seqid, iprot, oprot, server_ctx)
  local args = getWapInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getWapInvitation_result:new{}
  local status, res = pcall(self.handler.getWapInvitation, self.handler, args.invitationHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getWapInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_invalidateUserTicket(seqid, iprot, oprot, server_ctx)
  local args = invalidateUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = invalidateUserTicket_result:new{}
  local status, res = pcall(self.handler.invalidateUserTicket, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('invalidateUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteFriendsBySms(seqid, iprot, oprot, server_ctx)
  local args = inviteFriendsBySms_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteFriendsBySms_result:new{}
  local status, res = pcall(self.handler.inviteFriendsBySms, self.handler, args.phoneNumberList)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteFriendsBySms', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteIntoGroup(seqid, iprot, oprot, server_ctx)
  local args = inviteIntoGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteIntoGroup_result:new{}
  local status, res = pcall(self.handler.inviteIntoGroup, self.handler, args.reqSeq, args.groupId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteIntoGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteIntoRoom(seqid, iprot, oprot, server_ctx)
  local args = inviteIntoRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteIntoRoom_result:new{}
  local status, res = pcall(self.handler.inviteIntoRoom, self.handler, args.reqSeq, args.roomId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteIntoRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteViaEmail(seqid, iprot, oprot, server_ctx)
  local args = inviteViaEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteViaEmail_result:new{}
  local status, res = pcall(self.handler.inviteViaEmail, self.handler, args.reqSeq, args.email, args.name)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteViaEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_isIdentityIdentifierAvailable(seqid, iprot, oprot, server_ctx)
  local args = isIdentityIdentifierAvailable_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = isIdentityIdentifierAvailable_result:new{}
  local status, res = pcall(self.handler.isIdentityIdentifierAvailable, self.handler, args.provider, args.identifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('isIdentityIdentifierAvailable', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_isUseridAvailable(seqid, iprot, oprot, server_ctx)
  local args = isUseridAvailable_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = isUseridAvailable_result:new{}
  local status, res = pcall(self.handler.isUseridAvailable, self.handler, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('isUseridAvailable', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_kickoutFromGroup(seqid, iprot, oprot, server_ctx)
  local args = kickoutFromGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = kickoutFromGroup_result:new{}
  local status, res = pcall(self.handler.kickoutFromGroup, self.handler, args.reqSeq, args.groupId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('kickoutFromGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_leaveGroup(seqid, iprot, oprot, server_ctx)
  local args = leaveGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = leaveGroup_result:new{}
  local status, res = pcall(self.handler.leaveGroup, self.handler, args.reqSeq, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('leaveGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_leaveRoom(seqid, iprot, oprot, server_ctx)
  local args = leaveRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = leaveRoom_result:new{}
  local status, res = pcall(self.handler.leaveRoom, self.handler, args.reqSeq, args.roomId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('leaveRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = loginWithIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithIdentityCredential_result:new{}
  local status, res = pcall(self.handler.loginWithIdentityCredential, self.handler, args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithIdentityCredentialForCertificate(seqid, iprot, oprot, server_ctx)
  local args = loginWithIdentityCredentialForCertificate_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithIdentityCredentialForCertificate_result:new{}
  local status, res = pcall(self.handler.loginWithIdentityCredentialForCertificate, self.handler, args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithIdentityCredentialForCertificate', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithVerifier(seqid, iprot, oprot, server_ctx)
  local args = loginWithVerifier_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithVerifier_result:new{}
  local status, res = pcall(self.handler.loginWithVerifier, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithVerifier', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithVerifierForCerificate(seqid, iprot, oprot, server_ctx)
  local args = loginWithVerifierForCerificate_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithVerifierForCerificate_result:new{}
  local status, res = pcall(self.handler.loginWithVerifierForCerificate, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithVerifierForCerificate', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithVerifierForCertificate(seqid, iprot, oprot, server_ctx)
  local args = loginWithVerifierForCertificate_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithVerifierForCertificate_result:new{}
  local status, res = pcall(self.handler.loginWithVerifierForCertificate, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithVerifierForCertificate', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_logout(seqid, iprot, oprot, server_ctx)
  local args = logout_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = logout_result:new{}
  local status, res = pcall(self.handler.logout, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('logout', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_logoutSession(seqid, iprot, oprot, server_ctx)
  local args = logoutSession_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = logoutSession_result:new{}
  local status, res = pcall(self.handler.logoutSession, self.handler, args.tokenKey)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('logoutSession', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_noop(seqid, iprot, oprot, server_ctx)
  local args = noop_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = noop_result:new{}
  local status, res = pcall(self.handler.noop, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('noop', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifiedRedirect(seqid, iprot, oprot, server_ctx)
  local args = notifiedRedirect_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifiedRedirect_result:new{}
  local status, res = pcall(self.handler.notifiedRedirect, self.handler, args.paramMap)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifiedRedirect', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyBuddyOnAir(seqid, iprot, oprot, server_ctx)
  local args = notifyBuddyOnAir_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyBuddyOnAir_result:new{}
  local status, res = pcall(self.handler.notifyBuddyOnAir, self.handler, args.seq, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyBuddyOnAir', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyIndividualEvent(seqid, iprot, oprot, server_ctx)
  local args = notifyIndividualEvent_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyIndividualEvent_result:new{}
  local status, res = pcall(self.handler.notifyIndividualEvent, self.handler, args.notificationStatus, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyIndividualEvent', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyInstalled(seqid, iprot, oprot, server_ctx)
  local args = notifyInstalled_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyInstalled_result:new{}
  local status, res = pcall(self.handler.notifyInstalled, self.handler, args.udidHash, args.applicationTypeWithExtensions)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyInstalled', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyRegistrationComplete(seqid, iprot, oprot, server_ctx)
  local args = notifyRegistrationComplete_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyRegistrationComplete_result:new{}
  local status, res = pcall(self.handler.notifyRegistrationComplete, self.handler, args.udidHash, args.applicationTypeWithExtensions)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyRegistrationComplete', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifySleep(seqid, iprot, oprot, server_ctx)
  local args = notifySleep_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifySleep_result:new{}
  local status, res = pcall(self.handler.notifySleep, self.handler, args.lastRev, args.badge)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifySleep', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyUpdated(seqid, iprot, oprot, server_ctx)
  local args = notifyUpdated_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyUpdated_result:new{}
  local status, res = pcall(self.handler.notifyUpdated, self.handler, args.lastRev, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyUpdated', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_openProximityMatch(seqid, iprot, oprot, server_ctx)
  local args = openProximityMatch_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = openProximityMatch_result:new{}
  local status, res = pcall(self.handler.openProximityMatch, self.handler, args.location)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('openProximityMatch', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerBuddyUser(seqid, iprot, oprot, server_ctx)
  local args = registerBuddyUser_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerBuddyUser_result:new{}
  local status, res = pcall(self.handler.registerBuddyUser, self.handler, args.buddyId, args.registrarPassword)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerBuddyUser', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerBuddyUserid(seqid, iprot, oprot, server_ctx)
  local args = registerBuddyUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerBuddyUserid_result:new{}
  local status, res = pcall(self.handler.registerBuddyUserid, self.handler, args.seq, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerBuddyUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDevice(seqid, iprot, oprot, server_ctx)
  local args = registerDevice_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDevice_result:new{}
  local status, res = pcall(self.handler.registerDevice, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDevice', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDeviceWithIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerDeviceWithIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDeviceWithIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerDeviceWithIdentityCredential, self.handler, args.sessionId, args.provider, args.identifier, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDeviceWithIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDeviceWithoutPhoneNumber(seqid, iprot, oprot, server_ctx)
  local args = registerDeviceWithoutPhoneNumber_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDeviceWithoutPhoneNumber_result:new{}
  local status, res = pcall(self.handler.registerDeviceWithoutPhoneNumber, self.handler, args.region, args.udidHash, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDeviceWithoutPhoneNumber', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDeviceWithoutPhoneNumberWithIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerDeviceWithoutPhoneNumberWithIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDeviceWithoutPhoneNumberWithIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerDeviceWithoutPhoneNumberWithIdentityCredential, self.handler, args.region, args.udidHash, args.deviceInfo, args.provider, args.identifier, args.verifier, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerUserid(seqid, iprot, oprot, server_ctx)
  local args = registerUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerUserid_result:new{}
  local status, res = pcall(self.handler.registerUserid, self.handler, args.reqSeq, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWapDevice(seqid, iprot, oprot, server_ctx)
  local args = registerWapDevice_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWapDevice_result:new{}
  local status, res = pcall(self.handler.registerWapDevice, self.handler, args.invitationHash, args.guidHash, args.email, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWapDevice', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithExistingSnsIdAndIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerWithExistingSnsIdAndIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithExistingSnsIdAndIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerWithExistingSnsIdAndIdentityCredential, self.handler, args.identityCredential, args.region, args.udidHash, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithSnsId(seqid, iprot, oprot, server_ctx)
  local args = registerWithSnsId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithSnsId_result:new{}
  local status, res = pcall(self.handler.registerWithSnsId, self.handler, args.snsIdType, args.snsAccessToken, args.region, args.udidHash, args.deviceInfo, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithSnsId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithSnsIdAndIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerWithSnsIdAndIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithSnsIdAndIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerWithSnsIdAndIdentityCredential, self.handler, args.snsIdType, args.snsAccessToken, args.identityCredential, args.region, args.udidHash, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithSnsIdAndIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reissueDeviceCredential(seqid, iprot, oprot, server_ctx)
  local args = reissueDeviceCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reissueDeviceCredential_result:new{}
  local status, res = pcall(self.handler.reissueDeviceCredential, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reissueDeviceCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reissueUserTicket(seqid, iprot, oprot, server_ctx)
  local args = reissueUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reissueUserTicket_result:new{}
  local status, res = pcall(self.handler.reissueUserTicket, self.handler, args.expirationTime, args.maxUseCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reissueUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_rejectGroupInvitation(seqid, iprot, oprot, server_ctx)
  local args = rejectGroupInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = rejectGroupInvitation_result:new{}
  local status, res = pcall(self.handler.rejectGroupInvitation, self.handler, args.reqSeq, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('rejectGroupInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_releaseSession(seqid, iprot, oprot, server_ctx)
  local args = releaseSession_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = releaseSession_result:new{}
  local status, res = pcall(self.handler.releaseSession, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('releaseSession', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeAllMessages(seqid, iprot, oprot, server_ctx)
  local args = removeAllMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeAllMessages_result:new{}
  local status, res = pcall(self.handler.removeAllMessages, self.handler, args.seq, args.lastMessageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeAllMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeBuddyLocation(seqid, iprot, oprot, server_ctx)
  local args = removeBuddyLocation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeBuddyLocation_result:new{}
  local status, res = pcall(self.handler.removeBuddyLocation, self.handler, args.mid, args.index)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeBuddyLocation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeMessage(seqid, iprot, oprot, server_ctx)
  local args = removeMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeMessage_result:new{}
  local status, res = pcall(self.handler.removeMessage, self.handler, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeMessageFromMyHome(seqid, iprot, oprot, server_ctx)
  local args = removeMessageFromMyHome_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeMessageFromMyHome_result:new{}
  local status, res = pcall(self.handler.removeMessageFromMyHome, self.handler, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeMessageFromMyHome', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeSnsId(seqid, iprot, oprot, server_ctx)
  local args = removeSnsId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeSnsId_result:new{}
  local status, res = pcall(self.handler.removeSnsId, self.handler, args.snsIdType)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeSnsId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_report(seqid, iprot, oprot, server_ctx)
  local args = report_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = report_result:new{}
  local status, res = pcall(self.handler.report, self.handler, args.syncOpRevision, args.category, args.report)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('report', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportContacts(seqid, iprot, oprot, server_ctx)
  local args = reportContacts_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportContacts_result:new{}
  local status, res = pcall(self.handler.reportContacts, self.handler, args.syncOpRevision, args.category, args.contactReports, args.actionType)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportContacts', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportGroups(seqid, iprot, oprot, server_ctx)
  local args = reportGroups_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportGroups_result:new{}
  local status, res = pcall(self.handler.reportGroups, self.handler, args.syncOpRevision, args.groups)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportGroups', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportProfile(seqid, iprot, oprot, server_ctx)
  local args = reportProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportProfile_result:new{}
  local status, res = pcall(self.handler.reportProfile, self.handler, args.syncOpRevision, args.profile)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportRooms(seqid, iprot, oprot, server_ctx)
  local args = reportRooms_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportRooms_result:new{}
  local status, res = pcall(self.handler.reportRooms, self.handler, args.syncOpRevision, args.rooms)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportRooms', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportSettings(seqid, iprot, oprot, server_ctx)
  local args = reportSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportSettings_result:new{}
  local status, res = pcall(self.handler.reportSettings, self.handler, args.syncOpRevision, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportSpammer(seqid, iprot, oprot, server_ctx)
  local args = reportSpammer_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportSpammer_result:new{}
  local status, res = pcall(self.handler.reportSpammer, self.handler, args.spammerMid, args.spammerReasons, args.spamMessageIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportSpammer', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestAccountPasswordReset(seqid, iprot, oprot, server_ctx)
  local args = requestAccountPasswordReset_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestAccountPasswordReset_result:new{}
  local status, res = pcall(self.handler.requestAccountPasswordReset, self.handler, args.provider, args.identifier, args.locale)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestAccountPasswordReset', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestEmailConfirmation(seqid, iprot, oprot, server_ctx)
  local args = requestEmailConfirmation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestEmailConfirmation_result:new{}
  local status, res = pcall(self.handler.requestEmailConfirmation, self.handler, args.emailConfirmation)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestEmailConfirmation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestIdentityUnbind(seqid, iprot, oprot, server_ctx)
  local args = requestIdentityUnbind_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestIdentityUnbind_result:new{}
  local status, res = pcall(self.handler.requestIdentityUnbind, self.handler, args.provider, args.identifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestIdentityUnbind', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_resendEmailConfirmation(seqid, iprot, oprot, server_ctx)
  local args = resendEmailConfirmation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = resendEmailConfirmation_result:new{}
  local status, res = pcall(self.handler.resendEmailConfirmation, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('resendEmailConfirmation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_resendPinCode(seqid, iprot, oprot, server_ctx)
  local args = resendPinCode_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = resendPinCode_result:new{}
  local status, res = pcall(self.handler.resendPinCode, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('resendPinCode', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_resendPinCodeBySMS(seqid, iprot, oprot, server_ctx)
  local args = resendPinCodeBySMS_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = resendPinCodeBySMS_result:new{}
  local status, res = pcall(self.handler.resendPinCodeBySMS, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('resendPinCodeBySMS', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendChatChecked(seqid, iprot, oprot, server_ctx)
  local args = sendChatChecked_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendChatChecked_result:new{}
  local status, res = pcall(self.handler.sendChatChecked, self.handler, args.seq, args.consumer, args.lastMessageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendChatChecked', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendChatRemoved(seqid, iprot, oprot, server_ctx)
  local args = sendChatRemoved_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendChatRemoved_result:new{}
  local status, res = pcall(self.handler.sendChatRemoved, self.handler, args.seq, args.consumer, args.lastMessageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendChatRemoved', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendContentPreviewUpdated(seqid, iprot, oprot, server_ctx)
  local args = sendContentPreviewUpdated_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendContentPreviewUpdated_result:new{}
  local status, res = pcall(self.handler.sendContentPreviewUpdated, self.handler, args.esq, args.messageId, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendContentPreviewUpdated', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendContentReceipt(seqid, iprot, oprot, server_ctx)
  local args = sendContentReceipt_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendContentReceipt_result:new{}
  local status, res = pcall(self.handler.sendContentReceipt, self.handler, args.seq, args.consumer, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendContentReceipt', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendDummyPush(seqid, iprot, oprot, server_ctx)
  local args = sendDummyPush_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendDummyPush_result:new{}
  local status, res = pcall(self.handler.sendDummyPush, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendDummyPush', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendEvent(seqid, iprot, oprot, server_ctx)
  local args = sendEvent_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendEvent_result:new{}
  local status, res = pcall(self.handler.sendEvent, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendEvent', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessage(seqid, iprot, oprot, server_ctx)
  local args = sendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessage_result:new{}
  local status, res = pcall(self.handler.sendMessage, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessageIgnored(seqid, iprot, oprot, server_ctx)
  local args = sendMessageIgnored_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessageIgnored_result:new{}
  local status, res = pcall(self.handler.sendMessageIgnored, self.handler, args.seq, args.consumer, args.messageIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessageIgnored', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessageReceipt(seqid, iprot, oprot, server_ctx)
  local args = sendMessageReceipt_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessageReceipt_result:new{}
  local status, res = pcall(self.handler.sendMessageReceipt, self.handler, args.seq, args.consumer, args.messageIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessageReceipt', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessageToMyHome(seqid, iprot, oprot, server_ctx)
  local args = sendMessageToMyHome_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessageToMyHome_result:new{}
  local status, res = pcall(self.handler.sendMessageToMyHome, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessageToMyHome', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_setBuddyLocation(seqid, iprot, oprot, server_ctx)
  local args = setBuddyLocation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = setBuddyLocation_result:new{}
  local status, res = pcall(self.handler.setBuddyLocation, self.handler, args.mid, args.index, args.location)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('setBuddyLocation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_setIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = setIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = setIdentityCredential_result:new{}
  local status, res = pcall(self.handler.setIdentityCredential, self.handler, args.provider, args.identifier, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('setIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_setNotificationsEnabled(seqid, iprot, oprot, server_ctx)
  local args = setNotificationsEnabled_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = setNotificationsEnabled_result:new{}
  local status, res = pcall(self.handler.setNotificationsEnabled, self.handler, args.reqSeq, args.type, args.target, args.enablement)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('setNotificationsEnabled', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_startUpdateVerification(seqid, iprot, oprot, server_ctx)
  local args = startUpdateVerification_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = startUpdateVerification_result:new{}
  local status, res = pcall(self.handler.startUpdateVerification, self.handler, args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.locale)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('startUpdateVerification', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_startVerification(seqid, iprot, oprot, server_ctx)
  local args = startVerification_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = startVerification_result:new{}
  local status, res = pcall(self.handler.startVerification, self.handler, args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.mid, args.locale)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('startVerification', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_storeUpdateProfileAttribute(seqid, iprot, oprot, server_ctx)
  local args = storeUpdateProfileAttribute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = storeUpdateProfileAttribute_result:new{}
  local status, res = pcall(self.handler.storeUpdateProfileAttribute, self.handler, args.seq, args.profileAttribute, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('storeUpdateProfileAttribute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_syncContactBySnsIds(seqid, iprot, oprot, server_ctx)
  local args = syncContactBySnsIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = syncContactBySnsIds_result:new{}
  local status, res = pcall(self.handler.syncContactBySnsIds, self.handler, args.reqSeq, args.modifications)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('syncContactBySnsIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_syncContacts(seqid, iprot, oprot, server_ctx)
  local args = syncContacts_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = syncContacts_result:new{}
  local status, res = pcall(self.handler.syncContacts, self.handler, args.reqSeq, args.localContacts)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('syncContacts', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_trySendMessage(seqid, iprot, oprot, server_ctx)
  local args = trySendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = trySendMessage_result:new{}
  local status, res = pcall(self.handler.trySendMessage, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('trySendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_unblockContact(seqid, iprot, oprot, server_ctx)
  local args = unblockContact_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = unblockContact_result:new{}
  local status, res = pcall(self.handler.unblockContact, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('unblockContact', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_unblockRecommendation(seqid, iprot, oprot, server_ctx)
  local args = unblockRecommendation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = unblockRecommendation_result:new{}
  local status, res = pcall(self.handler.unblockRecommendation, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('unblockRecommendation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_unregisterUserAndDevice(seqid, iprot, oprot, server_ctx)
  local args = unregisterUserAndDevice_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = unregisterUserAndDevice_result:new{}
  local status, res = pcall(self.handler.unregisterUserAndDevice, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('unregisterUserAndDevice', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateApnsDeviceToken(seqid, iprot, oprot, server_ctx)
  local args = updateApnsDeviceToken_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateApnsDeviceToken_result:new{}
  local status, res = pcall(self.handler.updateApnsDeviceToken, self.handler, args.apnsDeviceToken)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateApnsDeviceToken', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateBuddySetting(seqid, iprot, oprot, server_ctx)
  local args = updateBuddySetting_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateBuddySetting_result:new{}
  local status, res = pcall(self.handler.updateBuddySetting, self.handler, args.key, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateBuddySetting', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateC2DMRegistrationId(seqid, iprot, oprot, server_ctx)
  local args = updateC2DMRegistrationId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateC2DMRegistrationId_result:new{}
  local status, res = pcall(self.handler.updateC2DMRegistrationId, self.handler, args.registrationId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateC2DMRegistrationId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateContactSetting(seqid, iprot, oprot, server_ctx)
  local args = updateContactSetting_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateContactSetting_result:new{}
  local status, res = pcall(self.handler.updateContactSetting, self.handler, args.reqSeq, args.mid, args.flag, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateContactSetting', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateCustomModeSettings(seqid, iprot, oprot, server_ctx)
  local args = updateCustomModeSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateCustomModeSettings_result:new{}
  local status, res = pcall(self.handler.updateCustomModeSettings, self.handler, args.customMode, args.paramMap)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateCustomModeSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateDeviceInfo(seqid, iprot, oprot, server_ctx)
  local args = updateDeviceInfo_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateDeviceInfo_result:new{}
  local status, res = pcall(self.handler.updateDeviceInfo, self.handler, args.deviceUid, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateDeviceInfo', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateGroup(seqid, iprot, oprot, server_ctx)
  local args = updateGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateGroup_result:new{}
  local status, res = pcall(self.handler.updateGroup, self.handler, args.reqSeq, args.group)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateNotificationToken(seqid, iprot, oprot, server_ctx)
  local args = updateNotificationToken_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateNotificationToken_result:new{}
  local status, res = pcall(self.handler.updateNotificationToken, self.handler, args.type, args.token)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateNotificationToken', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateNotificationTokenWithBytes(seqid, iprot, oprot, server_ctx)
  local args = updateNotificationTokenWithBytes_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateNotificationTokenWithBytes_result:new{}
  local status, res = pcall(self.handler.updateNotificationTokenWithBytes, self.handler, args.type, args.token)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateNotificationTokenWithBytes', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateProfile(seqid, iprot, oprot, server_ctx)
  local args = updateProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateProfile_result:new{}
  local status, res = pcall(self.handler.updateProfile, self.handler, args.reqSeq, args.profile)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateProfileAttribute(seqid, iprot, oprot, server_ctx)
  local args = updateProfileAttribute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateProfileAttribute_result:new{}
  local status, res = pcall(self.handler.updateProfileAttribute, self.handler, args.reqSeq, args.attr, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateProfileAttribute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateRegion(seqid, iprot, oprot, server_ctx)
  local args = updateRegion_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateRegion_result:new{}
  local status, res = pcall(self.handler.updateRegion, self.handler, args.region)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateRegion', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettings(seqid, iprot, oprot, server_ctx)
  local args = updateSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettings_result:new{}
  local status, res = pcall(self.handler.updateSettings, self.handler, args.reqSeq, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettings2(seqid, iprot, oprot, server_ctx)
  local args = updateSettings2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettings2_result:new{}
  local status, res = pcall(self.handler.updateSettings2, self.handler, args.reqSeq, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettings2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettingsAttribute(seqid, iprot, oprot, server_ctx)
  local args = updateSettingsAttribute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettingsAttribute_result:new{}
  local status, res = pcall(self.handler.updateSettingsAttribute, self.handler, args.reqSeq, args.attr, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettingsAttribute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettingsAttributes(seqid, iprot, oprot, server_ctx)
  local args = updateSettingsAttributes_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettingsAttributes_result:new{}
  local status, res = pcall(self.handler.updateSettingsAttributes, self.handler, args.reqSeq, args.attrBitset, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettingsAttributes', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = verifyIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyIdentityCredential_result:new{}
  local status, res = pcall(self.handler.verifyIdentityCredential, self.handler, args.identityProvider, args.identifier, args.password)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyIdentityCredentialWithResult(seqid, iprot, oprot, server_ctx)
  local args = verifyIdentityCredentialWithResult_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyIdentityCredentialWithResult_result:new{}
  local status, res = pcall(self.handler.verifyIdentityCredentialWithResult, self.handler, args.identityCredential)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyIdentityCredentialWithResult', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyPhone(seqid, iprot, oprot, server_ctx)
  local args = verifyPhone_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyPhone_result:new{}
  local status, res = pcall(self.handler.verifyPhone, self.handler, args.sessionId, args.pinCode, args.udidHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyPhone', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyQrcode(seqid, iprot, oprot, server_ctx)
  local args = verifyQrcode_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyQrcode_result:new{}
  local status, res = pcall(self.handler.verifyQrcode, self.handler, args.verifier, args.pinCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyQrcode', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

-- HELPER FUNCTIONS AND STRUCTURES

acceptGroupInvitation_args = __TObject:new{
  reqSeq,
  groupId
}

function acceptGroupInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptGroupInvitation_args:write(oprot)
  oprot:writeStructBegin('acceptGroupInvitation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptGroupInvitation_result = __TObject:new{
  e
}

function acceptGroupInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptGroupInvitation_result:write(oprot)
  oprot:writeStructBegin('acceptGroupInvitation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptProximityMatches_args = __TObject:new{
  sessionId,
  ids
}

function acceptProximityMatches_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.SET then
        self.ids = {}
        local _etype613, _size610 = iprot:readSetBegin()
        for _i=1,_size610 do
          local _elem614 = iprot:readString()
          self.ids[_elem614] = _elem614
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptProximityMatches_args:write(oprot)
  oprot:writeStructBegin('acceptProximityMatches_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.ids ~= nil then
    oprot:writeFieldBegin('ids', TType.SET, 3)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.ids))
    for iter615,_ in pairs(self.ids) do
      oprot:writeString(iter615)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptProximityMatches_result = __TObject:new{
  e
}

function acceptProximityMatches_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptProximityMatches_result:write(oprot)
  oprot:writeStructBegin('acceptProximityMatches_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallRoute_args = __TObject:new{
  to
}

function acquireCallRoute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.to = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallRoute_args:write(oprot)
  oprot:writeStructBegin('acquireCallRoute_args')
  if self.to ~= nil then
    oprot:writeFieldBegin('to', TType.STRING, 2)
    oprot:writeString(self.to)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallRoute_result = __TObject:new{
  success,
  e
}

function acquireCallRoute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype619, _size616 = iprot:readListBegin()
        for _i=1,_size616 do
          local _elem620 = iprot:readString()
          table.insert(self.success, _elem620)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallRoute_result:write(oprot)
  oprot:writeStructBegin('acquireCallRoute_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter621 in ipairs(self.success) do
      oprot:writeString(iter621)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallTicket_args = __TObject:new{
  to
}

function acquireCallTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.to = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallTicket_args:write(oprot)
  oprot:writeStructBegin('acquireCallTicket_args')
  if self.to ~= nil then
    oprot:writeFieldBegin('to', TType.STRING, 2)
    oprot:writeString(self.to)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallTicket_result = __TObject:new{
  success,
  e
}

function acquireCallTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallTicket_result:write(oprot)
  oprot:writeStructBegin('acquireCallTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireEncryptedAccessToken_args = __TObject:new{
  featureType
}

function acquireEncryptedAccessToken_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.featureType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireEncryptedAccessToken_args:write(oprot)
  oprot:writeStructBegin('acquireEncryptedAccessToken_args')
  if self.featureType ~= nil then
    oprot:writeFieldBegin('featureType', TType.I32, 2)
    oprot:writeI32(self.featureType)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireEncryptedAccessToken_result = __TObject:new{
  success,
  e
}

function acquireEncryptedAccessToken_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireEncryptedAccessToken_result:write(oprot)
  oprot:writeStructBegin('acquireEncryptedAccessToken_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

addSnsId_args = __TObject:new{
  snsIdType,
  snsAccessToken
}

function addSnsId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function addSnsId_args:write(oprot)
  oprot:writeStructBegin('addSnsId_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

addSnsId_result = __TObject:new{
  success,
  e
}

function addSnsId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function addSnsId_result:write(oprot)
  oprot:writeStructBegin('addSnsId_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockContact_args = __TObject:new{
  reqSeq,
  id
}

function blockContact_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockContact_args:write(oprot)
  oprot:writeStructBegin('blockContact_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockContact_result = __TObject:new{
  e
}

function blockContact_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockContact_result:write(oprot)
  oprot:writeStructBegin('blockContact_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockRecommendation_args = __TObject:new{
  reqSeq,
  id
}

function blockRecommendation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockRecommendation_args:write(oprot)
  oprot:writeStructBegin('blockRecommendation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockRecommendation_result = __TObject:new{
  e
}

function blockRecommendation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockRecommendation_result:write(oprot)
  oprot:writeStructBegin('blockRecommendation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

cancelGroupInvitation_args = __TObject:new{
  reqSeq,
  groupId,
  contactIds
}

function cancelGroupInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype625, _size622 = iprot:readListBegin()
        for _i=1,_size622 do
          local _elem626 = iprot:readString()
          table.insert(self.contactIds, _elem626)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function cancelGroupInvitation_args:write(oprot)
  oprot:writeStructBegin('cancelGroupInvitation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter627 in ipairs(self.contactIds) do
      oprot:writeString(iter627)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

cancelGroupInvitation_result = __TObject:new{
  e
}

function cancelGroupInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function cancelGroupInvitation_result:write(oprot)
  oprot:writeStructBegin('cancelGroupInvitation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

changeVerificationMethod_args = __TObject:new{
  sessionId,
  method
}

function changeVerificationMethod_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.method = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function changeVerificationMethod_args:write(oprot)
  oprot:writeStructBegin('changeVerificationMethod_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.method ~= nil then
    oprot:writeFieldBegin('method', TType.I32, 3)
    oprot:writeI32(self.method)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

changeVerificationMethod_result = __TObject:new{
  success,
  e
}

function changeVerificationMethod_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = VerificationSessionData:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function changeVerificationMethod_result:write(oprot)
  oprot:writeStructBegin('changeVerificationMethod_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearIdentityCredential_args = __TObject:new{

}

function clearIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('clearIdentityCredential_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearIdentityCredential_result = __TObject:new{
  e
}

function clearIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('clearIdentityCredential_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearMessageBox_args = __TObject:new{
  channelId,
  messageBoxId
}

function clearMessageBox_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearMessageBox_args:write(oprot)
  oprot:writeStructBegin('clearMessageBox_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 3)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearMessageBox_result = __TObject:new{
  e
}

function clearMessageBox_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearMessageBox_result:write(oprot)
  oprot:writeStructBegin('clearMessageBox_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

closeProximityMatch_args = __TObject:new{
  sessionId
}

function closeProximityMatch_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function closeProximityMatch_args:write(oprot)
  oprot:writeStructBegin('closeProximityMatch_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

closeProximityMatch_result = __TObject:new{
  e
}

function closeProximityMatch_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function closeProximityMatch_result:write(oprot)
  oprot:writeStructBegin('closeProximityMatch_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessage_args = __TObject:new{
  seq,
  messageId,
  receiverMids
}

function commitSendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype631, _size628 = iprot:readListBegin()
        for _i=1,_size628 do
          local _elem632 = iprot:readString()
          table.insert(self.receiverMids, _elem632)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessage_args:write(oprot)
  oprot:writeStructBegin('commitSendMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter633 in ipairs(self.receiverMids) do
      oprot:writeString(iter633)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessage_result = __TObject:new{
  success,
  e
}

function commitSendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype635, _vtype636, _size634 = iprot:readMapBegin() 
        for _i=1,_size634 do
          local _key638 = iprot:readString()
          local _val639 = iprot:readString()
          self.success[_key638] = _val639
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessage_result:write(oprot)
  oprot:writeStructBegin('commitSendMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter640,viter641 in pairs(self.success) do
      oprot:writeString(kiter640)
      oprot:writeString(viter641)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessages_args = __TObject:new{
  seq,
  messageIds,
  receiverMids
}

function commitSendMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.messageIds = {}
        local _etype645, _size642 = iprot:readListBegin()
        for _i=1,_size642 do
          local _elem646 = iprot:readString()
          table.insert(self.messageIds, _elem646)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype650, _size647 = iprot:readListBegin()
        for _i=1,_size647 do
          local _elem651 = iprot:readString()
          table.insert(self.receiverMids, _elem651)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessages_args:write(oprot)
  oprot:writeStructBegin('commitSendMessages_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.messageIds ~= nil then
    oprot:writeFieldBegin('messageIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.messageIds)
    for _,iter652 in ipairs(self.messageIds) do
      oprot:writeString(iter652)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter653 in ipairs(self.receiverMids) do
      oprot:writeString(iter653)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessages_result = __TObject:new{
  success,
  e
}

function commitSendMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype655, _vtype656, _size654 = iprot:readMapBegin() 
        for _i=1,_size654 do
          local _key658 = iprot:readString()
          local _val659 = iprot:readString()
          self.success[_key658] = _val659
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessages_result:write(oprot)
  oprot:writeStructBegin('commitSendMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter660,viter661 in pairs(self.success) do
      oprot:writeString(kiter660)
      oprot:writeString(viter661)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitUpdateProfile_args = __TObject:new{
  seq,
  attrs,
  receiverMids
}

function commitUpdateProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.attrs = {}
        local _etype665, _size662 = iprot:readListBegin()
        for _i=1,_size662 do
          local _elem666 = iprot:readI32()
          table.insert(self.attrs, _elem666)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype670, _size667 = iprot:readListBegin()
        for _i=1,_size667 do
          local _elem671 = iprot:readString()
          table.insert(self.receiverMids, _elem671)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitUpdateProfile_args:write(oprot)
  oprot:writeStructBegin('commitUpdateProfile_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.attrs ~= nil then
    oprot:writeFieldBegin('attrs', TType.LIST, 2)
    oprot:writeListBegin(TType.I32, #self.attrs)
    for _,iter672 in ipairs(self.attrs) do
      oprot:writeI32(iter672)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter673 in ipairs(self.receiverMids) do
      oprot:writeString(iter673)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitUpdateProfile_result = __TObject:new{
  success,
  e
}

function commitUpdateProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype675, _vtype676, _size674 = iprot:readMapBegin() 
        for _i=1,_size674 do
          local _key678 = iprot:readString()
          local _val679 = iprot:readString()
          self.success[_key678] = _val679
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitUpdateProfile_result:write(oprot)
  oprot:writeStructBegin('commitUpdateProfile_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter680,viter681 in pairs(self.success) do
      oprot:writeString(kiter680)
      oprot:writeString(viter681)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

confirmEmail_args = __TObject:new{
  verifier,
  pinCode
}

function confirmEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function confirmEmail_args:write(oprot)
  oprot:writeStructBegin('confirmEmail_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 2)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  if self.pinCode ~= nil then
    oprot:writeFieldBegin('pinCode', TType.STRING, 3)
    oprot:writeString(self.pinCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

confirmEmail_result = __TObject:new{
  e
}

function confirmEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function confirmEmail_result:write(oprot)
  oprot:writeStructBegin('confirmEmail_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createGroup_args = __TObject:new{
  seq,
  name,
  contactIds
}

function createGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.name = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype685, _size682 = iprot:readListBegin()
        for _i=1,_size682 do
          local _elem686 = iprot:readString()
          table.insert(self.contactIds, _elem686)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createGroup_args:write(oprot)
  oprot:writeStructBegin('createGroup_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.name ~= nil then
    oprot:writeFieldBegin('name', TType.STRING, 2)
    oprot:writeString(self.name)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter687 in ipairs(self.contactIds) do
      oprot:writeString(iter687)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createGroup_result = __TObject:new{
  success,
  e
}

function createGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createGroup_result:write(oprot)
  oprot:writeStructBegin('createGroup_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createQrcodeBase64Image_args = __TObject:new{
  url,
  characterSet,
  imageSize,
  x,
  y,
  width,
  height
}

function createQrcodeBase64Image_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.url = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.characterSet = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.imageSize = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.x = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.I32 then
        self.y = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.I32 then
        self.width = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.height = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createQrcodeBase64Image_args:write(oprot)
  oprot:writeStructBegin('createQrcodeBase64Image_args')
  if self.url ~= nil then
    oprot:writeFieldBegin('url', TType.STRING, 2)
    oprot:writeString(self.url)
    oprot:writeFieldEnd()
  end
  if self.characterSet ~= nil then
    oprot:writeFieldBegin('characterSet', TType.STRING, 3)
    oprot:writeString(self.characterSet)
    oprot:writeFieldEnd()
  end
  if self.imageSize ~= nil then
    oprot:writeFieldBegin('imageSize', TType.I32, 4)
    oprot:writeI32(self.imageSize)
    oprot:writeFieldEnd()
  end
  if self.x ~= nil then
    oprot:writeFieldBegin('x', TType.I32, 5)
    oprot:writeI32(self.x)
    oprot:writeFieldEnd()
  end
  if self.y ~= nil then
    oprot:writeFieldBegin('y', TType.I32, 6)
    oprot:writeI32(self.y)
    oprot:writeFieldEnd()
  end
  if self.width ~= nil then
    oprot:writeFieldBegin('width', TType.I32, 7)
    oprot:writeI32(self.width)
    oprot:writeFieldEnd()
  end
  if self.height ~= nil then
    oprot:writeFieldBegin('height', TType.I32, 8)
    oprot:writeI32(self.height)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createQrcodeBase64Image_result = __TObject:new{
  success,
  e
}

function createQrcodeBase64Image_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createQrcodeBase64Image_result:write(oprot)
  oprot:writeStructBegin('createQrcodeBase64Image_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createRoom_args = __TObject:new{
  reqSeq,
  contactIds
}

function createRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype691, _size688 = iprot:readListBegin()
        for _i=1,_size688 do
          local _elem692 = iprot:readString()
          table.insert(self.contactIds, _elem692)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createRoom_args:write(oprot)
  oprot:writeStructBegin('createRoom_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter693 in ipairs(self.contactIds) do
      oprot:writeString(iter693)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createRoom_result = __TObject:new{
  success,
  e
}

function createRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Room:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createRoom_result:write(oprot)
  oprot:writeStructBegin('createRoom_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createSession_args = __TObject:new{

}

function createSession_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createSession_args:write(oprot)
  oprot:writeStructBegin('createSession_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createSession_result = __TObject:new{
  success,
  e
}

function createSession_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createSession_result:write(oprot)
  oprot:writeStructBegin('createSession_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchAnnouncements_args = __TObject:new{
  lastFetchedIndex
}

function fetchAnnouncements_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.lastFetchedIndex = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchAnnouncements_args:write(oprot)
  oprot:writeStructBegin('fetchAnnouncements_args')
  if self.lastFetchedIndex ~= nil then
    oprot:writeFieldBegin('lastFetchedIndex', TType.I32, 2)
    oprot:writeI32(self.lastFetchedIndex)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchAnnouncements_result = __TObject:new{
  success,
  e
}

function fetchAnnouncements_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype697, _size694 = iprot:readListBegin()
        for _i=1,_size694 do
          local _elem698 = Announcement:new{}
          _elem698:read(iprot)
          table.insert(self.success, _elem698)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchAnnouncements_result:write(oprot)
  oprot:writeStructBegin('fetchAnnouncements_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter699 in ipairs(self.success) do
      iter699:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchMessages_args = __TObject:new{
  localTs,
  count
}

function fetchMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.localTs = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchMessages_args:write(oprot)
  oprot:writeStructBegin('fetchMessages_args')
  if self.localTs ~= nil then
    oprot:writeFieldBegin('localTs', TType.I64, 2)
    oprot:writeI64(self.localTs)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchMessages_result = __TObject:new{
  success,
  e
}

function fetchMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype703, _size700 = iprot:readListBegin()
        for _i=1,_size700 do
          local _elem704 = Message:new{}
          _elem704:read(iprot)
          table.insert(self.success, _elem704)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchMessages_result:write(oprot)
  oprot:writeStructBegin('fetchMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter705 in ipairs(self.success) do
      iter705:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOperations_args = __TObject:new{
  localRev,
  count
}

function fetchOperations_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.localRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOperations_args:write(oprot)
  oprot:writeStructBegin('fetchOperations_args')
  if self.localRev ~= nil then
    oprot:writeFieldBegin('localRev', TType.I64, 2)
    oprot:writeI64(self.localRev)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOperations_result = __TObject:new{
  success,
  e
}

function fetchOperations_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype709, _size706 = iprot:readListBegin()
        for _i=1,_size706 do
          local _elem710 = Operation:new{}
          _elem710:read(iprot)
          table.insert(self.success, _elem710)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOperations_result:write(oprot)
  oprot:writeStructBegin('fetchOperations_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter711 in ipairs(self.success) do
      iter711:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOps_args = __TObject:new{
  localRev,
  count,
  globalRev,
  individualRev
}

function fetchOps_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.localRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I64 then
        self.globalRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I64 then
        self.individualRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOps_args:write(oprot)
  oprot:writeStructBegin('fetchOps_args')
  if self.localRev ~= nil then
    oprot:writeFieldBegin('localRev', TType.I64, 2)
    oprot:writeI64(self.localRev)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  if self.globalRev ~= nil then
    oprot:writeFieldBegin('globalRev', TType.I64, 4)
    oprot:writeI64(self.globalRev)
    oprot:writeFieldEnd()
  end
  if self.individualRev ~= nil then
    oprot:writeFieldBegin('individualRev', TType.I64, 5)
    oprot:writeI64(self.individualRev)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOps_result = __TObject:new{
  success,
  e
}

function fetchOps_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype715, _size712 = iprot:readListBegin()
        for _i=1,_size712 do
          local _elem716 = Operation:new{}
          _elem716:read(iprot)
          table.insert(self.success, _elem716)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOps_result:write(oprot)
  oprot:writeStructBegin('fetchOps_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter717 in ipairs(self.success) do
      iter717:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByEmail_args = __TObject:new{
  reqSeq,
  emails
}

function findAndAddContactsByEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.SET then
        self.emails = {}
        local _etype721, _size718 = iprot:readSetBegin()
        for _i=1,_size718 do
          local _elem722 = iprot:readString()
          self.emails[_elem722] = _elem722
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByEmail_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByEmail_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.emails ~= nil then
    oprot:writeFieldBegin('emails', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.emails))
    for iter723,_ in pairs(self.emails) do
      oprot:writeString(iter723)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByEmail_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype725, _vtype726, _size724 = iprot:readMapBegin() 
        for _i=1,_size724 do
          local _key728 = iprot:readString()
          local _val729 = Contact:new{}
          _val729:read(iprot)
          self.success[_key728] = _val729
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByEmail_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByEmail_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter730,viter731 in pairs(self.success) do
      oprot:writeString(kiter730)
      viter731:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByMid_args = __TObject:new{
  reqSeq,
  mid
}

function findAndAddContactsByMid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByMid_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByMid_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByMid_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByMid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype733, _vtype734, _size732 = iprot:readMapBegin() 
        for _i=1,_size732 do
          local _key736 = iprot:readString()
          local _val737 = Contact:new{}
          _val737:read(iprot)
          self.success[_key736] = _val737
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByMid_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByMid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter738,viter739 in pairs(self.success) do
      oprot:writeString(kiter738)
      viter739:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByPhone_args = __TObject:new{
  reqSeq,
  phones
}

function findAndAddContactsByPhone_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.SET then
        self.phones = {}
        local _etype743, _size740 = iprot:readSetBegin()
        for _i=1,_size740 do
          local _elem744 = iprot:readString()
          self.phones[_elem744] = _elem744
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByPhone_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByPhone_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.phones ~= nil then
    oprot:writeFieldBegin('phones', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.phones))
    for iter745,_ in pairs(self.phones) do
      oprot:writeString(iter745)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByPhone_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByPhone_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype747, _vtype748, _size746 = iprot:readMapBegin() 
        for _i=1,_size746 do
          local _key750 = iprot:readString()
          local _val751 = Contact:new{}
          _val751:read(iprot)
          self.success[_key750] = _val751
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByPhone_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByPhone_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter752,viter753 in pairs(self.success) do
      oprot:writeString(kiter752)
      viter753:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByUserid_args = __TObject:new{
  reqSeq,
  userid
}

function findAndAddContactsByUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByUserid_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByUserid_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByUserid_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype755, _vtype756, _size754 = iprot:readMapBegin() 
        for _i=1,_size754 do
          local _key758 = iprot:readString()
          local _val759 = Contact:new{}
          _val759:read(iprot)
          self.success[_key758] = _val759
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByUserid_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByUserid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter760,viter761 in pairs(self.success) do
      oprot:writeString(kiter760)
      viter761:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserid_args = __TObject:new{
  userid
}

function findContactByUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserid_args:write(oprot)
  oprot:writeStructBegin('findContactByUserid_args')
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserid_result = __TObject:new{
  success,
  e
}

function findContactByUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserid_result:write(oprot)
  oprot:writeStructBegin('findContactByUserid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserTicket_args = __TObject:new{
  ticketId
}

function findContactByUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.ticketId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserTicket_args:write(oprot)
  oprot:writeStructBegin('findContactByUserTicket_args')
  if self.ticketId ~= nil then
    oprot:writeFieldBegin('ticketId', TType.STRING, 2)
    oprot:writeString(self.ticketId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserTicket_result = __TObject:new{
  success,
  e
}

function findContactByUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserTicket_result:write(oprot)
  oprot:writeStructBegin('findContactByUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByEmail_args = __TObject:new{
  emails
}

function findContactsByEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.SET then
        self.emails = {}
        local _etype765, _size762 = iprot:readSetBegin()
        for _i=1,_size762 do
          local _elem766 = iprot:readString()
          self.emails[_elem766] = _elem766
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByEmail_args:write(oprot)
  oprot:writeStructBegin('findContactsByEmail_args')
  if self.emails ~= nil then
    oprot:writeFieldBegin('emails', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.emails))
    for iter767,_ in pairs(self.emails) do
      oprot:writeString(iter767)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByEmail_result = __TObject:new{
  success,
  e
}

function findContactsByEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype769, _vtype770, _size768 = iprot:readMapBegin() 
        for _i=1,_size768 do
          local _key772 = iprot:readString()
          local _val773 = Contact:new{}
          _val773:read(iprot)
          self.success[_key772] = _val773
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByEmail_result:write(oprot)
  oprot:writeStructBegin('findContactsByEmail_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter774,viter775 in pairs(self.success) do
      oprot:writeString(kiter774)
      viter775:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByPhone_args = __TObject:new{
  phones
}

function findContactsByPhone_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.SET then
        self.phones = {}
        local _etype779, _size776 = iprot:readSetBegin()
        for _i=1,_size776 do
          local _elem780 = iprot:readString()
          self.phones[_elem780] = _elem780
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByPhone_args:write(oprot)
  oprot:writeStructBegin('findContactsByPhone_args')
  if self.phones ~= nil then
    oprot:writeFieldBegin('phones', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.phones))
    for iter781,_ in pairs(self.phones) do
      oprot:writeString(iter781)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByPhone_result = __TObject:new{
  success,
  e
}

function findContactsByPhone_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype783, _vtype784, _size782 = iprot:readMapBegin() 
        for _i=1,_size782 do
          local _key786 = iprot:readString()
          local _val787 = Contact:new{}
          _val787:read(iprot)
          self.success[_key786] = _val787
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByPhone_result:write(oprot)
  oprot:writeStructBegin('findContactsByPhone_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter788,viter789 in pairs(self.success) do
      oprot:writeString(kiter788)
      viter789:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findSnsIdUserStatus_args = __TObject:new{
  snsIdType,
  snsAccessToken,
  udidHash
}

function findSnsIdUserStatus_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findSnsIdUserStatus_args:write(oprot)
  oprot:writeStructBegin('findSnsIdUserStatus_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 4)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findSnsIdUserStatus_result = __TObject:new{
  success,
  e
}

function findSnsIdUserStatus_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = SnsIdUserStatus:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findSnsIdUserStatus_result:write(oprot)
  oprot:writeStructBegin('findSnsIdUserStatus_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

finishUpdateVerification_args = __TObject:new{
  sessionId
}

function finishUpdateVerification_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function finishUpdateVerification_args:write(oprot)
  oprot:writeStructBegin('finishUpdateVerification_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

finishUpdateVerification_result = __TObject:new{
  e
}

function finishUpdateVerification_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function finishUpdateVerification_result:write(oprot)
  oprot:writeStructBegin('finishUpdateVerification_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

generateUserTicket_args = __TObject:new{
  expirationTime,
  maxUseCount
}

function generateUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.expirationTime = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.maxUseCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function generateUserTicket_args:write(oprot)
  oprot:writeStructBegin('generateUserTicket_args')
  if self.expirationTime ~= nil then
    oprot:writeFieldBegin('expirationTime', TType.I64, 3)
    oprot:writeI64(self.expirationTime)
    oprot:writeFieldEnd()
  end
  if self.maxUseCount ~= nil then
    oprot:writeFieldBegin('maxUseCount', TType.I32, 4)
    oprot:writeI32(self.maxUseCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

generateUserTicket_result = __TObject:new{
  success,
  e
}

function generateUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Ticket:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function generateUserTicket_result:write(oprot)
  oprot:writeStructBegin('generateUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAcceptedProximityMatches_args = __TObject:new{
  sessionId
}

function getAcceptedProximityMatches_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAcceptedProximityMatches_args:write(oprot)
  oprot:writeStructBegin('getAcceptedProximityMatches_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAcceptedProximityMatches_result = __TObject:new{
  success,
  e
}

function getAcceptedProximityMatches_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.SET then
        self.success = {}
        local _etype793, _size790 = iprot:readSetBegin()
        for _i=1,_size790 do
          local _elem794 = iprot:readString()
          self.success[_elem794] = _elem794
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAcceptedProximityMatches_result:write(oprot)
  oprot:writeStructBegin('getAcceptedProximityMatches_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.SET, 0)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.success))
    for iter795,_ in pairs(self.success) do
      oprot:writeString(iter795)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActiveBuddySubscriberIds_args = __TObject:new{

}

function getActiveBuddySubscriberIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActiveBuddySubscriberIds_args:write(oprot)
  oprot:writeStructBegin('getActiveBuddySubscriberIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActiveBuddySubscriberIds_result = __TObject:new{
  success,
  e
}

function getActiveBuddySubscriberIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype799, _size796 = iprot:readListBegin()
        for _i=1,_size796 do
          local _elem800 = iprot:readString()
          table.insert(self.success, _elem800)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActiveBuddySubscriberIds_result:write(oprot)
  oprot:writeStructBegin('getActiveBuddySubscriberIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter801 in ipairs(self.success) do
      oprot:writeString(iter801)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAllContactIds_args = __TObject:new{

}

function getAllContactIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAllContactIds_args:write(oprot)
  oprot:writeStructBegin('getAllContactIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAllContactIds_result = __TObject:new{
  success,
  e
}

function getAllContactIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype805, _size802 = iprot:readListBegin()
        for _i=1,_size802 do
          local _elem806 = iprot:readString()
          table.insert(self.success, _elem806)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAllContactIds_result:write(oprot)
  oprot:writeStructBegin('getAllContactIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter807 in ipairs(self.success) do
      oprot:writeString(iter807)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAuthQrcode_args = __TObject:new{
  keepLoggedIn,
  systemName
}

function getAuthQrcode_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.BOOL then
        self.keepLoggedIn = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.systemName = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAuthQrcode_args:write(oprot)
  oprot:writeStructBegin('getAuthQrcode_args')
  if self.keepLoggedIn ~= nil then
    oprot:writeFieldBegin('keepLoggedIn', TType.BOOL, 2)
    oprot:writeBool(self.keepLoggedIn)
    oprot:writeFieldEnd()
  end
  if self.systemName ~= nil then
    oprot:writeFieldBegin('systemName', TType.STRING, 3)
    oprot:writeString(self.systemName)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAuthQrcode_result = __TObject:new{
  success,
  e
}

function getAuthQrcode_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = AuthQrcode:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAuthQrcode_result:write(oprot)
  oprot:writeStructBegin('getAuthQrcode_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIds_args = __TObject:new{

}

function getBlockedContactIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIds_args:write(oprot)
  oprot:writeStructBegin('getBlockedContactIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIds_result = __TObject:new{
  success,
  e
}

function getBlockedContactIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype811, _size808 = iprot:readListBegin()
        for _i=1,_size808 do
          local _elem812 = iprot:readString()
          table.insert(self.success, _elem812)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIds_result:write(oprot)
  oprot:writeStructBegin('getBlockedContactIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter813 in ipairs(self.success) do
      oprot:writeString(iter813)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIdsByRange_args = __TObject:new{
  start,
  count
}

function getBlockedContactIdsByRange_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.start = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIdsByRange_args:write(oprot)
  oprot:writeStructBegin('getBlockedContactIdsByRange_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I32, 2)
    oprot:writeI32(self.start)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIdsByRange_result = __TObject:new{
  success,
  e
}

function getBlockedContactIdsByRange_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype817, _size814 = iprot:readListBegin()
        for _i=1,_size814 do
          local _elem818 = iprot:readString()
          table.insert(self.success, _elem818)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIdsByRange_result:write(oprot)
  oprot:writeStructBegin('getBlockedContactIdsByRange_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter819 in ipairs(self.success) do
      oprot:writeString(iter819)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedRecommendationIds_args = __TObject:new{

}

function getBlockedRecommendationIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedRecommendationIds_args:write(oprot)
  oprot:writeStructBegin('getBlockedRecommendationIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedRecommendationIds_result = __TObject:new{
  success,
  e
}

function getBlockedRecommendationIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype823, _size820 = iprot:readListBegin()
        for _i=1,_size820 do
          local _elem824 = iprot:readString()
          table.insert(self.success, _elem824)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedRecommendationIds_result:write(oprot)
  oprot:writeStructBegin('getBlockedRecommendationIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter825 in ipairs(self.success) do
      oprot:writeString(iter825)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyBlockerIds_args = __TObject:new{

}

function getBuddyBlockerIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyBlockerIds_args:write(oprot)
  oprot:writeStructBegin('getBuddyBlockerIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyBlockerIds_result = __TObject:new{
  success,
  e
}

function getBuddyBlockerIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype829, _size826 = iprot:readListBegin()
        for _i=1,_size826 do
          local _elem830 = iprot:readString()
          table.insert(self.success, _elem830)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyBlockerIds_result:write(oprot)
  oprot:writeStructBegin('getBuddyBlockerIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter831 in ipairs(self.success) do
      oprot:writeString(iter831)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyLocation_args = __TObject:new{
  mid,
  index
}

function getBuddyLocation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.index = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyLocation_args:write(oprot)
  oprot:writeStructBegin('getBuddyLocation_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.index ~= nil then
    oprot:writeFieldBegin('index', TType.I32, 3)
    oprot:writeI32(self.index)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyLocation_result = __TObject:new{
  success,
  e
}

function getBuddyLocation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Geolocation:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyLocation_result:write(oprot)
  oprot:writeStructBegin('getBuddyLocation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactContactsModifiedSince_args = __TObject:new{
  timestamp
}

function getCompactContactsModifiedSince_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.timestamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactContactsModifiedSince_args:write(oprot)
  oprot:writeStructBegin('getCompactContactsModifiedSince_args')
  if self.timestamp ~= nil then
    oprot:writeFieldBegin('timestamp', TType.I64, 2)
    oprot:writeI64(self.timestamp)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactContactsModifiedSince_result = __TObject:new{
  success,
  e
}

function getCompactContactsModifiedSince_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype835, _size832 = iprot:readListBegin()
        for _i=1,_size832 do
          local _elem836 = CompactContact:new{}
          _elem836:read(iprot)
          table.insert(self.success, _elem836)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactContactsModifiedSince_result:write(oprot)
  oprot:writeStructBegin('getCompactContactsModifiedSince_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter837 in ipairs(self.success) do
      iter837:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactGroup_args = __TObject:new{
  groupId
}

function getCompactGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactGroup_args:write(oprot)
  oprot:writeStructBegin('getCompactGroup_args')
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactGroup_result = __TObject:new{
  success,
  e
}

function getCompactGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactGroup_result:write(oprot)
  oprot:writeStructBegin('getCompactGroup_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactRoom_args = __TObject:new{
  roomId
}

function getCompactRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactRoom_args:write(oprot)
  oprot:writeStructBegin('getCompactRoom_args')
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactRoom_result = __TObject:new{
  success,
  e
}

function getCompactRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Room:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactRoom_result:write(oprot)
  oprot:writeStructBegin('getCompactRoom_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContact_args = __TObject:new{
  id
}

function getContact_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContact_args:write(oprot)
  oprot:writeStructBegin('getContact_args')
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContact_result = __TObject:new{
  success,
  e
}

function getContact_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContact_result:write(oprot)
  oprot:writeStructBegin('getContact_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContacts_args = __TObject:new{
  ids
}

function getContacts_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.ids = {}
        local _etype841, _size838 = iprot:readListBegin()
        for _i=1,_size838 do
          local _elem842 = iprot:readString()
          table.insert(self.ids, _elem842)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContacts_args:write(oprot)
  oprot:writeStructBegin('getContacts_args')
  if self.ids ~= nil then
    oprot:writeFieldBegin('ids', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.ids)
    for _,iter843 in ipairs(self.ids) do
      oprot:writeString(iter843)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContacts_result = __TObject:new{
  success,
  e
}

function getContacts_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype847, _size844 = iprot:readListBegin()
        for _i=1,_size844 do
          local _elem848 = Contact:new{}
          _elem848:read(iprot)
          table.insert(self.success, _elem848)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContacts_result:write(oprot)
  oprot:writeStructBegin('getContacts_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter849 in ipairs(self.success) do
      iter849:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCountryWithRequestIp_args = __TObject:new{

}

function getCountryWithRequestIp_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCountryWithRequestIp_args:write(oprot)
  oprot:writeStructBegin('getCountryWithRequestIp_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCountryWithRequestIp_result = __TObject:new{
  success,
  e
}

function getCountryWithRequestIp_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCountryWithRequestIp_result:write(oprot)
  oprot:writeStructBegin('getCountryWithRequestIp_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getFavoriteMids_args = __TObject:new{

}

function getFavoriteMids_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getFavoriteMids_args:write(oprot)
  oprot:writeStructBegin('getFavoriteMids_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getFavoriteMids_result = __TObject:new{
  success,
  e
}

function getFavoriteMids_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype853, _size850 = iprot:readListBegin()
        for _i=1,_size850 do
          local _elem854 = iprot:readString()
          table.insert(self.success, _elem854)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getFavoriteMids_result:write(oprot)
  oprot:writeStructBegin('getFavoriteMids_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter855 in ipairs(self.success) do
      oprot:writeString(iter855)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroup_args = __TObject:new{
  groupId
}

function getGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroup_args:write(oprot)
  oprot:writeStructBegin('getGroup_args')
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroup_result = __TObject:new{
  success,
  e
}

function getGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroup_result:write(oprot)
  oprot:writeStructBegin('getGroup_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsInvited_args = __TObject:new{

}

function getGroupIdsInvited_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsInvited_args:write(oprot)
  oprot:writeStructBegin('getGroupIdsInvited_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsInvited_result = __TObject:new{
  success,
  e
}

function getGroupIdsInvited_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype859, _size856 = iprot:readListBegin()
        for _i=1,_size856 do
          local _elem860 = iprot:readString()
          table.insert(self.success, _elem860)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsInvited_result:write(oprot)
  oprot:writeStructBegin('getGroupIdsInvited_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter861 in ipairs(self.success) do
      oprot:writeString(iter861)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsJoined_args = __TObject:new{

}

function getGroupIdsJoined_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsJoined_args:write(oprot)
  oprot:writeStructBegin('getGroupIdsJoined_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsJoined_result = __TObject:new{
  success,
  e
}

function getGroupIdsJoined_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype865, _size862 = iprot:readListBegin()
        for _i=1,_size862 do
          local _elem866 = iprot:readString()
          table.insert(self.success, _elem866)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsJoined_result:write(oprot)
  oprot:writeStructBegin('getGroupIdsJoined_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter867 in ipairs(self.success) do
      oprot:writeString(iter867)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroups_args = __TObject:new{
  groupIds
}

function getGroups_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.groupIds = {}
        local _etype871, _size868 = iprot:readListBegin()
        for _i=1,_size868 do
          local _elem872 = iprot:readString()
          table.insert(self.groupIds, _elem872)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroups_args:write(oprot)
  oprot:writeStructBegin('getGroups_args')
  if self.groupIds ~= nil then
    oprot:writeFieldBegin('groupIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.groupIds)
    for _,iter873 in ipairs(self.groupIds) do
      oprot:writeString(iter873)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroups_result = __TObject:new{
  success,
  e
}

function getGroups_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype877, _size874 = iprot:readListBegin()
        for _i=1,_size874 do
          local _elem878 = Group:new{}
          _elem878:read(iprot)
          table.insert(self.success, _elem878)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroups_result:write(oprot)
  oprot:writeStructBegin('getGroups_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter879 in ipairs(self.success) do
      iter879:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getHiddenContactMids_args = __TObject:new{

}

function getHiddenContactMids_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getHiddenContactMids_args:write(oprot)
  oprot:writeStructBegin('getHiddenContactMids_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getHiddenContactMids_result = __TObject:new{
  success,
  e
}

function getHiddenContactMids_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype883, _size880 = iprot:readListBegin()
        for _i=1,_size880 do
          local _elem884 = iprot:readString()
          table.insert(self.success, _elem884)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getHiddenContactMids_result:write(oprot)
  oprot:writeStructBegin('getHiddenContactMids_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter885 in ipairs(self.success) do
      oprot:writeString(iter885)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getIdentityIdentifier_args = __TObject:new{

}

function getIdentityIdentifier_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getIdentityIdentifier_args:write(oprot)
  oprot:writeStructBegin('getIdentityIdentifier_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getIdentityIdentifier_result = __TObject:new{
  success,
  e
}

function getIdentityIdentifier_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getIdentityIdentifier_result:write(oprot)
  oprot:writeStructBegin('getIdentityIdentifier_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastAnnouncementIndex_args = __TObject:new{

}

function getLastAnnouncementIndex_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastAnnouncementIndex_args:write(oprot)
  oprot:writeStructBegin('getLastAnnouncementIndex_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastAnnouncementIndex_result = __TObject:new{
  success,
  e
}

function getLastAnnouncementIndex_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastAnnouncementIndex_result:write(oprot)
  oprot:writeStructBegin('getLastAnnouncementIndex_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastOpRevision_args = __TObject:new{

}

function getLastOpRevision_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastOpRevision_args:write(oprot)
  oprot:writeStructBegin('getLastOpRevision_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastOpRevision_result = __TObject:new{
  success,
  e
}

function getLastOpRevision_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I64 then
        self.success = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastOpRevision_result:write(oprot)
  oprot:writeStructBegin('getLastOpRevision_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I64, 0)
    oprot:writeI64(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBox_args = __TObject:new{
  channelId,
  messageBoxId,
  lastMessagesCount
}

function getMessageBox_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.lastMessagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBox_args:write(oprot)
  oprot:writeStructBegin('getMessageBox_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 3)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.lastMessagesCount ~= nil then
    oprot:writeFieldBegin('lastMessagesCount', TType.I32, 4)
    oprot:writeI32(self.lastMessagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBox_result = __TObject:new{
  success,
  e
}

function getMessageBox_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBox:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBox_result:write(oprot)
  oprot:writeStructBegin('getMessageBox_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUp_args = __TObject:new{
  mid
}

function getMessageBoxCompactWrapUp_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUp_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUp_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUp_result = __TObject:new{
  success,
  e
}

function getMessageBoxCompactWrapUp_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUp:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUp_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUp_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUpList_args = __TObject:new{
  start,
  messageBoxCount
}

function getMessageBoxCompactWrapUpList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.start = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.messageBoxCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUpList_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUpList_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I32, 2)
    oprot:writeI32(self.start)
    oprot:writeFieldEnd()
  end
  if self.messageBoxCount ~= nil then
    oprot:writeFieldBegin('messageBoxCount', TType.I32, 3)
    oprot:writeI32(self.messageBoxCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUpList_result = __TObject:new{
  success,
  e
}

function getMessageBoxCompactWrapUpList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUpResponse:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUpList_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUpList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxList_args = __TObject:new{
  channelId,
  lastMessagesCount
}

function getMessageBoxList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.lastMessagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxList_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxList_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.lastMessagesCount ~= nil then
    oprot:writeFieldBegin('lastMessagesCount', TType.I32, 3)
    oprot:writeI32(self.lastMessagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxList_result = __TObject:new{
  success,
  e
}

function getMessageBoxList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype889, _size886 = iprot:readListBegin()
        for _i=1,_size886 do
          local _elem890 = TMessageBox:new{}
          _elem890:read(iprot)
          table.insert(self.success, _elem890)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxList_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter891 in ipairs(self.success) do
      iter891:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxListByStatus_args = __TObject:new{
  channelId,
  lastMessagesCount,
  status
}

function getMessageBoxListByStatus_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.lastMessagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.status = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxListByStatus_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxListByStatus_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.lastMessagesCount ~= nil then
    oprot:writeFieldBegin('lastMessagesCount', TType.I32, 3)
    oprot:writeI32(self.lastMessagesCount)
    oprot:writeFieldEnd()
  end
  if self.status ~= nil then
    oprot:writeFieldBegin('status', TType.I32, 4)
    oprot:writeI32(self.status)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxListByStatus_result = __TObject:new{
  success,
  e
}

function getMessageBoxListByStatus_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype895, _size892 = iprot:readListBegin()
        for _i=1,_size892 do
          local _elem896 = TMessageBox:new{}
          _elem896:read(iprot)
          table.insert(self.success, _elem896)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxListByStatus_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxListByStatus_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter897 in ipairs(self.success) do
      iter897:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUp_args = __TObject:new{
  mid
}

function getMessageBoxWrapUp_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUp_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUp_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUp_result = __TObject:new{
  success,
  e
}

function getMessageBoxWrapUp_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUp:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUp_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUp_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUpList_args = __TObject:new{
  start,
  messageBoxCount
}

function getMessageBoxWrapUpList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.start = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.messageBoxCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUpList_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUpList_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I32, 2)
    oprot:writeI32(self.start)
    oprot:writeFieldEnd()
  end
  if self.messageBoxCount ~= nil then
    oprot:writeFieldBegin('messageBoxCount', TType.I32, 3)
    oprot:writeI32(self.messageBoxCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUpList_result = __TObject:new{
  success,
  e
}

function getMessageBoxWrapUpList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUpResponse:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUpList_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUpList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessagesBySequenceNumber_args = __TObject:new{
  channelId,
  messageBoxId,
  startSeq,
  endSeq
}

function getMessagesBySequenceNumber_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I64 then
        self.startSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I64 then
        self.endSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessagesBySequenceNumber_args:write(oprot)
  oprot:writeStructBegin('getMessagesBySequenceNumber_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 3)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.startSeq ~= nil then
    oprot:writeFieldBegin('startSeq', TType.I64, 4)
    oprot:writeI64(self.startSeq)
    oprot:writeFieldEnd()
  end
  if self.endSeq ~= nil then
    oprot:writeFieldBegin('endSeq', TType.I64, 5)
    oprot:writeI64(self.endSeq)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessagesBySequenceNumber_result = __TObject:new{
  success,
  e
}

function getMessagesBySequenceNumber_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype901, _size898 = iprot:readListBegin()
        for _i=1,_size898 do
          local _elem902 = Message:new{}
          _elem902:read(iprot)
          table.insert(self.success, _elem902)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessagesBySequenceNumber_result:write(oprot)
  oprot:writeStructBegin('getMessagesBySequenceNumber_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter903 in ipairs(self.success) do
      iter903:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNextMessages_args = __TObject:new{
  messageBoxId,
  startSeq,
  messagesCount
}

function getNextMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.startSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNextMessages_args:write(oprot)
  oprot:writeStructBegin('getNextMessages_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.startSeq ~= nil then
    oprot:writeFieldBegin('startSeq', TType.I64, 3)
    oprot:writeI64(self.startSeq)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 4)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNextMessages_result = __TObject:new{
  success,
  e
}

function getNextMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype907, _size904 = iprot:readListBegin()
        for _i=1,_size904 do
          local _elem908 = Message:new{}
          _elem908:read(iprot)
          table.insert(self.success, _elem908)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNextMessages_result:write(oprot)
  oprot:writeStructBegin('getNextMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter909 in ipairs(self.success) do
      iter909:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNotificationPolicy_args = __TObject:new{
  carrier
}

function getNotificationPolicy_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.carrier = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNotificationPolicy_args:write(oprot)
  oprot:writeStructBegin('getNotificationPolicy_args')
  if self.carrier ~= nil then
    oprot:writeFieldBegin('carrier', TType.I32, 2)
    oprot:writeI32(self.carrier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNotificationPolicy_result = __TObject:new{
  success,
  e
}

function getNotificationPolicy_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype913, _size910 = iprot:readListBegin()
        for _i=1,_size910 do
          local _elem914 = iprot:readI32()
          table.insert(self.success, _elem914)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNotificationPolicy_result:write(oprot)
  oprot:writeStructBegin('getNotificationPolicy_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.I32, #self.success)
    for _,iter915 in ipairs(self.success) do
      oprot:writeI32(iter915)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPreviousMessages_args = __TObject:new{
  messageBoxId,
  endSeq,
  messagesCount
}

function getPreviousMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.endSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPreviousMessages_args:write(oprot)
  oprot:writeStructBegin('getPreviousMessages_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.endSeq ~= nil then
    oprot:writeFieldBegin('endSeq', TType.I64, 3)
    oprot:writeI64(self.endSeq)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 4)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPreviousMessages_result = __TObject:new{
  success,
  e
}

function getPreviousMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype919, _size916 = iprot:readListBegin()
        for _i=1,_size916 do
          local _elem920 = Message:new{}
          _elem920:read(iprot)
          table.insert(self.success, _elem920)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPreviousMessages_result:write(oprot)
  oprot:writeStructBegin('getPreviousMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter921 in ipairs(self.success) do
      iter921:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProfile_args = __TObject:new{

}

function getProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProfile_args:write(oprot)
  oprot:writeStructBegin('getProfile_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProfile_result = __TObject:new{
  success,
  e
}

function getProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Profile:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProfile_result:write(oprot)
  oprot:writeStructBegin('getProfile_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidateList_args = __TObject:new{
  sessionId
}

function getProximityMatchCandidateList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidateList_args:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidateList_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidateList_result = __TObject:new{
  success,
  e
}

function getProximityMatchCandidateList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProximityMatchCandidateResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidateList_result:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidateList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidates_args = __TObject:new{
  sessionId
}

function getProximityMatchCandidates_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidates_args:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidates_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidates_result = __TObject:new{
  success,
  e
}

function getProximityMatchCandidates_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.SET then
        self.success = {}
        local _etype925, _size922 = iprot:readSetBegin()
        for _i=1,_size922 do
          local _elem926 = Contact:new{}
          _elem926:read(iprot)
          self.success[_elem926] = _elem926
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidates_result:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidates_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.SET, 0)
    oprot:writeSetBegin(TType.STRUCT, ttable_size(self.success))
    for iter927,_ in pairs(self.success) do
      iter927:write(oprot)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecentMessages_args = __TObject:new{
  messageBoxId,
  messagesCount
}

function getRecentMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecentMessages_args:write(oprot)
  oprot:writeStructBegin('getRecentMessages_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 3)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecentMessages_result = __TObject:new{
  success,
  e
}

function getRecentMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype931, _size928 = iprot:readListBegin()
        for _i=1,_size928 do
          local _elem932 = Message:new{}
          _elem932:read(iprot)
          table.insert(self.success, _elem932)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecentMessages_result:write(oprot)
  oprot:writeStructBegin('getRecentMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter933 in ipairs(self.success) do
      iter933:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecommendationIds_args = __TObject:new{

}

function getRecommendationIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecommendationIds_args:write(oprot)
  oprot:writeStructBegin('getRecommendationIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecommendationIds_result = __TObject:new{
  success,
  e
}

function getRecommendationIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype937, _size934 = iprot:readListBegin()
        for _i=1,_size934 do
          local _elem938 = iprot:readString()
          table.insert(self.success, _elem938)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecommendationIds_result:write(oprot)
  oprot:writeStructBegin('getRecommendationIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter939 in ipairs(self.success) do
      oprot:writeString(iter939)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRoom_args = __TObject:new{
  roomId
}

function getRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRoom_args:write(oprot)
  oprot:writeStructBegin('getRoom_args')
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRoom_result = __TObject:new{
  success,
  e
}

function getRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Room:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRoom_result:write(oprot)
  oprot:writeStructBegin('getRoom_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRSAKeyInfo_args = __TObject:new{
  provider
}

function getRSAKeyInfo_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRSAKeyInfo_args:write(oprot)
  oprot:writeStructBegin('getRSAKeyInfo_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 2)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRSAKeyInfo_result = __TObject:new{
  success,
  e
}

function getRSAKeyInfo_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = RSAKey:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRSAKeyInfo_result:write(oprot)
  oprot:writeStructBegin('getRSAKeyInfo_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getServerTime_args = __TObject:new{

}

function getServerTime_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getServerTime_args:write(oprot)
  oprot:writeStructBegin('getServerTime_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getServerTime_result = __TObject:new{
  success,
  e
}

function getServerTime_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I64 then
        self.success = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getServerTime_result:write(oprot)
  oprot:writeStructBegin('getServerTime_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I64, 0)
    oprot:writeI64(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSessions_args = __TObject:new{

}

function getSessions_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSessions_args:write(oprot)
  oprot:writeStructBegin('getSessions_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSessions_result = __TObject:new{
  success,
  e
}

function getSessions_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype943, _size940 = iprot:readListBegin()
        for _i=1,_size940 do
          local _elem944 = LoginSession:new{}
          _elem944:read(iprot)
          table.insert(self.success, _elem944)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSessions_result:write(oprot)
  oprot:writeStructBegin('getSessions_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter945 in ipairs(self.success) do
      iter945:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettings_args = __TObject:new{

}

function getSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettings_args:write(oprot)
  oprot:writeStructBegin('getSettings_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettings_result = __TObject:new{
  success,
  e
}

function getSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Settings:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettings_result:write(oprot)
  oprot:writeStructBegin('getSettings_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettingsAttributes_args = __TObject:new{
  attrBitset
}

function getSettingsAttributes_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attrBitset = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettingsAttributes_args:write(oprot)
  oprot:writeStructBegin('getSettingsAttributes_args')
  if self.attrBitset ~= nil then
    oprot:writeFieldBegin('attrBitset', TType.I32, 2)
    oprot:writeI32(self.attrBitset)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettingsAttributes_result = __TObject:new{
  success,
  e
}

function getSettingsAttributes_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Settings:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettingsAttributes_result:write(oprot)
  oprot:writeStructBegin('getSettingsAttributes_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSystemConfiguration_args = __TObject:new{

}

function getSystemConfiguration_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSystemConfiguration_args:write(oprot)
  oprot:writeStructBegin('getSystemConfiguration_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSystemConfiguration_result = __TObject:new{
  success,
  e
}

function getSystemConfiguration_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = SystemConfiguration:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSystemConfiguration_result:write(oprot)
  oprot:writeStructBegin('getSystemConfiguration_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getUserTicket_args = __TObject:new{

}

function getUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getUserTicket_args:write(oprot)
  oprot:writeStructBegin('getUserTicket_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getUserTicket_result = __TObject:new{
  success,
  e
}

function getUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Ticket:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getUserTicket_result:write(oprot)
  oprot:writeStructBegin('getUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getWapInvitation_args = __TObject:new{
  invitationHash
}

function getWapInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.invitationHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getWapInvitation_args:write(oprot)
  oprot:writeStructBegin('getWapInvitation_args')
  if self.invitationHash ~= nil then
    oprot:writeFieldBegin('invitationHash', TType.STRING, 2)
    oprot:writeString(self.invitationHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getWapInvitation_result = __TObject:new{
  success,
  e
}

function getWapInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = WapInvitation:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getWapInvitation_result:write(oprot)
  oprot:writeStructBegin('getWapInvitation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

invalidateUserTicket_args = __TObject:new{

}

function invalidateUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function invalidateUserTicket_args:write(oprot)
  oprot:writeStructBegin('invalidateUserTicket_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

invalidateUserTicket_result = __TObject:new{
  e
}

function invalidateUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function invalidateUserTicket_result:write(oprot)
  oprot:writeStructBegin('invalidateUserTicket_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteFriendsBySms_args = __TObject:new{
  phoneNumberList
}

function inviteFriendsBySms_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.phoneNumberList = {}
        local _etype949, _size946 = iprot:readListBegin()
        for _i=1,_size946 do
          local _elem950 = iprot:readString()
          table.insert(self.phoneNumberList, _elem950)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteFriendsBySms_args:write(oprot)
  oprot:writeStructBegin('inviteFriendsBySms_args')
  if self.phoneNumberList ~= nil then
    oprot:writeFieldBegin('phoneNumberList', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.phoneNumberList)
    for _,iter951 in ipairs(self.phoneNumberList) do
      oprot:writeString(iter951)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteFriendsBySms_result = __TObject:new{
  e
}

function inviteFriendsBySms_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteFriendsBySms_result:write(oprot)
  oprot:writeStructBegin('inviteFriendsBySms_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoGroup_args = __TObject:new{
  reqSeq,
  groupId,
  contactIds
}

function inviteIntoGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype955, _size952 = iprot:readListBegin()
        for _i=1,_size952 do
          local _elem956 = iprot:readString()
          table.insert(self.contactIds, _elem956)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoGroup_args:write(oprot)
  oprot:writeStructBegin('inviteIntoGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter957 in ipairs(self.contactIds) do
      oprot:writeString(iter957)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoGroup_result = __TObject:new{
  e
}

function inviteIntoGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoGroup_result:write(oprot)
  oprot:writeStructBegin('inviteIntoGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoRoom_args = __TObject:new{
  reqSeq,
  roomId,
  contactIds
}

function inviteIntoRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype961, _size958 = iprot:readListBegin()
        for _i=1,_size958 do
          local _elem962 = iprot:readString()
          table.insert(self.contactIds, _elem962)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoRoom_args:write(oprot)
  oprot:writeStructBegin('inviteIntoRoom_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter963 in ipairs(self.contactIds) do
      oprot:writeString(iter963)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoRoom_result = __TObject:new{
  e
}

function inviteIntoRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoRoom_result:write(oprot)
  oprot:writeStructBegin('inviteIntoRoom_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteViaEmail_args = __TObject:new{
  reqSeq,
  email,
  name
}

function inviteViaEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.email = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.name = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteViaEmail_args:write(oprot)
  oprot:writeStructBegin('inviteViaEmail_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.email ~= nil then
    oprot:writeFieldBegin('email', TType.STRING, 2)
    oprot:writeString(self.email)
    oprot:writeFieldEnd()
  end
  if self.name ~= nil then
    oprot:writeFieldBegin('name', TType.STRING, 3)
    oprot:writeString(self.name)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteViaEmail_result = __TObject:new{
  e
}

function inviteViaEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteViaEmail_result:write(oprot)
  oprot:writeStructBegin('inviteViaEmail_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isIdentityIdentifierAvailable_args = __TObject:new{
  provider,
  identifier
}

function isIdentityIdentifierAvailable_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isIdentityIdentifierAvailable_args:write(oprot)
  oprot:writeStructBegin('isIdentityIdentifierAvailable_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 3)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isIdentityIdentifierAvailable_result = __TObject:new{
  success,
  e
}

function isIdentityIdentifierAvailable_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isIdentityIdentifierAvailable_result:write(oprot)
  oprot:writeStructBegin('isIdentityIdentifierAvailable_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isUseridAvailable_args = __TObject:new{
  userid
}

function isUseridAvailable_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isUseridAvailable_args:write(oprot)
  oprot:writeStructBegin('isUseridAvailable_args')
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isUseridAvailable_result = __TObject:new{
  success,
  e
}

function isUseridAvailable_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isUseridAvailable_result:write(oprot)
  oprot:writeStructBegin('isUseridAvailable_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

kickoutFromGroup_args = __TObject:new{
  reqSeq,
  groupId,
  contactIds
}

function kickoutFromGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype967, _size964 = iprot:readListBegin()
        for _i=1,_size964 do
          local _elem968 = iprot:readString()
          table.insert(self.contactIds, _elem968)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function kickoutFromGroup_args:write(oprot)
  oprot:writeStructBegin('kickoutFromGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter969 in ipairs(self.contactIds) do
      oprot:writeString(iter969)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

kickoutFromGroup_result = __TObject:new{
  e
}

function kickoutFromGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function kickoutFromGroup_result:write(oprot)
  oprot:writeStructBegin('kickoutFromGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveGroup_args = __TObject:new{
  reqSeq,
  groupId
}

function leaveGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveGroup_args:write(oprot)
  oprot:writeStructBegin('leaveGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveGroup_result = __TObject:new{
  e
}

function leaveGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveGroup_result:write(oprot)
  oprot:writeStructBegin('leaveGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveRoom_args = __TObject:new{
  reqSeq,
  roomId
}

function leaveRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveRoom_args:write(oprot)
  oprot:writeStructBegin('leaveRoom_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveRoom_result = __TObject:new{
  e
}

function leaveRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveRoom_result:write(oprot)
  oprot:writeStructBegin('leaveRoom_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredential_args = __TObject:new{
  identityProvider,
  identifier,
  password,
  keepLoggedIn,
  accessLocation,
  systemName,
  certificate
}

function loginWithIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.identityProvider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.password = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.BOOL then
        self.keepLoggedIn = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.accessLocation = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.systemName = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRING then
        self.certificate = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredential_args')
  if self.identityProvider ~= nil then
    oprot:writeFieldBegin('identityProvider', TType.I32, 8)
    oprot:writeI32(self.identityProvider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.password ~= nil then
    oprot:writeFieldBegin('password', TType.STRING, 4)
    oprot:writeString(self.password)
    oprot:writeFieldEnd()
  end
  if self.keepLoggedIn ~= nil then
    oprot:writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
    oprot:writeBool(self.keepLoggedIn)
    oprot:writeFieldEnd()
  end
  if self.accessLocation ~= nil then
    oprot:writeFieldBegin('accessLocation', TType.STRING, 6)
    oprot:writeString(self.accessLocation)
    oprot:writeFieldEnd()
  end
  if self.systemName ~= nil then
    oprot:writeFieldBegin('systemName', TType.STRING, 7)
    oprot:writeString(self.systemName)
    oprot:writeFieldEnd()
  end
  if self.certificate ~= nil then
    oprot:writeFieldBegin('certificate', TType.STRING, 9)
    oprot:writeString(self.certificate)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredential_result = __TObject:new{
  success,
  e
}

function loginWithIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredentialForCertificate_args = __TObject:new{
  identityProvider,
  identifier,
  password,
  keepLoggedIn,
  accessLocation,
  systemName,
  certificate
}

function loginWithIdentityCredentialForCertificate_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.identityProvider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.password = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.BOOL then
        self.keepLoggedIn = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.accessLocation = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.systemName = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRING then
        self.certificate = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredentialForCertificate_args:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredentialForCertificate_args')
  if self.identityProvider ~= nil then
    oprot:writeFieldBegin('identityProvider', TType.I32, 8)
    oprot:writeI32(self.identityProvider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.password ~= nil then
    oprot:writeFieldBegin('password', TType.STRING, 4)
    oprot:writeString(self.password)
    oprot:writeFieldEnd()
  end
  if self.keepLoggedIn ~= nil then
    oprot:writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
    oprot:writeBool(self.keepLoggedIn)
    oprot:writeFieldEnd()
  end
  if self.accessLocation ~= nil then
    oprot:writeFieldBegin('accessLocation', TType.STRING, 6)
    oprot:writeString(self.accessLocation)
    oprot:writeFieldEnd()
  end
  if self.systemName ~= nil then
    oprot:writeFieldBegin('systemName', TType.STRING, 7)
    oprot:writeString(self.systemName)
    oprot:writeFieldEnd()
  end
  if self.certificate ~= nil then
    oprot:writeFieldBegin('certificate', TType.STRING, 9)
    oprot:writeString(self.certificate)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredentialForCertificate_result = __TObject:new{
  success,
  e
}

function loginWithIdentityCredentialForCertificate_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = LoginResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredentialForCertificate_result:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredentialForCertificate_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifier_args = __TObject:new{
  verifier
}

function loginWithVerifier_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifier_args:write(oprot)
  oprot:writeStructBegin('loginWithVerifier_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifier_result = __TObject:new{
  success,
  e
}

function loginWithVerifier_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifier_result:write(oprot)
  oprot:writeStructBegin('loginWithVerifier_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCerificate_args = __TObject:new{
  verifier
}

function loginWithVerifierForCerificate_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCerificate_args:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCerificate_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCerificate_result = __TObject:new{
  success,
  e
}

function loginWithVerifierForCerificate_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = LoginResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCerificate_result:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCerificate_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCertificate_args = __TObject:new{
  verifier
}

function loginWithVerifierForCertificate_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCertificate_args:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCertificate_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCertificate_result = __TObject:new{
  success,
  e
}

function loginWithVerifierForCertificate_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = LoginResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCertificate_result:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCertificate_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logout_args = __TObject:new{

}

function logout_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logout_args:write(oprot)
  oprot:writeStructBegin('logout_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logout_result = __TObject:new{
  e
}

function logout_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logout_result:write(oprot)
  oprot:writeStructBegin('logout_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logoutSession_args = __TObject:new{
  tokenKey
}

function logoutSession_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.tokenKey = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logoutSession_args:write(oprot)
  oprot:writeStructBegin('logoutSession_args')
  if self.tokenKey ~= nil then
    oprot:writeFieldBegin('tokenKey', TType.STRING, 2)
    oprot:writeString(self.tokenKey)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logoutSession_result = __TObject:new{
  e
}

function logoutSession_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logoutSession_result:write(oprot)
  oprot:writeStructBegin('logoutSession_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

noop_args = __TObject:new{

}

function noop_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function noop_args:write(oprot)
  oprot:writeStructBegin('noop_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

noop_result = __TObject:new{
  e
}

function noop_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function noop_result:write(oprot)
  oprot:writeStructBegin('noop_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifiedRedirect_args = __TObject:new{
  paramMap
}

function notifiedRedirect_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.MAP then
        self.paramMap = {}
        local _ktype971, _vtype972, _size970 = iprot:readMapBegin() 
        for _i=1,_size970 do
          local _key974 = iprot:readString()
          local _val975 = iprot:readString()
          self.paramMap[_key974] = _val975
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifiedRedirect_args:write(oprot)
  oprot:writeStructBegin('notifiedRedirect_args')
  if self.paramMap ~= nil then
    oprot:writeFieldBegin('paramMap', TType.MAP, 2)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.paramMap))
    for kiter976,viter977 in pairs(self.paramMap) do
      oprot:writeString(kiter976)
      oprot:writeString(viter977)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifiedRedirect_result = __TObject:new{
  e
}

function notifiedRedirect_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifiedRedirect_result:write(oprot)
  oprot:writeStructBegin('notifiedRedirect_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyBuddyOnAir_args = __TObject:new{
  seq,
  receiverMids
}

function notifyBuddyOnAir_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype981, _size978 = iprot:readListBegin()
        for _i=1,_size978 do
          local _elem982 = iprot:readString()
          table.insert(self.receiverMids, _elem982)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyBuddyOnAir_args:write(oprot)
  oprot:writeStructBegin('notifyBuddyOnAir_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter983 in ipairs(self.receiverMids) do
      oprot:writeString(iter983)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyBuddyOnAir_result = __TObject:new{
  success,
  e
}

function notifyBuddyOnAir_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype985, _vtype986, _size984 = iprot:readMapBegin() 
        for _i=1,_size984 do
          local _key988 = iprot:readString()
          local _val989 = iprot:readString()
          self.success[_key988] = _val989
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyBuddyOnAir_result:write(oprot)
  oprot:writeStructBegin('notifyBuddyOnAir_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter990,viter991 in pairs(self.success) do
      oprot:writeString(kiter990)
      oprot:writeString(viter991)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyIndividualEvent_args = __TObject:new{
  notificationStatus,
  receiverMids
}

function notifyIndividualEvent_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.notificationStatus = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype995, _size992 = iprot:readListBegin()
        for _i=1,_size992 do
          local _elem996 = iprot:readString()
          table.insert(self.receiverMids, _elem996)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyIndividualEvent_args:write(oprot)
  oprot:writeStructBegin('notifyIndividualEvent_args')
  if self.notificationStatus ~= nil then
    oprot:writeFieldBegin('notificationStatus', TType.I32, 2)
    oprot:writeI32(self.notificationStatus)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter997 in ipairs(self.receiverMids) do
      oprot:writeString(iter997)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyIndividualEvent_result = __TObject:new{
  e
}

function notifyIndividualEvent_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyIndividualEvent_result:write(oprot)
  oprot:writeStructBegin('notifyIndividualEvent_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyInstalled_args = __TObject:new{
  udidHash,
  applicationTypeWithExtensions
}

function notifyInstalled_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.applicationTypeWithExtensions = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyInstalled_args:write(oprot)
  oprot:writeStructBegin('notifyInstalled_args')
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 2)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.applicationTypeWithExtensions ~= nil then
    oprot:writeFieldBegin('applicationTypeWithExtensions', TType.STRING, 3)
    oprot:writeString(self.applicationTypeWithExtensions)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyInstalled_result = __TObject:new{

}

function notifyInstalled_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyInstalled_result:write(oprot)
  oprot:writeStructBegin('notifyInstalled_result')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyRegistrationComplete_args = __TObject:new{
  udidHash,
  applicationTypeWithExtensions
}

function notifyRegistrationComplete_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.applicationTypeWithExtensions = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyRegistrationComplete_args:write(oprot)
  oprot:writeStructBegin('notifyRegistrationComplete_args')
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 2)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.applicationTypeWithExtensions ~= nil then
    oprot:writeFieldBegin('applicationTypeWithExtensions', TType.STRING, 3)
    oprot:writeString(self.applicationTypeWithExtensions)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyRegistrationComplete_result = __TObject:new{

}

function notifyRegistrationComplete_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyRegistrationComplete_result:write(oprot)
  oprot:writeStructBegin('notifyRegistrationComplete_result')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifySleep_args = __TObject:new{
  lastRev,
  badge
}

function notifySleep_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.lastRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.badge = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifySleep_args:write(oprot)
  oprot:writeStructBegin('notifySleep_args')
  if self.lastRev ~= nil then
    oprot:writeFieldBegin('lastRev', TType.I64, 2)
    oprot:writeI64(self.lastRev)
    oprot:writeFieldEnd()
  end
  if self.badge ~= nil then
    oprot:writeFieldBegin('badge', TType.I32, 3)
    oprot:writeI32(self.badge)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifySleep_result = __TObject:new{
  e
}

function notifySleep_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifySleep_result:write(oprot)
  oprot:writeStructBegin('notifySleep_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyUpdated_args = __TObject:new{
  lastRev,
  deviceInfo
}

function notifyUpdated_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.lastRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyUpdated_args:write(oprot)
  oprot:writeStructBegin('notifyUpdated_args')
  if self.lastRev ~= nil then
    oprot:writeFieldBegin('lastRev', TType.I64, 2)
    oprot:writeI64(self.lastRev)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 3)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyUpdated_result = __TObject:new{
  e
}

function notifyUpdated_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyUpdated_result:write(oprot)
  oprot:writeStructBegin('notifyUpdated_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

openProximityMatch_args = __TObject:new{
  location
}

function openProximityMatch_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.location = Location:new{}
        self.location:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function openProximityMatch_args:write(oprot)
  oprot:writeStructBegin('openProximityMatch_args')
  if self.location ~= nil then
    oprot:writeFieldBegin('location', TType.STRUCT, 2)
    self.location:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

openProximityMatch_result = __TObject:new{
  success,
  e
}

function openProximityMatch_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function openProximityMatch_result:write(oprot)
  oprot:writeStructBegin('openProximityMatch_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUser_args = __TObject:new{
  buddyId,
  registrarPassword
}

function registerBuddyUser_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.buddyId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.registrarPassword = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUser_args:write(oprot)
  oprot:writeStructBegin('registerBuddyUser_args')
  if self.buddyId ~= nil then
    oprot:writeFieldBegin('buddyId', TType.STRING, 2)
    oprot:writeString(self.buddyId)
    oprot:writeFieldEnd()
  end
  if self.registrarPassword ~= nil then
    oprot:writeFieldBegin('registrarPassword', TType.STRING, 3)
    oprot:writeString(self.registrarPassword)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUser_result = __TObject:new{
  success,
  e
}

function registerBuddyUser_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUser_result:write(oprot)
  oprot:writeStructBegin('registerBuddyUser_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUserid_args = __TObject:new{
  seq,
  userid
}

function registerBuddyUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUserid_args:write(oprot)
  oprot:writeStructBegin('registerBuddyUserid_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 2)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 3)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUserid_result = __TObject:new{
  e
}

function registerBuddyUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUserid_result:write(oprot)
  oprot:writeStructBegin('registerBuddyUserid_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDevice_args = __TObject:new{
  sessionId
}

function registerDevice_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDevice_args:write(oprot)
  oprot:writeStructBegin('registerDevice_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDevice_result = __TObject:new{
  success,
  e
}

function registerDevice_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDevice_result:write(oprot)
  oprot:writeStructBegin('registerDevice_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithIdentityCredential_args = __TObject:new{
  sessionId,
  provider,
  identifier,
  verifier
}

function registerDeviceWithIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerDeviceWithIdentityCredential_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 5)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 4)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerDeviceWithIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerDeviceWithIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumber_args = __TObject:new{
  region,
  udidHash,
  deviceInfo
}

function registerDeviceWithoutPhoneNumber_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumber_args:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumber_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 3)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 4)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumber_result = __TObject:new{
  success,
  e
}

function registerDeviceWithoutPhoneNumber_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumber_result:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumber_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumberWithIdentityCredential_args = __TObject:new{
  region,
  udidHash,
  deviceInfo,
  provider,
  identifier,
  verifier,
  mid
}

function registerDeviceWithoutPhoneNumberWithIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumberWithIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 3)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 4)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 5)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 6)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 7)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 8)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumberWithIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerDeviceWithoutPhoneNumberWithIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumberWithIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerUserid_args = __TObject:new{
  reqSeq,
  userid
}

function registerUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerUserid_args:write(oprot)
  oprot:writeStructBegin('registerUserid_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerUserid_result = __TObject:new{
  success,
  e
}

function registerUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerUserid_result:write(oprot)
  oprot:writeStructBegin('registerUserid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWapDevice_args = __TObject:new{
  invitationHash,
  guidHash,
  email,
  deviceInfo
}

function registerWapDevice_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.invitationHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.guidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.email = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWapDevice_args:write(oprot)
  oprot:writeStructBegin('registerWapDevice_args')
  if self.invitationHash ~= nil then
    oprot:writeFieldBegin('invitationHash', TType.STRING, 2)
    oprot:writeString(self.invitationHash)
    oprot:writeFieldEnd()
  end
  if self.guidHash ~= nil then
    oprot:writeFieldBegin('guidHash', TType.STRING, 3)
    oprot:writeString(self.guidHash)
    oprot:writeFieldEnd()
  end
  if self.email ~= nil then
    oprot:writeFieldBegin('email', TType.STRING, 4)
    oprot:writeString(self.email)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 5)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWapDevice_result = __TObject:new{
  success,
  e
}

function registerWapDevice_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWapDevice_result:write(oprot)
  oprot:writeStructBegin('registerWapDevice_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithExistingSnsIdAndIdentityCredential_args = __TObject:new{
  identityCredential,
  region,
  udidHash,
  deviceInfo
}

function registerWithExistingSnsIdAndIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.identityCredential = IdentityCredential:new{}
        self.identityCredential:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithExistingSnsIdAndIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerWithExistingSnsIdAndIdentityCredential_args')
  if self.identityCredential ~= nil then
    oprot:writeFieldBegin('identityCredential', TType.STRUCT, 2)
    self.identityCredential:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 3)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 4)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 5)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithExistingSnsIdAndIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerWithExistingSnsIdAndIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithExistingSnsIdAndIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerWithExistingSnsIdAndIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsId_args = __TObject:new{
  snsIdType,
  snsAccessToken,
  region,
  udidHash,
  deviceInfo,
  mid
}

function registerWithSnsId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsId_args:write(oprot)
  oprot:writeStructBegin('registerWithSnsId_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 4)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 5)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 6)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 7)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsId_result = __TObject:new{
  success,
  e
}

function registerWithSnsId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = RegisterWithSnsIdResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsId_result:write(oprot)
  oprot:writeStructBegin('registerWithSnsId_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsIdAndIdentityCredential_args = __TObject:new{
  snsIdType,
  snsAccessToken,
  identityCredential,
  region,
  udidHash,
  deviceInfo
}

function registerWithSnsIdAndIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.identityCredential = IdentityCredential:new{}
        self.identityCredential:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsIdAndIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerWithSnsIdAndIdentityCredential_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  if self.identityCredential ~= nil then
    oprot:writeFieldBegin('identityCredential', TType.STRUCT, 4)
    self.identityCredential:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 5)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 6)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 7)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsIdAndIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerWithSnsIdAndIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsIdAndIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerWithSnsIdAndIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueDeviceCredential_args = __TObject:new{

}

function reissueDeviceCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueDeviceCredential_args:write(oprot)
  oprot:writeStructBegin('reissueDeviceCredential_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueDeviceCredential_result = __TObject:new{
  success,
  e
}

function reissueDeviceCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueDeviceCredential_result:write(oprot)
  oprot:writeStructBegin('reissueDeviceCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueUserTicket_args = __TObject:new{
  expirationTime,
  maxUseCount
}

function reissueUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.expirationTime = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.maxUseCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueUserTicket_args:write(oprot)
  oprot:writeStructBegin('reissueUserTicket_args')
  if self.expirationTime ~= nil then
    oprot:writeFieldBegin('expirationTime', TType.I64, 3)
    oprot:writeI64(self.expirationTime)
    oprot:writeFieldEnd()
  end
  if self.maxUseCount ~= nil then
    oprot:writeFieldBegin('maxUseCount', TType.I32, 4)
    oprot:writeI32(self.maxUseCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueUserTicket_result = __TObject:new{
  success,
  e
}

function reissueUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueUserTicket_result:write(oprot)
  oprot:writeStructBegin('reissueUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

rejectGroupInvitation_args = __TObject:new{
  reqSeq,
  groupId
}

function rejectGroupInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function rejectGroupInvitation_args:write(oprot)
  oprot:writeStructBegin('rejectGroupInvitation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

rejectGroupInvitation_result = __TObject:new{
  e
}

function rejectGroupInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function rejectGroupInvitation_result:write(oprot)
  oprot:writeStructBegin('rejectGroupInvitation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

releaseSession_args = __TObject:new{

}

function releaseSession_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function releaseSession_args:write(oprot)
  oprot:writeStructBegin('releaseSession_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

releaseSession_result = __TObject:new{
  e
}

function releaseSession_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function releaseSession_result:write(oprot)
  oprot:writeStructBegin('releaseSession_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeAllMessages_args = __TObject:new{
  seq,
  lastMessageId
}

function removeAllMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.lastMessageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeAllMessages_args:write(oprot)
  oprot:writeStructBegin('removeAllMessages_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.lastMessageId ~= nil then
    oprot:writeFieldBegin('lastMessageId', TType.STRING, 2)
    oprot:writeString(self.lastMessageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeAllMessages_result = __TObject:new{
  e
}

function removeAllMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeAllMessages_result:write(oprot)
  oprot:writeStructBegin('removeAllMessages_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeBuddyLocation_args = __TObject:new{
  mid,
  index
}

function removeBuddyLocation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.index = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeBuddyLocation_args:write(oprot)
  oprot:writeStructBegin('removeBuddyLocation_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.index ~= nil then
    oprot:writeFieldBegin('index', TType.I32, 3)
    oprot:writeI32(self.index)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeBuddyLocation_result = __TObject:new{
  e
}

function removeBuddyLocation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeBuddyLocation_result:write(oprot)
  oprot:writeStructBegin('removeBuddyLocation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessage_args = __TObject:new{
  messageId
}

function removeMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessage_args:write(oprot)
  oprot:writeStructBegin('removeMessage_args')
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessage_result = __TObject:new{
  success,
  e
}

function removeMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessage_result:write(oprot)
  oprot:writeStructBegin('removeMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessageFromMyHome_args = __TObject:new{
  messageId
}

function removeMessageFromMyHome_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessageFromMyHome_args:write(oprot)
  oprot:writeStructBegin('removeMessageFromMyHome_args')
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessageFromMyHome_result = __TObject:new{
  success,
  e
}

function removeMessageFromMyHome_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessageFromMyHome_result:write(oprot)
  oprot:writeStructBegin('removeMessageFromMyHome_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeSnsId_args = __TObject:new{
  snsIdType
}

function removeSnsId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeSnsId_args:write(oprot)
  oprot:writeStructBegin('removeSnsId_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeSnsId_result = __TObject:new{
  success,
  e
}

function removeSnsId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeSnsId_result:write(oprot)
  oprot:writeStructBegin('removeSnsId_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

report_args = __TObject:new{
  syncOpRevision,
  category,
  report
}

function report_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.category = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.report = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function report_args:write(oprot)
  oprot:writeStructBegin('report_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.category ~= nil then
    oprot:writeFieldBegin('category', TType.I32, 3)
    oprot:writeI32(self.category)
    oprot:writeFieldEnd()
  end
  if self.report ~= nil then
    oprot:writeFieldBegin('report', TType.STRING, 4)
    oprot:writeString(self.report)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

report_result = __TObject:new{
  e
}

function report_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function report_result:write(oprot)
  oprot:writeStructBegin('report_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportContacts_args = __TObject:new{
  syncOpRevision,
  category,
  contactReports,
  actionType
}

function reportContacts_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.category = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.LIST then
        self.contactReports = {}
        local _etype1001, _size998 = iprot:readListBegin()
        for _i=1,_size998 do
          local _elem1002 = ContactReport:new{}
          _elem1002:read(iprot)
          table.insert(self.contactReports, _elem1002)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.actionType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportContacts_args:write(oprot)
  oprot:writeStructBegin('reportContacts_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.category ~= nil then
    oprot:writeFieldBegin('category', TType.I32, 3)
    oprot:writeI32(self.category)
    oprot:writeFieldEnd()
  end
  if self.contactReports ~= nil then
    oprot:writeFieldBegin('contactReports', TType.LIST, 4)
    oprot:writeListBegin(TType.STRUCT, #self.contactReports)
    for _,iter1003 in ipairs(self.contactReports) do
      iter1003:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.actionType ~= nil then
    oprot:writeFieldBegin('actionType', TType.I32, 5)
    oprot:writeI32(self.actionType)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportContacts_result = __TObject:new{
  success,
  e
}

function reportContacts_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1007, _size1004 = iprot:readListBegin()
        for _i=1,_size1004 do
          local _elem1008 = ContactReportResult:new{}
          _elem1008:read(iprot)
          table.insert(self.success, _elem1008)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportContacts_result:write(oprot)
  oprot:writeStructBegin('reportContacts_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1009 in ipairs(self.success) do
      iter1009:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportGroups_args = __TObject:new{
  syncOpRevision,
  groups
}

function reportGroups_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.groups = {}
        local _etype1013, _size1010 = iprot:readListBegin()
        for _i=1,_size1010 do
          local _elem1014 = Group:new{}
          _elem1014:read(iprot)
          table.insert(self.groups, _elem1014)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportGroups_args:write(oprot)
  oprot:writeStructBegin('reportGroups_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.groups ~= nil then
    oprot:writeFieldBegin('groups', TType.LIST, 3)
    oprot:writeListBegin(TType.STRUCT, #self.groups)
    for _,iter1015 in ipairs(self.groups) do
      iter1015:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportGroups_result = __TObject:new{
  e
}

function reportGroups_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportGroups_result:write(oprot)
  oprot:writeStructBegin('reportGroups_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportProfile_args = __TObject:new{
  syncOpRevision,
  profile
}

function reportProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.profile = Profile:new{}
        self.profile:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportProfile_args:write(oprot)
  oprot:writeStructBegin('reportProfile_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.profile ~= nil then
    oprot:writeFieldBegin('profile', TType.STRUCT, 3)
    self.profile:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportProfile_result = __TObject:new{
  e
}

function reportProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportProfile_result:write(oprot)
  oprot:writeStructBegin('reportProfile_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportRooms_args = __TObject:new{
  syncOpRevision,
  rooms
}

function reportRooms_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.rooms = {}
        local _etype1019, _size1016 = iprot:readListBegin()
        for _i=1,_size1016 do
          local _elem1020 = Room:new{}
          _elem1020:read(iprot)
          table.insert(self.rooms, _elem1020)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportRooms_args:write(oprot)
  oprot:writeStructBegin('reportRooms_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.rooms ~= nil then
    oprot:writeFieldBegin('rooms', TType.LIST, 3)
    oprot:writeListBegin(TType.STRUCT, #self.rooms)
    for _,iter1021 in ipairs(self.rooms) do
      iter1021:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportRooms_result = __TObject:new{
  e
}

function reportRooms_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportRooms_result:write(oprot)
  oprot:writeStructBegin('reportRooms_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSettings_args = __TObject:new{
  syncOpRevision,
  settings
}

function reportSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSettings_args:write(oprot)
  oprot:writeStructBegin('reportSettings_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 3)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSettings_result = __TObject:new{
  e
}

function reportSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSettings_result:write(oprot)
  oprot:writeStructBegin('reportSettings_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSpammer_args = __TObject:new{
  spammerMid,
  spammerReasons,
  spamMessageIds
}

function reportSpammer_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.spammerMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.spammerReasons = {}
        local _etype1025, _size1022 = iprot:readListBegin()
        for _i=1,_size1022 do
          local _elem1026 = iprot:readI32()
          table.insert(self.spammerReasons, _elem1026)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.LIST then
        self.spamMessageIds = {}
        local _etype1030, _size1027 = iprot:readListBegin()
        for _i=1,_size1027 do
          local _elem1031 = iprot:readString()
          table.insert(self.spamMessageIds, _elem1031)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSpammer_args:write(oprot)
  oprot:writeStructBegin('reportSpammer_args')
  if self.spammerMid ~= nil then
    oprot:writeFieldBegin('spammerMid', TType.STRING, 2)
    oprot:writeString(self.spammerMid)
    oprot:writeFieldEnd()
  end
  if self.spammerReasons ~= nil then
    oprot:writeFieldBegin('spammerReasons', TType.LIST, 3)
    oprot:writeListBegin(TType.I32, #self.spammerReasons)
    for _,iter1032 in ipairs(self.spammerReasons) do
      oprot:writeI32(iter1032)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.spamMessageIds ~= nil then
    oprot:writeFieldBegin('spamMessageIds', TType.LIST, 4)
    oprot:writeListBegin(TType.STRING, #self.spamMessageIds)
    for _,iter1033 in ipairs(self.spamMessageIds) do
      oprot:writeString(iter1033)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSpammer_result = __TObject:new{
  e
}

function reportSpammer_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSpammer_result:write(oprot)
  oprot:writeStructBegin('reportSpammer_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestAccountPasswordReset_args = __TObject:new{
  provider,
  identifier,
  locale
}

function requestAccountPasswordReset_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.locale = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestAccountPasswordReset_args:write(oprot)
  oprot:writeStructBegin('requestAccountPasswordReset_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 4)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.locale ~= nil then
    oprot:writeFieldBegin('locale', TType.STRING, 5)
    oprot:writeString(self.locale)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestAccountPasswordReset_result = __TObject:new{
  e
}

function requestAccountPasswordReset_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestAccountPasswordReset_result:write(oprot)
  oprot:writeStructBegin('requestAccountPasswordReset_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestEmailConfirmation_args = __TObject:new{
  emailConfirmation
}

function requestEmailConfirmation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.emailConfirmation = EmailConfirmation:new{}
        self.emailConfirmation:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestEmailConfirmation_args:write(oprot)
  oprot:writeStructBegin('requestEmailConfirmation_args')
  if self.emailConfirmation ~= nil then
    oprot:writeFieldBegin('emailConfirmation', TType.STRUCT, 2)
    self.emailConfirmation:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestEmailConfirmation_result = __TObject:new{
  success,
  e
}

function requestEmailConfirmation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = EmailConfirmationSession:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestEmailConfirmation_result:write(oprot)
  oprot:writeStructBegin('requestEmailConfirmation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestIdentityUnbind_args = __TObject:new{
  provider,
  identifier
}

function requestIdentityUnbind_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestIdentityUnbind_args:write(oprot)
  oprot:writeStructBegin('requestIdentityUnbind_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 4)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestIdentityUnbind_result = __TObject:new{
  e
}

function requestIdentityUnbind_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestIdentityUnbind_result:write(oprot)
  oprot:writeStructBegin('requestIdentityUnbind_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendEmailConfirmation_args = __TObject:new{
  verifier
}

function resendEmailConfirmation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendEmailConfirmation_args:write(oprot)
  oprot:writeStructBegin('resendEmailConfirmation_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 2)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendEmailConfirmation_result = __TObject:new{
  success,
  e
}

function resendEmailConfirmation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = EmailConfirmationSession:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendEmailConfirmation_result:write(oprot)
  oprot:writeStructBegin('resendEmailConfirmation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCode_args = __TObject:new{
  sessionId
}

function resendPinCode_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCode_args:write(oprot)
  oprot:writeStructBegin('resendPinCode_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCode_result = __TObject:new{
  e
}

function resendPinCode_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCode_result:write(oprot)
  oprot:writeStructBegin('resendPinCode_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCodeBySMS_args = __TObject:new{
  sessionId
}

function resendPinCodeBySMS_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCodeBySMS_args:write(oprot)
  oprot:writeStructBegin('resendPinCodeBySMS_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCodeBySMS_result = __TObject:new{
  e
}

function resendPinCodeBySMS_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCodeBySMS_result:write(oprot)
  oprot:writeStructBegin('resendPinCodeBySMS_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatChecked_args = __TObject:new{
  seq,
  consumer,
  lastMessageId
}

function sendChatChecked_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.lastMessageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatChecked_args:write(oprot)
  oprot:writeStructBegin('sendChatChecked_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.lastMessageId ~= nil then
    oprot:writeFieldBegin('lastMessageId', TType.STRING, 3)
    oprot:writeString(self.lastMessageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatChecked_result = __TObject:new{
  e
}

function sendChatChecked_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatChecked_result:write(oprot)
  oprot:writeStructBegin('sendChatChecked_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatRemoved_args = __TObject:new{
  seq,
  consumer,
  lastMessageId
}

function sendChatRemoved_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.lastMessageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatRemoved_args:write(oprot)
  oprot:writeStructBegin('sendChatRemoved_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.lastMessageId ~= nil then
    oprot:writeFieldBegin('lastMessageId', TType.STRING, 3)
    oprot:writeString(self.lastMessageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatRemoved_result = __TObject:new{
  e
}

function sendChatRemoved_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatRemoved_result:write(oprot)
  oprot:writeStructBegin('sendChatRemoved_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentPreviewUpdated_args = __TObject:new{
  esq,
  messageId,
  receiverMids
}

function sendContentPreviewUpdated_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.esq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype1037, _size1034 = iprot:readListBegin()
        for _i=1,_size1034 do
          local _elem1038 = iprot:readString()
          table.insert(self.receiverMids, _elem1038)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentPreviewUpdated_args:write(oprot)
  oprot:writeStructBegin('sendContentPreviewUpdated_args')
  if self.esq ~= nil then
    oprot:writeFieldBegin('esq', TType.I32, 1)
    oprot:writeI32(self.esq)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter1039 in ipairs(self.receiverMids) do
      oprot:writeString(iter1039)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentPreviewUpdated_result = __TObject:new{
  success,
  e
}

function sendContentPreviewUpdated_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1041, _vtype1042, _size1040 = iprot:readMapBegin() 
        for _i=1,_size1040 do
          local _key1044 = iprot:readString()
          local _val1045 = iprot:readString()
          self.success[_key1044] = _val1045
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentPreviewUpdated_result:write(oprot)
  oprot:writeStructBegin('sendContentPreviewUpdated_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter1046,viter1047 in pairs(self.success) do
      oprot:writeString(kiter1046)
      oprot:writeString(viter1047)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentReceipt_args = __TObject:new{
  seq,
  consumer,
  messageId
}

function sendContentReceipt_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentReceipt_args:write(oprot)
  oprot:writeStructBegin('sendContentReceipt_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 3)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentReceipt_result = __TObject:new{
  e
}

function sendContentReceipt_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentReceipt_result:write(oprot)
  oprot:writeStructBegin('sendContentReceipt_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendDummyPush_args = __TObject:new{

}

function sendDummyPush_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendDummyPush_args:write(oprot)
  oprot:writeStructBegin('sendDummyPush_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendDummyPush_result = __TObject:new{
  e
}

function sendDummyPush_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendDummyPush_result:write(oprot)
  oprot:writeStructBegin('sendDummyPush_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendEvent_args = __TObject:new{
  seq,
  message
}

function sendEvent_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendEvent_args:write(oprot)
  oprot:writeStructBegin('sendEvent_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendEvent_result = __TObject:new{
  success,
  e
}

function sendEvent_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendEvent_result:write(oprot)
  oprot:writeStructBegin('sendEvent_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessage_args = __TObject:new{
  seq,
  message
}

function sendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessage_args:write(oprot)
  oprot:writeStructBegin('sendMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessage_result = __TObject:new{
  success,
  e
}

function sendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessage_result:write(oprot)
  oprot:writeStructBegin('sendMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageIgnored_args = __TObject:new{
  seq,
  consumer,
  messageIds
}

function sendMessageIgnored_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.messageIds = {}
        local _etype1051, _size1048 = iprot:readListBegin()
        for _i=1,_size1048 do
          local _elem1052 = iprot:readString()
          table.insert(self.messageIds, _elem1052)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageIgnored_args:write(oprot)
  oprot:writeStructBegin('sendMessageIgnored_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.messageIds ~= nil then
    oprot:writeFieldBegin('messageIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.messageIds)
    for _,iter1053 in ipairs(self.messageIds) do
      oprot:writeString(iter1053)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageIgnored_result = __TObject:new{
  e
}

function sendMessageIgnored_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageIgnored_result:write(oprot)
  oprot:writeStructBegin('sendMessageIgnored_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageReceipt_args = __TObject:new{
  seq,
  consumer,
  messageIds
}

function sendMessageReceipt_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.messageIds = {}
        local _etype1057, _size1054 = iprot:readListBegin()
        for _i=1,_size1054 do
          local _elem1058 = iprot:readString()
          table.insert(self.messageIds, _elem1058)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageReceipt_args:write(oprot)
  oprot:writeStructBegin('sendMessageReceipt_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.messageIds ~= nil then
    oprot:writeFieldBegin('messageIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.messageIds)
    for _,iter1059 in ipairs(self.messageIds) do
      oprot:writeString(iter1059)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageReceipt_result = __TObject:new{
  e
}

function sendMessageReceipt_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageReceipt_result:write(oprot)
  oprot:writeStructBegin('sendMessageReceipt_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageToMyHome_args = __TObject:new{
  seq,
  message
}

function sendMessageToMyHome_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageToMyHome_args:write(oprot)
  oprot:writeStructBegin('sendMessageToMyHome_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageToMyHome_result = __TObject:new{
  success,
  e
}

function sendMessageToMyHome_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageToMyHome_result:write(oprot)
  oprot:writeStructBegin('sendMessageToMyHome_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setBuddyLocation_args = __TObject:new{
  mid,
  index,
  location
}

function setBuddyLocation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.index = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.location = Geolocation:new{}
        self.location:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setBuddyLocation_args:write(oprot)
  oprot:writeStructBegin('setBuddyLocation_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.index ~= nil then
    oprot:writeFieldBegin('index', TType.I32, 3)
    oprot:writeI32(self.index)
    oprot:writeFieldEnd()
  end
  if self.location ~= nil then
    oprot:writeFieldBegin('location', TType.STRUCT, 4)
    self.location:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setBuddyLocation_result = __TObject:new{
  e
}

function setBuddyLocation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setBuddyLocation_result:write(oprot)
  oprot:writeStructBegin('setBuddyLocation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setIdentityCredential_args = __TObject:new{
  provider,
  identifier,
  verifier
}

function setIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('setIdentityCredential_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 4)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setIdentityCredential_result = __TObject:new{
  e
}

function setIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('setIdentityCredential_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setNotificationsEnabled_args = __TObject:new{
  reqSeq,
  type,
  target,
  enablement
}

function setNotificationsEnabled_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.target = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.BOOL then
        self.enablement = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setNotificationsEnabled_args:write(oprot)
  oprot:writeStructBegin('setNotificationsEnabled_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 2)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.target ~= nil then
    oprot:writeFieldBegin('target', TType.STRING, 3)
    oprot:writeString(self.target)
    oprot:writeFieldEnd()
  end
  if self.enablement ~= nil then
    oprot:writeFieldBegin('enablement', TType.BOOL, 4)
    oprot:writeBool(self.enablement)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setNotificationsEnabled_result = __TObject:new{
  e
}

function setNotificationsEnabled_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setNotificationsEnabled_result:write(oprot)
  oprot:writeStructBegin('setNotificationsEnabled_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startUpdateVerification_args = __TObject:new{
  region,
  carrier,
  phone,
  udidHash,
  deviceInfo,
  networkCode,
  locale
}

function startUpdateVerification_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.carrier = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.phone = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.networkCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRING then
        self.locale = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startUpdateVerification_args:write(oprot)
  oprot:writeStructBegin('startUpdateVerification_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.carrier ~= nil then
    oprot:writeFieldBegin('carrier', TType.I32, 3)
    oprot:writeI32(self.carrier)
    oprot:writeFieldEnd()
  end
  if self.phone ~= nil then
    oprot:writeFieldBegin('phone', TType.STRING, 4)
    oprot:writeString(self.phone)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 5)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 6)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.networkCode ~= nil then
    oprot:writeFieldBegin('networkCode', TType.STRING, 7)
    oprot:writeString(self.networkCode)
    oprot:writeFieldEnd()
  end
  if self.locale ~= nil then
    oprot:writeFieldBegin('locale', TType.STRING, 8)
    oprot:writeString(self.locale)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startUpdateVerification_result = __TObject:new{
  success,
  e
}

function startUpdateVerification_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = VerificationSessionData:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startUpdateVerification_result:write(oprot)
  oprot:writeStructBegin('startUpdateVerification_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startVerification_args = __TObject:new{
  region,
  carrier,
  phone,
  udidHash,
  deviceInfo,
  networkCode,
  mid,
  locale
}

function startVerification_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.carrier = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.phone = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.networkCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRING then
        self.locale = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startVerification_args:write(oprot)
  oprot:writeStructBegin('startVerification_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.carrier ~= nil then
    oprot:writeFieldBegin('carrier', TType.I32, 3)
    oprot:writeI32(self.carrier)
    oprot:writeFieldEnd()
  end
  if self.phone ~= nil then
    oprot:writeFieldBegin('phone', TType.STRING, 4)
    oprot:writeString(self.phone)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 5)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 6)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.networkCode ~= nil then
    oprot:writeFieldBegin('networkCode', TType.STRING, 7)
    oprot:writeString(self.networkCode)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 8)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.locale ~= nil then
    oprot:writeFieldBegin('locale', TType.STRING, 9)
    oprot:writeString(self.locale)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startVerification_result = __TObject:new{
  success,
  e
}

function startVerification_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = VerificationSessionData:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startVerification_result:write(oprot)
  oprot:writeStructBegin('startVerification_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

storeUpdateProfileAttribute_args = __TObject:new{
  seq,
  profileAttribute,
  value
}

function storeUpdateProfileAttribute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.profileAttribute = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function storeUpdateProfileAttribute_args:write(oprot)
  oprot:writeStructBegin('storeUpdateProfileAttribute_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.profileAttribute ~= nil then
    oprot:writeFieldBegin('profileAttribute', TType.I32, 2)
    oprot:writeI32(self.profileAttribute)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

storeUpdateProfileAttribute_result = __TObject:new{
  e
}

function storeUpdateProfileAttribute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function storeUpdateProfileAttribute_result:write(oprot)
  oprot:writeStructBegin('storeUpdateProfileAttribute_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContactBySnsIds_args = __TObject:new{
  reqSeq,
  modifications
}

function syncContactBySnsIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.modifications = {}
        local _etype1063, _size1060 = iprot:readListBegin()
        for _i=1,_size1060 do
          local _elem1064 = SnsFriendModification:new{}
          _elem1064:read(iprot)
          table.insert(self.modifications, _elem1064)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContactBySnsIds_args:write(oprot)
  oprot:writeStructBegin('syncContactBySnsIds_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.modifications ~= nil then
    oprot:writeFieldBegin('modifications', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.modifications)
    for _,iter1065 in ipairs(self.modifications) do
      iter1065:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContactBySnsIds_result = __TObject:new{
  success,
  e
}

function syncContactBySnsIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1069, _size1066 = iprot:readListBegin()
        for _i=1,_size1066 do
          local _elem1070 = SnsFriendContactRegistration:new{}
          _elem1070:read(iprot)
          table.insert(self.success, _elem1070)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContactBySnsIds_result:write(oprot)
  oprot:writeStructBegin('syncContactBySnsIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1071 in ipairs(self.success) do
      iter1071:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContacts_args = __TObject:new{
  reqSeq,
  localContacts
}

function syncContacts_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.localContacts = {}
        local _etype1075, _size1072 = iprot:readListBegin()
        for _i=1,_size1072 do
          local _elem1076 = ContactModification:new{}
          _elem1076:read(iprot)
          table.insert(self.localContacts, _elem1076)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContacts_args:write(oprot)
  oprot:writeStructBegin('syncContacts_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.localContacts ~= nil then
    oprot:writeFieldBegin('localContacts', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.localContacts)
    for _,iter1077 in ipairs(self.localContacts) do
      iter1077:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContacts_result = __TObject:new{
  success,
  e
}

function syncContacts_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1079, _vtype1080, _size1078 = iprot:readMapBegin() 
        for _i=1,_size1078 do
          local _key1082 = iprot:readString()
          local _val1083 = ContactRegistration:new{}
          _val1083:read(iprot)
          self.success[_key1082] = _val1083
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContacts_result:write(oprot)
  oprot:writeStructBegin('syncContacts_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1084,viter1085 in pairs(self.success) do
      oprot:writeString(kiter1084)
      viter1085:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

trySendMessage_args = __TObject:new{
  seq,
  message
}

function trySendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function trySendMessage_args:write(oprot)
  oprot:writeStructBegin('trySendMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

trySendMessage_result = __TObject:new{
  success,
  e
}

function trySendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function trySendMessage_result:write(oprot)
  oprot:writeStructBegin('trySendMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockContact_args = __TObject:new{
  reqSeq,
  id
}

function unblockContact_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockContact_args:write(oprot)
  oprot:writeStructBegin('unblockContact_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockContact_result = __TObject:new{
  e
}

function unblockContact_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockContact_result:write(oprot)
  oprot:writeStructBegin('unblockContact_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockRecommendation_args = __TObject:new{
  reqSeq,
  id
}

function unblockRecommendation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockRecommendation_args:write(oprot)
  oprot:writeStructBegin('unblockRecommendation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockRecommendation_result = __TObject:new{
  e
}

function unblockRecommendation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockRecommendation_result:write(oprot)
  oprot:writeStructBegin('unblockRecommendation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unregisterUserAndDevice_args = __TObject:new{

}

function unregisterUserAndDevice_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unregisterUserAndDevice_args:write(oprot)
  oprot:writeStructBegin('unregisterUserAndDevice_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unregisterUserAndDevice_result = __TObject:new{
  success,
  e
}

function unregisterUserAndDevice_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unregisterUserAndDevice_result:write(oprot)
  oprot:writeStructBegin('unregisterUserAndDevice_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateApnsDeviceToken_args = __TObject:new{
  apnsDeviceToken
}

function updateApnsDeviceToken_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.apnsDeviceToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateApnsDeviceToken_args:write(oprot)
  oprot:writeStructBegin('updateApnsDeviceToken_args')
  if self.apnsDeviceToken ~= nil then
    oprot:writeFieldBegin('apnsDeviceToken', TType.STRING, 2)
    oprot:writeString(self.apnsDeviceToken)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateApnsDeviceToken_result = __TObject:new{
  e
}

function updateApnsDeviceToken_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateApnsDeviceToken_result:write(oprot)
  oprot:writeStructBegin('updateApnsDeviceToken_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateBuddySetting_args = __TObject:new{
  key,
  value
}

function updateBuddySetting_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.key = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateBuddySetting_args:write(oprot)
  oprot:writeStructBegin('updateBuddySetting_args')
  if self.key ~= nil then
    oprot:writeFieldBegin('key', TType.STRING, 2)
    oprot:writeString(self.key)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateBuddySetting_result = __TObject:new{
  e
}

function updateBuddySetting_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateBuddySetting_result:write(oprot)
  oprot:writeStructBegin('updateBuddySetting_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateC2DMRegistrationId_args = __TObject:new{
  registrationId
}

function updateC2DMRegistrationId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.registrationId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateC2DMRegistrationId_args:write(oprot)
  oprot:writeStructBegin('updateC2DMRegistrationId_args')
  if self.registrationId ~= nil then
    oprot:writeFieldBegin('registrationId', TType.STRING, 2)
    oprot:writeString(self.registrationId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateC2DMRegistrationId_result = __TObject:new{
  e
}

function updateC2DMRegistrationId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateC2DMRegistrationId_result:write(oprot)
  oprot:writeStructBegin('updateC2DMRegistrationId_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateContactSetting_args = __TObject:new{
  reqSeq,
  mid,
  flag,
  value
}

function updateContactSetting_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.flag = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateContactSetting_args:write(oprot)
  oprot:writeStructBegin('updateContactSetting_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.flag ~= nil then
    oprot:writeFieldBegin('flag', TType.I32, 3)
    oprot:writeI32(self.flag)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 4)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateContactSetting_result = __TObject:new{
  e
}

function updateContactSetting_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateContactSetting_result:write(oprot)
  oprot:writeStructBegin('updateContactSetting_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateCustomModeSettings_args = __TObject:new{
  customMode,
  paramMap
}

function updateCustomModeSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.customMode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.paramMap = {}
        local _ktype1087, _vtype1088, _size1086 = iprot:readMapBegin() 
        for _i=1,_size1086 do
          local _key1090 = iprot:readString()
          local _val1091 = iprot:readString()
          self.paramMap[_key1090] = _val1091
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateCustomModeSettings_args:write(oprot)
  oprot:writeStructBegin('updateCustomModeSettings_args')
  if self.customMode ~= nil then
    oprot:writeFieldBegin('customMode', TType.I32, 2)
    oprot:writeI32(self.customMode)
    oprot:writeFieldEnd()
  end
  if self.paramMap ~= nil then
    oprot:writeFieldBegin('paramMap', TType.MAP, 3)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.paramMap))
    for kiter1092,viter1093 in pairs(self.paramMap) do
      oprot:writeString(kiter1092)
      oprot:writeString(viter1093)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateCustomModeSettings_result = __TObject:new{
  e
}

function updateCustomModeSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateCustomModeSettings_result:write(oprot)
  oprot:writeStructBegin('updateCustomModeSettings_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateDeviceInfo_args = __TObject:new{
  deviceUid,
  deviceInfo
}

function updateDeviceInfo_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.deviceUid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateDeviceInfo_args:write(oprot)
  oprot:writeStructBegin('updateDeviceInfo_args')
  if self.deviceUid ~= nil then
    oprot:writeFieldBegin('deviceUid', TType.STRING, 2)
    oprot:writeString(self.deviceUid)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 3)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateDeviceInfo_result = __TObject:new{
  e
}

function updateDeviceInfo_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateDeviceInfo_result:write(oprot)
  oprot:writeStructBegin('updateDeviceInfo_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateGroup_args = __TObject:new{
  reqSeq,
  group
}

function updateGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.group = Group:new{}
        self.group:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateGroup_args:write(oprot)
  oprot:writeStructBegin('updateGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.group ~= nil then
    oprot:writeFieldBegin('group', TType.STRUCT, 2)
    self.group:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateGroup_result = __TObject:new{
  e
}

function updateGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateGroup_result:write(oprot)
  oprot:writeStructBegin('updateGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationToken_args = __TObject:new{
  type,
  token
}

function updateNotificationToken_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.token = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationToken_args:write(oprot)
  oprot:writeStructBegin('updateNotificationToken_args')
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 3)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.token ~= nil then
    oprot:writeFieldBegin('token', TType.STRING, 2)
    oprot:writeString(self.token)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationToken_result = __TObject:new{
  e
}

function updateNotificationToken_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationToken_result:write(oprot)
  oprot:writeStructBegin('updateNotificationToken_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationTokenWithBytes_args = __TObject:new{
  type,
  token
}

function updateNotificationTokenWithBytes_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.token = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationTokenWithBytes_args:write(oprot)
  oprot:writeStructBegin('updateNotificationTokenWithBytes_args')
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 3)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.token ~= nil then
    oprot:writeFieldBegin('token', TType.STRING, 2)
    oprot:writeString(self.token)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationTokenWithBytes_result = __TObject:new{
  e
}

function updateNotificationTokenWithBytes_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationTokenWithBytes_result:write(oprot)
  oprot:writeStructBegin('updateNotificationTokenWithBytes_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfile_args = __TObject:new{
  reqSeq,
  profile
}

function updateProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.profile = Profile:new{}
        self.profile:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfile_args:write(oprot)
  oprot:writeStructBegin('updateProfile_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.profile ~= nil then
    oprot:writeFieldBegin('profile', TType.STRUCT, 2)
    self.profile:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfile_result = __TObject:new{
  e
}

function updateProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfile_result:write(oprot)
  oprot:writeStructBegin('updateProfile_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfileAttribute_args = __TObject:new{
  reqSeq,
  attr,
  value
}

function updateProfileAttribute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attr = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfileAttribute_args:write(oprot)
  oprot:writeStructBegin('updateProfileAttribute_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.attr ~= nil then
    oprot:writeFieldBegin('attr', TType.I32, 2)
    oprot:writeI32(self.attr)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfileAttribute_result = __TObject:new{
  e
}

function updateProfileAttribute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfileAttribute_result:write(oprot)
  oprot:writeStructBegin('updateProfileAttribute_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateRegion_args = __TObject:new{
  region
}

function updateRegion_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateRegion_args:write(oprot)
  oprot:writeStructBegin('updateRegion_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateRegion_result = __TObject:new{
  e
}

function updateRegion_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateRegion_result:write(oprot)
  oprot:writeStructBegin('updateRegion_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings_args = __TObject:new{
  reqSeq,
  settings
}

function updateSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings_args:write(oprot)
  oprot:writeStructBegin('updateSettings_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 2)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings_result = __TObject:new{
  e
}

function updateSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings_result:write(oprot)
  oprot:writeStructBegin('updateSettings_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings2_args = __TObject:new{
  reqSeq,
  settings
}

function updateSettings2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings2_args:write(oprot)
  oprot:writeStructBegin('updateSettings2_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 2)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings2_result = __TObject:new{
  success,
  e
}

function updateSettings2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings2_result:write(oprot)
  oprot:writeStructBegin('updateSettings2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttribute_args = __TObject:new{
  reqSeq,
  attr,
  value
}

function updateSettingsAttribute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attr = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttribute_args:write(oprot)
  oprot:writeStructBegin('updateSettingsAttribute_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.attr ~= nil then
    oprot:writeFieldBegin('attr', TType.I32, 2)
    oprot:writeI32(self.attr)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttribute_result = __TObject:new{
  e
}

function updateSettingsAttribute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttribute_result:write(oprot)
  oprot:writeStructBegin('updateSettingsAttribute_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttributes_args = __TObject:new{
  reqSeq,
  attrBitset,
  settings
}

function updateSettingsAttributes_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attrBitset = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttributes_args:write(oprot)
  oprot:writeStructBegin('updateSettingsAttributes_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.attrBitset ~= nil then
    oprot:writeFieldBegin('attrBitset', TType.I32, 2)
    oprot:writeI32(self.attrBitset)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 3)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttributes_result = __TObject:new{
  success,
  e
}

function updateSettingsAttributes_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttributes_result:write(oprot)
  oprot:writeStructBegin('updateSettingsAttributes_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredential_args = __TObject:new{
  identityProvider,
  identifier,
  password
}

function verifyIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.identityProvider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.password = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredential_args')
  if self.identityProvider ~= nil then
    oprot:writeFieldBegin('identityProvider', TType.I32, 8)
    oprot:writeI32(self.identityProvider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.password ~= nil then
    oprot:writeFieldBegin('password', TType.STRING, 4)
    oprot:writeString(self.password)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredential_result = __TObject:new{
  e
}

function verifyIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredential_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredentialWithResult_args = __TObject:new{
  identityCredential
}

function verifyIdentityCredentialWithResult_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.identityCredential = IdentityCredential:new{}
        self.identityCredential:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredentialWithResult_args:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredentialWithResult_args')
  if self.identityCredential ~= nil then
    oprot:writeFieldBegin('identityCredential', TType.STRUCT, 2)
    self.identityCredential:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredentialWithResult_result = __TObject:new{
  success,
  e
}

function verifyIdentityCredentialWithResult_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = UserAuthStatus:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredentialWithResult_result:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredentialWithResult_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhone_args = __TObject:new{
  sessionId,
  pinCode,
  udidHash
}

function verifyPhone_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhone_args:write(oprot)
  oprot:writeStructBegin('verifyPhone_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.pinCode ~= nil then
    oprot:writeFieldBegin('pinCode', TType.STRING, 3)
    oprot:writeString(self.pinCode)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 4)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhone_result = __TObject:new{
  success,
  e
}

function verifyPhone_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhone_result:write(oprot)
  oprot:writeStructBegin('verifyPhone_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyQrcode_args = __TObject:new{
  verifier,
  pinCode
}

function verifyQrcode_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyQrcode_args:write(oprot)
  oprot:writeStructBegin('verifyQrcode_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 2)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  if self.pinCode ~= nil then
    oprot:writeFieldBegin('pinCode', TType.STRING, 3)
    oprot:writeString(self.pinCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyQrcode_result = __TObject:new{
  success,
  e
}

function verifyQrcode_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyQrcode_result:write(oprot)
  oprot:writeStructBegin('verifyQrcode_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end