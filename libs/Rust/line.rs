// Autogenerated by Thrift Compiler (0.14.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate thrift;

use thrift::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ApplicationType {
  Ios = 16,
  IosRc = 17,
  IosBeta = 18,
  IosAlpha = 19,
  Android = 32,
  AndroidRc = 33,
  AndroidBeta = 34,
  AndroidAlpha = 35,
  Wap = 48,
  WapRc = 49,
  WapBeta = 50,
  WapAlpha = 51,
  Bot = 64,
  BotRc = 65,
  BotBeta = 66,
  BotAlpha = 67,
  Web = 80,
  WebRc = 81,
  WebBeta = 82,
  WebAlpha = 83,
  Desktopwin = 96,
  DesktopwinRc = 97,
  DesktopwinBeta = 98,
  DesktopwinAlpha = 99,
  Desktopmac = 112,
  DesktopmacRc = 113,
  DesktopmacBeta = 114,
  DesktopmacAlpha = 115,
  Channelgw = 128,
  ChannelgwRc = 129,
  ChannelgwBeta = 130,
  ChannelgwAlpha = 131,
  Channelcp = 144,
  ChannelcpRc = 145,
  ChannelcpBeta = 146,
  ChannelcpAlpha = 147,
  Winphone = 160,
  WinphoneRc = 161,
  WinphoneBeta = 162,
  WinphoneAlpha = 163,
  Blackberry = 176,
  BlackberryRc = 177,
  BlackberryBeta = 178,
  BlackberryAlpha = 179,
  Winmetro = 192,
  WinmetroRc = 193,
  WinmetroBeta = 194,
  WinmetroAlpha = 195,
  S40 = 208,
  S40Rc = 209,
  S40Beta = 210,
  S40Alpha = 211,
  Chrono = 224,
  ChronoRc = 225,
  ChronoBeta = 226,
  ChronoAlpha = 227,
  Tizen = 256,
  TizenRc = 257,
  TizenBeta = 258,
  TizenAlpha = 259,
  Virtual = 272,
}

impl ApplicationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplicationType> {
    let enum_value = i_prot.read_i32()?;
    ApplicationType::try_from(enum_value)  }
}

impl TryFrom<i32> for ApplicationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      16 => Ok(ApplicationType::Ios),
      17 => Ok(ApplicationType::IosRc),
      18 => Ok(ApplicationType::IosBeta),
      19 => Ok(ApplicationType::IosAlpha),
      32 => Ok(ApplicationType::Android),
      33 => Ok(ApplicationType::AndroidRc),
      34 => Ok(ApplicationType::AndroidBeta),
      35 => Ok(ApplicationType::AndroidAlpha),
      48 => Ok(ApplicationType::Wap),
      49 => Ok(ApplicationType::WapRc),
      50 => Ok(ApplicationType::WapBeta),
      51 => Ok(ApplicationType::WapAlpha),
      64 => Ok(ApplicationType::Bot),
      65 => Ok(ApplicationType::BotRc),
      66 => Ok(ApplicationType::BotBeta),
      67 => Ok(ApplicationType::BotAlpha),
      80 => Ok(ApplicationType::Web),
      81 => Ok(ApplicationType::WebRc),
      82 => Ok(ApplicationType::WebBeta),
      83 => Ok(ApplicationType::WebAlpha),
      96 => Ok(ApplicationType::Desktopwin),
      97 => Ok(ApplicationType::DesktopwinRc),
      98 => Ok(ApplicationType::DesktopwinBeta),
      99 => Ok(ApplicationType::DesktopwinAlpha),
      112 => Ok(ApplicationType::Desktopmac),
      113 => Ok(ApplicationType::DesktopmacRc),
      114 => Ok(ApplicationType::DesktopmacBeta),
      115 => Ok(ApplicationType::DesktopmacAlpha),
      128 => Ok(ApplicationType::Channelgw),
      129 => Ok(ApplicationType::ChannelgwRc),
      130 => Ok(ApplicationType::ChannelgwBeta),
      131 => Ok(ApplicationType::ChannelgwAlpha),
      144 => Ok(ApplicationType::Channelcp),
      145 => Ok(ApplicationType::ChannelcpRc),
      146 => Ok(ApplicationType::ChannelcpBeta),
      147 => Ok(ApplicationType::ChannelcpAlpha),
      160 => Ok(ApplicationType::Winphone),
      161 => Ok(ApplicationType::WinphoneRc),
      162 => Ok(ApplicationType::WinphoneBeta),
      163 => Ok(ApplicationType::WinphoneAlpha),
      176 => Ok(ApplicationType::Blackberry),
      177 => Ok(ApplicationType::BlackberryRc),
      178 => Ok(ApplicationType::BlackberryBeta),
      179 => Ok(ApplicationType::BlackberryAlpha),
      192 => Ok(ApplicationType::Winmetro),
      193 => Ok(ApplicationType::WinmetroRc),
      194 => Ok(ApplicationType::WinmetroBeta),
      195 => Ok(ApplicationType::WinmetroAlpha),
      208 => Ok(ApplicationType::S40),
      209 => Ok(ApplicationType::S40Rc),
      210 => Ok(ApplicationType::S40Beta),
      211 => Ok(ApplicationType::S40Alpha),
      224 => Ok(ApplicationType::Chrono),
      225 => Ok(ApplicationType::ChronoRc),
      226 => Ok(ApplicationType::ChronoBeta),
      227 => Ok(ApplicationType::ChronoAlpha),
      256 => Ok(ApplicationType::Tizen),
      257 => Ok(ApplicationType::TizenRc),
      258 => Ok(ApplicationType::TizenBeta),
      259 => Ok(ApplicationType::TizenAlpha),
      272 => Ok(ApplicationType::Virtual),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ApplicationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum BuddyBannerLinkType {
  BuddyBannerLinkHidden = 0,
  BuddyBannerLinkMid = 1,
  BuddyBannerLinkUrl = 2,
}

impl BuddyBannerLinkType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyBannerLinkType> {
    let enum_value = i_prot.read_i32()?;
    BuddyBannerLinkType::try_from(enum_value)  }
}

impl TryFrom<i32> for BuddyBannerLinkType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(BuddyBannerLinkType::BuddyBannerLinkHidden),
      1 => Ok(BuddyBannerLinkType::BuddyBannerLinkMid),
      2 => Ok(BuddyBannerLinkType::BuddyBannerLinkUrl),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to BuddyBannerLinkType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum BuddyOnAirType {
  Normal = 0,
  Live = 1,
  Voip = 2,
}

impl BuddyOnAirType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyOnAirType> {
    let enum_value = i_prot.read_i32()?;
    BuddyOnAirType::try_from(enum_value)  }
}

impl TryFrom<i32> for BuddyOnAirType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(BuddyOnAirType::Normal),
      1 => Ok(BuddyOnAirType::Live),
      2 => Ok(BuddyOnAirType::Voip),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to BuddyOnAirType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum BuddyResultState {
  Accepted = 1,
  Succeeded = 2,
  Failed = 3,
  Cancelled = 4,
  NotifyFailed = 5,
  Storing = 11,
  Uploading = 21,
  Notifying = 31,
}

impl BuddyResultState {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyResultState> {
    let enum_value = i_prot.read_i32()?;
    BuddyResultState::try_from(enum_value)  }
}

impl TryFrom<i32> for BuddyResultState {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(BuddyResultState::Accepted),
      2 => Ok(BuddyResultState::Succeeded),
      3 => Ok(BuddyResultState::Failed),
      4 => Ok(BuddyResultState::Cancelled),
      5 => Ok(BuddyResultState::NotifyFailed),
      11 => Ok(BuddyResultState::Storing),
      21 => Ok(BuddyResultState::Uploading),
      31 => Ok(BuddyResultState::Notifying),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to BuddyResultState", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum BuddySearchRequestSource {
  Na = 0,
  FriendView = 1,
  OfficialAccountView = 2,
}

impl BuddySearchRequestSource {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddySearchRequestSource> {
    let enum_value = i_prot.read_i32()?;
    BuddySearchRequestSource::try_from(enum_value)  }
}

impl TryFrom<i32> for BuddySearchRequestSource {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(BuddySearchRequestSource::Na),
      1 => Ok(BuddySearchRequestSource::FriendView),
      2 => Ok(BuddySearchRequestSource::OfficialAccountView),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to BuddySearchRequestSource", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum CarrierCode {
  NotSpecified = 0,
  JpDocomo = 1,
  JpAu = 2,
  JpSoftbank = 3,
  KrSkt = 17,
  KrKt = 18,
  KrLgt = 19,
}

impl CarrierCode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CarrierCode> {
    let enum_value = i_prot.read_i32()?;
    CarrierCode::try_from(enum_value)  }
}

impl TryFrom<i32> for CarrierCode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(CarrierCode::NotSpecified),
      1 => Ok(CarrierCode::JpDocomo),
      2 => Ok(CarrierCode::JpAu),
      3 => Ok(CarrierCode::JpSoftbank),
      17 => Ok(CarrierCode::KrSkt),
      18 => Ok(CarrierCode::KrKt),
      19 => Ok(CarrierCode::KrLgt),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to CarrierCode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ChannelConfiguration {
  Message = 0,
  MessageNotification = 1,
  NotificationCenter = 2,
}

impl ChannelConfiguration {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelConfiguration> {
    let enum_value = i_prot.read_i32()?;
    ChannelConfiguration::try_from(enum_value)  }
}

impl TryFrom<i32> for ChannelConfiguration {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ChannelConfiguration::Message),
      1 => Ok(ChannelConfiguration::MessageNotification),
      2 => Ok(ChannelConfiguration::NotificationCenter),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ChannelConfiguration", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ChannelErrorCode {
  IllegalArgument = 0,
  InternalError = 1,
  ConnectionError = 2,
  AuthenticationiFailed = 3,
  NeedPermissionApproval = 4,
  CoinNotUsable = 5,
}

impl ChannelErrorCode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelErrorCode> {
    let enum_value = i_prot.read_i32()?;
    ChannelErrorCode::try_from(enum_value)  }
}

impl TryFrom<i32> for ChannelErrorCode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ChannelErrorCode::IllegalArgument),
      1 => Ok(ChannelErrorCode::InternalError),
      2 => Ok(ChannelErrorCode::ConnectionError),
      3 => Ok(ChannelErrorCode::AuthenticationiFailed),
      4 => Ok(ChannelErrorCode::NeedPermissionApproval),
      5 => Ok(ChannelErrorCode::CoinNotUsable),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ChannelErrorCode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ChannelSyncType {
  Sync = 0,
  Remove = 1,
}

impl ChannelSyncType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelSyncType> {
    let enum_value = i_prot.read_i32()?;
    ChannelSyncType::try_from(enum_value)  }
}

impl TryFrom<i32> for ChannelSyncType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ChannelSyncType::Sync),
      1 => Ok(ChannelSyncType::Remove),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ChannelSyncType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ContactAttribute {
  ContactAttributeCapableVoiceCall = 1,
  ContactAttributeCapableVideoCall = 2,
  ContactAttributeCapableMyHome = 16,
  ContactAttributeCapableBuddy = 32,
}

impl ContactAttribute {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactAttribute> {
    let enum_value = i_prot.read_i32()?;
    ContactAttribute::try_from(enum_value)  }
}

impl TryFrom<i32> for ContactAttribute {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(ContactAttribute::ContactAttributeCapableVoiceCall),
      2 => Ok(ContactAttribute::ContactAttributeCapableVideoCall),
      16 => Ok(ContactAttribute::ContactAttributeCapableMyHome),
      32 => Ok(ContactAttribute::ContactAttributeCapableBuddy),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ContactAttribute", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ContactCategory {
  Normal = 0,
  Recommend = 1,
}

impl ContactCategory {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactCategory> {
    let enum_value = i_prot.read_i32()?;
    ContactCategory::try_from(enum_value)  }
}

impl TryFrom<i32> for ContactCategory {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ContactCategory::Normal),
      1 => Ok(ContactCategory::Recommend),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ContactCategory", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ContactRelation {
  Oneway = 0,
  Both = 1,
  NotRegistered = 2,
}

impl ContactRelation {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactRelation> {
    let enum_value = i_prot.read_i32()?;
    ContactRelation::try_from(enum_value)  }
}

impl TryFrom<i32> for ContactRelation {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ContactRelation::Oneway),
      1 => Ok(ContactRelation::Both),
      2 => Ok(ContactRelation::NotRegistered),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ContactRelation", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ContactSetting {
  ContactSettingNotificationDisable = 1,
  ContactSettingDisplayNameOverride = 2,
  ContactSettingContactHide = 4,
  ContactSettingFavorite = 8,
  ContactSettingDelete = 16,
}

impl ContactSetting {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactSetting> {
    let enum_value = i_prot.read_i32()?;
    ContactSetting::try_from(enum_value)  }
}

impl TryFrom<i32> for ContactSetting {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(ContactSetting::ContactSettingNotificationDisable),
      2 => Ok(ContactSetting::ContactSettingDisplayNameOverride),
      4 => Ok(ContactSetting::ContactSettingContactHide),
      8 => Ok(ContactSetting::ContactSettingFavorite),
      16 => Ok(ContactSetting::ContactSettingDelete),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ContactSetting", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ContactStatus {
  Unspecified = 0,
  Friend = 1,
  FriendBlocked = 2,
  Recommend = 3,
  RecommendBlocked = 4,
  Deleted = 5,
  DeletedBlocked = 6,
}

impl ContactStatus {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactStatus> {
    let enum_value = i_prot.read_i32()?;
    ContactStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for ContactStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ContactStatus::Unspecified),
      1 => Ok(ContactStatus::Friend),
      2 => Ok(ContactStatus::FriendBlocked),
      3 => Ok(ContactStatus::Recommend),
      4 => Ok(ContactStatus::RecommendBlocked),
      5 => Ok(ContactStatus::Deleted),
      6 => Ok(ContactStatus::DeletedBlocked),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ContactStatus", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ContactType {
  Mid = 0,
  Phone = 1,
  Email = 2,
  Userid = 3,
  Proximity = 4,
  Group = 5,
  User = 6,
  Qrcode = 7,
  PromotionBot = 8,
  Repair = 128,
  Facebook = 2305,
  Sina = 2306,
  Renren = 2307,
  Feixin = 2308,
}

impl ContactType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactType> {
    let enum_value = i_prot.read_i32()?;
    ContactType::try_from(enum_value)  }
}

impl TryFrom<i32> for ContactType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ContactType::Mid),
      1 => Ok(ContactType::Phone),
      2 => Ok(ContactType::Email),
      3 => Ok(ContactType::Userid),
      4 => Ok(ContactType::Proximity),
      5 => Ok(ContactType::Group),
      6 => Ok(ContactType::User),
      7 => Ok(ContactType::Qrcode),
      8 => Ok(ContactType::PromotionBot),
      128 => Ok(ContactType::Repair),
      2305 => Ok(ContactType::Facebook),
      2306 => Ok(ContactType::Sina),
      2307 => Ok(ContactType::Renren),
      2308 => Ok(ContactType::Feixin),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ContactType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ContentType {
  None = 0,
  Image = 1,
  Video = 2,
  Audio = 3,
  Html = 4,
  Pdf = 5,
  Call = 6,
  Sticker = 7,
  Presence = 8,
  Gift = 9,
  Groupboard = 10,
  Applink = 11,
  Link = 12,
  Contact = 13,
  File = 14,
  Location = 15,
  Postnotification = 16,
  Rich = 17,
  Chatevent = 18,
}

impl ContentType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContentType> {
    let enum_value = i_prot.read_i32()?;
    ContentType::try_from(enum_value)  }
}

impl TryFrom<i32> for ContentType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ContentType::None),
      1 => Ok(ContentType::Image),
      2 => Ok(ContentType::Video),
      3 => Ok(ContentType::Audio),
      4 => Ok(ContentType::Html),
      5 => Ok(ContentType::Pdf),
      6 => Ok(ContentType::Call),
      7 => Ok(ContentType::Sticker),
      8 => Ok(ContentType::Presence),
      9 => Ok(ContentType::Gift),
      10 => Ok(ContentType::Groupboard),
      11 => Ok(ContentType::Applink),
      12 => Ok(ContentType::Link),
      13 => Ok(ContentType::Contact),
      14 => Ok(ContentType::File),
      15 => Ok(ContentType::Location),
      16 => Ok(ContentType::Postnotification),
      17 => Ok(ContentType::Rich),
      18 => Ok(ContentType::Chatevent),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ContentType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum CustomMode {
  PromotionFriendsInvite = 1,
  CapabilityServerSideSms = 2,
  LineClientAnalyticsConfiguration = 3,
}

impl CustomMode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CustomMode> {
    let enum_value = i_prot.read_i32()?;
    CustomMode::try_from(enum_value)  }
}

impl TryFrom<i32> for CustomMode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(CustomMode::PromotionFriendsInvite),
      2 => Ok(CustomMode::CapabilityServerSideSms),
      3 => Ok(CustomMode::LineClientAnalyticsConfiguration),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to CustomMode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EmailConfirmationStatus {
  NotSpecified = 0,
  NotYet = 1,
  Done = 3,
}

impl EmailConfirmationStatus {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EmailConfirmationStatus> {
    let enum_value = i_prot.read_i32()?;
    EmailConfirmationStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for EmailConfirmationStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(EmailConfirmationStatus::NotSpecified),
      1 => Ok(EmailConfirmationStatus::NotYet),
      3 => Ok(EmailConfirmationStatus::Done),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EmailConfirmationStatus", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EmailConfirmationType {
  ServerSideEmail = 0,
  ClientSideEmail = 1,
}

impl EmailConfirmationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EmailConfirmationType> {
    let enum_value = i_prot.read_i32()?;
    EmailConfirmationType::try_from(enum_value)  }
}

impl TryFrom<i32> for EmailConfirmationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(EmailConfirmationType::ServerSideEmail),
      1 => Ok(EmailConfirmationType::ClientSideEmail),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EmailConfirmationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ErrorCode {
  IllegalArgument = 0,
  AuthenticationFailed = 1,
  DbFailed = 2,
  InvalidState = 3,
  ExcessiveAccess = 4,
  NotFound = 5,
  InvalidLength = 6,
  NotAvailableUser = 7,
  NotAuthorizedDevice = 8,
  InvalidMid = 9,
  NotAMember = 10,
  IncompatibleAppVersion = 11,
  NotReady = 12,
  NotAvailableSession = 13,
  NotAuthorizedSession = 14,
  SystemError = 15,
  NoAvailableVerificationMethod = 16,
  NotAuthenticated = 17,
  InvalidIdentityCredential = 18,
  NotAvailableIdentityIdentifier = 19,
  InternalError = 20,
  NoSuchIdentityIdenfier = 21,
  DeactivatedAccountBoundToThisIdentity = 22,
  IllegalIdentityCredential = 23,
  UnknownChannel = 24,
  NoSuchMessageBox = 25,
  NotAvailableMessageBox = 26,
  ChannelDoesNotMatch = 27,
  NotYourMessage = 28,
  MessageDefinedError = 29,
  UserCannotAcceptPresents = 30,
  UserNotStickerOwner = 32,
  MaintenanceError = 33,
  AccountNotMatched = 34,
  AbuseBlock = 35,
  NotFriend = 36,
  NotAllowedCall = 37,
  BlockFriend = 38,
  IncompatibleVoipVersion = 39,
  InvalidSnsAccessToken = 40,
  ExternalServiceNotAvailable = 41,
  NotAllowedAddContact = 42,
  NotCertificated = 43,
  NotAllowedSecondaryDevice = 44,
  InvalidPinCode = 45,
  NotFoundIdentityCredential = 46,
  ExceedFileMaxSize = 47,
  ExceedDailyQuota = 48,
  NotSupportSendFile = 49,
  MustUpgrade = 50,
  NotAvailablePinCodeSession = 51,
}

impl ErrorCode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ErrorCode> {
    let enum_value = i_prot.read_i32()?;
    ErrorCode::try_from(enum_value)  }
}

impl TryFrom<i32> for ErrorCode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ErrorCode::IllegalArgument),
      1 => Ok(ErrorCode::AuthenticationFailed),
      2 => Ok(ErrorCode::DbFailed),
      3 => Ok(ErrorCode::InvalidState),
      4 => Ok(ErrorCode::ExcessiveAccess),
      5 => Ok(ErrorCode::NotFound),
      6 => Ok(ErrorCode::InvalidLength),
      7 => Ok(ErrorCode::NotAvailableUser),
      8 => Ok(ErrorCode::NotAuthorizedDevice),
      9 => Ok(ErrorCode::InvalidMid),
      10 => Ok(ErrorCode::NotAMember),
      11 => Ok(ErrorCode::IncompatibleAppVersion),
      12 => Ok(ErrorCode::NotReady),
      13 => Ok(ErrorCode::NotAvailableSession),
      14 => Ok(ErrorCode::NotAuthorizedSession),
      15 => Ok(ErrorCode::SystemError),
      16 => Ok(ErrorCode::NoAvailableVerificationMethod),
      17 => Ok(ErrorCode::NotAuthenticated),
      18 => Ok(ErrorCode::InvalidIdentityCredential),
      19 => Ok(ErrorCode::NotAvailableIdentityIdentifier),
      20 => Ok(ErrorCode::InternalError),
      21 => Ok(ErrorCode::NoSuchIdentityIdenfier),
      22 => Ok(ErrorCode::DeactivatedAccountBoundToThisIdentity),
      23 => Ok(ErrorCode::IllegalIdentityCredential),
      24 => Ok(ErrorCode::UnknownChannel),
      25 => Ok(ErrorCode::NoSuchMessageBox),
      26 => Ok(ErrorCode::NotAvailableMessageBox),
      27 => Ok(ErrorCode::ChannelDoesNotMatch),
      28 => Ok(ErrorCode::NotYourMessage),
      29 => Ok(ErrorCode::MessageDefinedError),
      30 => Ok(ErrorCode::UserCannotAcceptPresents),
      32 => Ok(ErrorCode::UserNotStickerOwner),
      33 => Ok(ErrorCode::MaintenanceError),
      34 => Ok(ErrorCode::AccountNotMatched),
      35 => Ok(ErrorCode::AbuseBlock),
      36 => Ok(ErrorCode::NotFriend),
      37 => Ok(ErrorCode::NotAllowedCall),
      38 => Ok(ErrorCode::BlockFriend),
      39 => Ok(ErrorCode::IncompatibleVoipVersion),
      40 => Ok(ErrorCode::InvalidSnsAccessToken),
      41 => Ok(ErrorCode::ExternalServiceNotAvailable),
      42 => Ok(ErrorCode::NotAllowedAddContact),
      43 => Ok(ErrorCode::NotCertificated),
      44 => Ok(ErrorCode::NotAllowedSecondaryDevice),
      45 => Ok(ErrorCode::InvalidPinCode),
      46 => Ok(ErrorCode::NotFoundIdentityCredential),
      47 => Ok(ErrorCode::ExceedFileMaxSize),
      48 => Ok(ErrorCode::ExceedDailyQuota),
      49 => Ok(ErrorCode::NotSupportSendFile),
      50 => Ok(ErrorCode::MustUpgrade),
      51 => Ok(ErrorCode::NotAvailablePinCodeSession),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ErrorCode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum FeatureType {
  ObjectStorage = 1,
}

impl FeatureType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FeatureType> {
    let enum_value = i_prot.read_i32()?;
    FeatureType::try_from(enum_value)  }
}

impl TryFrom<i32> for FeatureType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(FeatureType::ObjectStorage),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to FeatureType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum GroupAttribute {
  Name = 1,
  PictureStatus = 2,
  All = 255,
}

impl GroupAttribute {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GroupAttribute> {
    let enum_value = i_prot.read_i32()?;
    GroupAttribute::try_from(enum_value)  }
}

impl TryFrom<i32> for GroupAttribute {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(GroupAttribute::Name),
      2 => Ok(GroupAttribute::PictureStatus),
      255 => Ok(GroupAttribute::All),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to GroupAttribute", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum IdentityProvider {
  Unknown = 0,
  Line = 1,
  NaverKr = 2,
}

impl IdentityProvider {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IdentityProvider> {
    let enum_value = i_prot.read_i32()?;
    IdentityProvider::try_from(enum_value)  }
}

impl TryFrom<i32> for IdentityProvider {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(IdentityProvider::Unknown),
      1 => Ok(IdentityProvider::Line),
      2 => Ok(IdentityProvider::NaverKr),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to IdentityProvider", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum LoginResultType {
  Success = 1,
  RequireQrcode = 2,
  RequireDeviceConfirm = 3,
}

impl LoginResultType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LoginResultType> {
    let enum_value = i_prot.read_i32()?;
    LoginResultType::try_from(enum_value)  }
}

impl TryFrom<i32> for LoginResultType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(LoginResultType::Success),
      2 => Ok(LoginResultType::RequireQrcode),
      3 => Ok(LoginResultType::RequireDeviceConfirm),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to LoginResultType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum MessageOperationType {
  SendMessage = 1,
  ReceiveMessage = 2,
  ReadMessage = 3,
  NotifiedReadMessage = 4,
  NotifiedJoinChat = 5,
  FailedSendMessage = 6,
  SendContent = 7,
  SendContentReceipt = 8,
  SendChatRemoved = 9,
  RemoveAllMessages = 10,
}

impl MessageOperationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageOperationType> {
    let enum_value = i_prot.read_i32()?;
    MessageOperationType::try_from(enum_value)  }
}

impl TryFrom<i32> for MessageOperationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(MessageOperationType::SendMessage),
      2 => Ok(MessageOperationType::ReceiveMessage),
      3 => Ok(MessageOperationType::ReadMessage),
      4 => Ok(MessageOperationType::NotifiedReadMessage),
      5 => Ok(MessageOperationType::NotifiedJoinChat),
      6 => Ok(MessageOperationType::FailedSendMessage),
      7 => Ok(MessageOperationType::SendContent),
      8 => Ok(MessageOperationType::SendContentReceipt),
      9 => Ok(MessageOperationType::SendChatRemoved),
      10 => Ok(MessageOperationType::RemoveAllMessages),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to MessageOperationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum MIDType {
  User = 0,
  Room = 1,
  Group = 2,
}

impl MIDType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MIDType> {
    let enum_value = i_prot.read_i32()?;
    MIDType::try_from(enum_value)  }
}

impl TryFrom<i32> for MIDType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(MIDType::User),
      1 => Ok(MIDType::Room),
      2 => Ok(MIDType::Group),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to MIDType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ModificationType {
  Add = 0,
  Remove = 1,
  Modify = 2,
}

impl ModificationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ModificationType> {
    let enum_value = i_prot.read_i32()?;
    ModificationType::try_from(enum_value)  }
}

impl TryFrom<i32> for ModificationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ModificationType::Add),
      1 => Ok(ModificationType::Remove),
      2 => Ok(ModificationType::Modify),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ModificationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum NotificationItemFetchMode {
  All = 0,
  Append = 1,
}

impl NotificationItemFetchMode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationItemFetchMode> {
    let enum_value = i_prot.read_i32()?;
    NotificationItemFetchMode::try_from(enum_value)  }
}

impl TryFrom<i32> for NotificationItemFetchMode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(NotificationItemFetchMode::All),
      1 => Ok(NotificationItemFetchMode::Append),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to NotificationItemFetchMode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum NotificationQueueType {
  Global = 1,
  Message = 2,
  Primary = 3,
}

impl NotificationQueueType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationQueueType> {
    let enum_value = i_prot.read_i32()?;
    NotificationQueueType::try_from(enum_value)  }
}

impl TryFrom<i32> for NotificationQueueType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(NotificationQueueType::Global),
      2 => Ok(NotificationQueueType::Message),
      3 => Ok(NotificationQueueType::Primary),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to NotificationQueueType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum NotificationStatus {
  NotificationItemExist = 1,
  TimelineItemExist = 2,
  NoteGroupNewItemExist = 4,
  TimelineBuddygroupChanged = 8,
  NoteOneToOneNewItemExist = 16,
  AlbumItemExist = 32,
  TimelineItemDeleted = 64,
}

impl NotificationStatus {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationStatus> {
    let enum_value = i_prot.read_i32()?;
    NotificationStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for NotificationStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(NotificationStatus::NotificationItemExist),
      2 => Ok(NotificationStatus::TimelineItemExist),
      4 => Ok(NotificationStatus::NoteGroupNewItemExist),
      8 => Ok(NotificationStatus::TimelineBuddygroupChanged),
      16 => Ok(NotificationStatus::NoteOneToOneNewItemExist),
      32 => Ok(NotificationStatus::AlbumItemExist),
      64 => Ok(NotificationStatus::TimelineItemDeleted),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to NotificationStatus", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum NotificationType {
  AppleApns = 1,
  GoogleC2dm = 2,
  NhnNni = 3,
  SktAom = 4,
  MsMpns = 5,
  RimBis = 6,
  GoogleGcm = 7,
  NokiaNnapi = 8,
  Tizen = 9,
  LineBot = 17,
  LineWap = 18,
}

impl NotificationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationType> {
    let enum_value = i_prot.read_i32()?;
    NotificationType::try_from(enum_value)  }
}

impl TryFrom<i32> for NotificationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(NotificationType::AppleApns),
      2 => Ok(NotificationType::GoogleC2dm),
      3 => Ok(NotificationType::NhnNni),
      4 => Ok(NotificationType::SktAom),
      5 => Ok(NotificationType::MsMpns),
      6 => Ok(NotificationType::RimBis),
      7 => Ok(NotificationType::GoogleGcm),
      8 => Ok(NotificationType::NokiaNnapi),
      9 => Ok(NotificationType::Tizen),
      17 => Ok(NotificationType::LineBot),
      18 => Ok(NotificationType::LineWap),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to NotificationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum OpStatus {
  Normal = 0,
  AlertDisabled = 1,
}

impl OpStatus {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OpStatus> {
    let enum_value = i_prot.read_i32()?;
    OpStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for OpStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(OpStatus::Normal),
      1 => Ok(OpStatus::AlertDisabled),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to OpStatus", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum OpType {
  EndOfOperation = 0,
  UpdateProfile = 1,
  NotifiedUpdateProfile = 2,
  RegisterUserid = 3,
  AddContact = 4,
  NotifiedAddContact = 5,
  BlockContact = 6,
  UnblockContact = 7,
  NotifiedRecommendContact = 8,
  CreateGroup = 9,
  UpdateGroup = 10,
  NotifiedUpdateGroup = 11,
  InviteIntoGroup = 12,
  NotifiedInviteIntoGroup = 13,
  LeaveGroup = 14,
  NotifiedLeaveGroup = 15,
  AcceptGroupInvitation = 16,
  NotifiedAcceptGroupInvitation = 17,
  KickoutFromGroup = 18,
  NotifiedKickoutFromGroup = 19,
  CreateRoom = 20,
  InviteIntoRoom = 21,
  NotifiedInviteIntoRoom = 22,
  LeaveRoom = 23,
  NotifiedLeaveRoom = 24,
  SendMessage = 25,
  ReceiveMessage = 26,
  SendMessageReceipt = 27,
  ReceiveMessageReceipt = 28,
  SendContentReceipt = 29,
  ReceiveAnnouncement = 30,
  CancelInvitationGroup = 31,
  NotifiedCancelInvitationGroup = 32,
  NotifiedUnregisterUser = 33,
  RejectGroupInvitation = 34,
  NotifiedRejectGroupInvitation = 35,
  UpdateSettings = 36,
  NotifiedRegisterUser = 37,
  InviteViaEmail = 38,
  NotifiedRequestRecovery = 39,
  SendChatChecked = 40,
  SendChatRemoved = 41,
  NotifiedForceSync = 42,
  SendContent = 43,
  SendMessageMyhome = 44,
  NotifiedUpdateContentPreview = 45,
  RemoveAllMessages = 46,
  NotifiedUpdatePurchases = 47,
  Dummy = 48,
  UpdateContact = 49,
  NotifiedReceivedCall = 50,
  CancelCall = 51,
  NotifiedRedirect = 52,
  NotifiedChannelSync = 53,
  FailedSendMessage = 54,
  NotifiedReadMessage = 55,
  FailedEmailConfirmation = 56,
  NotifiedChatContent = 58,
  NotifiedPushNoticenterItem = 59,
}

impl OpType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OpType> {
    let enum_value = i_prot.read_i32()?;
    OpType::try_from(enum_value)  }
}

impl TryFrom<i32> for OpType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(OpType::EndOfOperation),
      1 => Ok(OpType::UpdateProfile),
      2 => Ok(OpType::NotifiedUpdateProfile),
      3 => Ok(OpType::RegisterUserid),
      4 => Ok(OpType::AddContact),
      5 => Ok(OpType::NotifiedAddContact),
      6 => Ok(OpType::BlockContact),
      7 => Ok(OpType::UnblockContact),
      8 => Ok(OpType::NotifiedRecommendContact),
      9 => Ok(OpType::CreateGroup),
      10 => Ok(OpType::UpdateGroup),
      11 => Ok(OpType::NotifiedUpdateGroup),
      12 => Ok(OpType::InviteIntoGroup),
      13 => Ok(OpType::NotifiedInviteIntoGroup),
      14 => Ok(OpType::LeaveGroup),
      15 => Ok(OpType::NotifiedLeaveGroup),
      16 => Ok(OpType::AcceptGroupInvitation),
      17 => Ok(OpType::NotifiedAcceptGroupInvitation),
      18 => Ok(OpType::KickoutFromGroup),
      19 => Ok(OpType::NotifiedKickoutFromGroup),
      20 => Ok(OpType::CreateRoom),
      21 => Ok(OpType::InviteIntoRoom),
      22 => Ok(OpType::NotifiedInviteIntoRoom),
      23 => Ok(OpType::LeaveRoom),
      24 => Ok(OpType::NotifiedLeaveRoom),
      25 => Ok(OpType::SendMessage),
      26 => Ok(OpType::ReceiveMessage),
      27 => Ok(OpType::SendMessageReceipt),
      28 => Ok(OpType::ReceiveMessageReceipt),
      29 => Ok(OpType::SendContentReceipt),
      30 => Ok(OpType::ReceiveAnnouncement),
      31 => Ok(OpType::CancelInvitationGroup),
      32 => Ok(OpType::NotifiedCancelInvitationGroup),
      33 => Ok(OpType::NotifiedUnregisterUser),
      34 => Ok(OpType::RejectGroupInvitation),
      35 => Ok(OpType::NotifiedRejectGroupInvitation),
      36 => Ok(OpType::UpdateSettings),
      37 => Ok(OpType::NotifiedRegisterUser),
      38 => Ok(OpType::InviteViaEmail),
      39 => Ok(OpType::NotifiedRequestRecovery),
      40 => Ok(OpType::SendChatChecked),
      41 => Ok(OpType::SendChatRemoved),
      42 => Ok(OpType::NotifiedForceSync),
      43 => Ok(OpType::SendContent),
      44 => Ok(OpType::SendMessageMyhome),
      45 => Ok(OpType::NotifiedUpdateContentPreview),
      46 => Ok(OpType::RemoveAllMessages),
      47 => Ok(OpType::NotifiedUpdatePurchases),
      48 => Ok(OpType::Dummy),
      49 => Ok(OpType::UpdateContact),
      50 => Ok(OpType::NotifiedReceivedCall),
      51 => Ok(OpType::CancelCall),
      52 => Ok(OpType::NotifiedRedirect),
      53 => Ok(OpType::NotifiedChannelSync),
      54 => Ok(OpType::FailedSendMessage),
      55 => Ok(OpType::NotifiedReadMessage),
      56 => Ok(OpType::FailedEmailConfirmation),
      58 => Ok(OpType::NotifiedChatContent),
      59 => Ok(OpType::NotifiedPushNoticenterItem),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to OpType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum PayloadType {
  PayloadBuy = 101,
  PayloadCs = 111,
  PayloadBonus = 121,
  PayloadEvent = 131,
}

impl PayloadType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PayloadType> {
    let enum_value = i_prot.read_i32()?;
    PayloadType::try_from(enum_value)  }
}

impl TryFrom<i32> for PayloadType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      101 => Ok(PayloadType::PayloadBuy),
      111 => Ok(PayloadType::PayloadCs),
      121 => Ok(PayloadType::PayloadBonus),
      131 => Ok(PayloadType::PayloadEvent),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to PayloadType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum PaymentPgType {
  PaymentPgNone = 0,
  PaymentPgAu = 1,
  PaymentPgAl = 2,
}

impl PaymentPgType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PaymentPgType> {
    let enum_value = i_prot.read_i32()?;
    PaymentPgType::try_from(enum_value)  }
}

impl TryFrom<i32> for PaymentPgType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(PaymentPgType::PaymentPgNone),
      1 => Ok(PaymentPgType::PaymentPgAu),
      2 => Ok(PaymentPgType::PaymentPgAl),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to PaymentPgType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum PaymentType {
  PaymentApple = 1,
  PaymentGoogle = 2,
}

impl PaymentType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PaymentType> {
    let enum_value = i_prot.read_i32()?;
    PaymentType::try_from(enum_value)  }
}

impl TryFrom<i32> for PaymentType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(PaymentType::PaymentApple),
      2 => Ok(PaymentType::PaymentGoogle),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to PaymentType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ProductBannerLinkType {
  BannerLinkNone = 0,
  BannerLinkItem = 1,
  BannerLinkUrl = 2,
  BannerLinkCategory = 3,
}

impl ProductBannerLinkType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProductBannerLinkType> {
    let enum_value = i_prot.read_i32()?;
    ProductBannerLinkType::try_from(enum_value)  }
}

impl TryFrom<i32> for ProductBannerLinkType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ProductBannerLinkType::BannerLinkNone),
      1 => Ok(ProductBannerLinkType::BannerLinkItem),
      2 => Ok(ProductBannerLinkType::BannerLinkUrl),
      3 => Ok(ProductBannerLinkType::BannerLinkCategory),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ProductBannerLinkType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ProductEventType {
  NoEvent = 0,
  CarrierAny = 65537,
  BuddyAny = 131073,
  InstallIos = 196609,
  InstallAndroid = 196610,
  MissionAny = 262145,
  MustbuyAny = 327681,
}

impl ProductEventType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProductEventType> {
    let enum_value = i_prot.read_i32()?;
    ProductEventType::try_from(enum_value)  }
}

impl TryFrom<i32> for ProductEventType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ProductEventType::NoEvent),
      65537 => Ok(ProductEventType::CarrierAny),
      131073 => Ok(ProductEventType::BuddyAny),
      196609 => Ok(ProductEventType::InstallIos),
      196610 => Ok(ProductEventType::InstallAndroid),
      262145 => Ok(ProductEventType::MissionAny),
      327681 => Ok(ProductEventType::MustbuyAny),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ProductEventType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ProfileAttribute {
  Email = 1,
  DisplayName = 2,
  PhoneticName = 4,
  Picture = 8,
  StatusMessage = 16,
  AllowSearchByUserid = 32,
  AllowSearchByEmail = 64,
  BuddyStatus = 128,
  All = 255,
}

impl ProfileAttribute {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProfileAttribute> {
    let enum_value = i_prot.read_i32()?;
    ProfileAttribute::try_from(enum_value)  }
}

impl TryFrom<i32> for ProfileAttribute {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(ProfileAttribute::Email),
      2 => Ok(ProfileAttribute::DisplayName),
      4 => Ok(ProfileAttribute::PhoneticName),
      8 => Ok(ProfileAttribute::Picture),
      16 => Ok(ProfileAttribute::StatusMessage),
      32 => Ok(ProfileAttribute::AllowSearchByUserid),
      64 => Ok(ProfileAttribute::AllowSearchByEmail),
      128 => Ok(ProfileAttribute::BuddyStatus),
      255 => Ok(ProfileAttribute::All),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ProfileAttribute", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum PublicType {
  Hidden = 0,
  Public = 1000,
}

impl PublicType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PublicType> {
    let enum_value = i_prot.read_i32()?;
    PublicType::try_from(enum_value)  }
}

impl TryFrom<i32> for PublicType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(PublicType::Hidden),
      1000 => Ok(PublicType::Public),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to PublicType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RedirectType {
  None = 0,
  ExpireSecond = 1,
}

impl RedirectType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RedirectType> {
    let enum_value = i_prot.read_i32()?;
    RedirectType::try_from(enum_value)  }
}

impl TryFrom<i32> for RedirectType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(RedirectType::None),
      1 => Ok(RedirectType::ExpireSecond),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to RedirectType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RegistrationType {
  Phone = 0,
  EmailWap = 1,
  Facebook = 2305,
  Sina = 2306,
  Renren = 2307,
  Feixin = 2308,
}

impl RegistrationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RegistrationType> {
    let enum_value = i_prot.read_i32()?;
    RegistrationType::try_from(enum_value)  }
}

impl TryFrom<i32> for RegistrationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(RegistrationType::Phone),
      1 => Ok(RegistrationType::EmailWap),
      2305 => Ok(RegistrationType::Facebook),
      2306 => Ok(RegistrationType::Sina),
      2307 => Ok(RegistrationType::Renren),
      2308 => Ok(RegistrationType::Feixin),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to RegistrationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SettingsAttribute {
  NotificationEnable = 1,
  NotificationMuteExpiration = 2,
  NotificationNewMessage = 4,
  NotificationGroupInvitation = 8,
  NotificationShowMessage = 16,
  NotificationIncomingCall = 32,
  PrivacySyncContacts = 64,
  PrivacySearchByPhoneNumber = 128,
  NotificationSoundMessage = 256,
  NotificationSoundGroup = 512,
  ContactMyTicket = 1024,
  IdentityProvider = 2048,
  IdentityIdentifier = 4096,
  PrivacySearchByUserid = 8192,
  PrivacySearchByEmail = 16384,
  PreferenceLocale = 32768,
  NotificationDisabledWithSub = 65536,
  SnsAccount = 524288,
  PhoneRegistration = 1048576,
  PrivacyAllowSecondaryDeviceLogin = 2097152,
  CustomMode = 4194304,
  PrivacyProfileImagePostToMyhome = 8388608,
  EmailConfirmationStatus = 16777216,
  PrivacyRecvMessagesFromNotFriend = 33554432,
  All = 2147483647,
}

impl SettingsAttribute {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SettingsAttribute> {
    let enum_value = i_prot.read_i32()?;
    SettingsAttribute::try_from(enum_value)  }
}

impl TryFrom<i32> for SettingsAttribute {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(SettingsAttribute::NotificationEnable),
      2 => Ok(SettingsAttribute::NotificationMuteExpiration),
      4 => Ok(SettingsAttribute::NotificationNewMessage),
      8 => Ok(SettingsAttribute::NotificationGroupInvitation),
      16 => Ok(SettingsAttribute::NotificationShowMessage),
      32 => Ok(SettingsAttribute::NotificationIncomingCall),
      64 => Ok(SettingsAttribute::PrivacySyncContacts),
      128 => Ok(SettingsAttribute::PrivacySearchByPhoneNumber),
      256 => Ok(SettingsAttribute::NotificationSoundMessage),
      512 => Ok(SettingsAttribute::NotificationSoundGroup),
      1024 => Ok(SettingsAttribute::ContactMyTicket),
      2048 => Ok(SettingsAttribute::IdentityProvider),
      4096 => Ok(SettingsAttribute::IdentityIdentifier),
      8192 => Ok(SettingsAttribute::PrivacySearchByUserid),
      16384 => Ok(SettingsAttribute::PrivacySearchByEmail),
      32768 => Ok(SettingsAttribute::PreferenceLocale),
      65536 => Ok(SettingsAttribute::NotificationDisabledWithSub),
      524288 => Ok(SettingsAttribute::SnsAccount),
      1048576 => Ok(SettingsAttribute::PhoneRegistration),
      2097152 => Ok(SettingsAttribute::PrivacyAllowSecondaryDeviceLogin),
      4194304 => Ok(SettingsAttribute::CustomMode),
      8388608 => Ok(SettingsAttribute::PrivacyProfileImagePostToMyhome),
      16777216 => Ok(SettingsAttribute::EmailConfirmationStatus),
      33554432 => Ok(SettingsAttribute::PrivacyRecvMessagesFromNotFriend),
      2147483647 => Ok(SettingsAttribute::All),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SettingsAttribute", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SnsIdType {
  Facebook = 1,
  Sina = 2,
  Renren = 3,
  Feixin = 4,
}

impl SnsIdType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsIdType> {
    let enum_value = i_prot.read_i32()?;
    SnsIdType::try_from(enum_value)  }
}

impl TryFrom<i32> for SnsIdType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(SnsIdType::Facebook),
      2 => Ok(SnsIdType::Sina),
      3 => Ok(SnsIdType::Renren),
      4 => Ok(SnsIdType::Feixin),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SnsIdType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SpammerReason {
  Other = 0,
  Advertising = 1,
  GenderHarassment = 2,
  Harassment = 3,
}

impl SpammerReason {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpammerReason> {
    let enum_value = i_prot.read_i32()?;
    SpammerReason::try_from(enum_value)  }
}

impl TryFrom<i32> for SpammerReason {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(SpammerReason::Other),
      1 => Ok(SpammerReason::Advertising),
      2 => Ok(SpammerReason::GenderHarassment),
      3 => Ok(SpammerReason::Harassment),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SpammerReason", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SyncActionType {
  Sync = 0,
  Report = 1,
}

impl SyncActionType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SyncActionType> {
    let enum_value = i_prot.read_i32()?;
    SyncActionType::try_from(enum_value)  }
}

impl TryFrom<i32> for SyncActionType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(SyncActionType::Sync),
      1 => Ok(SyncActionType::Report),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SyncActionType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SyncCategory {
  Profile = 0,
  Settings = 1,
  Ops = 2,
  Contact = 3,
  Recommend = 4,
  Block = 5,
  Group = 6,
  Room = 7,
  Notification = 8,
}

impl SyncCategory {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SyncCategory> {
    let enum_value = i_prot.read_i32()?;
    SyncCategory::try_from(enum_value)  }
}

impl TryFrom<i32> for SyncCategory {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(SyncCategory::Profile),
      1 => Ok(SyncCategory::Settings),
      2 => Ok(SyncCategory::Ops),
      3 => Ok(SyncCategory::Contact),
      4 => Ok(SyncCategory::Recommend),
      5 => Ok(SyncCategory::Block),
      6 => Ok(SyncCategory::Group),
      7 => Ok(SyncCategory::Room),
      8 => Ok(SyncCategory::Notification),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SyncCategory", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TMessageBoxStatus {
  Activated = 1,
  Unread = 2,
}

impl TMessageBoxStatus {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMessageBoxStatus> {
    let enum_value = i_prot.read_i32()?;
    TMessageBoxStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for TMessageBoxStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(TMessageBoxStatus::Activated),
      2 => Ok(TMessageBoxStatus::Unread),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TMessageBoxStatus", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum UniversalNotificationServiceErrorCode {
  InternalError = 0,
  InvalidKey = 1,
  IllegalArgument = 2,
  TooManyRequest = 3,
  AuthenticationFailed = 4,
  NoWritePermission = 5,
}

impl UniversalNotificationServiceErrorCode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UniversalNotificationServiceErrorCode> {
    let enum_value = i_prot.read_i32()?;
    UniversalNotificationServiceErrorCode::try_from(enum_value)  }
}

impl TryFrom<i32> for UniversalNotificationServiceErrorCode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(UniversalNotificationServiceErrorCode::InternalError),
      1 => Ok(UniversalNotificationServiceErrorCode::InvalidKey),
      2 => Ok(UniversalNotificationServiceErrorCode::IllegalArgument),
      3 => Ok(UniversalNotificationServiceErrorCode::TooManyRequest),
      4 => Ok(UniversalNotificationServiceErrorCode::AuthenticationFailed),
      5 => Ok(UniversalNotificationServiceErrorCode::NoWritePermission),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to UniversalNotificationServiceErrorCode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum UnregistrationReason {
  UnregistrationReasonUnregisterUser = 1,
  UnregistrationReasonUnbindDevice = 2,
}

impl UnregistrationReason {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UnregistrationReason> {
    let enum_value = i_prot.read_i32()?;
    UnregistrationReason::try_from(enum_value)  }
}

impl TryFrom<i32> for UnregistrationReason {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(UnregistrationReason::UnregistrationReasonUnregisterUser),
      2 => Ok(UnregistrationReason::UnregistrationReasonUnbindDevice),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to UnregistrationReason", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum UserAgeType {
  Over = 1,
  Under = 2,
  Undefined = 3,
}

impl UserAgeType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserAgeType> {
    let enum_value = i_prot.read_i32()?;
    UserAgeType::try_from(enum_value)  }
}

impl TryFrom<i32> for UserAgeType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(UserAgeType::Over),
      2 => Ok(UserAgeType::Under),
      3 => Ok(UserAgeType::Undefined),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to UserAgeType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum VerificationMethod {
  NoAvailable = 0,
  PinViaSms = 1,
  CalleridIndigo = 2,
  PinViaTts = 4,
  Skip = 10,
}

impl VerificationMethod {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VerificationMethod> {
    let enum_value = i_prot.read_i32()?;
    VerificationMethod::try_from(enum_value)  }
}

impl TryFrom<i32> for VerificationMethod {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(VerificationMethod::NoAvailable),
      1 => Ok(VerificationMethod::PinViaSms),
      2 => Ok(VerificationMethod::CalleridIndigo),
      4 => Ok(VerificationMethod::PinViaTts),
      10 => Ok(VerificationMethod::Skip),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to VerificationMethod", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum VerificationResult {
  Failed = 0,
  OkNotRegisteredYet = 1,
  OkRegisteredWithSameDevice = 2,
  OkRegisteredWithAnotherDevice = 3,
}

impl VerificationResult {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VerificationResult> {
    let enum_value = i_prot.read_i32()?;
    VerificationResult::try_from(enum_value)  }
}

impl TryFrom<i32> for VerificationResult {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(VerificationResult::Failed),
      1 => Ok(VerificationResult::OkNotRegisteredYet),
      2 => Ok(VerificationResult::OkRegisteredWithSameDevice),
      3 => Ok(VerificationResult::OkRegisteredWithAnotherDevice),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to VerificationResult", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum WapInvitationType {
  Registration = 1,
  Chat = 2,
}

impl WapInvitationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WapInvitationType> {
    let enum_value = i_prot.read_i32()?;
    WapInvitationType::try_from(enum_value)  }
}

impl TryFrom<i32> for WapInvitationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(WapInvitationType::Registration),
      2 => Ok(WapInvitationType::Chat),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to WapInvitationType", i)
            )
          )
        )
      },
    }
  }
}

//
// AgeCheckDocomoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AgeCheckDocomoResult {
  pub auth_url: Option<String>,
  pub user_age_type: Option<UserAgeType>,
}

impl AgeCheckDocomoResult {
  pub fn new<F1, F2>(auth_url: F1, user_age_type: F2) -> AgeCheckDocomoResult where F1: Into<Option<String>>, F2: Into<Option<UserAgeType>> {
    AgeCheckDocomoResult {
      auth_url: auth_url.into(),
      user_age_type: user_age_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckDocomoResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<UserAgeType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = UserAgeType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AgeCheckDocomoResult {
      auth_url: f_1,
      user_age_type: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AgeCheckDocomoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.auth_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("authUrl", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_age_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("userAgeType", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AgeCheckDocomoResult {
  fn default() -> Self {
    AgeCheckDocomoResult{
      auth_url: Some("".to_owned()),
      user_age_type: None,
    }
  }
}

//
// AgeCheckRequestResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AgeCheckRequestResult {
  pub auth_url: Option<String>,
  pub session_id: Option<String>,
}

impl AgeCheckRequestResult {
  pub fn new<F1, F2>(auth_url: F1, session_id: F2) -> AgeCheckRequestResult where F1: Into<Option<String>>, F2: Into<Option<String>> {
    AgeCheckRequestResult {
      auth_url: auth_url.into(),
      session_id: session_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckRequestResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AgeCheckRequestResult {
      auth_url: f_1,
      session_id: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AgeCheckRequestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.auth_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("authUrl", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AgeCheckRequestResult {
  fn default() -> Self {
    AgeCheckRequestResult{
      auth_url: Some("".to_owned()),
      session_id: Some("".to_owned()),
    }
  }
}

//
// Announcement
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Announcement {
  pub index: Option<i32>,
  pub force_update: Option<bool>,
  pub title: Option<String>,
  pub text: Option<String>,
  pub created_time: Option<i64>,
  pub picture_url: Option<String>,
  pub thumbnail_url: Option<String>,
}

impl Announcement {
  pub fn new<F1, F10, F11, F12, F13, F14, F15>(index: F1, force_update: F10, title: F11, text: F12, created_time: F13, picture_url: F14, thumbnail_url: F15) -> Announcement where F1: Into<Option<i32>>, F10: Into<Option<bool>>, F11: Into<Option<String>>, F12: Into<Option<String>>, F13: Into<Option<i64>>, F14: Into<Option<String>>, F15: Into<Option<String>> {
    Announcement {
      index: index.into(),
      force_update: force_update.into(),
      title: title.into(),
      text: text.into(),
      created_time: created_time.into(),
      picture_url: picture_url.into(),
      thumbnail_url: thumbnail_url.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Announcement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_10: Option<bool> = Some(false);
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    let mut f_13: Option<i64> = Some(0);
    let mut f_14: Option<String> = Some("".to_owned());
    let mut f_15: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Announcement {
      index: f_1,
      force_update: f_10,
      title: f_11,
      text: f_12,
      created_time: f_13,
      picture_url: f_14,
      thumbnail_url: f_15,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Announcement");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.index {
      o_prot.write_field_begin(&TFieldIdentifier::new("index", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.force_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("forceUpdate", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.text {
      o_prot.write_field_begin(&TFieldIdentifier::new("text", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("pictureUrl", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.thumbnail_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("thumbnailUrl", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Announcement {
  fn default() -> Self {
    Announcement{
      index: Some(0),
      force_update: Some(false),
      title: Some("".to_owned()),
      text: Some("".to_owned()),
      created_time: Some(0),
      picture_url: Some("".to_owned()),
      thumbnail_url: Some("".to_owned()),
    }
  }
}

//
// ChannelProvider
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelProvider {
  pub name: Option<String>,
}

impl ChannelProvider {
  pub fn new<F1>(name: F1) -> ChannelProvider where F1: Into<Option<String>> {
    ChannelProvider {
      name: name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelProvider> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelProvider {
      name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelProvider");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelProvider {
  fn default() -> Self {
    ChannelProvider{
      name: Some("".to_owned()),
    }
  }
}

//
// ChannelInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelInfo {
  pub channel_id: Option<String>,
  pub name: Option<String>,
  pub entry_page_url: Option<String>,
  pub description_text: Option<String>,
  pub provider: Option<ChannelProvider>,
  pub public_type: Option<PublicType>,
  pub icon_image: Option<String>,
  pub permissions: Option<Vec<String>>,
  pub icon_thumbnail_image: Option<String>,
  pub channel_configurations: Option<Vec<ChannelConfiguration>>,
}

impl ChannelInfo {
  pub fn new<F1, F3, F4, F5, F6, F7, F8, F9, F11, F12>(channel_id: F1, name: F3, entry_page_url: F4, description_text: F5, provider: F6, public_type: F7, icon_image: F8, permissions: F9, icon_thumbnail_image: F11, channel_configurations: F12) -> ChannelInfo where F1: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<ChannelProvider>>, F7: Into<Option<PublicType>>, F8: Into<Option<String>>, F9: Into<Option<Vec<String>>>, F11: Into<Option<String>>, F12: Into<Option<Vec<ChannelConfiguration>>> {
    ChannelInfo {
      channel_id: channel_id.into(),
      name: name.into(),
      entry_page_url: entry_page_url.into(),
      description_text: description_text.into(),
      provider: provider.into(),
      public_type: public_type.into(),
      icon_image: icon_image.into(),
      permissions: permissions.into(),
      icon_thumbnail_image: icon_thumbnail_image.into(),
      channel_configurations: channel_configurations.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<ChannelProvider> = None;
    let mut f_7: Option<PublicType> = None;
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<Vec<String>> = Some(Vec::new());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<Vec<ChannelConfiguration>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = ChannelProvider::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = PublicType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChannelConfiguration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = ChannelConfiguration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelInfo {
      channel_id: f_1,
      name: f_3,
      entry_page_url: f_4,
      description_text: f_5,
      provider: f_6,
      public_type: f_7,
      icon_image: f_8,
      permissions: f_9,
      icon_thumbnail_image: f_11,
      channel_configurations: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.entry_page_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("entryPageUrl", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.description_text {
      o_prot.write_field_begin(&TFieldIdentifier::new("descriptionText", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.provider {
      o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.public_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("publicType", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.icon_image {
      o_prot.write_field_begin(&TFieldIdentifier::new("iconImage", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.permissions {
      o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.icon_thumbnail_image {
      o_prot.write_field_begin(&TFieldIdentifier::new("iconThumbnailImage", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.channel_configurations {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelConfigurations", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelInfo {
  fn default() -> Self {
    ChannelInfo{
      channel_id: Some("".to_owned()),
      name: Some("".to_owned()),
      entry_page_url: Some("".to_owned()),
      description_text: Some("".to_owned()),
      provider: None,
      public_type: None,
      icon_image: Some("".to_owned()),
      permissions: Some(Vec::new()),
      icon_thumbnail_image: Some("".to_owned()),
      channel_configurations: Some(Vec::new()),
    }
  }
}

//
// ApprovedChannelInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ApprovedChannelInfo {
  pub channel_info: Option<ChannelInfo>,
  pub approved_at: Option<i64>,
}

impl ApprovedChannelInfo {
  pub fn new<F1, F2>(channel_info: F1, approved_at: F2) -> ApprovedChannelInfo where F1: Into<Option<ChannelInfo>>, F2: Into<Option<i64>> {
    ApprovedChannelInfo {
      channel_info: channel_info.into(),
      approved_at: approved_at.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApprovedChannelInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ChannelInfo> = None;
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ChannelInfo::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApprovedChannelInfo {
      channel_info: f_1,
      approved_at: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApprovedChannelInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelInfo", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.approved_at {
      o_prot.write_field_begin(&TFieldIdentifier::new("approvedAt", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ApprovedChannelInfo {
  fn default() -> Self {
    ApprovedChannelInfo{
      channel_info: None,
      approved_at: Some(0),
    }
  }
}

//
// ApprovedChannelInfos
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ApprovedChannelInfos {
  pub approved_channel_infos: Option<Vec<ApprovedChannelInfo>>,
  pub revision: Option<i64>,
}

impl ApprovedChannelInfos {
  pub fn new<F1, F2>(approved_channel_infos: F1, revision: F2) -> ApprovedChannelInfos where F1: Into<Option<Vec<ApprovedChannelInfo>>>, F2: Into<Option<i64>> {
    ApprovedChannelInfos {
      approved_channel_infos: approved_channel_infos.into(),
      revision: revision.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApprovedChannelInfos> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ApprovedChannelInfo>> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ApprovedChannelInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = ApprovedChannelInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApprovedChannelInfos {
      approved_channel_infos: f_1,
      revision: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApprovedChannelInfos");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.approved_channel_infos {
      o_prot.write_field_begin(&TFieldIdentifier::new("approvedChannelInfos", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ApprovedChannelInfos {
  fn default() -> Self {
    ApprovedChannelInfos{
      approved_channel_infos: Some(Vec::new()),
      revision: Some(0),
    }
  }
}

//
// AuthQrcode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AuthQrcode {
  pub qrcode: Option<String>,
  pub verifier: Option<String>,
}

impl AuthQrcode {
  pub fn new<F1, F2>(qrcode: F1, verifier: F2) -> AuthQrcode where F1: Into<Option<String>>, F2: Into<Option<String>> {
    AuthQrcode {
      qrcode: qrcode.into(),
      verifier: verifier.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AuthQrcode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AuthQrcode {
      qrcode: f_1,
      verifier: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AuthQrcode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.qrcode {
      o_prot.write_field_begin(&TFieldIdentifier::new("qrcode", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.verifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AuthQrcode {
  fn default() -> Self {
    AuthQrcode{
      qrcode: Some("".to_owned()),
      verifier: Some("".to_owned()),
    }
  }
}

//
// BuddyBanner
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddyBanner {
  pub buddy_banner_link_type: Option<BuddyBannerLinkType>,
  pub buddy_banner_link: Option<String>,
  pub buddy_banner_image_url: Option<String>,
}

impl BuddyBanner {
  pub fn new<F1, F2, F3>(buddy_banner_link_type: F1, buddy_banner_link: F2, buddy_banner_image_url: F3) -> BuddyBanner where F1: Into<Option<BuddyBannerLinkType>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    BuddyBanner {
      buddy_banner_link_type: buddy_banner_link_type.into(),
      buddy_banner_link: buddy_banner_link.into(),
      buddy_banner_image_url: buddy_banner_image_url.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyBanner> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BuddyBannerLinkType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = BuddyBannerLinkType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyBanner {
      buddy_banner_link_type: f_1,
      buddy_banner_link: f_2,
      buddy_banner_image_url: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyBanner");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.buddy_banner_link_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("buddyBannerLinkType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.buddy_banner_link {
      o_prot.write_field_begin(&TFieldIdentifier::new("buddyBannerLink", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.buddy_banner_image_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("buddyBannerImageUrl", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddyBanner {
  fn default() -> Self {
    BuddyBanner{
      buddy_banner_link_type: None,
      buddy_banner_link: Some("".to_owned()),
      buddy_banner_image_url: Some("".to_owned()),
    }
  }
}

//
// BuddyDetail
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddyDetail {
  pub mid: Option<String>,
  pub member_count: Option<i64>,
  pub on_air: Option<bool>,
  pub business_account: Option<bool>,
  pub addable: Option<bool>,
  pub acceptable_content_types: Option<BTreeSet<ContentType>>,
  pub capable_myhome: Option<bool>,
}

impl BuddyDetail {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(mid: F1, member_count: F2, on_air: F3, business_account: F4, addable: F5, acceptable_content_types: F6, capable_myhome: F7) -> BuddyDetail where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<BTreeSet<ContentType>>>, F7: Into<Option<bool>> {
    BuddyDetail {
      mid: mid.into(),
      member_count: member_count.into(),
      on_air: on_air.into(),
      business_account: business_account.into(),
      addable: addable.into(),
      acceptable_content_types: acceptable_content_types.into(),
      capable_myhome: capable_myhome.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyDetail> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<BTreeSet<ContentType>> = Some(BTreeSet::new());
    let mut f_7: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<ContentType> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_3 = ContentType::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_3);
          }
          i_prot.read_set_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyDetail {
      mid: f_1,
      member_count: f_2,
      on_air: f_3,
      business_account: f_4,
      addable: f_5,
      acceptable_content_types: f_6,
      capable_myhome: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyDetail");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.member_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("memberCount", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.on_air {
      o_prot.write_field_begin(&TFieldIdentifier::new("onAir", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.business_account {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessAccount", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.addable {
      o_prot.write_field_begin(&TFieldIdentifier::new("addable", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.acceptable_content_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("acceptableContentTypes", TType::Set, 6))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_set_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.capable_myhome {
      o_prot.write_field_begin(&TFieldIdentifier::new("capableMyhome", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddyDetail {
  fn default() -> Self {
    BuddyDetail{
      mid: Some("".to_owned()),
      member_count: Some(0),
      on_air: Some(false),
      business_account: Some(false),
      addable: Some(false),
      acceptable_content_types: Some(BTreeSet::new()),
      capable_myhome: Some(false),
    }
  }
}

//
// Contact
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Contact {
  pub mid: Option<String>,
  pub created_time: Option<i64>,
  pub type_: Option<ContactType>,
  pub status: Option<ContactStatus>,
  pub relation: Option<ContactRelation>,
  pub display_name: Option<String>,
  pub phonetic_name: Option<String>,
  pub picture_status: Option<String>,
  pub thumbnail_url: Option<String>,
  pub status_message: Option<String>,
  pub display_name_overridden: Option<String>,
  pub favorite_time: Option<i64>,
  pub capable_voice_call: Option<bool>,
  pub capable_video_call: Option<bool>,
  pub capable_myhome: Option<bool>,
  pub capable_buddy: Option<bool>,
  pub attributes: Option<i32>,
  pub settings: Option<i64>,
  pub picture_path: Option<String>,
}

impl Contact {
  pub fn new<F1, F2, F10, F11, F21, F22, F23, F24, F25, F26, F27, F28, F31, F32, F33, F34, F35, F36, F37>(mid: F1, created_time: F2, type_: F10, status: F11, relation: F21, display_name: F22, phonetic_name: F23, picture_status: F24, thumbnail_url: F25, status_message: F26, display_name_overridden: F27, favorite_time: F28, capable_voice_call: F31, capable_video_call: F32, capable_myhome: F33, capable_buddy: F34, attributes: F35, settings: F36, picture_path: F37) -> Contact where F1: Into<Option<String>>, F2: Into<Option<i64>>, F10: Into<Option<ContactType>>, F11: Into<Option<ContactStatus>>, F21: Into<Option<ContactRelation>>, F22: Into<Option<String>>, F23: Into<Option<String>>, F24: Into<Option<String>>, F25: Into<Option<String>>, F26: Into<Option<String>>, F27: Into<Option<String>>, F28: Into<Option<i64>>, F31: Into<Option<bool>>, F32: Into<Option<bool>>, F33: Into<Option<bool>>, F34: Into<Option<bool>>, F35: Into<Option<i32>>, F36: Into<Option<i64>>, F37: Into<Option<String>> {
    Contact {
      mid: mid.into(),
      created_time: created_time.into(),
      type_: type_.into(),
      status: status.into(),
      relation: relation.into(),
      display_name: display_name.into(),
      phonetic_name: phonetic_name.into(),
      picture_status: picture_status.into(),
      thumbnail_url: thumbnail_url.into(),
      status_message: status_message.into(),
      display_name_overridden: display_name_overridden.into(),
      favorite_time: favorite_time.into(),
      capable_voice_call: capable_voice_call.into(),
      capable_video_call: capable_video_call.into(),
      capable_myhome: capable_myhome.into(),
      capable_buddy: capable_buddy.into(),
      attributes: attributes.into(),
      settings: settings.into(),
      picture_path: picture_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Contact> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_10: Option<ContactType> = None;
    let mut f_11: Option<ContactStatus> = None;
    let mut f_21: Option<ContactRelation> = None;
    let mut f_22: Option<String> = Some("".to_owned());
    let mut f_23: Option<String> = Some("".to_owned());
    let mut f_24: Option<String> = Some("".to_owned());
    let mut f_25: Option<String> = Some("".to_owned());
    let mut f_26: Option<String> = Some("".to_owned());
    let mut f_27: Option<String> = Some("".to_owned());
    let mut f_28: Option<i64> = Some(0);
    let mut f_31: Option<bool> = Some(false);
    let mut f_32: Option<bool> = Some(false);
    let mut f_33: Option<bool> = Some(false);
    let mut f_34: Option<bool> = Some(false);
    let mut f_35: Option<i32> = Some(0);
    let mut f_36: Option<i64> = Some(0);
    let mut f_37: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        10 => {
          let val = ContactType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = ContactStatus::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        21 => {
          let val = ContactRelation::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_string()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_string()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_string()?;
          f_25 = Some(val);
        },
        26 => {
          let val = i_prot.read_string()?;
          f_26 = Some(val);
        },
        27 => {
          let val = i_prot.read_string()?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_i64()?;
          f_28 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        32 => {
          let val = i_prot.read_bool()?;
          f_32 = Some(val);
        },
        33 => {
          let val = i_prot.read_bool()?;
          f_33 = Some(val);
        },
        34 => {
          let val = i_prot.read_bool()?;
          f_34 = Some(val);
        },
        35 => {
          let val = i_prot.read_i32()?;
          f_35 = Some(val);
        },
        36 => {
          let val = i_prot.read_i64()?;
          f_36 = Some(val);
        },
        37 => {
          let val = i_prot.read_string()?;
          f_37 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Contact {
      mid: f_1,
      created_time: f_2,
      type_: f_10,
      status: f_11,
      relation: f_21,
      display_name: f_22,
      phonetic_name: f_23,
      picture_status: f_24,
      thumbnail_url: f_25,
      status_message: f_26,
      display_name_overridden: f_27,
      favorite_time: f_28,
      capable_voice_call: f_31,
      capable_video_call: f_32,
      capable_myhome: f_33,
      capable_buddy: f_34,
      attributes: f_35,
      settings: f_36,
      picture_path: f_37,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Contact");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.relation {
      o_prot.write_field_begin(&TFieldIdentifier::new("relation", TType::I32, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.phonetic_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("phoneticName", TType::String, 23))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("pictureStatus", TType::String, 24))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.thumbnail_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("thumbnailUrl", TType::String, 25))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("statusMessage", TType::String, 26))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name_overridden {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayNameOverridden", TType::String, 27))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.favorite_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("favoriteTime", TType::I64, 28))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.capable_voice_call {
      o_prot.write_field_begin(&TFieldIdentifier::new("capableVoiceCall", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.capable_video_call {
      o_prot.write_field_begin(&TFieldIdentifier::new("capableVideoCall", TType::Bool, 32))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.capable_myhome {
      o_prot.write_field_begin(&TFieldIdentifier::new("capableMyhome", TType::Bool, 33))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.capable_buddy {
      o_prot.write_field_begin(&TFieldIdentifier::new("capableBuddy", TType::Bool, 34))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::I32, 35))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.settings {
      o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::I64, 36))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("picturePath", TType::String, 37))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Contact {
  fn default() -> Self {
    Contact{
      mid: Some("".to_owned()),
      created_time: Some(0),
      type_: None,
      status: None,
      relation: None,
      display_name: Some("".to_owned()),
      phonetic_name: Some("".to_owned()),
      picture_status: Some("".to_owned()),
      thumbnail_url: Some("".to_owned()),
      status_message: Some("".to_owned()),
      display_name_overridden: Some("".to_owned()),
      favorite_time: Some(0),
      capable_voice_call: Some(false),
      capable_video_call: Some(false),
      capable_myhome: Some(false),
      capable_buddy: Some(false),
      attributes: Some(0),
      settings: Some(0),
      picture_path: Some("".to_owned()),
    }
  }
}

//
// BuddyList
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddyList {
  pub classification: Option<String>,
  pub display_name: Option<String>,
  pub total_buddy_count: Option<i32>,
  pub popular_contacts: Option<Vec<Contact>>,
}

impl BuddyList {
  pub fn new<F1, F2, F3, F4>(classification: F1, display_name: F2, total_buddy_count: F3, popular_contacts: F4) -> BuddyList where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<Vec<Contact>>> {
    BuddyList {
      classification: classification.into(),
      display_name: display_name.into(),
      total_buddy_count: total_buddy_count.into(),
      popular_contacts: popular_contacts.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<Vec<Contact>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyList {
      classification: f_1,
      display_name: f_2,
      total_buddy_count: f_3,
      popular_contacts: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyList");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.classification {
      o_prot.write_field_begin(&TFieldIdentifier::new("classification", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_buddy_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalBuddyCount", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.popular_contacts {
      o_prot.write_field_begin(&TFieldIdentifier::new("popularContacts", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddyList {
  fn default() -> Self {
    BuddyList{
      classification: Some("".to_owned()),
      display_name: Some("".to_owned()),
      total_buddy_count: Some(0),
      popular_contacts: Some(Vec::new()),
    }
  }
}

//
// Location
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Location {
  pub title: Option<String>,
  pub address: Option<String>,
  pub latitude: Option<OrderedFloat<f64>>,
  pub longitude: Option<OrderedFloat<f64>>,
  pub phone: Option<String>,
}

impl Location {
  pub fn new<F1, F2, F3, F4, F5>(title: F1, address: F2, latitude: F3, longitude: F4, phone: F5) -> Location where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<OrderedFloat<f64>>>, F5: Into<Option<String>> {
    Location {
      title: title.into(),
      address: address.into(),
      latitude: latitude.into(),
      longitude: longitude.into(),
      phone: phone.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Location> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_4: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Location {
      title: f_1,
      address: f_2,
      latitude: f_3,
      longitude: f_4,
      phone: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Location");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.address {
      o_prot.write_field_begin(&TFieldIdentifier::new("address", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.latitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("latitude", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.longitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("longitude", TType::Double, 4))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.phone {
      o_prot.write_field_begin(&TFieldIdentifier::new("phone", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Location {
  fn default() -> Self {
    Location{
      title: Some("".to_owned()),
      address: Some("".to_owned()),
      latitude: Some(OrderedFloat::from(0.0)),
      longitude: Some(OrderedFloat::from(0.0)),
      phone: Some("".to_owned()),
    }
  }
}

//
// BuddyMessageRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddyMessageRequest {
  pub content_type: Option<ContentType>,
  pub text: Option<String>,
  pub location: Option<Location>,
  pub content: Option<Vec<u8>>,
  pub content_metadata: Option<BTreeMap<String, String>>,
}

impl BuddyMessageRequest {
  pub fn new<F1, F2, F3, F4, F5>(content_type: F1, text: F2, location: F3, content: F4, content_metadata: F5) -> BuddyMessageRequest where F1: Into<Option<ContentType>>, F2: Into<Option<String>>, F3: Into<Option<Location>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<BTreeMap<String, String>>> {
    BuddyMessageRequest {
      content_type: content_type.into(),
      text: text.into(),
      location: location.into(),
      content: content.into(),
      content_metadata: content_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyMessageRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ContentType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<Location> = None;
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ContentType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Location::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_string()?;
            let map_val_6 = i_prot.read_string()?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyMessageRequest {
      content_type: f_1,
      text: f_2,
      location: f_3,
      content: f_4,
      content_metadata: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyMessageRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.content_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.text {
      o_prot.write_field_begin(&TFieldIdentifier::new("text", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.location {
      o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content {
      o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentMetadata", TType::Map, 5))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddyMessageRequest {
  fn default() -> Self {
    BuddyMessageRequest{
      content_type: None,
      text: Some("".to_owned()),
      location: None,
      content: Some(Vec::new()),
      content_metadata: Some(BTreeMap::new()),
    }
  }
}

//
// BuddyOnAirUrls
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddyOnAirUrls {
  pub hls: Option<BTreeMap<String, String>>,
  pub smooth_streaming: Option<BTreeMap<String, String>>,
}

impl BuddyOnAirUrls {
  pub fn new<F1, F2>(hls: F1, smooth_streaming: F2) -> BuddyOnAirUrls where F1: Into<Option<BTreeMap<String, String>>>, F2: Into<Option<BTreeMap<String, String>>> {
    BuddyOnAirUrls {
      hls: hls.into(),
      smooth_streaming: smooth_streaming.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyOnAirUrls> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    let mut f_2: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_7 = i_prot.read_string()?;
            let map_val_8 = i_prot.read_string()?;
            val.insert(map_key_7, map_val_8);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_9 = i_prot.read_string()?;
            let map_val_10 = i_prot.read_string()?;
            val.insert(map_key_9, map_val_10);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyOnAirUrls {
      hls: f_1,
      smooth_streaming: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyOnAirUrls");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hls {
      o_prot.write_field_begin(&TFieldIdentifier::new("hls", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.smooth_streaming {
      o_prot.write_field_begin(&TFieldIdentifier::new("smoothStreaming", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddyOnAirUrls {
  fn default() -> Self {
    BuddyOnAirUrls{
      hls: Some(BTreeMap::new()),
      smooth_streaming: Some(BTreeMap::new()),
    }
  }
}

//
// BuddyOnAir
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddyOnAir {
  pub mid: Option<String>,
  pub freshness_lifetime: Option<i64>,
  pub on_air_id: Option<String>,
  pub on_air: Option<bool>,
  pub text: Option<String>,
  pub viewer_count: Option<i64>,
  pub target_count: Option<i64>,
  pub on_air_type: Option<BuddyOnAirType>,
  pub on_air_urls: Option<BuddyOnAirUrls>,
}

impl BuddyOnAir {
  pub fn new<F1, F3, F4, F5, F11, F12, F13, F31, F32>(mid: F1, freshness_lifetime: F3, on_air_id: F4, on_air: F5, text: F11, viewer_count: F12, target_count: F13, on_air_type: F31, on_air_urls: F32) -> BuddyOnAir where F1: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F11: Into<Option<String>>, F12: Into<Option<i64>>, F13: Into<Option<i64>>, F31: Into<Option<BuddyOnAirType>>, F32: Into<Option<BuddyOnAirUrls>> {
    BuddyOnAir {
      mid: mid.into(),
      freshness_lifetime: freshness_lifetime.into(),
      on_air_id: on_air_id.into(),
      on_air: on_air.into(),
      text: text.into(),
      viewer_count: viewer_count.into(),
      target_count: target_count.into(),
      on_air_type: on_air_type.into(),
      on_air_urls: on_air_urls.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyOnAir> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<bool> = Some(false);
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<i64> = Some(0);
    let mut f_13: Option<i64> = Some(0);
    let mut f_31: Option<BuddyOnAirType> = None;
    let mut f_32: Option<BuddyOnAirUrls> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        31 => {
          let val = BuddyOnAirType::read_from_in_protocol(i_prot)?;
          f_31 = Some(val);
        },
        32 => {
          let val = BuddyOnAirUrls::read_from_in_protocol(i_prot)?;
          f_32 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyOnAir {
      mid: f_1,
      freshness_lifetime: f_3,
      on_air_id: f_4,
      on_air: f_5,
      text: f_11,
      viewer_count: f_12,
      target_count: f_13,
      on_air_type: f_31,
      on_air_urls: f_32,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyOnAir");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.freshness_lifetime {
      o_prot.write_field_begin(&TFieldIdentifier::new("freshnessLifetime", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.on_air_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("onAirId", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.on_air {
      o_prot.write_field_begin(&TFieldIdentifier::new("onAir", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.text {
      o_prot.write_field_begin(&TFieldIdentifier::new("text", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.viewer_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("viewerCount", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.target_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetCount", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.on_air_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("onAirType", TType::I32, 31))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.on_air_urls {
      o_prot.write_field_begin(&TFieldIdentifier::new("onAirUrls", TType::Struct, 32))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddyOnAir {
  fn default() -> Self {
    BuddyOnAir{
      mid: Some("".to_owned()),
      freshness_lifetime: Some(0),
      on_air_id: Some("".to_owned()),
      on_air: Some(false),
      text: Some("".to_owned()),
      viewer_count: Some(0),
      target_count: Some(0),
      on_air_type: None,
      on_air_urls: None,
    }
  }
}

//
// BuddyProfile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddyProfile {
  pub buddy_id: Option<String>,
  pub mid: Option<String>,
  pub search_id: Option<String>,
  pub display_name: Option<String>,
  pub status_message: Option<String>,
  pub contact_count: Option<i64>,
}

impl BuddyProfile {
  pub fn new<F1, F2, F3, F4, F5, F11>(buddy_id: F1, mid: F2, search_id: F3, display_name: F4, status_message: F5, contact_count: F11) -> BuddyProfile where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F11: Into<Option<i64>> {
    BuddyProfile {
      buddy_id: buddy_id.into(),
      mid: mid.into(),
      search_id: search_id.into(),
      display_name: display_name.into(),
      status_message: status_message.into(),
      contact_count: contact_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyProfile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_11: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyProfile {
      buddy_id: f_1,
      mid: f_2,
      search_id: f_3,
      display_name: f_4,
      status_message: f_5,
      contact_count: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyProfile");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.buddy_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("buddyId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.search_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchId", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("statusMessage", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.contact_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("contactCount", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddyProfile {
  fn default() -> Self {
    BuddyProfile{
      buddy_id: Some("".to_owned()),
      mid: Some("".to_owned()),
      search_id: Some("".to_owned()),
      display_name: Some("".to_owned()),
      status_message: Some("".to_owned()),
      contact_count: Some(0),
    }
  }
}

//
// BuddySearchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BuddySearchResult {
  pub mid: Option<String>,
  pub display_name: Option<String>,
  pub picture_status: Option<String>,
  pub picture_path: Option<String>,
  pub status_message: Option<String>,
  pub business_account: Option<bool>,
}

impl BuddySearchResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(mid: F1, display_name: F2, picture_status: F3, picture_path: F4, status_message: F5, business_account: F6) -> BuddySearchResult where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<bool>> {
    BuddySearchResult {
      mid: mid.into(),
      display_name: display_name.into(),
      picture_status: picture_status.into(),
      picture_path: picture_path.into(),
      status_message: status_message.into(),
      business_account: business_account.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddySearchResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddySearchResult {
      mid: f_1,
      display_name: f_2,
      picture_status: f_3,
      picture_path: f_4,
      status_message: f_5,
      business_account: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddySearchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("pictureStatus", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("picturePath", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("statusMessage", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.business_account {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessAccount", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BuddySearchResult {
  fn default() -> Self {
    BuddySearchResult{
      mid: Some("".to_owned()),
      display_name: Some("".to_owned()),
      picture_status: Some("".to_owned()),
      picture_path: Some("".to_owned()),
      status_message: Some("".to_owned()),
      business_account: Some(false),
    }
  }
}

//
// ChannelDomain
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelDomain {
  pub host: Option<String>,
  pub removed: Option<bool>,
}

impl ChannelDomain {
  pub fn new<F1, F2>(host: F1, removed: F2) -> ChannelDomain where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    ChannelDomain {
      host: host.into(),
      removed: removed.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelDomain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelDomain {
      host: f_1,
      removed: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelDomain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.host {
      o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.removed {
      o_prot.write_field_begin(&TFieldIdentifier::new("removed", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelDomain {
  fn default() -> Self {
    ChannelDomain{
      host: Some("".to_owned()),
      removed: Some(false),
    }
  }
}

//
// ChannelDomains
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelDomains {
  pub channel_domains: Option<Vec<ChannelDomain>>,
  pub revision: Option<i64>,
}

impl ChannelDomains {
  pub fn new<F1, F2>(channel_domains: F1, revision: F2) -> ChannelDomains where F1: Into<Option<Vec<ChannelDomain>>>, F2: Into<Option<i64>> {
    ChannelDomains {
      channel_domains: channel_domains.into(),
      revision: revision.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelDomains> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ChannelDomain>> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChannelDomain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = ChannelDomain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelDomains {
      channel_domains: f_1,
      revision: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelDomains");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_domains {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelDomains", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelDomains {
  fn default() -> Self {
    ChannelDomains{
      channel_domains: Some(Vec::new()),
      revision: Some(0),
    }
  }
}

//
// ChannelException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelException {
  pub code: Option<ChannelErrorCode>,
  pub reason: Option<String>,
  pub parameter_map: Option<BTreeMap<String, String>>,
}

impl ChannelException {
  pub fn new<F1, F2, F3>(code: F1, reason: F2, parameter_map: F3) -> ChannelException where F1: Into<Option<ChannelErrorCode>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    ChannelException {
      code: code.into(),
      reason: reason.into(),
      parameter_map: parameter_map.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ChannelErrorCode> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ChannelErrorCode::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_12 = i_prot.read_string()?;
            let map_val_13 = i_prot.read_string()?;
            val.insert(map_key_12, map_val_13);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelException {
      code: f_1,
      reason: f_2,
      parameter_map: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.parameter_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameterMap", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelException {
  fn default() -> Self {
    ChannelException{
      code: None,
      reason: Some("".to_owned()),
      parameter_map: Some(BTreeMap::new()),
    }
  }
}

impl Error for ChannelException {
  fn description(&self) -> &str {
    "remote service threw ChannelException"
  }
}

impl From<ChannelException> for thrift::Error {
  fn from(e: ChannelException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ChannelException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// ChannelInfos
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelInfos {
  pub channel_infos: Option<Vec<ChannelInfo>>,
  pub revision: Option<i64>,
}

impl ChannelInfos {
  pub fn new<F1, F2>(channel_infos: F1, revision: F2) -> ChannelInfos where F1: Into<Option<Vec<ChannelInfo>>>, F2: Into<Option<i64>> {
    ChannelInfos {
      channel_infos: channel_infos.into(),
      revision: revision.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelInfos> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ChannelInfo>> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChannelInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = ChannelInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelInfos {
      channel_infos: f_1,
      revision: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelInfos");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_infos {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelInfos", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelInfos {
  fn default() -> Self {
    ChannelInfos{
      channel_infos: Some(Vec::new()),
      revision: Some(0),
    }
  }
}

//
// ChannelNotificationSetting
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelNotificationSetting {
  pub channel_id: Option<String>,
  pub name: Option<String>,
  pub notification_receivable: Option<bool>,
  pub message_receivable: Option<bool>,
  pub show_default: Option<bool>,
}

impl ChannelNotificationSetting {
  pub fn new<F1, F2, F3, F4, F5>(channel_id: F1, name: F2, notification_receivable: F3, message_receivable: F4, show_default: F5) -> ChannelNotificationSetting where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>> {
    ChannelNotificationSetting {
      channel_id: channel_id.into(),
      name: name.into(),
      notification_receivable: notification_receivable.into(),
      message_receivable: message_receivable.into(),
      show_default: show_default.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelNotificationSetting> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelNotificationSetting {
      channel_id: f_1,
      name: f_2,
      notification_receivable: f_3,
      message_receivable: f_4,
      show_default: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelNotificationSetting");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_receivable {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationReceivable", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.message_receivable {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageReceivable", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.show_default {
      o_prot.write_field_begin(&TFieldIdentifier::new("showDefault", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelNotificationSetting {
  fn default() -> Self {
    ChannelNotificationSetting{
      channel_id: Some("".to_owned()),
      name: Some("".to_owned()),
      notification_receivable: Some(false),
      message_receivable: Some(false),
      show_default: Some(false),
    }
  }
}

//
// ChannelSyncDatas
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelSyncDatas {
  pub channel_infos: Option<Vec<ChannelInfo>>,
  pub channel_domains: Option<Vec<ChannelDomain>>,
  pub revision: Option<i64>,
  pub expires: Option<i64>,
}

impl ChannelSyncDatas {
  pub fn new<F1, F2, F3, F4>(channel_infos: F1, channel_domains: F2, revision: F3, expires: F4) -> ChannelSyncDatas where F1: Into<Option<Vec<ChannelInfo>>>, F2: Into<Option<Vec<ChannelDomain>>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    ChannelSyncDatas {
      channel_infos: channel_infos.into(),
      channel_domains: channel_domains.into(),
      revision: revision.into(),
      expires: expires.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelSyncDatas> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ChannelInfo>> = Some(Vec::new());
    let mut f_2: Option<Vec<ChannelDomain>> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChannelInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = ChannelInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChannelDomain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = ChannelDomain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelSyncDatas {
      channel_infos: f_1,
      channel_domains: f_2,
      revision: f_3,
      expires: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelSyncDatas");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_infos {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelInfos", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.channel_domains {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelDomains", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.expires {
      o_prot.write_field_begin(&TFieldIdentifier::new("expires", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelSyncDatas {
  fn default() -> Self {
    ChannelSyncDatas{
      channel_infos: Some(Vec::new()),
      channel_domains: Some(Vec::new()),
      revision: Some(0),
      expires: Some(0),
    }
  }
}

//
// ChannelToken
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChannelToken {
  pub token: Option<String>,
  pub obs_token: Option<String>,
  pub expiration: Option<i64>,
  pub refresh_token: Option<String>,
  pub channel_access_token: Option<String>,
}

impl ChannelToken {
  pub fn new<F1, F2, F3, F4, F5>(token: F1, obs_token: F2, expiration: F3, refresh_token: F4, channel_access_token: F5) -> ChannelToken where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    ChannelToken {
      token: token.into(),
      obs_token: obs_token.into(),
      expiration: expiration.into(),
      refresh_token: refresh_token.into(),
      channel_access_token: channel_access_token.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelToken> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelToken {
      token: f_1,
      obs_token: f_2,
      expiration: f_3,
      refresh_token: f_4,
      channel_access_token: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelToken");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.token {
      o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.obs_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("obsToken", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.expiration {
      o_prot.write_field_begin(&TFieldIdentifier::new("expiration", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.refresh_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("refreshToken", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.channel_access_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelAccessToken", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ChannelToken {
  fn default() -> Self {
    ChannelToken{
      token: Some("".to_owned()),
      obs_token: Some("".to_owned()),
      expiration: Some(0),
      refresh_token: Some("".to_owned()),
      channel_access_token: Some("".to_owned()),
    }
  }
}

//
// Coin
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Coin {
  pub free_coin_balance: Option<i32>,
  pub payed_coin_balance: Option<i32>,
  pub total_coin_balance: Option<i32>,
  pub reward_coin_balance: Option<i32>,
}

impl Coin {
  pub fn new<F1, F2, F3, F4>(free_coin_balance: F1, payed_coin_balance: F2, total_coin_balance: F3, reward_coin_balance: F4) -> Coin where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<i32>> {
    Coin {
      free_coin_balance: free_coin_balance.into(),
      payed_coin_balance: payed_coin_balance.into(),
      total_coin_balance: total_coin_balance.into(),
      reward_coin_balance: reward_coin_balance.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Coin> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Coin {
      free_coin_balance: f_1,
      payed_coin_balance: f_2,
      total_coin_balance: f_3,
      reward_coin_balance: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Coin");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.free_coin_balance {
      o_prot.write_field_begin(&TFieldIdentifier::new("freeCoinBalance", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.payed_coin_balance {
      o_prot.write_field_begin(&TFieldIdentifier::new("payedCoinBalance", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_coin_balance {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalCoinBalance", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.reward_coin_balance {
      o_prot.write_field_begin(&TFieldIdentifier::new("rewardCoinBalance", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Coin {
  fn default() -> Self {
    Coin{
      free_coin_balance: Some(0),
      payed_coin_balance: Some(0),
      total_coin_balance: Some(0),
      reward_coin_balance: Some(0),
    }
  }
}

//
// CoinPayLoad
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinPayLoad {
  pub pay_coin: Option<i32>,
  pub free_coin: Option<i32>,
  pub type_: Option<PayloadType>,
  pub reward_coin: Option<i32>,
}

impl CoinPayLoad {
  pub fn new<F1, F2, F3, F4>(pay_coin: F1, free_coin: F2, type_: F3, reward_coin: F4) -> CoinPayLoad where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<PayloadType>>, F4: Into<Option<i32>> {
    CoinPayLoad {
      pay_coin: pay_coin.into(),
      free_coin: free_coin.into(),
      type_: type_.into(),
      reward_coin: reward_coin.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinPayLoad> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<PayloadType> = None;
    let mut f_4: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = PayloadType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinPayLoad {
      pay_coin: f_1,
      free_coin: f_2,
      type_: f_3,
      reward_coin: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinPayLoad");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.pay_coin {
      o_prot.write_field_begin(&TFieldIdentifier::new("payCoin", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.free_coin {
      o_prot.write_field_begin(&TFieldIdentifier::new("freeCoin", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.reward_coin {
      o_prot.write_field_begin(&TFieldIdentifier::new("rewardCoin", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinPayLoad {
  fn default() -> Self {
    CoinPayLoad{
      pay_coin: Some(0),
      free_coin: Some(0),
      type_: None,
      reward_coin: Some(0),
    }
  }
}

//
// CoinHistory
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinHistory {
  pub pay_date: Option<i64>,
  pub coin_balance: Option<i32>,
  pub coin: Option<i32>,
  pub price: Option<String>,
  pub title: Option<String>,
  pub refund: Option<bool>,
  pub pay_seq: Option<String>,
  pub currency: Option<String>,
  pub currency_sign: Option<String>,
  pub display_price: Option<String>,
  pub payload: Option<CoinPayLoad>,
  pub channel_id: Option<String>,
}

impl CoinHistory {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(pay_date: F1, coin_balance: F2, coin: F3, price: F4, title: F5, refund: F6, pay_seq: F7, currency: F8, currency_sign: F9, display_price: F10, payload: F11, channel_id: F12) -> CoinHistory where F1: Into<Option<i64>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<bool>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<CoinPayLoad>>, F12: Into<Option<String>> {
    CoinHistory {
      pay_date: pay_date.into(),
      coin_balance: coin_balance.into(),
      coin: coin.into(),
      price: price.into(),
      title: title.into(),
      refund: refund.into(),
      pay_seq: pay_seq.into(),
      currency: currency.into(),
      currency_sign: currency_sign.into(),
      display_price: display_price.into(),
      payload: payload.into(),
      channel_id: channel_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinHistory> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<CoinPayLoad> = None;
    let mut f_12: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = CoinPayLoad::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinHistory {
      pay_date: f_1,
      coin_balance: f_2,
      coin: f_3,
      price: f_4,
      title: f_5,
      refund: f_6,
      pay_seq: f_7,
      currency: f_8,
      currency_sign: f_9,
      display_price: f_10,
      payload: f_11,
      channel_id: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinHistory");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.pay_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("payDate", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.coin_balance {
      o_prot.write_field_begin(&TFieldIdentifier::new("coinBalance", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.coin {
      o_prot.write_field_begin(&TFieldIdentifier::new("coin", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.price {
      o_prot.write_field_begin(&TFieldIdentifier::new("price", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.refund {
      o_prot.write_field_begin(&TFieldIdentifier::new("refund", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.pay_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("paySeq", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.currency {
      o_prot.write_field_begin(&TFieldIdentifier::new("currency", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.currency_sign {
      o_prot.write_field_begin(&TFieldIdentifier::new("currencySign", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_price {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayPrice", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.payload {
      o_prot.write_field_begin(&TFieldIdentifier::new("payload", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.channel_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinHistory {
  fn default() -> Self {
    CoinHistory{
      pay_date: Some(0),
      coin_balance: Some(0),
      coin: Some(0),
      price: Some("".to_owned()),
      title: Some("".to_owned()),
      refund: Some(false),
      pay_seq: Some("".to_owned()),
      currency: Some("".to_owned()),
      currency_sign: Some("".to_owned()),
      display_price: Some("".to_owned()),
      payload: None,
      channel_id: Some("".to_owned()),
    }
  }
}

//
// CoinHistoryCondition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinHistoryCondition {
  pub start: Option<i64>,
  pub size: Option<i32>,
  pub language: Option<String>,
  pub eddt: Option<String>,
  pub app_store_code: Option<PaymentType>,
}

impl CoinHistoryCondition {
  pub fn new<F1, F2, F3, F4, F5>(start: F1, size: F2, language: F3, eddt: F4, app_store_code: F5) -> CoinHistoryCondition where F1: Into<Option<i64>>, F2: Into<Option<i32>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<PaymentType>> {
    CoinHistoryCondition {
      start: start.into(),
      size: size.into(),
      language: language.into(),
      eddt: eddt.into(),
      app_store_code: app_store_code.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinHistoryCondition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<PaymentType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinHistoryCondition {
      start: f_1,
      size: f_2,
      language: f_3,
      eddt: f_4,
      app_store_code: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinHistoryCondition");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.start {
      o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.size {
      o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.language {
      o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.eddt {
      o_prot.write_field_begin(&TFieldIdentifier::new("eddt", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.app_store_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinHistoryCondition {
  fn default() -> Self {
    CoinHistoryCondition{
      start: Some(0),
      size: Some(0),
      language: Some("".to_owned()),
      eddt: Some("".to_owned()),
      app_store_code: None,
    }
  }
}

//
// CoinHistoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinHistoryResult {
  pub historys: Option<Vec<CoinHistory>>,
  pub balance: Option<Coin>,
  pub has_next: Option<bool>,
}

impl CoinHistoryResult {
  pub fn new<F1, F2, F3>(historys: F1, balance: F2, has_next: F3) -> CoinHistoryResult where F1: Into<Option<Vec<CoinHistory>>>, F2: Into<Option<Coin>>, F3: Into<Option<bool>> {
    CoinHistoryResult {
      historys: historys.into(),
      balance: balance.into(),
      has_next: has_next.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinHistoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<CoinHistory>> = Some(Vec::new());
    let mut f_2: Option<Coin> = None;
    let mut f_3: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CoinHistory> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = CoinHistory::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Coin::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinHistoryResult {
      historys: f_1,
      balance: f_2,
      has_next: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinHistoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.historys {
      o_prot.write_field_begin(&TFieldIdentifier::new("historys", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.balance {
      o_prot.write_field_begin(&TFieldIdentifier::new("balance", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_next {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasNext", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinHistoryResult {
  fn default() -> Self {
    CoinHistoryResult{
      historys: Some(Vec::new()),
      balance: None,
      has_next: Some(false),
    }
  }
}

//
// CoinProductItem
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinProductItem {
  pub item_id: Option<String>,
  pub coin: Option<i32>,
  pub free_coin: Option<i32>,
  pub currency: Option<String>,
  pub price: Option<String>,
  pub display_price: Option<String>,
  pub name: Option<String>,
  pub desc: Option<String>,
}

impl CoinProductItem {
  pub fn new<F1, F2, F3, F5, F6, F7, F8, F9>(item_id: F1, coin: F2, free_coin: F3, currency: F5, price: F6, display_price: F7, name: F8, desc: F9) -> CoinProductItem where F1: Into<Option<String>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>> {
    CoinProductItem {
      item_id: item_id.into(),
      coin: coin.into(),
      free_coin: free_coin.into(),
      currency: currency.into(),
      price: price.into(),
      display_price: display_price.into(),
      name: name.into(),
      desc: desc.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinProductItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinProductItem {
      item_id: f_1,
      coin: f_2,
      free_coin: f_3,
      currency: f_5,
      price: f_6,
      display_price: f_7,
      name: f_8,
      desc: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinProductItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.item_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("itemId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.coin {
      o_prot.write_field_begin(&TFieldIdentifier::new("coin", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.free_coin {
      o_prot.write_field_begin(&TFieldIdentifier::new("freeCoin", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.currency {
      o_prot.write_field_begin(&TFieldIdentifier::new("currency", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.price {
      o_prot.write_field_begin(&TFieldIdentifier::new("price", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_price {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayPrice", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("desc", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinProductItem {
  fn default() -> Self {
    CoinProductItem{
      item_id: Some("".to_owned()),
      coin: Some(0),
      free_coin: Some(0),
      currency: Some("".to_owned()),
      price: Some("".to_owned()),
      display_price: Some("".to_owned()),
      name: Some("".to_owned()),
      desc: Some("".to_owned()),
    }
  }
}

//
// CoinPurchaseConfirm
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinPurchaseConfirm {
  pub order_id: Option<String>,
  pub app_store_code: Option<PaymentType>,
  pub receipt: Option<String>,
  pub signature: Option<String>,
  pub seller: Option<String>,
  pub request_type: Option<String>,
  pub ignore_receipt: Option<bool>,
}

impl CoinPurchaseConfirm {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(order_id: F1, app_store_code: F2, receipt: F3, signature: F4, seller: F5, request_type: F6, ignore_receipt: F7) -> CoinPurchaseConfirm where F1: Into<Option<String>>, F2: Into<Option<PaymentType>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<bool>> {
    CoinPurchaseConfirm {
      order_id: order_id.into(),
      app_store_code: app_store_code.into(),
      receipt: receipt.into(),
      signature: signature.into(),
      seller: seller.into(),
      request_type: request_type.into(),
      ignore_receipt: ignore_receipt.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinPurchaseConfirm> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<PaymentType> = None;
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinPurchaseConfirm {
      order_id: f_1,
      app_store_code: f_2,
      receipt: f_3,
      signature: f_4,
      seller: f_5,
      request_type: f_6,
      ignore_receipt: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinPurchaseConfirm");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.order_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("orderId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.app_store_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.receipt {
      o_prot.write_field_begin(&TFieldIdentifier::new("receipt", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.signature {
      o_prot.write_field_begin(&TFieldIdentifier::new("signature", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.seller {
      o_prot.write_field_begin(&TFieldIdentifier::new("seller", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.request_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestType", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ignore_receipt {
      o_prot.write_field_begin(&TFieldIdentifier::new("ignoreReceipt", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinPurchaseConfirm {
  fn default() -> Self {
    CoinPurchaseConfirm{
      order_id: Some("".to_owned()),
      app_store_code: None,
      receipt: Some("".to_owned()),
      signature: Some("".to_owned()),
      seller: Some("".to_owned()),
      request_type: Some("".to_owned()),
      ignore_receipt: Some(false),
    }
  }
}

//
// CoinPurchaseReservation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinPurchaseReservation {
  pub product_id: Option<String>,
  pub country: Option<String>,
  pub currency: Option<String>,
  pub price: Option<String>,
  pub app_store_code: Option<PaymentType>,
  pub language: Option<String>,
  pub pg_code: Option<PaymentPgType>,
  pub redirect_url: Option<String>,
}

impl CoinPurchaseReservation {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(product_id: F1, country: F2, currency: F3, price: F4, app_store_code: F5, language: F6, pg_code: F7, redirect_url: F8) -> CoinPurchaseReservation where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<PaymentType>>, F6: Into<Option<String>>, F7: Into<Option<PaymentPgType>>, F8: Into<Option<String>> {
    CoinPurchaseReservation {
      product_id: product_id.into(),
      country: country.into(),
      currency: currency.into(),
      price: price.into(),
      app_store_code: app_store_code.into(),
      language: language.into(),
      pg_code: pg_code.into(),
      redirect_url: redirect_url.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinPurchaseReservation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<PaymentType> = None;
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<PaymentPgType> = None;
    let mut f_8: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = PaymentPgType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinPurchaseReservation {
      product_id: f_1,
      country: f_2,
      currency: f_3,
      price: f_4,
      app_store_code: f_5,
      language: f_6,
      pg_code: f_7,
      redirect_url: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinPurchaseReservation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.product_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.country {
      o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.currency {
      o_prot.write_field_begin(&TFieldIdentifier::new("currency", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.price {
      o_prot.write_field_begin(&TFieldIdentifier::new("price", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.app_store_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.language {
      o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.pg_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("pgCode", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.redirect_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("redirectUrl", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinPurchaseReservation {
  fn default() -> Self {
    CoinPurchaseReservation{
      product_id: Some("".to_owned()),
      country: Some("".to_owned()),
      currency: Some("".to_owned()),
      price: Some("".to_owned()),
      app_store_code: None,
      language: Some("".to_owned()),
      pg_code: None,
      redirect_url: Some("".to_owned()),
    }
  }
}

//
// CoinUseReservationItem
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinUseReservationItem {
  pub item_id: Option<String>,
  pub item_name: Option<String>,
  pub amount: Option<i32>,
}

impl CoinUseReservationItem {
  pub fn new<F1, F2, F3>(item_id: F1, item_name: F2, amount: F3) -> CoinUseReservationItem where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>> {
    CoinUseReservationItem {
      item_id: item_id.into(),
      item_name: item_name.into(),
      amount: amount.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinUseReservationItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinUseReservationItem {
      item_id: f_1,
      item_name: f_2,
      amount: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinUseReservationItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.item_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("itemId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.item_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("itemName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.amount {
      o_prot.write_field_begin(&TFieldIdentifier::new("amount", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinUseReservationItem {
  fn default() -> Self {
    CoinUseReservationItem{
      item_id: Some("".to_owned()),
      item_name: Some("".to_owned()),
      amount: Some(0),
    }
  }
}

//
// CoinUseReservation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CoinUseReservation {
  pub channel_id: Option<String>,
  pub shop_order_id: Option<String>,
  pub app_store_code: Option<PaymentType>,
  pub items: Option<Vec<CoinUseReservationItem>>,
  pub country: Option<String>,
}

impl CoinUseReservation {
  pub fn new<F1, F2, F3, F4, F5>(channel_id: F1, shop_order_id: F2, app_store_code: F3, items: F4, country: F5) -> CoinUseReservation where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<PaymentType>>, F4: Into<Option<Vec<CoinUseReservationItem>>>, F5: Into<Option<String>> {
    CoinUseReservation {
      channel_id: channel_id.into(),
      shop_order_id: shop_order_id.into(),
      app_store_code: app_store_code.into(),
      items: items.into(),
      country: country.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CoinUseReservation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<PaymentType> = None;
    let mut f_4: Option<Vec<CoinUseReservationItem>> = Some(Vec::new());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CoinUseReservationItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = CoinUseReservationItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CoinUseReservation {
      channel_id: f_1,
      shop_order_id: f_2,
      app_store_code: f_3,
      items: f_4,
      country: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CoinUseReservation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.shop_order_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("shopOrderId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.app_store_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.items {
      o_prot.write_field_begin(&TFieldIdentifier::new("items", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.country {
      o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CoinUseReservation {
  fn default() -> Self {
    CoinUseReservation{
      channel_id: Some("".to_owned()),
      shop_order_id: Some("".to_owned()),
      app_store_code: None,
      items: Some(Vec::new()),
      country: Some("".to_owned()),
    }
  }
}

//
// CompactContact
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompactContact {
  pub mid: Option<String>,
  pub created_time: Option<i64>,
  pub modified_time: Option<i64>,
  pub status: Option<ContactStatus>,
  pub settings: Option<i64>,
  pub display_name_overridden: Option<String>,
}

impl CompactContact {
  pub fn new<F1, F2, F3, F4, F5, F6>(mid: F1, created_time: F2, modified_time: F3, status: F4, settings: F5, display_name_overridden: F6) -> CompactContact where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<ContactStatus>>, F5: Into<Option<i64>>, F6: Into<Option<String>> {
    CompactContact {
      mid: mid.into(),
      created_time: created_time.into(),
      modified_time: modified_time.into(),
      status: status.into(),
      settings: settings.into(),
      display_name_overridden: display_name_overridden.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompactContact> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<ContactStatus> = None;
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = ContactStatus::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CompactContact {
      mid: f_1,
      created_time: f_2,
      modified_time: f_3,
      status: f_4,
      settings: f_5,
      display_name_overridden: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CompactContact");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.modified_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("modifiedTime", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.settings {
      o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name_overridden {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayNameOverridden", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CompactContact {
  fn default() -> Self {
    CompactContact{
      mid: Some("".to_owned()),
      created_time: Some(0),
      modified_time: Some(0),
      status: None,
      settings: Some(0),
      display_name_overridden: Some("".to_owned()),
    }
  }
}

//
// ContactModification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ContactModification {
  pub type_: Option<ModificationType>,
  pub luid: Option<String>,
  pub phones: Option<Vec<String>>,
  pub emails: Option<Vec<String>>,
  pub userids: Option<Vec<String>>,
}

impl ContactModification {
  pub fn new<F1, F2, F11, F12, F13>(type_: F1, luid: F2, phones: F11, emails: F12, userids: F13) -> ContactModification where F1: Into<Option<ModificationType>>, F2: Into<Option<String>>, F11: Into<Option<Vec<String>>>, F12: Into<Option<Vec<String>>>, F13: Into<Option<Vec<String>>> {
    ContactModification {
      type_: type_.into(),
      luid: luid.into(),
      phones: phones.into(),
      emails: emails.into(),
      userids: userids.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactModification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ModificationType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_11: Option<Vec<String>> = Some(Vec::new());
    let mut f_12: Option<Vec<String>> = Some(Vec::new());
    let mut f_13: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ModificationType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = i_prot.read_string()?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        13 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = i_prot.read_string()?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ContactModification {
      type_: f_1,
      luid: f_2,
      phones: f_11,
      emails: f_12,
      userids: f_13,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ContactModification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.luid {
      o_prot.write_field_begin(&TFieldIdentifier::new("luid", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.phones {
      o_prot.write_field_begin(&TFieldIdentifier::new("phones", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.emails {
      o_prot.write_field_begin(&TFieldIdentifier::new("emails", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.userids {
      o_prot.write_field_begin(&TFieldIdentifier::new("userids", TType::List, 13))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ContactModification {
  fn default() -> Self {
    ContactModification{
      type_: None,
      luid: Some("".to_owned()),
      phones: Some(Vec::new()),
      emails: Some(Vec::new()),
      userids: Some(Vec::new()),
    }
  }
}

//
// ContactRegistration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ContactRegistration {
  pub contact: Option<Contact>,
  pub luid: Option<String>,
  pub contact_type: Option<ContactType>,
  pub contact_key: Option<String>,
}

impl ContactRegistration {
  pub fn new<F1, F10, F11, F12>(contact: F1, luid: F10, contact_type: F11, contact_key: F12) -> ContactRegistration where F1: Into<Option<Contact>>, F10: Into<Option<String>>, F11: Into<Option<ContactType>>, F12: Into<Option<String>> {
    ContactRegistration {
      contact: contact.into(),
      luid: luid.into(),
      contact_type: contact_type.into(),
      contact_key: contact_key.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactRegistration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Contact> = None;
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<ContactType> = None;
    let mut f_12: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = ContactType::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ContactRegistration {
      contact: f_1,
      luid: f_10,
      contact_type: f_11,
      contact_key: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ContactRegistration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.contact {
      o_prot.write_field_begin(&TFieldIdentifier::new("contact", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.luid {
      o_prot.write_field_begin(&TFieldIdentifier::new("luid", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contact_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("contactType", TType::I32, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contact_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("contactKey", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ContactRegistration {
  fn default() -> Self {
    ContactRegistration{
      contact: None,
      luid: Some("".to_owned()),
      contact_type: None,
      contact_key: Some("".to_owned()),
    }
  }
}

//
// ContactReport
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ContactReport {
  pub mid: Option<String>,
  pub exists: Option<bool>,
  pub contact: Option<Contact>,
}

impl ContactReport {
  pub fn new<F1, F2, F3>(mid: F1, exists: F2, contact: F3) -> ContactReport where F1: Into<Option<String>>, F2: Into<Option<bool>>, F3: Into<Option<Contact>> {
    ContactReport {
      mid: mid.into(),
      exists: exists.into(),
      contact: contact.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactReport> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<Contact> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ContactReport {
      mid: f_1,
      exists: f_2,
      contact: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ContactReport");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.exists {
      o_prot.write_field_begin(&TFieldIdentifier::new("exists", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contact {
      o_prot.write_field_begin(&TFieldIdentifier::new("contact", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ContactReport {
  fn default() -> Self {
    ContactReport{
      mid: Some("".to_owned()),
      exists: Some(false),
      contact: None,
    }
  }
}

//
// ContactReportResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ContactReportResult {
  pub mid: Option<String>,
  pub exists: Option<bool>,
}

impl ContactReportResult {
  pub fn new<F1, F2>(mid: F1, exists: F2) -> ContactReportResult where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    ContactReportResult {
      mid: mid.into(),
      exists: exists.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactReportResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ContactReportResult {
      mid: f_1,
      exists: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ContactReportResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.exists {
      o_prot.write_field_begin(&TFieldIdentifier::new("exists", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ContactReportResult {
  fn default() -> Self {
    ContactReportResult{
      mid: Some("".to_owned()),
      exists: Some(false),
    }
  }
}

//
// DeviceInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DeviceInfo {
  pub device_name: Option<String>,
  pub system_name: Option<String>,
  pub system_version: Option<String>,
  pub model: Option<String>,
  pub carrier_code: Option<CarrierCode>,
  pub carrier_name: Option<String>,
  pub application_type: Option<ApplicationType>,
}

impl DeviceInfo {
  pub fn new<F1, F2, F3, F4, F10, F11, F20>(device_name: F1, system_name: F2, system_version: F3, model: F4, carrier_code: F10, carrier_name: F11, application_type: F20) -> DeviceInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F10: Into<Option<CarrierCode>>, F11: Into<Option<String>>, F20: Into<Option<ApplicationType>> {
    DeviceInfo {
      device_name: device_name.into(),
      system_name: system_name.into(),
      system_version: system_version.into(),
      model: model.into(),
      carrier_code: carrier_code.into(),
      carrier_name: carrier_name.into(),
      application_type: application_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DeviceInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_10: Option<CarrierCode> = None;
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_20: Option<ApplicationType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        10 => {
          let val = CarrierCode::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        20 => {
          let val = ApplicationType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DeviceInfo {
      device_name: f_1,
      system_name: f_2,
      system_version: f_3,
      model: f_4,
      carrier_code: f_10,
      carrier_name: f_11,
      application_type: f_20,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DeviceInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.system_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.system_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemVersion", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.model {
      o_prot.write_field_begin(&TFieldIdentifier::new("model", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.carrier_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("carrierCode", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.carrier_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("carrierName", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.application_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationType", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for DeviceInfo {
  fn default() -> Self {
    DeviceInfo{
      device_name: Some("".to_owned()),
      system_name: Some("".to_owned()),
      system_version: Some("".to_owned()),
      model: Some("".to_owned()),
      carrier_code: None,
      carrier_name: Some("".to_owned()),
      application_type: None,
    }
  }
}

//
// EmailConfirmation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EmailConfirmation {
  pub use_password_set: Option<bool>,
  pub email: Option<String>,
  pub password: Option<String>,
  pub ignore_duplication: Option<bool>,
}

impl EmailConfirmation {
  pub fn new<F1, F2, F3, F4>(use_password_set: F1, email: F2, password: F3, ignore_duplication: F4) -> EmailConfirmation where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<bool>> {
    EmailConfirmation {
      use_password_set: use_password_set.into(),
      email: email.into(),
      password: password.into(),
      ignore_duplication: ignore_duplication.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EmailConfirmation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EmailConfirmation {
      use_password_set: f_1,
      email: f_2,
      password: f_3,
      ignore_duplication: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EmailConfirmation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.use_password_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("usePasswordSet", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.password {
      o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ignore_duplication {
      o_prot.write_field_begin(&TFieldIdentifier::new("ignoreDuplication", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for EmailConfirmation {
  fn default() -> Self {
    EmailConfirmation{
      use_password_set: Some(false),
      email: Some("".to_owned()),
      password: Some("".to_owned()),
      ignore_duplication: Some(false),
    }
  }
}

//
// EmailConfirmationSession
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EmailConfirmationSession {
  pub email_confirmation_type: Option<EmailConfirmationType>,
  pub verifier: Option<String>,
  pub target_email: Option<String>,
}

impl EmailConfirmationSession {
  pub fn new<F1, F2, F3>(email_confirmation_type: F1, verifier: F2, target_email: F3) -> EmailConfirmationSession where F1: Into<Option<EmailConfirmationType>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    EmailConfirmationSession {
      email_confirmation_type: email_confirmation_type.into(),
      verifier: verifier.into(),
      target_email: target_email.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EmailConfirmationSession> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<EmailConfirmationType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = EmailConfirmationType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EmailConfirmationSession {
      email_confirmation_type: f_1,
      verifier: f_2,
      target_email: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EmailConfirmationSession");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.email_confirmation_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("emailConfirmationType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.verifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.target_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetEmail", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for EmailConfirmationSession {
  fn default() -> Self {
    EmailConfirmationSession{
      email_confirmation_type: None,
      verifier: Some("".to_owned()),
      target_email: Some("".to_owned()),
    }
  }
}

//
// FriendChannelMatrix
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FriendChannelMatrix {
  pub channel_id: Option<String>,
  pub represent_mid: Option<String>,
  pub count: Option<i32>,
}

impl FriendChannelMatrix {
  pub fn new<F1, F2, F3>(channel_id: F1, represent_mid: F2, count: F3) -> FriendChannelMatrix where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>> {
    FriendChannelMatrix {
      channel_id: channel_id.into(),
      represent_mid: represent_mid.into(),
      count: count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FriendChannelMatrix> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FriendChannelMatrix {
      channel_id: f_1,
      represent_mid: f_2,
      count: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FriendChannelMatrix");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.channel_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.represent_mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("representMid", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.count {
      o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FriendChannelMatrix {
  fn default() -> Self {
    FriendChannelMatrix{
      channel_id: Some("".to_owned()),
      represent_mid: Some("".to_owned()),
      count: Some(0),
    }
  }
}

//
// FriendChannelMatricesResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FriendChannelMatricesResponse {
  pub expires: Option<i64>,
  pub matrices: Option<Vec<FriendChannelMatrix>>,
}

impl FriendChannelMatricesResponse {
  pub fn new<F1, F2>(expires: F1, matrices: F2) -> FriendChannelMatricesResponse where F1: Into<Option<i64>>, F2: Into<Option<Vec<FriendChannelMatrix>>> {
    FriendChannelMatricesResponse {
      expires: expires.into(),
      matrices: matrices.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FriendChannelMatricesResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<Vec<FriendChannelMatrix>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FriendChannelMatrix> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = FriendChannelMatrix::read_from_in_protocol(i_prot)?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FriendChannelMatricesResponse {
      expires: f_1,
      matrices: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FriendChannelMatricesResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.expires {
      o_prot.write_field_begin(&TFieldIdentifier::new("expires", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.matrices {
      o_prot.write_field_begin(&TFieldIdentifier::new("matrices", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FriendChannelMatricesResponse {
  fn default() -> Self {
    FriendChannelMatricesResponse{
      expires: Some(0),
      matrices: Some(Vec::new()),
    }
  }
}

//
// Geolocation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Geolocation {
  pub longitude: Option<OrderedFloat<f64>>,
  pub latitude: Option<OrderedFloat<f64>>,
}

impl Geolocation {
  pub fn new<F1, F2>(longitude: F1, latitude: F2) -> Geolocation where F1: Into<Option<OrderedFloat<f64>>>, F2: Into<Option<OrderedFloat<f64>>> {
    Geolocation {
      longitude: longitude.into(),
      latitude: latitude.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Geolocation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Geolocation {
      longitude: f_1,
      latitude: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Geolocation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.longitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("longitude", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.latitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("latitude", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Geolocation {
  fn default() -> Self {
    Geolocation{
      longitude: Some(OrderedFloat::from(0.0)),
      latitude: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// NotificationTarget
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationTarget {
  pub application_type: Option<String>,
  pub application_version: Option<String>,
  pub region: Option<String>,
}

impl NotificationTarget {
  pub fn new<F1, F2, F3>(application_type: F1, application_version: F2, region: F3) -> NotificationTarget where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    NotificationTarget {
      application_type: application_type.into(),
      application_version: application_version.into(),
      region: region.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationTarget> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotificationTarget {
      application_type: f_1,
      application_version: f_2,
      region: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationTarget");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.application_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationType", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.application_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationVersion", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.region {
      o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NotificationTarget {
  fn default() -> Self {
    NotificationTarget{
      application_type: Some("".to_owned()),
      application_version: Some("".to_owned()),
      region: Some("".to_owned()),
    }
  }
}

//
// GlobalEvent
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GlobalEvent {
  pub key: Option<String>,
  pub targets: Option<Vec<NotificationTarget>>,
  pub created_time: Option<i64>,
  pub data: Option<i64>,
  pub max_delay: Option<i32>,
}

impl GlobalEvent {
  pub fn new<F1, F2, F3, F4, F5>(key: F1, targets: F2, created_time: F3, data: F4, max_delay: F5) -> GlobalEvent where F1: Into<Option<String>>, F2: Into<Option<Vec<NotificationTarget>>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i32>> {
    GlobalEvent {
      key: key.into(),
      targets: targets.into(),
      created_time: created_time.into(),
      data: data.into(),
      max_delay: max_delay.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GlobalEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<NotificationTarget>> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NotificationTarget> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = NotificationTarget::read_from_in_protocol(i_prot)?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GlobalEvent {
      key: f_1,
      targets: f_2,
      created_time: f_3,
      data: f_4,
      max_delay: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.targets {
      o_prot.write_field_begin(&TFieldIdentifier::new("targets", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_delay {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxDelay", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GlobalEvent {
  fn default() -> Self {
    GlobalEvent{
      key: Some("".to_owned()),
      targets: Some(Vec::new()),
      created_time: Some(0),
      data: Some(0),
      max_delay: Some(0),
    }
  }
}

//
// Group
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Group {
  pub id: Option<String>,
  pub created_time: Option<i64>,
  pub name: Option<String>,
  pub picture_status: Option<String>,
  pub members: Option<Vec<Contact>>,
  pub creator: Option<Contact>,
  pub invitee: Option<Vec<Contact>>,
  pub notification_disabled: Option<bool>,
}

impl Group {
  pub fn new<F1, F2, F10, F11, F20, F21, F22, F31>(id: F1, created_time: F2, name: F10, picture_status: F11, members: F20, creator: F21, invitee: F22, notification_disabled: F31) -> Group where F1: Into<Option<String>>, F2: Into<Option<i64>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F20: Into<Option<Vec<Contact>>>, F21: Into<Option<Contact>>, F22: Into<Option<Vec<Contact>>>, F31: Into<Option<bool>> {
    Group {
      id: id.into(),
      created_time: created_time.into(),
      name: name.into(),
      picture_status: picture_status.into(),
      members: members.into(),
      creator: creator.into(),
      invitee: invitee.into(),
      notification_disabled: notification_disabled.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Group> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_20: Option<Vec<Contact>> = Some(Vec::new());
    let mut f_21: Option<Contact> = None;
    let mut f_22: Option<Vec<Contact>> = Some(Vec::new());
    let mut f_31: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        21 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_22 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Group {
      id: f_1,
      created_time: f_2,
      name: f_10,
      picture_status: f_11,
      members: f_20,
      creator: f_21,
      invitee: f_22,
      notification_disabled: f_31,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("pictureStatus", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.members {
      o_prot.write_field_begin(&TFieldIdentifier::new("members", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.creator {
      o_prot.write_field_begin(&TFieldIdentifier::new("creator", TType::Struct, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.invitee {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitee", TType::List, 22))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_disabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationDisabled", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Group {
  fn default() -> Self {
    Group{
      id: Some("".to_owned()),
      created_time: Some(0),
      name: Some("".to_owned()),
      picture_status: Some("".to_owned()),
      members: Some(Vec::new()),
      creator: None,
      invitee: Some(Vec::new()),
      notification_disabled: Some(false),
    }
  }
}

//
// IdentityCredential
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IdentityCredential {
  pub provider: Option<IdentityProvider>,
  pub identifier: Option<String>,
  pub password: Option<String>,
}

impl IdentityCredential {
  pub fn new<F1, F2, F3>(provider: F1, identifier: F2, password: F3) -> IdentityCredential where F1: Into<Option<IdentityProvider>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    IdentityCredential {
      provider: provider.into(),
      identifier: identifier.into(),
      password: password.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IdentityCredential> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<IdentityProvider> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IdentityCredential {
      provider: f_1,
      identifier: f_2,
      password: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IdentityCredential");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.provider {
      o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.identifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.password {
      o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for IdentityCredential {
  fn default() -> Self {
    IdentityCredential{
      provider: None,
      identifier: Some("".to_owned()),
      password: Some("".to_owned()),
    }
  }
}

//
// LastReadMessageId
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LastReadMessageId {
  pub mid: Option<String>,
  pub last_read_message_id: Option<String>,
}

impl LastReadMessageId {
  pub fn new<F1, F2>(mid: F1, last_read_message_id: F2) -> LastReadMessageId where F1: Into<Option<String>>, F2: Into<Option<String>> {
    LastReadMessageId {
      mid: mid.into(),
      last_read_message_id: last_read_message_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LastReadMessageId> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LastReadMessageId {
      mid: f_1,
      last_read_message_id: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LastReadMessageId");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.last_read_message_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastReadMessageId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for LastReadMessageId {
  fn default() -> Self {
    LastReadMessageId{
      mid: Some("".to_owned()),
      last_read_message_id: Some("".to_owned()),
    }
  }
}

//
// LastReadMessageIds
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LastReadMessageIds {
  pub chat_id: Option<String>,
  pub last_read_message_ids: Option<Vec<LastReadMessageId>>,
}

impl LastReadMessageIds {
  pub fn new<F1, F2>(chat_id: F1, last_read_message_ids: F2) -> LastReadMessageIds where F1: Into<Option<String>>, F2: Into<Option<Vec<LastReadMessageId>>> {
    LastReadMessageIds {
      chat_id: chat_id.into(),
      last_read_message_ids: last_read_message_ids.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LastReadMessageIds> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<LastReadMessageId>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<LastReadMessageId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = LastReadMessageId::read_from_in_protocol(i_prot)?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LastReadMessageIds {
      chat_id: f_1,
      last_read_message_ids: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LastReadMessageIds");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.chat_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("chatId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.last_read_message_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastReadMessageIds", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for LastReadMessageIds {
  fn default() -> Self {
    LastReadMessageIds{
      chat_id: Some("".to_owned()),
      last_read_message_ids: Some(Vec::new()),
    }
  }
}

//
// LoginResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LoginResult {
  pub auth_token: Option<String>,
  pub certificate: Option<String>,
  pub verifier: Option<String>,
  pub pin_code: Option<String>,
  pub type_: Option<LoginResultType>,
}

impl LoginResult {
  pub fn new<F1, F2, F3, F4, F5>(auth_token: F1, certificate: F2, verifier: F3, pin_code: F4, type_: F5) -> LoginResult where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<LoginResultType>> {
    LoginResult {
      auth_token: auth_token.into(),
      certificate: certificate.into(),
      verifier: verifier.into(),
      pin_code: pin_code.into(),
      type_: type_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LoginResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<LoginResultType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = LoginResultType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LoginResult {
      auth_token: f_1,
      certificate: f_2,
      verifier: f_3,
      pin_code: f_4,
      type_: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LoginResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.auth_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("authToken", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.certificate {
      o_prot.write_field_begin(&TFieldIdentifier::new("certificate", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.verifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.pin_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("pinCode", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for LoginResult {
  fn default() -> Self {
    LoginResult{
      auth_token: Some("".to_owned()),
      certificate: Some("".to_owned()),
      verifier: Some("".to_owned()),
      pin_code: Some("".to_owned()),
      type_: None,
    }
  }
}

//
// LoginSession
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LoginSession {
  pub token_key: Option<String>,
  pub expiration_time: Option<i64>,
  pub application_type: Option<ApplicationType>,
  pub system_name: Option<String>,
  pub access_location: Option<String>,
}

impl LoginSession {
  pub fn new<F1, F3, F11, F12, F22>(token_key: F1, expiration_time: F3, application_type: F11, system_name: F12, access_location: F22) -> LoginSession where F1: Into<Option<String>>, F3: Into<Option<i64>>, F11: Into<Option<ApplicationType>>, F12: Into<Option<String>>, F22: Into<Option<String>> {
    LoginSession {
      token_key: token_key.into(),
      expiration_time: expiration_time.into(),
      application_type: application_type.into(),
      system_name: system_name.into(),
      access_location: access_location.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LoginSession> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_11: Option<ApplicationType> = None;
    let mut f_12: Option<String> = Some("".to_owned());
    let mut f_22: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        11 => {
          let val = ApplicationType::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LoginSession {
      token_key: f_1,
      expiration_time: f_3,
      application_type: f_11,
      system_name: f_12,
      access_location: f_22,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LoginSession");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.token_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("tokenKey", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.expiration_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("expirationTime", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.application_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationType", TType::I32, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.system_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemName", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.access_location {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessLocation", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for LoginSession {
  fn default() -> Self {
    LoginSession{
      token_key: Some("".to_owned()),
      expiration_time: Some(0),
      application_type: None,
      system_name: Some("".to_owned()),
      access_location: Some("".to_owned()),
    }
  }
}

//
// Message
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Message {
  pub from_: Option<String>,
  pub to: Option<String>,
  pub to_type: Option<MIDType>,
  pub id: Option<String>,
  pub created_time: Option<i64>,
  pub delivered_time: Option<i64>,
  pub text: Option<String>,
  pub location: Option<Location>,
  pub has_content: Option<bool>,
  pub content_type: Option<ContentType>,
  pub content_preview: Option<Vec<u8>>,
  pub content_metadata: Option<BTreeMap<String, String>>,
}

impl Message {
  pub fn new<F1, F2, F3, F4, F5, F6, F10, F11, F14, F15, F17, F18>(from_: F1, to: F2, to_type: F3, id: F4, created_time: F5, delivered_time: F6, text: F10, location: F11, has_content: F14, content_type: F15, content_preview: F17, content_metadata: F18) -> Message where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<MIDType>>, F4: Into<Option<String>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F10: Into<Option<String>>, F11: Into<Option<Location>>, F14: Into<Option<bool>>, F15: Into<Option<ContentType>>, F17: Into<Option<Vec<u8>>>, F18: Into<Option<BTreeMap<String, String>>> {
    Message {
      from_: from_.into(),
      to: to.into(),
      to_type: to_type.into(),
      id: id.into(),
      created_time: created_time.into(),
      delivered_time: delivered_time.into(),
      text: text.into(),
      location: location.into(),
      has_content: has_content.into(),
      content_type: content_type.into(),
      content_preview: content_preview.into(),
      content_metadata: content_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Message> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<MIDType> = None;
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<Location> = None;
    let mut f_14: Option<bool> = Some(false);
    let mut f_15: Option<ContentType> = None;
    let mut f_17: Option<Vec<u8>> = Some(Vec::new());
    let mut f_18: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = MIDType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = Location::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = ContentType::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        17 => {
          let val = i_prot.read_bytes()?;
          f_17 = Some(val);
        },
        18 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_27 = i_prot.read_string()?;
            let map_val_28 = i_prot.read_string()?;
            val.insert(map_key_27, map_val_28);
          }
          i_prot.read_map_end()?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Message {
      from_: f_1,
      to: f_2,
      to_type: f_3,
      id: f_4,
      created_time: f_5,
      delivered_time: f_6,
      text: f_10,
      location: f_11,
      has_content: f_14,
      content_type: f_15,
      content_preview: f_17,
      content_metadata: f_18,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Message");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.from_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("from_", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.to {
      o_prot.write_field_begin(&TFieldIdentifier::new("to", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.to_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("toType", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delivered_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("deliveredTime", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.text {
      o_prot.write_field_begin(&TFieldIdentifier::new("text", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.location {
      o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_content {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasContent", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentType", TType::I32, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content_preview {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentPreview", TType::String, 17))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentMetadata", TType::Map, 18))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Message {
  fn default() -> Self {
    Message{
      from_: Some("".to_owned()),
      to: Some("".to_owned()),
      to_type: None,
      id: Some("".to_owned()),
      created_time: Some(0),
      delivered_time: Some(0),
      text: Some("".to_owned()),
      location: None,
      has_content: Some(false),
      content_type: None,
      content_preview: Some(Vec::new()),
      content_metadata: Some(BTreeMap::new()),
    }
  }
}

//
// MessageOperation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MessageOperation {
  pub revision: Option<i64>,
  pub created_time: Option<i64>,
  pub type_: Option<MessageOperationType>,
  pub req_seq: Option<i32>,
  pub status: Option<OpStatus>,
  pub param1: Option<String>,
  pub param2: Option<String>,
  pub param3: Option<String>,
  pub message: Option<Message>,
}

impl MessageOperation {
  pub fn new<F1, F2, F3, F4, F5, F10, F11, F12, F20>(revision: F1, created_time: F2, type_: F3, req_seq: F4, status: F5, param1: F10, param2: F11, param3: F12, message: F20) -> MessageOperation where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<MessageOperationType>>, F4: Into<Option<i32>>, F5: Into<Option<OpStatus>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<String>>, F20: Into<Option<Message>> {
    MessageOperation {
      revision: revision.into(),
      created_time: created_time.into(),
      type_: type_.into(),
      req_seq: req_seq.into(),
      status: status.into(),
      param1: param1.into(),
      param2: param2.into(),
      param3: param3.into(),
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageOperation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<MessageOperationType> = None;
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<OpStatus> = None;
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    let mut f_20: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = MessageOperationType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = OpStatus::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        20 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MessageOperation {
      revision: f_1,
      created_time: f_2,
      type_: f_3,
      req_seq: f_4,
      status: f_5,
      param1: f_10,
      param2: f_11,
      param3: f_12,
      message: f_20,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MessageOperation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.req_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.param1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("param1", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.param2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("param2", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.param3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("param3", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MessageOperation {
  fn default() -> Self {
    MessageOperation{
      revision: Some(0),
      created_time: Some(0),
      type_: None,
      req_seq: Some(0),
      status: None,
      param1: Some("".to_owned()),
      param2: Some("".to_owned()),
      param3: Some("".to_owned()),
      message: None,
    }
  }
}

//
// MessageOperations
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MessageOperations {
  pub operations: Option<Vec<MessageOperation>>,
  pub end_flag: Option<bool>,
}

impl MessageOperations {
  pub fn new<F1, F2>(operations: F1, end_flag: F2) -> MessageOperations where F1: Into<Option<Vec<MessageOperation>>>, F2: Into<Option<bool>> {
    MessageOperations {
      operations: operations.into(),
      end_flag: end_flag.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageOperations> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<MessageOperation>> = Some(Vec::new());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<MessageOperation> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = MessageOperation::read_from_in_protocol(i_prot)?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MessageOperations {
      operations: f_1,
      end_flag: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MessageOperations");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.operations {
      o_prot.write_field_begin(&TFieldIdentifier::new("operations", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.end_flag {
      o_prot.write_field_begin(&TFieldIdentifier::new("endFlag", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MessageOperations {
  fn default() -> Self {
    MessageOperations{
      operations: Some(Vec::new()),
      end_flag: Some(false),
    }
  }
}

//
// MetaProfile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MetaProfile {
  pub create_time: Option<i64>,
  pub region_code: Option<String>,
  pub identities: Option<BTreeMap<RegistrationType, String>>,
}

impl MetaProfile {
  pub fn new<F1, F2, F3>(create_time: F1, region_code: F2, identities: F3) -> MetaProfile where F1: Into<Option<i64>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<RegistrationType, String>>> {
    MetaProfile {
      create_time: create_time.into(),
      region_code: region_code.into(),
      identities: identities.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MetaProfile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<BTreeMap<RegistrationType, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<RegistrationType, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_30 = RegistrationType::read_from_in_protocol(i_prot)?;
            let map_val_31 = i_prot.read_string()?;
            val.insert(map_key_30, map_val_31);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MetaProfile {
      create_time: f_1,
      region_code: f_2,
      identities: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MetaProfile");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.region_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("regionCode", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.identities {
      o_prot.write_field_begin(&TFieldIdentifier::new("identities", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        k.write_to_out_protocol(o_prot)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MetaProfile {
  fn default() -> Self {
    MetaProfile{
      create_time: Some(0),
      region_code: Some("".to_owned()),
      identities: Some(BTreeMap::new()),
    }
  }
}

//
// NotificationItem
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationItem {
  pub id: Option<String>,
  pub from_: Option<String>,
  pub to: Option<String>,
  pub from_channel: Option<String>,
  pub to_channel: Option<String>,
  pub revision: Option<i64>,
  pub created_time: Option<i64>,
  pub content: Option<BTreeMap<String, String>>,
}

impl NotificationItem {
  pub fn new<F1, F2, F3, F4, F5, F7, F8, F9>(id: F1, from_: F2, to: F3, from_channel: F4, to_channel: F5, revision: F7, created_time: F8, content: F9) -> NotificationItem where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<BTreeMap<String, String>>> {
    NotificationItem {
      id: id.into(),
      from_: from_.into(),
      to: to.into(),
      from_channel: from_channel.into(),
      to_channel: to_channel.into(),
      revision: revision.into(),
      created_time: created_time.into(),
      content: content.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<i64> = Some(0);
    let mut f_9: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_32 = i_prot.read_string()?;
            let map_val_33 = i_prot.read_string()?;
            val.insert(map_key_32, map_val_33);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotificationItem {
      id: f_1,
      from_: f_2,
      to: f_3,
      from_channel: f_4,
      to_channel: f_5,
      revision: f_7,
      created_time: f_8,
      content: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.from_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("from_", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.to {
      o_prot.write_field_begin(&TFieldIdentifier::new("to", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.from_channel {
      o_prot.write_field_begin(&TFieldIdentifier::new("fromChannel", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.to_channel {
      o_prot.write_field_begin(&TFieldIdentifier::new("toChannel", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content {
      o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NotificationItem {
  fn default() -> Self {
    NotificationItem{
      id: Some("".to_owned()),
      from_: Some("".to_owned()),
      to: Some("".to_owned()),
      from_channel: Some("".to_owned()),
      to_channel: Some("".to_owned()),
      revision: Some(0),
      created_time: Some(0),
      content: Some(BTreeMap::new()),
    }
  }
}

//
// NotificationFetchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationFetchResult {
  pub fetch_mode: Option<NotificationItemFetchMode>,
  pub item_list: Option<Vec<NotificationItem>>,
}

impl NotificationFetchResult {
  pub fn new<F1, F2>(fetch_mode: F1, item_list: F2) -> NotificationFetchResult where F1: Into<Option<NotificationItemFetchMode>>, F2: Into<Option<Vec<NotificationItem>>> {
    NotificationFetchResult {
      fetch_mode: fetch_mode.into(),
      item_list: item_list.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationFetchResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NotificationItemFetchMode> = None;
    let mut f_2: Option<Vec<NotificationItem>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NotificationItemFetchMode::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NotificationItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_34 = NotificationItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_34);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotificationFetchResult {
      fetch_mode: f_1,
      item_list: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationFetchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.fetch_mode {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchMode", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.item_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("itemList", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NotificationFetchResult {
  fn default() -> Self {
    NotificationFetchResult{
      fetch_mode: None,
      item_list: Some(Vec::new()),
    }
  }
}

//
// Operation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Operation {
  pub revision: Option<i64>,
  pub created_time: Option<i64>,
  pub type_: Option<OpType>,
  pub req_seq: Option<i32>,
  pub checksum: Option<String>,
  pub status: Option<OpStatus>,
  pub param1: Option<String>,
  pub param2: Option<String>,
  pub param3: Option<String>,
  pub message: Option<Message>,
}

impl Operation {
  pub fn new<F1, F2, F3, F4, F5, F7, F10, F11, F12, F20>(revision: F1, created_time: F2, type_: F3, req_seq: F4, checksum: F5, status: F7, param1: F10, param2: F11, param3: F12, message: F20) -> Operation where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<OpType>>, F4: Into<Option<i32>>, F5: Into<Option<String>>, F7: Into<Option<OpStatus>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<String>>, F20: Into<Option<Message>> {
    Operation {
      revision: revision.into(),
      created_time: created_time.into(),
      type_: type_.into(),
      req_seq: req_seq.into(),
      checksum: checksum.into(),
      status: status.into(),
      param1: param1.into(),
      param2: param2.into(),
      param3: param3.into(),
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Operation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<OpType> = None;
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_7: Option<OpStatus> = None;
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    let mut f_20: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OpType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        7 => {
          let val = OpStatus::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        20 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Operation {
      revision: f_1,
      created_time: f_2,
      type_: f_3,
      req_seq: f_4,
      checksum: f_5,
      status: f_7,
      param1: f_10,
      param2: f_11,
      param3: f_12,
      message: f_20,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Operation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.req_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("checksum", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.param1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("param1", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.param2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("param2", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.param3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("param3", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Operation {
  fn default() -> Self {
    Operation{
      revision: Some(0),
      created_time: Some(0),
      type_: None,
      req_seq: Some(0),
      checksum: Some("".to_owned()),
      status: None,
      param1: Some("".to_owned()),
      param2: Some("".to_owned()),
      param3: Some("".to_owned()),
      message: None,
    }
  }
}

//
// PaymentReservation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PaymentReservation {
  pub receiver_mid: Option<String>,
  pub product_id: Option<String>,
  pub language: Option<String>,
  pub location: Option<String>,
  pub currency: Option<String>,
  pub price: Option<String>,
  pub app_store_code: Option<PaymentType>,
  pub message_text: Option<String>,
  pub message_template: Option<i32>,
  pub package_id: Option<i64>,
}

impl PaymentReservation {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(receiver_mid: F1, product_id: F2, language: F3, location: F4, currency: F5, price: F6, app_store_code: F7, message_text: F8, message_template: F9, package_id: F10) -> PaymentReservation where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<PaymentType>>, F8: Into<Option<String>>, F9: Into<Option<i32>>, F10: Into<Option<i64>> {
    PaymentReservation {
      receiver_mid: receiver_mid.into(),
      product_id: product_id.into(),
      language: language.into(),
      location: location.into(),
      currency: currency.into(),
      price: price.into(),
      app_store_code: app_store_code.into(),
      message_text: message_text.into(),
      message_template: message_template.into(),
      package_id: package_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PaymentReservation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<PaymentType> = None;
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<i32> = Some(0);
    let mut f_10: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PaymentReservation {
      receiver_mid: f_1,
      product_id: f_2,
      language: f_3,
      location: f_4,
      currency: f_5,
      price: f_6,
      app_store_code: f_7,
      message_text: f_8,
      message_template: f_9,
      package_id: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PaymentReservation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.receiver_mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("receiverMid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.product_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.language {
      o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.location {
      o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.currency {
      o_prot.write_field_begin(&TFieldIdentifier::new("currency", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.price {
      o_prot.write_field_begin(&TFieldIdentifier::new("price", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.app_store_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message_text {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageText", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.message_template {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageTemplate", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.package_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("packageId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PaymentReservation {
  fn default() -> Self {
    PaymentReservation{
      receiver_mid: Some("".to_owned()),
      product_id: Some("".to_owned()),
      language: Some("".to_owned()),
      location: Some("".to_owned()),
      currency: Some("".to_owned()),
      price: Some("".to_owned()),
      app_store_code: None,
      message_text: Some("".to_owned()),
      message_template: Some(0),
      package_id: Some(0),
    }
  }
}

//
// PaymentReservationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PaymentReservationResult {
  pub order_id: Option<String>,
  pub confirm_url: Option<String>,
  pub extras: Option<BTreeMap<String, String>>,
}

impl PaymentReservationResult {
  pub fn new<F1, F2, F3>(order_id: F1, confirm_url: F2, extras: F3) -> PaymentReservationResult where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    PaymentReservationResult {
      order_id: order_id.into(),
      confirm_url: confirm_url.into(),
      extras: extras.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PaymentReservationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_35 = i_prot.read_string()?;
            let map_val_36 = i_prot.read_string()?;
            val.insert(map_key_35, map_val_36);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PaymentReservationResult {
      order_id: f_1,
      confirm_url: f_2,
      extras: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PaymentReservationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.order_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("orderId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.confirm_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("confirmUrl", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.extras {
      o_prot.write_field_begin(&TFieldIdentifier::new("extras", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PaymentReservationResult {
  fn default() -> Self {
    PaymentReservationResult{
      order_id: Some("".to_owned()),
      confirm_url: Some("".to_owned()),
      extras: Some(BTreeMap::new()),
    }
  }
}

//
// Product
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Product {
  pub product_id: Option<String>,
  pub package_id: Option<i64>,
  pub version: Option<i32>,
  pub author_name: Option<String>,
  pub on_sale: Option<bool>,
  pub valid_days: Option<i32>,
  pub sale_type: Option<i32>,
  pub copyright: Option<String>,
  pub title: Option<String>,
  pub description_text: Option<String>,
  pub shop_order_id: Option<i64>,
  pub from_mid: Option<String>,
  pub to_mid: Option<String>,
  pub valid_until: Option<i64>,
  pub price_tier: Option<i32>,
  pub price: Option<String>,
  pub currency: Option<String>,
  pub currency_symbol: Option<String>,
  pub payment_type: Option<PaymentType>,
  pub create_date: Option<i64>,
  pub own_flag: Option<bool>,
  pub event_type: Option<ProductEventType>,
  pub url_schema: Option<String>,
  pub download_url: Option<String>,
  pub buddy_mid: Option<String>,
  pub publish_since: Option<i64>,
  pub new_flag: Option<bool>,
  pub mission_flag: Option<bool>,
}

impl Product {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27, F28>(product_id: F1, package_id: F2, version: F3, author_name: F4, on_sale: F5, valid_days: F6, sale_type: F7, copyright: F8, title: F9, description_text: F10, shop_order_id: F11, from_mid: F12, to_mid: F13, valid_until: F14, price_tier: F15, price: F16, currency: F17, currency_symbol: F18, payment_type: F19, create_date: F20, own_flag: F21, event_type: F22, url_schema: F23, download_url: F24, buddy_mid: F25, publish_since: F26, new_flag: F27, mission_flag: F28) -> Product where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i32>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<i32>>, F7: Into<Option<i32>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<i64>>, F12: Into<Option<String>>, F13: Into<Option<String>>, F14: Into<Option<i64>>, F15: Into<Option<i32>>, F16: Into<Option<String>>, F17: Into<Option<String>>, F18: Into<Option<String>>, F19: Into<Option<PaymentType>>, F20: Into<Option<i64>>, F21: Into<Option<bool>>, F22: Into<Option<ProductEventType>>, F23: Into<Option<String>>, F24: Into<Option<String>>, F25: Into<Option<String>>, F26: Into<Option<i64>>, F27: Into<Option<bool>>, F28: Into<Option<bool>> {
    Product {
      product_id: product_id.into(),
      package_id: package_id.into(),
      version: version.into(),
      author_name: author_name.into(),
      on_sale: on_sale.into(),
      valid_days: valid_days.into(),
      sale_type: sale_type.into(),
      copyright: copyright.into(),
      title: title.into(),
      description_text: description_text.into(),
      shop_order_id: shop_order_id.into(),
      from_mid: from_mid.into(),
      to_mid: to_mid.into(),
      valid_until: valid_until.into(),
      price_tier: price_tier.into(),
      price: price.into(),
      currency: currency.into(),
      currency_symbol: currency_symbol.into(),
      payment_type: payment_type.into(),
      create_date: create_date.into(),
      own_flag: own_flag.into(),
      event_type: event_type.into(),
      url_schema: url_schema.into(),
      download_url: download_url.into(),
      buddy_mid: buddy_mid.into(),
      publish_since: publish_since.into(),
      new_flag: new_flag.into(),
      mission_flag: mission_flag.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Product> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<i32> = Some(0);
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<i64> = Some(0);
    let mut f_12: Option<String> = Some("".to_owned());
    let mut f_13: Option<String> = Some("".to_owned());
    let mut f_14: Option<i64> = Some(0);
    let mut f_15: Option<i32> = Some(0);
    let mut f_16: Option<String> = Some("".to_owned());
    let mut f_17: Option<String> = Some("".to_owned());
    let mut f_18: Option<String> = Some("".to_owned());
    let mut f_19: Option<PaymentType> = None;
    let mut f_20: Option<i64> = Some(0);
    let mut f_21: Option<bool> = Some(false);
    let mut f_22: Option<ProductEventType> = None;
    let mut f_23: Option<String> = Some("".to_owned());
    let mut f_24: Option<String> = Some("".to_owned());
    let mut f_25: Option<String> = Some("".to_owned());
    let mut f_26: Option<i64> = Some(0);
    let mut f_27: Option<bool> = Some(false);
    let mut f_28: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i32()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_string()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_string()?;
          f_18 = Some(val);
        },
        19 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_bool()?;
          f_21 = Some(val);
        },
        22 => {
          let val = ProductEventType::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_string()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_string()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_string()?;
          f_25 = Some(val);
        },
        26 => {
          let val = i_prot.read_i64()?;
          f_26 = Some(val);
        },
        27 => {
          let val = i_prot.read_bool()?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_bool()?;
          f_28 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Product {
      product_id: f_1,
      package_id: f_2,
      version: f_3,
      author_name: f_4,
      on_sale: f_5,
      valid_days: f_6,
      sale_type: f_7,
      copyright: f_8,
      title: f_9,
      description_text: f_10,
      shop_order_id: f_11,
      from_mid: f_12,
      to_mid: f_13,
      valid_until: f_14,
      price_tier: f_15,
      price: f_16,
      currency: f_17,
      currency_symbol: f_18,
      payment_type: f_19,
      create_date: f_20,
      own_flag: f_21,
      event_type: f_22,
      url_schema: f_23,
      download_url: f_24,
      buddy_mid: f_25,
      publish_since: f_26,
      new_flag: f_27,
      mission_flag: f_28,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Product");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.product_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.package_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("packageId", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.author_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("authorName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.on_sale {
      o_prot.write_field_begin(&TFieldIdentifier::new("onSale", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.valid_days {
      o_prot.write_field_begin(&TFieldIdentifier::new("validDays", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sale_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("saleType", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.copyright {
      o_prot.write_field_begin(&TFieldIdentifier::new("copyright", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.description_text {
      o_prot.write_field_begin(&TFieldIdentifier::new("descriptionText", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.shop_order_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("shopOrderId", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.from_mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("fromMid", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.to_mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("toMid", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.valid_until {
      o_prot.write_field_begin(&TFieldIdentifier::new("validUntil", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.price_tier {
      o_prot.write_field_begin(&TFieldIdentifier::new("priceTier", TType::I32, 15))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.price {
      o_prot.write_field_begin(&TFieldIdentifier::new("price", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.currency {
      o_prot.write_field_begin(&TFieldIdentifier::new("currency", TType::String, 17))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.currency_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("currencySymbol", TType::String, 18))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.payment_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("paymentType", TType::I32, 19))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.create_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("createDate", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.own_flag {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownFlag", TType::Bool, 21))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.event_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::I32, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.url_schema {
      o_prot.write_field_begin(&TFieldIdentifier::new("urlSchema", TType::String, 23))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.download_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("downloadUrl", TType::String, 24))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.buddy_mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 25))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.publish_since {
      o_prot.write_field_begin(&TFieldIdentifier::new("publishSince", TType::I64, 26))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.new_flag {
      o_prot.write_field_begin(&TFieldIdentifier::new("newFlag", TType::Bool, 27))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.mission_flag {
      o_prot.write_field_begin(&TFieldIdentifier::new("missionFlag", TType::Bool, 28))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Product {
  fn default() -> Self {
    Product{
      product_id: Some("".to_owned()),
      package_id: Some(0),
      version: Some(0),
      author_name: Some("".to_owned()),
      on_sale: Some(false),
      valid_days: Some(0),
      sale_type: Some(0),
      copyright: Some("".to_owned()),
      title: Some("".to_owned()),
      description_text: Some("".to_owned()),
      shop_order_id: Some(0),
      from_mid: Some("".to_owned()),
      to_mid: Some("".to_owned()),
      valid_until: Some(0),
      price_tier: Some(0),
      price: Some("".to_owned()),
      currency: Some("".to_owned()),
      currency_symbol: Some("".to_owned()),
      payment_type: None,
      create_date: Some(0),
      own_flag: Some(false),
      event_type: None,
      url_schema: Some("".to_owned()),
      download_url: Some("".to_owned()),
      buddy_mid: Some("".to_owned()),
      publish_since: Some(0),
      new_flag: Some(false),
      mission_flag: Some(false),
    }
  }
}

//
// ProductList
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ProductList {
  pub has_next: Option<bool>,
  pub banner_sequence: Option<i64>,
  pub banner_target_type: Option<ProductBannerLinkType>,
  pub banner_target_path: Option<String>,
  pub product_list: Option<Vec<Product>>,
  pub banner_lang: Option<String>,
}

impl ProductList {
  pub fn new<F1, F4, F5, F6, F7, F8>(has_next: F1, banner_sequence: F4, banner_target_type: F5, banner_target_path: F6, product_list: F7, banner_lang: F8) -> ProductList where F1: Into<Option<bool>>, F4: Into<Option<i64>>, F5: Into<Option<ProductBannerLinkType>>, F6: Into<Option<String>>, F7: Into<Option<Vec<Product>>>, F8: Into<Option<String>> {
    ProductList {
      has_next: has_next.into(),
      banner_sequence: banner_sequence.into(),
      banner_target_type: banner_target_type.into(),
      banner_target_path: banner_target_path.into(),
      product_list: product_list.into(),
      banner_lang: banner_lang.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProductList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<ProductBannerLinkType> = None;
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<Vec<Product>> = Some(Vec::new());
    let mut f_8: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = ProductBannerLinkType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Product> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_37 = Product::read_from_in_protocol(i_prot)?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ProductList {
      has_next: f_1,
      banner_sequence: f_4,
      banner_target_type: f_5,
      banner_target_path: f_6,
      product_list: f_7,
      banner_lang: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ProductList");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.has_next {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasNext", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.banner_sequence {
      o_prot.write_field_begin(&TFieldIdentifier::new("bannerSequence", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.banner_target_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("bannerTargetType", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.banner_target_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("bannerTargetPath", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.product_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("productList", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.banner_lang {
      o_prot.write_field_begin(&TFieldIdentifier::new("bannerLang", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ProductList {
  fn default() -> Self {
    ProductList{
      has_next: Some(false),
      banner_sequence: Some(0),
      banner_target_type: None,
      banner_target_path: Some("".to_owned()),
      product_list: Some(Vec::new()),
      banner_lang: Some("".to_owned()),
    }
  }
}

//
// ProductSimple
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ProductSimple {
  pub product_id: Option<String>,
  pub package_id: Option<i64>,
  pub version: Option<i32>,
  pub on_sale: Option<bool>,
  pub valid_until: Option<i64>,
}

impl ProductSimple {
  pub fn new<F1, F2, F3, F4, F5>(product_id: F1, package_id: F2, version: F3, on_sale: F4, valid_until: F5) -> ProductSimple where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i32>>, F4: Into<Option<bool>>, F5: Into<Option<i64>> {
    ProductSimple {
      product_id: product_id.into(),
      package_id: package_id.into(),
      version: version.into(),
      on_sale: on_sale.into(),
      valid_until: valid_until.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProductSimple> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ProductSimple {
      product_id: f_1,
      package_id: f_2,
      version: f_3,
      on_sale: f_4,
      valid_until: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ProductSimple");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.product_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.package_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("packageId", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.on_sale {
      o_prot.write_field_begin(&TFieldIdentifier::new("onSale", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.valid_until {
      o_prot.write_field_begin(&TFieldIdentifier::new("validUntil", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ProductSimple {
  fn default() -> Self {
    ProductSimple{
      product_id: Some("".to_owned()),
      package_id: Some(0),
      version: Some(0),
      on_sale: Some(false),
      valid_until: Some(0),
    }
  }
}

//
// ProductSimpleList
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ProductSimpleList {
  pub has_next: Option<bool>,
  pub reinvoke_hour: Option<i32>,
  pub last_version_seq: Option<i64>,
  pub product_list: Option<Vec<ProductSimple>>,
  pub recent_new_release_date: Option<i64>,
  pub recent_event_release_date: Option<i64>,
}

impl ProductSimpleList {
  pub fn new<F1, F2, F3, F4, F5, F6>(has_next: F1, reinvoke_hour: F2, last_version_seq: F3, product_list: F4, recent_new_release_date: F5, recent_event_release_date: F6) -> ProductSimpleList where F1: Into<Option<bool>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<Vec<ProductSimple>>>, F5: Into<Option<i64>>, F6: Into<Option<i64>> {
    ProductSimpleList {
      has_next: has_next.into(),
      reinvoke_hour: reinvoke_hour.into(),
      last_version_seq: last_version_seq.into(),
      product_list: product_list.into(),
      recent_new_release_date: recent_new_release_date.into(),
      recent_event_release_date: recent_event_release_date.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProductSimpleList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<Vec<ProductSimple>> = Some(Vec::new());
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ProductSimple> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = ProductSimple::read_from_in_protocol(i_prot)?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ProductSimpleList {
      has_next: f_1,
      reinvoke_hour: f_2,
      last_version_seq: f_3,
      product_list: f_4,
      recent_new_release_date: f_5,
      recent_event_release_date: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ProductSimpleList");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.has_next {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasNext", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.reinvoke_hour {
      o_prot.write_field_begin(&TFieldIdentifier::new("reinvokeHour", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.last_version_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastVersionSeq", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.product_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("productList", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.recent_new_release_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("recentNewReleaseDate", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.recent_event_release_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("recentEventReleaseDate", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ProductSimpleList {
  fn default() -> Self {
    ProductSimpleList{
      has_next: Some(false),
      reinvoke_hour: Some(0),
      last_version_seq: Some(0),
      product_list: Some(Vec::new()),
      recent_new_release_date: Some(0),
      recent_event_release_date: Some(0),
    }
  }
}

//
// Profile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Profile {
  pub mid: Option<String>,
  pub userid: Option<String>,
  pub phone: Option<String>,
  pub email: Option<String>,
  pub region_code: Option<String>,
  pub display_name: Option<String>,
  pub phonetic_name: Option<String>,
  pub picture_status: Option<String>,
  pub thumbnail_url: Option<String>,
  pub status_message: Option<String>,
  pub allow_search_by_userid: Option<bool>,
  pub allow_search_by_email: Option<bool>,
  pub picture_path: Option<String>,
}

impl Profile {
  pub fn new<F1, F3, F10, F11, F12, F20, F21, F22, F23, F24, F31, F32, F33>(mid: F1, userid: F3, phone: F10, email: F11, region_code: F12, display_name: F20, phonetic_name: F21, picture_status: F22, thumbnail_url: F23, status_message: F24, allow_search_by_userid: F31, allow_search_by_email: F32, picture_path: F33) -> Profile where F1: Into<Option<String>>, F3: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<String>>, F20: Into<Option<String>>, F21: Into<Option<String>>, F22: Into<Option<String>>, F23: Into<Option<String>>, F24: Into<Option<String>>, F31: Into<Option<bool>>, F32: Into<Option<bool>>, F33: Into<Option<String>> {
    Profile {
      mid: mid.into(),
      userid: userid.into(),
      phone: phone.into(),
      email: email.into(),
      region_code: region_code.into(),
      display_name: display_name.into(),
      phonetic_name: phonetic_name.into(),
      picture_status: picture_status.into(),
      thumbnail_url: thumbnail_url.into(),
      status_message: status_message.into(),
      allow_search_by_userid: allow_search_by_userid.into(),
      allow_search_by_email: allow_search_by_email.into(),
      picture_path: picture_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Profile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    let mut f_20: Option<String> = Some("".to_owned());
    let mut f_21: Option<String> = Some("".to_owned());
    let mut f_22: Option<String> = Some("".to_owned());
    let mut f_23: Option<String> = Some("".to_owned());
    let mut f_24: Option<String> = Some("".to_owned());
    let mut f_31: Option<bool> = Some(false);
    let mut f_32: Option<bool> = Some(false);
    let mut f_33: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_string()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_string()?;
          f_24 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        32 => {
          let val = i_prot.read_bool()?;
          f_32 = Some(val);
        },
        33 => {
          let val = i_prot.read_string()?;
          f_33 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Profile {
      mid: f_1,
      userid: f_3,
      phone: f_10,
      email: f_11,
      region_code: f_12,
      display_name: f_20,
      phonetic_name: f_21,
      picture_status: f_22,
      thumbnail_url: f_23,
      status_message: f_24,
      allow_search_by_userid: f_31,
      allow_search_by_email: f_32,
      picture_path: f_33,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Profile");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.userid {
      o_prot.write_field_begin(&TFieldIdentifier::new("userid", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.phone {
      o_prot.write_field_begin(&TFieldIdentifier::new("phone", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.region_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("regionCode", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.phonetic_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("phoneticName", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("pictureStatus", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.thumbnail_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("thumbnailUrl", TType::String, 23))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("statusMessage", TType::String, 24))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.allow_search_by_userid {
      o_prot.write_field_begin(&TFieldIdentifier::new("allowSearchByUserid", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.allow_search_by_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("allowSearchByEmail", TType::Bool, 32))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("picturePath", TType::String, 33))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Profile {
  fn default() -> Self {
    Profile{
      mid: Some("".to_owned()),
      userid: Some("".to_owned()),
      phone: Some("".to_owned()),
      email: Some("".to_owned()),
      region_code: Some("".to_owned()),
      display_name: Some("".to_owned()),
      phonetic_name: Some("".to_owned()),
      picture_status: Some("".to_owned()),
      thumbnail_url: Some("".to_owned()),
      status_message: Some("".to_owned()),
      allow_search_by_userid: Some(false),
      allow_search_by_email: Some(false),
      picture_path: Some("".to_owned()),
    }
  }
}

//
// ProximityMatchCandidateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ProximityMatchCandidateResult {
  pub users: Option<Vec<Contact>>,
  pub buddies: Option<Vec<Contact>>,
}

impl ProximityMatchCandidateResult {
  pub fn new<F1, F2>(users: F1, buddies: F2) -> ProximityMatchCandidateResult where F1: Into<Option<Vec<Contact>>>, F2: Into<Option<Vec<Contact>>> {
    ProximityMatchCandidateResult {
      users: users.into(),
      buddies: buddies.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProximityMatchCandidateResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Contact>> = Some(Vec::new());
    let mut f_2: Option<Vec<Contact>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ProximityMatchCandidateResult {
      users: f_1,
      buddies: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ProximityMatchCandidateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.users {
      o_prot.write_field_begin(&TFieldIdentifier::new("users", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.buddies {
      o_prot.write_field_begin(&TFieldIdentifier::new("buddies", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ProximityMatchCandidateResult {
  fn default() -> Self {
    ProximityMatchCandidateResult{
      users: Some(Vec::new()),
      buddies: Some(Vec::new()),
    }
  }
}

//
// RegisterWithSnsIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RegisterWithSnsIdResult {
  pub auth_token: Option<String>,
  pub user_created: Option<bool>,
}

impl RegisterWithSnsIdResult {
  pub fn new<F1, F2>(auth_token: F1, user_created: F2) -> RegisterWithSnsIdResult where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    RegisterWithSnsIdResult {
      auth_token: auth_token.into(),
      user_created: user_created.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RegisterWithSnsIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RegisterWithSnsIdResult {
      auth_token: f_1,
      user_created: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RegisterWithSnsIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.auth_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("authToken", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.user_created {
      o_prot.write_field_begin(&TFieldIdentifier::new("userCreated", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RegisterWithSnsIdResult {
  fn default() -> Self {
    RegisterWithSnsIdResult{
      auth_token: Some("".to_owned()),
      user_created: Some(false),
    }
  }
}

//
// RequestTokenResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RequestTokenResponse {
  pub request_token: Option<String>,
  pub return_url: Option<String>,
}

impl RequestTokenResponse {
  pub fn new<F1, F2>(request_token: F1, return_url: F2) -> RequestTokenResponse where F1: Into<Option<String>>, F2: Into<Option<String>> {
    RequestTokenResponse {
      request_token: request_token.into(),
      return_url: return_url.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestTokenResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RequestTokenResponse {
      request_token: f_1,
      return_url: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestTokenResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestToken", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.return_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("returnUrl", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RequestTokenResponse {
  fn default() -> Self {
    RequestTokenResponse{
      request_token: Some("".to_owned()),
      return_url: Some("".to_owned()),
    }
  }
}

//
// Room
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Room {
  pub mid: Option<String>,
  pub created_time: Option<i64>,
  pub contacts: Option<Vec<Contact>>,
  pub notification_disabled: Option<bool>,
}

impl Room {
  pub fn new<F1, F2, F10, F31>(mid: F1, created_time: F2, contacts: F10, notification_disabled: F31) -> Room where F1: Into<Option<String>>, F2: Into<Option<i64>>, F10: Into<Option<Vec<Contact>>>, F31: Into<Option<bool>> {
    Room {
      mid: mid.into(),
      created_time: created_time.into(),
      contacts: contacts.into(),
      notification_disabled: notification_disabled.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Room> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_10: Option<Vec<Contact>> = Some(Vec::new());
    let mut f_31: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Room {
      mid: f_1,
      created_time: f_2,
      contacts: f_10,
      notification_disabled: f_31,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Room");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contacts {
      o_prot.write_field_begin(&TFieldIdentifier::new("contacts", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_disabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationDisabled", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Room {
  fn default() -> Self {
    Room{
      mid: Some("".to_owned()),
      created_time: Some(0),
      contacts: Some(Vec::new()),
      notification_disabled: Some(false),
    }
  }
}

//
// RSAKey
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RSAKey {
  pub keynm: Option<String>,
  pub nvalue: Option<String>,
  pub evalue: Option<String>,
  pub session_key: Option<String>,
}

impl RSAKey {
  pub fn new<F1, F2, F3, F4>(keynm: F1, nvalue: F2, evalue: F3, session_key: F4) -> RSAKey where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>> {
    RSAKey {
      keynm: keynm.into(),
      nvalue: nvalue.into(),
      evalue: evalue.into(),
      session_key: session_key.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RSAKey> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RSAKey {
      keynm: f_1,
      nvalue: f_2,
      evalue: f_3,
      session_key: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RSAKey");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.keynm {
      o_prot.write_field_begin(&TFieldIdentifier::new("keynm", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nvalue {
      o_prot.write_field_begin(&TFieldIdentifier::new("nvalue", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.evalue {
      o_prot.write_field_begin(&TFieldIdentifier::new("evalue", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.session_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionKey", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RSAKey {
  fn default() -> Self {
    RSAKey{
      keynm: Some("".to_owned()),
      nvalue: Some("".to_owned()),
      evalue: Some("".to_owned()),
      session_key: Some("".to_owned()),
    }
  }
}

//
// SendBuddyMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SendBuddyMessageResult {
  pub request_id: Option<String>,
  pub state: Option<BuddyResultState>,
  pub message_id: Option<String>,
  pub event_no: Option<i32>,
  pub receiver_count: Option<i64>,
  pub success_count: Option<i64>,
  pub fail_count: Option<i64>,
  pub cancel_count: Option<i64>,
  pub block_count: Option<i64>,
  pub unregister_count: Option<i64>,
  pub timestamp: Option<i64>,
  pub message: Option<String>,
}

impl SendBuddyMessageResult {
  pub fn new<F1, F2, F3, F4, F11, F12, F13, F14, F15, F16, F21, F22>(request_id: F1, state: F2, message_id: F3, event_no: F4, receiver_count: F11, success_count: F12, fail_count: F13, cancel_count: F14, block_count: F15, unregister_count: F16, timestamp: F21, message: F22) -> SendBuddyMessageResult where F1: Into<Option<String>>, F2: Into<Option<BuddyResultState>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F11: Into<Option<i64>>, F12: Into<Option<i64>>, F13: Into<Option<i64>>, F14: Into<Option<i64>>, F15: Into<Option<i64>>, F16: Into<Option<i64>>, F21: Into<Option<i64>>, F22: Into<Option<String>> {
    SendBuddyMessageResult {
      request_id: request_id.into(),
      state: state.into(),
      message_id: message_id.into(),
      event_no: event_no.into(),
      receiver_count: receiver_count.into(),
      success_count: success_count.into(),
      fail_count: fail_count.into(),
      cancel_count: cancel_count.into(),
      block_count: block_count.into(),
      unregister_count: unregister_count.into(),
      timestamp: timestamp.into(),
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SendBuddyMessageResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<BuddyResultState> = None;
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i32> = Some(0);
    let mut f_11: Option<i64> = Some(0);
    let mut f_12: Option<i64> = Some(0);
    let mut f_13: Option<i64> = Some(0);
    let mut f_14: Option<i64> = Some(0);
    let mut f_15: Option<i64> = Some(0);
    let mut f_16: Option<i64> = Some(0);
    let mut f_21: Option<i64> = Some(0);
    let mut f_22: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = BuddyResultState::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        21 => {
          let val = i_prot.read_i64()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SendBuddyMessageResult {
      request_id: f_1,
      state: f_2,
      message_id: f_3,
      event_no: f_4,
      receiver_count: f_11,
      success_count: f_12,
      fail_count: f_13,
      cancel_count: f_14,
      block_count: f_15,
      unregister_count: f_16,
      timestamp: f_21,
      message: f_22,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SendBuddyMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.event_no {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventNo", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.receiver_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("receiverCount", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.success_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("successCount", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fail_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("failCount", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cancel_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelCount", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.block_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("blockCount", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.unregister_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("unregisterCount", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 21))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SendBuddyMessageResult {
  fn default() -> Self {
    SendBuddyMessageResult{
      request_id: Some("".to_owned()),
      state: None,
      message_id: Some("".to_owned()),
      event_no: Some(0),
      receiver_count: Some(0),
      success_count: Some(0),
      fail_count: Some(0),
      cancel_count: Some(0),
      block_count: Some(0),
      unregister_count: Some(0),
      timestamp: Some(0),
      message: Some("".to_owned()),
    }
  }
}

//
// SetBuddyOnAirResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetBuddyOnAirResult {
  pub request_id: Option<String>,
  pub state: Option<BuddyResultState>,
  pub event_no: Option<i32>,
  pub receiver_count: Option<i64>,
  pub success_count: Option<i64>,
  pub fail_count: Option<i64>,
  pub cancel_count: Option<i64>,
  pub unregister_count: Option<i64>,
  pub timestamp: Option<i64>,
  pub message: Option<String>,
}

impl SetBuddyOnAirResult {
  pub fn new<F1, F2, F3, F11, F12, F13, F14, F15, F21, F22>(request_id: F1, state: F2, event_no: F3, receiver_count: F11, success_count: F12, fail_count: F13, cancel_count: F14, unregister_count: F15, timestamp: F21, message: F22) -> SetBuddyOnAirResult where F1: Into<Option<String>>, F2: Into<Option<BuddyResultState>>, F3: Into<Option<i32>>, F11: Into<Option<i64>>, F12: Into<Option<i64>>, F13: Into<Option<i64>>, F14: Into<Option<i64>>, F15: Into<Option<i64>>, F21: Into<Option<i64>>, F22: Into<Option<String>> {
    SetBuddyOnAirResult {
      request_id: request_id.into(),
      state: state.into(),
      event_no: event_no.into(),
      receiver_count: receiver_count.into(),
      success_count: success_count.into(),
      fail_count: fail_count.into(),
      cancel_count: cancel_count.into(),
      unregister_count: unregister_count.into(),
      timestamp: timestamp.into(),
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetBuddyOnAirResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<BuddyResultState> = None;
    let mut f_3: Option<i32> = Some(0);
    let mut f_11: Option<i64> = Some(0);
    let mut f_12: Option<i64> = Some(0);
    let mut f_13: Option<i64> = Some(0);
    let mut f_14: Option<i64> = Some(0);
    let mut f_15: Option<i64> = Some(0);
    let mut f_21: Option<i64> = Some(0);
    let mut f_22: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = BuddyResultState::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        21 => {
          let val = i_prot.read_i64()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SetBuddyOnAirResult {
      request_id: f_1,
      state: f_2,
      event_no: f_3,
      receiver_count: f_11,
      success_count: f_12,
      fail_count: f_13,
      cancel_count: f_14,
      unregister_count: f_15,
      timestamp: f_21,
      message: f_22,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetBuddyOnAirResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.event_no {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventNo", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.receiver_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("receiverCount", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.success_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("successCount", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fail_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("failCount", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cancel_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelCount", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.unregister_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("unregisterCount", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 21))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SetBuddyOnAirResult {
  fn default() -> Self {
    SetBuddyOnAirResult{
      request_id: Some("".to_owned()),
      state: None,
      event_no: Some(0),
      receiver_count: Some(0),
      success_count: Some(0),
      fail_count: Some(0),
      cancel_count: Some(0),
      unregister_count: Some(0),
      timestamp: Some(0),
      message: Some("".to_owned()),
    }
  }
}

//
// Settings
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Settings {
  pub notification_enable: Option<bool>,
  pub notification_mute_expiration: Option<i64>,
  pub notification_new_message: Option<bool>,
  pub notification_group_invitation: Option<bool>,
  pub notification_show_message: Option<bool>,
  pub notification_incoming_call: Option<bool>,
  pub notification_sound_message: Option<String>,
  pub notification_sound_group: Option<String>,
  pub notification_disabled_with_sub: Option<bool>,
  pub privacy_sync_contacts: Option<bool>,
  pub privacy_search_by_phone_number: Option<bool>,
  pub privacy_search_by_userid: Option<bool>,
  pub privacy_search_by_email: Option<bool>,
  pub privacy_allow_secondary_device_login: Option<bool>,
  pub privacy_profile_image_post_to_myhome: Option<bool>,
  pub privacy_receive_messages_from_not_friend: Option<bool>,
  pub contact_my_ticket: Option<String>,
  pub identity_provider: Option<IdentityProvider>,
  pub identity_identifier: Option<String>,
  pub sns_accounts: Option<BTreeMap<SnsIdType, String>>,
  pub phone_registration: Option<bool>,
  pub email_confirmation_status: Option<EmailConfirmationStatus>,
  pub preference_locale: Option<String>,
  pub custom_modes: Option<BTreeMap<CustomMode, String>>,
}

impl Settings {
  pub fn new<F10, F11, F12, F13, F14, F15, F16, F17, F18, F20, F21, F22, F23, F24, F25, F26, F30, F40, F41, F42, F43, F44, F50, F60>(notification_enable: F10, notification_mute_expiration: F11, notification_new_message: F12, notification_group_invitation: F13, notification_show_message: F14, notification_incoming_call: F15, notification_sound_message: F16, notification_sound_group: F17, notification_disabled_with_sub: F18, privacy_sync_contacts: F20, privacy_search_by_phone_number: F21, privacy_search_by_userid: F22, privacy_search_by_email: F23, privacy_allow_secondary_device_login: F24, privacy_profile_image_post_to_myhome: F25, privacy_receive_messages_from_not_friend: F26, contact_my_ticket: F30, identity_provider: F40, identity_identifier: F41, sns_accounts: F42, phone_registration: F43, email_confirmation_status: F44, preference_locale: F50, custom_modes: F60) -> Settings where F10: Into<Option<bool>>, F11: Into<Option<i64>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<String>>, F17: Into<Option<String>>, F18: Into<Option<bool>>, F20: Into<Option<bool>>, F21: Into<Option<bool>>, F22: Into<Option<bool>>, F23: Into<Option<bool>>, F24: Into<Option<bool>>, F25: Into<Option<bool>>, F26: Into<Option<bool>>, F30: Into<Option<String>>, F40: Into<Option<IdentityProvider>>, F41: Into<Option<String>>, F42: Into<Option<BTreeMap<SnsIdType, String>>>, F43: Into<Option<bool>>, F44: Into<Option<EmailConfirmationStatus>>, F50: Into<Option<String>>, F60: Into<Option<BTreeMap<CustomMode, String>>> {
    Settings {
      notification_enable: notification_enable.into(),
      notification_mute_expiration: notification_mute_expiration.into(),
      notification_new_message: notification_new_message.into(),
      notification_group_invitation: notification_group_invitation.into(),
      notification_show_message: notification_show_message.into(),
      notification_incoming_call: notification_incoming_call.into(),
      notification_sound_message: notification_sound_message.into(),
      notification_sound_group: notification_sound_group.into(),
      notification_disabled_with_sub: notification_disabled_with_sub.into(),
      privacy_sync_contacts: privacy_sync_contacts.into(),
      privacy_search_by_phone_number: privacy_search_by_phone_number.into(),
      privacy_search_by_userid: privacy_search_by_userid.into(),
      privacy_search_by_email: privacy_search_by_email.into(),
      privacy_allow_secondary_device_login: privacy_allow_secondary_device_login.into(),
      privacy_profile_image_post_to_myhome: privacy_profile_image_post_to_myhome.into(),
      privacy_receive_messages_from_not_friend: privacy_receive_messages_from_not_friend.into(),
      contact_my_ticket: contact_my_ticket.into(),
      identity_provider: identity_provider.into(),
      identity_identifier: identity_identifier.into(),
      sns_accounts: sns_accounts.into(),
      phone_registration: phone_registration.into(),
      email_confirmation_status: email_confirmation_status.into(),
      preference_locale: preference_locale.into(),
      custom_modes: custom_modes.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Settings> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<bool> = Some(false);
    let mut f_11: Option<i64> = Some(0);
    let mut f_12: Option<bool> = Some(false);
    let mut f_13: Option<bool> = Some(false);
    let mut f_14: Option<bool> = Some(false);
    let mut f_15: Option<bool> = Some(false);
    let mut f_16: Option<String> = Some("".to_owned());
    let mut f_17: Option<String> = Some("".to_owned());
    let mut f_18: Option<bool> = Some(false);
    let mut f_20: Option<bool> = Some(false);
    let mut f_21: Option<bool> = Some(false);
    let mut f_22: Option<bool> = Some(false);
    let mut f_23: Option<bool> = Some(false);
    let mut f_24: Option<bool> = Some(false);
    let mut f_25: Option<bool> = Some(false);
    let mut f_26: Option<bool> = Some(false);
    let mut f_30: Option<String> = Some("".to_owned());
    let mut f_40: Option<IdentityProvider> = None;
    let mut f_41: Option<String> = Some("".to_owned());
    let mut f_42: Option<BTreeMap<SnsIdType, String>> = Some(BTreeMap::new());
    let mut f_43: Option<bool> = Some(false);
    let mut f_44: Option<EmailConfirmationStatus> = None;
    let mut f_50: Option<String> = Some("".to_owned());
    let mut f_60: Option<BTreeMap<CustomMode, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_string()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_bool()?;
          f_18 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_bool()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_bool()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_bool()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_bool()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_bool()?;
          f_25 = Some(val);
        },
        26 => {
          let val = i_prot.read_bool()?;
          f_26 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        41 => {
          let val = i_prot.read_string()?;
          f_41 = Some(val);
        },
        42 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<SnsIdType, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_42 = SnsIdType::read_from_in_protocol(i_prot)?;
            let map_val_43 = i_prot.read_string()?;
            val.insert(map_key_42, map_val_43);
          }
          i_prot.read_map_end()?;
          f_42 = Some(val);
        },
        43 => {
          let val = i_prot.read_bool()?;
          f_43 = Some(val);
        },
        44 => {
          let val = EmailConfirmationStatus::read_from_in_protocol(i_prot)?;
          f_44 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<CustomMode, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_44 = CustomMode::read_from_in_protocol(i_prot)?;
            let map_val_45 = i_prot.read_string()?;
            val.insert(map_key_44, map_val_45);
          }
          i_prot.read_map_end()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Settings {
      notification_enable: f_10,
      notification_mute_expiration: f_11,
      notification_new_message: f_12,
      notification_group_invitation: f_13,
      notification_show_message: f_14,
      notification_incoming_call: f_15,
      notification_sound_message: f_16,
      notification_sound_group: f_17,
      notification_disabled_with_sub: f_18,
      privacy_sync_contacts: f_20,
      privacy_search_by_phone_number: f_21,
      privacy_search_by_userid: f_22,
      privacy_search_by_email: f_23,
      privacy_allow_secondary_device_login: f_24,
      privacy_profile_image_post_to_myhome: f_25,
      privacy_receive_messages_from_not_friend: f_26,
      contact_my_ticket: f_30,
      identity_provider: f_40,
      identity_identifier: f_41,
      sns_accounts: f_42,
      phone_registration: f_43,
      email_confirmation_status: f_44,
      preference_locale: f_50,
      custom_modes: f_60,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Settings");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.notification_enable {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationEnable", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_mute_expiration {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationMuteExpiration", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_new_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationNewMessage", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_group_invitation {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationGroupInvitation", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_show_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationShowMessage", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_incoming_call {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationIncomingCall", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.notification_sound_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationSoundMessage", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.notification_sound_group {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationSoundGroup", TType::String, 17))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.notification_disabled_with_sub {
      o_prot.write_field_begin(&TFieldIdentifier::new("notificationDisabledWithSub", TType::Bool, 18))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.privacy_sync_contacts {
      o_prot.write_field_begin(&TFieldIdentifier::new("privacySyncContacts", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.privacy_search_by_phone_number {
      o_prot.write_field_begin(&TFieldIdentifier::new("privacySearchByPhoneNumber", TType::Bool, 21))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.privacy_search_by_userid {
      o_prot.write_field_begin(&TFieldIdentifier::new("privacySearchByUserid", TType::Bool, 22))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.privacy_search_by_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("privacySearchByEmail", TType::Bool, 23))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.privacy_allow_secondary_device_login {
      o_prot.write_field_begin(&TFieldIdentifier::new("privacyAllowSecondaryDeviceLogin", TType::Bool, 24))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.privacy_profile_image_post_to_myhome {
      o_prot.write_field_begin(&TFieldIdentifier::new("privacyProfileImagePostToMyhome", TType::Bool, 25))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.privacy_receive_messages_from_not_friend {
      o_prot.write_field_begin(&TFieldIdentifier::new("privacyReceiveMessagesFromNotFriend", TType::Bool, 26))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contact_my_ticket {
      o_prot.write_field_begin(&TFieldIdentifier::new("contactMyTicket", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.identity_provider {
      o_prot.write_field_begin(&TFieldIdentifier::new("identityProvider", TType::I32, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.identity_identifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("identityIdentifier", TType::String, 41))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sns_accounts {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsAccounts", TType::Map, 42))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        k.write_to_out_protocol(o_prot)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.phone_registration {
      o_prot.write_field_begin(&TFieldIdentifier::new("phoneRegistration", TType::Bool, 43))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.email_confirmation_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("emailConfirmationStatus", TType::I32, 44))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.preference_locale {
      o_prot.write_field_begin(&TFieldIdentifier::new("preferenceLocale", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.custom_modes {
      o_prot.write_field_begin(&TFieldIdentifier::new("customModes", TType::Map, 60))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        k.write_to_out_protocol(o_prot)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Settings {
  fn default() -> Self {
    Settings{
      notification_enable: Some(false),
      notification_mute_expiration: Some(0),
      notification_new_message: Some(false),
      notification_group_invitation: Some(false),
      notification_show_message: Some(false),
      notification_incoming_call: Some(false),
      notification_sound_message: Some("".to_owned()),
      notification_sound_group: Some("".to_owned()),
      notification_disabled_with_sub: Some(false),
      privacy_sync_contacts: Some(false),
      privacy_search_by_phone_number: Some(false),
      privacy_search_by_userid: Some(false),
      privacy_search_by_email: Some(false),
      privacy_allow_secondary_device_login: Some(false),
      privacy_profile_image_post_to_myhome: Some(false),
      privacy_receive_messages_from_not_friend: Some(false),
      contact_my_ticket: Some("".to_owned()),
      identity_provider: None,
      identity_identifier: Some("".to_owned()),
      sns_accounts: Some(BTreeMap::new()),
      phone_registration: Some(false),
      email_confirmation_status: None,
      preference_locale: Some("".to_owned()),
      custom_modes: Some(BTreeMap::new()),
    }
  }
}

//
// SimpleChannelClient
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SimpleChannelClient {
  pub application_type: Option<String>,
  pub application_version: Option<String>,
  pub locale: Option<String>,
}

impl SimpleChannelClient {
  pub fn new<F1, F2, F3>(application_type: F1, application_version: F2, locale: F3) -> SimpleChannelClient where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    SimpleChannelClient {
      application_type: application_type.into(),
      application_version: application_version.into(),
      locale: locale.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SimpleChannelClient> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SimpleChannelClient {
      application_type: f_1,
      application_version: f_2,
      locale: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SimpleChannelClient");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.application_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationType", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.application_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationVersion", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.locale {
      o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SimpleChannelClient {
  fn default() -> Self {
    SimpleChannelClient{
      application_type: Some("".to_owned()),
      application_version: Some("".to_owned()),
      locale: Some("".to_owned()),
    }
  }
}

//
// SimpleChannelContact
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SimpleChannelContact {
  pub mid: Option<String>,
  pub display_name: Option<String>,
  pub picture_status: Option<String>,
  pub picture_path: Option<String>,
  pub status_message: Option<String>,
}

impl SimpleChannelContact {
  pub fn new<F1, F2, F3, F4, F5>(mid: F1, display_name: F2, picture_status: F3, picture_path: F4, status_message: F5) -> SimpleChannelContact where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    SimpleChannelContact {
      mid: mid.into(),
      display_name: display_name.into(),
      picture_status: picture_status.into(),
      picture_path: picture_path.into(),
      status_message: status_message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SimpleChannelContact> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SimpleChannelContact {
      mid: f_1,
      display_name: f_2,
      picture_status: f_3,
      picture_path: f_4,
      status_message: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SimpleChannelContact");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("pictureStatus", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("picturePath", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.status_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("statusMessage", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SimpleChannelContact {
  fn default() -> Self {
    SimpleChannelContact{
      mid: Some("".to_owned()),
      display_name: Some("".to_owned()),
      picture_status: Some("".to_owned()),
      picture_path: Some("".to_owned()),
      status_message: Some("".to_owned()),
    }
  }
}

//
// SnsFriend
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnsFriend {
  pub sns_user_id: Option<String>,
  pub sns_user_name: Option<String>,
  pub sns_id_type: Option<SnsIdType>,
}

impl SnsFriend {
  pub fn new<F1, F2, F3>(sns_user_id: F1, sns_user_name: F2, sns_id_type: F3) -> SnsFriend where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<SnsIdType>> {
    SnsFriend {
      sns_user_id: sns_user_id.into(),
      sns_user_name: sns_user_name.into(),
      sns_id_type: sns_id_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsFriend> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<SnsIdType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsFriend {
      sns_user_id: f_1,
      sns_user_name: f_2,
      sns_id_type: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsFriend");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.sns_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsUserId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sns_user_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsUserName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sns_id_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SnsFriend {
  fn default() -> Self {
    SnsFriend{
      sns_user_id: Some("".to_owned()),
      sns_user_name: Some("".to_owned()),
      sns_id_type: None,
    }
  }
}

//
// SnsFriendContactRegistration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnsFriendContactRegistration {
  pub contact: Option<Contact>,
  pub sns_id_type: Option<SnsIdType>,
  pub sns_user_id: Option<String>,
}

impl SnsFriendContactRegistration {
  pub fn new<F1, F2, F3>(contact: F1, sns_id_type: F2, sns_user_id: F3) -> SnsFriendContactRegistration where F1: Into<Option<Contact>>, F2: Into<Option<SnsIdType>>, F3: Into<Option<String>> {
    SnsFriendContactRegistration {
      contact: contact.into(),
      sns_id_type: sns_id_type.into(),
      sns_user_id: sns_user_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsFriendContactRegistration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Contact> = None;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsFriendContactRegistration {
      contact: f_1,
      sns_id_type: f_2,
      sns_user_id: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsFriendContactRegistration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.contact {
      o_prot.write_field_begin(&TFieldIdentifier::new("contact", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sns_id_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sns_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsUserId", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SnsFriendContactRegistration {
  fn default() -> Self {
    SnsFriendContactRegistration{
      contact: None,
      sns_id_type: None,
      sns_user_id: Some("".to_owned()),
    }
  }
}

//
// SnsFriendModification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnsFriendModification {
  pub type_: Option<ModificationType>,
  pub sns_friend: Option<SnsFriend>,
}

impl SnsFriendModification {
  pub fn new<F1, F2>(type_: F1, sns_friend: F2) -> SnsFriendModification where F1: Into<Option<ModificationType>>, F2: Into<Option<SnsFriend>> {
    SnsFriendModification {
      type_: type_.into(),
      sns_friend: sns_friend.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsFriendModification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ModificationType> = None;
    let mut f_2: Option<SnsFriend> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ModificationType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = SnsFriend::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsFriendModification {
      type_: f_1,
      sns_friend: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsFriendModification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sns_friend {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsFriend", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SnsFriendModification {
  fn default() -> Self {
    SnsFriendModification{
      type_: None,
      sns_friend: None,
    }
  }
}

//
// SnsFriends
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnsFriends {
  pub sns_friends: Option<Vec<SnsFriend>>,
  pub has_more: Option<bool>,
}

impl SnsFriends {
  pub fn new<F1, F2>(sns_friends: F1, has_more: F2) -> SnsFriends where F1: Into<Option<Vec<SnsFriend>>>, F2: Into<Option<bool>> {
    SnsFriends {
      sns_friends: sns_friends.into(),
      has_more: has_more.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsFriends> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SnsFriend>> = Some(Vec::new());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SnsFriend> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = SnsFriend::read_from_in_protocol(i_prot)?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsFriends {
      sns_friends: f_1,
      has_more: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsFriends");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.sns_friends {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsFriends", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_more {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasMore", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SnsFriends {
  fn default() -> Self {
    SnsFriends{
      sns_friends: Some(Vec::new()),
      has_more: Some(false),
    }
  }
}

//
// SnsIdUserStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnsIdUserStatus {
  pub user_existing: Option<bool>,
  pub phone_number_registered: Option<bool>,
  pub same_device: Option<bool>,
}

impl SnsIdUserStatus {
  pub fn new<F1, F2, F3>(user_existing: F1, phone_number_registered: F2, same_device: F3) -> SnsIdUserStatus where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>> {
    SnsIdUserStatus {
      user_existing: user_existing.into(),
      phone_number_registered: phone_number_registered.into(),
      same_device: same_device.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsIdUserStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsIdUserStatus {
      user_existing: f_1,
      phone_number_registered: f_2,
      same_device: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsIdUserStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.user_existing {
      o_prot.write_field_begin(&TFieldIdentifier::new("userExisting", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.phone_number_registered {
      o_prot.write_field_begin(&TFieldIdentifier::new("phoneNumberRegistered", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.same_device {
      o_prot.write_field_begin(&TFieldIdentifier::new("sameDevice", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SnsIdUserStatus {
  fn default() -> Self {
    SnsIdUserStatus{
      user_existing: Some(false),
      phone_number_registered: Some(false),
      same_device: Some(false),
    }
  }
}

//
// SnsProfile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnsProfile {
  pub sns_user_id: Option<String>,
  pub sns_user_name: Option<String>,
  pub email: Option<String>,
  pub thumbnail_url: Option<String>,
}

impl SnsProfile {
  pub fn new<F1, F2, F3, F4>(sns_user_id: F1, sns_user_name: F2, email: F3, thumbnail_url: F4) -> SnsProfile where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>> {
    SnsProfile {
      sns_user_id: sns_user_id.into(),
      sns_user_name: sns_user_name.into(),
      email: email.into(),
      thumbnail_url: thumbnail_url.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsProfile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsProfile {
      sns_user_id: f_1,
      sns_user_name: f_2,
      email: f_3,
      thumbnail_url: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsProfile");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.sns_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsUserId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sns_user_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("snsUserName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.thumbnail_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("thumbnailUrl", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SnsProfile {
  fn default() -> Self {
    SnsProfile{
      sns_user_id: Some("".to_owned()),
      sns_user_name: Some("".to_owned()),
      email: Some("".to_owned()),
      thumbnail_url: Some("".to_owned()),
    }
  }
}

//
// SystemConfiguration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SystemConfiguration {
  pub endpoint: Option<String>,
  pub endpoint_ssl: Option<String>,
  pub update_url: Option<String>,
  pub c2dm_account: Option<String>,
  pub nni_server: Option<String>,
}

impl SystemConfiguration {
  pub fn new<F1, F2, F3, F11, F12>(endpoint: F1, endpoint_ssl: F2, update_url: F3, c2dm_account: F11, nni_server: F12) -> SystemConfiguration where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<String>> {
    SystemConfiguration {
      endpoint: endpoint.into(),
      endpoint_ssl: endpoint_ssl.into(),
      update_url: update_url.into(),
      c2dm_account: c2dm_account.into(),
      nni_server: nni_server.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SystemConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SystemConfiguration {
      endpoint: f_1,
      endpoint_ssl: f_2,
      update_url: f_3,
      c2dm_account: f_11,
      nni_server: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SystemConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.endpoint {
      o_prot.write_field_begin(&TFieldIdentifier::new("endpoint", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.endpoint_ssl {
      o_prot.write_field_begin(&TFieldIdentifier::new("endpointSsl", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.update_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateUrl", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.c2dm_account {
      o_prot.write_field_begin(&TFieldIdentifier::new("c2dmAccount", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nni_server {
      o_prot.write_field_begin(&TFieldIdentifier::new("nniServer", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SystemConfiguration {
  fn default() -> Self {
    SystemConfiguration{
      endpoint: Some("".to_owned()),
      endpoint_ssl: Some("".to_owned()),
      update_url: Some("".to_owned()),
      c2dm_account: Some("".to_owned()),
      nni_server: Some("".to_owned()),
    }
  }
}

//
// TalkException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TalkException {
  pub code: Option<ErrorCode>,
  pub reason: Option<String>,
  pub parameter_map: Option<BTreeMap<String, String>>,
}

impl TalkException {
  pub fn new<F1, F2, F3>(code: F1, reason: F2, parameter_map: F3) -> TalkException where F1: Into<Option<ErrorCode>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    TalkException {
      code: code.into(),
      reason: reason.into(),
      parameter_map: parameter_map.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ErrorCode> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ErrorCode::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_47 = i_prot.read_string()?;
            let map_val_48 = i_prot.read_string()?;
            val.insert(map_key_47, map_val_48);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkException {
      code: f_1,
      reason: f_2,
      parameter_map: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.parameter_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameterMap", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TalkException {
  fn default() -> Self {
    TalkException{
      code: None,
      reason: Some("".to_owned()),
      parameter_map: Some(BTreeMap::new()),
    }
  }
}

impl Error for TalkException {
  fn description(&self) -> &str {
    "remote service threw TalkException"
  }
}

impl From<TalkException> for thrift::Error {
  fn from(e: TalkException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TalkException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// Ticket
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Ticket {
  pub id: Option<String>,
  pub expiration_time: Option<i64>,
  pub max_use_count: Option<i32>,
}

impl Ticket {
  pub fn new<F1, F10, F21>(id: F1, expiration_time: F10, max_use_count: F21) -> Ticket where F1: Into<Option<String>>, F10: Into<Option<i64>>, F21: Into<Option<i32>> {
    Ticket {
      id: id.into(),
      expiration_time: expiration_time.into(),
      max_use_count: max_use_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Ticket> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_10: Option<i64> = Some(0);
    let mut f_21: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        21 => {
          let val = i_prot.read_i32()?;
          f_21 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Ticket {
      id: f_1,
      expiration_time: f_10,
      max_use_count: f_21,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Ticket");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.expiration_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("expirationTime", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_use_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxUseCount", TType::I32, 21))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Ticket {
  fn default() -> Self {
    Ticket{
      id: Some("".to_owned()),
      expiration_time: Some(0),
      max_use_count: Some(0),
    }
  }
}

//
// TMessageBox
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMessageBox {
  pub id: Option<String>,
  pub channel_id: Option<String>,
  pub last_seq: Option<i64>,
  pub unread_count: Option<i64>,
  pub last_modified_time: Option<i64>,
  pub status: Option<i32>,
  pub mid_type: Option<MIDType>,
  pub last_messages: Option<Vec<Message>>,
}

impl TMessageBox {
  pub fn new<F1, F2, F5, F6, F7, F8, F9, F10>(id: F1, channel_id: F2, last_seq: F5, unread_count: F6, last_modified_time: F7, status: F8, mid_type: F9, last_messages: F10) -> TMessageBox where F1: Into<Option<String>>, F2: Into<Option<String>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<i32>>, F9: Into<Option<MIDType>>, F10: Into<Option<Vec<Message>>> {
    TMessageBox {
      id: id.into(),
      channel_id: channel_id.into(),
      last_seq: last_seq.into(),
      unread_count: unread_count.into(),
      last_modified_time: last_modified_time.into(),
      status: status.into(),
      mid_type: mid_type.into(),
      last_messages: last_messages.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMessageBox> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<i32> = Some(0);
    let mut f_9: Option<MIDType> = None;
    let mut f_10: Option<Vec<Message>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = MIDType::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Message> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = Message::read_from_in_protocol(i_prot)?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMessageBox {
      id: f_1,
      channel_id: f_2,
      last_seq: f_5,
      unread_count: f_6,
      last_modified_time: f_7,
      status: f_8,
      mid_type: f_9,
      last_messages: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMessageBox");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.channel_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.last_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastSeq", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.unread_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("unreadCount", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.last_modified_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastModifiedTime", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.mid_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("midType", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.last_messages {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastMessages", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TMessageBox {
  fn default() -> Self {
    TMessageBox{
      id: Some("".to_owned()),
      channel_id: Some("".to_owned()),
      last_seq: Some(0),
      unread_count: Some(0),
      last_modified_time: Some(0),
      status: Some(0),
      mid_type: None,
      last_messages: Some(Vec::new()),
    }
  }
}

//
// TMessageBoxWrapUp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMessageBoxWrapUp {
  pub message_box: Option<TMessageBox>,
  pub name: Option<String>,
  pub contacts: Option<Vec<Contact>>,
  pub picture_revision: Option<String>,
}

impl TMessageBoxWrapUp {
  pub fn new<F1, F2, F3, F4>(message_box: F1, name: F2, contacts: F3, picture_revision: F4) -> TMessageBoxWrapUp where F1: Into<Option<TMessageBox>>, F2: Into<Option<String>>, F3: Into<Option<Vec<Contact>>>, F4: Into<Option<String>> {
    TMessageBoxWrapUp {
      message_box: message_box.into(),
      name: name.into(),
      contacts: contacts.into(),
      picture_revision: picture_revision.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMessageBoxWrapUp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMessageBox> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<Vec<Contact>> = Some(Vec::new());
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMessageBox::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMessageBoxWrapUp {
      message_box: f_1,
      name: f_2,
      contacts: f_3,
      picture_revision: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMessageBoxWrapUp");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message_box {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageBox", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contacts {
      o_prot.write_field_begin(&TFieldIdentifier::new("contacts", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.picture_revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("pictureRevision", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TMessageBoxWrapUp {
  fn default() -> Self {
    TMessageBoxWrapUp{
      message_box: None,
      name: Some("".to_owned()),
      contacts: Some(Vec::new()),
      picture_revision: Some("".to_owned()),
    }
  }
}

//
// TMessageBoxWrapUpResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMessageBoxWrapUpResponse {
  pub message_box_wrap_up_list: Option<Vec<TMessageBoxWrapUp>>,
  pub total_size: Option<i32>,
}

impl TMessageBoxWrapUpResponse {
  pub fn new<F1, F2>(message_box_wrap_up_list: F1, total_size: F2) -> TMessageBoxWrapUpResponse where F1: Into<Option<Vec<TMessageBoxWrapUp>>>, F2: Into<Option<i32>> {
    TMessageBoxWrapUpResponse {
      message_box_wrap_up_list: message_box_wrap_up_list.into(),
      total_size: total_size.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMessageBoxWrapUpResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TMessageBoxWrapUp>> = Some(Vec::new());
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TMessageBoxWrapUp> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = TMessageBoxWrapUp::read_from_in_protocol(i_prot)?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMessageBoxWrapUpResponse {
      message_box_wrap_up_list: f_1,
      total_size: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMessageBoxWrapUpResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message_box_wrap_up_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxWrapUpList", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalSize", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TMessageBoxWrapUpResponse {
  fn default() -> Self {
    TMessageBoxWrapUpResponse{
      message_box_wrap_up_list: Some(Vec::new()),
      total_size: Some(0),
    }
  }
}

//
// UniversalNotificationServiceException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UniversalNotificationServiceException {
  pub code: Option<UniversalNotificationServiceErrorCode>,
  pub reason: Option<String>,
  pub parameter_map: Option<BTreeMap<String, String>>,
}

impl UniversalNotificationServiceException {
  pub fn new<F1, F2, F3>(code: F1, reason: F2, parameter_map: F3) -> UniversalNotificationServiceException where F1: Into<Option<UniversalNotificationServiceErrorCode>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    UniversalNotificationServiceException {
      code: code.into(),
      reason: reason.into(),
      parameter_map: parameter_map.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UniversalNotificationServiceException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UniversalNotificationServiceErrorCode> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = UniversalNotificationServiceErrorCode::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_52 = i_prot.read_string()?;
            let map_val_53 = i_prot.read_string()?;
            val.insert(map_key_52, map_val_53);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UniversalNotificationServiceException {
      code: f_1,
      reason: f_2,
      parameter_map: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UniversalNotificationServiceException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.parameter_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameterMap", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UniversalNotificationServiceException {
  fn default() -> Self {
    UniversalNotificationServiceException{
      code: None,
      reason: Some("".to_owned()),
      parameter_map: Some(BTreeMap::new()),
    }
  }
}

impl Error for UniversalNotificationServiceException {
  fn description(&self) -> &str {
    "remote service threw UniversalNotificationServiceException"
  }
}

impl From<UniversalNotificationServiceException> for thrift::Error {
  fn from(e: UniversalNotificationServiceException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for UniversalNotificationServiceException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// UpdateBuddyProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpdateBuddyProfileResult {
  pub request_id: Option<String>,
  pub state: Option<BuddyResultState>,
  pub event_no: Option<i32>,
  pub receiver_count: Option<i64>,
  pub success_count: Option<i64>,
  pub fail_count: Option<i64>,
  pub cancel_count: Option<i64>,
  pub unregister_count: Option<i64>,
  pub timestamp: Option<i64>,
  pub message: Option<String>,
}

impl UpdateBuddyProfileResult {
  pub fn new<F1, F2, F3, F11, F12, F13, F14, F15, F21, F22>(request_id: F1, state: F2, event_no: F3, receiver_count: F11, success_count: F12, fail_count: F13, cancel_count: F14, unregister_count: F15, timestamp: F21, message: F22) -> UpdateBuddyProfileResult where F1: Into<Option<String>>, F2: Into<Option<BuddyResultState>>, F3: Into<Option<i32>>, F11: Into<Option<i64>>, F12: Into<Option<i64>>, F13: Into<Option<i64>>, F14: Into<Option<i64>>, F15: Into<Option<i64>>, F21: Into<Option<i64>>, F22: Into<Option<String>> {
    UpdateBuddyProfileResult {
      request_id: request_id.into(),
      state: state.into(),
      event_no: event_no.into(),
      receiver_count: receiver_count.into(),
      success_count: success_count.into(),
      fail_count: fail_count.into(),
      cancel_count: cancel_count.into(),
      unregister_count: unregister_count.into(),
      timestamp: timestamp.into(),
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpdateBuddyProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<BuddyResultState> = None;
    let mut f_3: Option<i32> = Some(0);
    let mut f_11: Option<i64> = Some(0);
    let mut f_12: Option<i64> = Some(0);
    let mut f_13: Option<i64> = Some(0);
    let mut f_14: Option<i64> = Some(0);
    let mut f_15: Option<i64> = Some(0);
    let mut f_21: Option<i64> = Some(0);
    let mut f_22: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = BuddyResultState::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        21 => {
          let val = i_prot.read_i64()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpdateBuddyProfileResult {
      request_id: f_1,
      state: f_2,
      event_no: f_3,
      receiver_count: f_11,
      success_count: f_12,
      fail_count: f_13,
      cancel_count: f_14,
      unregister_count: f_15,
      timestamp: f_21,
      message: f_22,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateBuddyProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.event_no {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventNo", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.receiver_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("receiverCount", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.success_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("successCount", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fail_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("failCount", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cancel_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelCount", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.unregister_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("unregisterCount", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 21))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UpdateBuddyProfileResult {
  fn default() -> Self {
    UpdateBuddyProfileResult{
      request_id: Some("".to_owned()),
      state: None,
      event_no: Some(0),
      receiver_count: Some(0),
      success_count: Some(0),
      fail_count: Some(0),
      cancel_count: Some(0),
      unregister_count: Some(0),
      timestamp: Some(0),
      message: Some("".to_owned()),
    }
  }
}

//
// UserAuthStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserAuthStatus {
  pub phone_number_registered: Option<bool>,
  pub registered_sns_id_types: Option<Vec<SnsIdType>>,
}

impl UserAuthStatus {
  pub fn new<F1, F2>(phone_number_registered: F1, registered_sns_id_types: F2) -> UserAuthStatus where F1: Into<Option<bool>>, F2: Into<Option<Vec<SnsIdType>>> {
    UserAuthStatus {
      phone_number_registered: phone_number_registered.into(),
      registered_sns_id_types: registered_sns_id_types.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserAuthStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<Vec<SnsIdType>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SnsIdType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = SnsIdType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserAuthStatus {
      phone_number_registered: f_1,
      registered_sns_id_types: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserAuthStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.phone_number_registered {
      o_prot.write_field_begin(&TFieldIdentifier::new("phoneNumberRegistered", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.registered_sns_id_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("registeredSnsIdTypes", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UserAuthStatus {
  fn default() -> Self {
    UserAuthStatus{
      phone_number_registered: Some(false),
      registered_sns_id_types: Some(Vec::new()),
    }
  }
}

//
// VerificationSessionData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VerificationSessionData {
  pub session_id: Option<String>,
  pub method: Option<VerificationMethod>,
  pub callback: Option<String>,
  pub normalized_phone: Option<String>,
  pub country_code: Option<String>,
  pub national_significant_number: Option<String>,
  pub available_verification_methods: Option<Vec<VerificationMethod>>,
}

impl VerificationSessionData {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(session_id: F1, method: F2, callback: F3, normalized_phone: F4, country_code: F5, national_significant_number: F6, available_verification_methods: F7) -> VerificationSessionData where F1: Into<Option<String>>, F2: Into<Option<VerificationMethod>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<Vec<VerificationMethod>>> {
    VerificationSessionData {
      session_id: session_id.into(),
      method: method.into(),
      callback: callback.into(),
      normalized_phone: normalized_phone.into(),
      country_code: country_code.into(),
      national_significant_number: national_significant_number.into(),
      available_verification_methods: available_verification_methods.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VerificationSessionData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<VerificationMethod> = None;
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<Vec<VerificationMethod>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = VerificationMethod::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<VerificationMethod> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = VerificationMethod::read_from_in_protocol(i_prot)?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = VerificationSessionData {
      session_id: f_1,
      method: f_2,
      callback: f_3,
      normalized_phone: f_4,
      country_code: f_5,
      national_significant_number: f_6,
      available_verification_methods: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("VerificationSessionData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.method {
      o_prot.write_field_begin(&TFieldIdentifier::new("method", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.callback {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.normalized_phone {
      o_prot.write_field_begin(&TFieldIdentifier::new("normalizedPhone", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.country_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("countryCode", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.national_significant_number {
      o_prot.write_field_begin(&TFieldIdentifier::new("nationalSignificantNumber", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.available_verification_methods {
      o_prot.write_field_begin(&TFieldIdentifier::new("availableVerificationMethods", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for VerificationSessionData {
  fn default() -> Self {
    VerificationSessionData{
      session_id: Some("".to_owned()),
      method: None,
      callback: Some("".to_owned()),
      normalized_phone: Some("".to_owned()),
      country_code: Some("".to_owned()),
      national_significant_number: Some("".to_owned()),
      available_verification_methods: Some(Vec::new()),
    }
  }
}

//
// WapInvitation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WapInvitation {
  pub type_: Option<WapInvitationType>,
  pub invitee_email: Option<String>,
  pub inviter_mid: Option<String>,
  pub room_mid: Option<String>,
}

impl WapInvitation {
  pub fn new<F1, F10, F11, F12>(type_: F1, invitee_email: F10, inviter_mid: F11, room_mid: F12) -> WapInvitation where F1: Into<Option<WapInvitationType>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<String>> {
    WapInvitation {
      type_: type_.into(),
      invitee_email: invitee_email.into(),
      inviter_mid: inviter_mid.into(),
      room_mid: room_mid.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WapInvitation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WapInvitationType> = None;
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WapInvitationType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WapInvitation {
      type_: f_1,
      invitee_email: f_10,
      inviter_mid: f_11,
      room_mid: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WapInvitation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.invitee_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("inviteeEmail", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.inviter_mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("inviterMid", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.room_mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("roomMid", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WapInvitation {
  fn default() -> Self {
    WapInvitation{
      type_: None,
      invitee_email: Some("".to_owned()),
      inviter_mid: Some("".to_owned()),
      room_mid: Some("".to_owned()),
    }
  }
}

//
// AccountSupervisorService service client
//

pub trait TAccountSupervisorServiceSyncClient {
  fn get_r_s_a_key(&mut self) -> thrift::Result<RSAKey>;
  fn notify_email_confirmation_result(&mut self, parameter_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn register_virtual_account(&mut self, locale: String, encrypted_virtual_user_id: String, encrypted_password: String) -> thrift::Result<String>;
  fn request_virtual_account_password_change(&mut self, virtual_mid: String, encrypted_virtual_user_id: String, encrypted_old_password: String, encrypted_new_password: String) -> thrift::Result<()>;
  fn request_virtual_account_password_set(&mut self, virtual_mid: String, encrypted_virtual_user_id: String, encrypted_new_password: String) -> thrift::Result<()>;
  fn unregister_virtual_account(&mut self, virtual_mid: String) -> thrift::Result<()>;
}

pub trait TAccountSupervisorServiceSyncClientMarker {}

pub struct AccountSupervisorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> AccountSupervisorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> AccountSupervisorServiceSyncClient<IP, OP> {
    AccountSupervisorServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for AccountSupervisorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TAccountSupervisorServiceSyncClientMarker for AccountSupervisorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TAccountSupervisorServiceSyncClientMarker> TAccountSupervisorServiceSyncClient for C {
  fn get_r_s_a_key(&mut self) -> thrift::Result<RSAKey> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getRSAKey", TMessageType::Call, self.sequence_number());
        let call_args = AccountSupervisorServiceGetRSAKeyArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getRSAKey", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AccountSupervisorServiceGetRSAKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_email_confirmation_result(&mut self, parameter_map: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyEmailConfirmationResult", TMessageType::Call, self.sequence_number());
        let call_args = AccountSupervisorServiceNotifyEmailConfirmationResultArgs { parameter_map: parameter_map };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyEmailConfirmationResult", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AccountSupervisorServiceNotifyEmailConfirmationResultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_virtual_account(&mut self, locale: String, encrypted_virtual_user_id: String, encrypted_password: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerVirtualAccount", TMessageType::Call, self.sequence_number());
        let call_args = AccountSupervisorServiceRegisterVirtualAccountArgs { locale: locale, encrypted_virtual_user_id: encrypted_virtual_user_id, encrypted_password: encrypted_password };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerVirtualAccount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AccountSupervisorServiceRegisterVirtualAccountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_virtual_account_password_change(&mut self, virtual_mid: String, encrypted_virtual_user_id: String, encrypted_old_password: String, encrypted_new_password: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordChange", TMessageType::Call, self.sequence_number());
        let call_args = AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs { virtual_mid: virtual_mid, encrypted_virtual_user_id: encrypted_virtual_user_id, encrypted_old_password: encrypted_old_password, encrypted_new_password: encrypted_new_password };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestVirtualAccountPasswordChange", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_virtual_account_password_set(&mut self, virtual_mid: String, encrypted_virtual_user_id: String, encrypted_new_password: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordSet", TMessageType::Call, self.sequence_number());
        let call_args = AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs { virtual_mid: virtual_mid, encrypted_virtual_user_id: encrypted_virtual_user_id, encrypted_new_password: encrypted_new_password };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestVirtualAccountPasswordSet", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AccountSupervisorServiceRequestVirtualAccountPasswordSetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unregister_virtual_account(&mut self, virtual_mid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unregisterVirtualAccount", TMessageType::Call, self.sequence_number());
        let call_args = AccountSupervisorServiceUnregisterVirtualAccountArgs { virtual_mid: virtual_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unregisterVirtualAccount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AccountSupervisorServiceUnregisterVirtualAccountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// AccountSupervisorService service processor
//

pub trait AccountSupervisorServiceSyncHandler {
  fn handle_get_r_s_a_key(&self) -> thrift::Result<RSAKey>;
  fn handle_notify_email_confirmation_result(&self, parameter_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn handle_register_virtual_account(&self, locale: String, encrypted_virtual_user_id: String, encrypted_password: String) -> thrift::Result<String>;
  fn handle_request_virtual_account_password_change(&self, virtual_mid: String, encrypted_virtual_user_id: String, encrypted_old_password: String, encrypted_new_password: String) -> thrift::Result<()>;
  fn handle_request_virtual_account_password_set(&self, virtual_mid: String, encrypted_virtual_user_id: String, encrypted_new_password: String) -> thrift::Result<()>;
  fn handle_unregister_virtual_account(&self, virtual_mid: String) -> thrift::Result<()>;
}

pub struct AccountSupervisorServiceSyncProcessor<H: AccountSupervisorServiceSyncHandler> {
  handler: H,
}

impl <H: AccountSupervisorServiceSyncHandler> AccountSupervisorServiceSyncProcessor<H> {
  pub fn new(handler: H) -> AccountSupervisorServiceSyncProcessor<H> {
    AccountSupervisorServiceSyncProcessor {
      handler,
    }
  }
  fn process_get_r_s_a_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAccountSupervisorServiceProcessFunctions::process_get_r_s_a_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_email_confirmation_result(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAccountSupervisorServiceProcessFunctions::process_notify_email_confirmation_result(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_virtual_account(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAccountSupervisorServiceProcessFunctions::process_register_virtual_account(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_virtual_account_password_change(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAccountSupervisorServiceProcessFunctions::process_request_virtual_account_password_change(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_virtual_account_password_set(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAccountSupervisorServiceProcessFunctions::process_request_virtual_account_password_set(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unregister_virtual_account(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAccountSupervisorServiceProcessFunctions::process_unregister_virtual_account(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TAccountSupervisorServiceProcessFunctions;

impl TAccountSupervisorServiceProcessFunctions {
  pub fn process_get_r_s_a_key<H: AccountSupervisorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = AccountSupervisorServiceGetRSAKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_r_s_a_key() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getRSAKey", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AccountSupervisorServiceGetRSAKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AccountSupervisorServiceGetRSAKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getRSAKey", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getRSAKey", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getRSAKey", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getRSAKey", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_email_confirmation_result<H: AccountSupervisorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AccountSupervisorServiceNotifyEmailConfirmationResultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_email_confirmation_result(args.parameter_map) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifyEmailConfirmationResult", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AccountSupervisorServiceNotifyEmailConfirmationResultResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AccountSupervisorServiceNotifyEmailConfirmationResultResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifyEmailConfirmationResult", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifyEmailConfirmationResult", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyEmailConfirmationResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyEmailConfirmationResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_virtual_account<H: AccountSupervisorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AccountSupervisorServiceRegisterVirtualAccountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_virtual_account(args.locale, args.encrypted_virtual_user_id, args.encrypted_password) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerVirtualAccount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AccountSupervisorServiceRegisterVirtualAccountResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AccountSupervisorServiceRegisterVirtualAccountResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerVirtualAccount", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerVirtualAccount", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerVirtualAccount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerVirtualAccount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_virtual_account_password_change<H: AccountSupervisorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_virtual_account_password_change(args.virtual_mid, args.encrypted_virtual_user_id, args.encrypted_old_password, args.encrypted_new_password) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordChange", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordChange", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordChange", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordChange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordChange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_virtual_account_password_set<H: AccountSupervisorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_virtual_account_password_set(args.virtual_mid, args.encrypted_virtual_user_id, args.encrypted_new_password) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordSet", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AccountSupervisorServiceRequestVirtualAccountPasswordSetResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AccountSupervisorServiceRequestVirtualAccountPasswordSetResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordSet", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordSet", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordSet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("requestVirtualAccountPasswordSet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unregister_virtual_account<H: AccountSupervisorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AccountSupervisorServiceUnregisterVirtualAccountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unregister_virtual_account(args.virtual_mid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unregisterVirtualAccount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AccountSupervisorServiceUnregisterVirtualAccountResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AccountSupervisorServiceUnregisterVirtualAccountResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unregisterVirtualAccount", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unregisterVirtualAccount", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unregisterVirtualAccount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unregisterVirtualAccount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: AccountSupervisorServiceSyncHandler> TProcessor for AccountSupervisorServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "getRSAKey" => {
        self.process_get_r_s_a_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyEmailConfirmationResult" => {
        self.process_notify_email_confirmation_result(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerVirtualAccount" => {
        self.process_register_virtual_account(message_ident.sequence_number, i_prot, o_prot)
      },
      "requestVirtualAccountPasswordChange" => {
        self.process_request_virtual_account_password_change(message_ident.sequence_number, i_prot, o_prot)
      },
      "requestVirtualAccountPasswordSet" => {
        self.process_request_virtual_account_password_set(message_ident.sequence_number, i_prot, o_prot)
      },
      "unregisterVirtualAccount" => {
        self.process_unregister_virtual_account(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// AccountSupervisorServiceGetRSAKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceGetRSAKeyArgs {
}

impl AccountSupervisorServiceGetRSAKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceGetRSAKeyArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountSupervisorServiceGetRSAKeyArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getRSAKey_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AccountSupervisorServiceGetRSAKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceGetRSAKeyResult {
  result_value: Option<RSAKey>,
  e: Option<TalkException>,
}

impl AccountSupervisorServiceGetRSAKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceGetRSAKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<RSAKey> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = RSAKey::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountSupervisorServiceGetRSAKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccountSupervisorServiceGetRSAKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<RSAKey> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for AccountSupervisorServiceGetRSAKey"
          )
        )
      )
    }
  }
}

//
// AccountSupervisorServiceNotifyEmailConfirmationResultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceNotifyEmailConfirmationResultArgs {
  parameter_map: BTreeMap<String, String>,
}

impl AccountSupervisorServiceNotifyEmailConfirmationResultArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceNotifyEmailConfirmationResultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_56 = i_prot.read_string()?;
            let map_val_57 = i_prot.read_string()?;
            val.insert(map_key_56, map_val_57);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AccountSupervisorServiceNotifyEmailConfirmationResultArgs.parameter_map", &f_2)?;
    let ret = AccountSupervisorServiceNotifyEmailConfirmationResultArgs {
      parameter_map: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyEmailConfirmationResult_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parameterMap", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.parameter_map.len() as i32))?;
    for (k, v) in &self.parameter_map {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AccountSupervisorServiceNotifyEmailConfirmationResultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceNotifyEmailConfirmationResultResult {
  e: Option<TalkException>,
}

impl AccountSupervisorServiceNotifyEmailConfirmationResultResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceNotifyEmailConfirmationResultResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountSupervisorServiceNotifyEmailConfirmationResultResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccountSupervisorServiceNotifyEmailConfirmationResultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// AccountSupervisorServiceRegisterVirtualAccountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceRegisterVirtualAccountArgs {
  locale: String,
  encrypted_virtual_user_id: String,
  encrypted_password: String,
}

impl AccountSupervisorServiceRegisterVirtualAccountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceRegisterVirtualAccountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AccountSupervisorServiceRegisterVirtualAccountArgs.locale", &f_2)?;
    verify_required_field_exists("AccountSupervisorServiceRegisterVirtualAccountArgs.encrypted_virtual_user_id", &f_3)?;
    verify_required_field_exists("AccountSupervisorServiceRegisterVirtualAccountArgs.encrypted_password", &f_4)?;
    let ret = AccountSupervisorServiceRegisterVirtualAccountArgs {
      locale: f_2.expect("auto-generated code should have checked for presence of required fields"),
      encrypted_virtual_user_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encrypted_password: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerVirtualAccount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 2))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encryptedVirtualUserId", TType::String, 3))?;
    o_prot.write_string(&self.encrypted_virtual_user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encryptedPassword", TType::String, 4))?;
    o_prot.write_string(&self.encrypted_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AccountSupervisorServiceRegisterVirtualAccountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceRegisterVirtualAccountResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl AccountSupervisorServiceRegisterVirtualAccountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceRegisterVirtualAccountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountSupervisorServiceRegisterVirtualAccountResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccountSupervisorServiceRegisterVirtualAccountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for AccountSupervisorServiceRegisterVirtualAccount"
          )
        )
      )
    }
  }
}

//
// AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs {
  virtual_mid: String,
  encrypted_virtual_user_id: String,
  encrypted_old_password: String,
  encrypted_new_password: String,
}

impl AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs.virtual_mid", &f_2)?;
    verify_required_field_exists("AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs.encrypted_virtual_user_id", &f_3)?;
    verify_required_field_exists("AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs.encrypted_old_password", &f_4)?;
    verify_required_field_exists("AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs.encrypted_new_password", &f_5)?;
    let ret = AccountSupervisorServiceRequestVirtualAccountPasswordChangeArgs {
      virtual_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      encrypted_virtual_user_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encrypted_old_password: f_4.expect("auto-generated code should have checked for presence of required fields"),
      encrypted_new_password: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestVirtualAccountPasswordChange_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("virtualMid", TType::String, 2))?;
    o_prot.write_string(&self.virtual_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encryptedVirtualUserId", TType::String, 3))?;
    o_prot.write_string(&self.encrypted_virtual_user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encryptedOldPassword", TType::String, 4))?;
    o_prot.write_string(&self.encrypted_old_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encryptedNewPassword", TType::String, 5))?;
    o_prot.write_string(&self.encrypted_new_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult {
  e: Option<TalkException>,
}

impl AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccountSupervisorServiceRequestVirtualAccountPasswordChangeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs {
  virtual_mid: String,
  encrypted_virtual_user_id: String,
  encrypted_new_password: String,
}

impl AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs.virtual_mid", &f_2)?;
    verify_required_field_exists("AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs.encrypted_virtual_user_id", &f_3)?;
    verify_required_field_exists("AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs.encrypted_new_password", &f_4)?;
    let ret = AccountSupervisorServiceRequestVirtualAccountPasswordSetArgs {
      virtual_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      encrypted_virtual_user_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encrypted_new_password: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestVirtualAccountPasswordSet_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("virtualMid", TType::String, 2))?;
    o_prot.write_string(&self.virtual_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encryptedVirtualUserId", TType::String, 3))?;
    o_prot.write_string(&self.encrypted_virtual_user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encryptedNewPassword", TType::String, 4))?;
    o_prot.write_string(&self.encrypted_new_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AccountSupervisorServiceRequestVirtualAccountPasswordSetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceRequestVirtualAccountPasswordSetResult {
  e: Option<TalkException>,
}

impl AccountSupervisorServiceRequestVirtualAccountPasswordSetResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceRequestVirtualAccountPasswordSetResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountSupervisorServiceRequestVirtualAccountPasswordSetResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccountSupervisorServiceRequestVirtualAccountPasswordSetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// AccountSupervisorServiceUnregisterVirtualAccountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceUnregisterVirtualAccountArgs {
  virtual_mid: String,
}

impl AccountSupervisorServiceUnregisterVirtualAccountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceUnregisterVirtualAccountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AccountSupervisorServiceUnregisterVirtualAccountArgs.virtual_mid", &f_2)?;
    let ret = AccountSupervisorServiceUnregisterVirtualAccountArgs {
      virtual_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unregisterVirtualAccount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("virtualMid", TType::String, 2))?;
    o_prot.write_string(&self.virtual_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AccountSupervisorServiceUnregisterVirtualAccountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AccountSupervisorServiceUnregisterVirtualAccountResult {
  e: Option<TalkException>,
}

impl AccountSupervisorServiceUnregisterVirtualAccountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountSupervisorServiceUnregisterVirtualAccountResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountSupervisorServiceUnregisterVirtualAccountResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccountSupervisorServiceUnregisterVirtualAccountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// AgeCheckService service client
//

pub trait TAgeCheckServiceSyncClient {
  fn check_user_age(&mut self, carrier: CarrierCode, session_id: String, verifier: String, standard_age: i32) -> thrift::Result<UserAgeType>;
  fn check_user_age_with_docomo(&mut self, open_id_redirect_url: String, standard_age: i32, verifier: String) -> thrift::Result<AgeCheckDocomoResult>;
  fn retrieve_open_id_auth_url_with_docomo(&mut self) -> thrift::Result<String>;
  fn retrieve_request_token(&mut self, carrier: CarrierCode) -> thrift::Result<AgeCheckRequestResult>;
}

pub trait TAgeCheckServiceSyncClientMarker {}

pub struct AgeCheckServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> AgeCheckServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> AgeCheckServiceSyncClient<IP, OP> {
    AgeCheckServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for AgeCheckServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TAgeCheckServiceSyncClientMarker for AgeCheckServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TAgeCheckServiceSyncClientMarker> TAgeCheckServiceSyncClient for C {
  fn check_user_age(&mut self, carrier: CarrierCode, session_id: String, verifier: String, standard_age: i32) -> thrift::Result<UserAgeType> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("checkUserAge", TMessageType::Call, self.sequence_number());
        let call_args = AgeCheckServiceCheckUserAgeArgs { carrier: carrier, session_id: session_id, verifier: verifier, standard_age: standard_age };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("checkUserAge", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AgeCheckServiceCheckUserAgeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_user_age_with_docomo(&mut self, open_id_redirect_url: String, standard_age: i32, verifier: String) -> thrift::Result<AgeCheckDocomoResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("checkUserAgeWithDocomo", TMessageType::Call, self.sequence_number());
        let call_args = AgeCheckServiceCheckUserAgeWithDocomoArgs { open_id_redirect_url: open_id_redirect_url, standard_age: standard_age, verifier: verifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("checkUserAgeWithDocomo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AgeCheckServiceCheckUserAgeWithDocomoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn retrieve_open_id_auth_url_with_docomo(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("retrieveOpenIdAuthUrlWithDocomo", TMessageType::Call, self.sequence_number());
        let call_args = AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("retrieveOpenIdAuthUrlWithDocomo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn retrieve_request_token(&mut self, carrier: CarrierCode) -> thrift::Result<AgeCheckRequestResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("retrieveRequestToken", TMessageType::Call, self.sequence_number());
        let call_args = AgeCheckServiceRetrieveRequestTokenArgs { carrier: carrier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("retrieveRequestToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = AgeCheckServiceRetrieveRequestTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// AgeCheckService service processor
//

pub trait AgeCheckServiceSyncHandler {
  fn handle_check_user_age(&self, carrier: CarrierCode, session_id: String, verifier: String, standard_age: i32) -> thrift::Result<UserAgeType>;
  fn handle_check_user_age_with_docomo(&self, open_id_redirect_url: String, standard_age: i32, verifier: String) -> thrift::Result<AgeCheckDocomoResult>;
  fn handle_retrieve_open_id_auth_url_with_docomo(&self) -> thrift::Result<String>;
  fn handle_retrieve_request_token(&self, carrier: CarrierCode) -> thrift::Result<AgeCheckRequestResult>;
}

pub struct AgeCheckServiceSyncProcessor<H: AgeCheckServiceSyncHandler> {
  handler: H,
}

impl <H: AgeCheckServiceSyncHandler> AgeCheckServiceSyncProcessor<H> {
  pub fn new(handler: H) -> AgeCheckServiceSyncProcessor<H> {
    AgeCheckServiceSyncProcessor {
      handler,
    }
  }
  fn process_check_user_age(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAgeCheckServiceProcessFunctions::process_check_user_age(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_user_age_with_docomo(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAgeCheckServiceProcessFunctions::process_check_user_age_with_docomo(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_retrieve_open_id_auth_url_with_docomo(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAgeCheckServiceProcessFunctions::process_retrieve_open_id_auth_url_with_docomo(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_retrieve_request_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TAgeCheckServiceProcessFunctions::process_retrieve_request_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TAgeCheckServiceProcessFunctions;

impl TAgeCheckServiceProcessFunctions {
  pub fn process_check_user_age<H: AgeCheckServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AgeCheckServiceCheckUserAgeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_user_age(args.carrier, args.session_id, args.verifier, args.standard_age) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("checkUserAge", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AgeCheckServiceCheckUserAgeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AgeCheckServiceCheckUserAgeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("checkUserAge", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("checkUserAge", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("checkUserAge", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("checkUserAge", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_user_age_with_docomo<H: AgeCheckServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AgeCheckServiceCheckUserAgeWithDocomoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_user_age_with_docomo(args.open_id_redirect_url, args.standard_age, args.verifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("checkUserAgeWithDocomo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AgeCheckServiceCheckUserAgeWithDocomoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AgeCheckServiceCheckUserAgeWithDocomoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("checkUserAgeWithDocomo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("checkUserAgeWithDocomo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("checkUserAgeWithDocomo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("checkUserAgeWithDocomo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_retrieve_open_id_auth_url_with_docomo<H: AgeCheckServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_retrieve_open_id_auth_url_with_docomo() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("retrieveOpenIdAuthUrlWithDocomo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("retrieveOpenIdAuthUrlWithDocomo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("retrieveOpenIdAuthUrlWithDocomo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("retrieveOpenIdAuthUrlWithDocomo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("retrieveOpenIdAuthUrlWithDocomo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_retrieve_request_token<H: AgeCheckServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = AgeCheckServiceRetrieveRequestTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_retrieve_request_token(args.carrier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("retrieveRequestToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = AgeCheckServiceRetrieveRequestTokenResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = AgeCheckServiceRetrieveRequestTokenResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("retrieveRequestToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("retrieveRequestToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("retrieveRequestToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("retrieveRequestToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: AgeCheckServiceSyncHandler> TProcessor for AgeCheckServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "checkUserAge" => {
        self.process_check_user_age(message_ident.sequence_number, i_prot, o_prot)
      },
      "checkUserAgeWithDocomo" => {
        self.process_check_user_age_with_docomo(message_ident.sequence_number, i_prot, o_prot)
      },
      "retrieveOpenIdAuthUrlWithDocomo" => {
        self.process_retrieve_open_id_auth_url_with_docomo(message_ident.sequence_number, i_prot, o_prot)
      },
      "retrieveRequestToken" => {
        self.process_retrieve_request_token(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// AgeCheckServiceCheckUserAgeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceCheckUserAgeArgs {
  carrier: CarrierCode,
  session_id: String,
  verifier: String,
  standard_age: i32,
}

impl AgeCheckServiceCheckUserAgeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceCheckUserAgeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CarrierCode> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CarrierCode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AgeCheckServiceCheckUserAgeArgs.carrier", &f_2)?;
    verify_required_field_exists("AgeCheckServiceCheckUserAgeArgs.session_id", &f_3)?;
    verify_required_field_exists("AgeCheckServiceCheckUserAgeArgs.verifier", &f_4)?;
    verify_required_field_exists("AgeCheckServiceCheckUserAgeArgs.standard_age", &f_5)?;
    let ret = AgeCheckServiceCheckUserAgeArgs {
      carrier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      session_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      verifier: f_4.expect("auto-generated code should have checked for presence of required fields"),
      standard_age: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("checkUserAge_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("carrier", TType::I32, 2))?;
    self.carrier.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 3))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 4))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("standardAge", TType::I32, 5))?;
    o_prot.write_i32(self.standard_age)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AgeCheckServiceCheckUserAgeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceCheckUserAgeResult {
  result_value: Option<UserAgeType>,
  e: Option<TalkException>,
}

impl AgeCheckServiceCheckUserAgeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceCheckUserAgeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UserAgeType> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UserAgeType::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AgeCheckServiceCheckUserAgeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AgeCheckServiceCheckUserAgeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<UserAgeType> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for AgeCheckServiceCheckUserAge"
          )
        )
      )
    }
  }
}

//
// AgeCheckServiceCheckUserAgeWithDocomoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceCheckUserAgeWithDocomoArgs {
  open_id_redirect_url: String,
  standard_age: i32,
  verifier: String,
}

impl AgeCheckServiceCheckUserAgeWithDocomoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceCheckUserAgeWithDocomoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AgeCheckServiceCheckUserAgeWithDocomoArgs.open_id_redirect_url", &f_2)?;
    verify_required_field_exists("AgeCheckServiceCheckUserAgeWithDocomoArgs.standard_age", &f_3)?;
    verify_required_field_exists("AgeCheckServiceCheckUserAgeWithDocomoArgs.verifier", &f_4)?;
    let ret = AgeCheckServiceCheckUserAgeWithDocomoArgs {
      open_id_redirect_url: f_2.expect("auto-generated code should have checked for presence of required fields"),
      standard_age: f_3.expect("auto-generated code should have checked for presence of required fields"),
      verifier: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("checkUserAgeWithDocomo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("openIdRedirectUrl", TType::String, 2))?;
    o_prot.write_string(&self.open_id_redirect_url)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("standardAge", TType::I32, 3))?;
    o_prot.write_i32(self.standard_age)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 4))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AgeCheckServiceCheckUserAgeWithDocomoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceCheckUserAgeWithDocomoResult {
  result_value: Option<AgeCheckDocomoResult>,
  e: Option<TalkException>,
}

impl AgeCheckServiceCheckUserAgeWithDocomoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceCheckUserAgeWithDocomoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AgeCheckDocomoResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AgeCheckDocomoResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AgeCheckServiceCheckUserAgeWithDocomoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AgeCheckServiceCheckUserAgeWithDocomoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AgeCheckDocomoResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for AgeCheckServiceCheckUserAgeWithDocomo"
          )
        )
      )
    }
  }
}

//
// AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoArgs {
}

impl AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("retrieveOpenIdAuthUrlWithDocomo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for AgeCheckServiceRetrieveOpenIdAuthUrlWithDocomo"
          )
        )
      )
    }
  }
}

//
// AgeCheckServiceRetrieveRequestTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceRetrieveRequestTokenArgs {
  carrier: CarrierCode,
}

impl AgeCheckServiceRetrieveRequestTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceRetrieveRequestTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CarrierCode> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CarrierCode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AgeCheckServiceRetrieveRequestTokenArgs.carrier", &f_2)?;
    let ret = AgeCheckServiceRetrieveRequestTokenArgs {
      carrier: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("retrieveRequestToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("carrier", TType::I32, 2))?;
    self.carrier.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AgeCheckServiceRetrieveRequestTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct AgeCheckServiceRetrieveRequestTokenResult {
  result_value: Option<AgeCheckRequestResult>,
  e: Option<TalkException>,
}

impl AgeCheckServiceRetrieveRequestTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AgeCheckServiceRetrieveRequestTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AgeCheckRequestResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AgeCheckRequestResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AgeCheckServiceRetrieveRequestTokenResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AgeCheckServiceRetrieveRequestTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AgeCheckRequestResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for AgeCheckServiceRetrieveRequestToken"
          )
        )
      )
    }
  }
}

//
// BuddyManagementService service client
//

pub trait TBuddyManagementServiceSyncClient {
  fn add_buddy_member(&mut self, request_id: String, user_mid: String) -> thrift::Result<()>;
  fn add_buddy_members(&mut self, request_id: String, user_mids: Vec<String>) -> thrift::Result<()>;
  fn block_buddy_member(&mut self, request_id: String, mid: String) -> thrift::Result<()>;
  fn commit_send_messages_to_all(&mut self, request_id_list: Vec<String>) -> thrift::Result<Vec<SendBuddyMessageResult>>;
  fn commit_send_messages_to_mids(&mut self, request_id_list: Vec<String>, mids: Vec<String>) -> thrift::Result<Vec<SendBuddyMessageResult>>;
  fn contains_buddy_member(&mut self, request_id: String, user_mid: String) -> thrift::Result<bool>;
  fn download_message_content(&mut self, request_id: String, message_id: String) -> thrift::Result<Vec<u8>>;
  fn download_message_content_preview(&mut self, request_id: String, message_id: String) -> thrift::Result<Vec<u8>>;
  fn download_profile_image(&mut self, request_id: String) -> thrift::Result<Vec<u8>>;
  fn download_profile_image_preview(&mut self, request_id: String) -> thrift::Result<Vec<u8>>;
  fn get_active_member_count_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<i64>;
  fn get_active_member_mids_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<Vec<String>>;
  fn get_all_buddy_members(&mut self) -> thrift::Result<Vec<String>>;
  fn get_blocked_buddy_members(&mut self) -> thrift::Result<Vec<String>>;
  fn get_blocker_count_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<i64>;
  fn get_buddy_detail_by_mid(&mut self, buddy_mid: String) -> thrift::Result<BuddyDetail>;
  fn get_buddy_profile(&mut self) -> thrift::Result<BuddyProfile>;
  fn get_contact_ticket(&mut self) -> thrift::Result<Ticket>;
  fn get_member_count_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<i64>;
  fn get_send_buddy_message_result(&mut self, send_buddy_message_request_id: String) -> thrift::Result<SendBuddyMessageResult>;
  fn get_set_buddy_on_air_result(&mut self, set_buddy_on_air_request_id: String) -> thrift::Result<SetBuddyOnAirResult>;
  fn get_update_buddy_profile_result(&mut self, update_buddy_profile_request_id: String) -> thrift::Result<UpdateBuddyProfileResult>;
  fn is_buddy_on_air_by_mid(&mut self, buddy_mid: String) -> thrift::Result<bool>;
  fn link_and_send_buddy_content_message_to_all_async(&mut self, request_id: String, msg: Message, source_content_id: String) -> thrift::Result<String>;
  fn link_and_send_buddy_content_message_to_mids(&mut self, request_id: String, msg: Message, source_content_id: String, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult>;
  fn notify_buddy_blocked(&mut self, buddy_mid: String, blocker_mid: String) -> thrift::Result<()>;
  fn notify_buddy_unblocked(&mut self, buddy_mid: String, blocker_mid: String) -> thrift::Result<()>;
  fn register_buddy(&mut self, buddy_id: String, search_id: String, display_name: String, status_meessage: String, picture: Vec<u8>, settings: BTreeMap<String, String>) -> thrift::Result<String>;
  fn register_buddy_admin(&mut self, buddy_id: String, search_id: String, display_name: String, status_message: String, picture: Vec<u8>) -> thrift::Result<String>;
  fn reissue_contact_ticket(&mut self, expiration_time: i64, max_use_count: i32) -> thrift::Result<String>;
  fn remove_buddy_member(&mut self, request_id: String, user_mid: String) -> thrift::Result<()>;
  fn remove_buddy_members(&mut self, request_id: String, user_mids: Vec<String>) -> thrift::Result<()>;
  fn send_buddy_content_message_to_all(&mut self, request_id: String, msg: Message, content: Vec<u8>) -> thrift::Result<SendBuddyMessageResult>;
  fn send_buddy_content_message_to_all_async(&mut self, request_id: String, msg: Message, content: Vec<u8>) -> thrift::Result<String>;
  fn send_buddy_content_message_to_mids(&mut self, request_id: String, msg: Message, content: Vec<u8>, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult>;
  fn send_buddy_content_message_to_mids_async(&mut self, request_id: String, msg: Message, content: Vec<u8>, mids: Vec<String>) -> thrift::Result<String>;
  fn send_buddy_message_to_all(&mut self, request_id: String, msg: Message) -> thrift::Result<SendBuddyMessageResult>;
  fn send_buddy_message_to_all_async(&mut self, request_id: String, msg: Message) -> thrift::Result<String>;
  fn send_buddy_message_to_mids(&mut self, request_id: String, msg: Message, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult>;
  fn send_buddy_message_to_mids_async(&mut self, request_id: String, msg: Message, mids: Vec<String>) -> thrift::Result<String>;
  fn send_individual_event_to_all_async(&mut self, request_id: String, buddy_mid: String, notification_status: NotificationStatus) -> thrift::Result<()>;
  fn set_buddy_on_air(&mut self, request_id: String, on_air: bool) -> thrift::Result<SetBuddyOnAirResult>;
  fn set_buddy_on_air_async(&mut self, request_id: String, on_air: bool) -> thrift::Result<String>;
  fn store_message(&mut self, request_id: String, message_request: BuddyMessageRequest) -> thrift::Result<SendBuddyMessageResult>;
  fn unblock_buddy_member(&mut self, request_id: String, mid: String) -> thrift::Result<()>;
  fn unregister_buddy(&mut self, request_id: String) -> thrift::Result<()>;
  fn unregister_buddy_admin(&mut self, request_id: String) -> thrift::Result<()>;
  fn update_buddy_admin_profile_attribute(&mut self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<()>;
  fn update_buddy_admin_profile_image(&mut self, request_id: String, picture: Vec<u8>) -> thrift::Result<()>;
  fn update_buddy_profile_attributes(&mut self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<UpdateBuddyProfileResult>;
  fn update_buddy_profile_attributes_async(&mut self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<String>;
  fn update_buddy_profile_image(&mut self, request_id: String, image: Vec<u8>) -> thrift::Result<UpdateBuddyProfileResult>;
  fn update_buddy_profile_image_async(&mut self, request_id: String, image: Vec<u8>) -> thrift::Result<String>;
  fn update_buddy_search_id(&mut self, request_id: String, search_id: String) -> thrift::Result<()>;
  fn update_buddy_settings(&mut self, settings: BTreeMap<String, String>) -> thrift::Result<()>;
  fn upload_buddy_content(&mut self, content_type: ContentType, content: Vec<u8>) -> thrift::Result<String>;
}

pub trait TBuddyManagementServiceSyncClientMarker {}

pub struct BuddyManagementServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> BuddyManagementServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> BuddyManagementServiceSyncClient<IP, OP> {
    BuddyManagementServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for BuddyManagementServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TBuddyManagementServiceSyncClientMarker for BuddyManagementServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TBuddyManagementServiceSyncClientMarker> TBuddyManagementServiceSyncClient for C {
  fn add_buddy_member(&mut self, request_id: String, user_mid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("addBuddyMember", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceAddBuddyMemberArgs { request_id: request_id, user_mid: user_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("addBuddyMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceAddBuddyMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_buddy_members(&mut self, request_id: String, user_mids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("addBuddyMembers", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceAddBuddyMembersArgs { request_id: request_id, user_mids: user_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("addBuddyMembers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceAddBuddyMembersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn block_buddy_member(&mut self, request_id: String, mid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("blockBuddyMember", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceBlockBuddyMemberArgs { request_id: request_id, mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("blockBuddyMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceBlockBuddyMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn commit_send_messages_to_all(&mut self, request_id_list: Vec<String>) -> thrift::Result<Vec<SendBuddyMessageResult>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("commitSendMessagesToAll", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceCommitSendMessagesToAllArgs { request_id_list: request_id_list };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("commitSendMessagesToAll", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceCommitSendMessagesToAllResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn commit_send_messages_to_mids(&mut self, request_id_list: Vec<String>, mids: Vec<String>) -> thrift::Result<Vec<SendBuddyMessageResult>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("commitSendMessagesToMids", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceCommitSendMessagesToMidsArgs { request_id_list: request_id_list, mids: mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("commitSendMessagesToMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceCommitSendMessagesToMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn contains_buddy_member(&mut self, request_id: String, user_mid: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("containsBuddyMember", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceContainsBuddyMemberArgs { request_id: request_id, user_mid: user_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("containsBuddyMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceContainsBuddyMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn download_message_content(&mut self, request_id: String, message_id: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("downloadMessageContent", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceDownloadMessageContentArgs { request_id: request_id, message_id: message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("downloadMessageContent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceDownloadMessageContentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn download_message_content_preview(&mut self, request_id: String, message_id: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("downloadMessageContentPreview", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceDownloadMessageContentPreviewArgs { request_id: request_id, message_id: message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("downloadMessageContentPreview", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceDownloadMessageContentPreviewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn download_profile_image(&mut self, request_id: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("downloadProfileImage", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceDownloadProfileImageArgs { request_id: request_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("downloadProfileImage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceDownloadProfileImageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn download_profile_image_preview(&mut self, request_id: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("downloadProfileImagePreview", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceDownloadProfileImagePreviewArgs { request_id: request_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("downloadProfileImagePreview", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceDownloadProfileImagePreviewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_active_member_count_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getActiveMemberCountByBuddyMid", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getActiveMemberCountByBuddyMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetActiveMemberCountByBuddyMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_active_member_mids_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getActiveMemberMidsByBuddyMid", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getActiveMemberMidsByBuddyMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_buddy_members(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getAllBuddyMembers", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetAllBuddyMembersArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getAllBuddyMembers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetAllBuddyMembersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_blocked_buddy_members(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBlockedBuddyMembers", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetBlockedBuddyMembersArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBlockedBuddyMembers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetBlockedBuddyMembersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_blocker_count_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBlockerCountByBuddyMid", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetBlockerCountByBuddyMidArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBlockerCountByBuddyMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetBlockerCountByBuddyMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_buddy_detail_by_mid(&mut self, buddy_mid: String) -> thrift::Result<BuddyDetail> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBuddyDetailByMid", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetBuddyDetailByMidArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBuddyDetailByMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetBuddyDetailByMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_buddy_profile(&mut self) -> thrift::Result<BuddyProfile> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBuddyProfile", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetBuddyProfileArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBuddyProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetBuddyProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_contact_ticket(&mut self) -> thrift::Result<Ticket> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getContactTicket", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetContactTicketArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getContactTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetContactTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_member_count_by_buddy_mid(&mut self, buddy_mid: String) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMemberCountByBuddyMid", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetMemberCountByBuddyMidArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMemberCountByBuddyMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetMemberCountByBuddyMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_send_buddy_message_result(&mut self, send_buddy_message_request_id: String) -> thrift::Result<SendBuddyMessageResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSendBuddyMessageResult", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetSendBuddyMessageResultArgs { send_buddy_message_request_id: send_buddy_message_request_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSendBuddyMessageResult", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetSendBuddyMessageResultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_set_buddy_on_air_result(&mut self, set_buddy_on_air_request_id: String) -> thrift::Result<SetBuddyOnAirResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSetBuddyOnAirResult", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetSetBuddyOnAirResultArgs { set_buddy_on_air_request_id: set_buddy_on_air_request_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSetBuddyOnAirResult", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetSetBuddyOnAirResultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_update_buddy_profile_result(&mut self, update_buddy_profile_request_id: String) -> thrift::Result<UpdateBuddyProfileResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUpdateBuddyProfileResult", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceGetUpdateBuddyProfileResultArgs { update_buddy_profile_request_id: update_buddy_profile_request_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUpdateBuddyProfileResult", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceGetUpdateBuddyProfileResultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_buddy_on_air_by_mid(&mut self, buddy_mid: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("isBuddyOnAirByMid", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceIsBuddyOnAirByMidArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("isBuddyOnAirByMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceIsBuddyOnAirByMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn link_and_send_buddy_content_message_to_all_async(&mut self, request_id: String, msg: Message, source_content_id: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToAllAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs { request_id: request_id, msg: msg, source_content_id: source_content_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("linkAndSendBuddyContentMessageToAllAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn link_and_send_buddy_content_message_to_mids(&mut self, request_id: String, msg: Message, source_content_id: String, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToMids", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs { request_id: request_id, msg: msg, source_content_id: source_content_id, mids: mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("linkAndSendBuddyContentMessageToMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_buddy_blocked(&mut self, buddy_mid: String, blocker_mid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyBuddyBlocked", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceNotifyBuddyBlockedArgs { buddy_mid: buddy_mid, blocker_mid: blocker_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyBuddyBlocked", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceNotifyBuddyBlockedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_buddy_unblocked(&mut self, buddy_mid: String, blocker_mid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyBuddyUnblocked", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceNotifyBuddyUnblockedArgs { buddy_mid: buddy_mid, blocker_mid: blocker_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyBuddyUnblocked", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceNotifyBuddyUnblockedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_buddy(&mut self, buddy_id: String, search_id: String, display_name: String, status_meessage: String, picture: Vec<u8>, settings: BTreeMap<String, String>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerBuddy", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceRegisterBuddyArgs { buddy_id: buddy_id, search_id: search_id, display_name: display_name, status_meessage: status_meessage, picture: picture, settings: settings };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerBuddy", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceRegisterBuddyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_buddy_admin(&mut self, buddy_id: String, search_id: String, display_name: String, status_message: String, picture: Vec<u8>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerBuddyAdmin", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceRegisterBuddyAdminArgs { buddy_id: buddy_id, search_id: search_id, display_name: display_name, status_message: status_message, picture: picture };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerBuddyAdmin", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceRegisterBuddyAdminResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reissue_contact_ticket(&mut self, expiration_time: i64, max_use_count: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reissueContactTicket", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceReissueContactTicketArgs { expiration_time: expiration_time, max_use_count: max_use_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reissueContactTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceReissueContactTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_buddy_member(&mut self, request_id: String, user_mid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeBuddyMember", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceRemoveBuddyMemberArgs { request_id: request_id, user_mid: user_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeBuddyMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceRemoveBuddyMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_buddy_members(&mut self, request_id: String, user_mids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeBuddyMembers", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceRemoveBuddyMembersArgs { request_id: request_id, user_mids: user_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeBuddyMembers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceRemoveBuddyMembersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_content_message_to_all(&mut self, request_id: String, msg: Message, content: Vec<u8>) -> thrift::Result<SendBuddyMessageResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAll", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyContentMessageToAllArgs { request_id: request_id, msg: msg, content: content };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyContentMessageToAll", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyContentMessageToAllResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_content_message_to_all_async(&mut self, request_id: String, msg: Message, content: Vec<u8>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAllAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs { request_id: request_id, msg: msg, content: content };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyContentMessageToAllAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_content_message_to_mids(&mut self, request_id: String, msg: Message, content: Vec<u8>, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMids", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyContentMessageToMidsArgs { request_id: request_id, msg: msg, content: content, mids: mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyContentMessageToMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyContentMessageToMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_content_message_to_mids_async(&mut self, request_id: String, msg: Message, content: Vec<u8>, mids: Vec<String>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMidsAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs { request_id: request_id, msg: msg, content: content, mids: mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyContentMessageToMidsAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_message_to_all(&mut self, request_id: String, msg: Message) -> thrift::Result<SendBuddyMessageResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToAll", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyMessageToAllArgs { request_id: request_id, msg: msg };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyMessageToAll", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyMessageToAllResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_message_to_all_async(&mut self, request_id: String, msg: Message) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToAllAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyMessageToAllAsyncArgs { request_id: request_id, msg: msg };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyMessageToAllAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyMessageToAllAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_message_to_mids(&mut self, request_id: String, msg: Message, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToMids", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyMessageToMidsArgs { request_id: request_id, msg: msg, mids: mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyMessageToMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyMessageToMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_buddy_message_to_mids_async(&mut self, request_id: String, msg: Message, mids: Vec<String>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToMidsAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs { request_id: request_id, msg: msg, mids: mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendBuddyMessageToMidsAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendBuddyMessageToMidsAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_individual_event_to_all_async(&mut self, request_id: String, buddy_mid: String, notification_status: NotificationStatus) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendIndividualEventToAllAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSendIndividualEventToAllAsyncArgs { request_id: request_id, buddy_mid: buddy_mid, notification_status: notification_status };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendIndividualEventToAllAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSendIndividualEventToAllAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_buddy_on_air(&mut self, request_id: String, on_air: bool) -> thrift::Result<SetBuddyOnAirResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setBuddyOnAir", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSetBuddyOnAirArgs { request_id: request_id, on_air: on_air };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setBuddyOnAir", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSetBuddyOnAirResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_buddy_on_air_async(&mut self, request_id: String, on_air: bool) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setBuddyOnAirAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceSetBuddyOnAirAsyncArgs { request_id: request_id, on_air: on_air };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setBuddyOnAirAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceSetBuddyOnAirAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn store_message(&mut self, request_id: String, message_request: BuddyMessageRequest) -> thrift::Result<SendBuddyMessageResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("storeMessage", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceStoreMessageArgs { request_id: request_id, message_request: message_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("storeMessage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceStoreMessageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unblock_buddy_member(&mut self, request_id: String, mid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unblockBuddyMember", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUnblockBuddyMemberArgs { request_id: request_id, mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unblockBuddyMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUnblockBuddyMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unregister_buddy(&mut self, request_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unregisterBuddy", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUnregisterBuddyArgs { request_id: request_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unregisterBuddy", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUnregisterBuddyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unregister_buddy_admin(&mut self, request_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unregisterBuddyAdmin", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUnregisterBuddyAdminArgs { request_id: request_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unregisterBuddyAdmin", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUnregisterBuddyAdminResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_admin_profile_attribute(&mut self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileAttribute", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs { request_id: request_id, attributes: attributes };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddyAdminProfileAttribute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_admin_profile_image(&mut self, request_id: String, picture: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileImage", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddyAdminProfileImageArgs { request_id: request_id, picture: picture };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddyAdminProfileImage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddyAdminProfileImageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_profile_attributes(&mut self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<UpdateBuddyProfileResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributes", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddyProfileAttributesArgs { request_id: request_id, attributes: attributes };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddyProfileAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddyProfileAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_profile_attributes_async(&mut self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributesAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs { request_id: request_id, attributes: attributes };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddyProfileAttributesAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_profile_image(&mut self, request_id: String, image: Vec<u8>) -> thrift::Result<UpdateBuddyProfileResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddyProfileImage", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddyProfileImageArgs { request_id: request_id, image: image };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddyProfileImage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddyProfileImageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_profile_image_async(&mut self, request_id: String, image: Vec<u8>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddyProfileImageAsync", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs { request_id: request_id, image: image };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddyProfileImageAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddyProfileImageAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_search_id(&mut self, request_id: String, search_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddySearchId", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddySearchIdArgs { request_id: request_id, search_id: search_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddySearchId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddySearchIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_settings(&mut self, settings: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddySettings", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUpdateBuddySettingsArgs { settings: settings };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddySettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUpdateBuddySettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn upload_buddy_content(&mut self, content_type: ContentType, content: Vec<u8>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("uploadBuddyContent", TMessageType::Call, self.sequence_number());
        let call_args = BuddyManagementServiceUploadBuddyContentArgs { content_type: content_type, content: content };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("uploadBuddyContent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyManagementServiceUploadBuddyContentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// BuddyManagementService service processor
//

pub trait BuddyManagementServiceSyncHandler {
  fn handle_add_buddy_member(&self, request_id: String, user_mid: String) -> thrift::Result<()>;
  fn handle_add_buddy_members(&self, request_id: String, user_mids: Vec<String>) -> thrift::Result<()>;
  fn handle_block_buddy_member(&self, request_id: String, mid: String) -> thrift::Result<()>;
  fn handle_commit_send_messages_to_all(&self, request_id_list: Vec<String>) -> thrift::Result<Vec<SendBuddyMessageResult>>;
  fn handle_commit_send_messages_to_mids(&self, request_id_list: Vec<String>, mids: Vec<String>) -> thrift::Result<Vec<SendBuddyMessageResult>>;
  fn handle_contains_buddy_member(&self, request_id: String, user_mid: String) -> thrift::Result<bool>;
  fn handle_download_message_content(&self, request_id: String, message_id: String) -> thrift::Result<Vec<u8>>;
  fn handle_download_message_content_preview(&self, request_id: String, message_id: String) -> thrift::Result<Vec<u8>>;
  fn handle_download_profile_image(&self, request_id: String) -> thrift::Result<Vec<u8>>;
  fn handle_download_profile_image_preview(&self, request_id: String) -> thrift::Result<Vec<u8>>;
  fn handle_get_active_member_count_by_buddy_mid(&self, buddy_mid: String) -> thrift::Result<i64>;
  fn handle_get_active_member_mids_by_buddy_mid(&self, buddy_mid: String) -> thrift::Result<Vec<String>>;
  fn handle_get_all_buddy_members(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_blocked_buddy_members(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_blocker_count_by_buddy_mid(&self, buddy_mid: String) -> thrift::Result<i64>;
  fn handle_get_buddy_detail_by_mid(&self, buddy_mid: String) -> thrift::Result<BuddyDetail>;
  fn handle_get_buddy_profile(&self) -> thrift::Result<BuddyProfile>;
  fn handle_get_contact_ticket(&self) -> thrift::Result<Ticket>;
  fn handle_get_member_count_by_buddy_mid(&self, buddy_mid: String) -> thrift::Result<i64>;
  fn handle_get_send_buddy_message_result(&self, send_buddy_message_request_id: String) -> thrift::Result<SendBuddyMessageResult>;
  fn handle_get_set_buddy_on_air_result(&self, set_buddy_on_air_request_id: String) -> thrift::Result<SetBuddyOnAirResult>;
  fn handle_get_update_buddy_profile_result(&self, update_buddy_profile_request_id: String) -> thrift::Result<UpdateBuddyProfileResult>;
  fn handle_is_buddy_on_air_by_mid(&self, buddy_mid: String) -> thrift::Result<bool>;
  fn handle_link_and_send_buddy_content_message_to_all_async(&self, request_id: String, msg: Message, source_content_id: String) -> thrift::Result<String>;
  fn handle_link_and_send_buddy_content_message_to_mids(&self, request_id: String, msg: Message, source_content_id: String, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult>;
  fn handle_notify_buddy_blocked(&self, buddy_mid: String, blocker_mid: String) -> thrift::Result<()>;
  fn handle_notify_buddy_unblocked(&self, buddy_mid: String, blocker_mid: String) -> thrift::Result<()>;
  fn handle_register_buddy(&self, buddy_id: String, search_id: String, display_name: String, status_meessage: String, picture: Vec<u8>, settings: BTreeMap<String, String>) -> thrift::Result<String>;
  fn handle_register_buddy_admin(&self, buddy_id: String, search_id: String, display_name: String, status_message: String, picture: Vec<u8>) -> thrift::Result<String>;
  fn handle_reissue_contact_ticket(&self, expiration_time: i64, max_use_count: i32) -> thrift::Result<String>;
  fn handle_remove_buddy_member(&self, request_id: String, user_mid: String) -> thrift::Result<()>;
  fn handle_remove_buddy_members(&self, request_id: String, user_mids: Vec<String>) -> thrift::Result<()>;
  fn handle_send_buddy_content_message_to_all(&self, request_id: String, msg: Message, content: Vec<u8>) -> thrift::Result<SendBuddyMessageResult>;
  fn handle_send_buddy_content_message_to_all_async(&self, request_id: String, msg: Message, content: Vec<u8>) -> thrift::Result<String>;
  fn handle_send_buddy_content_message_to_mids(&self, request_id: String, msg: Message, content: Vec<u8>, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult>;
  fn handle_send_buddy_content_message_to_mids_async(&self, request_id: String, msg: Message, content: Vec<u8>, mids: Vec<String>) -> thrift::Result<String>;
  fn handle_send_buddy_message_to_all(&self, request_id: String, msg: Message) -> thrift::Result<SendBuddyMessageResult>;
  fn handle_send_buddy_message_to_all_async(&self, request_id: String, msg: Message) -> thrift::Result<String>;
  fn handle_send_buddy_message_to_mids(&self, request_id: String, msg: Message, mids: Vec<String>) -> thrift::Result<SendBuddyMessageResult>;
  fn handle_send_buddy_message_to_mids_async(&self, request_id: String, msg: Message, mids: Vec<String>) -> thrift::Result<String>;
  fn handle_send_individual_event_to_all_async(&self, request_id: String, buddy_mid: String, notification_status: NotificationStatus) -> thrift::Result<()>;
  fn handle_set_buddy_on_air(&self, request_id: String, on_air: bool) -> thrift::Result<SetBuddyOnAirResult>;
  fn handle_set_buddy_on_air_async(&self, request_id: String, on_air: bool) -> thrift::Result<String>;
  fn handle_store_message(&self, request_id: String, message_request: BuddyMessageRequest) -> thrift::Result<SendBuddyMessageResult>;
  fn handle_unblock_buddy_member(&self, request_id: String, mid: String) -> thrift::Result<()>;
  fn handle_unregister_buddy(&self, request_id: String) -> thrift::Result<()>;
  fn handle_unregister_buddy_admin(&self, request_id: String) -> thrift::Result<()>;
  fn handle_update_buddy_admin_profile_attribute(&self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<()>;
  fn handle_update_buddy_admin_profile_image(&self, request_id: String, picture: Vec<u8>) -> thrift::Result<()>;
  fn handle_update_buddy_profile_attributes(&self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<UpdateBuddyProfileResult>;
  fn handle_update_buddy_profile_attributes_async(&self, request_id: String, attributes: BTreeMap<String, String>) -> thrift::Result<String>;
  fn handle_update_buddy_profile_image(&self, request_id: String, image: Vec<u8>) -> thrift::Result<UpdateBuddyProfileResult>;
  fn handle_update_buddy_profile_image_async(&self, request_id: String, image: Vec<u8>) -> thrift::Result<String>;
  fn handle_update_buddy_search_id(&self, request_id: String, search_id: String) -> thrift::Result<()>;
  fn handle_update_buddy_settings(&self, settings: BTreeMap<String, String>) -> thrift::Result<()>;
  fn handle_upload_buddy_content(&self, content_type: ContentType, content: Vec<u8>) -> thrift::Result<String>;
}

pub struct BuddyManagementServiceSyncProcessor<H: BuddyManagementServiceSyncHandler> {
  handler: H,
}

impl <H: BuddyManagementServiceSyncHandler> BuddyManagementServiceSyncProcessor<H> {
  pub fn new(handler: H) -> BuddyManagementServiceSyncProcessor<H> {
    BuddyManagementServiceSyncProcessor {
      handler,
    }
  }
  fn process_add_buddy_member(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_add_buddy_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_buddy_members(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_add_buddy_members(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_block_buddy_member(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_block_buddy_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_commit_send_messages_to_all(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_commit_send_messages_to_all(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_commit_send_messages_to_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_commit_send_messages_to_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_contains_buddy_member(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_contains_buddy_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_download_message_content(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_download_message_content(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_download_message_content_preview(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_download_message_content_preview(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_download_profile_image(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_download_profile_image(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_download_profile_image_preview(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_download_profile_image_preview(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_active_member_count_by_buddy_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_active_member_count_by_buddy_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_active_member_mids_by_buddy_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_active_member_mids_by_buddy_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_buddy_members(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_all_buddy_members(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_blocked_buddy_members(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_blocked_buddy_members(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_blocker_count_by_buddy_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_blocker_count_by_buddy_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_buddy_detail_by_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_buddy_detail_by_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_buddy_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_buddy_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_contact_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_contact_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_member_count_by_buddy_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_member_count_by_buddy_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_send_buddy_message_result(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_send_buddy_message_result(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_set_buddy_on_air_result(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_set_buddy_on_air_result(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_update_buddy_profile_result(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_get_update_buddy_profile_result(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_buddy_on_air_by_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_is_buddy_on_air_by_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_link_and_send_buddy_content_message_to_all_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_link_and_send_buddy_content_message_to_all_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_link_and_send_buddy_content_message_to_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_link_and_send_buddy_content_message_to_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_buddy_blocked(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_notify_buddy_blocked(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_buddy_unblocked(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_notify_buddy_unblocked(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_buddy(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_register_buddy(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_buddy_admin(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_register_buddy_admin(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reissue_contact_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_reissue_contact_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_buddy_member(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_remove_buddy_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_buddy_members(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_remove_buddy_members(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_content_message_to_all(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_content_message_to_all(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_content_message_to_all_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_content_message_to_all_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_content_message_to_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_content_message_to_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_content_message_to_mids_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_content_message_to_mids_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_message_to_all(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_message_to_all(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_message_to_all_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_message_to_all_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_message_to_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_message_to_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_buddy_message_to_mids_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_buddy_message_to_mids_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_individual_event_to_all_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_send_individual_event_to_all_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_buddy_on_air(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_set_buddy_on_air(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_buddy_on_air_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_set_buddy_on_air_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_store_message(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_store_message(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unblock_buddy_member(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_unblock_buddy_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unregister_buddy(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_unregister_buddy(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unregister_buddy_admin(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_unregister_buddy_admin(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_admin_profile_attribute(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_admin_profile_attribute(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_admin_profile_image(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_admin_profile_image(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_profile_attributes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_profile_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_profile_attributes_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_profile_attributes_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_profile_image(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_profile_image(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_profile_image_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_profile_image_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_search_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_search_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_settings(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_update_buddy_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_upload_buddy_content(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyManagementServiceProcessFunctions::process_upload_buddy_content(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TBuddyManagementServiceProcessFunctions;

impl TBuddyManagementServiceProcessFunctions {
  pub fn process_add_buddy_member<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceAddBuddyMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_buddy_member(args.request_id, args.user_mid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("addBuddyMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceAddBuddyMemberResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceAddBuddyMemberResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("addBuddyMember", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("addBuddyMember", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("addBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("addBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_buddy_members<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceAddBuddyMembersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_buddy_members(args.request_id, args.user_mids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("addBuddyMembers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceAddBuddyMembersResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceAddBuddyMembersResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("addBuddyMembers", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("addBuddyMembers", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("addBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("addBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_block_buddy_member<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceBlockBuddyMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_block_buddy_member(args.request_id, args.mid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("blockBuddyMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceBlockBuddyMemberResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceBlockBuddyMemberResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("blockBuddyMember", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("blockBuddyMember", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("blockBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("blockBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_commit_send_messages_to_all<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceCommitSendMessagesToAllArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_commit_send_messages_to_all(args.request_id_list) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("commitSendMessagesToAll", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceCommitSendMessagesToAllResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceCommitSendMessagesToAllResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("commitSendMessagesToAll", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("commitSendMessagesToAll", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("commitSendMessagesToAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("commitSendMessagesToAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_commit_send_messages_to_mids<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceCommitSendMessagesToMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_commit_send_messages_to_mids(args.request_id_list, args.mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("commitSendMessagesToMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceCommitSendMessagesToMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceCommitSendMessagesToMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("commitSendMessagesToMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("commitSendMessagesToMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("commitSendMessagesToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("commitSendMessagesToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_contains_buddy_member<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceContainsBuddyMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_contains_buddy_member(args.request_id, args.user_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("containsBuddyMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceContainsBuddyMemberResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceContainsBuddyMemberResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("containsBuddyMember", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("containsBuddyMember", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("containsBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("containsBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_download_message_content<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceDownloadMessageContentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_download_message_content(args.request_id, args.message_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("downloadMessageContent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceDownloadMessageContentResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceDownloadMessageContentResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("downloadMessageContent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("downloadMessageContent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("downloadMessageContent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("downloadMessageContent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_download_message_content_preview<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceDownloadMessageContentPreviewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_download_message_content_preview(args.request_id, args.message_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("downloadMessageContentPreview", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceDownloadMessageContentPreviewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceDownloadMessageContentPreviewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("downloadMessageContentPreview", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("downloadMessageContentPreview", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("downloadMessageContentPreview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("downloadMessageContentPreview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_download_profile_image<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceDownloadProfileImageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_download_profile_image(args.request_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("downloadProfileImage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceDownloadProfileImageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceDownloadProfileImageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("downloadProfileImage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("downloadProfileImage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("downloadProfileImage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("downloadProfileImage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_download_profile_image_preview<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceDownloadProfileImagePreviewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_download_profile_image_preview(args.request_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("downloadProfileImagePreview", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceDownloadProfileImagePreviewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceDownloadProfileImagePreviewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("downloadProfileImagePreview", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("downloadProfileImagePreview", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("downloadProfileImagePreview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("downloadProfileImagePreview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_active_member_count_by_buddy_mid<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_active_member_count_by_buddy_mid(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getActiveMemberCountByBuddyMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetActiveMemberCountByBuddyMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetActiveMemberCountByBuddyMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getActiveMemberCountByBuddyMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getActiveMemberCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getActiveMemberCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getActiveMemberCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_active_member_mids_by_buddy_mid<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_active_member_mids_by_buddy_mid(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getActiveMemberMidsByBuddyMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getActiveMemberMidsByBuddyMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getActiveMemberMidsByBuddyMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getActiveMemberMidsByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getActiveMemberMidsByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_buddy_members<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = BuddyManagementServiceGetAllBuddyMembersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_buddy_members() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getAllBuddyMembers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetAllBuddyMembersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetAllBuddyMembersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getAllBuddyMembers", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getAllBuddyMembers", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getAllBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getAllBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_blocked_buddy_members<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = BuddyManagementServiceGetBlockedBuddyMembersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_blocked_buddy_members() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBlockedBuddyMembers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetBlockedBuddyMembersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetBlockedBuddyMembersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBlockedBuddyMembers", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBlockedBuddyMembers", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBlockedBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBlockedBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_blocker_count_by_buddy_mid<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetBlockerCountByBuddyMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_blocker_count_by_buddy_mid(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBlockerCountByBuddyMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetBlockerCountByBuddyMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetBlockerCountByBuddyMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBlockerCountByBuddyMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBlockerCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBlockerCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBlockerCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_buddy_detail_by_mid<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetBuddyDetailByMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_buddy_detail_by_mid(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBuddyDetailByMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetBuddyDetailByMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetBuddyDetailByMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBuddyDetailByMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBuddyDetailByMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBuddyDetailByMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBuddyDetailByMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_buddy_profile<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = BuddyManagementServiceGetBuddyProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_buddy_profile() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBuddyProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetBuddyProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetBuddyProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBuddyProfile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBuddyProfile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBuddyProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBuddyProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_contact_ticket<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = BuddyManagementServiceGetContactTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_contact_ticket() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getContactTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetContactTicketResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetContactTicketResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getContactTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getContactTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getContactTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getContactTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_member_count_by_buddy_mid<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetMemberCountByBuddyMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_member_count_by_buddy_mid(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMemberCountByBuddyMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetMemberCountByBuddyMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetMemberCountByBuddyMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMemberCountByBuddyMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMemberCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMemberCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMemberCountByBuddyMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_send_buddy_message_result<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetSendBuddyMessageResultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_send_buddy_message_result(args.send_buddy_message_request_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSendBuddyMessageResult", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetSendBuddyMessageResultResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetSendBuddyMessageResultResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSendBuddyMessageResult", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSendBuddyMessageResult", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSendBuddyMessageResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSendBuddyMessageResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_set_buddy_on_air_result<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetSetBuddyOnAirResultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_set_buddy_on_air_result(args.set_buddy_on_air_request_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSetBuddyOnAirResult", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetSetBuddyOnAirResultResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetSetBuddyOnAirResultResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSetBuddyOnAirResult", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSetBuddyOnAirResult", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSetBuddyOnAirResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSetBuddyOnAirResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_update_buddy_profile_result<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceGetUpdateBuddyProfileResultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_update_buddy_profile_result(args.update_buddy_profile_request_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUpdateBuddyProfileResult", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceGetUpdateBuddyProfileResultResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceGetUpdateBuddyProfileResultResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUpdateBuddyProfileResult", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getUpdateBuddyProfileResult", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUpdateBuddyProfileResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getUpdateBuddyProfileResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_buddy_on_air_by_mid<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceIsBuddyOnAirByMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_buddy_on_air_by_mid(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("isBuddyOnAirByMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceIsBuddyOnAirByMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceIsBuddyOnAirByMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("isBuddyOnAirByMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("isBuddyOnAirByMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("isBuddyOnAirByMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("isBuddyOnAirByMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_link_and_send_buddy_content_message_to_all_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_link_and_send_buddy_content_message_to_all_async(args.request_id, args.msg, args.source_content_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToAllAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToAllAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_link_and_send_buddy_content_message_to_mids<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_link_and_send_buddy_content_message_to_mids(args.request_id, args.msg, args.source_content_id, args.mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("linkAndSendBuddyContentMessageToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_buddy_blocked<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceNotifyBuddyBlockedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_buddy_blocked(args.buddy_mid, args.blocker_mid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifyBuddyBlocked", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceNotifyBuddyBlockedResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceNotifyBuddyBlockedResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifyBuddyBlocked", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifyBuddyBlocked", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyBuddyBlocked", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyBuddyBlocked", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_buddy_unblocked<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceNotifyBuddyUnblockedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_buddy_unblocked(args.buddy_mid, args.blocker_mid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifyBuddyUnblocked", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceNotifyBuddyUnblockedResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceNotifyBuddyUnblockedResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifyBuddyUnblocked", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifyBuddyUnblocked", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyBuddyUnblocked", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyBuddyUnblocked", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_buddy<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceRegisterBuddyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_buddy(args.buddy_id, args.search_id, args.display_name, args.status_meessage, args.picture, args.settings) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerBuddy", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceRegisterBuddyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceRegisterBuddyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerBuddy", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerBuddy", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerBuddy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerBuddy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_buddy_admin<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceRegisterBuddyAdminArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_buddy_admin(args.buddy_id, args.search_id, args.display_name, args.status_message, args.picture) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerBuddyAdmin", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceRegisterBuddyAdminResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceRegisterBuddyAdminResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerBuddyAdmin", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerBuddyAdmin", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerBuddyAdmin", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerBuddyAdmin", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reissue_contact_ticket<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceReissueContactTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reissue_contact_ticket(args.expiration_time, args.max_use_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("reissueContactTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceReissueContactTicketResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceReissueContactTicketResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reissueContactTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reissueContactTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reissueContactTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reissueContactTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_buddy_member<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceRemoveBuddyMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_buddy_member(args.request_id, args.user_mid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("removeBuddyMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceRemoveBuddyMemberResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceRemoveBuddyMemberResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeBuddyMember", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeBuddyMember", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_buddy_members<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceRemoveBuddyMembersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_buddy_members(args.request_id, args.user_mids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("removeBuddyMembers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceRemoveBuddyMembersResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceRemoveBuddyMembersResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeBuddyMembers", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeBuddyMembers", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeBuddyMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_content_message_to_all<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyContentMessageToAllArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_content_message_to_all(args.request_id, args.msg, args.content) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAll", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyContentMessageToAllResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyContentMessageToAllResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAll", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAll", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_content_message_to_all_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_content_message_to_all_async(args.request_id, args.msg, args.content) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAllAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAllAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_content_message_to_mids<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyContentMessageToMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_content_message_to_mids(args.request_id, args.msg, args.content, args.mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyContentMessageToMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyContentMessageToMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_content_message_to_mids_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_content_message_to_mids_async(args.request_id, args.msg, args.content, args.mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMidsAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMidsAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMidsAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMidsAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyContentMessageToMidsAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_message_to_all<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyMessageToAllArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_message_to_all(args.request_id, args.msg) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToAll", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyMessageToAllResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyMessageToAllResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToAll", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToAll", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_message_to_all_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyMessageToAllAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_message_to_all_async(args.request_id, args.msg) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToAllAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyMessageToAllAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyMessageToAllAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToAllAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_message_to_mids<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyMessageToMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_message_to_mids(args.request_id, args.msg, args.mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyMessageToMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyMessageToMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_buddy_message_to_mids_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_buddy_message_to_mids_async(args.request_id, args.msg, args.mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendBuddyMessageToMidsAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendBuddyMessageToMidsAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendBuddyMessageToMidsAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToMidsAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendBuddyMessageToMidsAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToMidsAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendBuddyMessageToMidsAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_individual_event_to_all_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSendIndividualEventToAllAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_individual_event_to_all_async(args.request_id, args.buddy_mid, args.notification_status) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendIndividualEventToAllAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSendIndividualEventToAllAsyncResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSendIndividualEventToAllAsyncResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendIndividualEventToAllAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendIndividualEventToAllAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendIndividualEventToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendIndividualEventToAllAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_buddy_on_air<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSetBuddyOnAirArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_buddy_on_air(args.request_id, args.on_air) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setBuddyOnAir", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSetBuddyOnAirResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSetBuddyOnAirResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("setBuddyOnAir", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("setBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("setBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_buddy_on_air_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceSetBuddyOnAirAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_buddy_on_air_async(args.request_id, args.on_air) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setBuddyOnAirAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceSetBuddyOnAirAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceSetBuddyOnAirAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("setBuddyOnAirAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("setBuddyOnAirAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setBuddyOnAirAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("setBuddyOnAirAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_store_message<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceStoreMessageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_store_message(args.request_id, args.message_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("storeMessage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceStoreMessageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceStoreMessageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("storeMessage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("storeMessage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("storeMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("storeMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unblock_buddy_member<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUnblockBuddyMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unblock_buddy_member(args.request_id, args.mid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unblockBuddyMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUnblockBuddyMemberResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUnblockBuddyMemberResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unblockBuddyMember", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unblockBuddyMember", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unblockBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unblockBuddyMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unregister_buddy<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUnregisterBuddyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unregister_buddy(args.request_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unregisterBuddy", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUnregisterBuddyResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUnregisterBuddyResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unregisterBuddy", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unregisterBuddy", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unregisterBuddy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unregisterBuddy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unregister_buddy_admin<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUnregisterBuddyAdminArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unregister_buddy_admin(args.request_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unregisterBuddyAdmin", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUnregisterBuddyAdminResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUnregisterBuddyAdminResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unregisterBuddyAdmin", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unregisterBuddyAdmin", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unregisterBuddyAdmin", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unregisterBuddyAdmin", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_admin_profile_attribute<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_admin_profile_attribute(args.request_id, args.attributes) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileAttribute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileAttribute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileAttribute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_admin_profile_image<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddyAdminProfileImageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_admin_profile_image(args.request_id, args.picture) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileImage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddyAdminProfileImageResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddyAdminProfileImageResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileImage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileImage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileImage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddyAdminProfileImage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_profile_attributes<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddyProfileAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_profile_attributes(args.request_id, args.attributes) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddyProfileAttributesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddyProfileAttributesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_profile_attributes_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_profile_attributes_async(args.request_id, args.attributes) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributesAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributesAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributesAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributesAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddyProfileAttributesAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_profile_image<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddyProfileImageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_profile_image(args.request_id, args.image) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateBuddyProfileImage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddyProfileImageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddyProfileImageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileImage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileImage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddyProfileImage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddyProfileImage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_profile_image_async<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_profile_image_async(args.request_id, args.image) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateBuddyProfileImageAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddyProfileImageAsyncResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddyProfileImageAsyncResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileImageAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddyProfileImageAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddyProfileImageAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddyProfileImageAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_search_id<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddySearchIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_search_id(args.request_id, args.search_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateBuddySearchId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddySearchIdResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddySearchIdResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddySearchId", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddySearchId", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddySearchId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddySearchId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_settings<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUpdateBuddySettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_settings(args.settings) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateBuddySettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUpdateBuddySettingsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUpdateBuddySettingsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddySettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddySettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddySettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddySettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_upload_buddy_content<H: BuddyManagementServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyManagementServiceUploadBuddyContentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_upload_buddy_content(args.content_type, args.content) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("uploadBuddyContent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyManagementServiceUploadBuddyContentResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyManagementServiceUploadBuddyContentResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("uploadBuddyContent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("uploadBuddyContent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("uploadBuddyContent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("uploadBuddyContent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: BuddyManagementServiceSyncHandler> TProcessor for BuddyManagementServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "addBuddyMember" => {
        self.process_add_buddy_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "addBuddyMembers" => {
        self.process_add_buddy_members(message_ident.sequence_number, i_prot, o_prot)
      },
      "blockBuddyMember" => {
        self.process_block_buddy_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "commitSendMessagesToAll" => {
        self.process_commit_send_messages_to_all(message_ident.sequence_number, i_prot, o_prot)
      },
      "commitSendMessagesToMids" => {
        self.process_commit_send_messages_to_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "containsBuddyMember" => {
        self.process_contains_buddy_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "downloadMessageContent" => {
        self.process_download_message_content(message_ident.sequence_number, i_prot, o_prot)
      },
      "downloadMessageContentPreview" => {
        self.process_download_message_content_preview(message_ident.sequence_number, i_prot, o_prot)
      },
      "downloadProfileImage" => {
        self.process_download_profile_image(message_ident.sequence_number, i_prot, o_prot)
      },
      "downloadProfileImagePreview" => {
        self.process_download_profile_image_preview(message_ident.sequence_number, i_prot, o_prot)
      },
      "getActiveMemberCountByBuddyMid" => {
        self.process_get_active_member_count_by_buddy_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "getActiveMemberMidsByBuddyMid" => {
        self.process_get_active_member_mids_by_buddy_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "getAllBuddyMembers" => {
        self.process_get_all_buddy_members(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBlockedBuddyMembers" => {
        self.process_get_blocked_buddy_members(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBlockerCountByBuddyMid" => {
        self.process_get_blocker_count_by_buddy_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBuddyDetailByMid" => {
        self.process_get_buddy_detail_by_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBuddyProfile" => {
        self.process_get_buddy_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "getContactTicket" => {
        self.process_get_contact_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMemberCountByBuddyMid" => {
        self.process_get_member_count_by_buddy_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSendBuddyMessageResult" => {
        self.process_get_send_buddy_message_result(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSetBuddyOnAirResult" => {
        self.process_get_set_buddy_on_air_result(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUpdateBuddyProfileResult" => {
        self.process_get_update_buddy_profile_result(message_ident.sequence_number, i_prot, o_prot)
      },
      "isBuddyOnAirByMid" => {
        self.process_is_buddy_on_air_by_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "linkAndSendBuddyContentMessageToAllAsync" => {
        self.process_link_and_send_buddy_content_message_to_all_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "linkAndSendBuddyContentMessageToMids" => {
        self.process_link_and_send_buddy_content_message_to_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyBuddyBlocked" => {
        self.process_notify_buddy_blocked(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyBuddyUnblocked" => {
        self.process_notify_buddy_unblocked(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerBuddy" => {
        self.process_register_buddy(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerBuddyAdmin" => {
        self.process_register_buddy_admin(message_ident.sequence_number, i_prot, o_prot)
      },
      "reissueContactTicket" => {
        self.process_reissue_contact_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeBuddyMember" => {
        self.process_remove_buddy_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeBuddyMembers" => {
        self.process_remove_buddy_members(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyContentMessageToAll" => {
        self.process_send_buddy_content_message_to_all(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyContentMessageToAllAsync" => {
        self.process_send_buddy_content_message_to_all_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyContentMessageToMids" => {
        self.process_send_buddy_content_message_to_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyContentMessageToMidsAsync" => {
        self.process_send_buddy_content_message_to_mids_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyMessageToAll" => {
        self.process_send_buddy_message_to_all(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyMessageToAllAsync" => {
        self.process_send_buddy_message_to_all_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyMessageToMids" => {
        self.process_send_buddy_message_to_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendBuddyMessageToMidsAsync" => {
        self.process_send_buddy_message_to_mids_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendIndividualEventToAllAsync" => {
        self.process_send_individual_event_to_all_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "setBuddyOnAir" => {
        self.process_set_buddy_on_air(message_ident.sequence_number, i_prot, o_prot)
      },
      "setBuddyOnAirAsync" => {
        self.process_set_buddy_on_air_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "storeMessage" => {
        self.process_store_message(message_ident.sequence_number, i_prot, o_prot)
      },
      "unblockBuddyMember" => {
        self.process_unblock_buddy_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "unregisterBuddy" => {
        self.process_unregister_buddy(message_ident.sequence_number, i_prot, o_prot)
      },
      "unregisterBuddyAdmin" => {
        self.process_unregister_buddy_admin(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddyAdminProfileAttribute" => {
        self.process_update_buddy_admin_profile_attribute(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddyAdminProfileImage" => {
        self.process_update_buddy_admin_profile_image(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddyProfileAttributes" => {
        self.process_update_buddy_profile_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddyProfileAttributesAsync" => {
        self.process_update_buddy_profile_attributes_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddyProfileImage" => {
        self.process_update_buddy_profile_image(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddyProfileImageAsync" => {
        self.process_update_buddy_profile_image_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddySearchId" => {
        self.process_update_buddy_search_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddySettings" => {
        self.process_update_buddy_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "uploadBuddyContent" => {
        self.process_upload_buddy_content(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// BuddyManagementServiceAddBuddyMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceAddBuddyMemberArgs {
  request_id: String,
  user_mid: String,
}

impl BuddyManagementServiceAddBuddyMemberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceAddBuddyMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceAddBuddyMemberArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceAddBuddyMemberArgs.user_mid", &f_2)?;
    let ret = BuddyManagementServiceAddBuddyMemberArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("addBuddyMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userMid", TType::String, 2))?;
    o_prot.write_string(&self.user_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceAddBuddyMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceAddBuddyMemberResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceAddBuddyMemberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceAddBuddyMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceAddBuddyMemberResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceAddBuddyMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceAddBuddyMembersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceAddBuddyMembersArgs {
  request_id: String,
  user_mids: Vec<String>,
}

impl BuddyManagementServiceAddBuddyMembersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceAddBuddyMembersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = i_prot.read_string()?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceAddBuddyMembersArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceAddBuddyMembersArgs.user_mids", &f_2)?;
    let ret = BuddyManagementServiceAddBuddyMembersArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_mids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("addBuddyMembers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userMids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.user_mids.len() as i32))?;
    for e in &self.user_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceAddBuddyMembersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceAddBuddyMembersResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceAddBuddyMembersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceAddBuddyMembersResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceAddBuddyMembersResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceAddBuddyMembersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceBlockBuddyMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceBlockBuddyMemberArgs {
  request_id: String,
  mid: String,
}

impl BuddyManagementServiceBlockBuddyMemberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceBlockBuddyMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceBlockBuddyMemberArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceBlockBuddyMemberArgs.mid", &f_2)?;
    let ret = BuddyManagementServiceBlockBuddyMemberArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("blockBuddyMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceBlockBuddyMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceBlockBuddyMemberResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceBlockBuddyMemberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceBlockBuddyMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceBlockBuddyMemberResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceBlockBuddyMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceCommitSendMessagesToAllArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceCommitSendMessagesToAllArgs {
  request_id_list: Vec<String>,
}

impl BuddyManagementServiceCommitSendMessagesToAllArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceCommitSendMessagesToAllArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = i_prot.read_string()?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceCommitSendMessagesToAllArgs.request_id_list", &f_1)?;
    let ret = BuddyManagementServiceCommitSendMessagesToAllArgs {
      request_id_list: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("commitSendMessagesToAll_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestIdList", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.request_id_list.len() as i32))?;
    for e in &self.request_id_list {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceCommitSendMessagesToAllResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceCommitSendMessagesToAllResult {
  result_value: Option<Vec<SendBuddyMessageResult>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceCommitSendMessagesToAllResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceCommitSendMessagesToAllResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<SendBuddyMessageResult>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SendBuddyMessageResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceCommitSendMessagesToAllResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceCommitSendMessagesToAllResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<SendBuddyMessageResult>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceCommitSendMessagesToAll"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceCommitSendMessagesToMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceCommitSendMessagesToMidsArgs {
  request_id_list: Vec<String>,
  mids: Vec<String>,
}

impl BuddyManagementServiceCommitSendMessagesToMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceCommitSendMessagesToMidsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = i_prot.read_string()?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = i_prot.read_string()?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceCommitSendMessagesToMidsArgs.request_id_list", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceCommitSendMessagesToMidsArgs.mids", &f_2)?;
    let ret = BuddyManagementServiceCommitSendMessagesToMidsArgs {
      request_id_list: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("commitSendMessagesToMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestIdList", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.request_id_list.len() as i32))?;
    for e in &self.request_id_list {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.mids.len() as i32))?;
    for e in &self.mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceCommitSendMessagesToMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceCommitSendMessagesToMidsResult {
  result_value: Option<Vec<SendBuddyMessageResult>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceCommitSendMessagesToMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceCommitSendMessagesToMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<SendBuddyMessageResult>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SendBuddyMessageResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_63 = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceCommitSendMessagesToMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceCommitSendMessagesToMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<SendBuddyMessageResult>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceCommitSendMessagesToMids"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceContainsBuddyMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceContainsBuddyMemberArgs {
  request_id: String,
  user_mid: String,
}

impl BuddyManagementServiceContainsBuddyMemberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceContainsBuddyMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceContainsBuddyMemberArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceContainsBuddyMemberArgs.user_mid", &f_2)?;
    let ret = BuddyManagementServiceContainsBuddyMemberArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("containsBuddyMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userMid", TType::String, 2))?;
    o_prot.write_string(&self.user_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceContainsBuddyMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceContainsBuddyMemberResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceContainsBuddyMemberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceContainsBuddyMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceContainsBuddyMemberResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceContainsBuddyMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceContainsBuddyMember"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceDownloadMessageContentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadMessageContentArgs {
  request_id: String,
  message_id: String,
}

impl BuddyManagementServiceDownloadMessageContentArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadMessageContentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceDownloadMessageContentArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceDownloadMessageContentArgs.message_id", &f_2)?;
    let ret = BuddyManagementServiceDownloadMessageContentArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("downloadMessageContent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 2))?;
    o_prot.write_string(&self.message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceDownloadMessageContentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadMessageContentResult {
  result_value: Option<Vec<u8>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceDownloadMessageContentResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadMessageContentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceDownloadMessageContentResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceDownloadMessageContentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceDownloadMessageContent"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceDownloadMessageContentPreviewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadMessageContentPreviewArgs {
  request_id: String,
  message_id: String,
}

impl BuddyManagementServiceDownloadMessageContentPreviewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadMessageContentPreviewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceDownloadMessageContentPreviewArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceDownloadMessageContentPreviewArgs.message_id", &f_2)?;
    let ret = BuddyManagementServiceDownloadMessageContentPreviewArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("downloadMessageContentPreview_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 2))?;
    o_prot.write_string(&self.message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceDownloadMessageContentPreviewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadMessageContentPreviewResult {
  result_value: Option<Vec<u8>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceDownloadMessageContentPreviewResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadMessageContentPreviewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceDownloadMessageContentPreviewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceDownloadMessageContentPreviewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceDownloadMessageContentPreview"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceDownloadProfileImageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadProfileImageArgs {
  request_id: String,
}

impl BuddyManagementServiceDownloadProfileImageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadProfileImageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceDownloadProfileImageArgs.request_id", &f_1)?;
    let ret = BuddyManagementServiceDownloadProfileImageArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("downloadProfileImage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceDownloadProfileImageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadProfileImageResult {
  result_value: Option<Vec<u8>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceDownloadProfileImageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadProfileImageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceDownloadProfileImageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceDownloadProfileImageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceDownloadProfileImage"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceDownloadProfileImagePreviewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadProfileImagePreviewArgs {
  request_id: String,
}

impl BuddyManagementServiceDownloadProfileImagePreviewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadProfileImagePreviewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceDownloadProfileImagePreviewArgs.request_id", &f_1)?;
    let ret = BuddyManagementServiceDownloadProfileImagePreviewArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("downloadProfileImagePreview_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceDownloadProfileImagePreviewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceDownloadProfileImagePreviewResult {
  result_value: Option<Vec<u8>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceDownloadProfileImagePreviewResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceDownloadProfileImagePreviewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceDownloadProfileImagePreviewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceDownloadProfileImagePreviewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceDownloadProfileImagePreview"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs {
  buddy_mid: String,
}

impl BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs.buddy_mid", &f_2)?;
    let ret = BuddyManagementServiceGetActiveMemberCountByBuddyMidArgs {
      buddy_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getActiveMemberCountByBuddyMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 2))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetActiveMemberCountByBuddyMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetActiveMemberCountByBuddyMidResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetActiveMemberCountByBuddyMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetActiveMemberCountByBuddyMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetActiveMemberCountByBuddyMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetActiveMemberCountByBuddyMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetActiveMemberCountByBuddyMid"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs {
  buddy_mid: String,
}

impl BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs.buddy_mid", &f_2)?;
    let ret = BuddyManagementServiceGetActiveMemberMidsByBuddyMidArgs {
      buddy_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getActiveMemberMidsByBuddyMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 2))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_64 = i_prot.read_string()?;
            val.push(list_elem_64);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetActiveMemberMidsByBuddyMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetActiveMemberMidsByBuddyMid"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetAllBuddyMembersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetAllBuddyMembersArgs {
}

impl BuddyManagementServiceGetAllBuddyMembersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetAllBuddyMembersArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetAllBuddyMembersArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getAllBuddyMembers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetAllBuddyMembersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetAllBuddyMembersResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetAllBuddyMembersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetAllBuddyMembersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_65 = i_prot.read_string()?;
            val.push(list_elem_65);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetAllBuddyMembersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetAllBuddyMembersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetAllBuddyMembers"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetBlockedBuddyMembersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBlockedBuddyMembersArgs {
}

impl BuddyManagementServiceGetBlockedBuddyMembersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBlockedBuddyMembersArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetBlockedBuddyMembersArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBlockedBuddyMembers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetBlockedBuddyMembersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBlockedBuddyMembersResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetBlockedBuddyMembersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBlockedBuddyMembersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = i_prot.read_string()?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetBlockedBuddyMembersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetBlockedBuddyMembersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetBlockedBuddyMembers"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetBlockerCountByBuddyMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBlockerCountByBuddyMidArgs {
  buddy_mid: String,
}

impl BuddyManagementServiceGetBlockerCountByBuddyMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBlockerCountByBuddyMidArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetBlockerCountByBuddyMidArgs.buddy_mid", &f_2)?;
    let ret = BuddyManagementServiceGetBlockerCountByBuddyMidArgs {
      buddy_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBlockerCountByBuddyMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 2))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetBlockerCountByBuddyMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBlockerCountByBuddyMidResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetBlockerCountByBuddyMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBlockerCountByBuddyMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetBlockerCountByBuddyMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetBlockerCountByBuddyMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetBlockerCountByBuddyMid"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetBuddyDetailByMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBuddyDetailByMidArgs {
  buddy_mid: String,
}

impl BuddyManagementServiceGetBuddyDetailByMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBuddyDetailByMidArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetBuddyDetailByMidArgs.buddy_mid", &f_2)?;
    let ret = BuddyManagementServiceGetBuddyDetailByMidArgs {
      buddy_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBuddyDetailByMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 2))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetBuddyDetailByMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBuddyDetailByMidResult {
  result_value: Option<BuddyDetail>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetBuddyDetailByMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBuddyDetailByMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BuddyDetail> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = BuddyDetail::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetBuddyDetailByMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetBuddyDetailByMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BuddyDetail> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetBuddyDetailByMid"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetBuddyProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBuddyProfileArgs {
}

impl BuddyManagementServiceGetBuddyProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBuddyProfileArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetBuddyProfileArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBuddyProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetBuddyProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetBuddyProfileResult {
  result_value: Option<BuddyProfile>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetBuddyProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetBuddyProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BuddyProfile> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = BuddyProfile::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetBuddyProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetBuddyProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BuddyProfile> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetBuddyProfile"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetContactTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetContactTicketArgs {
}

impl BuddyManagementServiceGetContactTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetContactTicketArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetContactTicketArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getContactTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetContactTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetContactTicketResult {
  result_value: Option<Ticket>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetContactTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetContactTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Ticket> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Ticket::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetContactTicketResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetContactTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Ticket> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetContactTicket"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetMemberCountByBuddyMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetMemberCountByBuddyMidArgs {
  buddy_mid: String,
}

impl BuddyManagementServiceGetMemberCountByBuddyMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetMemberCountByBuddyMidArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetMemberCountByBuddyMidArgs.buddy_mid", &f_2)?;
    let ret = BuddyManagementServiceGetMemberCountByBuddyMidArgs {
      buddy_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMemberCountByBuddyMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 2))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetMemberCountByBuddyMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetMemberCountByBuddyMidResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetMemberCountByBuddyMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetMemberCountByBuddyMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetMemberCountByBuddyMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetMemberCountByBuddyMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetMemberCountByBuddyMid"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetSendBuddyMessageResultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetSendBuddyMessageResultArgs {
  send_buddy_message_request_id: String,
}

impl BuddyManagementServiceGetSendBuddyMessageResultArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetSendBuddyMessageResultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetSendBuddyMessageResultArgs.send_buddy_message_request_id", &f_1)?;
    let ret = BuddyManagementServiceGetSendBuddyMessageResultArgs {
      send_buddy_message_request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSendBuddyMessageResult_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sendBuddyMessageRequestId", TType::String, 1))?;
    o_prot.write_string(&self.send_buddy_message_request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetSendBuddyMessageResultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetSendBuddyMessageResultResult {
  result_value: Option<SendBuddyMessageResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetSendBuddyMessageResultResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetSendBuddyMessageResultResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SendBuddyMessageResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetSendBuddyMessageResultResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetSendBuddyMessageResultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SendBuddyMessageResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetSendBuddyMessageResult"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetSetBuddyOnAirResultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetSetBuddyOnAirResultArgs {
  set_buddy_on_air_request_id: String,
}

impl BuddyManagementServiceGetSetBuddyOnAirResultArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetSetBuddyOnAirResultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetSetBuddyOnAirResultArgs.set_buddy_on_air_request_id", &f_1)?;
    let ret = BuddyManagementServiceGetSetBuddyOnAirResultArgs {
      set_buddy_on_air_request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSetBuddyOnAirResult_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("setBuddyOnAirRequestId", TType::String, 1))?;
    o_prot.write_string(&self.set_buddy_on_air_request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetSetBuddyOnAirResultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetSetBuddyOnAirResultResult {
  result_value: Option<SetBuddyOnAirResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetSetBuddyOnAirResultResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetSetBuddyOnAirResultResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SetBuddyOnAirResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SetBuddyOnAirResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetSetBuddyOnAirResultResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetSetBuddyOnAirResultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SetBuddyOnAirResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetSetBuddyOnAirResult"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceGetUpdateBuddyProfileResultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetUpdateBuddyProfileResultArgs {
  update_buddy_profile_request_id: String,
}

impl BuddyManagementServiceGetUpdateBuddyProfileResultArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetUpdateBuddyProfileResultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceGetUpdateBuddyProfileResultArgs.update_buddy_profile_request_id", &f_1)?;
    let ret = BuddyManagementServiceGetUpdateBuddyProfileResultArgs {
      update_buddy_profile_request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUpdateBuddyProfileResult_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updateBuddyProfileRequestId", TType::String, 1))?;
    o_prot.write_string(&self.update_buddy_profile_request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceGetUpdateBuddyProfileResultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceGetUpdateBuddyProfileResultResult {
  result_value: Option<UpdateBuddyProfileResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceGetUpdateBuddyProfileResultResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceGetUpdateBuddyProfileResultResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UpdateBuddyProfileResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UpdateBuddyProfileResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceGetUpdateBuddyProfileResultResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceGetUpdateBuddyProfileResultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<UpdateBuddyProfileResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceGetUpdateBuddyProfileResult"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceIsBuddyOnAirByMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceIsBuddyOnAirByMidArgs {
  buddy_mid: String,
}

impl BuddyManagementServiceIsBuddyOnAirByMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceIsBuddyOnAirByMidArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceIsBuddyOnAirByMidArgs.buddy_mid", &f_2)?;
    let ret = BuddyManagementServiceIsBuddyOnAirByMidArgs {
      buddy_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("isBuddyOnAirByMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 2))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceIsBuddyOnAirByMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceIsBuddyOnAirByMidResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceIsBuddyOnAirByMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceIsBuddyOnAirByMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceIsBuddyOnAirByMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceIsBuddyOnAirByMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceIsBuddyOnAirByMid"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs {
  request_id: String,
  msg: Message,
  source_content_id: String,
}

impl BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs.source_content_id", &f_3)?;
    let ret = BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      source_content_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("linkAndSendBuddyContentMessageToAllAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sourceContentId", TType::String, 3))?;
    o_prot.write_string(&self.source_content_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceLinkAndSendBuddyContentMessageToAllAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs {
  request_id: String,
  msg: Message,
  source_content_id: String,
  mids: Vec<String>,
}

impl BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = i_prot.read_string()?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs.source_content_id", &f_3)?;
    verify_required_field_exists("BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs.mids", &f_4)?;
    let ret = BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      source_content_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      mids: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("linkAndSendBuddyContentMessageToMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sourceContentId", TType::String, 3))?;
    o_prot.write_string(&self.source_content_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mids", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.mids.len() as i32))?;
    for e in &self.mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult {
  result_value: Option<SendBuddyMessageResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SendBuddyMessageResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceLinkAndSendBuddyContentMessageToMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SendBuddyMessageResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceLinkAndSendBuddyContentMessageToMids"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceNotifyBuddyBlockedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceNotifyBuddyBlockedArgs {
  buddy_mid: String,
  blocker_mid: String,
}

impl BuddyManagementServiceNotifyBuddyBlockedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceNotifyBuddyBlockedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceNotifyBuddyBlockedArgs.buddy_mid", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceNotifyBuddyBlockedArgs.blocker_mid", &f_2)?;
    let ret = BuddyManagementServiceNotifyBuddyBlockedArgs {
      buddy_mid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      blocker_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyBuddyBlocked_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 1))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("blockerMid", TType::String, 2))?;
    o_prot.write_string(&self.blocker_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceNotifyBuddyBlockedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceNotifyBuddyBlockedResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceNotifyBuddyBlockedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceNotifyBuddyBlockedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceNotifyBuddyBlockedResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceNotifyBuddyBlockedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceNotifyBuddyUnblockedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceNotifyBuddyUnblockedArgs {
  buddy_mid: String,
  blocker_mid: String,
}

impl BuddyManagementServiceNotifyBuddyUnblockedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceNotifyBuddyUnblockedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceNotifyBuddyUnblockedArgs.buddy_mid", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceNotifyBuddyUnblockedArgs.blocker_mid", &f_2)?;
    let ret = BuddyManagementServiceNotifyBuddyUnblockedArgs {
      buddy_mid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      blocker_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyBuddyUnblocked_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 1))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("blockerMid", TType::String, 2))?;
    o_prot.write_string(&self.blocker_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceNotifyBuddyUnblockedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceNotifyBuddyUnblockedResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceNotifyBuddyUnblockedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceNotifyBuddyUnblockedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceNotifyBuddyUnblockedResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceNotifyBuddyUnblockedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceRegisterBuddyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRegisterBuddyArgs {
  buddy_id: String,
  search_id: String,
  display_name: String,
  status_meessage: String,
  picture: Vec<u8>,
  settings: BTreeMap<String, String>,
}

impl BuddyManagementServiceRegisterBuddyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRegisterBuddyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<u8>> = None;
    let mut f_7: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bytes()?;
          f_6 = Some(val);
        },
        7 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_68 = i_prot.read_string()?;
            let map_val_69 = i_prot.read_string()?;
            val.insert(map_key_68, map_val_69);
          }
          i_prot.read_map_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyArgs.buddy_id", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyArgs.search_id", &f_3)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyArgs.display_name", &f_4)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyArgs.status_meessage", &f_5)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyArgs.picture", &f_6)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyArgs.settings", &f_7)?;
    let ret = BuddyManagementServiceRegisterBuddyArgs {
      buddy_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      search_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      display_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
      status_meessage: f_5.expect("auto-generated code should have checked for presence of required fields"),
      picture: f_6.expect("auto-generated code should have checked for presence of required fields"),
      settings: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerBuddy_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyId", TType::String, 2))?;
    o_prot.write_string(&self.buddy_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("searchId", TType::String, 3))?;
    o_prot.write_string(&self.search_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 4))?;
    o_prot.write_string(&self.display_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statusMeessage", TType::String, 5))?;
    o_prot.write_string(&self.status_meessage)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("picture", TType::String, 6))?;
    o_prot.write_bytes(&self.picture)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::Map, 7))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.settings.len() as i32))?;
    for (k, v) in &self.settings {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceRegisterBuddyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRegisterBuddyResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceRegisterBuddyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRegisterBuddyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceRegisterBuddyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceRegisterBuddyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceRegisterBuddy"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceRegisterBuddyAdminArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRegisterBuddyAdminArgs {
  buddy_id: String,
  search_id: String,
  display_name: String,
  status_message: String,
  picture: Vec<u8>,
}

impl BuddyManagementServiceRegisterBuddyAdminArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRegisterBuddyAdminArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bytes()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyAdminArgs.buddy_id", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyAdminArgs.search_id", &f_3)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyAdminArgs.display_name", &f_4)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyAdminArgs.status_message", &f_5)?;
    verify_required_field_exists("BuddyManagementServiceRegisterBuddyAdminArgs.picture", &f_6)?;
    let ret = BuddyManagementServiceRegisterBuddyAdminArgs {
      buddy_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      search_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      display_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
      status_message: f_5.expect("auto-generated code should have checked for presence of required fields"),
      picture: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerBuddyAdmin_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyId", TType::String, 2))?;
    o_prot.write_string(&self.buddy_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("searchId", TType::String, 3))?;
    o_prot.write_string(&self.search_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 4))?;
    o_prot.write_string(&self.display_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statusMessage", TType::String, 5))?;
    o_prot.write_string(&self.status_message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("picture", TType::String, 6))?;
    o_prot.write_bytes(&self.picture)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceRegisterBuddyAdminResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRegisterBuddyAdminResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceRegisterBuddyAdminResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRegisterBuddyAdminResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceRegisterBuddyAdminResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceRegisterBuddyAdminResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceRegisterBuddyAdmin"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceReissueContactTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceReissueContactTicketArgs {
  expiration_time: i64,
  max_use_count: i32,
}

impl BuddyManagementServiceReissueContactTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceReissueContactTicketArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceReissueContactTicketArgs.expiration_time", &f_3)?;
    verify_required_field_exists("BuddyManagementServiceReissueContactTicketArgs.max_use_count", &f_4)?;
    let ret = BuddyManagementServiceReissueContactTicketArgs {
      expiration_time: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_use_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reissueContactTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expirationTime", TType::I64, 3))?;
    o_prot.write_i64(self.expiration_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxUseCount", TType::I32, 4))?;
    o_prot.write_i32(self.max_use_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceReissueContactTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceReissueContactTicketResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceReissueContactTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceReissueContactTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceReissueContactTicketResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceReissueContactTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceReissueContactTicket"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceRemoveBuddyMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRemoveBuddyMemberArgs {
  request_id: String,
  user_mid: String,
}

impl BuddyManagementServiceRemoveBuddyMemberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRemoveBuddyMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceRemoveBuddyMemberArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceRemoveBuddyMemberArgs.user_mid", &f_2)?;
    let ret = BuddyManagementServiceRemoveBuddyMemberArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeBuddyMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userMid", TType::String, 2))?;
    o_prot.write_string(&self.user_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceRemoveBuddyMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRemoveBuddyMemberResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceRemoveBuddyMemberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRemoveBuddyMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceRemoveBuddyMemberResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceRemoveBuddyMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceRemoveBuddyMembersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRemoveBuddyMembersArgs {
  request_id: String,
  user_mids: Vec<String>,
}

impl BuddyManagementServiceRemoveBuddyMembersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRemoveBuddyMembersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_70 = i_prot.read_string()?;
            val.push(list_elem_70);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceRemoveBuddyMembersArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceRemoveBuddyMembersArgs.user_mids", &f_2)?;
    let ret = BuddyManagementServiceRemoveBuddyMembersArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_mids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeBuddyMembers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userMids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.user_mids.len() as i32))?;
    for e in &self.user_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceRemoveBuddyMembersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceRemoveBuddyMembersResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceRemoveBuddyMembersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceRemoveBuddyMembersResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceRemoveBuddyMembersResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceRemoveBuddyMembersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToAllArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToAllArgs {
  request_id: String,
  msg: Message,
  content: Vec<u8>,
}

impl BuddyManagementServiceSendBuddyContentMessageToAllArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToAllArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToAllArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToAllArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToAllArgs.content", &f_3)?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToAllArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyContentMessageToAll_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
    o_prot.write_bytes(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToAllResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToAllResult {
  result_value: Option<SendBuddyMessageResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyContentMessageToAllResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToAllResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SendBuddyMessageResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToAllResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyContentMessageToAllResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SendBuddyMessageResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyContentMessageToAll"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs {
  request_id: String,
  msg: Message,
  content: Vec<u8>,
}

impl BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs.content", &f_3)?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToAllAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyContentMessageToAllAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
    o_prot.write_bytes(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyContentMessageToAllAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyContentMessageToAllAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToMidsArgs {
  request_id: String,
  msg: Message,
  content: Vec<u8>,
  mids: Vec<String>,
}

impl BuddyManagementServiceSendBuddyContentMessageToMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToMidsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_71 = i_prot.read_string()?;
            val.push(list_elem_71);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsArgs.content", &f_3)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsArgs.mids", &f_4)?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToMidsArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      mids: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyContentMessageToMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
    o_prot.write_bytes(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mids", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.mids.len() as i32))?;
    for e in &self.mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToMidsResult {
  result_value: Option<SendBuddyMessageResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyContentMessageToMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SendBuddyMessageResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyContentMessageToMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SendBuddyMessageResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyContentMessageToMids"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs {
  request_id: String,
  msg: Message,
  content: Vec<u8>,
  mids: Vec<String>,
}

impl BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_72 = i_prot.read_string()?;
            val.push(list_elem_72);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs.content", &f_3)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs.mids", &f_4)?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToMidsAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      mids: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyContentMessageToMidsAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
    o_prot.write_bytes(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mids", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.mids.len() as i32))?;
    for e in &self.mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyContentMessageToMidsAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyContentMessageToMidsAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendBuddyMessageToAllArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToAllArgs {
  request_id: String,
  msg: Message,
}

impl BuddyManagementServiceSendBuddyMessageToAllArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToAllArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToAllArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToAllArgs.msg", &f_2)?;
    let ret = BuddyManagementServiceSendBuddyMessageToAllArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyMessageToAll_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyMessageToAllResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToAllResult {
  result_value: Option<SendBuddyMessageResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyMessageToAllResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToAllResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SendBuddyMessageResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyMessageToAllResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyMessageToAllResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SendBuddyMessageResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyMessageToAll"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendBuddyMessageToAllAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToAllAsyncArgs {
  request_id: String,
  msg: Message,
}

impl BuddyManagementServiceSendBuddyMessageToAllAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToAllAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToAllAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToAllAsyncArgs.msg", &f_2)?;
    let ret = BuddyManagementServiceSendBuddyMessageToAllAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyMessageToAllAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyMessageToAllAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToAllAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyMessageToAllAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToAllAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyMessageToAllAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyMessageToAllAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyMessageToAllAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendBuddyMessageToMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToMidsArgs {
  request_id: String,
  msg: Message,
  mids: Vec<String>,
}

impl BuddyManagementServiceSendBuddyMessageToMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToMidsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_73 = i_prot.read_string()?;
            val.push(list_elem_73);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToMidsArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToMidsArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToMidsArgs.mids", &f_3)?;
    let ret = BuddyManagementServiceSendBuddyMessageToMidsArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      mids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyMessageToMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mids", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.mids.len() as i32))?;
    for e in &self.mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyMessageToMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToMidsResult {
  result_value: Option<SendBuddyMessageResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyMessageToMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SendBuddyMessageResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyMessageToMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyMessageToMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SendBuddyMessageResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyMessageToMids"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs {
  request_id: String,
  msg: Message,
  mids: Vec<String>,
}

impl BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Message> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_74 = i_prot.read_string()?;
            val.push(list_elem_74);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs.msg", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs.mids", &f_3)?;
    let ret = BuddyManagementServiceSendBuddyMessageToMidsAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
      mids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendBuddyMessageToMidsAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::Struct, 2))?;
    self.msg.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mids", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.mids.len() as i32))?;
    for e in &self.mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendBuddyMessageToMidsAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendBuddyMessageToMidsAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendBuddyMessageToMidsAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendBuddyMessageToMidsAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendBuddyMessageToMidsAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendBuddyMessageToMidsAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSendBuddyMessageToMidsAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSendIndividualEventToAllAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendIndividualEventToAllAsyncArgs {
  request_id: String,
  buddy_mid: String,
  notification_status: NotificationStatus,
}

impl BuddyManagementServiceSendIndividualEventToAllAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendIndividualEventToAllAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<NotificationStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = NotificationStatus::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSendIndividualEventToAllAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSendIndividualEventToAllAsyncArgs.buddy_mid", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceSendIndividualEventToAllAsyncArgs.notification_status", &f_3)?;
    let ret = BuddyManagementServiceSendIndividualEventToAllAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      buddy_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      notification_status: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendIndividualEventToAllAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 2))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationStatus", TType::I32, 3))?;
    self.notification_status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSendIndividualEventToAllAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSendIndividualEventToAllAsyncResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceSendIndividualEventToAllAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSendIndividualEventToAllAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSendIndividualEventToAllAsyncResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSendIndividualEventToAllAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceSetBuddyOnAirArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSetBuddyOnAirArgs {
  request_id: String,
  on_air: bool,
}

impl BuddyManagementServiceSetBuddyOnAirArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSetBuddyOnAirArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSetBuddyOnAirArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSetBuddyOnAirArgs.on_air", &f_2)?;
    let ret = BuddyManagementServiceSetBuddyOnAirArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      on_air: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setBuddyOnAir_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("onAir", TType::Bool, 2))?;
    o_prot.write_bool(self.on_air)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSetBuddyOnAirResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSetBuddyOnAirResult {
  result_value: Option<SetBuddyOnAirResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSetBuddyOnAirResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSetBuddyOnAirResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SetBuddyOnAirResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SetBuddyOnAirResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSetBuddyOnAirResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSetBuddyOnAirResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SetBuddyOnAirResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSetBuddyOnAir"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceSetBuddyOnAirAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSetBuddyOnAirAsyncArgs {
  request_id: String,
  on_air: bool,
}

impl BuddyManagementServiceSetBuddyOnAirAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSetBuddyOnAirAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceSetBuddyOnAirAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceSetBuddyOnAirAsyncArgs.on_air", &f_2)?;
    let ret = BuddyManagementServiceSetBuddyOnAirAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      on_air: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setBuddyOnAirAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("onAir", TType::Bool, 2))?;
    o_prot.write_bool(self.on_air)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceSetBuddyOnAirAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceSetBuddyOnAirAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceSetBuddyOnAirAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceSetBuddyOnAirAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceSetBuddyOnAirAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceSetBuddyOnAirAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceSetBuddyOnAirAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceStoreMessageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceStoreMessageArgs {
  request_id: String,
  message_request: BuddyMessageRequest,
}

impl BuddyManagementServiceStoreMessageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceStoreMessageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<BuddyMessageRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = BuddyMessageRequest::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceStoreMessageArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceStoreMessageArgs.message_request", &f_2)?;
    let ret = BuddyManagementServiceStoreMessageArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message_request: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("storeMessage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageRequest", TType::Struct, 2))?;
    self.message_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceStoreMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceStoreMessageResult {
  result_value: Option<SendBuddyMessageResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceStoreMessageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceStoreMessageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SendBuddyMessageResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SendBuddyMessageResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceStoreMessageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceStoreMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SendBuddyMessageResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceStoreMessage"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceUnblockBuddyMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUnblockBuddyMemberArgs {
  request_id: String,
  mid: String,
}

impl BuddyManagementServiceUnblockBuddyMemberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUnblockBuddyMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUnblockBuddyMemberArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUnblockBuddyMemberArgs.mid", &f_2)?;
    let ret = BuddyManagementServiceUnblockBuddyMemberArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unblockBuddyMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUnblockBuddyMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUnblockBuddyMemberResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceUnblockBuddyMemberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUnblockBuddyMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUnblockBuddyMemberResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUnblockBuddyMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceUnregisterBuddyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUnregisterBuddyArgs {
  request_id: String,
}

impl BuddyManagementServiceUnregisterBuddyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUnregisterBuddyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUnregisterBuddyArgs.request_id", &f_1)?;
    let ret = BuddyManagementServiceUnregisterBuddyArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unregisterBuddy_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUnregisterBuddyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUnregisterBuddyResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceUnregisterBuddyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUnregisterBuddyResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUnregisterBuddyResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUnregisterBuddyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceUnregisterBuddyAdminArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUnregisterBuddyAdminArgs {
  request_id: String,
}

impl BuddyManagementServiceUnregisterBuddyAdminArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUnregisterBuddyAdminArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUnregisterBuddyAdminArgs.request_id", &f_1)?;
    let ret = BuddyManagementServiceUnregisterBuddyAdminArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unregisterBuddyAdmin_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUnregisterBuddyAdminResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUnregisterBuddyAdminResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceUnregisterBuddyAdminResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUnregisterBuddyAdminResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUnregisterBuddyAdminResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUnregisterBuddyAdminResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs {
  request_id: String,
  attributes: BTreeMap<String, String>,
}

impl BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_75 = i_prot.read_string()?;
            let map_val_76 = i_prot.read_string()?;
            val.insert(map_key_75, map_val_76);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs.attributes", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddyAdminProfileAttributeArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      attributes: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddyAdminProfileAttribute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.attributes.len() as i32))?;
    for (k, v) in &self.attributes {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddyAdminProfileAttributeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceUpdateBuddyAdminProfileImageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyAdminProfileImageArgs {
  request_id: String,
  picture: Vec<u8>,
}

impl BuddyManagementServiceUpdateBuddyAdminProfileImageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyAdminProfileImageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyAdminProfileImageArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyAdminProfileImageArgs.picture", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddyAdminProfileImageArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      picture: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddyAdminProfileImage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("picture", TType::String, 2))?;
    o_prot.write_bytes(&self.picture)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddyAdminProfileImageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyAdminProfileImageResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddyAdminProfileImageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyAdminProfileImageResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddyAdminProfileImageResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddyAdminProfileImageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileAttributesArgs {
  request_id: String,
  attributes: BTreeMap<String, String>,
}

impl BuddyManagementServiceUpdateBuddyProfileAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_77 = i_prot.read_string()?;
            let map_val_78 = i_prot.read_string()?;
            val.insert(map_key_77, map_val_78);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileAttributesArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileAttributesArgs.attributes", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddyProfileAttributesArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      attributes: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddyProfileAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.attributes.len() as i32))?;
    for (k, v) in &self.attributes {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileAttributesResult {
  result_value: Option<UpdateBuddyProfileResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddyProfileAttributesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UpdateBuddyProfileResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UpdateBuddyProfileResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddyProfileAttributesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddyProfileAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<UpdateBuddyProfileResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceUpdateBuddyProfileAttributes"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs {
  request_id: String,
  attributes: BTreeMap<String, String>,
}

impl BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_79 = i_prot.read_string()?;
            let map_val_80 = i_prot.read_string()?;
            val.insert(map_key_79, map_val_80);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs.attributes", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddyProfileAttributesAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      attributes: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddyProfileAttributesAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.attributes.len() as i32))?;
    for (k, v) in &self.attributes {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddyProfileAttributesAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceUpdateBuddyProfileAttributesAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileImageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileImageArgs {
  request_id: String,
  image: Vec<u8>,
}

impl BuddyManagementServiceUpdateBuddyProfileImageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileImageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileImageArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileImageArgs.image", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddyProfileImageArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      image: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddyProfileImage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image", TType::String, 2))?;
    o_prot.write_bytes(&self.image)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileImageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileImageResult {
  result_value: Option<UpdateBuddyProfileResult>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddyProfileImageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileImageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UpdateBuddyProfileResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UpdateBuddyProfileResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddyProfileImageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddyProfileImageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<UpdateBuddyProfileResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceUpdateBuddyProfileImage"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs {
  request_id: String,
  image: Vec<u8>,
}

impl BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs.image", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddyProfileImageAsyncArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      image: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddyProfileImageAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image", TType::String, 2))?;
    o_prot.write_bytes(&self.image)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddyProfileImageAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddyProfileImageAsyncResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddyProfileImageAsyncResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddyProfileImageAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddyProfileImageAsyncResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddyProfileImageAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceUpdateBuddyProfileImageAsync"
          )
        )
      )
    }
  }
}

//
// BuddyManagementServiceUpdateBuddySearchIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddySearchIdArgs {
  request_id: String,
  search_id: String,
}

impl BuddyManagementServiceUpdateBuddySearchIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddySearchIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddySearchIdArgs.request_id", &f_1)?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddySearchIdArgs.search_id", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddySearchIdArgs {
      request_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      search_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddySearchId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 1))?;
    o_prot.write_string(&self.request_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("searchId", TType::String, 2))?;
    o_prot.write_string(&self.search_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddySearchIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddySearchIdResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddySearchIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddySearchIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddySearchIdResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddySearchIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceUpdateBuddySettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddySettingsArgs {
  settings: BTreeMap<String, String>,
}

impl BuddyManagementServiceUpdateBuddySettingsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddySettingsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_81 = i_prot.read_string()?;
            let map_val_82 = i_prot.read_string()?;
            val.insert(map_key_81, map_val_82);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUpdateBuddySettingsArgs.settings", &f_2)?;
    let ret = BuddyManagementServiceUpdateBuddySettingsArgs {
      settings: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddySettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.settings.len() as i32))?;
    for (k, v) in &self.settings {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUpdateBuddySettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUpdateBuddySettingsResult {
  e: Option<TalkException>,
}

impl BuddyManagementServiceUpdateBuddySettingsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUpdateBuddySettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUpdateBuddySettingsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUpdateBuddySettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// BuddyManagementServiceUploadBuddyContentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUploadBuddyContentArgs {
  content_type: ContentType,
  content: Vec<u8>,
}

impl BuddyManagementServiceUploadBuddyContentArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUploadBuddyContentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<ContentType> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = ContentType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyManagementServiceUploadBuddyContentArgs.content_type", &f_2)?;
    verify_required_field_exists("BuddyManagementServiceUploadBuddyContentArgs.content", &f_3)?;
    let ret = BuddyManagementServiceUploadBuddyContentArgs {
      content_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("uploadBuddyContent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contentType", TType::I32, 2))?;
    self.content_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
    o_prot.write_bytes(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyManagementServiceUploadBuddyContentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyManagementServiceUploadBuddyContentResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl BuddyManagementServiceUploadBuddyContentResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyManagementServiceUploadBuddyContentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyManagementServiceUploadBuddyContentResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyManagementServiceUploadBuddyContentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyManagementServiceUploadBuddyContent"
          )
        )
      )
    }
  }
}

//
// BuddyService service client
//

pub trait TBuddyServiceSyncClient {
  fn find_buddy_contacts_by_query(&mut self, language: String, country: String, query: String, from_index: i32, count: i32, request_source: BuddySearchRequestSource) -> thrift::Result<Vec<BuddySearchResult>>;
  fn get_buddy_contacts(&mut self, language: String, country: String, classification: String, from_index: i32, count: i32) -> thrift::Result<Vec<Contact>>;
  fn get_buddy_detail(&mut self, buddy_mid: String) -> thrift::Result<BuddyDetail>;
  fn get_buddy_on_air(&mut self, buddy_mid: String) -> thrift::Result<BuddyOnAir>;
  fn get_countries_having_buddy(&mut self) -> thrift::Result<Vec<String>>;
  fn get_newly_released_buddy_ids(&mut self, country: String) -> thrift::Result<BTreeMap<String, i64>>;
  fn get_popular_buddy_banner(&mut self, language: String, country: String, application_type: ApplicationType, resource_specification: String) -> thrift::Result<BuddyBanner>;
  fn get_popular_buddy_lists(&mut self, language: String, country: String) -> thrift::Result<Vec<BuddyList>>;
  fn get_promoted_buddy_contacts(&mut self, language: String, country: String) -> thrift::Result<Vec<Contact>>;
}

pub trait TBuddyServiceSyncClientMarker {}

pub struct BuddyServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> BuddyServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> BuddyServiceSyncClient<IP, OP> {
    BuddyServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for BuddyServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TBuddyServiceSyncClientMarker for BuddyServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TBuddyServiceSyncClientMarker> TBuddyServiceSyncClient for C {
  fn find_buddy_contacts_by_query(&mut self, language: String, country: String, query: String, from_index: i32, count: i32, request_source: BuddySearchRequestSource) -> thrift::Result<Vec<BuddySearchResult>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findBuddyContactsByQuery", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceFindBuddyContactsByQueryArgs { language: language, country: country, query: query, from_index: from_index, count: count, request_source: request_source };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findBuddyContactsByQuery", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceFindBuddyContactsByQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_buddy_contacts(&mut self, language: String, country: String, classification: String, from_index: i32, count: i32) -> thrift::Result<Vec<Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBuddyContacts", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetBuddyContactsArgs { language: language, country: country, classification: classification, from_index: from_index, count: count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBuddyContacts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetBuddyContactsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_buddy_detail(&mut self, buddy_mid: String) -> thrift::Result<BuddyDetail> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBuddyDetail", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetBuddyDetailArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBuddyDetail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetBuddyDetailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_buddy_on_air(&mut self, buddy_mid: String) -> thrift::Result<BuddyOnAir> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBuddyOnAir", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetBuddyOnAirArgs { buddy_mid: buddy_mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBuddyOnAir", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetBuddyOnAirResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_countries_having_buddy(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCountriesHavingBuddy", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetCountriesHavingBuddyArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCountriesHavingBuddy", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetCountriesHavingBuddyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_newly_released_buddy_ids(&mut self, country: String) -> thrift::Result<BTreeMap<String, i64>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNewlyReleasedBuddyIds", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetNewlyReleasedBuddyIdsArgs { country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNewlyReleasedBuddyIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetNewlyReleasedBuddyIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_popular_buddy_banner(&mut self, language: String, country: String, application_type: ApplicationType, resource_specification: String) -> thrift::Result<BuddyBanner> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPopularBuddyBanner", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetPopularBuddyBannerArgs { language: language, country: country, application_type: application_type, resource_specification: resource_specification };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPopularBuddyBanner", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetPopularBuddyBannerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_popular_buddy_lists(&mut self, language: String, country: String) -> thrift::Result<Vec<BuddyList>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPopularBuddyLists", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetPopularBuddyListsArgs { language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPopularBuddyLists", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetPopularBuddyListsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_promoted_buddy_contacts(&mut self, language: String, country: String) -> thrift::Result<Vec<Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPromotedBuddyContacts", TMessageType::Call, self.sequence_number());
        let call_args = BuddyServiceGetPromotedBuddyContactsArgs { language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPromotedBuddyContacts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BuddyServiceGetPromotedBuddyContactsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// BuddyService service processor
//

pub trait BuddyServiceSyncHandler {
  fn handle_find_buddy_contacts_by_query(&self, language: String, country: String, query: String, from_index: i32, count: i32, request_source: BuddySearchRequestSource) -> thrift::Result<Vec<BuddySearchResult>>;
  fn handle_get_buddy_contacts(&self, language: String, country: String, classification: String, from_index: i32, count: i32) -> thrift::Result<Vec<Contact>>;
  fn handle_get_buddy_detail(&self, buddy_mid: String) -> thrift::Result<BuddyDetail>;
  fn handle_get_buddy_on_air(&self, buddy_mid: String) -> thrift::Result<BuddyOnAir>;
  fn handle_get_countries_having_buddy(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_newly_released_buddy_ids(&self, country: String) -> thrift::Result<BTreeMap<String, i64>>;
  fn handle_get_popular_buddy_banner(&self, language: String, country: String, application_type: ApplicationType, resource_specification: String) -> thrift::Result<BuddyBanner>;
  fn handle_get_popular_buddy_lists(&self, language: String, country: String) -> thrift::Result<Vec<BuddyList>>;
  fn handle_get_promoted_buddy_contacts(&self, language: String, country: String) -> thrift::Result<Vec<Contact>>;
}

pub struct BuddyServiceSyncProcessor<H: BuddyServiceSyncHandler> {
  handler: H,
}

impl <H: BuddyServiceSyncHandler> BuddyServiceSyncProcessor<H> {
  pub fn new(handler: H) -> BuddyServiceSyncProcessor<H> {
    BuddyServiceSyncProcessor {
      handler,
    }
  }
  fn process_find_buddy_contacts_by_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_find_buddy_contacts_by_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_buddy_contacts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_buddy_contacts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_buddy_detail(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_buddy_detail(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_buddy_on_air(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_buddy_on_air(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_countries_having_buddy(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_countries_having_buddy(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_newly_released_buddy_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_newly_released_buddy_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_popular_buddy_banner(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_popular_buddy_banner(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_popular_buddy_lists(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_popular_buddy_lists(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_promoted_buddy_contacts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TBuddyServiceProcessFunctions::process_get_promoted_buddy_contacts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TBuddyServiceProcessFunctions;

impl TBuddyServiceProcessFunctions {
  pub fn process_find_buddy_contacts_by_query<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceFindBuddyContactsByQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_buddy_contacts_by_query(args.language, args.country, args.query, args.from_index, args.count, args.request_source) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findBuddyContactsByQuery", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceFindBuddyContactsByQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceFindBuddyContactsByQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findBuddyContactsByQuery", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findBuddyContactsByQuery", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findBuddyContactsByQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findBuddyContactsByQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_buddy_contacts<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceGetBuddyContactsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_buddy_contacts(args.language, args.country, args.classification, args.from_index, args.count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBuddyContacts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetBuddyContactsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetBuddyContactsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBuddyContacts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBuddyContacts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBuddyContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBuddyContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_buddy_detail<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceGetBuddyDetailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_buddy_detail(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBuddyDetail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetBuddyDetailResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetBuddyDetailResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBuddyDetail", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBuddyDetail", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBuddyDetail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBuddyDetail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_buddy_on_air<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceGetBuddyOnAirArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_buddy_on_air(args.buddy_mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBuddyOnAir", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetBuddyOnAirResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetBuddyOnAirResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBuddyOnAir", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_countries_having_buddy<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = BuddyServiceGetCountriesHavingBuddyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_countries_having_buddy() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCountriesHavingBuddy", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetCountriesHavingBuddyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetCountriesHavingBuddyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCountriesHavingBuddy", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCountriesHavingBuddy", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCountriesHavingBuddy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCountriesHavingBuddy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_newly_released_buddy_ids<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceGetNewlyReleasedBuddyIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_newly_released_buddy_ids(args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNewlyReleasedBuddyIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetNewlyReleasedBuddyIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetNewlyReleasedBuddyIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNewlyReleasedBuddyIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getNewlyReleasedBuddyIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNewlyReleasedBuddyIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getNewlyReleasedBuddyIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_popular_buddy_banner<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceGetPopularBuddyBannerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_popular_buddy_banner(args.language, args.country, args.application_type, args.resource_specification) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPopularBuddyBanner", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetPopularBuddyBannerResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetPopularBuddyBannerResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPopularBuddyBanner", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPopularBuddyBanner", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPopularBuddyBanner", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPopularBuddyBanner", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_popular_buddy_lists<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceGetPopularBuddyListsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_popular_buddy_lists(args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPopularBuddyLists", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetPopularBuddyListsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetPopularBuddyListsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPopularBuddyLists", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPopularBuddyLists", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPopularBuddyLists", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPopularBuddyLists", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_promoted_buddy_contacts<H: BuddyServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = BuddyServiceGetPromotedBuddyContactsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_promoted_buddy_contacts(args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPromotedBuddyContacts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BuddyServiceGetPromotedBuddyContactsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = BuddyServiceGetPromotedBuddyContactsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPromotedBuddyContacts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPromotedBuddyContacts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPromotedBuddyContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPromotedBuddyContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: BuddyServiceSyncHandler> TProcessor for BuddyServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "findBuddyContactsByQuery" => {
        self.process_find_buddy_contacts_by_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBuddyContacts" => {
        self.process_get_buddy_contacts(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBuddyDetail" => {
        self.process_get_buddy_detail(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBuddyOnAir" => {
        self.process_get_buddy_on_air(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCountriesHavingBuddy" => {
        self.process_get_countries_having_buddy(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNewlyReleasedBuddyIds" => {
        self.process_get_newly_released_buddy_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPopularBuddyBanner" => {
        self.process_get_popular_buddy_banner(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPopularBuddyLists" => {
        self.process_get_popular_buddy_lists(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPromotedBuddyContacts" => {
        self.process_get_promoted_buddy_contacts(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// BuddyServiceFindBuddyContactsByQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceFindBuddyContactsByQueryArgs {
  language: String,
  country: String,
  query: String,
  from_index: i32,
  count: i32,
  request_source: BuddySearchRequestSource,
}

impl BuddyServiceFindBuddyContactsByQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceFindBuddyContactsByQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<BuddySearchRequestSource> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = BuddySearchRequestSource::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceFindBuddyContactsByQueryArgs.language", &f_2)?;
    verify_required_field_exists("BuddyServiceFindBuddyContactsByQueryArgs.country", &f_3)?;
    verify_required_field_exists("BuddyServiceFindBuddyContactsByQueryArgs.query", &f_4)?;
    verify_required_field_exists("BuddyServiceFindBuddyContactsByQueryArgs.from_index", &f_5)?;
    verify_required_field_exists("BuddyServiceFindBuddyContactsByQueryArgs.count", &f_6)?;
    verify_required_field_exists("BuddyServiceFindBuddyContactsByQueryArgs.request_source", &f_7)?;
    let ret = BuddyServiceFindBuddyContactsByQueryArgs {
      language: f_2.expect("auto-generated code should have checked for presence of required fields"),
      country: f_3.expect("auto-generated code should have checked for presence of required fields"),
      query: f_4.expect("auto-generated code should have checked for presence of required fields"),
      from_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
      count: f_6.expect("auto-generated code should have checked for presence of required fields"),
      request_source: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findBuddyContactsByQuery_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 2))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 3))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 4))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fromIndex", TType::I32, 5))?;
    o_prot.write_i32(self.from_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 6))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestSource", TType::I32, 7))?;
    self.request_source.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceFindBuddyContactsByQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceFindBuddyContactsByQueryResult {
  result_value: Option<Vec<BuddySearchResult>>,
  e: Option<TalkException>,
}

impl BuddyServiceFindBuddyContactsByQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceFindBuddyContactsByQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<BuddySearchResult>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BuddySearchResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_83 = BuddySearchResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_83);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceFindBuddyContactsByQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceFindBuddyContactsByQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<BuddySearchResult>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceFindBuddyContactsByQuery"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetBuddyContactsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetBuddyContactsArgs {
  language: String,
  country: String,
  classification: String,
  from_index: i32,
  count: i32,
}

impl BuddyServiceGetBuddyContactsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetBuddyContactsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceGetBuddyContactsArgs.language", &f_2)?;
    verify_required_field_exists("BuddyServiceGetBuddyContactsArgs.country", &f_3)?;
    verify_required_field_exists("BuddyServiceGetBuddyContactsArgs.classification", &f_4)?;
    verify_required_field_exists("BuddyServiceGetBuddyContactsArgs.from_index", &f_5)?;
    verify_required_field_exists("BuddyServiceGetBuddyContactsArgs.count", &f_6)?;
    let ret = BuddyServiceGetBuddyContactsArgs {
      language: f_2.expect("auto-generated code should have checked for presence of required fields"),
      country: f_3.expect("auto-generated code should have checked for presence of required fields"),
      classification: f_4.expect("auto-generated code should have checked for presence of required fields"),
      from_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
      count: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBuddyContacts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 2))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 3))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("classification", TType::String, 4))?;
    o_prot.write_string(&self.classification)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fromIndex", TType::I32, 5))?;
    o_prot.write_i32(self.from_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 6))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetBuddyContactsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetBuddyContactsResult {
  result_value: Option<Vec<Contact>>,
  e: Option<TalkException>,
}

impl BuddyServiceGetBuddyContactsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetBuddyContactsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetBuddyContactsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetBuddyContactsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetBuddyContacts"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetBuddyDetailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetBuddyDetailArgs {
  buddy_mid: String,
}

impl BuddyServiceGetBuddyDetailArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetBuddyDetailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceGetBuddyDetailArgs.buddy_mid", &f_4)?;
    let ret = BuddyServiceGetBuddyDetailArgs {
      buddy_mid: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBuddyDetail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 4))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetBuddyDetailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetBuddyDetailResult {
  result_value: Option<BuddyDetail>,
  e: Option<TalkException>,
}

impl BuddyServiceGetBuddyDetailResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetBuddyDetailResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BuddyDetail> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = BuddyDetail::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetBuddyDetailResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetBuddyDetailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BuddyDetail> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetBuddyDetail"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetBuddyOnAirArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetBuddyOnAirArgs {
  buddy_mid: String,
}

impl BuddyServiceGetBuddyOnAirArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetBuddyOnAirArgs> {
    i_prot.read_struct_begin()?;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceGetBuddyOnAirArgs.buddy_mid", &f_4)?;
    let ret = BuddyServiceGetBuddyOnAirArgs {
      buddy_mid: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBuddyOnAir_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyMid", TType::String, 4))?;
    o_prot.write_string(&self.buddy_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetBuddyOnAirResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetBuddyOnAirResult {
  result_value: Option<BuddyOnAir>,
  e: Option<TalkException>,
}

impl BuddyServiceGetBuddyOnAirResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetBuddyOnAirResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BuddyOnAir> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = BuddyOnAir::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetBuddyOnAirResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetBuddyOnAirResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BuddyOnAir> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetBuddyOnAir"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetCountriesHavingBuddyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetCountriesHavingBuddyArgs {
}

impl BuddyServiceGetCountriesHavingBuddyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetCountriesHavingBuddyArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetCountriesHavingBuddyArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCountriesHavingBuddy_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetCountriesHavingBuddyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetCountriesHavingBuddyResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl BuddyServiceGetCountriesHavingBuddyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetCountriesHavingBuddyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_85 = i_prot.read_string()?;
            val.push(list_elem_85);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetCountriesHavingBuddyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetCountriesHavingBuddyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetCountriesHavingBuddy"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetNewlyReleasedBuddyIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetNewlyReleasedBuddyIdsArgs {
  country: String,
}

impl BuddyServiceGetNewlyReleasedBuddyIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetNewlyReleasedBuddyIdsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceGetNewlyReleasedBuddyIdsArgs.country", &f_3)?;
    let ret = BuddyServiceGetNewlyReleasedBuddyIdsArgs {
      country: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNewlyReleasedBuddyIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 3))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetNewlyReleasedBuddyIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetNewlyReleasedBuddyIdsResult {
  result_value: Option<BTreeMap<String, i64>>,
  e: Option<TalkException>,
}

impl BuddyServiceGetNewlyReleasedBuddyIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetNewlyReleasedBuddyIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, i64>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, i64> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_86 = i_prot.read_string()?;
            let map_val_87 = i_prot.read_i64()?;
            val.insert(map_key_86, map_val_87);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetNewlyReleasedBuddyIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetNewlyReleasedBuddyIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I64, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i64(*v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, i64>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetNewlyReleasedBuddyIds"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetPopularBuddyBannerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetPopularBuddyBannerArgs {
  language: String,
  country: String,
  application_type: ApplicationType,
  resource_specification: String,
}

impl BuddyServiceGetPopularBuddyBannerArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetPopularBuddyBannerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<ApplicationType> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = ApplicationType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceGetPopularBuddyBannerArgs.language", &f_2)?;
    verify_required_field_exists("BuddyServiceGetPopularBuddyBannerArgs.country", &f_3)?;
    verify_required_field_exists("BuddyServiceGetPopularBuddyBannerArgs.application_type", &f_4)?;
    verify_required_field_exists("BuddyServiceGetPopularBuddyBannerArgs.resource_specification", &f_5)?;
    let ret = BuddyServiceGetPopularBuddyBannerArgs {
      language: f_2.expect("auto-generated code should have checked for presence of required fields"),
      country: f_3.expect("auto-generated code should have checked for presence of required fields"),
      application_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      resource_specification: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPopularBuddyBanner_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 2))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 3))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("applicationType", TType::I32, 4))?;
    self.application_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resourceSpecification", TType::String, 5))?;
    o_prot.write_string(&self.resource_specification)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetPopularBuddyBannerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetPopularBuddyBannerResult {
  result_value: Option<BuddyBanner>,
  e: Option<TalkException>,
}

impl BuddyServiceGetPopularBuddyBannerResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetPopularBuddyBannerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BuddyBanner> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = BuddyBanner::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetPopularBuddyBannerResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetPopularBuddyBannerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BuddyBanner> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetPopularBuddyBanner"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetPopularBuddyListsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetPopularBuddyListsArgs {
  language: String,
  country: String,
}

impl BuddyServiceGetPopularBuddyListsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetPopularBuddyListsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceGetPopularBuddyListsArgs.language", &f_2)?;
    verify_required_field_exists("BuddyServiceGetPopularBuddyListsArgs.country", &f_3)?;
    let ret = BuddyServiceGetPopularBuddyListsArgs {
      language: f_2.expect("auto-generated code should have checked for presence of required fields"),
      country: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPopularBuddyLists_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 2))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 3))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetPopularBuddyListsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetPopularBuddyListsResult {
  result_value: Option<Vec<BuddyList>>,
  e: Option<TalkException>,
}

impl BuddyServiceGetPopularBuddyListsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetPopularBuddyListsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<BuddyList>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BuddyList> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_88 = BuddyList::read_from_in_protocol(i_prot)?;
            val.push(list_elem_88);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetPopularBuddyListsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetPopularBuddyListsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<BuddyList>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetPopularBuddyLists"
          )
        )
      )
    }
  }
}

//
// BuddyServiceGetPromotedBuddyContactsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetPromotedBuddyContactsArgs {
  language: String,
  country: String,
}

impl BuddyServiceGetPromotedBuddyContactsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetPromotedBuddyContactsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BuddyServiceGetPromotedBuddyContactsArgs.language", &f_2)?;
    verify_required_field_exists("BuddyServiceGetPromotedBuddyContactsArgs.country", &f_3)?;
    let ret = BuddyServiceGetPromotedBuddyContactsArgs {
      language: f_2.expect("auto-generated code should have checked for presence of required fields"),
      country: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPromotedBuddyContacts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 2))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 3))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BuddyServiceGetPromotedBuddyContactsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BuddyServiceGetPromotedBuddyContactsResult {
  result_value: Option<Vec<Contact>>,
  e: Option<TalkException>,
}

impl BuddyServiceGetPromotedBuddyContactsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BuddyServiceGetPromotedBuddyContactsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_89 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_89);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BuddyServiceGetPromotedBuddyContactsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BuddyServiceGetPromotedBuddyContactsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BuddyServiceGetPromotedBuddyContacts"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedService service client
//

pub trait TChannelApplicationProvidedServiceSyncClient {
  fn active_buddy_subscriber_count(&mut self) -> thrift::Result<i64>;
  fn add_operation_for_channel(&mut self, op_type: OpType, param1: String, param2: String, param3: String) -> thrift::Result<()>;
  fn display_buddy_subscriber_count(&mut self) -> thrift::Result<i64>;
  fn find_contact_by_userid_without_abuse_block_for_channel(&mut self, userid: String) -> thrift::Result<Contact>;
  fn get_all_contact_ids_for_channel(&mut self) -> thrift::Result<Vec<String>>;
  fn get_compact_contacts(&mut self, last_modified_timestamp: i64) -> thrift::Result<Vec<CompactContact>>;
  fn get_contacts_for_channel(&mut self, ids: Vec<String>) -> thrift::Result<Vec<Contact>>;
  fn get_display_name(&mut self, mid: String) -> thrift::Result<String>;
  fn get_favorite_mids_for_channel(&mut self) -> thrift::Result<Vec<String>>;
  fn get_friend_mids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_group_member_mids(&mut self, group_id: String) -> thrift::Result<Vec<String>>;
  fn get_groups_for_channel(&mut self, group_ids: Vec<String>) -> thrift::Result<Vec<Group>>;
  fn get_identity_credential(&mut self) -> thrift::Result<IdentityCredential>;
  fn get_joined_group_ids_for_channel(&mut self) -> thrift::Result<Vec<String>>;
  fn get_meta_profile(&mut self) -> thrift::Result<MetaProfile>;
  fn get_mid(&mut self) -> thrift::Result<String>;
  fn get_primary_client_for_channel(&mut self) -> thrift::Result<SimpleChannelClient>;
  fn get_profile_for_channel(&mut self) -> thrift::Result<Profile>;
  fn get_simple_channel_contacts(&mut self, ids: Vec<String>) -> thrift::Result<Vec<SimpleChannelContact>>;
  fn get_user_country_for_billing(&mut self, country: String, remote_ip: String) -> thrift::Result<String>;
  fn get_user_create_time(&mut self) -> thrift::Result<i64>;
  fn get_user_identities(&mut self) -> thrift::Result<BTreeMap<RegistrationType, String>>;
  fn get_user_language(&mut self) -> thrift::Result<String>;
  fn get_user_mids_who_added_me(&mut self) -> thrift::Result<Vec<String>>;
  fn is_group_member(&mut self, group_id: String) -> thrift::Result<bool>;
  fn is_in_contact(&mut self, mid: String) -> thrift::Result<bool>;
  fn register_channel_c_p(&mut self, cp_id: String, register_password: String) -> thrift::Result<String>;
  fn remove_notification_status(&mut self, notification_status: NotificationStatus) -> thrift::Result<()>;
  fn send_message_for_channel(&mut self, message: Message) -> thrift::Result<Message>;
  fn send_pin_code_operation(&mut self, verifier: String) -> thrift::Result<()>;
  fn update_profile_attribute_for_channel(&mut self, profile_attribute: ProfileAttribute, value: String) -> thrift::Result<()>;
}

pub trait TChannelApplicationProvidedServiceSyncClientMarker {}

pub struct ChannelApplicationProvidedServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ChannelApplicationProvidedServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ChannelApplicationProvidedServiceSyncClient<IP, OP> {
    ChannelApplicationProvidedServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ChannelApplicationProvidedServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TChannelApplicationProvidedServiceSyncClientMarker for ChannelApplicationProvidedServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TChannelApplicationProvidedServiceSyncClientMarker> TChannelApplicationProvidedServiceSyncClient for C {
  fn active_buddy_subscriber_count(&mut self) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("activeBuddySubscriberCount", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("activeBuddySubscriberCount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_operation_for_channel(&mut self, op_type: OpType, param1: String, param2: String, param3: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("addOperationForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceAddOperationForChannelArgs { op_type: op_type, param1: param1, param2: param2, param3: param3 };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("addOperationForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceAddOperationForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn display_buddy_subscriber_count(&mut self) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("displayBuddySubscriberCount", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("displayBuddySubscriberCount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_contact_by_userid_without_abuse_block_for_channel(&mut self, userid: String) -> thrift::Result<Contact> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findContactByUseridWithoutAbuseBlockForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs { userid: userid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findContactByUseridWithoutAbuseBlockForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_contact_ids_for_channel(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getAllContactIdsForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getAllContactIdsForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_compact_contacts(&mut self, last_modified_timestamp: i64) -> thrift::Result<Vec<CompactContact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCompactContacts", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetCompactContactsArgs { last_modified_timestamp: last_modified_timestamp };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCompactContacts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetCompactContactsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_contacts_for_channel(&mut self, ids: Vec<String>) -> thrift::Result<Vec<Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getContactsForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetContactsForChannelArgs { ids: ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getContactsForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetContactsForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_display_name(&mut self, mid: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getDisplayName", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetDisplayNameArgs { mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getDisplayName", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetDisplayNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_favorite_mids_for_channel(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getFavoriteMidsForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getFavoriteMidsForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_friend_mids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getFriendMids", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetFriendMidsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getFriendMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetFriendMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_group_member_mids(&mut self, group_id: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getGroupMemberMids", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetGroupMemberMidsArgs { group_id: group_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getGroupMemberMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetGroupMemberMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_groups_for_channel(&mut self, group_ids: Vec<String>) -> thrift::Result<Vec<Group>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getGroupsForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetGroupsForChannelArgs { group_ids: group_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getGroupsForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetGroupsForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_identity_credential(&mut self) -> thrift::Result<IdentityCredential> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetIdentityCredentialArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_joined_group_ids_for_channel(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getJoinedGroupIdsForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getJoinedGroupIdsForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_meta_profile(&mut self) -> thrift::Result<MetaProfile> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMetaProfile", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetMetaProfileArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMetaProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetMetaProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_mid(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMid", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetMidArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_primary_client_for_channel(&mut self) -> thrift::Result<SimpleChannelClient> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPrimaryClientForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPrimaryClientForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_profile_for_channel(&mut self) -> thrift::Result<Profile> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProfileForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetProfileForChannelArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProfileForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetProfileForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_simple_channel_contacts(&mut self, ids: Vec<String>) -> thrift::Result<Vec<SimpleChannelContact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSimpleChannelContacts", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs { ids: ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSimpleChannelContacts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetSimpleChannelContactsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_country_for_billing(&mut self, country: String, remote_ip: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUserCountryForBilling", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetUserCountryForBillingArgs { country: country, remote_ip: remote_ip };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUserCountryForBilling", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetUserCountryForBillingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_create_time(&mut self) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUserCreateTime", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetUserCreateTimeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUserCreateTime", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetUserCreateTimeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_identities(&mut self) -> thrift::Result<BTreeMap<RegistrationType, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUserIdentities", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetUserIdentitiesArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUserIdentities", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetUserIdentitiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_language(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUserLanguage", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetUserLanguageArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUserLanguage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetUserLanguageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_mids_who_added_me(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUserMidsWhoAddedMe", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUserMidsWhoAddedMe", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_group_member(&mut self, group_id: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("isGroupMember", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceIsGroupMemberArgs { group_id: group_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("isGroupMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceIsGroupMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_in_contact(&mut self, mid: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("isInContact", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceIsInContactArgs { mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("isInContact", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceIsInContactResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_channel_c_p(&mut self, cp_id: String, register_password: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerChannelCP", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceRegisterChannelCPArgs { cp_id: cp_id, register_password: register_password };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerChannelCP", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceRegisterChannelCPResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_notification_status(&mut self, notification_status: NotificationStatus) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeNotificationStatus", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceRemoveNotificationStatusArgs { notification_status: notification_status };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeNotificationStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceRemoveNotificationStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_message_for_channel(&mut self, message: Message) -> thrift::Result<Message> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendMessageForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceSendMessageForChannelArgs { message: message };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendMessageForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceSendMessageForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_pin_code_operation(&mut self, verifier: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendPinCodeOperation", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceSendPinCodeOperationArgs { verifier: verifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendPinCodeOperation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceSendPinCodeOperationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_profile_attribute_for_channel(&mut self, profile_attribute: ProfileAttribute, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateProfileAttributeForChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs { profile_attribute: profile_attribute, value: value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateProfileAttributeForChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// ChannelApplicationProvidedService service processor
//

pub trait ChannelApplicationProvidedServiceSyncHandler {
  fn handle_active_buddy_subscriber_count(&self) -> thrift::Result<i64>;
  fn handle_add_operation_for_channel(&self, op_type: OpType, param1: String, param2: String, param3: String) -> thrift::Result<()>;
  fn handle_display_buddy_subscriber_count(&self) -> thrift::Result<i64>;
  fn handle_find_contact_by_userid_without_abuse_block_for_channel(&self, userid: String) -> thrift::Result<Contact>;
  fn handle_get_all_contact_ids_for_channel(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_compact_contacts(&self, last_modified_timestamp: i64) -> thrift::Result<Vec<CompactContact>>;
  fn handle_get_contacts_for_channel(&self, ids: Vec<String>) -> thrift::Result<Vec<Contact>>;
  fn handle_get_display_name(&self, mid: String) -> thrift::Result<String>;
  fn handle_get_favorite_mids_for_channel(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_friend_mids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_group_member_mids(&self, group_id: String) -> thrift::Result<Vec<String>>;
  fn handle_get_groups_for_channel(&self, group_ids: Vec<String>) -> thrift::Result<Vec<Group>>;
  fn handle_get_identity_credential(&self) -> thrift::Result<IdentityCredential>;
  fn handle_get_joined_group_ids_for_channel(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_meta_profile(&self) -> thrift::Result<MetaProfile>;
  fn handle_get_mid(&self) -> thrift::Result<String>;
  fn handle_get_primary_client_for_channel(&self) -> thrift::Result<SimpleChannelClient>;
  fn handle_get_profile_for_channel(&self) -> thrift::Result<Profile>;
  fn handle_get_simple_channel_contacts(&self, ids: Vec<String>) -> thrift::Result<Vec<SimpleChannelContact>>;
  fn handle_get_user_country_for_billing(&self, country: String, remote_ip: String) -> thrift::Result<String>;
  fn handle_get_user_create_time(&self) -> thrift::Result<i64>;
  fn handle_get_user_identities(&self) -> thrift::Result<BTreeMap<RegistrationType, String>>;
  fn handle_get_user_language(&self) -> thrift::Result<String>;
  fn handle_get_user_mids_who_added_me(&self) -> thrift::Result<Vec<String>>;
  fn handle_is_group_member(&self, group_id: String) -> thrift::Result<bool>;
  fn handle_is_in_contact(&self, mid: String) -> thrift::Result<bool>;
  fn handle_register_channel_c_p(&self, cp_id: String, register_password: String) -> thrift::Result<String>;
  fn handle_remove_notification_status(&self, notification_status: NotificationStatus) -> thrift::Result<()>;
  fn handle_send_message_for_channel(&self, message: Message) -> thrift::Result<Message>;
  fn handle_send_pin_code_operation(&self, verifier: String) -> thrift::Result<()>;
  fn handle_update_profile_attribute_for_channel(&self, profile_attribute: ProfileAttribute, value: String) -> thrift::Result<()>;
}

pub struct ChannelApplicationProvidedServiceSyncProcessor<H: ChannelApplicationProvidedServiceSyncHandler> {
  handler: H,
}

impl <H: ChannelApplicationProvidedServiceSyncHandler> ChannelApplicationProvidedServiceSyncProcessor<H> {
  pub fn new(handler: H) -> ChannelApplicationProvidedServiceSyncProcessor<H> {
    ChannelApplicationProvidedServiceSyncProcessor {
      handler,
    }
  }
  fn process_active_buddy_subscriber_count(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_active_buddy_subscriber_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_operation_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_add_operation_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_display_buddy_subscriber_count(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_display_buddy_subscriber_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_contact_by_userid_without_abuse_block_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_find_contact_by_userid_without_abuse_block_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_contact_ids_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_all_contact_ids_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_compact_contacts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_compact_contacts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_contacts_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_contacts_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_display_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_display_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_favorite_mids_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_favorite_mids_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_friend_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_friend_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_group_member_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_group_member_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_groups_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_groups_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_joined_group_ids_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_joined_group_ids_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_meta_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_meta_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_primary_client_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_primary_client_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_profile_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_profile_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_simple_channel_contacts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_simple_channel_contacts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_country_for_billing(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_user_country_for_billing(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_create_time(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_user_create_time(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_identities(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_user_identities(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_language(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_user_language(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_mids_who_added_me(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_get_user_mids_who_added_me(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_group_member(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_is_group_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_in_contact(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_is_in_contact(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_channel_c_p(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_register_channel_c_p(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_notification_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_remove_notification_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_message_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_send_message_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_pin_code_operation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_send_pin_code_operation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_profile_attribute_for_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelApplicationProvidedServiceProcessFunctions::process_update_profile_attribute_for_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TChannelApplicationProvidedServiceProcessFunctions;

impl TChannelApplicationProvidedServiceProcessFunctions {
  pub fn process_active_buddy_subscriber_count<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_active_buddy_subscriber_count() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("activeBuddySubscriberCount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("activeBuddySubscriberCount", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("activeBuddySubscriberCount", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("activeBuddySubscriberCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("activeBuddySubscriberCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_operation_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceAddOperationForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_operation_for_channel(args.op_type, args.param1, args.param2, args.param3) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("addOperationForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceAddOperationForChannelResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceAddOperationForChannelResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("addOperationForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("addOperationForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("addOperationForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("addOperationForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_display_buddy_subscriber_count<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_display_buddy_subscriber_count() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("displayBuddySubscriberCount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("displayBuddySubscriberCount", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("displayBuddySubscriberCount", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("displayBuddySubscriberCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("displayBuddySubscriberCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_contact_by_userid_without_abuse_block_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_contact_by_userid_without_abuse_block_for_channel(args.userid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findContactByUseridWithoutAbuseBlockForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findContactByUseridWithoutAbuseBlockForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findContactByUseridWithoutAbuseBlockForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findContactByUseridWithoutAbuseBlockForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findContactByUseridWithoutAbuseBlockForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_contact_ids_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_contact_ids_for_channel() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getAllContactIdsForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getAllContactIdsForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getAllContactIdsForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getAllContactIdsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getAllContactIdsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_compact_contacts<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceGetCompactContactsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_compact_contacts(args.last_modified_timestamp) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCompactContacts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetCompactContactsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetCompactContactsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCompactContacts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCompactContacts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCompactContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCompactContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_contacts_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceGetContactsForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_contacts_for_channel(args.ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getContactsForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetContactsForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetContactsForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getContactsForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getContactsForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getContactsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getContactsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_display_name<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceGetDisplayNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_display_name(args.mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getDisplayName", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetDisplayNameResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetDisplayNameResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getDisplayName", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getDisplayName", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getDisplayName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getDisplayName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_favorite_mids_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_favorite_mids_for_channel() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getFavoriteMidsForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getFavoriteMidsForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getFavoriteMidsForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getFavoriteMidsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getFavoriteMidsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_friend_mids<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetFriendMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_friend_mids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getFriendMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetFriendMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetFriendMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getFriendMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getFriendMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getFriendMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getFriendMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_group_member_mids<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceGetGroupMemberMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_group_member_mids(args.group_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getGroupMemberMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetGroupMemberMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetGroupMemberMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getGroupMemberMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getGroupMemberMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getGroupMemberMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getGroupMemberMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_groups_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceGetGroupsForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_groups_for_channel(args.group_ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getGroupsForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetGroupsForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetGroupsForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getGroupsForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getGroupsForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getGroupsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getGroupsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_identity_credential<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_identity_credential() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetIdentityCredentialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetIdentityCredentialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_joined_group_ids_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_joined_group_ids_for_channel() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getJoinedGroupIdsForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getJoinedGroupIdsForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getJoinedGroupIdsForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getJoinedGroupIdsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getJoinedGroupIdsForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_meta_profile<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetMetaProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_meta_profile() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMetaProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetMetaProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetMetaProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMetaProfile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMetaProfile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMetaProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMetaProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_mid<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_mid() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_primary_client_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_primary_client_for_channel() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPrimaryClientForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPrimaryClientForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPrimaryClientForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPrimaryClientForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPrimaryClientForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_profile_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetProfileForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_profile_for_channel() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProfileForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetProfileForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetProfileForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProfileForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProfileForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProfileForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProfileForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_simple_channel_contacts<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_simple_channel_contacts(args.ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSimpleChannelContacts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetSimpleChannelContactsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetSimpleChannelContactsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSimpleChannelContacts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSimpleChannelContacts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSimpleChannelContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSimpleChannelContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_country_for_billing<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceGetUserCountryForBillingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_country_for_billing(args.country, args.remote_ip) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUserCountryForBilling", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetUserCountryForBillingResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetUserCountryForBillingResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUserCountryForBilling", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getUserCountryForBilling", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUserCountryForBilling", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getUserCountryForBilling", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_create_time<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetUserCreateTimeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_create_time() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUserCreateTime", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetUserCreateTimeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetUserCreateTimeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUserCreateTime", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getUserCreateTime", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUserCreateTime", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getUserCreateTime", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_identities<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetUserIdentitiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_identities() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUserIdentities", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetUserIdentitiesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetUserIdentitiesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUserIdentities", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getUserIdentities", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUserIdentities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getUserIdentities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_language<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetUserLanguageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_language() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUserLanguage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetUserLanguageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetUserLanguageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUserLanguage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getUserLanguage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUserLanguage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getUserLanguage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_mids_who_added_me<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_mids_who_added_me() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUserMidsWhoAddedMe", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUserMidsWhoAddedMe", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getUserMidsWhoAddedMe", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUserMidsWhoAddedMe", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getUserMidsWhoAddedMe", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_group_member<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceIsGroupMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_group_member(args.group_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("isGroupMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceIsGroupMemberResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceIsGroupMemberResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("isGroupMember", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("isGroupMember", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("isGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("isGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_in_contact<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceIsInContactArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_in_contact(args.mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("isInContact", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceIsInContactResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceIsInContactResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("isInContact", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("isInContact", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("isInContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("isInContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_channel_c_p<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceRegisterChannelCPArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_channel_c_p(args.cp_id, args.register_password) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerChannelCP", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceRegisterChannelCPResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceRegisterChannelCPResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerChannelCP", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerChannelCP", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerChannelCP", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerChannelCP", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_notification_status<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceRemoveNotificationStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_notification_status(args.notification_status) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("removeNotificationStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceRemoveNotificationStatusResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceRemoveNotificationStatusResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeNotificationStatus", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeNotificationStatus", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeNotificationStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeNotificationStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_message_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceSendMessageForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_message_for_channel(args.message) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendMessageForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceSendMessageForChannelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceSendMessageForChannelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendMessageForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendMessageForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendMessageForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendMessageForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_pin_code_operation<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceSendPinCodeOperationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_pin_code_operation(args.verifier) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendPinCodeOperation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceSendPinCodeOperationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceSendPinCodeOperationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendPinCodeOperation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendPinCodeOperation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendPinCodeOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendPinCodeOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_profile_attribute_for_channel<H: ChannelApplicationProvidedServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_profile_attribute_for_channel(args.profile_attribute, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateProfileAttributeForChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateProfileAttributeForChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateProfileAttributeForChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateProfileAttributeForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateProfileAttributeForChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ChannelApplicationProvidedServiceSyncHandler> TProcessor for ChannelApplicationProvidedServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "activeBuddySubscriberCount" => {
        self.process_active_buddy_subscriber_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "addOperationForChannel" => {
        self.process_add_operation_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "displayBuddySubscriberCount" => {
        self.process_display_buddy_subscriber_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "findContactByUseridWithoutAbuseBlockForChannel" => {
        self.process_find_contact_by_userid_without_abuse_block_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getAllContactIdsForChannel" => {
        self.process_get_all_contact_ids_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCompactContacts" => {
        self.process_get_compact_contacts(message_ident.sequence_number, i_prot, o_prot)
      },
      "getContactsForChannel" => {
        self.process_get_contacts_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getDisplayName" => {
        self.process_get_display_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "getFavoriteMidsForChannel" => {
        self.process_get_favorite_mids_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getFriendMids" => {
        self.process_get_friend_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getGroupMemberMids" => {
        self.process_get_group_member_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getGroupsForChannel" => {
        self.process_get_groups_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getIdentityCredential" => {
        self.process_get_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "getJoinedGroupIdsForChannel" => {
        self.process_get_joined_group_ids_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMetaProfile" => {
        self.process_get_meta_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMid" => {
        self.process_get_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPrimaryClientForChannel" => {
        self.process_get_primary_client_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProfileForChannel" => {
        self.process_get_profile_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSimpleChannelContacts" => {
        self.process_get_simple_channel_contacts(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUserCountryForBilling" => {
        self.process_get_user_country_for_billing(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUserCreateTime" => {
        self.process_get_user_create_time(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUserIdentities" => {
        self.process_get_user_identities(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUserLanguage" => {
        self.process_get_user_language(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUserMidsWhoAddedMe" => {
        self.process_get_user_mids_who_added_me(message_ident.sequence_number, i_prot, o_prot)
      },
      "isGroupMember" => {
        self.process_is_group_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "isInContact" => {
        self.process_is_in_contact(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerChannelCP" => {
        self.process_register_channel_c_p(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeNotificationStatus" => {
        self.process_remove_notification_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendMessageForChannel" => {
        self.process_send_message_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendPinCodeOperation" => {
        self.process_send_pin_code_operation(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateProfileAttributeForChannel" => {
        self.process_update_profile_attribute_for_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs {
}

impl ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("activeBuddySubscriberCount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceActiveBuddySubscriberCount"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceAddOperationForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceAddOperationForChannelArgs {
  op_type: OpType,
  param1: String,
  param2: String,
  param3: String,
}

impl ChannelApplicationProvidedServiceAddOperationForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceAddOperationForChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OpType> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OpType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceAddOperationForChannelArgs.op_type", &f_1)?;
    verify_required_field_exists("ChannelApplicationProvidedServiceAddOperationForChannelArgs.param1", &f_2)?;
    verify_required_field_exists("ChannelApplicationProvidedServiceAddOperationForChannelArgs.param2", &f_3)?;
    verify_required_field_exists("ChannelApplicationProvidedServiceAddOperationForChannelArgs.param3", &f_4)?;
    let ret = ChannelApplicationProvidedServiceAddOperationForChannelArgs {
      op_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      param1: f_2.expect("auto-generated code should have checked for presence of required fields"),
      param2: f_3.expect("auto-generated code should have checked for presence of required fields"),
      param3: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("addOperationForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("opType", TType::I32, 1))?;
    self.op_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("param1", TType::String, 2))?;
    o_prot.write_string(&self.param1)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("param2", TType::String, 3))?;
    o_prot.write_string(&self.param2)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("param3", TType::String, 4))?;
    o_prot.write_string(&self.param3)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceAddOperationForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceAddOperationForChannelResult {
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceAddOperationForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceAddOperationForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceAddOperationForChannelResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceAddOperationForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs {
}

impl ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("displayBuddySubscriberCount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceDisplayBuddySubscriberCount"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs {
  userid: String,
}

impl ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs.userid", &f_2)?;
    let ret = ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs {
      userid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findContactByUseridWithoutAbuseBlockForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userid", TType::String, 2))?;
    o_prot.write_string(&self.userid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult {
  result_value: Option<Contact>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Contact> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Contact> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs {
}

impl ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getAllContactIdsForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_90 = i_prot.read_string()?;
            val.push(list_elem_90);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetAllContactIdsForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetCompactContactsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetCompactContactsArgs {
  last_modified_timestamp: i64,
}

impl ChannelApplicationProvidedServiceGetCompactContactsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetCompactContactsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetCompactContactsArgs.last_modified_timestamp", &f_2)?;
    let ret = ChannelApplicationProvidedServiceGetCompactContactsArgs {
      last_modified_timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCompactContacts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastModifiedTimestamp", TType::I64, 2))?;
    o_prot.write_i64(self.last_modified_timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetCompactContactsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetCompactContactsResult {
  result_value: Option<Vec<CompactContact>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetCompactContactsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetCompactContactsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<CompactContact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactContact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_91 = CompactContact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_91);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetCompactContactsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetCompactContactsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<CompactContact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetCompactContacts"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetContactsForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetContactsForChannelArgs {
  ids: Vec<String>,
}

impl ChannelApplicationProvidedServiceGetContactsForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetContactsForChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_92 = i_prot.read_string()?;
            val.push(list_elem_92);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetContactsForChannelArgs.ids", &f_2)?;
    let ret = ChannelApplicationProvidedServiceGetContactsForChannelArgs {
      ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getContactsForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.ids.len() as i32))?;
    for e in &self.ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetContactsForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetContactsForChannelResult {
  result_value: Option<Vec<Contact>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetContactsForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetContactsForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_93 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_93);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetContactsForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetContactsForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetContactsForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetDisplayNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetDisplayNameArgs {
  mid: String,
}

impl ChannelApplicationProvidedServiceGetDisplayNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetDisplayNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetDisplayNameArgs.mid", &f_2)?;
    let ret = ChannelApplicationProvidedServiceGetDisplayNameArgs {
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getDisplayName_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetDisplayNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetDisplayNameResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetDisplayNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetDisplayNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetDisplayNameResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetDisplayNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetDisplayName"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs {
}

impl ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getFavoriteMidsForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_94 = i_prot.read_string()?;
            val.push(list_elem_94);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetFavoriteMidsForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetFriendMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetFriendMidsArgs {
}

impl ChannelApplicationProvidedServiceGetFriendMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetFriendMidsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetFriendMidsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getFriendMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetFriendMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetFriendMidsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetFriendMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetFriendMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_95 = i_prot.read_string()?;
            val.push(list_elem_95);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetFriendMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetFriendMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetFriendMids"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetGroupMemberMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetGroupMemberMidsArgs {
  group_id: String,
}

impl ChannelApplicationProvidedServiceGetGroupMemberMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetGroupMemberMidsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetGroupMemberMidsArgs.group_id", &f_1)?;
    let ret = ChannelApplicationProvidedServiceGetGroupMemberMidsArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getGroupMemberMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetGroupMemberMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetGroupMemberMidsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetGroupMemberMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetGroupMemberMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_96 = i_prot.read_string()?;
            val.push(list_elem_96);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetGroupMemberMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetGroupMemberMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetGroupMemberMids"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetGroupsForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetGroupsForChannelArgs {
  group_ids: Vec<String>,
}

impl ChannelApplicationProvidedServiceGetGroupsForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetGroupsForChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_97 = i_prot.read_string()?;
            val.push(list_elem_97);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetGroupsForChannelArgs.group_ids", &f_1)?;
    let ret = ChannelApplicationProvidedServiceGetGroupsForChannelArgs {
      group_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getGroupsForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.group_ids.len() as i32))?;
    for e in &self.group_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetGroupsForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetGroupsForChannelResult {
  result_value: Option<Vec<Group>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetGroupsForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetGroupsForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Group>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Group> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_98 = Group::read_from_in_protocol(i_prot)?;
            val.push(list_elem_98);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetGroupsForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetGroupsForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Group>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetGroupsForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetIdentityCredentialArgs {
}

impl ChannelApplicationProvidedServiceGetIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetIdentityCredentialArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetIdentityCredentialResult {
  result_value: Option<IdentityCredential>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<IdentityCredential> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = IdentityCredential::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetIdentityCredentialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<IdentityCredential> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetIdentityCredential"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs {
}

impl ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getJoinedGroupIdsForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_99 = i_prot.read_string()?;
            val.push(list_elem_99);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetMetaProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetMetaProfileArgs {
}

impl ChannelApplicationProvidedServiceGetMetaProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetMetaProfileArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetMetaProfileArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMetaProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetMetaProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetMetaProfileResult {
  result_value: Option<MetaProfile>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetMetaProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetMetaProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<MetaProfile> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = MetaProfile::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetMetaProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetMetaProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<MetaProfile> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetMetaProfile"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetMidArgs {
}

impl ChannelApplicationProvidedServiceGetMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetMidArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetMidArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetMidResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetMid"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs {
}

impl ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPrimaryClientForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult {
  result_value: Option<SimpleChannelClient>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SimpleChannelClient> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SimpleChannelClient::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SimpleChannelClient> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetPrimaryClientForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetProfileForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetProfileForChannelArgs {
}

impl ChannelApplicationProvidedServiceGetProfileForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetProfileForChannelArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetProfileForChannelArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProfileForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetProfileForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetProfileForChannelResult {
  result_value: Option<Profile>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetProfileForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetProfileForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Profile> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Profile::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetProfileForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetProfileForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Profile> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetProfileForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs {
  ids: Vec<String>,
}

impl ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_100 = i_prot.read_string()?;
            val.push(list_elem_100);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs.ids", &f_1)?;
    let ret = ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs {
      ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSimpleChannelContacts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ids", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.ids.len() as i32))?;
    for e in &self.ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetSimpleChannelContactsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetSimpleChannelContactsResult {
  result_value: Option<Vec<SimpleChannelContact>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetSimpleChannelContactsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetSimpleChannelContactsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<SimpleChannelContact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SimpleChannelContact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_101 = SimpleChannelContact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_101);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetSimpleChannelContactsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetSimpleChannelContactsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<SimpleChannelContact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetSimpleChannelContacts"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetUserCountryForBillingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserCountryForBillingArgs {
  country: String,
  remote_ip: String,
}

impl ChannelApplicationProvidedServiceGetUserCountryForBillingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserCountryForBillingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetUserCountryForBillingArgs.country", &f_2)?;
    verify_required_field_exists("ChannelApplicationProvidedServiceGetUserCountryForBillingArgs.remote_ip", &f_3)?;
    let ret = ChannelApplicationProvidedServiceGetUserCountryForBillingArgs {
      country: f_2.expect("auto-generated code should have checked for presence of required fields"),
      remote_ip: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUserCountryForBilling_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 2))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("remoteIp", TType::String, 3))?;
    o_prot.write_string(&self.remote_ip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetUserCountryForBillingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserCountryForBillingResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetUserCountryForBillingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserCountryForBillingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserCountryForBillingResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetUserCountryForBillingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetUserCountryForBilling"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetUserCreateTimeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserCreateTimeArgs {
}

impl ChannelApplicationProvidedServiceGetUserCreateTimeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserCreateTimeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserCreateTimeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUserCreateTime_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetUserCreateTimeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserCreateTimeResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetUserCreateTimeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserCreateTimeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserCreateTimeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetUserCreateTimeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetUserCreateTime"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetUserIdentitiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserIdentitiesArgs {
}

impl ChannelApplicationProvidedServiceGetUserIdentitiesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserIdentitiesArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserIdentitiesArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUserIdentities_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetUserIdentitiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserIdentitiesResult {
  result_value: Option<BTreeMap<RegistrationType, String>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetUserIdentitiesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserIdentitiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<RegistrationType, String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<RegistrationType, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_102 = RegistrationType::read_from_in_protocol(i_prot)?;
            let map_val_103 = i_prot.read_string()?;
            val.insert(map_key_102, map_val_103);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserIdentitiesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetUserIdentitiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        k.write_to_out_protocol(o_prot)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<RegistrationType, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetUserIdentities"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetUserLanguageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserLanguageArgs {
}

impl ChannelApplicationProvidedServiceGetUserLanguageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserLanguageArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserLanguageArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUserLanguage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetUserLanguageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserLanguageResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetUserLanguageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserLanguageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserLanguageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetUserLanguageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetUserLanguage"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs {
}

impl ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUserMidsWhoAddedMe_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_104 = i_prot.read_string()?;
            val.push(list_elem_104);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceGetUserMidsWhoAddedMe"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceIsGroupMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceIsGroupMemberArgs {
  group_id: String,
}

impl ChannelApplicationProvidedServiceIsGroupMemberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceIsGroupMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceIsGroupMemberArgs.group_id", &f_1)?;
    let ret = ChannelApplicationProvidedServiceIsGroupMemberArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("isGroupMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceIsGroupMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceIsGroupMemberResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceIsGroupMemberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceIsGroupMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceIsGroupMemberResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceIsGroupMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceIsGroupMember"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceIsInContactArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceIsInContactArgs {
  mid: String,
}

impl ChannelApplicationProvidedServiceIsInContactArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceIsInContactArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceIsInContactArgs.mid", &f_2)?;
    let ret = ChannelApplicationProvidedServiceIsInContactArgs {
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("isInContact_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceIsInContactResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceIsInContactResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceIsInContactResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceIsInContactResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceIsInContactResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceIsInContactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceIsInContact"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceRegisterChannelCPArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceRegisterChannelCPArgs {
  cp_id: String,
  register_password: String,
}

impl ChannelApplicationProvidedServiceRegisterChannelCPArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceRegisterChannelCPArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceRegisterChannelCPArgs.cp_id", &f_2)?;
    verify_required_field_exists("ChannelApplicationProvidedServiceRegisterChannelCPArgs.register_password", &f_3)?;
    let ret = ChannelApplicationProvidedServiceRegisterChannelCPArgs {
      cp_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      register_password: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerChannelCP_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpId", TType::String, 2))?;
    o_prot.write_string(&self.cp_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("registerPassword", TType::String, 3))?;
    o_prot.write_string(&self.register_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceRegisterChannelCPResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceRegisterChannelCPResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceRegisterChannelCPResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceRegisterChannelCPResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceRegisterChannelCPResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceRegisterChannelCPResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceRegisterChannelCP"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceRemoveNotificationStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceRemoveNotificationStatusArgs {
  notification_status: NotificationStatus,
}

impl ChannelApplicationProvidedServiceRemoveNotificationStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceRemoveNotificationStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<NotificationStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = NotificationStatus::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceRemoveNotificationStatusArgs.notification_status", &f_2)?;
    let ret = ChannelApplicationProvidedServiceRemoveNotificationStatusArgs {
      notification_status: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeNotificationStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationStatus", TType::I32, 2))?;
    self.notification_status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceRemoveNotificationStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceRemoveNotificationStatusResult {
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceRemoveNotificationStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceRemoveNotificationStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceRemoveNotificationStatusResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceRemoveNotificationStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ChannelApplicationProvidedServiceSendMessageForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceSendMessageForChannelArgs {
  message: Message,
}

impl ChannelApplicationProvidedServiceSendMessageForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceSendMessageForChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceSendMessageForChannelArgs.message", &f_2)?;
    let ret = ChannelApplicationProvidedServiceSendMessageForChannelArgs {
      message: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendMessageForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 2))?;
    self.message.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceSendMessageForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceSendMessageForChannelResult {
  result_value: Option<Message>,
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceSendMessageForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceSendMessageForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Message> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceSendMessageForChannelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceSendMessageForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Message> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelApplicationProvidedServiceSendMessageForChannel"
          )
        )
      )
    }
  }
}

//
// ChannelApplicationProvidedServiceSendPinCodeOperationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceSendPinCodeOperationArgs {
  verifier: String,
}

impl ChannelApplicationProvidedServiceSendPinCodeOperationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceSendPinCodeOperationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceSendPinCodeOperationArgs.verifier", &f_1)?;
    let ret = ChannelApplicationProvidedServiceSendPinCodeOperationArgs {
      verifier: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendPinCodeOperation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 1))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceSendPinCodeOperationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceSendPinCodeOperationResult {
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceSendPinCodeOperationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceSendPinCodeOperationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceSendPinCodeOperationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceSendPinCodeOperationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs {
  profile_attribute: ProfileAttribute,
  value: String,
}

impl ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<ProfileAttribute> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = ProfileAttribute::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs.profile_attribute", &f_2)?;
    verify_required_field_exists("ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs.value", &f_3)?;
    let ret = ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs {
      profile_attribute: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateProfileAttributeForChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileAttribute", TType::I32, 2))?;
    self.profile_attribute.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult {
  e: Option<TalkException>,
}

impl ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ChannelService service client
//

pub trait TChannelServiceSyncClient {
  fn approve_channel_and_issue_channel_token(&mut self, channel_id: String) -> thrift::Result<ChannelToken>;
  fn approve_channel_and_issue_request_token(&mut self, channel_id: String, otp_id: String) -> thrift::Result<String>;
  fn fetch_notification_items(&mut self, local_rev: i64) -> thrift::Result<NotificationFetchResult>;
  fn get_approved_channels(&mut self, last_synced: i64, locale: String) -> thrift::Result<ApprovedChannelInfos>;
  fn get_channel_info(&mut self, channel_id: String, locale: String) -> thrift::Result<ChannelInfo>;
  fn get_channel_notification_setting(&mut self, channel_id: String, locale: String) -> thrift::Result<ChannelNotificationSetting>;
  fn get_channel_notification_settings(&mut self, locale: String) -> thrift::Result<Vec<ChannelNotificationSetting>>;
  fn get_channels(&mut self, last_synced: i64, locale: String) -> thrift::Result<ChannelInfos>;
  fn get_domains(&mut self, last_synced: i64) -> thrift::Result<ChannelDomains>;
  fn get_friend_channel_matrices(&mut self, channel_ids: Vec<String>) -> thrift::Result<FriendChannelMatricesResponse>;
  fn get_notification_badge_count(&mut self, local_rev: i64) -> thrift::Result<i32>;
  fn issue_channel_token(&mut self, channel_id: String) -> thrift::Result<ChannelToken>;
  fn issue_request_token(&mut self, channel_id: String, otp_id: String) -> thrift::Result<String>;
  fn issue_request_token_with_auth_scheme(&mut self, channel_id: String, otp_id: String, auth_scheme: Vec<String>, return_url: String) -> thrift::Result<RequestTokenResponse>;
  fn reserve_coin_use(&mut self, request: CoinUseReservation, locale: String) -> thrift::Result<String>;
  fn revoke_channel(&mut self, channel_id: String) -> thrift::Result<()>;
  fn sync_channel_data(&mut self, last_synced: i64, locale: String) -> thrift::Result<ChannelSyncDatas>;
  fn update_channel_notification_setting(&mut self, setting: Vec<ChannelNotificationSetting>) -> thrift::Result<()>;
}

pub trait TChannelServiceSyncClientMarker {}

pub struct ChannelServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ChannelServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ChannelServiceSyncClient<IP, OP> {
    ChannelServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ChannelServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TChannelServiceSyncClientMarker for ChannelServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TChannelServiceSyncClientMarker> TChannelServiceSyncClient for C {
  fn approve_channel_and_issue_channel_token(&mut self, channel_id: String) -> thrift::Result<ChannelToken> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("approveChannelAndIssueChannelToken", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceApproveChannelAndIssueChannelTokenArgs { channel_id: channel_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("approveChannelAndIssueChannelToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceApproveChannelAndIssueChannelTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn approve_channel_and_issue_request_token(&mut self, channel_id: String, otp_id: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("approveChannelAndIssueRequestToken", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceApproveChannelAndIssueRequestTokenArgs { channel_id: channel_id, otp_id: otp_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("approveChannelAndIssueRequestToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceApproveChannelAndIssueRequestTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_notification_items(&mut self, local_rev: i64) -> thrift::Result<NotificationFetchResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchNotificationItems", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceFetchNotificationItemsArgs { local_rev: local_rev };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchNotificationItems", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceFetchNotificationItemsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_approved_channels(&mut self, last_synced: i64, locale: String) -> thrift::Result<ApprovedChannelInfos> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getApprovedChannels", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetApprovedChannelsArgs { last_synced: last_synced, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getApprovedChannels", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetApprovedChannelsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_channel_info(&mut self, channel_id: String, locale: String) -> thrift::Result<ChannelInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getChannelInfo", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetChannelInfoArgs { channel_id: channel_id, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getChannelInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetChannelInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_channel_notification_setting(&mut self, channel_id: String, locale: String) -> thrift::Result<ChannelNotificationSetting> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getChannelNotificationSetting", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetChannelNotificationSettingArgs { channel_id: channel_id, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getChannelNotificationSetting", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetChannelNotificationSettingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_channel_notification_settings(&mut self, locale: String) -> thrift::Result<Vec<ChannelNotificationSetting>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getChannelNotificationSettings", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetChannelNotificationSettingsArgs { locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getChannelNotificationSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetChannelNotificationSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_channels(&mut self, last_synced: i64, locale: String) -> thrift::Result<ChannelInfos> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getChannels", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetChannelsArgs { last_synced: last_synced, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getChannels", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetChannelsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_domains(&mut self, last_synced: i64) -> thrift::Result<ChannelDomains> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getDomains", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetDomainsArgs { last_synced: last_synced };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getDomains", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetDomainsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_friend_channel_matrices(&mut self, channel_ids: Vec<String>) -> thrift::Result<FriendChannelMatricesResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getFriendChannelMatrices", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetFriendChannelMatricesArgs { channel_ids: channel_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getFriendChannelMatrices", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetFriendChannelMatricesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_notification_badge_count(&mut self, local_rev: i64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNotificationBadgeCount", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceGetNotificationBadgeCountArgs { local_rev: local_rev };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNotificationBadgeCount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceGetNotificationBadgeCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn issue_channel_token(&mut self, channel_id: String) -> thrift::Result<ChannelToken> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("issueChannelToken", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceIssueChannelTokenArgs { channel_id: channel_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("issueChannelToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceIssueChannelTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn issue_request_token(&mut self, channel_id: String, otp_id: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("issueRequestToken", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceIssueRequestTokenArgs { channel_id: channel_id, otp_id: otp_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("issueRequestToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceIssueRequestTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn issue_request_token_with_auth_scheme(&mut self, channel_id: String, otp_id: String, auth_scheme: Vec<String>, return_url: String) -> thrift::Result<RequestTokenResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("issueRequestTokenWithAuthScheme", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceIssueRequestTokenWithAuthSchemeArgs { channel_id: channel_id, otp_id: otp_id, auth_scheme: auth_scheme, return_url: return_url };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("issueRequestTokenWithAuthScheme", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceIssueRequestTokenWithAuthSchemeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reserve_coin_use(&mut self, request: CoinUseReservation, locale: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reserveCoinUse", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceReserveCoinUseArgs { request: request, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reserveCoinUse", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceReserveCoinUseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn revoke_channel(&mut self, channel_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("revokeChannel", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceRevokeChannelArgs { channel_id: channel_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("revokeChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceRevokeChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sync_channel_data(&mut self, last_synced: i64, locale: String) -> thrift::Result<ChannelSyncDatas> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("syncChannelData", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceSyncChannelDataArgs { last_synced: last_synced, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("syncChannelData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceSyncChannelDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_channel_notification_setting(&mut self, setting: Vec<ChannelNotificationSetting>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateChannelNotificationSetting", TMessageType::Call, self.sequence_number());
        let call_args = ChannelServiceUpdateChannelNotificationSettingArgs { setting: setting };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateChannelNotificationSetting", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ChannelServiceUpdateChannelNotificationSettingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// ChannelService service processor
//

pub trait ChannelServiceSyncHandler {
  fn handle_approve_channel_and_issue_channel_token(&self, channel_id: String) -> thrift::Result<ChannelToken>;
  fn handle_approve_channel_and_issue_request_token(&self, channel_id: String, otp_id: String) -> thrift::Result<String>;
  fn handle_fetch_notification_items(&self, local_rev: i64) -> thrift::Result<NotificationFetchResult>;
  fn handle_get_approved_channels(&self, last_synced: i64, locale: String) -> thrift::Result<ApprovedChannelInfos>;
  fn handle_get_channel_info(&self, channel_id: String, locale: String) -> thrift::Result<ChannelInfo>;
  fn handle_get_channel_notification_setting(&self, channel_id: String, locale: String) -> thrift::Result<ChannelNotificationSetting>;
  fn handle_get_channel_notification_settings(&self, locale: String) -> thrift::Result<Vec<ChannelNotificationSetting>>;
  fn handle_get_channels(&self, last_synced: i64, locale: String) -> thrift::Result<ChannelInfos>;
  fn handle_get_domains(&self, last_synced: i64) -> thrift::Result<ChannelDomains>;
  fn handle_get_friend_channel_matrices(&self, channel_ids: Vec<String>) -> thrift::Result<FriendChannelMatricesResponse>;
  fn handle_get_notification_badge_count(&self, local_rev: i64) -> thrift::Result<i32>;
  fn handle_issue_channel_token(&self, channel_id: String) -> thrift::Result<ChannelToken>;
  fn handle_issue_request_token(&self, channel_id: String, otp_id: String) -> thrift::Result<String>;
  fn handle_issue_request_token_with_auth_scheme(&self, channel_id: String, otp_id: String, auth_scheme: Vec<String>, return_url: String) -> thrift::Result<RequestTokenResponse>;
  fn handle_reserve_coin_use(&self, request: CoinUseReservation, locale: String) -> thrift::Result<String>;
  fn handle_revoke_channel(&self, channel_id: String) -> thrift::Result<()>;
  fn handle_sync_channel_data(&self, last_synced: i64, locale: String) -> thrift::Result<ChannelSyncDatas>;
  fn handle_update_channel_notification_setting(&self, setting: Vec<ChannelNotificationSetting>) -> thrift::Result<()>;
}

pub struct ChannelServiceSyncProcessor<H: ChannelServiceSyncHandler> {
  handler: H,
}

impl <H: ChannelServiceSyncHandler> ChannelServiceSyncProcessor<H> {
  pub fn new(handler: H) -> ChannelServiceSyncProcessor<H> {
    ChannelServiceSyncProcessor {
      handler,
    }
  }
  fn process_approve_channel_and_issue_channel_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_approve_channel_and_issue_channel_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_approve_channel_and_issue_request_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_approve_channel_and_issue_request_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_notification_items(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_fetch_notification_items(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_approved_channels(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_approved_channels(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_channel_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_channel_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_channel_notification_setting(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_channel_notification_setting(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_channel_notification_settings(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_channel_notification_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_channels(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_channels(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_domains(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_domains(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_friend_channel_matrices(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_friend_channel_matrices(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_notification_badge_count(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_get_notification_badge_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_issue_channel_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_issue_channel_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_issue_request_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_issue_request_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_issue_request_token_with_auth_scheme(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_issue_request_token_with_auth_scheme(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reserve_coin_use(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_reserve_coin_use(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_revoke_channel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_revoke_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sync_channel_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_sync_channel_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_channel_notification_setting(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TChannelServiceProcessFunctions::process_update_channel_notification_setting(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TChannelServiceProcessFunctions;

impl TChannelServiceProcessFunctions {
  pub fn process_approve_channel_and_issue_channel_token<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceApproveChannelAndIssueChannelTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_approve_channel_and_issue_channel_token(args.channel_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("approveChannelAndIssueChannelToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceApproveChannelAndIssueChannelTokenResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceApproveChannelAndIssueChannelTokenResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("approveChannelAndIssueChannelToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("approveChannelAndIssueChannelToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("approveChannelAndIssueChannelToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("approveChannelAndIssueChannelToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_approve_channel_and_issue_request_token<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceApproveChannelAndIssueRequestTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_approve_channel_and_issue_request_token(args.channel_id, args.otp_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("approveChannelAndIssueRequestToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceApproveChannelAndIssueRequestTokenResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceApproveChannelAndIssueRequestTokenResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("approveChannelAndIssueRequestToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("approveChannelAndIssueRequestToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("approveChannelAndIssueRequestToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("approveChannelAndIssueRequestToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_notification_items<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceFetchNotificationItemsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_notification_items(args.local_rev) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchNotificationItems", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceFetchNotificationItemsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceFetchNotificationItemsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("fetchNotificationItems", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("fetchNotificationItems", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchNotificationItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchNotificationItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_approved_channels<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetApprovedChannelsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_approved_channels(args.last_synced, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getApprovedChannels", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetApprovedChannelsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetApprovedChannelsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getApprovedChannels", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getApprovedChannels", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getApprovedChannels", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getApprovedChannels", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_channel_info<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetChannelInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_channel_info(args.channel_id, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getChannelInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetChannelInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetChannelInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getChannelInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getChannelInfo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getChannelInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getChannelInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_channel_notification_setting<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetChannelNotificationSettingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_channel_notification_setting(args.channel_id, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getChannelNotificationSetting", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetChannelNotificationSettingResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetChannelNotificationSettingResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getChannelNotificationSetting", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getChannelNotificationSetting", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getChannelNotificationSetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getChannelNotificationSetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_channel_notification_settings<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetChannelNotificationSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_channel_notification_settings(args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getChannelNotificationSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetChannelNotificationSettingsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetChannelNotificationSettingsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getChannelNotificationSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getChannelNotificationSettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getChannelNotificationSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getChannelNotificationSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_channels<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetChannelsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_channels(args.last_synced, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getChannels", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetChannelsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetChannelsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getChannels", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getChannels", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getChannels", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getChannels", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_domains<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetDomainsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_domains(args.last_synced) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getDomains", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetDomainsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetDomainsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getDomains", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getDomains", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getDomains", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getDomains", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_friend_channel_matrices<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetFriendChannelMatricesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_friend_channel_matrices(args.channel_ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getFriendChannelMatrices", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetFriendChannelMatricesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetFriendChannelMatricesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getFriendChannelMatrices", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getFriendChannelMatrices", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getFriendChannelMatrices", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getFriendChannelMatrices", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_notification_badge_count<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceGetNotificationBadgeCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_notification_badge_count(args.local_rev) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNotificationBadgeCount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceGetNotificationBadgeCountResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceGetNotificationBadgeCountResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNotificationBadgeCount", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getNotificationBadgeCount", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNotificationBadgeCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getNotificationBadgeCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_issue_channel_token<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceIssueChannelTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_issue_channel_token(args.channel_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("issueChannelToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceIssueChannelTokenResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceIssueChannelTokenResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("issueChannelToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("issueChannelToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("issueChannelToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("issueChannelToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_issue_request_token<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceIssueRequestTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_issue_request_token(args.channel_id, args.otp_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("issueRequestToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceIssueRequestTokenResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceIssueRequestTokenResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("issueRequestToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("issueRequestToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("issueRequestToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("issueRequestToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_issue_request_token_with_auth_scheme<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceIssueRequestTokenWithAuthSchemeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_issue_request_token_with_auth_scheme(args.channel_id, args.otp_id, args.auth_scheme, args.return_url) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("issueRequestTokenWithAuthScheme", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceIssueRequestTokenWithAuthSchemeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceIssueRequestTokenWithAuthSchemeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("issueRequestTokenWithAuthScheme", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("issueRequestTokenWithAuthScheme", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("issueRequestTokenWithAuthScheme", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("issueRequestTokenWithAuthScheme", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reserve_coin_use<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceReserveCoinUseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reserve_coin_use(args.request, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("reserveCoinUse", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceReserveCoinUseResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceReserveCoinUseResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reserveCoinUse", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reserveCoinUse", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reserveCoinUse", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reserveCoinUse", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_revoke_channel<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceRevokeChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_revoke_channel(args.channel_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("revokeChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceRevokeChannelResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceRevokeChannelResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("revokeChannel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("revokeChannel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("revokeChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("revokeChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sync_channel_data<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceSyncChannelDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sync_channel_data(args.last_synced, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("syncChannelData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceSyncChannelDataResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceSyncChannelDataResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("syncChannelData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("syncChannelData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("syncChannelData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("syncChannelData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_channel_notification_setting<H: ChannelServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ChannelServiceUpdateChannelNotificationSettingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_channel_notification_setting(args.setting) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateChannelNotificationSetting", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ChannelServiceUpdateChannelNotificationSettingResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ChannelException>().is_some() {
              let err = usr_err.downcast::<ChannelException>().expect("downcast already checked");
              let ret_err = ChannelServiceUpdateChannelNotificationSettingResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateChannelNotificationSetting", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateChannelNotificationSetting", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateChannelNotificationSetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateChannelNotificationSetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ChannelServiceSyncHandler> TProcessor for ChannelServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "approveChannelAndIssueChannelToken" => {
        self.process_approve_channel_and_issue_channel_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "approveChannelAndIssueRequestToken" => {
        self.process_approve_channel_and_issue_request_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchNotificationItems" => {
        self.process_fetch_notification_items(message_ident.sequence_number, i_prot, o_prot)
      },
      "getApprovedChannels" => {
        self.process_get_approved_channels(message_ident.sequence_number, i_prot, o_prot)
      },
      "getChannelInfo" => {
        self.process_get_channel_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "getChannelNotificationSetting" => {
        self.process_get_channel_notification_setting(message_ident.sequence_number, i_prot, o_prot)
      },
      "getChannelNotificationSettings" => {
        self.process_get_channel_notification_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "getChannels" => {
        self.process_get_channels(message_ident.sequence_number, i_prot, o_prot)
      },
      "getDomains" => {
        self.process_get_domains(message_ident.sequence_number, i_prot, o_prot)
      },
      "getFriendChannelMatrices" => {
        self.process_get_friend_channel_matrices(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNotificationBadgeCount" => {
        self.process_get_notification_badge_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "issueChannelToken" => {
        self.process_issue_channel_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "issueRequestToken" => {
        self.process_issue_request_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "issueRequestTokenWithAuthScheme" => {
        self.process_issue_request_token_with_auth_scheme(message_ident.sequence_number, i_prot, o_prot)
      },
      "reserveCoinUse" => {
        self.process_reserve_coin_use(message_ident.sequence_number, i_prot, o_prot)
      },
      "revokeChannel" => {
        self.process_revoke_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "syncChannelData" => {
        self.process_sync_channel_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateChannelNotificationSetting" => {
        self.process_update_channel_notification_setting(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ChannelServiceApproveChannelAndIssueChannelTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceApproveChannelAndIssueChannelTokenArgs {
  channel_id: String,
}

impl ChannelServiceApproveChannelAndIssueChannelTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceApproveChannelAndIssueChannelTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceApproveChannelAndIssueChannelTokenArgs.channel_id", &f_1)?;
    let ret = ChannelServiceApproveChannelAndIssueChannelTokenArgs {
      channel_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("approveChannelAndIssueChannelToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceApproveChannelAndIssueChannelTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceApproveChannelAndIssueChannelTokenResult {
  result_value: Option<ChannelToken>,
  e: Option<ChannelException>,
}

impl ChannelServiceApproveChannelAndIssueChannelTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceApproveChannelAndIssueChannelTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ChannelToken> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ChannelToken::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceApproveChannelAndIssueChannelTokenResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceApproveChannelAndIssueChannelTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ChannelToken> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceApproveChannelAndIssueChannelToken"
          )
        )
      )
    }
  }
}

//
// ChannelServiceApproveChannelAndIssueRequestTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceApproveChannelAndIssueRequestTokenArgs {
  channel_id: String,
  otp_id: String,
}

impl ChannelServiceApproveChannelAndIssueRequestTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceApproveChannelAndIssueRequestTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceApproveChannelAndIssueRequestTokenArgs.channel_id", &f_1)?;
    verify_required_field_exists("ChannelServiceApproveChannelAndIssueRequestTokenArgs.otp_id", &f_2)?;
    let ret = ChannelServiceApproveChannelAndIssueRequestTokenArgs {
      channel_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      otp_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("approveChannelAndIssueRequestToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("otpId", TType::String, 2))?;
    o_prot.write_string(&self.otp_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceApproveChannelAndIssueRequestTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceApproveChannelAndIssueRequestTokenResult {
  result_value: Option<String>,
  e: Option<ChannelException>,
}

impl ChannelServiceApproveChannelAndIssueRequestTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceApproveChannelAndIssueRequestTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceApproveChannelAndIssueRequestTokenResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceApproveChannelAndIssueRequestTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceApproveChannelAndIssueRequestToken"
          )
        )
      )
    }
  }
}

//
// ChannelServiceFetchNotificationItemsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceFetchNotificationItemsArgs {
  local_rev: i64,
}

impl ChannelServiceFetchNotificationItemsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceFetchNotificationItemsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceFetchNotificationItemsArgs.local_rev", &f_2)?;
    let ret = ChannelServiceFetchNotificationItemsArgs {
      local_rev: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchNotificationItems_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localRev", TType::I64, 2))?;
    o_prot.write_i64(self.local_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceFetchNotificationItemsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceFetchNotificationItemsResult {
  result_value: Option<NotificationFetchResult>,
  e: Option<ChannelException>,
}

impl ChannelServiceFetchNotificationItemsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceFetchNotificationItemsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NotificationFetchResult> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NotificationFetchResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceFetchNotificationItemsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceFetchNotificationItemsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NotificationFetchResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceFetchNotificationItems"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetApprovedChannelsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetApprovedChannelsArgs {
  last_synced: i64,
  locale: String,
}

impl ChannelServiceGetApprovedChannelsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetApprovedChannelsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetApprovedChannelsArgs.last_synced", &f_2)?;
    verify_required_field_exists("ChannelServiceGetApprovedChannelsArgs.locale", &f_3)?;
    let ret = ChannelServiceGetApprovedChannelsArgs {
      last_synced: f_2.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getApprovedChannels_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastSynced", TType::I64, 2))?;
    o_prot.write_i64(self.last_synced)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 3))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetApprovedChannelsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetApprovedChannelsResult {
  result_value: Option<ApprovedChannelInfos>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetApprovedChannelsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetApprovedChannelsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ApprovedChannelInfos> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ApprovedChannelInfos::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetApprovedChannelsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetApprovedChannelsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ApprovedChannelInfos> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetApprovedChannels"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetChannelInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelInfoArgs {
  channel_id: String,
  locale: String,
}

impl ChannelServiceGetChannelInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetChannelInfoArgs.channel_id", &f_2)?;
    verify_required_field_exists("ChannelServiceGetChannelInfoArgs.locale", &f_3)?;
    let ret = ChannelServiceGetChannelInfoArgs {
      channel_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getChannelInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 2))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 3))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetChannelInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelInfoResult {
  result_value: Option<ChannelInfo>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetChannelInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ChannelInfo> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ChannelInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetChannelInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetChannelInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ChannelInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetChannelInfo"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetChannelNotificationSettingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelNotificationSettingArgs {
  channel_id: String,
  locale: String,
}

impl ChannelServiceGetChannelNotificationSettingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelNotificationSettingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetChannelNotificationSettingArgs.channel_id", &f_1)?;
    verify_required_field_exists("ChannelServiceGetChannelNotificationSettingArgs.locale", &f_2)?;
    let ret = ChannelServiceGetChannelNotificationSettingArgs {
      channel_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getChannelNotificationSetting_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 2))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetChannelNotificationSettingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelNotificationSettingResult {
  result_value: Option<ChannelNotificationSetting>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetChannelNotificationSettingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelNotificationSettingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ChannelNotificationSetting> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ChannelNotificationSetting::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetChannelNotificationSettingResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetChannelNotificationSettingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ChannelNotificationSetting> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetChannelNotificationSetting"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetChannelNotificationSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelNotificationSettingsArgs {
  locale: String,
}

impl ChannelServiceGetChannelNotificationSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelNotificationSettingsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetChannelNotificationSettingsArgs.locale", &f_1)?;
    let ret = ChannelServiceGetChannelNotificationSettingsArgs {
      locale: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getChannelNotificationSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 1))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetChannelNotificationSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelNotificationSettingsResult {
  result_value: Option<Vec<ChannelNotificationSetting>>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetChannelNotificationSettingsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelNotificationSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<ChannelNotificationSetting>> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChannelNotificationSetting> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_105 = ChannelNotificationSetting::read_from_in_protocol(i_prot)?;
            val.push(list_elem_105);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetChannelNotificationSettingsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetChannelNotificationSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<ChannelNotificationSetting>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetChannelNotificationSettings"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetChannelsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelsArgs {
  last_synced: i64,
  locale: String,
}

impl ChannelServiceGetChannelsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetChannelsArgs.last_synced", &f_2)?;
    verify_required_field_exists("ChannelServiceGetChannelsArgs.locale", &f_3)?;
    let ret = ChannelServiceGetChannelsArgs {
      last_synced: f_2.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getChannels_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastSynced", TType::I64, 2))?;
    o_prot.write_i64(self.last_synced)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 3))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetChannelsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetChannelsResult {
  result_value: Option<ChannelInfos>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetChannelsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetChannelsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ChannelInfos> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ChannelInfos::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetChannelsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetChannelsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ChannelInfos> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetChannels"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetDomainsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetDomainsArgs {
  last_synced: i64,
}

impl ChannelServiceGetDomainsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetDomainsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetDomainsArgs.last_synced", &f_2)?;
    let ret = ChannelServiceGetDomainsArgs {
      last_synced: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getDomains_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastSynced", TType::I64, 2))?;
    o_prot.write_i64(self.last_synced)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetDomainsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetDomainsResult {
  result_value: Option<ChannelDomains>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetDomainsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetDomainsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ChannelDomains> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ChannelDomains::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetDomainsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetDomainsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ChannelDomains> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetDomains"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetFriendChannelMatricesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetFriendChannelMatricesArgs {
  channel_ids: Vec<String>,
}

impl ChannelServiceGetFriendChannelMatricesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetFriendChannelMatricesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_106 = i_prot.read_string()?;
            val.push(list_elem_106);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetFriendChannelMatricesArgs.channel_ids", &f_1)?;
    let ret = ChannelServiceGetFriendChannelMatricesArgs {
      channel_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getFriendChannelMatrices_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.channel_ids.len() as i32))?;
    for e in &self.channel_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetFriendChannelMatricesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetFriendChannelMatricesResult {
  result_value: Option<FriendChannelMatricesResponse>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetFriendChannelMatricesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetFriendChannelMatricesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FriendChannelMatricesResponse> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FriendChannelMatricesResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetFriendChannelMatricesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetFriendChannelMatricesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FriendChannelMatricesResponse> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetFriendChannelMatrices"
          )
        )
      )
    }
  }
}

//
// ChannelServiceGetNotificationBadgeCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetNotificationBadgeCountArgs {
  local_rev: i64,
}

impl ChannelServiceGetNotificationBadgeCountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetNotificationBadgeCountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceGetNotificationBadgeCountArgs.local_rev", &f_2)?;
    let ret = ChannelServiceGetNotificationBadgeCountArgs {
      local_rev: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNotificationBadgeCount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localRev", TType::I64, 2))?;
    o_prot.write_i64(self.local_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceGetNotificationBadgeCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceGetNotificationBadgeCountResult {
  result_value: Option<i32>,
  e: Option<ChannelException>,
}

impl ChannelServiceGetNotificationBadgeCountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceGetNotificationBadgeCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceGetNotificationBadgeCountResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceGetNotificationBadgeCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceGetNotificationBadgeCount"
          )
        )
      )
    }
  }
}

//
// ChannelServiceIssueChannelTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceIssueChannelTokenArgs {
  channel_id: String,
}

impl ChannelServiceIssueChannelTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceIssueChannelTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceIssueChannelTokenArgs.channel_id", &f_1)?;
    let ret = ChannelServiceIssueChannelTokenArgs {
      channel_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("issueChannelToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceIssueChannelTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceIssueChannelTokenResult {
  result_value: Option<ChannelToken>,
  e: Option<ChannelException>,
}

impl ChannelServiceIssueChannelTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceIssueChannelTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ChannelToken> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ChannelToken::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceIssueChannelTokenResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceIssueChannelTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ChannelToken> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceIssueChannelToken"
          )
        )
      )
    }
  }
}

//
// ChannelServiceIssueRequestTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceIssueRequestTokenArgs {
  channel_id: String,
  otp_id: String,
}

impl ChannelServiceIssueRequestTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceIssueRequestTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceIssueRequestTokenArgs.channel_id", &f_1)?;
    verify_required_field_exists("ChannelServiceIssueRequestTokenArgs.otp_id", &f_2)?;
    let ret = ChannelServiceIssueRequestTokenArgs {
      channel_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      otp_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("issueRequestToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("otpId", TType::String, 2))?;
    o_prot.write_string(&self.otp_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceIssueRequestTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceIssueRequestTokenResult {
  result_value: Option<String>,
  e: Option<ChannelException>,
}

impl ChannelServiceIssueRequestTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceIssueRequestTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceIssueRequestTokenResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceIssueRequestTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceIssueRequestToken"
          )
        )
      )
    }
  }
}

//
// ChannelServiceIssueRequestTokenWithAuthSchemeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceIssueRequestTokenWithAuthSchemeArgs {
  channel_id: String,
  otp_id: String,
  auth_scheme: Vec<String>,
  return_url: String,
}

impl ChannelServiceIssueRequestTokenWithAuthSchemeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceIssueRequestTokenWithAuthSchemeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_107 = i_prot.read_string()?;
            val.push(list_elem_107);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceIssueRequestTokenWithAuthSchemeArgs.channel_id", &f_1)?;
    verify_required_field_exists("ChannelServiceIssueRequestTokenWithAuthSchemeArgs.otp_id", &f_2)?;
    verify_required_field_exists("ChannelServiceIssueRequestTokenWithAuthSchemeArgs.auth_scheme", &f_3)?;
    verify_required_field_exists("ChannelServiceIssueRequestTokenWithAuthSchemeArgs.return_url", &f_4)?;
    let ret = ChannelServiceIssueRequestTokenWithAuthSchemeArgs {
      channel_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      otp_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      auth_scheme: f_3.expect("auto-generated code should have checked for presence of required fields"),
      return_url: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("issueRequestTokenWithAuthScheme_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("otpId", TType::String, 2))?;
    o_prot.write_string(&self.otp_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authScheme", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.auth_scheme.len() as i32))?;
    for e in &self.auth_scheme {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("returnUrl", TType::String, 4))?;
    o_prot.write_string(&self.return_url)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceIssueRequestTokenWithAuthSchemeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceIssueRequestTokenWithAuthSchemeResult {
  result_value: Option<RequestTokenResponse>,
  e: Option<ChannelException>,
}

impl ChannelServiceIssueRequestTokenWithAuthSchemeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceIssueRequestTokenWithAuthSchemeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<RequestTokenResponse> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = RequestTokenResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceIssueRequestTokenWithAuthSchemeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceIssueRequestTokenWithAuthSchemeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<RequestTokenResponse> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceIssueRequestTokenWithAuthScheme"
          )
        )
      )
    }
  }
}

//
// ChannelServiceReserveCoinUseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceReserveCoinUseArgs {
  request: CoinUseReservation,
  locale: String,
}

impl ChannelServiceReserveCoinUseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceReserveCoinUseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CoinUseReservation> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CoinUseReservation::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceReserveCoinUseArgs.request", &f_2)?;
    verify_required_field_exists("ChannelServiceReserveCoinUseArgs.locale", &f_3)?;
    let ret = ChannelServiceReserveCoinUseArgs {
      request: f_2.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reserveCoinUse_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 2))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 3))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceReserveCoinUseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceReserveCoinUseResult {
  result_value: Option<String>,
  e: Option<ChannelException>,
}

impl ChannelServiceReserveCoinUseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceReserveCoinUseResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceReserveCoinUseResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceReserveCoinUseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceReserveCoinUse"
          )
        )
      )
    }
  }
}

//
// ChannelServiceRevokeChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceRevokeChannelArgs {
  channel_id: String,
}

impl ChannelServiceRevokeChannelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceRevokeChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceRevokeChannelArgs.channel_id", &f_1)?;
    let ret = ChannelServiceRevokeChannelArgs {
      channel_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("revokeChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 1))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceRevokeChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceRevokeChannelResult {
  e: Option<ChannelException>,
}

impl ChannelServiceRevokeChannelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceRevokeChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceRevokeChannelResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceRevokeChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ChannelServiceSyncChannelDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceSyncChannelDataArgs {
  last_synced: i64,
  locale: String,
}

impl ChannelServiceSyncChannelDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceSyncChannelDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceSyncChannelDataArgs.last_synced", &f_2)?;
    verify_required_field_exists("ChannelServiceSyncChannelDataArgs.locale", &f_3)?;
    let ret = ChannelServiceSyncChannelDataArgs {
      last_synced: f_2.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("syncChannelData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastSynced", TType::I64, 2))?;
    o_prot.write_i64(self.last_synced)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 3))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceSyncChannelDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceSyncChannelDataResult {
  result_value: Option<ChannelSyncDatas>,
  e: Option<ChannelException>,
}

impl ChannelServiceSyncChannelDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceSyncChannelDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ChannelSyncDatas> = None;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ChannelSyncDatas::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceSyncChannelDataResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceSyncChannelDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ChannelSyncDatas> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ChannelServiceSyncChannelData"
          )
        )
      )
    }
  }
}

//
// ChannelServiceUpdateChannelNotificationSettingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceUpdateChannelNotificationSettingArgs {
  setting: Vec<ChannelNotificationSetting>,
}

impl ChannelServiceUpdateChannelNotificationSettingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceUpdateChannelNotificationSettingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ChannelNotificationSetting>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChannelNotificationSetting> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_108 = ChannelNotificationSetting::read_from_in_protocol(i_prot)?;
            val.push(list_elem_108);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ChannelServiceUpdateChannelNotificationSettingArgs.setting", &f_1)?;
    let ret = ChannelServiceUpdateChannelNotificationSettingArgs {
      setting: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateChannelNotificationSetting_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("setting", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.setting.len() as i32))?;
    for e in &self.setting {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChannelServiceUpdateChannelNotificationSettingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ChannelServiceUpdateChannelNotificationSettingResult {
  e: Option<ChannelException>,
}

impl ChannelServiceUpdateChannelNotificationSettingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChannelServiceUpdateChannelNotificationSettingResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ChannelException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ChannelException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChannelServiceUpdateChannelNotificationSettingResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChannelServiceUpdateChannelNotificationSettingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MessageService service client
//

pub trait TMessageServiceSyncClient {
  fn fetch_message_operations(&mut self, local_revision: i64, last_op_timestamp: i64, count: i32) -> thrift::Result<MessageOperations>;
  fn get_last_read_message_ids(&mut self, chat_id: String) -> thrift::Result<LastReadMessageIds>;
  fn multi_get_last_read_message_ids(&mut self, chat_ids: Vec<String>) -> thrift::Result<Vec<LastReadMessageIds>>;
}

pub trait TMessageServiceSyncClientMarker {}

pub struct MessageServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> MessageServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> MessageServiceSyncClient<IP, OP> {
    MessageServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for MessageServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TMessageServiceSyncClientMarker for MessageServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TMessageServiceSyncClientMarker> TMessageServiceSyncClient for C {
  fn fetch_message_operations(&mut self, local_revision: i64, last_op_timestamp: i64, count: i32) -> thrift::Result<MessageOperations> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchMessageOperations", TMessageType::Call, self.sequence_number());
        let call_args = MessageServiceFetchMessageOperationsArgs { local_revision: local_revision, last_op_timestamp: last_op_timestamp, count: count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchMessageOperations", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MessageServiceFetchMessageOperationsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_last_read_message_ids(&mut self, chat_id: String) -> thrift::Result<LastReadMessageIds> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getLastReadMessageIds", TMessageType::Call, self.sequence_number());
        let call_args = MessageServiceGetLastReadMessageIdsArgs { chat_id: chat_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getLastReadMessageIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MessageServiceGetLastReadMessageIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn multi_get_last_read_message_ids(&mut self, chat_ids: Vec<String>) -> thrift::Result<Vec<LastReadMessageIds>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("multiGetLastReadMessageIds", TMessageType::Call, self.sequence_number());
        let call_args = MessageServiceMultiGetLastReadMessageIdsArgs { chat_ids: chat_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("multiGetLastReadMessageIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MessageServiceMultiGetLastReadMessageIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// MessageService service processor
//

pub trait MessageServiceSyncHandler {
  fn handle_fetch_message_operations(&self, local_revision: i64, last_op_timestamp: i64, count: i32) -> thrift::Result<MessageOperations>;
  fn handle_get_last_read_message_ids(&self, chat_id: String) -> thrift::Result<LastReadMessageIds>;
  fn handle_multi_get_last_read_message_ids(&self, chat_ids: Vec<String>) -> thrift::Result<Vec<LastReadMessageIds>>;
}

pub struct MessageServiceSyncProcessor<H: MessageServiceSyncHandler> {
  handler: H,
}

impl <H: MessageServiceSyncHandler> MessageServiceSyncProcessor<H> {
  pub fn new(handler: H) -> MessageServiceSyncProcessor<H> {
    MessageServiceSyncProcessor {
      handler,
    }
  }
  fn process_fetch_message_operations(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMessageServiceProcessFunctions::process_fetch_message_operations(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_last_read_message_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMessageServiceProcessFunctions::process_get_last_read_message_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_multi_get_last_read_message_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMessageServiceProcessFunctions::process_multi_get_last_read_message_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TMessageServiceProcessFunctions;

impl TMessageServiceProcessFunctions {
  pub fn process_fetch_message_operations<H: MessageServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MessageServiceFetchMessageOperationsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_message_operations(args.local_revision, args.last_op_timestamp, args.count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchMessageOperations", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MessageServiceFetchMessageOperationsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = MessageServiceFetchMessageOperationsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("fetchMessageOperations", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("fetchMessageOperations", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchMessageOperations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchMessageOperations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_last_read_message_ids<H: MessageServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MessageServiceGetLastReadMessageIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_last_read_message_ids(args.chat_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getLastReadMessageIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MessageServiceGetLastReadMessageIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = MessageServiceGetLastReadMessageIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getLastReadMessageIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getLastReadMessageIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getLastReadMessageIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getLastReadMessageIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_multi_get_last_read_message_ids<H: MessageServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MessageServiceMultiGetLastReadMessageIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_multi_get_last_read_message_ids(args.chat_ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("multiGetLastReadMessageIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MessageServiceMultiGetLastReadMessageIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = MessageServiceMultiGetLastReadMessageIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("multiGetLastReadMessageIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("multiGetLastReadMessageIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("multiGetLastReadMessageIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("multiGetLastReadMessageIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: MessageServiceSyncHandler> TProcessor for MessageServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "fetchMessageOperations" => {
        self.process_fetch_message_operations(message_ident.sequence_number, i_prot, o_prot)
      },
      "getLastReadMessageIds" => {
        self.process_get_last_read_message_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "multiGetLastReadMessageIds" => {
        self.process_multi_get_last_read_message_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// MessageServiceFetchMessageOperationsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MessageServiceFetchMessageOperationsArgs {
  local_revision: i64,
  last_op_timestamp: i64,
  count: i32,
}

impl MessageServiceFetchMessageOperationsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageServiceFetchMessageOperationsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MessageServiceFetchMessageOperationsArgs.local_revision", &f_2)?;
    verify_required_field_exists("MessageServiceFetchMessageOperationsArgs.last_op_timestamp", &f_3)?;
    verify_required_field_exists("MessageServiceFetchMessageOperationsArgs.count", &f_4)?;
    let ret = MessageServiceFetchMessageOperationsArgs {
      local_revision: f_2.expect("auto-generated code should have checked for presence of required fields"),
      last_op_timestamp: f_3.expect("auto-generated code should have checked for presence of required fields"),
      count: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchMessageOperations_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localRevision", TType::I64, 2))?;
    o_prot.write_i64(self.local_revision)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastOpTimestamp", TType::I64, 3))?;
    o_prot.write_i64(self.last_op_timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 4))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MessageServiceFetchMessageOperationsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MessageServiceFetchMessageOperationsResult {
  result_value: Option<MessageOperations>,
  e: Option<TalkException>,
}

impl MessageServiceFetchMessageOperationsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageServiceFetchMessageOperationsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<MessageOperations> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = MessageOperations::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MessageServiceFetchMessageOperationsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MessageServiceFetchMessageOperationsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<MessageOperations> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MessageServiceFetchMessageOperations"
          )
        )
      )
    }
  }
}

//
// MessageServiceGetLastReadMessageIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MessageServiceGetLastReadMessageIdsArgs {
  chat_id: String,
}

impl MessageServiceGetLastReadMessageIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageServiceGetLastReadMessageIdsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MessageServiceGetLastReadMessageIdsArgs.chat_id", &f_2)?;
    let ret = MessageServiceGetLastReadMessageIdsArgs {
      chat_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getLastReadMessageIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("chatId", TType::String, 2))?;
    o_prot.write_string(&self.chat_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MessageServiceGetLastReadMessageIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MessageServiceGetLastReadMessageIdsResult {
  result_value: Option<LastReadMessageIds>,
  e: Option<TalkException>,
}

impl MessageServiceGetLastReadMessageIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageServiceGetLastReadMessageIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LastReadMessageIds> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LastReadMessageIds::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MessageServiceGetLastReadMessageIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MessageServiceGetLastReadMessageIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LastReadMessageIds> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MessageServiceGetLastReadMessageIds"
          )
        )
      )
    }
  }
}

//
// MessageServiceMultiGetLastReadMessageIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MessageServiceMultiGetLastReadMessageIdsArgs {
  chat_ids: Vec<String>,
}

impl MessageServiceMultiGetLastReadMessageIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageServiceMultiGetLastReadMessageIdsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_109 = i_prot.read_string()?;
            val.push(list_elem_109);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MessageServiceMultiGetLastReadMessageIdsArgs.chat_ids", &f_2)?;
    let ret = MessageServiceMultiGetLastReadMessageIdsArgs {
      chat_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("multiGetLastReadMessageIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("chatIds", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.chat_ids.len() as i32))?;
    for e in &self.chat_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MessageServiceMultiGetLastReadMessageIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MessageServiceMultiGetLastReadMessageIdsResult {
  result_value: Option<Vec<LastReadMessageIds>>,
  e: Option<TalkException>,
}

impl MessageServiceMultiGetLastReadMessageIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MessageServiceMultiGetLastReadMessageIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<LastReadMessageIds>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<LastReadMessageIds> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_110 = LastReadMessageIds::read_from_in_protocol(i_prot)?;
            val.push(list_elem_110);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MessageServiceMultiGetLastReadMessageIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MessageServiceMultiGetLastReadMessageIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<LastReadMessageIds>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MessageServiceMultiGetLastReadMessageIds"
          )
        )
      )
    }
  }
}

//
// ShopService service client
//

pub trait TShopServiceSyncClient {
  fn buy_coin_product(&mut self, payment_reservation: PaymentReservation) -> thrift::Result<()>;
  fn buy_free_product(&mut self, receiver_mid: String, product_id: String, message_template: i32, language: String, country: String, package_id: i64) -> thrift::Result<()>;
  fn buy_mustbuy_product(&mut self, receiver_mid: String, product_id: String, message_template: i32, language: String, country: String, package_id: i64, serial_number: String) -> thrift::Result<()>;
  fn check_can_receive_present(&mut self, recipient_mid: String, package_id: i64, language: String, country: String) -> thrift::Result<()>;
  fn get_active_purchases(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_active_purchase_versions(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductSimpleList>;
  fn get_coin_products(&mut self, app_store_code: PaymentType, country: String, language: String) -> thrift::Result<Vec<CoinProductItem>>;
  fn get_coin_products_by_pg_code(&mut self, app_store_code: PaymentType, pg_code: PaymentPgType, country: String, language: String) -> thrift::Result<Vec<CoinProductItem>>;
  fn get_coin_purchase_history(&mut self, request: CoinHistoryCondition) -> thrift::Result<CoinHistoryResult>;
  fn get_coin_use_and_refund_history(&mut self, request: CoinHistoryCondition) -> thrift::Result<CoinHistoryResult>;
  fn get_downloads(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_event_packages(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_newly_released_packages(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_popular_packages(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_presents_received(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_presents_sent(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_product(&mut self, package_i_d: i64, language: String, country: String) -> thrift::Result<Product>;
  fn get_product_list(&mut self, product_id_list: Vec<String>, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_product_list_with_carrier(&mut self, product_id_list: Vec<String>, language: String, country: String, carrier_code: String) -> thrift::Result<ProductList>;
  fn get_product_with_carrier(&mut self, package_i_d: i64, language: String, country: String, carrier_code: String) -> thrift::Result<Product>;
  fn get_purchase_history(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn get_total_balance(&mut self, app_store_code: PaymentType) -> thrift::Result<Coin>;
  fn notify_downloaded(&mut self, package_id: i64, language: String) -> thrift::Result<i64>;
  fn reserve_coin_purchase(&mut self, request: CoinPurchaseReservation) -> thrift::Result<PaymentReservationResult>;
  fn reserve_payment(&mut self, payment_reservation: PaymentReservation) -> thrift::Result<PaymentReservationResult>;
}

pub trait TShopServiceSyncClientMarker {}

pub struct ShopServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ShopServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ShopServiceSyncClient<IP, OP> {
    ShopServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ShopServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TShopServiceSyncClientMarker for ShopServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TShopServiceSyncClientMarker> TShopServiceSyncClient for C {
  fn buy_coin_product(&mut self, payment_reservation: PaymentReservation) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("buyCoinProduct", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceBuyCoinProductArgs { payment_reservation: payment_reservation };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("buyCoinProduct", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceBuyCoinProductResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn buy_free_product(&mut self, receiver_mid: String, product_id: String, message_template: i32, language: String, country: String, package_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("buyFreeProduct", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceBuyFreeProductArgs { receiver_mid: receiver_mid, product_id: product_id, message_template: message_template, language: language, country: country, package_id: package_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("buyFreeProduct", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceBuyFreeProductResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn buy_mustbuy_product(&mut self, receiver_mid: String, product_id: String, message_template: i32, language: String, country: String, package_id: i64, serial_number: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("buyMustbuyProduct", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceBuyMustbuyProductArgs { receiver_mid: receiver_mid, product_id: product_id, message_template: message_template, language: language, country: country, package_id: package_id, serial_number: serial_number };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("buyMustbuyProduct", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceBuyMustbuyProductResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_can_receive_present(&mut self, recipient_mid: String, package_id: i64, language: String, country: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("checkCanReceivePresent", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceCheckCanReceivePresentArgs { recipient_mid: recipient_mid, package_id: package_id, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("checkCanReceivePresent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceCheckCanReceivePresentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_active_purchases(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getActivePurchases", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetActivePurchasesArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getActivePurchases", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetActivePurchasesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_active_purchase_versions(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductSimpleList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getActivePurchaseVersions", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetActivePurchaseVersionsArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getActivePurchaseVersions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetActivePurchaseVersionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_coin_products(&mut self, app_store_code: PaymentType, country: String, language: String) -> thrift::Result<Vec<CoinProductItem>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCoinProducts", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetCoinProductsArgs { app_store_code: app_store_code, country: country, language: language };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCoinProducts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetCoinProductsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_coin_products_by_pg_code(&mut self, app_store_code: PaymentType, pg_code: PaymentPgType, country: String, language: String) -> thrift::Result<Vec<CoinProductItem>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCoinProductsByPgCode", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetCoinProductsByPgCodeArgs { app_store_code: app_store_code, pg_code: pg_code, country: country, language: language };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCoinProductsByPgCode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetCoinProductsByPgCodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_coin_purchase_history(&mut self, request: CoinHistoryCondition) -> thrift::Result<CoinHistoryResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCoinPurchaseHistory", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetCoinPurchaseHistoryArgs { request: request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCoinPurchaseHistory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetCoinPurchaseHistoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_coin_use_and_refund_history(&mut self, request: CoinHistoryCondition) -> thrift::Result<CoinHistoryResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCoinUseAndRefundHistory", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetCoinUseAndRefundHistoryArgs { request: request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCoinUseAndRefundHistory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetCoinUseAndRefundHistoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_downloads(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getDownloads", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetDownloadsArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getDownloads", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetDownloadsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_event_packages(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getEventPackages", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetEventPackagesArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getEventPackages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetEventPackagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_newly_released_packages(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNewlyReleasedPackages", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetNewlyReleasedPackagesArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNewlyReleasedPackages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetNewlyReleasedPackagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_popular_packages(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPopularPackages", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetPopularPackagesArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPopularPackages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetPopularPackagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_presents_received(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPresentsReceived", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetPresentsReceivedArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPresentsReceived", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetPresentsReceivedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_presents_sent(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPresentsSent", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetPresentsSentArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPresentsSent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetPresentsSentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_product(&mut self, package_i_d: i64, language: String, country: String) -> thrift::Result<Product> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProduct", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetProductArgs { package_i_d: package_i_d, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProduct", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetProductResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_product_list(&mut self, product_id_list: Vec<String>, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProductList", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetProductListArgs { product_id_list: product_id_list, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProductList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetProductListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_product_list_with_carrier(&mut self, product_id_list: Vec<String>, language: String, country: String, carrier_code: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProductListWithCarrier", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetProductListWithCarrierArgs { product_id_list: product_id_list, language: language, country: country, carrier_code: carrier_code };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProductListWithCarrier", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetProductListWithCarrierResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_product_with_carrier(&mut self, package_i_d: i64, language: String, country: String, carrier_code: String) -> thrift::Result<Product> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProductWithCarrier", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetProductWithCarrierArgs { package_i_d: package_i_d, language: language, country: country, carrier_code: carrier_code };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProductWithCarrier", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetProductWithCarrierResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_purchase_history(&mut self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPurchaseHistory", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetPurchaseHistoryArgs { start: start, size: size, language: language, country: country };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPurchaseHistory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetPurchaseHistoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_total_balance(&mut self, app_store_code: PaymentType) -> thrift::Result<Coin> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getTotalBalance", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceGetTotalBalanceArgs { app_store_code: app_store_code };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getTotalBalance", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceGetTotalBalanceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_downloaded(&mut self, package_id: i64, language: String) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyDownloaded", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceNotifyDownloadedArgs { package_id: package_id, language: language };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyDownloaded", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceNotifyDownloadedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reserve_coin_purchase(&mut self, request: CoinPurchaseReservation) -> thrift::Result<PaymentReservationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reserveCoinPurchase", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceReserveCoinPurchaseArgs { request: request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reserveCoinPurchase", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceReserveCoinPurchaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reserve_payment(&mut self, payment_reservation: PaymentReservation) -> thrift::Result<PaymentReservationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reservePayment", TMessageType::Call, self.sequence_number());
        let call_args = ShopServiceReservePaymentArgs { payment_reservation: payment_reservation };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reservePayment", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ShopServiceReservePaymentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// ShopService service processor
//

pub trait ShopServiceSyncHandler {
  fn handle_buy_coin_product(&self, payment_reservation: PaymentReservation) -> thrift::Result<()>;
  fn handle_buy_free_product(&self, receiver_mid: String, product_id: String, message_template: i32, language: String, country: String, package_id: i64) -> thrift::Result<()>;
  fn handle_buy_mustbuy_product(&self, receiver_mid: String, product_id: String, message_template: i32, language: String, country: String, package_id: i64, serial_number: String) -> thrift::Result<()>;
  fn handle_check_can_receive_present(&self, recipient_mid: String, package_id: i64, language: String, country: String) -> thrift::Result<()>;
  fn handle_get_active_purchases(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_active_purchase_versions(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductSimpleList>;
  fn handle_get_coin_products(&self, app_store_code: PaymentType, country: String, language: String) -> thrift::Result<Vec<CoinProductItem>>;
  fn handle_get_coin_products_by_pg_code(&self, app_store_code: PaymentType, pg_code: PaymentPgType, country: String, language: String) -> thrift::Result<Vec<CoinProductItem>>;
  fn handle_get_coin_purchase_history(&self, request: CoinHistoryCondition) -> thrift::Result<CoinHistoryResult>;
  fn handle_get_coin_use_and_refund_history(&self, request: CoinHistoryCondition) -> thrift::Result<CoinHistoryResult>;
  fn handle_get_downloads(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_event_packages(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_newly_released_packages(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_popular_packages(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_presents_received(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_presents_sent(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_product(&self, package_i_d: i64, language: String, country: String) -> thrift::Result<Product>;
  fn handle_get_product_list(&self, product_id_list: Vec<String>, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_product_list_with_carrier(&self, product_id_list: Vec<String>, language: String, country: String, carrier_code: String) -> thrift::Result<ProductList>;
  fn handle_get_product_with_carrier(&self, package_i_d: i64, language: String, country: String, carrier_code: String) -> thrift::Result<Product>;
  fn handle_get_purchase_history(&self, start: i64, size: i32, language: String, country: String) -> thrift::Result<ProductList>;
  fn handle_get_total_balance(&self, app_store_code: PaymentType) -> thrift::Result<Coin>;
  fn handle_notify_downloaded(&self, package_id: i64, language: String) -> thrift::Result<i64>;
  fn handle_reserve_coin_purchase(&self, request: CoinPurchaseReservation) -> thrift::Result<PaymentReservationResult>;
  fn handle_reserve_payment(&self, payment_reservation: PaymentReservation) -> thrift::Result<PaymentReservationResult>;
}

pub struct ShopServiceSyncProcessor<H: ShopServiceSyncHandler> {
  handler: H,
}

impl <H: ShopServiceSyncHandler> ShopServiceSyncProcessor<H> {
  pub fn new(handler: H) -> ShopServiceSyncProcessor<H> {
    ShopServiceSyncProcessor {
      handler,
    }
  }
  fn process_buy_coin_product(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_buy_coin_product(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_buy_free_product(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_buy_free_product(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_buy_mustbuy_product(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_buy_mustbuy_product(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_can_receive_present(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_check_can_receive_present(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_active_purchases(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_active_purchases(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_active_purchase_versions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_active_purchase_versions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_coin_products(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_coin_products(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_coin_products_by_pg_code(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_coin_products_by_pg_code(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_coin_purchase_history(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_coin_purchase_history(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_coin_use_and_refund_history(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_coin_use_and_refund_history(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_downloads(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_downloads(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_event_packages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_event_packages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_newly_released_packages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_newly_released_packages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_popular_packages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_popular_packages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_presents_received(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_presents_received(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_presents_sent(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_presents_sent(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_product(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_product(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_product_list(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_product_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_product_list_with_carrier(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_product_list_with_carrier(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_product_with_carrier(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_product_with_carrier(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_purchase_history(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_purchase_history(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_total_balance(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_get_total_balance(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_downloaded(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_notify_downloaded(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reserve_coin_purchase(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_reserve_coin_purchase(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reserve_payment(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TShopServiceProcessFunctions::process_reserve_payment(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TShopServiceProcessFunctions;

impl TShopServiceProcessFunctions {
  pub fn process_buy_coin_product<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceBuyCoinProductArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_buy_coin_product(args.payment_reservation) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("buyCoinProduct", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceBuyCoinProductResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceBuyCoinProductResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("buyCoinProduct", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("buyCoinProduct", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("buyCoinProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("buyCoinProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_buy_free_product<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceBuyFreeProductArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_buy_free_product(args.receiver_mid, args.product_id, args.message_template, args.language, args.country, args.package_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("buyFreeProduct", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceBuyFreeProductResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceBuyFreeProductResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("buyFreeProduct", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("buyFreeProduct", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("buyFreeProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("buyFreeProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_buy_mustbuy_product<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceBuyMustbuyProductArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_buy_mustbuy_product(args.receiver_mid, args.product_id, args.message_template, args.language, args.country, args.package_id, args.serial_number) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("buyMustbuyProduct", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceBuyMustbuyProductResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceBuyMustbuyProductResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("buyMustbuyProduct", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("buyMustbuyProduct", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("buyMustbuyProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("buyMustbuyProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_can_receive_present<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceCheckCanReceivePresentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_can_receive_present(args.recipient_mid, args.package_id, args.language, args.country) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("checkCanReceivePresent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceCheckCanReceivePresentResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceCheckCanReceivePresentResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("checkCanReceivePresent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("checkCanReceivePresent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("checkCanReceivePresent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("checkCanReceivePresent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_active_purchases<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetActivePurchasesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_active_purchases(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getActivePurchases", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetActivePurchasesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetActivePurchasesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getActivePurchases", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getActivePurchases", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getActivePurchases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getActivePurchases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_active_purchase_versions<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetActivePurchaseVersionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_active_purchase_versions(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getActivePurchaseVersions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetActivePurchaseVersionsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetActivePurchaseVersionsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getActivePurchaseVersions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getActivePurchaseVersions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getActivePurchaseVersions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getActivePurchaseVersions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_coin_products<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetCoinProductsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_coin_products(args.app_store_code, args.country, args.language) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCoinProducts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetCoinProductsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetCoinProductsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCoinProducts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCoinProducts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCoinProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCoinProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_coin_products_by_pg_code<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetCoinProductsByPgCodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_coin_products_by_pg_code(args.app_store_code, args.pg_code, args.country, args.language) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCoinProductsByPgCode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetCoinProductsByPgCodeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetCoinProductsByPgCodeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCoinProductsByPgCode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCoinProductsByPgCode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCoinProductsByPgCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCoinProductsByPgCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_coin_purchase_history<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetCoinPurchaseHistoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_coin_purchase_history(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCoinPurchaseHistory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetCoinPurchaseHistoryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetCoinPurchaseHistoryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCoinPurchaseHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCoinPurchaseHistory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCoinPurchaseHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCoinPurchaseHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_coin_use_and_refund_history<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetCoinUseAndRefundHistoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_coin_use_and_refund_history(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCoinUseAndRefundHistory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetCoinUseAndRefundHistoryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetCoinUseAndRefundHistoryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCoinUseAndRefundHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCoinUseAndRefundHistory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCoinUseAndRefundHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCoinUseAndRefundHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_downloads<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetDownloadsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_downloads(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getDownloads", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetDownloadsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetDownloadsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getDownloads", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getDownloads", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getDownloads", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getDownloads", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_event_packages<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetEventPackagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_event_packages(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getEventPackages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetEventPackagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetEventPackagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getEventPackages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getEventPackages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getEventPackages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getEventPackages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_newly_released_packages<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetNewlyReleasedPackagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_newly_released_packages(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNewlyReleasedPackages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetNewlyReleasedPackagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetNewlyReleasedPackagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNewlyReleasedPackages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getNewlyReleasedPackages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNewlyReleasedPackages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getNewlyReleasedPackages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_popular_packages<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetPopularPackagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_popular_packages(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPopularPackages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetPopularPackagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetPopularPackagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPopularPackages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPopularPackages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPopularPackages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPopularPackages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_presents_received<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetPresentsReceivedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_presents_received(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPresentsReceived", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetPresentsReceivedResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetPresentsReceivedResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPresentsReceived", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPresentsReceived", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPresentsReceived", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPresentsReceived", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_presents_sent<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetPresentsSentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_presents_sent(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPresentsSent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetPresentsSentResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetPresentsSentResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPresentsSent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPresentsSent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPresentsSent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPresentsSent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_product<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetProductArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_product(args.package_i_d, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProduct", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetProductResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetProductResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProduct", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProduct", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_product_list<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetProductListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_product_list(args.product_id_list, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProductList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetProductListResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetProductListResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProductList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProductList", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProductList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProductList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_product_list_with_carrier<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetProductListWithCarrierArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_product_list_with_carrier(args.product_id_list, args.language, args.country, args.carrier_code) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProductListWithCarrier", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetProductListWithCarrierResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetProductListWithCarrierResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProductListWithCarrier", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProductListWithCarrier", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProductListWithCarrier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProductListWithCarrier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_product_with_carrier<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetProductWithCarrierArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_product_with_carrier(args.package_i_d, args.language, args.country, args.carrier_code) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProductWithCarrier", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetProductWithCarrierResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetProductWithCarrierResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProductWithCarrier", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProductWithCarrier", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProductWithCarrier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProductWithCarrier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_purchase_history<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetPurchaseHistoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_purchase_history(args.start, args.size, args.language, args.country) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPurchaseHistory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetPurchaseHistoryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetPurchaseHistoryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPurchaseHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPurchaseHistory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPurchaseHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPurchaseHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_total_balance<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceGetTotalBalanceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_total_balance(args.app_store_code) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getTotalBalance", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceGetTotalBalanceResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceGetTotalBalanceResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getTotalBalance", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getTotalBalance", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getTotalBalance", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getTotalBalance", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_downloaded<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceNotifyDownloadedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_downloaded(args.package_id, args.language) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("notifyDownloaded", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceNotifyDownloadedResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceNotifyDownloadedResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifyDownloaded", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifyDownloaded", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyDownloaded", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyDownloaded", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reserve_coin_purchase<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceReserveCoinPurchaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reserve_coin_purchase(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("reserveCoinPurchase", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceReserveCoinPurchaseResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceReserveCoinPurchaseResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reserveCoinPurchase", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reserveCoinPurchase", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reserveCoinPurchase", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reserveCoinPurchase", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reserve_payment<H: ShopServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ShopServiceReservePaymentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reserve_payment(args.payment_reservation) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("reservePayment", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ShopServiceReservePaymentResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = ShopServiceReservePaymentResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reservePayment", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reservePayment", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reservePayment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reservePayment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ShopServiceSyncHandler> TProcessor for ShopServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "buyCoinProduct" => {
        self.process_buy_coin_product(message_ident.sequence_number, i_prot, o_prot)
      },
      "buyFreeProduct" => {
        self.process_buy_free_product(message_ident.sequence_number, i_prot, o_prot)
      },
      "buyMustbuyProduct" => {
        self.process_buy_mustbuy_product(message_ident.sequence_number, i_prot, o_prot)
      },
      "checkCanReceivePresent" => {
        self.process_check_can_receive_present(message_ident.sequence_number, i_prot, o_prot)
      },
      "getActivePurchases" => {
        self.process_get_active_purchases(message_ident.sequence_number, i_prot, o_prot)
      },
      "getActivePurchaseVersions" => {
        self.process_get_active_purchase_versions(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCoinProducts" => {
        self.process_get_coin_products(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCoinProductsByPgCode" => {
        self.process_get_coin_products_by_pg_code(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCoinPurchaseHistory" => {
        self.process_get_coin_purchase_history(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCoinUseAndRefundHistory" => {
        self.process_get_coin_use_and_refund_history(message_ident.sequence_number, i_prot, o_prot)
      },
      "getDownloads" => {
        self.process_get_downloads(message_ident.sequence_number, i_prot, o_prot)
      },
      "getEventPackages" => {
        self.process_get_event_packages(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNewlyReleasedPackages" => {
        self.process_get_newly_released_packages(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPopularPackages" => {
        self.process_get_popular_packages(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPresentsReceived" => {
        self.process_get_presents_received(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPresentsSent" => {
        self.process_get_presents_sent(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProduct" => {
        self.process_get_product(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProductList" => {
        self.process_get_product_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProductListWithCarrier" => {
        self.process_get_product_list_with_carrier(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProductWithCarrier" => {
        self.process_get_product_with_carrier(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPurchaseHistory" => {
        self.process_get_purchase_history(message_ident.sequence_number, i_prot, o_prot)
      },
      "getTotalBalance" => {
        self.process_get_total_balance(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyDownloaded" => {
        self.process_notify_downloaded(message_ident.sequence_number, i_prot, o_prot)
      },
      "reserveCoinPurchase" => {
        self.process_reserve_coin_purchase(message_ident.sequence_number, i_prot, o_prot)
      },
      "reservePayment" => {
        self.process_reserve_payment(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ShopServiceBuyCoinProductArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceBuyCoinProductArgs {
  payment_reservation: PaymentReservation,
}

impl ShopServiceBuyCoinProductArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceBuyCoinProductArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<PaymentReservation> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = PaymentReservation::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceBuyCoinProductArgs.payment_reservation", &f_2)?;
    let ret = ShopServiceBuyCoinProductArgs {
      payment_reservation: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("buyCoinProduct_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paymentReservation", TType::Struct, 2))?;
    self.payment_reservation.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceBuyCoinProductResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceBuyCoinProductResult {
  e: Option<TalkException>,
}

impl ShopServiceBuyCoinProductResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceBuyCoinProductResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceBuyCoinProductResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceBuyCoinProductResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ShopServiceBuyFreeProductArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceBuyFreeProductArgs {
  receiver_mid: String,
  product_id: String,
  message_template: i32,
  language: String,
  country: String,
  package_id: i64,
}

impl ShopServiceBuyFreeProductArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceBuyFreeProductArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceBuyFreeProductArgs.receiver_mid", &f_2)?;
    verify_required_field_exists("ShopServiceBuyFreeProductArgs.product_id", &f_3)?;
    verify_required_field_exists("ShopServiceBuyFreeProductArgs.message_template", &f_4)?;
    verify_required_field_exists("ShopServiceBuyFreeProductArgs.language", &f_5)?;
    verify_required_field_exists("ShopServiceBuyFreeProductArgs.country", &f_6)?;
    verify_required_field_exists("ShopServiceBuyFreeProductArgs.package_id", &f_7)?;
    let ret = ShopServiceBuyFreeProductArgs {
      receiver_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      product_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      message_template: f_4.expect("auto-generated code should have checked for presence of required fields"),
      language: f_5.expect("auto-generated code should have checked for presence of required fields"),
      country: f_6.expect("auto-generated code should have checked for presence of required fields"),
      package_id: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("buyFreeProduct_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMid", TType::String, 2))?;
    o_prot.write_string(&self.receiver_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 3))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageTemplate", TType::I32, 4))?;
    o_prot.write_i32(self.message_template)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 5))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 6))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("packageId", TType::I64, 7))?;
    o_prot.write_i64(self.package_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceBuyFreeProductResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceBuyFreeProductResult {
  e: Option<TalkException>,
}

impl ShopServiceBuyFreeProductResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceBuyFreeProductResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceBuyFreeProductResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceBuyFreeProductResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ShopServiceBuyMustbuyProductArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceBuyMustbuyProductArgs {
  receiver_mid: String,
  product_id: String,
  message_template: i32,
  language: String,
  country: String,
  package_id: i64,
  serial_number: String,
}

impl ShopServiceBuyMustbuyProductArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceBuyMustbuyProductArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceBuyMustbuyProductArgs.receiver_mid", &f_2)?;
    verify_required_field_exists("ShopServiceBuyMustbuyProductArgs.product_id", &f_3)?;
    verify_required_field_exists("ShopServiceBuyMustbuyProductArgs.message_template", &f_4)?;
    verify_required_field_exists("ShopServiceBuyMustbuyProductArgs.language", &f_5)?;
    verify_required_field_exists("ShopServiceBuyMustbuyProductArgs.country", &f_6)?;
    verify_required_field_exists("ShopServiceBuyMustbuyProductArgs.package_id", &f_7)?;
    verify_required_field_exists("ShopServiceBuyMustbuyProductArgs.serial_number", &f_8)?;
    let ret = ShopServiceBuyMustbuyProductArgs {
      receiver_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      product_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      message_template: f_4.expect("auto-generated code should have checked for presence of required fields"),
      language: f_5.expect("auto-generated code should have checked for presence of required fields"),
      country: f_6.expect("auto-generated code should have checked for presence of required fields"),
      package_id: f_7.expect("auto-generated code should have checked for presence of required fields"),
      serial_number: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("buyMustbuyProduct_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMid", TType::String, 2))?;
    o_prot.write_string(&self.receiver_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 3))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageTemplate", TType::I32, 4))?;
    o_prot.write_i32(self.message_template)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 5))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 6))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("packageId", TType::I64, 7))?;
    o_prot.write_i64(self.package_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serialNumber", TType::String, 8))?;
    o_prot.write_string(&self.serial_number)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceBuyMustbuyProductResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceBuyMustbuyProductResult {
  e: Option<TalkException>,
}

impl ShopServiceBuyMustbuyProductResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceBuyMustbuyProductResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceBuyMustbuyProductResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceBuyMustbuyProductResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ShopServiceCheckCanReceivePresentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceCheckCanReceivePresentArgs {
  recipient_mid: String,
  package_id: i64,
  language: String,
  country: String,
}

impl ShopServiceCheckCanReceivePresentArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceCheckCanReceivePresentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceCheckCanReceivePresentArgs.recipient_mid", &f_2)?;
    verify_required_field_exists("ShopServiceCheckCanReceivePresentArgs.package_id", &f_3)?;
    verify_required_field_exists("ShopServiceCheckCanReceivePresentArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceCheckCanReceivePresentArgs.country", &f_5)?;
    let ret = ShopServiceCheckCanReceivePresentArgs {
      recipient_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      package_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("checkCanReceivePresent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("recipientMid", TType::String, 2))?;
    o_prot.write_string(&self.recipient_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("packageId", TType::I64, 3))?;
    o_prot.write_i64(self.package_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceCheckCanReceivePresentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceCheckCanReceivePresentResult {
  e: Option<TalkException>,
}

impl ShopServiceCheckCanReceivePresentResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceCheckCanReceivePresentResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceCheckCanReceivePresentResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceCheckCanReceivePresentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ShopServiceGetActivePurchasesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetActivePurchasesArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetActivePurchasesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetActivePurchasesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetActivePurchasesArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetActivePurchasesArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetActivePurchasesArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetActivePurchasesArgs.country", &f_5)?;
    let ret = ShopServiceGetActivePurchasesArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getActivePurchases_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetActivePurchasesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetActivePurchasesResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetActivePurchasesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetActivePurchasesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetActivePurchasesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetActivePurchasesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetActivePurchases"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetActivePurchaseVersionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetActivePurchaseVersionsArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetActivePurchaseVersionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetActivePurchaseVersionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetActivePurchaseVersionsArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetActivePurchaseVersionsArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetActivePurchaseVersionsArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetActivePurchaseVersionsArgs.country", &f_5)?;
    let ret = ShopServiceGetActivePurchaseVersionsArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getActivePurchaseVersions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetActivePurchaseVersionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetActivePurchaseVersionsResult {
  result_value: Option<ProductSimpleList>,
  e: Option<TalkException>,
}

impl ShopServiceGetActivePurchaseVersionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetActivePurchaseVersionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductSimpleList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductSimpleList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetActivePurchaseVersionsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetActivePurchaseVersionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductSimpleList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetActivePurchaseVersions"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetCoinProductsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinProductsArgs {
  app_store_code: PaymentType,
  country: String,
  language: String,
}

impl ShopServiceGetCoinProductsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinProductsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<PaymentType> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetCoinProductsArgs.app_store_code", &f_2)?;
    verify_required_field_exists("ShopServiceGetCoinProductsArgs.country", &f_3)?;
    verify_required_field_exists("ShopServiceGetCoinProductsArgs.language", &f_4)?;
    let ret = ShopServiceGetCoinProductsArgs {
      app_store_code: f_2.expect("auto-generated code should have checked for presence of required fields"),
      country: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCoinProducts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 2))?;
    self.app_store_code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 3))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetCoinProductsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinProductsResult {
  result_value: Option<Vec<CoinProductItem>>,
  e: Option<TalkException>,
}

impl ShopServiceGetCoinProductsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinProductsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<CoinProductItem>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CoinProductItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_111 = CoinProductItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_111);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetCoinProductsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetCoinProductsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<CoinProductItem>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetCoinProducts"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetCoinProductsByPgCodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinProductsByPgCodeArgs {
  app_store_code: PaymentType,
  pg_code: PaymentPgType,
  country: String,
  language: String,
}

impl ShopServiceGetCoinProductsByPgCodeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinProductsByPgCodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<PaymentType> = None;
    let mut f_3: Option<PaymentPgType> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = PaymentPgType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetCoinProductsByPgCodeArgs.app_store_code", &f_2)?;
    verify_required_field_exists("ShopServiceGetCoinProductsByPgCodeArgs.pg_code", &f_3)?;
    verify_required_field_exists("ShopServiceGetCoinProductsByPgCodeArgs.country", &f_4)?;
    verify_required_field_exists("ShopServiceGetCoinProductsByPgCodeArgs.language", &f_5)?;
    let ret = ShopServiceGetCoinProductsByPgCodeArgs {
      app_store_code: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pg_code: f_3.expect("auto-generated code should have checked for presence of required fields"),
      country: f_4.expect("auto-generated code should have checked for presence of required fields"),
      language: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCoinProductsByPgCode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 2))?;
    self.app_store_code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pgCode", TType::I32, 3))?;
    self.pg_code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 4))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 5))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetCoinProductsByPgCodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinProductsByPgCodeResult {
  result_value: Option<Vec<CoinProductItem>>,
  e: Option<TalkException>,
}

impl ShopServiceGetCoinProductsByPgCodeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinProductsByPgCodeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<CoinProductItem>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CoinProductItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_112 = CoinProductItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_112);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetCoinProductsByPgCodeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetCoinProductsByPgCodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<CoinProductItem>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetCoinProductsByPgCode"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetCoinPurchaseHistoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinPurchaseHistoryArgs {
  request: CoinHistoryCondition,
}

impl ShopServiceGetCoinPurchaseHistoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinPurchaseHistoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CoinHistoryCondition> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CoinHistoryCondition::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetCoinPurchaseHistoryArgs.request", &f_2)?;
    let ret = ShopServiceGetCoinPurchaseHistoryArgs {
      request: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCoinPurchaseHistory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 2))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetCoinPurchaseHistoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinPurchaseHistoryResult {
  result_value: Option<CoinHistoryResult>,
  e: Option<TalkException>,
}

impl ShopServiceGetCoinPurchaseHistoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinPurchaseHistoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CoinHistoryResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CoinHistoryResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetCoinPurchaseHistoryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetCoinPurchaseHistoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CoinHistoryResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetCoinPurchaseHistory"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetCoinUseAndRefundHistoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinUseAndRefundHistoryArgs {
  request: CoinHistoryCondition,
}

impl ShopServiceGetCoinUseAndRefundHistoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinUseAndRefundHistoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CoinHistoryCondition> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CoinHistoryCondition::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetCoinUseAndRefundHistoryArgs.request", &f_2)?;
    let ret = ShopServiceGetCoinUseAndRefundHistoryArgs {
      request: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCoinUseAndRefundHistory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 2))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetCoinUseAndRefundHistoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetCoinUseAndRefundHistoryResult {
  result_value: Option<CoinHistoryResult>,
  e: Option<TalkException>,
}

impl ShopServiceGetCoinUseAndRefundHistoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetCoinUseAndRefundHistoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CoinHistoryResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CoinHistoryResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetCoinUseAndRefundHistoryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetCoinUseAndRefundHistoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CoinHistoryResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetCoinUseAndRefundHistory"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetDownloadsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetDownloadsArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetDownloadsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetDownloadsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetDownloadsArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetDownloadsArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetDownloadsArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetDownloadsArgs.country", &f_5)?;
    let ret = ShopServiceGetDownloadsArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getDownloads_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetDownloadsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetDownloadsResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetDownloadsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetDownloadsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetDownloadsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetDownloadsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetDownloads"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetEventPackagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetEventPackagesArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetEventPackagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetEventPackagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetEventPackagesArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetEventPackagesArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetEventPackagesArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetEventPackagesArgs.country", &f_5)?;
    let ret = ShopServiceGetEventPackagesArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getEventPackages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetEventPackagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetEventPackagesResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetEventPackagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetEventPackagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetEventPackagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetEventPackagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetEventPackages"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetNewlyReleasedPackagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetNewlyReleasedPackagesArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetNewlyReleasedPackagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetNewlyReleasedPackagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetNewlyReleasedPackagesArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetNewlyReleasedPackagesArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetNewlyReleasedPackagesArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetNewlyReleasedPackagesArgs.country", &f_5)?;
    let ret = ShopServiceGetNewlyReleasedPackagesArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNewlyReleasedPackages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetNewlyReleasedPackagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetNewlyReleasedPackagesResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetNewlyReleasedPackagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetNewlyReleasedPackagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetNewlyReleasedPackagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetNewlyReleasedPackagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetNewlyReleasedPackages"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetPopularPackagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPopularPackagesArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetPopularPackagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPopularPackagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetPopularPackagesArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetPopularPackagesArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetPopularPackagesArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetPopularPackagesArgs.country", &f_5)?;
    let ret = ShopServiceGetPopularPackagesArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPopularPackages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetPopularPackagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPopularPackagesResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetPopularPackagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPopularPackagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetPopularPackagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetPopularPackagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetPopularPackages"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetPresentsReceivedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPresentsReceivedArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetPresentsReceivedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPresentsReceivedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetPresentsReceivedArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetPresentsReceivedArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetPresentsReceivedArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetPresentsReceivedArgs.country", &f_5)?;
    let ret = ShopServiceGetPresentsReceivedArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPresentsReceived_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetPresentsReceivedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPresentsReceivedResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetPresentsReceivedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPresentsReceivedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetPresentsReceivedResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetPresentsReceivedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetPresentsReceived"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetPresentsSentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPresentsSentArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetPresentsSentArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPresentsSentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetPresentsSentArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetPresentsSentArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetPresentsSentArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetPresentsSentArgs.country", &f_5)?;
    let ret = ShopServiceGetPresentsSentArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPresentsSent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetPresentsSentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPresentsSentResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetPresentsSentResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPresentsSentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetPresentsSentResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetPresentsSentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetPresentsSent"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetProductArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductArgs {
  package_i_d: i64,
  language: String,
  country: String,
}

impl ShopServiceGetProductArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetProductArgs.package_i_d", &f_2)?;
    verify_required_field_exists("ShopServiceGetProductArgs.language", &f_3)?;
    verify_required_field_exists("ShopServiceGetProductArgs.country", &f_4)?;
    let ret = ShopServiceGetProductArgs {
      package_i_d: f_2.expect("auto-generated code should have checked for presence of required fields"),
      language: f_3.expect("auto-generated code should have checked for presence of required fields"),
      country: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProduct_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("packageID", TType::I64, 2))?;
    o_prot.write_i64(self.package_i_d)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 3))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 4))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetProductResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductResult {
  result_value: Option<Product>,
  e: Option<TalkException>,
}

impl ShopServiceGetProductResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Product> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Product::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetProductResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetProductResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Product> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetProduct"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetProductListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductListArgs {
  product_id_list: Vec<String>,
  language: String,
  country: String,
}

impl ShopServiceGetProductListArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_113 = i_prot.read_string()?;
            val.push(list_elem_113);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetProductListArgs.product_id_list", &f_2)?;
    verify_required_field_exists("ShopServiceGetProductListArgs.language", &f_3)?;
    verify_required_field_exists("ShopServiceGetProductListArgs.country", &f_4)?;
    let ret = ShopServiceGetProductListArgs {
      product_id_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
      language: f_3.expect("auto-generated code should have checked for presence of required fields"),
      country: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProductList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productIdList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.product_id_list.len() as i32))?;
    for e in &self.product_id_list {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 3))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 4))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetProductListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductListResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetProductListResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetProductListResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetProductListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetProductList"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetProductListWithCarrierArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductListWithCarrierArgs {
  product_id_list: Vec<String>,
  language: String,
  country: String,
  carrier_code: String,
}

impl ShopServiceGetProductListWithCarrierArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductListWithCarrierArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_114 = i_prot.read_string()?;
            val.push(list_elem_114);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetProductListWithCarrierArgs.product_id_list", &f_2)?;
    verify_required_field_exists("ShopServiceGetProductListWithCarrierArgs.language", &f_3)?;
    verify_required_field_exists("ShopServiceGetProductListWithCarrierArgs.country", &f_4)?;
    verify_required_field_exists("ShopServiceGetProductListWithCarrierArgs.carrier_code", &f_5)?;
    let ret = ShopServiceGetProductListWithCarrierArgs {
      product_id_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
      language: f_3.expect("auto-generated code should have checked for presence of required fields"),
      country: f_4.expect("auto-generated code should have checked for presence of required fields"),
      carrier_code: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProductListWithCarrier_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productIdList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.product_id_list.len() as i32))?;
    for e in &self.product_id_list {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 3))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 4))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("carrierCode", TType::String, 5))?;
    o_prot.write_string(&self.carrier_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetProductListWithCarrierResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductListWithCarrierResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetProductListWithCarrierResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductListWithCarrierResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetProductListWithCarrierResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetProductListWithCarrierResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetProductListWithCarrier"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetProductWithCarrierArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductWithCarrierArgs {
  package_i_d: i64,
  language: String,
  country: String,
  carrier_code: String,
}

impl ShopServiceGetProductWithCarrierArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductWithCarrierArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetProductWithCarrierArgs.package_i_d", &f_2)?;
    verify_required_field_exists("ShopServiceGetProductWithCarrierArgs.language", &f_3)?;
    verify_required_field_exists("ShopServiceGetProductWithCarrierArgs.country", &f_4)?;
    verify_required_field_exists("ShopServiceGetProductWithCarrierArgs.carrier_code", &f_5)?;
    let ret = ShopServiceGetProductWithCarrierArgs {
      package_i_d: f_2.expect("auto-generated code should have checked for presence of required fields"),
      language: f_3.expect("auto-generated code should have checked for presence of required fields"),
      country: f_4.expect("auto-generated code should have checked for presence of required fields"),
      carrier_code: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProductWithCarrier_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("packageID", TType::I64, 2))?;
    o_prot.write_i64(self.package_i_d)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 3))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 4))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("carrierCode", TType::String, 5))?;
    o_prot.write_string(&self.carrier_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetProductWithCarrierResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetProductWithCarrierResult {
  result_value: Option<Product>,
  e: Option<TalkException>,
}

impl ShopServiceGetProductWithCarrierResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetProductWithCarrierResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Product> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Product::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetProductWithCarrierResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetProductWithCarrierResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Product> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetProductWithCarrier"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetPurchaseHistoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPurchaseHistoryArgs {
  start: i64,
  size: i32,
  language: String,
  country: String,
}

impl ShopServiceGetPurchaseHistoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPurchaseHistoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetPurchaseHistoryArgs.start", &f_2)?;
    verify_required_field_exists("ShopServiceGetPurchaseHistoryArgs.size", &f_3)?;
    verify_required_field_exists("ShopServiceGetPurchaseHistoryArgs.language", &f_4)?;
    verify_required_field_exists("ShopServiceGetPurchaseHistoryArgs.country", &f_5)?;
    let ret = ShopServiceGetPurchaseHistoryArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      language: f_4.expect("auto-generated code should have checked for presence of required fields"),
      country: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPurchaseHistory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 2))?;
    o_prot.write_i64(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 3))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 4))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("country", TType::String, 5))?;
    o_prot.write_string(&self.country)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetPurchaseHistoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetPurchaseHistoryResult {
  result_value: Option<ProductList>,
  e: Option<TalkException>,
}

impl ShopServiceGetPurchaseHistoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetPurchaseHistoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProductList> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProductList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetPurchaseHistoryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetPurchaseHistoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProductList> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetPurchaseHistory"
          )
        )
      )
    }
  }
}

//
// ShopServiceGetTotalBalanceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetTotalBalanceArgs {
  app_store_code: PaymentType,
}

impl ShopServiceGetTotalBalanceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetTotalBalanceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<PaymentType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = PaymentType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceGetTotalBalanceArgs.app_store_code", &f_2)?;
    let ret = ShopServiceGetTotalBalanceArgs {
      app_store_code: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getTotalBalance_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("appStoreCode", TType::I32, 2))?;
    self.app_store_code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceGetTotalBalanceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceGetTotalBalanceResult {
  result_value: Option<Coin>,
  e: Option<TalkException>,
}

impl ShopServiceGetTotalBalanceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceGetTotalBalanceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Coin> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Coin::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceGetTotalBalanceResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceGetTotalBalanceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Coin> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceGetTotalBalance"
          )
        )
      )
    }
  }
}

//
// ShopServiceNotifyDownloadedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceNotifyDownloadedArgs {
  package_id: i64,
  language: String,
}

impl ShopServiceNotifyDownloadedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceNotifyDownloadedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceNotifyDownloadedArgs.package_id", &f_2)?;
    verify_required_field_exists("ShopServiceNotifyDownloadedArgs.language", &f_3)?;
    let ret = ShopServiceNotifyDownloadedArgs {
      package_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      language: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyDownloaded_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("packageId", TType::I64, 2))?;
    o_prot.write_i64(self.package_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("language", TType::String, 3))?;
    o_prot.write_string(&self.language)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceNotifyDownloadedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceNotifyDownloadedResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl ShopServiceNotifyDownloadedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceNotifyDownloadedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceNotifyDownloadedResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceNotifyDownloadedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceNotifyDownloaded"
          )
        )
      )
    }
  }
}

//
// ShopServiceReserveCoinPurchaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceReserveCoinPurchaseArgs {
  request: CoinPurchaseReservation,
}

impl ShopServiceReserveCoinPurchaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceReserveCoinPurchaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CoinPurchaseReservation> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CoinPurchaseReservation::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceReserveCoinPurchaseArgs.request", &f_2)?;
    let ret = ShopServiceReserveCoinPurchaseArgs {
      request: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reserveCoinPurchase_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 2))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceReserveCoinPurchaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceReserveCoinPurchaseResult {
  result_value: Option<PaymentReservationResult>,
  e: Option<TalkException>,
}

impl ShopServiceReserveCoinPurchaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceReserveCoinPurchaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PaymentReservationResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PaymentReservationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceReserveCoinPurchaseResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceReserveCoinPurchaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PaymentReservationResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceReserveCoinPurchase"
          )
        )
      )
    }
  }
}

//
// ShopServiceReservePaymentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceReservePaymentArgs {
  payment_reservation: PaymentReservation,
}

impl ShopServiceReservePaymentArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceReservePaymentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<PaymentReservation> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = PaymentReservation::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShopServiceReservePaymentArgs.payment_reservation", &f_2)?;
    let ret = ShopServiceReservePaymentArgs {
      payment_reservation: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reservePayment_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paymentReservation", TType::Struct, 2))?;
    self.payment_reservation.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShopServiceReservePaymentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ShopServiceReservePaymentResult {
  result_value: Option<PaymentReservationResult>,
  e: Option<TalkException>,
}

impl ShopServiceReservePaymentResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShopServiceReservePaymentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PaymentReservationResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PaymentReservationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShopServiceReservePaymentResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShopServiceReservePaymentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PaymentReservationResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ShopServiceReservePayment"
          )
        )
      )
    }
  }
}

//
// SnsAdaptorService service client
//

pub trait TSnsAdaptorServiceSyncClient {
  fn get_sns_friends(&mut self, sns_id_type: SnsIdType, sns_access_token: String, start_idx: i32, limit: i32) -> thrift::Result<SnsFriends>;
  fn get_sns_my_profile(&mut self, sns_id_type: SnsIdType, sns_access_token: String) -> thrift::Result<SnsProfile>;
  fn post_sns_invitation_message(&mut self, sns_id_type: SnsIdType, sns_access_token: String, to_sns_user_id: String) -> thrift::Result<()>;
}

pub trait TSnsAdaptorServiceSyncClientMarker {}

pub struct SnsAdaptorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> SnsAdaptorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> SnsAdaptorServiceSyncClient<IP, OP> {
    SnsAdaptorServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for SnsAdaptorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TSnsAdaptorServiceSyncClientMarker for SnsAdaptorServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TSnsAdaptorServiceSyncClientMarker> TSnsAdaptorServiceSyncClient for C {
  fn get_sns_friends(&mut self, sns_id_type: SnsIdType, sns_access_token: String, start_idx: i32, limit: i32) -> thrift::Result<SnsFriends> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSnsFriends", TMessageType::Call, self.sequence_number());
        let call_args = SnsAdaptorServiceGetSnsFriendsArgs { sns_id_type: sns_id_type, sns_access_token: sns_access_token, start_idx: start_idx, limit: limit };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSnsFriends", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SnsAdaptorServiceGetSnsFriendsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_sns_my_profile(&mut self, sns_id_type: SnsIdType, sns_access_token: String) -> thrift::Result<SnsProfile> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSnsMyProfile", TMessageType::Call, self.sequence_number());
        let call_args = SnsAdaptorServiceGetSnsMyProfileArgs { sns_id_type: sns_id_type, sns_access_token: sns_access_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSnsMyProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SnsAdaptorServiceGetSnsMyProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn post_sns_invitation_message(&mut self, sns_id_type: SnsIdType, sns_access_token: String, to_sns_user_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("postSnsInvitationMessage", TMessageType::Call, self.sequence_number());
        let call_args = SnsAdaptorServicePostSnsInvitationMessageArgs { sns_id_type: sns_id_type, sns_access_token: sns_access_token, to_sns_user_id: to_sns_user_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("postSnsInvitationMessage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SnsAdaptorServicePostSnsInvitationMessageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// SnsAdaptorService service processor
//

pub trait SnsAdaptorServiceSyncHandler {
  fn handle_get_sns_friends(&self, sns_id_type: SnsIdType, sns_access_token: String, start_idx: i32, limit: i32) -> thrift::Result<SnsFriends>;
  fn handle_get_sns_my_profile(&self, sns_id_type: SnsIdType, sns_access_token: String) -> thrift::Result<SnsProfile>;
  fn handle_post_sns_invitation_message(&self, sns_id_type: SnsIdType, sns_access_token: String, to_sns_user_id: String) -> thrift::Result<()>;
}

pub struct SnsAdaptorServiceSyncProcessor<H: SnsAdaptorServiceSyncHandler> {
  handler: H,
}

impl <H: SnsAdaptorServiceSyncHandler> SnsAdaptorServiceSyncProcessor<H> {
  pub fn new(handler: H) -> SnsAdaptorServiceSyncProcessor<H> {
    SnsAdaptorServiceSyncProcessor {
      handler,
    }
  }
  fn process_get_sns_friends(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TSnsAdaptorServiceProcessFunctions::process_get_sns_friends(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_sns_my_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TSnsAdaptorServiceProcessFunctions::process_get_sns_my_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_post_sns_invitation_message(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TSnsAdaptorServiceProcessFunctions::process_post_sns_invitation_message(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TSnsAdaptorServiceProcessFunctions;

impl TSnsAdaptorServiceProcessFunctions {
  pub fn process_get_sns_friends<H: SnsAdaptorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = SnsAdaptorServiceGetSnsFriendsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_sns_friends(args.sns_id_type, args.sns_access_token, args.start_idx, args.limit) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSnsFriends", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SnsAdaptorServiceGetSnsFriendsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = SnsAdaptorServiceGetSnsFriendsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSnsFriends", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSnsFriends", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSnsFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSnsFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_sns_my_profile<H: SnsAdaptorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = SnsAdaptorServiceGetSnsMyProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_sns_my_profile(args.sns_id_type, args.sns_access_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSnsMyProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SnsAdaptorServiceGetSnsMyProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = SnsAdaptorServiceGetSnsMyProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSnsMyProfile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSnsMyProfile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSnsMyProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSnsMyProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_post_sns_invitation_message<H: SnsAdaptorServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = SnsAdaptorServicePostSnsInvitationMessageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_post_sns_invitation_message(args.sns_id_type, args.sns_access_token, args.to_sns_user_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("postSnsInvitationMessage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SnsAdaptorServicePostSnsInvitationMessageResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = SnsAdaptorServicePostSnsInvitationMessageResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("postSnsInvitationMessage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("postSnsInvitationMessage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("postSnsInvitationMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("postSnsInvitationMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: SnsAdaptorServiceSyncHandler> TProcessor for SnsAdaptorServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "getSnsFriends" => {
        self.process_get_sns_friends(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSnsMyProfile" => {
        self.process_get_sns_my_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "postSnsInvitationMessage" => {
        self.process_post_sns_invitation_message(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// SnsAdaptorServiceGetSnsFriendsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SnsAdaptorServiceGetSnsFriendsArgs {
  sns_id_type: SnsIdType,
  sns_access_token: String,
  start_idx: i32,
  limit: i32,
}

impl SnsAdaptorServiceGetSnsFriendsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsAdaptorServiceGetSnsFriendsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SnsAdaptorServiceGetSnsFriendsArgs.sns_id_type", &f_2)?;
    verify_required_field_exists("SnsAdaptorServiceGetSnsFriendsArgs.sns_access_token", &f_3)?;
    verify_required_field_exists("SnsAdaptorServiceGetSnsFriendsArgs.start_idx", &f_4)?;
    verify_required_field_exists("SnsAdaptorServiceGetSnsFriendsArgs.limit", &f_5)?;
    let ret = SnsAdaptorServiceGetSnsFriendsArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sns_access_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
      start_idx: f_4.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSnsFriends_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsAccessToken", TType::String, 3))?;
    o_prot.write_string(&self.sns_access_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startIdx", TType::I32, 4))?;
    o_prot.write_i32(self.start_idx)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 5))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SnsAdaptorServiceGetSnsFriendsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SnsAdaptorServiceGetSnsFriendsResult {
  result_value: Option<SnsFriends>,
  e: Option<TalkException>,
}

impl SnsAdaptorServiceGetSnsFriendsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsAdaptorServiceGetSnsFriendsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SnsFriends> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SnsFriends::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsAdaptorServiceGetSnsFriendsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsAdaptorServiceGetSnsFriendsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SnsFriends> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SnsAdaptorServiceGetSnsFriends"
          )
        )
      )
    }
  }
}

//
// SnsAdaptorServiceGetSnsMyProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SnsAdaptorServiceGetSnsMyProfileArgs {
  sns_id_type: SnsIdType,
  sns_access_token: String,
}

impl SnsAdaptorServiceGetSnsMyProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsAdaptorServiceGetSnsMyProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SnsAdaptorServiceGetSnsMyProfileArgs.sns_id_type", &f_2)?;
    verify_required_field_exists("SnsAdaptorServiceGetSnsMyProfileArgs.sns_access_token", &f_3)?;
    let ret = SnsAdaptorServiceGetSnsMyProfileArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sns_access_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSnsMyProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsAccessToken", TType::String, 3))?;
    o_prot.write_string(&self.sns_access_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SnsAdaptorServiceGetSnsMyProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SnsAdaptorServiceGetSnsMyProfileResult {
  result_value: Option<SnsProfile>,
  e: Option<TalkException>,
}

impl SnsAdaptorServiceGetSnsMyProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsAdaptorServiceGetSnsMyProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SnsProfile> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SnsProfile::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsAdaptorServiceGetSnsMyProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsAdaptorServiceGetSnsMyProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SnsProfile> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SnsAdaptorServiceGetSnsMyProfile"
          )
        )
      )
    }
  }
}

//
// SnsAdaptorServicePostSnsInvitationMessageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SnsAdaptorServicePostSnsInvitationMessageArgs {
  sns_id_type: SnsIdType,
  sns_access_token: String,
  to_sns_user_id: String,
}

impl SnsAdaptorServicePostSnsInvitationMessageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsAdaptorServicePostSnsInvitationMessageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SnsAdaptorServicePostSnsInvitationMessageArgs.sns_id_type", &f_2)?;
    verify_required_field_exists("SnsAdaptorServicePostSnsInvitationMessageArgs.sns_access_token", &f_3)?;
    verify_required_field_exists("SnsAdaptorServicePostSnsInvitationMessageArgs.to_sns_user_id", &f_4)?;
    let ret = SnsAdaptorServicePostSnsInvitationMessageArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sns_access_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
      to_sns_user_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("postSnsInvitationMessage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsAccessToken", TType::String, 3))?;
    o_prot.write_string(&self.sns_access_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toSnsUserId", TType::String, 4))?;
    o_prot.write_string(&self.to_sns_user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SnsAdaptorServicePostSnsInvitationMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SnsAdaptorServicePostSnsInvitationMessageResult {
  e: Option<TalkException>,
}

impl SnsAdaptorServicePostSnsInvitationMessageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnsAdaptorServicePostSnsInvitationMessageResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SnsAdaptorServicePostSnsInvitationMessageResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnsAdaptorServicePostSnsInvitationMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkService service client
//

pub trait TTalkServiceSyncClient {
  fn accept_group_invitation(&mut self, req_seq: i32, group_id: String) -> thrift::Result<()>;
  fn accept_proximity_matches(&mut self, session_id: String, ids: BTreeSet<String>) -> thrift::Result<()>;
  fn acquire_call_route(&mut self, to: String) -> thrift::Result<Vec<String>>;
  fn acquire_call_ticket(&mut self, to: String) -> thrift::Result<String>;
  fn acquire_encrypted_access_token(&mut self, feature_type: FeatureType) -> thrift::Result<String>;
  fn add_sns_id(&mut self, sns_id_type: SnsIdType, sns_access_token: String) -> thrift::Result<String>;
  fn block_contact(&mut self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn block_recommendation(&mut self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn cancel_group_invitation(&mut self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn change_verification_method(&mut self, session_id: String, method: VerificationMethod) -> thrift::Result<VerificationSessionData>;
  fn clear_identity_credential(&mut self) -> thrift::Result<()>;
  fn clear_message_box(&mut self, channel_id: String, message_box_id: String) -> thrift::Result<()>;
  fn close_proximity_match(&mut self, session_id: String) -> thrift::Result<()>;
  fn commit_send_message(&mut self, seq: i32, message_id: String, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn commit_send_messages(&mut self, seq: i32, message_ids: Vec<String>, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn commit_update_profile(&mut self, seq: i32, attrs: Vec<ProfileAttribute>, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn confirm_email(&mut self, verifier: String, pin_code: String) -> thrift::Result<()>;
  fn create_group(&mut self, seq: i32, name: String, contact_ids: Vec<String>) -> thrift::Result<Group>;
  fn create_qrcode_base64_image(&mut self, url: String, character_set: String, image_size: i32, x: i32, y: i32, width: i32, height: i32) -> thrift::Result<String>;
  fn create_room(&mut self, req_seq: i32, contact_ids: Vec<String>) -> thrift::Result<Room>;
  fn create_session(&mut self) -> thrift::Result<String>;
  fn fetch_announcements(&mut self, last_fetched_index: i32) -> thrift::Result<Vec<Announcement>>;
  fn fetch_messages(&mut self, local_ts: i64, count: i32) -> thrift::Result<Vec<Message>>;
  fn fetch_operations(&mut self, local_rev: i64, count: i32) -> thrift::Result<Vec<Operation>>;
  fn fetch_ops(&mut self, local_rev: i64, count: i32, global_rev: i64, individual_rev: i64) -> thrift::Result<Vec<Operation>>;
  fn find_and_add_contacts_by_email(&mut self, req_seq: i32, emails: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn find_and_add_contacts_by_mid(&mut self, req_seq: i32, mid: String) -> thrift::Result<BTreeMap<String, Contact>>;
  fn find_and_add_contacts_by_phone(&mut self, req_seq: i32, phones: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn find_and_add_contacts_by_userid(&mut self, req_seq: i32, userid: String) -> thrift::Result<BTreeMap<String, Contact>>;
  fn find_contact_by_userid(&mut self, userid: String) -> thrift::Result<Contact>;
  fn find_contact_by_user_ticket(&mut self, ticket_id: String) -> thrift::Result<Contact>;
  fn find_contacts_by_email(&mut self, emails: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn find_contacts_by_phone(&mut self, phones: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn find_sns_id_user_status(&mut self, sns_id_type: SnsIdType, sns_access_token: String, udid_hash: String) -> thrift::Result<SnsIdUserStatus>;
  fn finish_update_verification(&mut self, session_id: String) -> thrift::Result<()>;
  fn generate_user_ticket(&mut self, expiration_time: i64, max_use_count: i32) -> thrift::Result<Ticket>;
  fn get_accepted_proximity_matches(&mut self, session_id: String) -> thrift::Result<BTreeSet<String>>;
  fn get_active_buddy_subscriber_ids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_all_contact_ids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_auth_qrcode(&mut self, keep_logged_in: bool, system_name: String) -> thrift::Result<AuthQrcode>;
  fn get_blocked_contact_ids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_blocked_contact_ids_by_range(&mut self, start: i32, count: i32) -> thrift::Result<Vec<String>>;
  fn get_blocked_recommendation_ids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_buddy_blocker_ids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_buddy_location(&mut self, mid: String, index: i32) -> thrift::Result<Geolocation>;
  fn get_compact_contacts_modified_since(&mut self, timestamp: i64) -> thrift::Result<Vec<CompactContact>>;
  fn get_compact_group(&mut self, group_id: String) -> thrift::Result<Group>;
  fn get_compact_room(&mut self, room_id: String) -> thrift::Result<Room>;
  fn get_contact(&mut self, id: String) -> thrift::Result<Contact>;
  fn get_contacts(&mut self, ids: Vec<String>) -> thrift::Result<Vec<Contact>>;
  fn get_country_with_request_ip(&mut self) -> thrift::Result<String>;
  fn get_favorite_mids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_group(&mut self, group_id: String) -> thrift::Result<Group>;
  fn get_group_ids_invited(&mut self) -> thrift::Result<Vec<String>>;
  fn get_group_ids_joined(&mut self) -> thrift::Result<Vec<String>>;
  fn get_groups(&mut self, group_ids: Vec<String>) -> thrift::Result<Vec<Group>>;
  fn get_hidden_contact_mids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_identity_identifier(&mut self) -> thrift::Result<String>;
  fn get_last_announcement_index(&mut self) -> thrift::Result<i32>;
  fn get_last_op_revision(&mut self) -> thrift::Result<i64>;
  fn get_message_box(&mut self, channel_id: String, message_box_id: String, last_messages_count: i32) -> thrift::Result<TMessageBox>;
  fn get_message_box_compact_wrap_up(&mut self, mid: String) -> thrift::Result<TMessageBoxWrapUp>;
  fn get_message_box_compact_wrap_up_list(&mut self, start: i32, message_box_count: i32) -> thrift::Result<TMessageBoxWrapUpResponse>;
  fn get_message_box_list(&mut self, channel_id: String, last_messages_count: i32) -> thrift::Result<Vec<TMessageBox>>;
  fn get_message_box_list_by_status(&mut self, channel_id: String, last_messages_count: i32, status: i32) -> thrift::Result<Vec<TMessageBox>>;
  fn get_message_box_wrap_up(&mut self, mid: String) -> thrift::Result<TMessageBoxWrapUp>;
  fn get_message_box_wrap_up_list(&mut self, start: i32, message_box_count: i32) -> thrift::Result<TMessageBoxWrapUpResponse>;
  fn get_messages_by_sequence_number(&mut self, channel_id: String, message_box_id: String, start_seq: i64, end_seq: i64) -> thrift::Result<Vec<Message>>;
  fn get_next_messages(&mut self, message_box_id: String, start_seq: i64, messages_count: i32) -> thrift::Result<Vec<Message>>;
  fn get_notification_policy(&mut self, carrier: CarrierCode) -> thrift::Result<Vec<NotificationType>>;
  fn get_previous_messages(&mut self, message_box_id: String, end_seq: i64, messages_count: i32) -> thrift::Result<Vec<Message>>;
  fn get_profile(&mut self) -> thrift::Result<Profile>;
  fn get_proximity_match_candidate_list(&mut self, session_id: String) -> thrift::Result<ProximityMatchCandidateResult>;
  fn get_proximity_match_candidates(&mut self, session_id: String) -> thrift::Result<BTreeSet<Contact>>;
  fn get_recent_messages(&mut self, message_box_id: String, messages_count: i32) -> thrift::Result<Vec<Message>>;
  fn get_recommendation_ids(&mut self) -> thrift::Result<Vec<String>>;
  fn get_room(&mut self, room_id: String) -> thrift::Result<Room>;
  fn get_r_s_a_key_info(&mut self, provider: IdentityProvider) -> thrift::Result<RSAKey>;
  fn get_server_time(&mut self) -> thrift::Result<i64>;
  fn get_sessions(&mut self) -> thrift::Result<Vec<LoginSession>>;
  fn get_settings(&mut self) -> thrift::Result<Settings>;
  fn get_settings_attributes(&mut self, attr_bitset: i32) -> thrift::Result<Settings>;
  fn get_system_configuration(&mut self) -> thrift::Result<SystemConfiguration>;
  fn get_user_ticket(&mut self) -> thrift::Result<Ticket>;
  fn get_wap_invitation(&mut self, invitation_hash: String) -> thrift::Result<WapInvitation>;
  fn invalidate_user_ticket(&mut self) -> thrift::Result<()>;
  fn invite_friends_by_sms(&mut self, phone_number_list: Vec<String>) -> thrift::Result<()>;
  fn invite_into_group(&mut self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn invite_into_room(&mut self, req_seq: i32, room_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn invite_via_email(&mut self, req_seq: i32, email: String, name: String) -> thrift::Result<()>;
  fn is_identity_identifier_available(&mut self, identifier: String, provider: IdentityProvider) -> thrift::Result<bool>;
  fn is_userid_available(&mut self, userid: String) -> thrift::Result<bool>;
  fn kickout_from_group(&mut self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn leave_group(&mut self, req_seq: i32, group_id: String) -> thrift::Result<()>;
  fn leave_room(&mut self, req_seq: i32, room_id: String) -> thrift::Result<()>;
  fn login_with_identity_credential(&mut self, identifier: String, password: String, keep_logged_in: bool, access_location: String, system_name: String, identity_provider: IdentityProvider, certificate: String) -> thrift::Result<String>;
  fn login_with_identity_credential_for_certificate(&mut self, identifier: String, password: String, keep_logged_in: bool, access_location: String, system_name: String, identity_provider: IdentityProvider, certificate: String) -> thrift::Result<LoginResult>;
  fn login_with_verifier(&mut self, verifier: String) -> thrift::Result<String>;
  fn login_with_verifier_for_cerificate(&mut self, verifier: String) -> thrift::Result<LoginResult>;
  fn login_with_verifier_for_certificate(&mut self, verifier: String) -> thrift::Result<LoginResult>;
  fn logout(&mut self) -> thrift::Result<()>;
  fn logout_session(&mut self, token_key: String) -> thrift::Result<()>;
  fn noop(&mut self) -> thrift::Result<()>;
  fn notified_redirect(&mut self, param_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn notify_buddy_on_air(&mut self, seq: i32, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn notify_individual_event(&mut self, notification_status: NotificationStatus, receiver_mids: Vec<String>) -> thrift::Result<()>;
  fn notify_installed(&mut self, udid_hash: String, application_type_with_extensions: String) -> thrift::Result<()>;
  fn notify_registration_complete(&mut self, udid_hash: String, application_type_with_extensions: String) -> thrift::Result<()>;
  fn notify_sleep(&mut self, last_rev: i64, badge: i32) -> thrift::Result<()>;
  fn notify_updated(&mut self, last_rev: i64, device_info: DeviceInfo) -> thrift::Result<()>;
  fn open_proximity_match(&mut self, location: Location) -> thrift::Result<String>;
  fn register_buddy_user(&mut self, buddy_id: String, registrar_password: String) -> thrift::Result<String>;
  fn register_buddy_userid(&mut self, seq: i32, userid: String) -> thrift::Result<()>;
  fn register_device(&mut self, session_id: String) -> thrift::Result<String>;
  fn register_device_with_identity_credential(&mut self, session_id: String, identifier: String, verifier: String, provider: IdentityProvider) -> thrift::Result<String>;
  fn register_device_without_phone_number(&mut self, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn register_device_without_phone_number_with_identity_credential(&mut self, region: String, udid_hash: String, device_info: DeviceInfo, provider: IdentityProvider, identifier: String, verifier: String, mid: String) -> thrift::Result<String>;
  fn register_userid(&mut self, req_seq: i32, userid: String) -> thrift::Result<bool>;
  fn register_wap_device(&mut self, invitation_hash: String, guid_hash: String, email: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn register_with_existing_sns_id_and_identity_credential(&mut self, identity_credential: IdentityCredential, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn register_with_sns_id(&mut self, sns_id_type: SnsIdType, sns_access_token: String, region: String, udid_hash: String, device_info: DeviceInfo, mid: String) -> thrift::Result<RegisterWithSnsIdResult>;
  fn register_with_sns_id_and_identity_credential(&mut self, sns_id_type: SnsIdType, sns_access_token: String, identity_credential: IdentityCredential, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn reissue_device_credential(&mut self) -> thrift::Result<String>;
  fn reissue_user_ticket(&mut self, expiration_time: i64, max_use_count: i32) -> thrift::Result<String>;
  fn reject_group_invitation(&mut self, req_seq: i32, group_id: String) -> thrift::Result<()>;
  fn release_session(&mut self) -> thrift::Result<()>;
  fn remove_all_messages(&mut self, seq: i32, last_message_id: String) -> thrift::Result<()>;
  fn remove_buddy_location(&mut self, mid: String, index: i32) -> thrift::Result<()>;
  fn remove_message(&mut self, message_id: String) -> thrift::Result<bool>;
  fn remove_message_from_my_home(&mut self, message_id: String) -> thrift::Result<bool>;
  fn remove_sns_id(&mut self, sns_id_type: SnsIdType) -> thrift::Result<String>;
  fn report(&mut self, sync_op_revision: i64, category: SyncCategory, report: String) -> thrift::Result<()>;
  fn report_contacts(&mut self, sync_op_revision: i64, category: SyncCategory, contact_reports: Vec<ContactReport>, action_type: SyncActionType) -> thrift::Result<Vec<ContactReportResult>>;
  fn report_groups(&mut self, sync_op_revision: i64, groups: Vec<Group>) -> thrift::Result<()>;
  fn report_profile(&mut self, sync_op_revision: i64, profile: Profile) -> thrift::Result<()>;
  fn report_rooms(&mut self, sync_op_revision: i64, rooms: Vec<Room>) -> thrift::Result<()>;
  fn report_settings(&mut self, sync_op_revision: i64, settings: Settings) -> thrift::Result<()>;
  fn report_spammer(&mut self, spammer_mid: String, spammer_reasons: Vec<SpammerReason>, spam_message_ids: Vec<String>) -> thrift::Result<()>;
  fn request_account_password_reset(&mut self, identifier: String, provider: IdentityProvider, locale: String) -> thrift::Result<()>;
  fn request_email_confirmation(&mut self, email_confirmation: EmailConfirmation) -> thrift::Result<EmailConfirmationSession>;
  fn request_identity_unbind(&mut self, identifier: String, provider: IdentityProvider) -> thrift::Result<()>;
  fn resend_email_confirmation(&mut self, verifier: String) -> thrift::Result<EmailConfirmationSession>;
  fn resend_pin_code(&mut self, session_id: String) -> thrift::Result<()>;
  fn resend_pin_code_by_s_m_s(&mut self, session_id: String) -> thrift::Result<()>;
  fn send_chat_checked(&mut self, seq: i32, consumer: String, last_message_id: String) -> thrift::Result<()>;
  fn send_chat_removed(&mut self, seq: i32, consumer: String, last_message_id: String) -> thrift::Result<()>;
  fn send_content_preview_updated(&mut self, esq: i32, message_id: String, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn send_content_receipt(&mut self, seq: i32, consumer: String, message_id: String) -> thrift::Result<()>;
  fn send_dummy_push(&mut self) -> thrift::Result<()>;
  fn send_event(&mut self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn send_message(&mut self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn send_message_ignored(&mut self, seq: i32, consumer: String, message_ids: Vec<String>) -> thrift::Result<()>;
  fn send_message_receipt(&mut self, seq: i32, consumer: String, message_ids: Vec<String>) -> thrift::Result<()>;
  fn send_message_to_my_home(&mut self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn set_buddy_location(&mut self, mid: String, index: i32, location: Geolocation) -> thrift::Result<()>;
  fn set_identity_credential(&mut self, identifier: String, verifier: String, provider: IdentityProvider) -> thrift::Result<()>;
  fn set_notifications_enabled(&mut self, req_seq: i32, type_: MIDType, target: String, enablement: bool) -> thrift::Result<()>;
  fn start_update_verification(&mut self, region: String, carrier: CarrierCode, phone: String, udid_hash: String, device_info: DeviceInfo, network_code: String, locale: String) -> thrift::Result<VerificationSessionData>;
  fn start_verification(&mut self, region: String, carrier: CarrierCode, phone: String, udid_hash: String, device_info: DeviceInfo, network_code: String, mid: String, locale: String) -> thrift::Result<VerificationSessionData>;
  fn store_update_profile_attribute(&mut self, seq: i32, profile_attribute: ProfileAttribute, value: String) -> thrift::Result<()>;
  fn sync_contact_by_sns_ids(&mut self, req_seq: i32, modifications: Vec<SnsFriendModification>) -> thrift::Result<Vec<SnsFriendContactRegistration>>;
  fn sync_contacts(&mut self, req_seq: i32, local_contacts: Vec<ContactModification>) -> thrift::Result<BTreeMap<String, ContactRegistration>>;
  fn try_send_message(&mut self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn unblock_contact(&mut self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn unblock_recommendation(&mut self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn unregister_user_and_device(&mut self) -> thrift::Result<String>;
  fn update_apns_device_token(&mut self, apns_device_token: Vec<u8>) -> thrift::Result<()>;
  fn update_buddy_setting(&mut self, key: String, value: String) -> thrift::Result<()>;
  fn update_c2_d_m_registration_id(&mut self, registration_id: String) -> thrift::Result<()>;
  fn update_contact_setting(&mut self, req_seq: i32, mid: String, flag: ContactSetting, value: String) -> thrift::Result<()>;
  fn update_custom_mode_settings(&mut self, custom_mode: CustomMode, param_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn update_device_info(&mut self, device_uid: String, device_info: DeviceInfo) -> thrift::Result<()>;
  fn update_group(&mut self, req_seq: i32, group: Group) -> thrift::Result<()>;
  fn update_notification_token(&mut self, token: String, type_: NotificationType) -> thrift::Result<()>;
  fn update_notification_token_with_bytes(&mut self, token: Vec<u8>, type_: NotificationType) -> thrift::Result<()>;
  fn update_profile(&mut self, req_seq: i32, profile: Profile) -> thrift::Result<()>;
  fn update_profile_attribute(&mut self, req_seq: i32, attr: ProfileAttribute, value: String) -> thrift::Result<()>;
  fn update_region(&mut self, region: String) -> thrift::Result<()>;
  fn update_settings(&mut self, req_seq: i32, settings: Settings) -> thrift::Result<()>;
  fn update_settings2(&mut self, req_seq: i32, settings: Settings) -> thrift::Result<i32>;
  fn update_settings_attribute(&mut self, req_seq: i32, attr: SettingsAttribute, value: String) -> thrift::Result<()>;
  fn update_settings_attributes(&mut self, req_seq: i32, attr_bitset: i32, settings: Settings) -> thrift::Result<i32>;
  fn verify_identity_credential(&mut self, identifier: String, password: String, identity_provider: IdentityProvider) -> thrift::Result<()>;
  fn verify_identity_credential_with_result(&mut self, identity_credential: IdentityCredential) -> thrift::Result<UserAuthStatus>;
  fn verify_phone(&mut self, session_id: String, pin_code: String, udid_hash: String) -> thrift::Result<VerificationResult>;
  fn verify_qrcode(&mut self, verifier: String, pin_code: String) -> thrift::Result<String>;
}

pub trait TTalkServiceSyncClientMarker {}

pub struct TalkServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> TalkServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> TalkServiceSyncClient<IP, OP> {
    TalkServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for TalkServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TTalkServiceSyncClientMarker for TalkServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TTalkServiceSyncClientMarker> TTalkServiceSyncClient for C {
  fn accept_group_invitation(&mut self, req_seq: i32, group_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("acceptGroupInvitation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceAcceptGroupInvitationArgs { req_seq: req_seq, group_id: group_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("acceptGroupInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceAcceptGroupInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn accept_proximity_matches(&mut self, session_id: String, ids: BTreeSet<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("acceptProximityMatches", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceAcceptProximityMatchesArgs { session_id: session_id, ids: ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("acceptProximityMatches", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceAcceptProximityMatchesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn acquire_call_route(&mut self, to: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("acquireCallRoute", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceAcquireCallRouteArgs { to: to };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("acquireCallRoute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceAcquireCallRouteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn acquire_call_ticket(&mut self, to: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("acquireCallTicket", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceAcquireCallTicketArgs { to: to };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("acquireCallTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceAcquireCallTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn acquire_encrypted_access_token(&mut self, feature_type: FeatureType) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("acquireEncryptedAccessToken", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceAcquireEncryptedAccessTokenArgs { feature_type: feature_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("acquireEncryptedAccessToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceAcquireEncryptedAccessTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_sns_id(&mut self, sns_id_type: SnsIdType, sns_access_token: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("addSnsId", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceAddSnsIdArgs { sns_id_type: sns_id_type, sns_access_token: sns_access_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("addSnsId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceAddSnsIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn block_contact(&mut self, req_seq: i32, id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("blockContact", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceBlockContactArgs { req_seq: req_seq, id: id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("blockContact", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceBlockContactResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn block_recommendation(&mut self, req_seq: i32, id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("blockRecommendation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceBlockRecommendationArgs { req_seq: req_seq, id: id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("blockRecommendation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceBlockRecommendationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cancel_group_invitation(&mut self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("cancelGroupInvitation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCancelGroupInvitationArgs { req_seq: req_seq, group_id: group_id, contact_ids: contact_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("cancelGroupInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCancelGroupInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn change_verification_method(&mut self, session_id: String, method: VerificationMethod) -> thrift::Result<VerificationSessionData> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("changeVerificationMethod", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceChangeVerificationMethodArgs { session_id: session_id, method: method };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("changeVerificationMethod", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceChangeVerificationMethodResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_identity_credential(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clearIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceClearIdentityCredentialArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clearIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceClearIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_message_box(&mut self, channel_id: String, message_box_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clearMessageBox", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceClearMessageBoxArgs { channel_id: channel_id, message_box_id: message_box_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clearMessageBox", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceClearMessageBoxResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn close_proximity_match(&mut self, session_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("closeProximityMatch", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCloseProximityMatchArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("closeProximityMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCloseProximityMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn commit_send_message(&mut self, seq: i32, message_id: String, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("commitSendMessage", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCommitSendMessageArgs { seq: seq, message_id: message_id, receiver_mids: receiver_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("commitSendMessage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCommitSendMessageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn commit_send_messages(&mut self, seq: i32, message_ids: Vec<String>, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("commitSendMessages", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCommitSendMessagesArgs { seq: seq, message_ids: message_ids, receiver_mids: receiver_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("commitSendMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCommitSendMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn commit_update_profile(&mut self, seq: i32, attrs: Vec<ProfileAttribute>, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("commitUpdateProfile", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCommitUpdateProfileArgs { seq: seq, attrs: attrs, receiver_mids: receiver_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("commitUpdateProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCommitUpdateProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn confirm_email(&mut self, verifier: String, pin_code: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("confirmEmail", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceConfirmEmailArgs { verifier: verifier, pin_code: pin_code };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("confirmEmail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceConfirmEmailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_group(&mut self, seq: i32, name: String, contact_ids: Vec<String>) -> thrift::Result<Group> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createGroup", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCreateGroupArgs { seq: seq, name: name, contact_ids: contact_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCreateGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_qrcode_base64_image(&mut self, url: String, character_set: String, image_size: i32, x: i32, y: i32, width: i32, height: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createQrcodeBase64Image", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCreateQrcodeBase64ImageArgs { url: url, character_set: character_set, image_size: image_size, x: x, y: y, width: width, height: height };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createQrcodeBase64Image", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCreateQrcodeBase64ImageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_room(&mut self, req_seq: i32, contact_ids: Vec<String>) -> thrift::Result<Room> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createRoom", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCreateRoomArgs { req_seq: req_seq, contact_ids: contact_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createRoom", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCreateRoomResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_session(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createSession", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceCreateSessionArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceCreateSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_announcements(&mut self, last_fetched_index: i32) -> thrift::Result<Vec<Announcement>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchAnnouncements", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFetchAnnouncementsArgs { last_fetched_index: last_fetched_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchAnnouncements", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFetchAnnouncementsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_messages(&mut self, local_ts: i64, count: i32) -> thrift::Result<Vec<Message>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchMessages", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFetchMessagesArgs { local_ts: local_ts, count: count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFetchMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_operations(&mut self, local_rev: i64, count: i32) -> thrift::Result<Vec<Operation>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchOperations", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFetchOperationsArgs { local_rev: local_rev, count: count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchOperations", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFetchOperationsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_ops(&mut self, local_rev: i64, count: i32, global_rev: i64, individual_rev: i64) -> thrift::Result<Vec<Operation>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchOps", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFetchOpsArgs { local_rev: local_rev, count: count, global_rev: global_rev, individual_rev: individual_rev };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchOps", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFetchOpsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_and_add_contacts_by_email(&mut self, req_seq: i32, emails: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findAndAddContactsByEmail", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindAndAddContactsByEmailArgs { req_seq: req_seq, emails: emails };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findAndAddContactsByEmail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindAndAddContactsByEmailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_and_add_contacts_by_mid(&mut self, req_seq: i32, mid: String) -> thrift::Result<BTreeMap<String, Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findAndAddContactsByMid", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindAndAddContactsByMidArgs { req_seq: req_seq, mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findAndAddContactsByMid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindAndAddContactsByMidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_and_add_contacts_by_phone(&mut self, req_seq: i32, phones: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findAndAddContactsByPhone", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindAndAddContactsByPhoneArgs { req_seq: req_seq, phones: phones };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findAndAddContactsByPhone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindAndAddContactsByPhoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_and_add_contacts_by_userid(&mut self, req_seq: i32, userid: String) -> thrift::Result<BTreeMap<String, Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findAndAddContactsByUserid", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindAndAddContactsByUseridArgs { req_seq: req_seq, userid: userid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findAndAddContactsByUserid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindAndAddContactsByUseridResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_contact_by_userid(&mut self, userid: String) -> thrift::Result<Contact> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findContactByUserid", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindContactByUseridArgs { userid: userid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findContactByUserid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindContactByUseridResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_contact_by_user_ticket(&mut self, ticket_id: String) -> thrift::Result<Contact> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findContactByUserTicket", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindContactByUserTicketArgs { ticket_id: ticket_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findContactByUserTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindContactByUserTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_contacts_by_email(&mut self, emails: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findContactsByEmail", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindContactsByEmailArgs { emails: emails };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findContactsByEmail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindContactsByEmailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_contacts_by_phone(&mut self, phones: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findContactsByPhone", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindContactsByPhoneArgs { phones: phones };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findContactsByPhone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindContactsByPhoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_sns_id_user_status(&mut self, sns_id_type: SnsIdType, sns_access_token: String, udid_hash: String) -> thrift::Result<SnsIdUserStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findSnsIdUserStatus", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFindSnsIdUserStatusArgs { sns_id_type: sns_id_type, sns_access_token: sns_access_token, udid_hash: udid_hash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findSnsIdUserStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFindSnsIdUserStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn finish_update_verification(&mut self, session_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("finishUpdateVerification", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceFinishUpdateVerificationArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("finishUpdateVerification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceFinishUpdateVerificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn generate_user_ticket(&mut self, expiration_time: i64, max_use_count: i32) -> thrift::Result<Ticket> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("generateUserTicket", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGenerateUserTicketArgs { expiration_time: expiration_time, max_use_count: max_use_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("generateUserTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGenerateUserTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_accepted_proximity_matches(&mut self, session_id: String) -> thrift::Result<BTreeSet<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getAcceptedProximityMatches", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetAcceptedProximityMatchesArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getAcceptedProximityMatches", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetAcceptedProximityMatchesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_active_buddy_subscriber_ids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getActiveBuddySubscriberIds", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetActiveBuddySubscriberIdsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getActiveBuddySubscriberIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetActiveBuddySubscriberIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_contact_ids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getAllContactIds", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetAllContactIdsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getAllContactIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetAllContactIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_auth_qrcode(&mut self, keep_logged_in: bool, system_name: String) -> thrift::Result<AuthQrcode> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getAuthQrcode", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetAuthQrcodeArgs { keep_logged_in: keep_logged_in, system_name: system_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getAuthQrcode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetAuthQrcodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_blocked_contact_ids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBlockedContactIds", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetBlockedContactIdsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBlockedContactIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetBlockedContactIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_blocked_contact_ids_by_range(&mut self, start: i32, count: i32) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBlockedContactIdsByRange", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetBlockedContactIdsByRangeArgs { start: start, count: count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBlockedContactIdsByRange", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetBlockedContactIdsByRangeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_blocked_recommendation_ids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBlockedRecommendationIds", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetBlockedRecommendationIdsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBlockedRecommendationIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetBlockedRecommendationIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_buddy_blocker_ids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBuddyBlockerIds", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetBuddyBlockerIdsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBuddyBlockerIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetBuddyBlockerIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_buddy_location(&mut self, mid: String, index: i32) -> thrift::Result<Geolocation> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBuddyLocation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetBuddyLocationArgs { mid: mid, index: index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBuddyLocation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetBuddyLocationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_compact_contacts_modified_since(&mut self, timestamp: i64) -> thrift::Result<Vec<CompactContact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCompactContactsModifiedSince", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetCompactContactsModifiedSinceArgs { timestamp: timestamp };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCompactContactsModifiedSince", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetCompactContactsModifiedSinceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_compact_group(&mut self, group_id: String) -> thrift::Result<Group> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCompactGroup", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetCompactGroupArgs { group_id: group_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCompactGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetCompactGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_compact_room(&mut self, room_id: String) -> thrift::Result<Room> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCompactRoom", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetCompactRoomArgs { room_id: room_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCompactRoom", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetCompactRoomResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_contact(&mut self, id: String) -> thrift::Result<Contact> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getContact", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetContactArgs { id: id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getContact", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetContactResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_contacts(&mut self, ids: Vec<String>) -> thrift::Result<Vec<Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getContacts", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetContactsArgs { ids: ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getContacts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetContactsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_country_with_request_ip(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCountryWithRequestIp", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetCountryWithRequestIpArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCountryWithRequestIp", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetCountryWithRequestIpResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_favorite_mids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getFavoriteMids", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetFavoriteMidsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getFavoriteMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetFavoriteMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_group(&mut self, group_id: String) -> thrift::Result<Group> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getGroup", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetGroupArgs { group_id: group_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_group_ids_invited(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getGroupIdsInvited", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetGroupIdsInvitedArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getGroupIdsInvited", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetGroupIdsInvitedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_group_ids_joined(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getGroupIdsJoined", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetGroupIdsJoinedArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getGroupIdsJoined", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetGroupIdsJoinedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_groups(&mut self, group_ids: Vec<String>) -> thrift::Result<Vec<Group>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getGroups", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetGroupsArgs { group_ids: group_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getGroups", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetGroupsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_hidden_contact_mids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getHiddenContactMids", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetHiddenContactMidsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getHiddenContactMids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetHiddenContactMidsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_identity_identifier(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getIdentityIdentifier", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetIdentityIdentifierArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getIdentityIdentifier", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetIdentityIdentifierResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_last_announcement_index(&mut self) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getLastAnnouncementIndex", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetLastAnnouncementIndexArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getLastAnnouncementIndex", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetLastAnnouncementIndexResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_last_op_revision(&mut self) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getLastOpRevision", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetLastOpRevisionArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getLastOpRevision", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetLastOpRevisionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_message_box(&mut self, channel_id: String, message_box_id: String, last_messages_count: i32) -> thrift::Result<TMessageBox> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessageBox", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessageBoxArgs { channel_id: channel_id, message_box_id: message_box_id, last_messages_count: last_messages_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessageBox", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessageBoxResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_message_box_compact_wrap_up(&mut self, mid: String) -> thrift::Result<TMessageBoxWrapUp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUp", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessageBoxCompactWrapUpArgs { mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessageBoxCompactWrapUp", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessageBoxCompactWrapUpResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_message_box_compact_wrap_up_list(&mut self, start: i32, message_box_count: i32) -> thrift::Result<TMessageBoxWrapUpResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUpList", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessageBoxCompactWrapUpListArgs { start: start, message_box_count: message_box_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessageBoxCompactWrapUpList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessageBoxCompactWrapUpListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_message_box_list(&mut self, channel_id: String, last_messages_count: i32) -> thrift::Result<Vec<TMessageBox>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessageBoxList", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessageBoxListArgs { channel_id: channel_id, last_messages_count: last_messages_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessageBoxList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessageBoxListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_message_box_list_by_status(&mut self, channel_id: String, last_messages_count: i32, status: i32) -> thrift::Result<Vec<TMessageBox>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessageBoxListByStatus", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessageBoxListByStatusArgs { channel_id: channel_id, last_messages_count: last_messages_count, status: status };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessageBoxListByStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessageBoxListByStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_message_box_wrap_up(&mut self, mid: String) -> thrift::Result<TMessageBoxWrapUp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessageBoxWrapUp", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessageBoxWrapUpArgs { mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessageBoxWrapUp", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessageBoxWrapUpResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_message_box_wrap_up_list(&mut self, start: i32, message_box_count: i32) -> thrift::Result<TMessageBoxWrapUpResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessageBoxWrapUpList", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessageBoxWrapUpListArgs { start: start, message_box_count: message_box_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessageBoxWrapUpList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessageBoxWrapUpListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_messages_by_sequence_number(&mut self, channel_id: String, message_box_id: String, start_seq: i64, end_seq: i64) -> thrift::Result<Vec<Message>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMessagesBySequenceNumber", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetMessagesBySequenceNumberArgs { channel_id: channel_id, message_box_id: message_box_id, start_seq: start_seq, end_seq: end_seq };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMessagesBySequenceNumber", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetMessagesBySequenceNumberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_next_messages(&mut self, message_box_id: String, start_seq: i64, messages_count: i32) -> thrift::Result<Vec<Message>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNextMessages", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetNextMessagesArgs { message_box_id: message_box_id, start_seq: start_seq, messages_count: messages_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNextMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetNextMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_notification_policy(&mut self, carrier: CarrierCode) -> thrift::Result<Vec<NotificationType>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNotificationPolicy", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetNotificationPolicyArgs { carrier: carrier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNotificationPolicy", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetNotificationPolicyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_previous_messages(&mut self, message_box_id: String, end_seq: i64, messages_count: i32) -> thrift::Result<Vec<Message>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPreviousMessages", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetPreviousMessagesArgs { message_box_id: message_box_id, end_seq: end_seq, messages_count: messages_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPreviousMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetPreviousMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_profile(&mut self) -> thrift::Result<Profile> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProfile", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetProfileArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_proximity_match_candidate_list(&mut self, session_id: String) -> thrift::Result<ProximityMatchCandidateResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProximityMatchCandidateList", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetProximityMatchCandidateListArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProximityMatchCandidateList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetProximityMatchCandidateListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_proximity_match_candidates(&mut self, session_id: String) -> thrift::Result<BTreeSet<Contact>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProximityMatchCandidates", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetProximityMatchCandidatesArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProximityMatchCandidates", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetProximityMatchCandidatesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_recent_messages(&mut self, message_box_id: String, messages_count: i32) -> thrift::Result<Vec<Message>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getRecentMessages", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetRecentMessagesArgs { message_box_id: message_box_id, messages_count: messages_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getRecentMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetRecentMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_recommendation_ids(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getRecommendationIds", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetRecommendationIdsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getRecommendationIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetRecommendationIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_room(&mut self, room_id: String) -> thrift::Result<Room> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getRoom", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetRoomArgs { room_id: room_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getRoom", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetRoomResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_r_s_a_key_info(&mut self, provider: IdentityProvider) -> thrift::Result<RSAKey> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getRSAKeyInfo", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetRSAKeyInfoArgs { provider: provider };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getRSAKeyInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetRSAKeyInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_server_time(&mut self) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getServerTime", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetServerTimeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getServerTime", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetServerTimeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_sessions(&mut self) -> thrift::Result<Vec<LoginSession>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSessions", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetSessionsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSessions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetSessionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_settings(&mut self) -> thrift::Result<Settings> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSettings", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetSettingsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_settings_attributes(&mut self, attr_bitset: i32) -> thrift::Result<Settings> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSettingsAttributes", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetSettingsAttributesArgs { attr_bitset: attr_bitset };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSettingsAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetSettingsAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_system_configuration(&mut self) -> thrift::Result<SystemConfiguration> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSystemConfiguration", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetSystemConfigurationArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSystemConfiguration", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetSystemConfigurationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_ticket(&mut self) -> thrift::Result<Ticket> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUserTicket", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetUserTicketArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUserTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetUserTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_wap_invitation(&mut self, invitation_hash: String) -> thrift::Result<WapInvitation> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getWapInvitation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceGetWapInvitationArgs { invitation_hash: invitation_hash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getWapInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceGetWapInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn invalidate_user_ticket(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("invalidateUserTicket", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceInvalidateUserTicketArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("invalidateUserTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceInvalidateUserTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn invite_friends_by_sms(&mut self, phone_number_list: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("inviteFriendsBySms", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceInviteFriendsBySmsArgs { phone_number_list: phone_number_list };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("inviteFriendsBySms", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceInviteFriendsBySmsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn invite_into_group(&mut self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("inviteIntoGroup", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceInviteIntoGroupArgs { req_seq: req_seq, group_id: group_id, contact_ids: contact_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("inviteIntoGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceInviteIntoGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn invite_into_room(&mut self, req_seq: i32, room_id: String, contact_ids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("inviteIntoRoom", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceInviteIntoRoomArgs { req_seq: req_seq, room_id: room_id, contact_ids: contact_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("inviteIntoRoom", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceInviteIntoRoomResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn invite_via_email(&mut self, req_seq: i32, email: String, name: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("inviteViaEmail", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceInviteViaEmailArgs { req_seq: req_seq, email: email, name: name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("inviteViaEmail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceInviteViaEmailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_identity_identifier_available(&mut self, identifier: String, provider: IdentityProvider) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("isIdentityIdentifierAvailable", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceIsIdentityIdentifierAvailableArgs { identifier: identifier, provider: provider };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("isIdentityIdentifierAvailable", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceIsIdentityIdentifierAvailableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_userid_available(&mut self, userid: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("isUseridAvailable", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceIsUseridAvailableArgs { userid: userid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("isUseridAvailable", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceIsUseridAvailableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn kickout_from_group(&mut self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("kickoutFromGroup", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceKickoutFromGroupArgs { req_seq: req_seq, group_id: group_id, contact_ids: contact_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("kickoutFromGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceKickoutFromGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn leave_group(&mut self, req_seq: i32, group_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("leaveGroup", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLeaveGroupArgs { req_seq: req_seq, group_id: group_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("leaveGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLeaveGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn leave_room(&mut self, req_seq: i32, room_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("leaveRoom", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLeaveRoomArgs { req_seq: req_seq, room_id: room_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("leaveRoom", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLeaveRoomResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn login_with_identity_credential(&mut self, identifier: String, password: String, keep_logged_in: bool, access_location: String, system_name: String, identity_provider: IdentityProvider, certificate: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("loginWithIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLoginWithIdentityCredentialArgs { identifier: identifier, password: password, keep_logged_in: keep_logged_in, access_location: access_location, system_name: system_name, identity_provider: identity_provider, certificate: certificate };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("loginWithIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLoginWithIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn login_with_identity_credential_for_certificate(&mut self, identifier: String, password: String, keep_logged_in: bool, access_location: String, system_name: String, identity_provider: IdentityProvider, certificate: String) -> thrift::Result<LoginResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("loginWithIdentityCredentialForCertificate", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLoginWithIdentityCredentialForCertificateArgs { identifier: identifier, password: password, keep_logged_in: keep_logged_in, access_location: access_location, system_name: system_name, identity_provider: identity_provider, certificate: certificate };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("loginWithIdentityCredentialForCertificate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLoginWithIdentityCredentialForCertificateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn login_with_verifier(&mut self, verifier: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("loginWithVerifier", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLoginWithVerifierArgs { verifier: verifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("loginWithVerifier", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLoginWithVerifierResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn login_with_verifier_for_cerificate(&mut self, verifier: String) -> thrift::Result<LoginResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("loginWithVerifierForCerificate", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLoginWithVerifierForCerificateArgs { verifier: verifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("loginWithVerifierForCerificate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLoginWithVerifierForCerificateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn login_with_verifier_for_certificate(&mut self, verifier: String) -> thrift::Result<LoginResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("loginWithVerifierForCertificate", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLoginWithVerifierForCertificateArgs { verifier: verifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("loginWithVerifierForCertificate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLoginWithVerifierForCertificateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn logout(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("logout", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLogoutArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("logout", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLogoutResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn logout_session(&mut self, token_key: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("logoutSession", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceLogoutSessionArgs { token_key: token_key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("logoutSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceLogoutSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn noop(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("noop", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNoopArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("noop", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNoopResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notified_redirect(&mut self, param_map: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifiedRedirect", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNotifiedRedirectArgs { param_map: param_map };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifiedRedirect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNotifiedRedirectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_buddy_on_air(&mut self, seq: i32, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyBuddyOnAir", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNotifyBuddyOnAirArgs { seq: seq, receiver_mids: receiver_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyBuddyOnAir", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNotifyBuddyOnAirResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_individual_event(&mut self, notification_status: NotificationStatus, receiver_mids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyIndividualEvent", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNotifyIndividualEventArgs { notification_status: notification_status, receiver_mids: receiver_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyIndividualEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNotifyIndividualEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_installed(&mut self, udid_hash: String, application_type_with_extensions: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyInstalled", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNotifyInstalledArgs { udid_hash: udid_hash, application_type_with_extensions: application_type_with_extensions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyInstalled", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNotifyInstalledResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_registration_complete(&mut self, udid_hash: String, application_type_with_extensions: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyRegistrationComplete", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNotifyRegistrationCompleteArgs { udid_hash: udid_hash, application_type_with_extensions: application_type_with_extensions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyRegistrationComplete", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNotifyRegistrationCompleteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_sleep(&mut self, last_rev: i64, badge: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifySleep", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNotifySleepArgs { last_rev: last_rev, badge: badge };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifySleep", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNotifySleepResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn notify_updated(&mut self, last_rev: i64, device_info: DeviceInfo) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notifyUpdated", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceNotifyUpdatedArgs { last_rev: last_rev, device_info: device_info };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notifyUpdated", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceNotifyUpdatedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn open_proximity_match(&mut self, location: Location) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("openProximityMatch", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceOpenProximityMatchArgs { location: location };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("openProximityMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceOpenProximityMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_buddy_user(&mut self, buddy_id: String, registrar_password: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerBuddyUser", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterBuddyUserArgs { buddy_id: buddy_id, registrar_password: registrar_password };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerBuddyUser", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterBuddyUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_buddy_userid(&mut self, seq: i32, userid: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerBuddyUserid", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterBuddyUseridArgs { seq: seq, userid: userid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerBuddyUserid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterBuddyUseridResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_device(&mut self, session_id: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerDevice", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterDeviceArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_device_with_identity_credential(&mut self, session_id: String, identifier: String, verifier: String, provider: IdentityProvider) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerDeviceWithIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterDeviceWithIdentityCredentialArgs { session_id: session_id, identifier: identifier, verifier: verifier, provider: provider };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerDeviceWithIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterDeviceWithIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_device_without_phone_number(&mut self, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumber", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterDeviceWithoutPhoneNumberArgs { region: region, udid_hash: udid_hash, device_info: device_info };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerDeviceWithoutPhoneNumber", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterDeviceWithoutPhoneNumberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_device_without_phone_number_with_identity_credential(&mut self, region: String, udid_hash: String, device_info: DeviceInfo, provider: IdentityProvider, identifier: String, verifier: String, mid: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs { region: region, udid_hash: udid_hash, device_info: device_info, provider: provider, identifier: identifier, verifier: verifier, mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerDeviceWithoutPhoneNumberWithIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_userid(&mut self, req_seq: i32, userid: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerUserid", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterUseridArgs { req_seq: req_seq, userid: userid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerUserid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterUseridResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_wap_device(&mut self, invitation_hash: String, guid_hash: String, email: String, device_info: DeviceInfo) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerWapDevice", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterWapDeviceArgs { invitation_hash: invitation_hash, guid_hash: guid_hash, email: email, device_info: device_info };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerWapDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterWapDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_with_existing_sns_id_and_identity_credential(&mut self, identity_credential: IdentityCredential, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerWithExistingSnsIdAndIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs { identity_credential: identity_credential, region: region, udid_hash: udid_hash, device_info: device_info };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerWithExistingSnsIdAndIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_with_sns_id(&mut self, sns_id_type: SnsIdType, sns_access_token: String, region: String, udid_hash: String, device_info: DeviceInfo, mid: String) -> thrift::Result<RegisterWithSnsIdResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerWithSnsId", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterWithSnsIdArgs { sns_id_type: sns_id_type, sns_access_token: sns_access_token, region: region, udid_hash: udid_hash, device_info: device_info, mid: mid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerWithSnsId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterWithSnsIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_with_sns_id_and_identity_credential(&mut self, sns_id_type: SnsIdType, sns_access_token: String, identity_credential: IdentityCredential, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerWithSnsIdAndIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs { sns_id_type: sns_id_type, sns_access_token: sns_access_token, identity_credential: identity_credential, region: region, udid_hash: udid_hash, device_info: device_info };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerWithSnsIdAndIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRegisterWithSnsIdAndIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reissue_device_credential(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reissueDeviceCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReissueDeviceCredentialArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reissueDeviceCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReissueDeviceCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reissue_user_ticket(&mut self, expiration_time: i64, max_use_count: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reissueUserTicket", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReissueUserTicketArgs { expiration_time: expiration_time, max_use_count: max_use_count };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reissueUserTicket", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReissueUserTicketResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reject_group_invitation(&mut self, req_seq: i32, group_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("rejectGroupInvitation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRejectGroupInvitationArgs { req_seq: req_seq, group_id: group_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("rejectGroupInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRejectGroupInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn release_session(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("releaseSession", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReleaseSessionArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("releaseSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReleaseSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_all_messages(&mut self, seq: i32, last_message_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeAllMessages", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRemoveAllMessagesArgs { seq: seq, last_message_id: last_message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeAllMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRemoveAllMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_buddy_location(&mut self, mid: String, index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeBuddyLocation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRemoveBuddyLocationArgs { mid: mid, index: index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeBuddyLocation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRemoveBuddyLocationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_message(&mut self, message_id: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeMessage", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRemoveMessageArgs { message_id: message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeMessage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRemoveMessageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_message_from_my_home(&mut self, message_id: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeMessageFromMyHome", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRemoveMessageFromMyHomeArgs { message_id: message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeMessageFromMyHome", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRemoveMessageFromMyHomeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_sns_id(&mut self, sns_id_type: SnsIdType) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeSnsId", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRemoveSnsIdArgs { sns_id_type: sns_id_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeSnsId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRemoveSnsIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn report(&mut self, sync_op_revision: i64, category: SyncCategory, report: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("report", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReportArgs { sync_op_revision: sync_op_revision, category: category, report: report };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("report", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReportResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn report_contacts(&mut self, sync_op_revision: i64, category: SyncCategory, contact_reports: Vec<ContactReport>, action_type: SyncActionType) -> thrift::Result<Vec<ContactReportResult>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reportContacts", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReportContactsArgs { sync_op_revision: sync_op_revision, category: category, contact_reports: contact_reports, action_type: action_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reportContacts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReportContactsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn report_groups(&mut self, sync_op_revision: i64, groups: Vec<Group>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reportGroups", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReportGroupsArgs { sync_op_revision: sync_op_revision, groups: groups };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reportGroups", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReportGroupsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn report_profile(&mut self, sync_op_revision: i64, profile: Profile) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reportProfile", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReportProfileArgs { sync_op_revision: sync_op_revision, profile: profile };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reportProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReportProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn report_rooms(&mut self, sync_op_revision: i64, rooms: Vec<Room>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reportRooms", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReportRoomsArgs { sync_op_revision: sync_op_revision, rooms: rooms };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reportRooms", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReportRoomsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn report_settings(&mut self, sync_op_revision: i64, settings: Settings) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reportSettings", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReportSettingsArgs { sync_op_revision: sync_op_revision, settings: settings };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reportSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReportSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn report_spammer(&mut self, spammer_mid: String, spammer_reasons: Vec<SpammerReason>, spam_message_ids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("reportSpammer", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceReportSpammerArgs { spammer_mid: spammer_mid, spammer_reasons: spammer_reasons, spam_message_ids: spam_message_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("reportSpammer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceReportSpammerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_account_password_reset(&mut self, identifier: String, provider: IdentityProvider, locale: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestAccountPasswordReset", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRequestAccountPasswordResetArgs { identifier: identifier, provider: provider, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestAccountPasswordReset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRequestAccountPasswordResetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_email_confirmation(&mut self, email_confirmation: EmailConfirmation) -> thrift::Result<EmailConfirmationSession> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestEmailConfirmation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRequestEmailConfirmationArgs { email_confirmation: email_confirmation };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestEmailConfirmation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRequestEmailConfirmationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_identity_unbind(&mut self, identifier: String, provider: IdentityProvider) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestIdentityUnbind", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceRequestIdentityUnbindArgs { identifier: identifier, provider: provider };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestIdentityUnbind", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceRequestIdentityUnbindResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn resend_email_confirmation(&mut self, verifier: String) -> thrift::Result<EmailConfirmationSession> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("resendEmailConfirmation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceResendEmailConfirmationArgs { verifier: verifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("resendEmailConfirmation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceResendEmailConfirmationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn resend_pin_code(&mut self, session_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("resendPinCode", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceResendPinCodeArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("resendPinCode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceResendPinCodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn resend_pin_code_by_s_m_s(&mut self, session_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("resendPinCodeBySMS", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceResendPinCodeBySMSArgs { session_id: session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("resendPinCodeBySMS", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceResendPinCodeBySMSResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_chat_checked(&mut self, seq: i32, consumer: String, last_message_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendChatChecked", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendChatCheckedArgs { seq: seq, consumer: consumer, last_message_id: last_message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendChatChecked", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendChatCheckedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_chat_removed(&mut self, seq: i32, consumer: String, last_message_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendChatRemoved", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendChatRemovedArgs { seq: seq, consumer: consumer, last_message_id: last_message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendChatRemoved", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendChatRemovedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_content_preview_updated(&mut self, esq: i32, message_id: String, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendContentPreviewUpdated", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendContentPreviewUpdatedArgs { esq: esq, message_id: message_id, receiver_mids: receiver_mids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendContentPreviewUpdated", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendContentPreviewUpdatedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_content_receipt(&mut self, seq: i32, consumer: String, message_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendContentReceipt", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendContentReceiptArgs { seq: seq, consumer: consumer, message_id: message_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendContentReceipt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendContentReceiptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_dummy_push(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendDummyPush", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendDummyPushArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendDummyPush", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendDummyPushResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_event(&mut self, seq: i32, message: Message) -> thrift::Result<Message> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendEvent", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendEventArgs { seq: seq, message: message };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_message(&mut self, seq: i32, message: Message) -> thrift::Result<Message> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendMessage", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendMessageArgs { seq: seq, message: message };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendMessage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendMessageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_message_ignored(&mut self, seq: i32, consumer: String, message_ids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendMessageIgnored", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendMessageIgnoredArgs { seq: seq, consumer: consumer, message_ids: message_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendMessageIgnored", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendMessageIgnoredResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_message_receipt(&mut self, seq: i32, consumer: String, message_ids: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendMessageReceipt", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendMessageReceiptArgs { seq: seq, consumer: consumer, message_ids: message_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendMessageReceipt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendMessageReceiptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_message_to_my_home(&mut self, seq: i32, message: Message) -> thrift::Result<Message> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sendMessageToMyHome", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSendMessageToMyHomeArgs { seq: seq, message: message };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sendMessageToMyHome", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSendMessageToMyHomeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_buddy_location(&mut self, mid: String, index: i32, location: Geolocation) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setBuddyLocation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSetBuddyLocationArgs { mid: mid, index: index, location: location };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setBuddyLocation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSetBuddyLocationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_identity_credential(&mut self, identifier: String, verifier: String, provider: IdentityProvider) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSetIdentityCredentialArgs { identifier: identifier, verifier: verifier, provider: provider };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSetIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_notifications_enabled(&mut self, req_seq: i32, type_: MIDType, target: String, enablement: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setNotificationsEnabled", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSetNotificationsEnabledArgs { req_seq: req_seq, type_: type_, target: target, enablement: enablement };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setNotificationsEnabled", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSetNotificationsEnabledResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_update_verification(&mut self, region: String, carrier: CarrierCode, phone: String, udid_hash: String, device_info: DeviceInfo, network_code: String, locale: String) -> thrift::Result<VerificationSessionData> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("startUpdateVerification", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceStartUpdateVerificationArgs { region: region, carrier: carrier, phone: phone, udid_hash: udid_hash, device_info: device_info, network_code: network_code, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("startUpdateVerification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceStartUpdateVerificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_verification(&mut self, region: String, carrier: CarrierCode, phone: String, udid_hash: String, device_info: DeviceInfo, network_code: String, mid: String, locale: String) -> thrift::Result<VerificationSessionData> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("startVerification", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceStartVerificationArgs { region: region, carrier: carrier, phone: phone, udid_hash: udid_hash, device_info: device_info, network_code: network_code, mid: mid, locale: locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("startVerification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceStartVerificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn store_update_profile_attribute(&mut self, seq: i32, profile_attribute: ProfileAttribute, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("storeUpdateProfileAttribute", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceStoreUpdateProfileAttributeArgs { seq: seq, profile_attribute: profile_attribute, value: value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("storeUpdateProfileAttribute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceStoreUpdateProfileAttributeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sync_contact_by_sns_ids(&mut self, req_seq: i32, modifications: Vec<SnsFriendModification>) -> thrift::Result<Vec<SnsFriendContactRegistration>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("syncContactBySnsIds", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSyncContactBySnsIdsArgs { req_seq: req_seq, modifications: modifications };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("syncContactBySnsIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSyncContactBySnsIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sync_contacts(&mut self, req_seq: i32, local_contacts: Vec<ContactModification>) -> thrift::Result<BTreeMap<String, ContactRegistration>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("syncContacts", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceSyncContactsArgs { req_seq: req_seq, local_contacts: local_contacts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("syncContacts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceSyncContactsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn try_send_message(&mut self, seq: i32, message: Message) -> thrift::Result<Message> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("trySendMessage", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceTrySendMessageArgs { seq: seq, message: message };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("trySendMessage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceTrySendMessageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unblock_contact(&mut self, req_seq: i32, id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unblockContact", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUnblockContactArgs { req_seq: req_seq, id: id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unblockContact", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUnblockContactResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unblock_recommendation(&mut self, req_seq: i32, id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unblockRecommendation", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUnblockRecommendationArgs { req_seq: req_seq, id: id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unblockRecommendation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUnblockRecommendationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unregister_user_and_device(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unregisterUserAndDevice", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUnregisterUserAndDeviceArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unregisterUserAndDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUnregisterUserAndDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_apns_device_token(&mut self, apns_device_token: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateApnsDeviceToken", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateApnsDeviceTokenArgs { apns_device_token: apns_device_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateApnsDeviceToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateApnsDeviceTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_buddy_setting(&mut self, key: String, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBuddySetting", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateBuddySettingArgs { key: key, value: value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBuddySetting", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateBuddySettingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_c2_d_m_registration_id(&mut self, registration_id: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateC2DMRegistrationId", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateC2DMRegistrationIdArgs { registration_id: registration_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateC2DMRegistrationId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateC2DMRegistrationIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_contact_setting(&mut self, req_seq: i32, mid: String, flag: ContactSetting, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateContactSetting", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateContactSettingArgs { req_seq: req_seq, mid: mid, flag: flag, value: value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateContactSetting", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateContactSettingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_custom_mode_settings(&mut self, custom_mode: CustomMode, param_map: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateCustomModeSettings", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateCustomModeSettingsArgs { custom_mode: custom_mode, param_map: param_map };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateCustomModeSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateCustomModeSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_device_info(&mut self, device_uid: String, device_info: DeviceInfo) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateDeviceInfo", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateDeviceInfoArgs { device_uid: device_uid, device_info: device_info };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateDeviceInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateDeviceInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_group(&mut self, req_seq: i32, group: Group) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateGroup", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateGroupArgs { req_seq: req_seq, group: group };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_notification_token(&mut self, token: String, type_: NotificationType) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateNotificationToken", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateNotificationTokenArgs { token: token, type_: type_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateNotificationToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateNotificationTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_notification_token_with_bytes(&mut self, token: Vec<u8>, type_: NotificationType) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateNotificationTokenWithBytes", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateNotificationTokenWithBytesArgs { token: token, type_: type_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateNotificationTokenWithBytes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateNotificationTokenWithBytesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_profile(&mut self, req_seq: i32, profile: Profile) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateProfile", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateProfileArgs { req_seq: req_seq, profile: profile };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_profile_attribute(&mut self, req_seq: i32, attr: ProfileAttribute, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateProfileAttribute", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateProfileAttributeArgs { req_seq: req_seq, attr: attr, value: value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateProfileAttribute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateProfileAttributeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_region(&mut self, region: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateRegion", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateRegionArgs { region: region };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateRegion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateRegionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_settings(&mut self, req_seq: i32, settings: Settings) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateSettings", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateSettingsArgs { req_seq: req_seq, settings: settings };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_settings2(&mut self, req_seq: i32, settings: Settings) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateSettings2", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateSettings2Args { req_seq: req_seq, settings: settings };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateSettings2", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateSettings2Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_settings_attribute(&mut self, req_seq: i32, attr: SettingsAttribute, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateSettingsAttribute", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateSettingsAttributeArgs { req_seq: req_seq, attr: attr, value: value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateSettingsAttribute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateSettingsAttributeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_settings_attributes(&mut self, req_seq: i32, attr_bitset: i32, settings: Settings) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateSettingsAttributes", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceUpdateSettingsAttributesArgs { req_seq: req_seq, attr_bitset: attr_bitset, settings: settings };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateSettingsAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceUpdateSettingsAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn verify_identity_credential(&mut self, identifier: String, password: String, identity_provider: IdentityProvider) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("verifyIdentityCredential", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceVerifyIdentityCredentialArgs { identifier: identifier, password: password, identity_provider: identity_provider };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("verifyIdentityCredential", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceVerifyIdentityCredentialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn verify_identity_credential_with_result(&mut self, identity_credential: IdentityCredential) -> thrift::Result<UserAuthStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("verifyIdentityCredentialWithResult", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceVerifyIdentityCredentialWithResultArgs { identity_credential: identity_credential };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("verifyIdentityCredentialWithResult", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceVerifyIdentityCredentialWithResultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn verify_phone(&mut self, session_id: String, pin_code: String, udid_hash: String) -> thrift::Result<VerificationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("verifyPhone", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceVerifyPhoneArgs { session_id: session_id, pin_code: pin_code, udid_hash: udid_hash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("verifyPhone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceVerifyPhoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn verify_qrcode(&mut self, verifier: String, pin_code: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("verifyQrcode", TMessageType::Call, self.sequence_number());
        let call_args = TalkServiceVerifyQrcodeArgs { verifier: verifier, pin_code: pin_code };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("verifyQrcode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TalkServiceVerifyQrcodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// TalkService service processor
//

pub trait TalkServiceSyncHandler {
  fn handle_accept_group_invitation(&self, req_seq: i32, group_id: String) -> thrift::Result<()>;
  fn handle_accept_proximity_matches(&self, session_id: String, ids: BTreeSet<String>) -> thrift::Result<()>;
  fn handle_acquire_call_route(&self, to: String) -> thrift::Result<Vec<String>>;
  fn handle_acquire_call_ticket(&self, to: String) -> thrift::Result<String>;
  fn handle_acquire_encrypted_access_token(&self, feature_type: FeatureType) -> thrift::Result<String>;
  fn handle_add_sns_id(&self, sns_id_type: SnsIdType, sns_access_token: String) -> thrift::Result<String>;
  fn handle_block_contact(&self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn handle_block_recommendation(&self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn handle_cancel_group_invitation(&self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn handle_change_verification_method(&self, session_id: String, method: VerificationMethod) -> thrift::Result<VerificationSessionData>;
  fn handle_clear_identity_credential(&self) -> thrift::Result<()>;
  fn handle_clear_message_box(&self, channel_id: String, message_box_id: String) -> thrift::Result<()>;
  fn handle_close_proximity_match(&self, session_id: String) -> thrift::Result<()>;
  fn handle_commit_send_message(&self, seq: i32, message_id: String, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_commit_send_messages(&self, seq: i32, message_ids: Vec<String>, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_commit_update_profile(&self, seq: i32, attrs: Vec<ProfileAttribute>, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_confirm_email(&self, verifier: String, pin_code: String) -> thrift::Result<()>;
  fn handle_create_group(&self, seq: i32, name: String, contact_ids: Vec<String>) -> thrift::Result<Group>;
  fn handle_create_qrcode_base64_image(&self, url: String, character_set: String, image_size: i32, x: i32, y: i32, width: i32, height: i32) -> thrift::Result<String>;
  fn handle_create_room(&self, req_seq: i32, contact_ids: Vec<String>) -> thrift::Result<Room>;
  fn handle_create_session(&self) -> thrift::Result<String>;
  fn handle_fetch_announcements(&self, last_fetched_index: i32) -> thrift::Result<Vec<Announcement>>;
  fn handle_fetch_messages(&self, local_ts: i64, count: i32) -> thrift::Result<Vec<Message>>;
  fn handle_fetch_operations(&self, local_rev: i64, count: i32) -> thrift::Result<Vec<Operation>>;
  fn handle_fetch_ops(&self, local_rev: i64, count: i32, global_rev: i64, individual_rev: i64) -> thrift::Result<Vec<Operation>>;
  fn handle_find_and_add_contacts_by_email(&self, req_seq: i32, emails: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn handle_find_and_add_contacts_by_mid(&self, req_seq: i32, mid: String) -> thrift::Result<BTreeMap<String, Contact>>;
  fn handle_find_and_add_contacts_by_phone(&self, req_seq: i32, phones: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn handle_find_and_add_contacts_by_userid(&self, req_seq: i32, userid: String) -> thrift::Result<BTreeMap<String, Contact>>;
  fn handle_find_contact_by_userid(&self, userid: String) -> thrift::Result<Contact>;
  fn handle_find_contact_by_user_ticket(&self, ticket_id: String) -> thrift::Result<Contact>;
  fn handle_find_contacts_by_email(&self, emails: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn handle_find_contacts_by_phone(&self, phones: BTreeSet<String>) -> thrift::Result<BTreeMap<String, Contact>>;
  fn handle_find_sns_id_user_status(&self, sns_id_type: SnsIdType, sns_access_token: String, udid_hash: String) -> thrift::Result<SnsIdUserStatus>;
  fn handle_finish_update_verification(&self, session_id: String) -> thrift::Result<()>;
  fn handle_generate_user_ticket(&self, expiration_time: i64, max_use_count: i32) -> thrift::Result<Ticket>;
  fn handle_get_accepted_proximity_matches(&self, session_id: String) -> thrift::Result<BTreeSet<String>>;
  fn handle_get_active_buddy_subscriber_ids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_all_contact_ids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_auth_qrcode(&self, keep_logged_in: bool, system_name: String) -> thrift::Result<AuthQrcode>;
  fn handle_get_blocked_contact_ids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_blocked_contact_ids_by_range(&self, start: i32, count: i32) -> thrift::Result<Vec<String>>;
  fn handle_get_blocked_recommendation_ids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_buddy_blocker_ids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_buddy_location(&self, mid: String, index: i32) -> thrift::Result<Geolocation>;
  fn handle_get_compact_contacts_modified_since(&self, timestamp: i64) -> thrift::Result<Vec<CompactContact>>;
  fn handle_get_compact_group(&self, group_id: String) -> thrift::Result<Group>;
  fn handle_get_compact_room(&self, room_id: String) -> thrift::Result<Room>;
  fn handle_get_contact(&self, id: String) -> thrift::Result<Contact>;
  fn handle_get_contacts(&self, ids: Vec<String>) -> thrift::Result<Vec<Contact>>;
  fn handle_get_country_with_request_ip(&self) -> thrift::Result<String>;
  fn handle_get_favorite_mids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_group(&self, group_id: String) -> thrift::Result<Group>;
  fn handle_get_group_ids_invited(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_group_ids_joined(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_groups(&self, group_ids: Vec<String>) -> thrift::Result<Vec<Group>>;
  fn handle_get_hidden_contact_mids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_identity_identifier(&self) -> thrift::Result<String>;
  fn handle_get_last_announcement_index(&self) -> thrift::Result<i32>;
  fn handle_get_last_op_revision(&self) -> thrift::Result<i64>;
  fn handle_get_message_box(&self, channel_id: String, message_box_id: String, last_messages_count: i32) -> thrift::Result<TMessageBox>;
  fn handle_get_message_box_compact_wrap_up(&self, mid: String) -> thrift::Result<TMessageBoxWrapUp>;
  fn handle_get_message_box_compact_wrap_up_list(&self, start: i32, message_box_count: i32) -> thrift::Result<TMessageBoxWrapUpResponse>;
  fn handle_get_message_box_list(&self, channel_id: String, last_messages_count: i32) -> thrift::Result<Vec<TMessageBox>>;
  fn handle_get_message_box_list_by_status(&self, channel_id: String, last_messages_count: i32, status: i32) -> thrift::Result<Vec<TMessageBox>>;
  fn handle_get_message_box_wrap_up(&self, mid: String) -> thrift::Result<TMessageBoxWrapUp>;
  fn handle_get_message_box_wrap_up_list(&self, start: i32, message_box_count: i32) -> thrift::Result<TMessageBoxWrapUpResponse>;
  fn handle_get_messages_by_sequence_number(&self, channel_id: String, message_box_id: String, start_seq: i64, end_seq: i64) -> thrift::Result<Vec<Message>>;
  fn handle_get_next_messages(&self, message_box_id: String, start_seq: i64, messages_count: i32) -> thrift::Result<Vec<Message>>;
  fn handle_get_notification_policy(&self, carrier: CarrierCode) -> thrift::Result<Vec<NotificationType>>;
  fn handle_get_previous_messages(&self, message_box_id: String, end_seq: i64, messages_count: i32) -> thrift::Result<Vec<Message>>;
  fn handle_get_profile(&self) -> thrift::Result<Profile>;
  fn handle_get_proximity_match_candidate_list(&self, session_id: String) -> thrift::Result<ProximityMatchCandidateResult>;
  fn handle_get_proximity_match_candidates(&self, session_id: String) -> thrift::Result<BTreeSet<Contact>>;
  fn handle_get_recent_messages(&self, message_box_id: String, messages_count: i32) -> thrift::Result<Vec<Message>>;
  fn handle_get_recommendation_ids(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_room(&self, room_id: String) -> thrift::Result<Room>;
  fn handle_get_r_s_a_key_info(&self, provider: IdentityProvider) -> thrift::Result<RSAKey>;
  fn handle_get_server_time(&self) -> thrift::Result<i64>;
  fn handle_get_sessions(&self) -> thrift::Result<Vec<LoginSession>>;
  fn handle_get_settings(&self) -> thrift::Result<Settings>;
  fn handle_get_settings_attributes(&self, attr_bitset: i32) -> thrift::Result<Settings>;
  fn handle_get_system_configuration(&self) -> thrift::Result<SystemConfiguration>;
  fn handle_get_user_ticket(&self) -> thrift::Result<Ticket>;
  fn handle_get_wap_invitation(&self, invitation_hash: String) -> thrift::Result<WapInvitation>;
  fn handle_invalidate_user_ticket(&self) -> thrift::Result<()>;
  fn handle_invite_friends_by_sms(&self, phone_number_list: Vec<String>) -> thrift::Result<()>;
  fn handle_invite_into_group(&self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn handle_invite_into_room(&self, req_seq: i32, room_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn handle_invite_via_email(&self, req_seq: i32, email: String, name: String) -> thrift::Result<()>;
  fn handle_is_identity_identifier_available(&self, identifier: String, provider: IdentityProvider) -> thrift::Result<bool>;
  fn handle_is_userid_available(&self, userid: String) -> thrift::Result<bool>;
  fn handle_kickout_from_group(&self, req_seq: i32, group_id: String, contact_ids: Vec<String>) -> thrift::Result<()>;
  fn handle_leave_group(&self, req_seq: i32, group_id: String) -> thrift::Result<()>;
  fn handle_leave_room(&self, req_seq: i32, room_id: String) -> thrift::Result<()>;
  fn handle_login_with_identity_credential(&self, identifier: String, password: String, keep_logged_in: bool, access_location: String, system_name: String, identity_provider: IdentityProvider, certificate: String) -> thrift::Result<String>;
  fn handle_login_with_identity_credential_for_certificate(&self, identifier: String, password: String, keep_logged_in: bool, access_location: String, system_name: String, identity_provider: IdentityProvider, certificate: String) -> thrift::Result<LoginResult>;
  fn handle_login_with_verifier(&self, verifier: String) -> thrift::Result<String>;
  fn handle_login_with_verifier_for_cerificate(&self, verifier: String) -> thrift::Result<LoginResult>;
  fn handle_login_with_verifier_for_certificate(&self, verifier: String) -> thrift::Result<LoginResult>;
  fn handle_logout(&self) -> thrift::Result<()>;
  fn handle_logout_session(&self, token_key: String) -> thrift::Result<()>;
  fn handle_noop(&self) -> thrift::Result<()>;
  fn handle_notified_redirect(&self, param_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn handle_notify_buddy_on_air(&self, seq: i32, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_notify_individual_event(&self, notification_status: NotificationStatus, receiver_mids: Vec<String>) -> thrift::Result<()>;
  fn handle_notify_installed(&self, udid_hash: String, application_type_with_extensions: String) -> thrift::Result<()>;
  fn handle_notify_registration_complete(&self, udid_hash: String, application_type_with_extensions: String) -> thrift::Result<()>;
  fn handle_notify_sleep(&self, last_rev: i64, badge: i32) -> thrift::Result<()>;
  fn handle_notify_updated(&self, last_rev: i64, device_info: DeviceInfo) -> thrift::Result<()>;
  fn handle_open_proximity_match(&self, location: Location) -> thrift::Result<String>;
  fn handle_register_buddy_user(&self, buddy_id: String, registrar_password: String) -> thrift::Result<String>;
  fn handle_register_buddy_userid(&self, seq: i32, userid: String) -> thrift::Result<()>;
  fn handle_register_device(&self, session_id: String) -> thrift::Result<String>;
  fn handle_register_device_with_identity_credential(&self, session_id: String, identifier: String, verifier: String, provider: IdentityProvider) -> thrift::Result<String>;
  fn handle_register_device_without_phone_number(&self, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn handle_register_device_without_phone_number_with_identity_credential(&self, region: String, udid_hash: String, device_info: DeviceInfo, provider: IdentityProvider, identifier: String, verifier: String, mid: String) -> thrift::Result<String>;
  fn handle_register_userid(&self, req_seq: i32, userid: String) -> thrift::Result<bool>;
  fn handle_register_wap_device(&self, invitation_hash: String, guid_hash: String, email: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn handle_register_with_existing_sns_id_and_identity_credential(&self, identity_credential: IdentityCredential, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn handle_register_with_sns_id(&self, sns_id_type: SnsIdType, sns_access_token: String, region: String, udid_hash: String, device_info: DeviceInfo, mid: String) -> thrift::Result<RegisterWithSnsIdResult>;
  fn handle_register_with_sns_id_and_identity_credential(&self, sns_id_type: SnsIdType, sns_access_token: String, identity_credential: IdentityCredential, region: String, udid_hash: String, device_info: DeviceInfo) -> thrift::Result<String>;
  fn handle_reissue_device_credential(&self) -> thrift::Result<String>;
  fn handle_reissue_user_ticket(&self, expiration_time: i64, max_use_count: i32) -> thrift::Result<String>;
  fn handle_reject_group_invitation(&self, req_seq: i32, group_id: String) -> thrift::Result<()>;
  fn handle_release_session(&self) -> thrift::Result<()>;
  fn handle_remove_all_messages(&self, seq: i32, last_message_id: String) -> thrift::Result<()>;
  fn handle_remove_buddy_location(&self, mid: String, index: i32) -> thrift::Result<()>;
  fn handle_remove_message(&self, message_id: String) -> thrift::Result<bool>;
  fn handle_remove_message_from_my_home(&self, message_id: String) -> thrift::Result<bool>;
  fn handle_remove_sns_id(&self, sns_id_type: SnsIdType) -> thrift::Result<String>;
  fn handle_report(&self, sync_op_revision: i64, category: SyncCategory, report: String) -> thrift::Result<()>;
  fn handle_report_contacts(&self, sync_op_revision: i64, category: SyncCategory, contact_reports: Vec<ContactReport>, action_type: SyncActionType) -> thrift::Result<Vec<ContactReportResult>>;
  fn handle_report_groups(&self, sync_op_revision: i64, groups: Vec<Group>) -> thrift::Result<()>;
  fn handle_report_profile(&self, sync_op_revision: i64, profile: Profile) -> thrift::Result<()>;
  fn handle_report_rooms(&self, sync_op_revision: i64, rooms: Vec<Room>) -> thrift::Result<()>;
  fn handle_report_settings(&self, sync_op_revision: i64, settings: Settings) -> thrift::Result<()>;
  fn handle_report_spammer(&self, spammer_mid: String, spammer_reasons: Vec<SpammerReason>, spam_message_ids: Vec<String>) -> thrift::Result<()>;
  fn handle_request_account_password_reset(&self, identifier: String, provider: IdentityProvider, locale: String) -> thrift::Result<()>;
  fn handle_request_email_confirmation(&self, email_confirmation: EmailConfirmation) -> thrift::Result<EmailConfirmationSession>;
  fn handle_request_identity_unbind(&self, identifier: String, provider: IdentityProvider) -> thrift::Result<()>;
  fn handle_resend_email_confirmation(&self, verifier: String) -> thrift::Result<EmailConfirmationSession>;
  fn handle_resend_pin_code(&self, session_id: String) -> thrift::Result<()>;
  fn handle_resend_pin_code_by_s_m_s(&self, session_id: String) -> thrift::Result<()>;
  fn handle_send_chat_checked(&self, seq: i32, consumer: String, last_message_id: String) -> thrift::Result<()>;
  fn handle_send_chat_removed(&self, seq: i32, consumer: String, last_message_id: String) -> thrift::Result<()>;
  fn handle_send_content_preview_updated(&self, esq: i32, message_id: String, receiver_mids: Vec<String>) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_send_content_receipt(&self, seq: i32, consumer: String, message_id: String) -> thrift::Result<()>;
  fn handle_send_dummy_push(&self) -> thrift::Result<()>;
  fn handle_send_event(&self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn handle_send_message(&self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn handle_send_message_ignored(&self, seq: i32, consumer: String, message_ids: Vec<String>) -> thrift::Result<()>;
  fn handle_send_message_receipt(&self, seq: i32, consumer: String, message_ids: Vec<String>) -> thrift::Result<()>;
  fn handle_send_message_to_my_home(&self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn handle_set_buddy_location(&self, mid: String, index: i32, location: Geolocation) -> thrift::Result<()>;
  fn handle_set_identity_credential(&self, identifier: String, verifier: String, provider: IdentityProvider) -> thrift::Result<()>;
  fn handle_set_notifications_enabled(&self, req_seq: i32, type_: MIDType, target: String, enablement: bool) -> thrift::Result<()>;
  fn handle_start_update_verification(&self, region: String, carrier: CarrierCode, phone: String, udid_hash: String, device_info: DeviceInfo, network_code: String, locale: String) -> thrift::Result<VerificationSessionData>;
  fn handle_start_verification(&self, region: String, carrier: CarrierCode, phone: String, udid_hash: String, device_info: DeviceInfo, network_code: String, mid: String, locale: String) -> thrift::Result<VerificationSessionData>;
  fn handle_store_update_profile_attribute(&self, seq: i32, profile_attribute: ProfileAttribute, value: String) -> thrift::Result<()>;
  fn handle_sync_contact_by_sns_ids(&self, req_seq: i32, modifications: Vec<SnsFriendModification>) -> thrift::Result<Vec<SnsFriendContactRegistration>>;
  fn handle_sync_contacts(&self, req_seq: i32, local_contacts: Vec<ContactModification>) -> thrift::Result<BTreeMap<String, ContactRegistration>>;
  fn handle_try_send_message(&self, seq: i32, message: Message) -> thrift::Result<Message>;
  fn handle_unblock_contact(&self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn handle_unblock_recommendation(&self, req_seq: i32, id: String) -> thrift::Result<()>;
  fn handle_unregister_user_and_device(&self) -> thrift::Result<String>;
  fn handle_update_apns_device_token(&self, apns_device_token: Vec<u8>) -> thrift::Result<()>;
  fn handle_update_buddy_setting(&self, key: String, value: String) -> thrift::Result<()>;
  fn handle_update_c2_d_m_registration_id(&self, registration_id: String) -> thrift::Result<()>;
  fn handle_update_contact_setting(&self, req_seq: i32, mid: String, flag: ContactSetting, value: String) -> thrift::Result<()>;
  fn handle_update_custom_mode_settings(&self, custom_mode: CustomMode, param_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn handle_update_device_info(&self, device_uid: String, device_info: DeviceInfo) -> thrift::Result<()>;
  fn handle_update_group(&self, req_seq: i32, group: Group) -> thrift::Result<()>;
  fn handle_update_notification_token(&self, token: String, type_: NotificationType) -> thrift::Result<()>;
  fn handle_update_notification_token_with_bytes(&self, token: Vec<u8>, type_: NotificationType) -> thrift::Result<()>;
  fn handle_update_profile(&self, req_seq: i32, profile: Profile) -> thrift::Result<()>;
  fn handle_update_profile_attribute(&self, req_seq: i32, attr: ProfileAttribute, value: String) -> thrift::Result<()>;
  fn handle_update_region(&self, region: String) -> thrift::Result<()>;
  fn handle_update_settings(&self, req_seq: i32, settings: Settings) -> thrift::Result<()>;
  fn handle_update_settings2(&self, req_seq: i32, settings: Settings) -> thrift::Result<i32>;
  fn handle_update_settings_attribute(&self, req_seq: i32, attr: SettingsAttribute, value: String) -> thrift::Result<()>;
  fn handle_update_settings_attributes(&self, req_seq: i32, attr_bitset: i32, settings: Settings) -> thrift::Result<i32>;
  fn handle_verify_identity_credential(&self, identifier: String, password: String, identity_provider: IdentityProvider) -> thrift::Result<()>;
  fn handle_verify_identity_credential_with_result(&self, identity_credential: IdentityCredential) -> thrift::Result<UserAuthStatus>;
  fn handle_verify_phone(&self, session_id: String, pin_code: String, udid_hash: String) -> thrift::Result<VerificationResult>;
  fn handle_verify_qrcode(&self, verifier: String, pin_code: String) -> thrift::Result<String>;
}

pub struct TalkServiceSyncProcessor<H: TalkServiceSyncHandler> {
  handler: H,
}

impl <H: TalkServiceSyncHandler> TalkServiceSyncProcessor<H> {
  pub fn new(handler: H) -> TalkServiceSyncProcessor<H> {
    TalkServiceSyncProcessor {
      handler,
    }
  }
  fn process_accept_group_invitation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_accept_group_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_accept_proximity_matches(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_accept_proximity_matches(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_acquire_call_route(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_acquire_call_route(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_acquire_call_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_acquire_call_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_acquire_encrypted_access_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_acquire_encrypted_access_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_sns_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_add_sns_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_block_contact(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_block_contact(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_block_recommendation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_block_recommendation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cancel_group_invitation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_cancel_group_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_change_verification_method(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_change_verification_method(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_clear_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_message_box(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_clear_message_box(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_close_proximity_match(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_close_proximity_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_commit_send_message(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_commit_send_message(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_commit_send_messages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_commit_send_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_commit_update_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_commit_update_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_confirm_email(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_confirm_email(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_create_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_qrcode_base64_image(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_create_qrcode_base64_image(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_room(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_create_room(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_create_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_announcements(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_fetch_announcements(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_messages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_fetch_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_operations(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_fetch_operations(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_ops(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_fetch_ops(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_and_add_contacts_by_email(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_and_add_contacts_by_email(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_and_add_contacts_by_mid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_and_add_contacts_by_mid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_and_add_contacts_by_phone(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_and_add_contacts_by_phone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_and_add_contacts_by_userid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_and_add_contacts_by_userid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_contact_by_userid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_contact_by_userid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_contact_by_user_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_contact_by_user_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_contacts_by_email(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_contacts_by_email(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_contacts_by_phone(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_contacts_by_phone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_sns_id_user_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_find_sns_id_user_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_finish_update_verification(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_finish_update_verification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_generate_user_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_generate_user_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_accepted_proximity_matches(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_accepted_proximity_matches(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_active_buddy_subscriber_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_active_buddy_subscriber_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_contact_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_all_contact_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_auth_qrcode(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_auth_qrcode(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_blocked_contact_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_blocked_contact_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_blocked_contact_ids_by_range(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_blocked_contact_ids_by_range(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_blocked_recommendation_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_blocked_recommendation_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_buddy_blocker_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_buddy_blocker_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_buddy_location(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_buddy_location(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_compact_contacts_modified_since(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_compact_contacts_modified_since(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_compact_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_compact_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_compact_room(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_compact_room(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_contact(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_contact(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_contacts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_contacts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_country_with_request_ip(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_country_with_request_ip(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_favorite_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_favorite_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_group_ids_invited(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_group_ids_invited(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_group_ids_joined(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_group_ids_joined(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_groups(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_groups(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_hidden_contact_mids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_hidden_contact_mids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_identity_identifier(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_identity_identifier(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_last_announcement_index(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_last_announcement_index(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_last_op_revision(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_last_op_revision(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_message_box(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_message_box(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_message_box_compact_wrap_up(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_message_box_compact_wrap_up(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_message_box_compact_wrap_up_list(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_message_box_compact_wrap_up_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_message_box_list(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_message_box_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_message_box_list_by_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_message_box_list_by_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_message_box_wrap_up(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_message_box_wrap_up(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_message_box_wrap_up_list(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_message_box_wrap_up_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_messages_by_sequence_number(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_messages_by_sequence_number(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_next_messages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_next_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_notification_policy(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_notification_policy(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_previous_messages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_previous_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_proximity_match_candidate_list(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_proximity_match_candidate_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_proximity_match_candidates(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_proximity_match_candidates(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_recent_messages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_recent_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_recommendation_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_recommendation_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_room(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_room(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_r_s_a_key_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_r_s_a_key_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_server_time(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_server_time(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_sessions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_sessions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_settings(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_settings_attributes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_settings_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_system_configuration(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_system_configuration(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_user_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_wap_invitation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_get_wap_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_invalidate_user_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_invalidate_user_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_invite_friends_by_sms(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_invite_friends_by_sms(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_invite_into_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_invite_into_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_invite_into_room(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_invite_into_room(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_invite_via_email(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_invite_via_email(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_identity_identifier_available(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_is_identity_identifier_available(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_userid_available(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_is_userid_available(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_kickout_from_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_kickout_from_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_leave_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_leave_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_leave_room(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_leave_room(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_login_with_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_login_with_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_login_with_identity_credential_for_certificate(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_login_with_identity_credential_for_certificate(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_login_with_verifier(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_login_with_verifier(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_login_with_verifier_for_cerificate(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_login_with_verifier_for_cerificate(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_login_with_verifier_for_certificate(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_login_with_verifier_for_certificate(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_logout(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_logout(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_logout_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_logout_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_noop(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_noop(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notified_redirect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_notified_redirect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_buddy_on_air(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_notify_buddy_on_air(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_individual_event(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_notify_individual_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_installed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_notify_installed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_registration_complete(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_notify_registration_complete(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_sleep(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_notify_sleep(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_notify_updated(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_notify_updated(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_open_proximity_match(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_open_proximity_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_buddy_user(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_buddy_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_buddy_userid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_buddy_userid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_device_with_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_device_with_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_device_without_phone_number(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_device_without_phone_number(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_device_without_phone_number_with_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_device_without_phone_number_with_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_userid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_userid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_wap_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_wap_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_with_existing_sns_id_and_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_with_existing_sns_id_and_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_with_sns_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_with_sns_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_with_sns_id_and_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_register_with_sns_id_and_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reissue_device_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_reissue_device_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reissue_user_ticket(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_reissue_user_ticket(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reject_group_invitation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_reject_group_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_release_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_release_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_all_messages(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_remove_all_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_buddy_location(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_remove_buddy_location(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_message(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_remove_message(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_message_from_my_home(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_remove_message_from_my_home(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_sns_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_remove_sns_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_report(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_report(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_report_contacts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_report_contacts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_report_groups(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_report_groups(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_report_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_report_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_report_rooms(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_report_rooms(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_report_settings(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_report_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_report_spammer(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_report_spammer(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_account_password_reset(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_request_account_password_reset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_email_confirmation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_request_email_confirmation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_identity_unbind(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_request_identity_unbind(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_resend_email_confirmation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_resend_email_confirmation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_resend_pin_code(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_resend_pin_code(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_resend_pin_code_by_s_m_s(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_resend_pin_code_by_s_m_s(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_chat_checked(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_chat_checked(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_chat_removed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_chat_removed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_content_preview_updated(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_content_preview_updated(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_content_receipt(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_content_receipt(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_dummy_push(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_dummy_push(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_event(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_message(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_message(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_message_ignored(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_message_ignored(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_message_receipt(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_message_receipt(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_message_to_my_home(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_send_message_to_my_home(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_buddy_location(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_set_buddy_location(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_set_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_notifications_enabled(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_set_notifications_enabled(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_update_verification(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_start_update_verification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_verification(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_start_verification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_store_update_profile_attribute(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_store_update_profile_attribute(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sync_contact_by_sns_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_sync_contact_by_sns_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sync_contacts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_sync_contacts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_try_send_message(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_try_send_message(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unblock_contact(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_unblock_contact(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unblock_recommendation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_unblock_recommendation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unregister_user_and_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_unregister_user_and_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_apns_device_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_apns_device_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_buddy_setting(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_buddy_setting(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_c2_d_m_registration_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_c2_d_m_registration_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_contact_setting(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_contact_setting(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_custom_mode_settings(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_custom_mode_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_device_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_device_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_notification_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_notification_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_notification_token_with_bytes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_notification_token_with_bytes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_profile_attribute(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_profile_attribute(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_region(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_region(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_settings(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_settings2(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_settings2(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_settings_attribute(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_settings_attribute(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_settings_attributes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_update_settings_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_verify_identity_credential(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_verify_identity_credential(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_verify_identity_credential_with_result(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_verify_identity_credential_with_result(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_verify_phone(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_verify_phone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_verify_qrcode(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTalkServiceProcessFunctions::process_verify_qrcode(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TTalkServiceProcessFunctions;

impl TTalkServiceProcessFunctions {
  pub fn process_accept_group_invitation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceAcceptGroupInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_accept_group_invitation(args.req_seq, args.group_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("acceptGroupInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceAcceptGroupInvitationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceAcceptGroupInvitationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("acceptGroupInvitation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("acceptGroupInvitation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("acceptGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("acceptGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_accept_proximity_matches<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceAcceptProximityMatchesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_accept_proximity_matches(args.session_id, args.ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("acceptProximityMatches", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceAcceptProximityMatchesResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceAcceptProximityMatchesResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("acceptProximityMatches", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("acceptProximityMatches", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("acceptProximityMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("acceptProximityMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_acquire_call_route<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceAcquireCallRouteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_acquire_call_route(args.to) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("acquireCallRoute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceAcquireCallRouteResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceAcquireCallRouteResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("acquireCallRoute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("acquireCallRoute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("acquireCallRoute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("acquireCallRoute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_acquire_call_ticket<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceAcquireCallTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_acquire_call_ticket(args.to) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("acquireCallTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceAcquireCallTicketResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceAcquireCallTicketResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("acquireCallTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("acquireCallTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("acquireCallTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("acquireCallTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_acquire_encrypted_access_token<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceAcquireEncryptedAccessTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_acquire_encrypted_access_token(args.feature_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("acquireEncryptedAccessToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceAcquireEncryptedAccessTokenResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceAcquireEncryptedAccessTokenResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("acquireEncryptedAccessToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("acquireEncryptedAccessToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("acquireEncryptedAccessToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("acquireEncryptedAccessToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_sns_id<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceAddSnsIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_sns_id(args.sns_id_type, args.sns_access_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("addSnsId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceAddSnsIdResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceAddSnsIdResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("addSnsId", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("addSnsId", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("addSnsId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("addSnsId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_block_contact<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceBlockContactArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_block_contact(args.req_seq, args.id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("blockContact", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceBlockContactResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceBlockContactResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("blockContact", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("blockContact", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("blockContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("blockContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_block_recommendation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceBlockRecommendationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_block_recommendation(args.req_seq, args.id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("blockRecommendation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceBlockRecommendationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceBlockRecommendationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("blockRecommendation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("blockRecommendation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("blockRecommendation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("blockRecommendation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cancel_group_invitation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCancelGroupInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cancel_group_invitation(args.req_seq, args.group_id, args.contact_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("cancelGroupInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCancelGroupInvitationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCancelGroupInvitationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("cancelGroupInvitation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("cancelGroupInvitation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("cancelGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("cancelGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_change_verification_method<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceChangeVerificationMethodArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_change_verification_method(args.session_id, args.method) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("changeVerificationMethod", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceChangeVerificationMethodResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceChangeVerificationMethodResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("changeVerificationMethod", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("changeVerificationMethod", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("changeVerificationMethod", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("changeVerificationMethod", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceClearIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_identity_credential() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clearIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceClearIdentityCredentialResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceClearIdentityCredentialResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clearIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("clearIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clearIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("clearIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_message_box<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceClearMessageBoxArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_message_box(args.channel_id, args.message_box_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clearMessageBox", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceClearMessageBoxResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceClearMessageBoxResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clearMessageBox", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("clearMessageBox", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clearMessageBox", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("clearMessageBox", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_close_proximity_match<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCloseProximityMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_close_proximity_match(args.session_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("closeProximityMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCloseProximityMatchResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCloseProximityMatchResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("closeProximityMatch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("closeProximityMatch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("closeProximityMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("closeProximityMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_commit_send_message<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCommitSendMessageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_commit_send_message(args.seq, args.message_id, args.receiver_mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("commitSendMessage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCommitSendMessageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCommitSendMessageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("commitSendMessage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("commitSendMessage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("commitSendMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("commitSendMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_commit_send_messages<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCommitSendMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_commit_send_messages(args.seq, args.message_ids, args.receiver_mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("commitSendMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCommitSendMessagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCommitSendMessagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("commitSendMessages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("commitSendMessages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("commitSendMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("commitSendMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_commit_update_profile<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCommitUpdateProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_commit_update_profile(args.seq, args.attrs, args.receiver_mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("commitUpdateProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCommitUpdateProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCommitUpdateProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("commitUpdateProfile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("commitUpdateProfile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("commitUpdateProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("commitUpdateProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_confirm_email<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceConfirmEmailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_confirm_email(args.verifier, args.pin_code) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("confirmEmail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceConfirmEmailResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceConfirmEmailResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("confirmEmail", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("confirmEmail", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("confirmEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("confirmEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_group<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCreateGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_group(args.seq, args.name, args.contact_ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCreateGroupResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCreateGroupResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("createGroup", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("createGroup", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("createGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_qrcode_base64_image<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCreateQrcodeBase64ImageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_qrcode_base64_image(args.url, args.character_set, args.image_size, args.x, args.y, args.width, args.height) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createQrcodeBase64Image", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCreateQrcodeBase64ImageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCreateQrcodeBase64ImageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("createQrcodeBase64Image", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("createQrcodeBase64Image", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createQrcodeBase64Image", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("createQrcodeBase64Image", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_room<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceCreateRoomArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_room(args.req_seq, args.contact_ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createRoom", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCreateRoomResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCreateRoomResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("createRoom", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("createRoom", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("createRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_session<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceCreateSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_session() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceCreateSessionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceCreateSessionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("createSession", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("createSession", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("createSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_announcements<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFetchAnnouncementsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_announcements(args.last_fetched_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchAnnouncements", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFetchAnnouncementsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFetchAnnouncementsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("fetchAnnouncements", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("fetchAnnouncements", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchAnnouncements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchAnnouncements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_messages<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFetchMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_messages(args.local_ts, args.count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFetchMessagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFetchMessagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("fetchMessages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("fetchMessages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_operations<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFetchOperationsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_operations(args.local_rev, args.count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchOperations", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFetchOperationsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFetchOperationsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("fetchOperations", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("fetchOperations", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchOperations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchOperations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_ops<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFetchOpsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_ops(args.local_rev, args.count, args.global_rev, args.individual_rev) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchOps", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFetchOpsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFetchOpsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("fetchOps", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("fetchOps", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchOps", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchOps", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_and_add_contacts_by_email<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindAndAddContactsByEmailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_and_add_contacts_by_email(args.req_seq, args.emails) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findAndAddContactsByEmail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindAndAddContactsByEmailResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindAndAddContactsByEmailResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByEmail", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByEmail", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findAndAddContactsByEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findAndAddContactsByEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_and_add_contacts_by_mid<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindAndAddContactsByMidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_and_add_contacts_by_mid(args.req_seq, args.mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findAndAddContactsByMid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindAndAddContactsByMidResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindAndAddContactsByMidResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByMid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByMid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findAndAddContactsByMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findAndAddContactsByMid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_and_add_contacts_by_phone<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindAndAddContactsByPhoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_and_add_contacts_by_phone(args.req_seq, args.phones) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findAndAddContactsByPhone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindAndAddContactsByPhoneResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindAndAddContactsByPhoneResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByPhone", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByPhone", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findAndAddContactsByPhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findAndAddContactsByPhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_and_add_contacts_by_userid<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindAndAddContactsByUseridArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_and_add_contacts_by_userid(args.req_seq, args.userid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findAndAddContactsByUserid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindAndAddContactsByUseridResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindAndAddContactsByUseridResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByUserid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findAndAddContactsByUserid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findAndAddContactsByUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findAndAddContactsByUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_contact_by_userid<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindContactByUseridArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_contact_by_userid(args.userid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findContactByUserid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindContactByUseridResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindContactByUseridResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findContactByUserid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findContactByUserid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findContactByUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findContactByUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_contact_by_user_ticket<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindContactByUserTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_contact_by_user_ticket(args.ticket_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findContactByUserTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindContactByUserTicketResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindContactByUserTicketResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findContactByUserTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findContactByUserTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findContactByUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findContactByUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_contacts_by_email<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindContactsByEmailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_contacts_by_email(args.emails) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findContactsByEmail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindContactsByEmailResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindContactsByEmailResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findContactsByEmail", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findContactsByEmail", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findContactsByEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findContactsByEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_contacts_by_phone<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindContactsByPhoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_contacts_by_phone(args.phones) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findContactsByPhone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindContactsByPhoneResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindContactsByPhoneResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findContactsByPhone", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findContactsByPhone", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findContactsByPhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findContactsByPhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_sns_id_user_status<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFindSnsIdUserStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_sns_id_user_status(args.sns_id_type, args.sns_access_token, args.udid_hash) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findSnsIdUserStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFindSnsIdUserStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFindSnsIdUserStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("findSnsIdUserStatus", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("findSnsIdUserStatus", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findSnsIdUserStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("findSnsIdUserStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_finish_update_verification<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceFinishUpdateVerificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_finish_update_verification(args.session_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("finishUpdateVerification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceFinishUpdateVerificationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceFinishUpdateVerificationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("finishUpdateVerification", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("finishUpdateVerification", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("finishUpdateVerification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("finishUpdateVerification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_generate_user_ticket<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGenerateUserTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_generate_user_ticket(args.expiration_time, args.max_use_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("generateUserTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGenerateUserTicketResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGenerateUserTicketResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("generateUserTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("generateUserTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("generateUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("generateUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_accepted_proximity_matches<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetAcceptedProximityMatchesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_accepted_proximity_matches(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getAcceptedProximityMatches", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetAcceptedProximityMatchesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetAcceptedProximityMatchesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getAcceptedProximityMatches", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getAcceptedProximityMatches", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getAcceptedProximityMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getAcceptedProximityMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_active_buddy_subscriber_ids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetActiveBuddySubscriberIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_active_buddy_subscriber_ids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getActiveBuddySubscriberIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetActiveBuddySubscriberIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetActiveBuddySubscriberIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getActiveBuddySubscriberIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getActiveBuddySubscriberIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getActiveBuddySubscriberIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getActiveBuddySubscriberIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_contact_ids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetAllContactIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_contact_ids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getAllContactIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetAllContactIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetAllContactIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getAllContactIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getAllContactIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getAllContactIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getAllContactIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_auth_qrcode<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetAuthQrcodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_auth_qrcode(args.keep_logged_in, args.system_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getAuthQrcode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetAuthQrcodeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetAuthQrcodeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getAuthQrcode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getAuthQrcode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getAuthQrcode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getAuthQrcode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_blocked_contact_ids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetBlockedContactIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_blocked_contact_ids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBlockedContactIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetBlockedContactIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetBlockedContactIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBlockedContactIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBlockedContactIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBlockedContactIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBlockedContactIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_blocked_contact_ids_by_range<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetBlockedContactIdsByRangeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_blocked_contact_ids_by_range(args.start, args.count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBlockedContactIdsByRange", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetBlockedContactIdsByRangeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetBlockedContactIdsByRangeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBlockedContactIdsByRange", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBlockedContactIdsByRange", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBlockedContactIdsByRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBlockedContactIdsByRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_blocked_recommendation_ids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetBlockedRecommendationIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_blocked_recommendation_ids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBlockedRecommendationIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetBlockedRecommendationIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetBlockedRecommendationIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBlockedRecommendationIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBlockedRecommendationIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBlockedRecommendationIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBlockedRecommendationIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_buddy_blocker_ids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetBuddyBlockerIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_buddy_blocker_ids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBuddyBlockerIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetBuddyBlockerIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetBuddyBlockerIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBuddyBlockerIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBuddyBlockerIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBuddyBlockerIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBuddyBlockerIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_buddy_location<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetBuddyLocationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_buddy_location(args.mid, args.index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBuddyLocation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetBuddyLocationResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetBuddyLocationResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getBuddyLocation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getBuddyLocation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBuddyLocation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getBuddyLocation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_compact_contacts_modified_since<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetCompactContactsModifiedSinceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_compact_contacts_modified_since(args.timestamp) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCompactContactsModifiedSince", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetCompactContactsModifiedSinceResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetCompactContactsModifiedSinceResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCompactContactsModifiedSince", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCompactContactsModifiedSince", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCompactContactsModifiedSince", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCompactContactsModifiedSince", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_compact_group<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetCompactGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_compact_group(args.group_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCompactGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetCompactGroupResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetCompactGroupResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCompactGroup", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCompactGroup", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCompactGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCompactGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_compact_room<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetCompactRoomArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_compact_room(args.room_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCompactRoom", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetCompactRoomResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetCompactRoomResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCompactRoom", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCompactRoom", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCompactRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCompactRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_contact<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetContactArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_contact(args.id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getContact", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetContactResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetContactResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getContact", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getContact", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_contacts<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetContactsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_contacts(args.ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getContacts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetContactsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetContactsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getContacts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getContacts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_country_with_request_ip<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetCountryWithRequestIpArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_country_with_request_ip() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCountryWithRequestIp", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetCountryWithRequestIpResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetCountryWithRequestIpResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getCountryWithRequestIp", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getCountryWithRequestIp", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCountryWithRequestIp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getCountryWithRequestIp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_favorite_mids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetFavoriteMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_favorite_mids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getFavoriteMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetFavoriteMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetFavoriteMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getFavoriteMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getFavoriteMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getFavoriteMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getFavoriteMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_group<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_group(args.group_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetGroupResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetGroupResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getGroup", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getGroup", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_group_ids_invited<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetGroupIdsInvitedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_group_ids_invited() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getGroupIdsInvited", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetGroupIdsInvitedResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetGroupIdsInvitedResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getGroupIdsInvited", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getGroupIdsInvited", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getGroupIdsInvited", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getGroupIdsInvited", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_group_ids_joined<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetGroupIdsJoinedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_group_ids_joined() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getGroupIdsJoined", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetGroupIdsJoinedResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetGroupIdsJoinedResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getGroupIdsJoined", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getGroupIdsJoined", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getGroupIdsJoined", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getGroupIdsJoined", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_groups<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetGroupsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_groups(args.group_ids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getGroups", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetGroupsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetGroupsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getGroups", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getGroups", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_hidden_contact_mids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetHiddenContactMidsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_hidden_contact_mids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getHiddenContactMids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetHiddenContactMidsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetHiddenContactMidsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getHiddenContactMids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getHiddenContactMids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getHiddenContactMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getHiddenContactMids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_identity_identifier<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetIdentityIdentifierArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_identity_identifier() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getIdentityIdentifier", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetIdentityIdentifierResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetIdentityIdentifierResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getIdentityIdentifier", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getIdentityIdentifier", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getIdentityIdentifier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getIdentityIdentifier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_last_announcement_index<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetLastAnnouncementIndexArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_last_announcement_index() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getLastAnnouncementIndex", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetLastAnnouncementIndexResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetLastAnnouncementIndexResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getLastAnnouncementIndex", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getLastAnnouncementIndex", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getLastAnnouncementIndex", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getLastAnnouncementIndex", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_last_op_revision<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetLastOpRevisionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_last_op_revision() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getLastOpRevision", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetLastOpRevisionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetLastOpRevisionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getLastOpRevision", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getLastOpRevision", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getLastOpRevision", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getLastOpRevision", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_message_box<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessageBoxArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_message_box(args.channel_id, args.message_box_id, args.last_messages_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessageBox", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessageBoxResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessageBoxResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessageBox", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessageBox", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessageBox", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessageBox", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_message_box_compact_wrap_up<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessageBoxCompactWrapUpArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_message_box_compact_wrap_up(args.mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUp", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessageBoxCompactWrapUpResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessageBoxCompactWrapUpResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUp", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUp", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_message_box_compact_wrap_up_list<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessageBoxCompactWrapUpListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_message_box_compact_wrap_up_list(args.start, args.message_box_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUpList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessageBoxCompactWrapUpListResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessageBoxCompactWrapUpListResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUpList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUpList", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUpList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessageBoxCompactWrapUpList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_message_box_list<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessageBoxListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_message_box_list(args.channel_id, args.last_messages_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessageBoxList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessageBoxListResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessageBoxListResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessageBoxList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessageBoxList", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessageBoxList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessageBoxList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_message_box_list_by_status<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessageBoxListByStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_message_box_list_by_status(args.channel_id, args.last_messages_count, args.status) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessageBoxListByStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessageBoxListByStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessageBoxListByStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessageBoxListByStatus", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessageBoxListByStatus", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessageBoxListByStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessageBoxListByStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_message_box_wrap_up<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessageBoxWrapUpArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_message_box_wrap_up(args.mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessageBoxWrapUp", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessageBoxWrapUpResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessageBoxWrapUpResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessageBoxWrapUp", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessageBoxWrapUp", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessageBoxWrapUp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessageBoxWrapUp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_message_box_wrap_up_list<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessageBoxWrapUpListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_message_box_wrap_up_list(args.start, args.message_box_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessageBoxWrapUpList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessageBoxWrapUpListResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessageBoxWrapUpListResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessageBoxWrapUpList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessageBoxWrapUpList", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessageBoxWrapUpList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessageBoxWrapUpList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_messages_by_sequence_number<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetMessagesBySequenceNumberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_messages_by_sequence_number(args.channel_id, args.message_box_id, args.start_seq, args.end_seq) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMessagesBySequenceNumber", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetMessagesBySequenceNumberResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetMessagesBySequenceNumberResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMessagesBySequenceNumber", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getMessagesBySequenceNumber", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMessagesBySequenceNumber", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getMessagesBySequenceNumber", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_next_messages<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetNextMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_next_messages(args.message_box_id, args.start_seq, args.messages_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNextMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetNextMessagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetNextMessagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNextMessages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getNextMessages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNextMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getNextMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_notification_policy<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetNotificationPolicyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_notification_policy(args.carrier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNotificationPolicy", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetNotificationPolicyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetNotificationPolicyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNotificationPolicy", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getNotificationPolicy", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNotificationPolicy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getNotificationPolicy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_previous_messages<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetPreviousMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_previous_messages(args.message_box_id, args.end_seq, args.messages_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPreviousMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetPreviousMessagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetPreviousMessagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPreviousMessages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getPreviousMessages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPreviousMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getPreviousMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_profile<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_profile() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProfile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProfile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_proximity_match_candidate_list<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetProximityMatchCandidateListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_proximity_match_candidate_list(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProximityMatchCandidateList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetProximityMatchCandidateListResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetProximityMatchCandidateListResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProximityMatchCandidateList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProximityMatchCandidateList", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProximityMatchCandidateList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProximityMatchCandidateList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_proximity_match_candidates<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetProximityMatchCandidatesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_proximity_match_candidates(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProximityMatchCandidates", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetProximityMatchCandidatesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetProximityMatchCandidatesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getProximityMatchCandidates", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getProximityMatchCandidates", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProximityMatchCandidates", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getProximityMatchCandidates", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_recent_messages<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetRecentMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_recent_messages(args.message_box_id, args.messages_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getRecentMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetRecentMessagesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetRecentMessagesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getRecentMessages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getRecentMessages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getRecentMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getRecentMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_recommendation_ids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetRecommendationIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_recommendation_ids() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getRecommendationIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetRecommendationIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetRecommendationIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getRecommendationIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getRecommendationIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getRecommendationIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getRecommendationIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_room<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetRoomArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_room(args.room_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getRoom", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetRoomResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetRoomResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getRoom", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getRoom", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_r_s_a_key_info<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetRSAKeyInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_r_s_a_key_info(args.provider) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getRSAKeyInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetRSAKeyInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetRSAKeyInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getRSAKeyInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getRSAKeyInfo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getRSAKeyInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getRSAKeyInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_server_time<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetServerTimeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_server_time() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getServerTime", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetServerTimeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetServerTimeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getServerTime", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getServerTime", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getServerTime", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getServerTime", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_sessions<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetSessionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_sessions() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSessions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetSessionsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetSessionsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSessions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSessions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSessions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSessions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_settings<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_settings() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetSettingsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetSettingsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_settings_attributes<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetSettingsAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_settings_attributes(args.attr_bitset) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSettingsAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetSettingsAttributesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetSettingsAttributesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSettingsAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSettingsAttributes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSettingsAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSettingsAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_system_configuration<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetSystemConfigurationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_system_configuration() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSystemConfiguration", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetSystemConfigurationResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetSystemConfigurationResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSystemConfiguration", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getSystemConfiguration", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSystemConfiguration", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getSystemConfiguration", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_ticket<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceGetUserTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_ticket() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUserTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetUserTicketResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetUserTicketResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUserTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getUserTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_wap_invitation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceGetWapInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_wap_invitation(args.invitation_hash) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getWapInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceGetWapInvitationResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceGetWapInvitationResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("getWapInvitation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("getWapInvitation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getWapInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getWapInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_invalidate_user_ticket<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceInvalidateUserTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_invalidate_user_ticket() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("invalidateUserTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceInvalidateUserTicketResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceInvalidateUserTicketResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("invalidateUserTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("invalidateUserTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("invalidateUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("invalidateUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_invite_friends_by_sms<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceInviteFriendsBySmsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_invite_friends_by_sms(args.phone_number_list) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("inviteFriendsBySms", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceInviteFriendsBySmsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceInviteFriendsBySmsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("inviteFriendsBySms", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("inviteFriendsBySms", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("inviteFriendsBySms", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("inviteFriendsBySms", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_invite_into_group<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceInviteIntoGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_invite_into_group(args.req_seq, args.group_id, args.contact_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("inviteIntoGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceInviteIntoGroupResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceInviteIntoGroupResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("inviteIntoGroup", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("inviteIntoGroup", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("inviteIntoGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("inviteIntoGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_invite_into_room<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceInviteIntoRoomArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_invite_into_room(args.req_seq, args.room_id, args.contact_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("inviteIntoRoom", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceInviteIntoRoomResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceInviteIntoRoomResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("inviteIntoRoom", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("inviteIntoRoom", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("inviteIntoRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("inviteIntoRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_invite_via_email<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceInviteViaEmailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_invite_via_email(args.req_seq, args.email, args.name) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("inviteViaEmail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceInviteViaEmailResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceInviteViaEmailResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("inviteViaEmail", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("inviteViaEmail", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("inviteViaEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("inviteViaEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_identity_identifier_available<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceIsIdentityIdentifierAvailableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_identity_identifier_available(args.identifier, args.provider) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("isIdentityIdentifierAvailable", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceIsIdentityIdentifierAvailableResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceIsIdentityIdentifierAvailableResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("isIdentityIdentifierAvailable", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("isIdentityIdentifierAvailable", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("isIdentityIdentifierAvailable", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("isIdentityIdentifierAvailable", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_userid_available<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceIsUseridAvailableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_userid_available(args.userid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("isUseridAvailable", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceIsUseridAvailableResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceIsUseridAvailableResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("isUseridAvailable", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("isUseridAvailable", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("isUseridAvailable", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("isUseridAvailable", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_kickout_from_group<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceKickoutFromGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_kickout_from_group(args.req_seq, args.group_id, args.contact_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("kickoutFromGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceKickoutFromGroupResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceKickoutFromGroupResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("kickoutFromGroup", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("kickoutFromGroup", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("kickoutFromGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("kickoutFromGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_leave_group<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLeaveGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_leave_group(args.req_seq, args.group_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("leaveGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLeaveGroupResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLeaveGroupResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("leaveGroup", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("leaveGroup", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("leaveGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("leaveGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_leave_room<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLeaveRoomArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_leave_room(args.req_seq, args.room_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("leaveRoom", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLeaveRoomResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLeaveRoomResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("leaveRoom", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("leaveRoom", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("leaveRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("leaveRoom", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_login_with_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLoginWithIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_login_with_identity_credential(args.identifier, args.password, args.keep_logged_in, args.access_location, args.system_name, args.identity_provider, args.certificate) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("loginWithIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLoginWithIdentityCredentialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLoginWithIdentityCredentialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("loginWithIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("loginWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("loginWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("loginWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_login_with_identity_credential_for_certificate<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLoginWithIdentityCredentialForCertificateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_login_with_identity_credential_for_certificate(args.identifier, args.password, args.keep_logged_in, args.access_location, args.system_name, args.identity_provider, args.certificate) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("loginWithIdentityCredentialForCertificate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLoginWithIdentityCredentialForCertificateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLoginWithIdentityCredentialForCertificateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("loginWithIdentityCredentialForCertificate", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("loginWithIdentityCredentialForCertificate", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("loginWithIdentityCredentialForCertificate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("loginWithIdentityCredentialForCertificate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_login_with_verifier<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLoginWithVerifierArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_login_with_verifier(args.verifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("loginWithVerifier", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLoginWithVerifierResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLoginWithVerifierResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("loginWithVerifier", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("loginWithVerifier", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("loginWithVerifier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("loginWithVerifier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_login_with_verifier_for_cerificate<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLoginWithVerifierForCerificateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_login_with_verifier_for_cerificate(args.verifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("loginWithVerifierForCerificate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLoginWithVerifierForCerificateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLoginWithVerifierForCerificateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("loginWithVerifierForCerificate", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("loginWithVerifierForCerificate", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("loginWithVerifierForCerificate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("loginWithVerifierForCerificate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_login_with_verifier_for_certificate<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLoginWithVerifierForCertificateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_login_with_verifier_for_certificate(args.verifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("loginWithVerifierForCertificate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLoginWithVerifierForCertificateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLoginWithVerifierForCertificateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("loginWithVerifierForCertificate", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("loginWithVerifierForCertificate", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("loginWithVerifierForCertificate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("loginWithVerifierForCertificate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_logout<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceLogoutArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_logout() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("logout", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLogoutResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLogoutResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("logout", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("logout", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("logout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("logout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_logout_session<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceLogoutSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_logout_session(args.token_key) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("logoutSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceLogoutSessionResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceLogoutSessionResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("logoutSession", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("logoutSession", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("logoutSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("logoutSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_noop<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceNoopArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_noop() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("noop", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNoopResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceNoopResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("noop", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("noop", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("noop", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("noop", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notified_redirect<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceNotifiedRedirectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notified_redirect(args.param_map) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifiedRedirect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNotifiedRedirectResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceNotifiedRedirectResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifiedRedirect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifiedRedirect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifiedRedirect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifiedRedirect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_buddy_on_air<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceNotifyBuddyOnAirArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_buddy_on_air(args.seq, args.receiver_mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("notifyBuddyOnAir", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNotifyBuddyOnAirResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceNotifyBuddyOnAirResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifyBuddyOnAir", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifyBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyBuddyOnAir", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_individual_event<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceNotifyIndividualEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_individual_event(args.notification_status, args.receiver_mids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifyIndividualEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNotifyIndividualEventResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceNotifyIndividualEventResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifyIndividualEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifyIndividualEvent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyIndividualEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyIndividualEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_installed<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceNotifyInstalledArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_installed(args.udid_hash, args.application_type_with_extensions) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifyInstalled", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNotifyInstalledResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyInstalled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyInstalled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_registration_complete<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceNotifyRegistrationCompleteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_registration_complete(args.udid_hash, args.application_type_with_extensions) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifyRegistrationComplete", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNotifyRegistrationCompleteResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyRegistrationComplete", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyRegistrationComplete", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_sleep<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceNotifySleepArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_sleep(args.last_rev, args.badge) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifySleep", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNotifySleepResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceNotifySleepResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifySleep", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifySleep", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifySleep", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifySleep", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_notify_updated<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceNotifyUpdatedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify_updated(args.last_rev, args.device_info) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notifyUpdated", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceNotifyUpdatedResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceNotifyUpdatedResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notifyUpdated", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notifyUpdated", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notifyUpdated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notifyUpdated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_open_proximity_match<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceOpenProximityMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_open_proximity_match(args.location) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("openProximityMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceOpenProximityMatchResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceOpenProximityMatchResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("openProximityMatch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("openProximityMatch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("openProximityMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("openProximityMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_buddy_user<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterBuddyUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_buddy_user(args.buddy_id, args.registrar_password) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerBuddyUser", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterBuddyUserResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterBuddyUserResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerBuddyUser", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerBuddyUser", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerBuddyUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerBuddyUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_buddy_userid<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterBuddyUseridArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_buddy_userid(args.seq, args.userid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("registerBuddyUserid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterBuddyUseridResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterBuddyUseridResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerBuddyUserid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerBuddyUserid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerBuddyUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerBuddyUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_device<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_device(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterDeviceResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterDeviceResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerDevice", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerDevice", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_device_with_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterDeviceWithIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_device_with_identity_credential(args.session_id, args.identifier, args.verifier, args.provider) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerDeviceWithIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterDeviceWithIdentityCredentialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterDeviceWithIdentityCredentialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerDeviceWithIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerDeviceWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerDeviceWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerDeviceWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_device_without_phone_number<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterDeviceWithoutPhoneNumberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_device_without_phone_number(args.region, args.udid_hash, args.device_info) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumber", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterDeviceWithoutPhoneNumberResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterDeviceWithoutPhoneNumberResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumber", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumber", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumber", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumber", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_device_without_phone_number_with_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_device_without_phone_number_with_identity_credential(args.region, args.udid_hash, args.device_info, args.provider, args.identifier, args.verifier, args.mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_userid<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterUseridArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_userid(args.req_seq, args.userid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerUserid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterUseridResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterUseridResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerUserid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerUserid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerUserid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_wap_device<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterWapDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_wap_device(args.invitation_hash, args.guid_hash, args.email, args.device_info) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerWapDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterWapDeviceResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterWapDeviceResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerWapDevice", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerWapDevice", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerWapDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerWapDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_with_existing_sns_id_and_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_with_existing_sns_id_and_identity_credential(args.identity_credential, args.region, args.udid_hash, args.device_info) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerWithExistingSnsIdAndIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerWithExistingSnsIdAndIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerWithExistingSnsIdAndIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerWithExistingSnsIdAndIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerWithExistingSnsIdAndIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_with_sns_id<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterWithSnsIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_with_sns_id(args.sns_id_type, args.sns_access_token, args.region, args.udid_hash, args.device_info, args.mid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerWithSnsId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterWithSnsIdResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterWithSnsIdResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerWithSnsId", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerWithSnsId", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerWithSnsId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerWithSnsId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_with_sns_id_and_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_with_sns_id_and_identity_credential(args.sns_id_type, args.sns_access_token, args.identity_credential, args.region, args.udid_hash, args.device_info) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerWithSnsIdAndIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRegisterWithSnsIdAndIdentityCredentialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRegisterWithSnsIdAndIdentityCredentialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("registerWithSnsIdAndIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("registerWithSnsIdAndIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerWithSnsIdAndIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("registerWithSnsIdAndIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reissue_device_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceReissueDeviceCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reissue_device_credential() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("reissueDeviceCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReissueDeviceCredentialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReissueDeviceCredentialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reissueDeviceCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reissueDeviceCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reissueDeviceCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reissueDeviceCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reissue_user_ticket<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReissueUserTicketArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reissue_user_ticket(args.expiration_time, args.max_use_count) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("reissueUserTicket", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReissueUserTicketResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReissueUserTicketResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reissueUserTicket", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reissueUserTicket", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reissueUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reissueUserTicket", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reject_group_invitation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRejectGroupInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reject_group_invitation(args.req_seq, args.group_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("rejectGroupInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRejectGroupInvitationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRejectGroupInvitationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("rejectGroupInvitation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("rejectGroupInvitation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("rejectGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("rejectGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_release_session<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceReleaseSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_release_session() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("releaseSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReleaseSessionResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReleaseSessionResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("releaseSession", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("releaseSession", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("releaseSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("releaseSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_all_messages<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRemoveAllMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_all_messages(args.seq, args.last_message_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("removeAllMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRemoveAllMessagesResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRemoveAllMessagesResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeAllMessages", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeAllMessages", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeAllMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeAllMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_buddy_location<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRemoveBuddyLocationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_buddy_location(args.mid, args.index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("removeBuddyLocation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRemoveBuddyLocationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRemoveBuddyLocationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeBuddyLocation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeBuddyLocation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeBuddyLocation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeBuddyLocation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_message<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRemoveMessageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_message(args.message_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("removeMessage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRemoveMessageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRemoveMessageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeMessage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeMessage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_message_from_my_home<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRemoveMessageFromMyHomeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_message_from_my_home(args.message_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("removeMessageFromMyHome", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRemoveMessageFromMyHomeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRemoveMessageFromMyHomeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeMessageFromMyHome", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeMessageFromMyHome", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeMessageFromMyHome", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeMessageFromMyHome", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_sns_id<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRemoveSnsIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_sns_id(args.sns_id_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("removeSnsId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRemoveSnsIdResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRemoveSnsIdResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeSnsId", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("removeSnsId", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeSnsId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("removeSnsId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_report<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReportArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_report(args.sync_op_revision, args.category, args.report) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("report", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReportResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReportResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("report", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("report", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("report", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("report", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_report_contacts<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReportContactsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_report_contacts(args.sync_op_revision, args.category, args.contact_reports, args.action_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("reportContacts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReportContactsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReportContactsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reportContacts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reportContacts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reportContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reportContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_report_groups<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReportGroupsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_report_groups(args.sync_op_revision, args.groups) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("reportGroups", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReportGroupsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReportGroupsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reportGroups", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reportGroups", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reportGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reportGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_report_profile<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReportProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_report_profile(args.sync_op_revision, args.profile) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("reportProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReportProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReportProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reportProfile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reportProfile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reportProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reportProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_report_rooms<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReportRoomsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_report_rooms(args.sync_op_revision, args.rooms) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("reportRooms", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReportRoomsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReportRoomsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reportRooms", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reportRooms", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reportRooms", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reportRooms", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_report_settings<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReportSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_report_settings(args.sync_op_revision, args.settings) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("reportSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReportSettingsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReportSettingsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reportSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reportSettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reportSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reportSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_report_spammer<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceReportSpammerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_report_spammer(args.spammer_mid, args.spammer_reasons, args.spam_message_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("reportSpammer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceReportSpammerResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceReportSpammerResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("reportSpammer", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("reportSpammer", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("reportSpammer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("reportSpammer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_account_password_reset<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRequestAccountPasswordResetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_account_password_reset(args.identifier, args.provider, args.locale) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("requestAccountPasswordReset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRequestAccountPasswordResetResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRequestAccountPasswordResetResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("requestAccountPasswordReset", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("requestAccountPasswordReset", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestAccountPasswordReset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("requestAccountPasswordReset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_email_confirmation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRequestEmailConfirmationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_email_confirmation(args.email_confirmation) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("requestEmailConfirmation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRequestEmailConfirmationResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRequestEmailConfirmationResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("requestEmailConfirmation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("requestEmailConfirmation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestEmailConfirmation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("requestEmailConfirmation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_identity_unbind<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceRequestIdentityUnbindArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_identity_unbind(args.identifier, args.provider) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("requestIdentityUnbind", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceRequestIdentityUnbindResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceRequestIdentityUnbindResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("requestIdentityUnbind", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("requestIdentityUnbind", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestIdentityUnbind", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("requestIdentityUnbind", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_resend_email_confirmation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceResendEmailConfirmationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_resend_email_confirmation(args.verifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("resendEmailConfirmation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceResendEmailConfirmationResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceResendEmailConfirmationResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("resendEmailConfirmation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("resendEmailConfirmation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("resendEmailConfirmation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("resendEmailConfirmation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_resend_pin_code<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceResendPinCodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_resend_pin_code(args.session_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("resendPinCode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceResendPinCodeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceResendPinCodeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("resendPinCode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("resendPinCode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("resendPinCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("resendPinCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_resend_pin_code_by_s_m_s<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceResendPinCodeBySMSArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_resend_pin_code_by_s_m_s(args.session_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("resendPinCodeBySMS", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceResendPinCodeBySMSResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceResendPinCodeBySMSResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("resendPinCodeBySMS", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("resendPinCodeBySMS", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("resendPinCodeBySMS", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("resendPinCodeBySMS", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_chat_checked<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendChatCheckedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_chat_checked(args.seq, args.consumer, args.last_message_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendChatChecked", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendChatCheckedResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendChatCheckedResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendChatChecked", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendChatChecked", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendChatChecked", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendChatChecked", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_chat_removed<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendChatRemovedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_chat_removed(args.seq, args.consumer, args.last_message_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendChatRemoved", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendChatRemovedResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendChatRemovedResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendChatRemoved", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendChatRemoved", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendChatRemoved", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendChatRemoved", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_content_preview_updated<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendContentPreviewUpdatedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_content_preview_updated(args.esq, args.message_id, args.receiver_mids) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendContentPreviewUpdated", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendContentPreviewUpdatedResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendContentPreviewUpdatedResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendContentPreviewUpdated", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendContentPreviewUpdated", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendContentPreviewUpdated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendContentPreviewUpdated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_content_receipt<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendContentReceiptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_content_receipt(args.seq, args.consumer, args.message_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendContentReceipt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendContentReceiptResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendContentReceiptResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendContentReceipt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendContentReceipt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendContentReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendContentReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_dummy_push<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceSendDummyPushArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_dummy_push() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendDummyPush", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendDummyPushResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendDummyPushResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendDummyPush", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendDummyPush", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendDummyPush", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendDummyPush", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_event<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_event(args.seq, args.message) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendEventResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendEventResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendEvent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_message<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendMessageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_message(args.seq, args.message) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendMessage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendMessageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendMessageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendMessage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendMessage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_message_ignored<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendMessageIgnoredArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_message_ignored(args.seq, args.consumer, args.message_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendMessageIgnored", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendMessageIgnoredResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendMessageIgnoredResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendMessageIgnored", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendMessageIgnored", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendMessageIgnored", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendMessageIgnored", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_message_receipt<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendMessageReceiptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_message_receipt(args.seq, args.consumer, args.message_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sendMessageReceipt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendMessageReceiptResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendMessageReceiptResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendMessageReceipt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendMessageReceipt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendMessageReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendMessageReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_message_to_my_home<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSendMessageToMyHomeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_message_to_my_home(args.seq, args.message) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sendMessageToMyHome", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSendMessageToMyHomeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSendMessageToMyHomeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sendMessageToMyHome", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sendMessageToMyHome", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sendMessageToMyHome", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sendMessageToMyHome", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_buddy_location<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSetBuddyLocationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_buddy_location(args.mid, args.index, args.location) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("setBuddyLocation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSetBuddyLocationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSetBuddyLocationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("setBuddyLocation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("setBuddyLocation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setBuddyLocation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("setBuddyLocation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSetIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_identity_credential(args.identifier, args.verifier, args.provider) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("setIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSetIdentityCredentialResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSetIdentityCredentialResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("setIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("setIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("setIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_notifications_enabled<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSetNotificationsEnabledArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_notifications_enabled(args.req_seq, args.type_, args.target, args.enablement) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("setNotificationsEnabled", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSetNotificationsEnabledResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSetNotificationsEnabledResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("setNotificationsEnabled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("setNotificationsEnabled", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setNotificationsEnabled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("setNotificationsEnabled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_update_verification<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceStartUpdateVerificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_update_verification(args.region, args.carrier, args.phone, args.udid_hash, args.device_info, args.network_code, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("startUpdateVerification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceStartUpdateVerificationResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceStartUpdateVerificationResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("startUpdateVerification", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("startUpdateVerification", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("startUpdateVerification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("startUpdateVerification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_verification<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceStartVerificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_verification(args.region, args.carrier, args.phone, args.udid_hash, args.device_info, args.network_code, args.mid, args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("startVerification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceStartVerificationResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceStartVerificationResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("startVerification", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("startVerification", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("startVerification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("startVerification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_store_update_profile_attribute<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceStoreUpdateProfileAttributeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_store_update_profile_attribute(args.seq, args.profile_attribute, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("storeUpdateProfileAttribute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceStoreUpdateProfileAttributeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceStoreUpdateProfileAttributeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("storeUpdateProfileAttribute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("storeUpdateProfileAttribute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("storeUpdateProfileAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("storeUpdateProfileAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sync_contact_by_sns_ids<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSyncContactBySnsIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sync_contact_by_sns_ids(args.req_seq, args.modifications) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("syncContactBySnsIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSyncContactBySnsIdsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSyncContactBySnsIdsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("syncContactBySnsIds", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("syncContactBySnsIds", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("syncContactBySnsIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("syncContactBySnsIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sync_contacts<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceSyncContactsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sync_contacts(args.req_seq, args.local_contacts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("syncContacts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceSyncContactsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceSyncContactsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("syncContacts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("syncContacts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("syncContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("syncContacts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_try_send_message<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceTrySendMessageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_try_send_message(args.seq, args.message) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("trySendMessage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceTrySendMessageResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceTrySendMessageResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("trySendMessage", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("trySendMessage", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("trySendMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("trySendMessage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unblock_contact<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUnblockContactArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unblock_contact(args.req_seq, args.id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unblockContact", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUnblockContactResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUnblockContactResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unblockContact", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unblockContact", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unblockContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unblockContact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unblock_recommendation<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUnblockRecommendationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unblock_recommendation(args.req_seq, args.id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unblockRecommendation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUnblockRecommendationResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUnblockRecommendationResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unblockRecommendation", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unblockRecommendation", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unblockRecommendation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unblockRecommendation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unregister_user_and_device<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TalkServiceUnregisterUserAndDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unregister_user_and_device() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("unregisterUserAndDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUnregisterUserAndDeviceResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUnregisterUserAndDeviceResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unregisterUserAndDevice", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unregisterUserAndDevice", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unregisterUserAndDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unregisterUserAndDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_apns_device_token<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateApnsDeviceTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_apns_device_token(args.apns_device_token) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateApnsDeviceToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateApnsDeviceTokenResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateApnsDeviceTokenResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateApnsDeviceToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateApnsDeviceToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateApnsDeviceToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateApnsDeviceToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_buddy_setting<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateBuddySettingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_buddy_setting(args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateBuddySetting", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateBuddySettingResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateBuddySettingResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBuddySetting", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBuddySetting", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBuddySetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBuddySetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_c2_d_m_registration_id<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateC2DMRegistrationIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_c2_d_m_registration_id(args.registration_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateC2DMRegistrationId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateC2DMRegistrationIdResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateC2DMRegistrationIdResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateC2DMRegistrationId", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateC2DMRegistrationId", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateC2DMRegistrationId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateC2DMRegistrationId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_contact_setting<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateContactSettingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_contact_setting(args.req_seq, args.mid, args.flag, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateContactSetting", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateContactSettingResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateContactSettingResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateContactSetting", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateContactSetting", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateContactSetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateContactSetting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_custom_mode_settings<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateCustomModeSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_custom_mode_settings(args.custom_mode, args.param_map) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateCustomModeSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateCustomModeSettingsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateCustomModeSettingsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateCustomModeSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateCustomModeSettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateCustomModeSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateCustomModeSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_device_info<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateDeviceInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_device_info(args.device_uid, args.device_info) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateDeviceInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateDeviceInfoResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateDeviceInfoResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateDeviceInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateDeviceInfo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateDeviceInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateDeviceInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_group<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_group(args.req_seq, args.group) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateGroupResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateGroupResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateGroup", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateGroup", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_notification_token<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateNotificationTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_notification_token(args.token, args.type_) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateNotificationToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateNotificationTokenResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateNotificationTokenResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateNotificationToken", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateNotificationToken", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateNotificationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateNotificationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_notification_token_with_bytes<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateNotificationTokenWithBytesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_notification_token_with_bytes(args.token, args.type_) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateNotificationTokenWithBytes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateNotificationTokenWithBytesResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateNotificationTokenWithBytesResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateNotificationTokenWithBytes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateNotificationTokenWithBytes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateNotificationTokenWithBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateNotificationTokenWithBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_profile<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_profile(args.req_seq, args.profile) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateProfile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateProfile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_profile_attribute<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateProfileAttributeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_profile_attribute(args.req_seq, args.attr, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateProfileAttribute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateProfileAttributeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateProfileAttributeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateProfileAttribute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateProfileAttribute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateProfileAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateProfileAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_region<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateRegionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_region(args.region) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateRegion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateRegionResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateRegionResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateRegion", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateRegion", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateRegion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateRegion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_settings<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_settings(args.req_seq, args.settings) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateSettingsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateSettingsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateSettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_settings2<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateSettings2Args::read_from_in_protocol(i_prot)?;
    match handler.handle_update_settings2(args.req_seq, args.settings) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateSettings2", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateSettings2Result { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateSettings2Result{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateSettings2", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateSettings2", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateSettings2", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateSettings2", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_settings_attribute<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateSettingsAttributeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_settings_attribute(args.req_seq, args.attr, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateSettingsAttribute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateSettingsAttributeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateSettingsAttributeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateSettingsAttribute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateSettingsAttribute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateSettingsAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateSettingsAttribute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_settings_attributes<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceUpdateSettingsAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_settings_attributes(args.req_seq, args.attr_bitset, args.settings) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateSettingsAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceUpdateSettingsAttributesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceUpdateSettingsAttributesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateSettingsAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updateSettingsAttributes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateSettingsAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updateSettingsAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_verify_identity_credential<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceVerifyIdentityCredentialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_verify_identity_credential(args.identifier, args.password, args.identity_provider) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("verifyIdentityCredential", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceVerifyIdentityCredentialResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceVerifyIdentityCredentialResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("verifyIdentityCredential", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("verifyIdentityCredential", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("verifyIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("verifyIdentityCredential", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_verify_identity_credential_with_result<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceVerifyIdentityCredentialWithResultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_verify_identity_credential_with_result(args.identity_credential) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("verifyIdentityCredentialWithResult", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceVerifyIdentityCredentialWithResultResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceVerifyIdentityCredentialWithResultResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("verifyIdentityCredentialWithResult", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("verifyIdentityCredentialWithResult", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("verifyIdentityCredentialWithResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("verifyIdentityCredentialWithResult", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_verify_phone<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceVerifyPhoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_verify_phone(args.session_id, args.pin_code, args.udid_hash) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("verifyPhone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceVerifyPhoneResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceVerifyPhoneResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("verifyPhone", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("verifyPhone", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("verifyPhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("verifyPhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_verify_qrcode<H: TalkServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TalkServiceVerifyQrcodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_verify_qrcode(args.verifier, args.pin_code) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("verifyQrcode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TalkServiceVerifyQrcodeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TalkException>().is_some() {
              let err = usr_err.downcast::<TalkException>().expect("downcast already checked");
              let ret_err = TalkServiceVerifyQrcodeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("verifyQrcode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("verifyQrcode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("verifyQrcode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("verifyQrcode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: TalkServiceSyncHandler> TProcessor for TalkServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "acceptGroupInvitation" => {
        self.process_accept_group_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "acceptProximityMatches" => {
        self.process_accept_proximity_matches(message_ident.sequence_number, i_prot, o_prot)
      },
      "acquireCallRoute" => {
        self.process_acquire_call_route(message_ident.sequence_number, i_prot, o_prot)
      },
      "acquireCallTicket" => {
        self.process_acquire_call_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "acquireEncryptedAccessToken" => {
        self.process_acquire_encrypted_access_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "addSnsId" => {
        self.process_add_sns_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "blockContact" => {
        self.process_block_contact(message_ident.sequence_number, i_prot, o_prot)
      },
      "blockRecommendation" => {
        self.process_block_recommendation(message_ident.sequence_number, i_prot, o_prot)
      },
      "cancelGroupInvitation" => {
        self.process_cancel_group_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "changeVerificationMethod" => {
        self.process_change_verification_method(message_ident.sequence_number, i_prot, o_prot)
      },
      "clearIdentityCredential" => {
        self.process_clear_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "clearMessageBox" => {
        self.process_clear_message_box(message_ident.sequence_number, i_prot, o_prot)
      },
      "closeProximityMatch" => {
        self.process_close_proximity_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "commitSendMessage" => {
        self.process_commit_send_message(message_ident.sequence_number, i_prot, o_prot)
      },
      "commitSendMessages" => {
        self.process_commit_send_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "commitUpdateProfile" => {
        self.process_commit_update_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "confirmEmail" => {
        self.process_confirm_email(message_ident.sequence_number, i_prot, o_prot)
      },
      "createGroup" => {
        self.process_create_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "createQrcodeBase64Image" => {
        self.process_create_qrcode_base64_image(message_ident.sequence_number, i_prot, o_prot)
      },
      "createRoom" => {
        self.process_create_room(message_ident.sequence_number, i_prot, o_prot)
      },
      "createSession" => {
        self.process_create_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchAnnouncements" => {
        self.process_fetch_announcements(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchMessages" => {
        self.process_fetch_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchOperations" => {
        self.process_fetch_operations(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchOps" => {
        self.process_fetch_ops(message_ident.sequence_number, i_prot, o_prot)
      },
      "findAndAddContactsByEmail" => {
        self.process_find_and_add_contacts_by_email(message_ident.sequence_number, i_prot, o_prot)
      },
      "findAndAddContactsByMid" => {
        self.process_find_and_add_contacts_by_mid(message_ident.sequence_number, i_prot, o_prot)
      },
      "findAndAddContactsByPhone" => {
        self.process_find_and_add_contacts_by_phone(message_ident.sequence_number, i_prot, o_prot)
      },
      "findAndAddContactsByUserid" => {
        self.process_find_and_add_contacts_by_userid(message_ident.sequence_number, i_prot, o_prot)
      },
      "findContactByUserid" => {
        self.process_find_contact_by_userid(message_ident.sequence_number, i_prot, o_prot)
      },
      "findContactByUserTicket" => {
        self.process_find_contact_by_user_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "findContactsByEmail" => {
        self.process_find_contacts_by_email(message_ident.sequence_number, i_prot, o_prot)
      },
      "findContactsByPhone" => {
        self.process_find_contacts_by_phone(message_ident.sequence_number, i_prot, o_prot)
      },
      "findSnsIdUserStatus" => {
        self.process_find_sns_id_user_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "finishUpdateVerification" => {
        self.process_finish_update_verification(message_ident.sequence_number, i_prot, o_prot)
      },
      "generateUserTicket" => {
        self.process_generate_user_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "getAcceptedProximityMatches" => {
        self.process_get_accepted_proximity_matches(message_ident.sequence_number, i_prot, o_prot)
      },
      "getActiveBuddySubscriberIds" => {
        self.process_get_active_buddy_subscriber_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getAllContactIds" => {
        self.process_get_all_contact_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getAuthQrcode" => {
        self.process_get_auth_qrcode(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBlockedContactIds" => {
        self.process_get_blocked_contact_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBlockedContactIdsByRange" => {
        self.process_get_blocked_contact_ids_by_range(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBlockedRecommendationIds" => {
        self.process_get_blocked_recommendation_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBuddyBlockerIds" => {
        self.process_get_buddy_blocker_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBuddyLocation" => {
        self.process_get_buddy_location(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCompactContactsModifiedSince" => {
        self.process_get_compact_contacts_modified_since(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCompactGroup" => {
        self.process_get_compact_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCompactRoom" => {
        self.process_get_compact_room(message_ident.sequence_number, i_prot, o_prot)
      },
      "getContact" => {
        self.process_get_contact(message_ident.sequence_number, i_prot, o_prot)
      },
      "getContacts" => {
        self.process_get_contacts(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCountryWithRequestIp" => {
        self.process_get_country_with_request_ip(message_ident.sequence_number, i_prot, o_prot)
      },
      "getFavoriteMids" => {
        self.process_get_favorite_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getGroup" => {
        self.process_get_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "getGroupIdsInvited" => {
        self.process_get_group_ids_invited(message_ident.sequence_number, i_prot, o_prot)
      },
      "getGroupIdsJoined" => {
        self.process_get_group_ids_joined(message_ident.sequence_number, i_prot, o_prot)
      },
      "getGroups" => {
        self.process_get_groups(message_ident.sequence_number, i_prot, o_prot)
      },
      "getHiddenContactMids" => {
        self.process_get_hidden_contact_mids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getIdentityIdentifier" => {
        self.process_get_identity_identifier(message_ident.sequence_number, i_prot, o_prot)
      },
      "getLastAnnouncementIndex" => {
        self.process_get_last_announcement_index(message_ident.sequence_number, i_prot, o_prot)
      },
      "getLastOpRevision" => {
        self.process_get_last_op_revision(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessageBox" => {
        self.process_get_message_box(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessageBoxCompactWrapUp" => {
        self.process_get_message_box_compact_wrap_up(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessageBoxCompactWrapUpList" => {
        self.process_get_message_box_compact_wrap_up_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessageBoxList" => {
        self.process_get_message_box_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessageBoxListByStatus" => {
        self.process_get_message_box_list_by_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessageBoxWrapUp" => {
        self.process_get_message_box_wrap_up(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessageBoxWrapUpList" => {
        self.process_get_message_box_wrap_up_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "getMessagesBySequenceNumber" => {
        self.process_get_messages_by_sequence_number(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNextMessages" => {
        self.process_get_next_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNotificationPolicy" => {
        self.process_get_notification_policy(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPreviousMessages" => {
        self.process_get_previous_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProfile" => {
        self.process_get_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProximityMatchCandidateList" => {
        self.process_get_proximity_match_candidate_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProximityMatchCandidates" => {
        self.process_get_proximity_match_candidates(message_ident.sequence_number, i_prot, o_prot)
      },
      "getRecentMessages" => {
        self.process_get_recent_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "getRecommendationIds" => {
        self.process_get_recommendation_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "getRoom" => {
        self.process_get_room(message_ident.sequence_number, i_prot, o_prot)
      },
      "getRSAKeyInfo" => {
        self.process_get_r_s_a_key_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "getServerTime" => {
        self.process_get_server_time(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSessions" => {
        self.process_get_sessions(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSettings" => {
        self.process_get_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSettingsAttributes" => {
        self.process_get_settings_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSystemConfiguration" => {
        self.process_get_system_configuration(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUserTicket" => {
        self.process_get_user_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "getWapInvitation" => {
        self.process_get_wap_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "invalidateUserTicket" => {
        self.process_invalidate_user_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "inviteFriendsBySms" => {
        self.process_invite_friends_by_sms(message_ident.sequence_number, i_prot, o_prot)
      },
      "inviteIntoGroup" => {
        self.process_invite_into_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "inviteIntoRoom" => {
        self.process_invite_into_room(message_ident.sequence_number, i_prot, o_prot)
      },
      "inviteViaEmail" => {
        self.process_invite_via_email(message_ident.sequence_number, i_prot, o_prot)
      },
      "isIdentityIdentifierAvailable" => {
        self.process_is_identity_identifier_available(message_ident.sequence_number, i_prot, o_prot)
      },
      "isUseridAvailable" => {
        self.process_is_userid_available(message_ident.sequence_number, i_prot, o_prot)
      },
      "kickoutFromGroup" => {
        self.process_kickout_from_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "leaveGroup" => {
        self.process_leave_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "leaveRoom" => {
        self.process_leave_room(message_ident.sequence_number, i_prot, o_prot)
      },
      "loginWithIdentityCredential" => {
        self.process_login_with_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "loginWithIdentityCredentialForCertificate" => {
        self.process_login_with_identity_credential_for_certificate(message_ident.sequence_number, i_prot, o_prot)
      },
      "loginWithVerifier" => {
        self.process_login_with_verifier(message_ident.sequence_number, i_prot, o_prot)
      },
      "loginWithVerifierForCerificate" => {
        self.process_login_with_verifier_for_cerificate(message_ident.sequence_number, i_prot, o_prot)
      },
      "loginWithVerifierForCertificate" => {
        self.process_login_with_verifier_for_certificate(message_ident.sequence_number, i_prot, o_prot)
      },
      "logout" => {
        self.process_logout(message_ident.sequence_number, i_prot, o_prot)
      },
      "logoutSession" => {
        self.process_logout_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "noop" => {
        self.process_noop(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifiedRedirect" => {
        self.process_notified_redirect(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyBuddyOnAir" => {
        self.process_notify_buddy_on_air(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyIndividualEvent" => {
        self.process_notify_individual_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyInstalled" => {
        self.process_notify_installed(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyRegistrationComplete" => {
        self.process_notify_registration_complete(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifySleep" => {
        self.process_notify_sleep(message_ident.sequence_number, i_prot, o_prot)
      },
      "notifyUpdated" => {
        self.process_notify_updated(message_ident.sequence_number, i_prot, o_prot)
      },
      "openProximityMatch" => {
        self.process_open_proximity_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerBuddyUser" => {
        self.process_register_buddy_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerBuddyUserid" => {
        self.process_register_buddy_userid(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerDevice" => {
        self.process_register_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerDeviceWithIdentityCredential" => {
        self.process_register_device_with_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerDeviceWithoutPhoneNumber" => {
        self.process_register_device_without_phone_number(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerDeviceWithoutPhoneNumberWithIdentityCredential" => {
        self.process_register_device_without_phone_number_with_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerUserid" => {
        self.process_register_userid(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerWapDevice" => {
        self.process_register_wap_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerWithExistingSnsIdAndIdentityCredential" => {
        self.process_register_with_existing_sns_id_and_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerWithSnsId" => {
        self.process_register_with_sns_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerWithSnsIdAndIdentityCredential" => {
        self.process_register_with_sns_id_and_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "reissueDeviceCredential" => {
        self.process_reissue_device_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "reissueUserTicket" => {
        self.process_reissue_user_ticket(message_ident.sequence_number, i_prot, o_prot)
      },
      "rejectGroupInvitation" => {
        self.process_reject_group_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "releaseSession" => {
        self.process_release_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeAllMessages" => {
        self.process_remove_all_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeBuddyLocation" => {
        self.process_remove_buddy_location(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeMessage" => {
        self.process_remove_message(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeMessageFromMyHome" => {
        self.process_remove_message_from_my_home(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeSnsId" => {
        self.process_remove_sns_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "report" => {
        self.process_report(message_ident.sequence_number, i_prot, o_prot)
      },
      "reportContacts" => {
        self.process_report_contacts(message_ident.sequence_number, i_prot, o_prot)
      },
      "reportGroups" => {
        self.process_report_groups(message_ident.sequence_number, i_prot, o_prot)
      },
      "reportProfile" => {
        self.process_report_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "reportRooms" => {
        self.process_report_rooms(message_ident.sequence_number, i_prot, o_prot)
      },
      "reportSettings" => {
        self.process_report_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "reportSpammer" => {
        self.process_report_spammer(message_ident.sequence_number, i_prot, o_prot)
      },
      "requestAccountPasswordReset" => {
        self.process_request_account_password_reset(message_ident.sequence_number, i_prot, o_prot)
      },
      "requestEmailConfirmation" => {
        self.process_request_email_confirmation(message_ident.sequence_number, i_prot, o_prot)
      },
      "requestIdentityUnbind" => {
        self.process_request_identity_unbind(message_ident.sequence_number, i_prot, o_prot)
      },
      "resendEmailConfirmation" => {
        self.process_resend_email_confirmation(message_ident.sequence_number, i_prot, o_prot)
      },
      "resendPinCode" => {
        self.process_resend_pin_code(message_ident.sequence_number, i_prot, o_prot)
      },
      "resendPinCodeBySMS" => {
        self.process_resend_pin_code_by_s_m_s(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendChatChecked" => {
        self.process_send_chat_checked(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendChatRemoved" => {
        self.process_send_chat_removed(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendContentPreviewUpdated" => {
        self.process_send_content_preview_updated(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendContentReceipt" => {
        self.process_send_content_receipt(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendDummyPush" => {
        self.process_send_dummy_push(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendEvent" => {
        self.process_send_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendMessage" => {
        self.process_send_message(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendMessageIgnored" => {
        self.process_send_message_ignored(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendMessageReceipt" => {
        self.process_send_message_receipt(message_ident.sequence_number, i_prot, o_prot)
      },
      "sendMessageToMyHome" => {
        self.process_send_message_to_my_home(message_ident.sequence_number, i_prot, o_prot)
      },
      "setBuddyLocation" => {
        self.process_set_buddy_location(message_ident.sequence_number, i_prot, o_prot)
      },
      "setIdentityCredential" => {
        self.process_set_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "setNotificationsEnabled" => {
        self.process_set_notifications_enabled(message_ident.sequence_number, i_prot, o_prot)
      },
      "startUpdateVerification" => {
        self.process_start_update_verification(message_ident.sequence_number, i_prot, o_prot)
      },
      "startVerification" => {
        self.process_start_verification(message_ident.sequence_number, i_prot, o_prot)
      },
      "storeUpdateProfileAttribute" => {
        self.process_store_update_profile_attribute(message_ident.sequence_number, i_prot, o_prot)
      },
      "syncContactBySnsIds" => {
        self.process_sync_contact_by_sns_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "syncContacts" => {
        self.process_sync_contacts(message_ident.sequence_number, i_prot, o_prot)
      },
      "trySendMessage" => {
        self.process_try_send_message(message_ident.sequence_number, i_prot, o_prot)
      },
      "unblockContact" => {
        self.process_unblock_contact(message_ident.sequence_number, i_prot, o_prot)
      },
      "unblockRecommendation" => {
        self.process_unblock_recommendation(message_ident.sequence_number, i_prot, o_prot)
      },
      "unregisterUserAndDevice" => {
        self.process_unregister_user_and_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateApnsDeviceToken" => {
        self.process_update_apns_device_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBuddySetting" => {
        self.process_update_buddy_setting(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateC2DMRegistrationId" => {
        self.process_update_c2_d_m_registration_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateContactSetting" => {
        self.process_update_contact_setting(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateCustomModeSettings" => {
        self.process_update_custom_mode_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateDeviceInfo" => {
        self.process_update_device_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateGroup" => {
        self.process_update_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateNotificationToken" => {
        self.process_update_notification_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateNotificationTokenWithBytes" => {
        self.process_update_notification_token_with_bytes(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateProfile" => {
        self.process_update_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateProfileAttribute" => {
        self.process_update_profile_attribute(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateRegion" => {
        self.process_update_region(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateSettings" => {
        self.process_update_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateSettings2" => {
        self.process_update_settings2(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateSettingsAttribute" => {
        self.process_update_settings_attribute(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateSettingsAttributes" => {
        self.process_update_settings_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "verifyIdentityCredential" => {
        self.process_verify_identity_credential(message_ident.sequence_number, i_prot, o_prot)
      },
      "verifyIdentityCredentialWithResult" => {
        self.process_verify_identity_credential_with_result(message_ident.sequence_number, i_prot, o_prot)
      },
      "verifyPhone" => {
        self.process_verify_phone(message_ident.sequence_number, i_prot, o_prot)
      },
      "verifyQrcode" => {
        self.process_verify_qrcode(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// TalkServiceAcceptGroupInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcceptGroupInvitationArgs {
  req_seq: i32,
  group_id: String,
}

impl TalkServiceAcceptGroupInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcceptGroupInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceAcceptGroupInvitationArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceAcceptGroupInvitationArgs.group_id", &f_2)?;
    let ret = TalkServiceAcceptGroupInvitationArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("acceptGroupInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceAcceptGroupInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcceptGroupInvitationResult {
  e: Option<TalkException>,
}

impl TalkServiceAcceptGroupInvitationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcceptGroupInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceAcceptGroupInvitationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceAcceptGroupInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceAcceptProximityMatchesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcceptProximityMatchesArgs {
  session_id: String,
  ids: BTreeSet<String>,
}

impl TalkServiceAcceptProximityMatchesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcceptProximityMatchesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeSet<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_115 = i_prot.read_string()?;
            val.insert(set_elem_115);
          }
          i_prot.read_set_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceAcceptProximityMatchesArgs.session_id", &f_2)?;
    verify_required_field_exists("TalkServiceAcceptProximityMatchesArgs.ids", &f_3)?;
    let ret = TalkServiceAcceptProximityMatchesArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("acceptProximityMatches_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ids", TType::Set, 3))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::String, self.ids.len() as i32))?;
    for e in &self.ids {
      o_prot.write_string(e)?;
      o_prot.write_set_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceAcceptProximityMatchesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcceptProximityMatchesResult {
  e: Option<TalkException>,
}

impl TalkServiceAcceptProximityMatchesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcceptProximityMatchesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceAcceptProximityMatchesResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceAcceptProximityMatchesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceAcquireCallRouteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcquireCallRouteArgs {
  to: String,
}

impl TalkServiceAcquireCallRouteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcquireCallRouteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceAcquireCallRouteArgs.to", &f_2)?;
    let ret = TalkServiceAcquireCallRouteArgs {
      to: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("acquireCallRoute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("to", TType::String, 2))?;
    o_prot.write_string(&self.to)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceAcquireCallRouteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcquireCallRouteResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceAcquireCallRouteResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcquireCallRouteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_116 = i_prot.read_string()?;
            val.push(list_elem_116);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceAcquireCallRouteResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceAcquireCallRouteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceAcquireCallRoute"
          )
        )
      )
    }
  }
}

//
// TalkServiceAcquireCallTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcquireCallTicketArgs {
  to: String,
}

impl TalkServiceAcquireCallTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcquireCallTicketArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceAcquireCallTicketArgs.to", &f_2)?;
    let ret = TalkServiceAcquireCallTicketArgs {
      to: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("acquireCallTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("to", TType::String, 2))?;
    o_prot.write_string(&self.to)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceAcquireCallTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcquireCallTicketResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceAcquireCallTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcquireCallTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceAcquireCallTicketResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceAcquireCallTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceAcquireCallTicket"
          )
        )
      )
    }
  }
}

//
// TalkServiceAcquireEncryptedAccessTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcquireEncryptedAccessTokenArgs {
  feature_type: FeatureType,
}

impl TalkServiceAcquireEncryptedAccessTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcquireEncryptedAccessTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<FeatureType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = FeatureType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceAcquireEncryptedAccessTokenArgs.feature_type", &f_2)?;
    let ret = TalkServiceAcquireEncryptedAccessTokenArgs {
      feature_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("acquireEncryptedAccessToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("featureType", TType::I32, 2))?;
    self.feature_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceAcquireEncryptedAccessTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAcquireEncryptedAccessTokenResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceAcquireEncryptedAccessTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAcquireEncryptedAccessTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceAcquireEncryptedAccessTokenResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceAcquireEncryptedAccessTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceAcquireEncryptedAccessToken"
          )
        )
      )
    }
  }
}

//
// TalkServiceAddSnsIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAddSnsIdArgs {
  sns_id_type: SnsIdType,
  sns_access_token: String,
}

impl TalkServiceAddSnsIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAddSnsIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceAddSnsIdArgs.sns_id_type", &f_2)?;
    verify_required_field_exists("TalkServiceAddSnsIdArgs.sns_access_token", &f_3)?;
    let ret = TalkServiceAddSnsIdArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sns_access_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("addSnsId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsAccessToken", TType::String, 3))?;
    o_prot.write_string(&self.sns_access_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceAddSnsIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceAddSnsIdResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceAddSnsIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceAddSnsIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceAddSnsIdResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceAddSnsIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceAddSnsId"
          )
        )
      )
    }
  }
}

//
// TalkServiceBlockContactArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceBlockContactArgs {
  req_seq: i32,
  id: String,
}

impl TalkServiceBlockContactArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceBlockContactArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceBlockContactArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceBlockContactArgs.id", &f_2)?;
    let ret = TalkServiceBlockContactArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("blockContact_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 2))?;
    o_prot.write_string(&self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceBlockContactResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceBlockContactResult {
  e: Option<TalkException>,
}

impl TalkServiceBlockContactResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceBlockContactResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceBlockContactResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceBlockContactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceBlockRecommendationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceBlockRecommendationArgs {
  req_seq: i32,
  id: String,
}

impl TalkServiceBlockRecommendationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceBlockRecommendationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceBlockRecommendationArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceBlockRecommendationArgs.id", &f_2)?;
    let ret = TalkServiceBlockRecommendationArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("blockRecommendation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 2))?;
    o_prot.write_string(&self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceBlockRecommendationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceBlockRecommendationResult {
  e: Option<TalkException>,
}

impl TalkServiceBlockRecommendationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceBlockRecommendationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceBlockRecommendationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceBlockRecommendationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceCancelGroupInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCancelGroupInvitationArgs {
  req_seq: i32,
  group_id: String,
  contact_ids: Vec<String>,
}

impl TalkServiceCancelGroupInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCancelGroupInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_117 = i_prot.read_string()?;
            val.push(list_elem_117);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCancelGroupInvitationArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceCancelGroupInvitationArgs.group_id", &f_2)?;
    verify_required_field_exists("TalkServiceCancelGroupInvitationArgs.contact_ids", &f_3)?;
    let ret = TalkServiceCancelGroupInvitationArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      contact_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cancelGroupInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.contact_ids.len() as i32))?;
    for e in &self.contact_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCancelGroupInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCancelGroupInvitationResult {
  e: Option<TalkException>,
}

impl TalkServiceCancelGroupInvitationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCancelGroupInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCancelGroupInvitationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCancelGroupInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceChangeVerificationMethodArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceChangeVerificationMethodArgs {
  session_id: String,
  method: VerificationMethod,
}

impl TalkServiceChangeVerificationMethodArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceChangeVerificationMethodArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<VerificationMethod> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = VerificationMethod::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceChangeVerificationMethodArgs.session_id", &f_2)?;
    verify_required_field_exists("TalkServiceChangeVerificationMethodArgs.method", &f_3)?;
    let ret = TalkServiceChangeVerificationMethodArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      method: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("changeVerificationMethod_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("method", TType::I32, 3))?;
    self.method.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceChangeVerificationMethodResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceChangeVerificationMethodResult {
  result_value: Option<VerificationSessionData>,
  e: Option<TalkException>,
}

impl TalkServiceChangeVerificationMethodResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceChangeVerificationMethodResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<VerificationSessionData> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = VerificationSessionData::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceChangeVerificationMethodResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceChangeVerificationMethodResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<VerificationSessionData> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceChangeVerificationMethod"
          )
        )
      )
    }
  }
}

//
// TalkServiceClearIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceClearIdentityCredentialArgs {
}

impl TalkServiceClearIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceClearIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceClearIdentityCredentialArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clearIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceClearIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceClearIdentityCredentialResult {
  e: Option<TalkException>,
}

impl TalkServiceClearIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceClearIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceClearIdentityCredentialResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceClearIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceClearMessageBoxArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceClearMessageBoxArgs {
  channel_id: String,
  message_box_id: String,
}

impl TalkServiceClearMessageBoxArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceClearMessageBoxArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceClearMessageBoxArgs.channel_id", &f_2)?;
    verify_required_field_exists("TalkServiceClearMessageBoxArgs.message_box_id", &f_3)?;
    let ret = TalkServiceClearMessageBoxArgs {
      channel_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_box_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clearMessageBox_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 2))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxId", TType::String, 3))?;
    o_prot.write_string(&self.message_box_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceClearMessageBoxResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceClearMessageBoxResult {
  e: Option<TalkException>,
}

impl TalkServiceClearMessageBoxResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceClearMessageBoxResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceClearMessageBoxResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceClearMessageBoxResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceCloseProximityMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCloseProximityMatchArgs {
  session_id: String,
}

impl TalkServiceCloseProximityMatchArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCloseProximityMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCloseProximityMatchArgs.session_id", &f_2)?;
    let ret = TalkServiceCloseProximityMatchArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("closeProximityMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCloseProximityMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCloseProximityMatchResult {
  e: Option<TalkException>,
}

impl TalkServiceCloseProximityMatchResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCloseProximityMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCloseProximityMatchResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCloseProximityMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceCommitSendMessageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCommitSendMessageArgs {
  seq: i32,
  message_id: String,
  receiver_mids: Vec<String>,
}

impl TalkServiceCommitSendMessageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCommitSendMessageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_118 = i_prot.read_string()?;
            val.push(list_elem_118);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCommitSendMessageArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceCommitSendMessageArgs.message_id", &f_2)?;
    verify_required_field_exists("TalkServiceCommitSendMessageArgs.receiver_mids", &f_3)?;
    let ret = TalkServiceCommitSendMessageArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      receiver_mids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("commitSendMessage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 2))?;
    o_prot.write_string(&self.message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMids", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.receiver_mids.len() as i32))?;
    for e in &self.receiver_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCommitSendMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCommitSendMessageResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TalkException>,
}

impl TalkServiceCommitSendMessageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCommitSendMessageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_119 = i_prot.read_string()?;
            let map_val_120 = i_prot.read_string()?;
            val.insert(map_key_119, map_val_120);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCommitSendMessageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCommitSendMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceCommitSendMessage"
          )
        )
      )
    }
  }
}

//
// TalkServiceCommitSendMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCommitSendMessagesArgs {
  seq: i32,
  message_ids: Vec<String>,
  receiver_mids: Vec<String>,
}

impl TalkServiceCommitSendMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCommitSendMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_121 = i_prot.read_string()?;
            val.push(list_elem_121);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_122 = i_prot.read_string()?;
            val.push(list_elem_122);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCommitSendMessagesArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceCommitSendMessagesArgs.message_ids", &f_2)?;
    verify_required_field_exists("TalkServiceCommitSendMessagesArgs.receiver_mids", &f_3)?;
    let ret = TalkServiceCommitSendMessagesArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
      receiver_mids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("commitSendMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageIds", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.message_ids.len() as i32))?;
    for e in &self.message_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMids", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.receiver_mids.len() as i32))?;
    for e in &self.receiver_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCommitSendMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCommitSendMessagesResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TalkException>,
}

impl TalkServiceCommitSendMessagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCommitSendMessagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_123 = i_prot.read_string()?;
            let map_val_124 = i_prot.read_string()?;
            val.insert(map_key_123, map_val_124);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCommitSendMessagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCommitSendMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceCommitSendMessages"
          )
        )
      )
    }
  }
}

//
// TalkServiceCommitUpdateProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCommitUpdateProfileArgs {
  seq: i32,
  attrs: Vec<ProfileAttribute>,
  receiver_mids: Vec<String>,
}

impl TalkServiceCommitUpdateProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCommitUpdateProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<ProfileAttribute>> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ProfileAttribute> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_125 = ProfileAttribute::read_from_in_protocol(i_prot)?;
            val.push(list_elem_125);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_126 = i_prot.read_string()?;
            val.push(list_elem_126);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCommitUpdateProfileArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceCommitUpdateProfileArgs.attrs", &f_2)?;
    verify_required_field_exists("TalkServiceCommitUpdateProfileArgs.receiver_mids", &f_3)?;
    let ret = TalkServiceCommitUpdateProfileArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      attrs: f_2.expect("auto-generated code should have checked for presence of required fields"),
      receiver_mids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("commitUpdateProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attrs", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.attrs.len() as i32))?;
    for e in &self.attrs {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMids", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.receiver_mids.len() as i32))?;
    for e in &self.receiver_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCommitUpdateProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCommitUpdateProfileResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TalkException>,
}

impl TalkServiceCommitUpdateProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCommitUpdateProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_127 = i_prot.read_string()?;
            let map_val_128 = i_prot.read_string()?;
            val.insert(map_key_127, map_val_128);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCommitUpdateProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCommitUpdateProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceCommitUpdateProfile"
          )
        )
      )
    }
  }
}

//
// TalkServiceConfirmEmailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceConfirmEmailArgs {
  verifier: String,
  pin_code: String,
}

impl TalkServiceConfirmEmailArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceConfirmEmailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceConfirmEmailArgs.verifier", &f_2)?;
    verify_required_field_exists("TalkServiceConfirmEmailArgs.pin_code", &f_3)?;
    let ret = TalkServiceConfirmEmailArgs {
      verifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pin_code: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("confirmEmail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 2))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pinCode", TType::String, 3))?;
    o_prot.write_string(&self.pin_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceConfirmEmailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceConfirmEmailResult {
  e: Option<TalkException>,
}

impl TalkServiceConfirmEmailResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceConfirmEmailResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceConfirmEmailResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceConfirmEmailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceCreateGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateGroupArgs {
  seq: i32,
  name: String,
  contact_ids: Vec<String>,
}

impl TalkServiceCreateGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_129 = i_prot.read_string()?;
            val.push(list_elem_129);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCreateGroupArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceCreateGroupArgs.name", &f_2)?;
    verify_required_field_exists("TalkServiceCreateGroupArgs.contact_ids", &f_3)?;
    let ret = TalkServiceCreateGroupArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      contact_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.contact_ids.len() as i32))?;
    for e in &self.contact_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCreateGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateGroupResult {
  result_value: Option<Group>,
  e: Option<TalkException>,
}

impl TalkServiceCreateGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Group> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Group::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCreateGroupResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCreateGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Group> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceCreateGroup"
          )
        )
      )
    }
  }
}

//
// TalkServiceCreateQrcodeBase64ImageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateQrcodeBase64ImageArgs {
  url: String,
  character_set: String,
  image_size: i32,
  x: i32,
  y: i32,
  width: i32,
  height: i32,
}

impl TalkServiceCreateQrcodeBase64ImageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateQrcodeBase64ImageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCreateQrcodeBase64ImageArgs.url", &f_2)?;
    verify_required_field_exists("TalkServiceCreateQrcodeBase64ImageArgs.character_set", &f_3)?;
    verify_required_field_exists("TalkServiceCreateQrcodeBase64ImageArgs.image_size", &f_4)?;
    verify_required_field_exists("TalkServiceCreateQrcodeBase64ImageArgs.x", &f_5)?;
    verify_required_field_exists("TalkServiceCreateQrcodeBase64ImageArgs.y", &f_6)?;
    verify_required_field_exists("TalkServiceCreateQrcodeBase64ImageArgs.width", &f_7)?;
    verify_required_field_exists("TalkServiceCreateQrcodeBase64ImageArgs.height", &f_8)?;
    let ret = TalkServiceCreateQrcodeBase64ImageArgs {
      url: f_2.expect("auto-generated code should have checked for presence of required fields"),
      character_set: f_3.expect("auto-generated code should have checked for presence of required fields"),
      image_size: f_4.expect("auto-generated code should have checked for presence of required fields"),
      x: f_5.expect("auto-generated code should have checked for presence of required fields"),
      y: f_6.expect("auto-generated code should have checked for presence of required fields"),
      width: f_7.expect("auto-generated code should have checked for presence of required fields"),
      height: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createQrcodeBase64Image_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("url", TType::String, 2))?;
    o_prot.write_string(&self.url)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("characterSet", TType::String, 3))?;
    o_prot.write_string(&self.character_set)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("imageSize", TType::I32, 4))?;
    o_prot.write_i32(self.image_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("x", TType::I32, 5))?;
    o_prot.write_i32(self.x)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("y", TType::I32, 6))?;
    o_prot.write_i32(self.y)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("width", TType::I32, 7))?;
    o_prot.write_i32(self.width)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("height", TType::I32, 8))?;
    o_prot.write_i32(self.height)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCreateQrcodeBase64ImageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateQrcodeBase64ImageResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceCreateQrcodeBase64ImageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateQrcodeBase64ImageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCreateQrcodeBase64ImageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCreateQrcodeBase64ImageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceCreateQrcodeBase64Image"
          )
        )
      )
    }
  }
}

//
// TalkServiceCreateRoomArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateRoomArgs {
  req_seq: i32,
  contact_ids: Vec<String>,
}

impl TalkServiceCreateRoomArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateRoomArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_130 = i_prot.read_string()?;
            val.push(list_elem_130);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceCreateRoomArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceCreateRoomArgs.contact_ids", &f_2)?;
    let ret = TalkServiceCreateRoomArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contact_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createRoom_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactIds", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.contact_ids.len() as i32))?;
    for e in &self.contact_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCreateRoomResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateRoomResult {
  result_value: Option<Room>,
  e: Option<TalkException>,
}

impl TalkServiceCreateRoomResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateRoomResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Room> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Room::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCreateRoomResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCreateRoomResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Room> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceCreateRoom"
          )
        )
      )
    }
  }
}

//
// TalkServiceCreateSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateSessionArgs {
}

impl TalkServiceCreateSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateSessionArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCreateSessionArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceCreateSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceCreateSessionResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceCreateSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceCreateSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceCreateSessionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceCreateSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceCreateSession"
          )
        )
      )
    }
  }
}

//
// TalkServiceFetchAnnouncementsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchAnnouncementsArgs {
  last_fetched_index: i32,
}

impl TalkServiceFetchAnnouncementsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchAnnouncementsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFetchAnnouncementsArgs.last_fetched_index", &f_2)?;
    let ret = TalkServiceFetchAnnouncementsArgs {
      last_fetched_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchAnnouncements_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastFetchedIndex", TType::I32, 2))?;
    o_prot.write_i32(self.last_fetched_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFetchAnnouncementsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchAnnouncementsResult {
  result_value: Option<Vec<Announcement>>,
  e: Option<TalkException>,
}

impl TalkServiceFetchAnnouncementsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchAnnouncementsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Announcement>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Announcement> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_131 = Announcement::read_from_in_protocol(i_prot)?;
            val.push(list_elem_131);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFetchAnnouncementsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFetchAnnouncementsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Announcement>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFetchAnnouncements"
          )
        )
      )
    }
  }
}

//
// TalkServiceFetchMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchMessagesArgs {
  local_ts: i64,
  count: i32,
}

impl TalkServiceFetchMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFetchMessagesArgs.local_ts", &f_2)?;
    verify_required_field_exists("TalkServiceFetchMessagesArgs.count", &f_3)?;
    let ret = TalkServiceFetchMessagesArgs {
      local_ts: f_2.expect("auto-generated code should have checked for presence of required fields"),
      count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localTs", TType::I64, 2))?;
    o_prot.write_i64(self.local_ts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 3))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFetchMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchMessagesResult {
  result_value: Option<Vec<Message>>,
  e: Option<TalkException>,
}

impl TalkServiceFetchMessagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchMessagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Message>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Message> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_132 = Message::read_from_in_protocol(i_prot)?;
            val.push(list_elem_132);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFetchMessagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFetchMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Message>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFetchMessages"
          )
        )
      )
    }
  }
}

//
// TalkServiceFetchOperationsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchOperationsArgs {
  local_rev: i64,
  count: i32,
}

impl TalkServiceFetchOperationsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchOperationsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFetchOperationsArgs.local_rev", &f_2)?;
    verify_required_field_exists("TalkServiceFetchOperationsArgs.count", &f_3)?;
    let ret = TalkServiceFetchOperationsArgs {
      local_rev: f_2.expect("auto-generated code should have checked for presence of required fields"),
      count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchOperations_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localRev", TType::I64, 2))?;
    o_prot.write_i64(self.local_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 3))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFetchOperationsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchOperationsResult {
  result_value: Option<Vec<Operation>>,
  e: Option<TalkException>,
}

impl TalkServiceFetchOperationsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchOperationsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Operation>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Operation> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_133 = Operation::read_from_in_protocol(i_prot)?;
            val.push(list_elem_133);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFetchOperationsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFetchOperationsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Operation>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFetchOperations"
          )
        )
      )
    }
  }
}

//
// TalkServiceFetchOpsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchOpsArgs {
  local_rev: i64,
  count: i32,
  global_rev: i64,
  individual_rev: i64,
}

impl TalkServiceFetchOpsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchOpsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFetchOpsArgs.local_rev", &f_2)?;
    verify_required_field_exists("TalkServiceFetchOpsArgs.count", &f_3)?;
    verify_required_field_exists("TalkServiceFetchOpsArgs.global_rev", &f_4)?;
    verify_required_field_exists("TalkServiceFetchOpsArgs.individual_rev", &f_5)?;
    let ret = TalkServiceFetchOpsArgs {
      local_rev: f_2.expect("auto-generated code should have checked for presence of required fields"),
      count: f_3.expect("auto-generated code should have checked for presence of required fields"),
      global_rev: f_4.expect("auto-generated code should have checked for presence of required fields"),
      individual_rev: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchOps_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localRev", TType::I64, 2))?;
    o_prot.write_i64(self.local_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 3))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("globalRev", TType::I64, 4))?;
    o_prot.write_i64(self.global_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("individualRev", TType::I64, 5))?;
    o_prot.write_i64(self.individual_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFetchOpsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFetchOpsResult {
  result_value: Option<Vec<Operation>>,
  e: Option<TalkException>,
}

impl TalkServiceFetchOpsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFetchOpsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Operation>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Operation> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_134 = Operation::read_from_in_protocol(i_prot)?;
            val.push(list_elem_134);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFetchOpsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFetchOpsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Operation>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFetchOps"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindAndAddContactsByEmailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByEmailArgs {
  req_seq: i32,
  emails: BTreeSet<String>,
}

impl TalkServiceFindAndAddContactsByEmailArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByEmailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<BTreeSet<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_135 = i_prot.read_string()?;
            val.insert(set_elem_135);
          }
          i_prot.read_set_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByEmailArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByEmailArgs.emails", &f_2)?;
    let ret = TalkServiceFindAndAddContactsByEmailArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      emails: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findAndAddContactsByEmail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("emails", TType::Set, 2))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::String, self.emails.len() as i32))?;
    for e in &self.emails {
      o_prot.write_string(e)?;
      o_prot.write_set_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindAndAddContactsByEmailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByEmailResult {
  result_value: Option<BTreeMap<String, Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceFindAndAddContactsByEmailResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByEmailResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Contact> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_136 = i_prot.read_string()?;
            let map_val_137 = Contact::read_from_in_protocol(i_prot)?;
            val.insert(map_key_136, map_val_137);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindAndAddContactsByEmailResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindAndAddContactsByEmailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindAndAddContactsByEmail"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindAndAddContactsByMidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByMidArgs {
  req_seq: i32,
  mid: String,
}

impl TalkServiceFindAndAddContactsByMidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByMidArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByMidArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByMidArgs.mid", &f_2)?;
    let ret = TalkServiceFindAndAddContactsByMidArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findAndAddContactsByMid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindAndAddContactsByMidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByMidResult {
  result_value: Option<BTreeMap<String, Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceFindAndAddContactsByMidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByMidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Contact> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_138 = i_prot.read_string()?;
            let map_val_139 = Contact::read_from_in_protocol(i_prot)?;
            val.insert(map_key_138, map_val_139);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindAndAddContactsByMidResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindAndAddContactsByMidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindAndAddContactsByMid"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindAndAddContactsByPhoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByPhoneArgs {
  req_seq: i32,
  phones: BTreeSet<String>,
}

impl TalkServiceFindAndAddContactsByPhoneArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByPhoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<BTreeSet<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_140 = i_prot.read_string()?;
            val.insert(set_elem_140);
          }
          i_prot.read_set_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByPhoneArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByPhoneArgs.phones", &f_2)?;
    let ret = TalkServiceFindAndAddContactsByPhoneArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      phones: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findAndAddContactsByPhone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("phones", TType::Set, 2))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::String, self.phones.len() as i32))?;
    for e in &self.phones {
      o_prot.write_string(e)?;
      o_prot.write_set_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindAndAddContactsByPhoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByPhoneResult {
  result_value: Option<BTreeMap<String, Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceFindAndAddContactsByPhoneResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByPhoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Contact> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_141 = i_prot.read_string()?;
            let map_val_142 = Contact::read_from_in_protocol(i_prot)?;
            val.insert(map_key_141, map_val_142);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindAndAddContactsByPhoneResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindAndAddContactsByPhoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindAndAddContactsByPhone"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindAndAddContactsByUseridArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByUseridArgs {
  req_seq: i32,
  userid: String,
}

impl TalkServiceFindAndAddContactsByUseridArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByUseridArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByUseridArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceFindAndAddContactsByUseridArgs.userid", &f_2)?;
    let ret = TalkServiceFindAndAddContactsByUseridArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      userid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findAndAddContactsByUserid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userid", TType::String, 2))?;
    o_prot.write_string(&self.userid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindAndAddContactsByUseridResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindAndAddContactsByUseridResult {
  result_value: Option<BTreeMap<String, Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceFindAndAddContactsByUseridResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindAndAddContactsByUseridResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Contact> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_143 = i_prot.read_string()?;
            let map_val_144 = Contact::read_from_in_protocol(i_prot)?;
            val.insert(map_key_143, map_val_144);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindAndAddContactsByUseridResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindAndAddContactsByUseridResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindAndAddContactsByUserid"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindContactByUseridArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactByUseridArgs {
  userid: String,
}

impl TalkServiceFindContactByUseridArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactByUseridArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindContactByUseridArgs.userid", &f_2)?;
    let ret = TalkServiceFindContactByUseridArgs {
      userid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findContactByUserid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userid", TType::String, 2))?;
    o_prot.write_string(&self.userid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindContactByUseridResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactByUseridResult {
  result_value: Option<Contact>,
  e: Option<TalkException>,
}

impl TalkServiceFindContactByUseridResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactByUseridResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Contact> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindContactByUseridResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindContactByUseridResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Contact> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindContactByUserid"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindContactByUserTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactByUserTicketArgs {
  ticket_id: String,
}

impl TalkServiceFindContactByUserTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactByUserTicketArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindContactByUserTicketArgs.ticket_id", &f_2)?;
    let ret = TalkServiceFindContactByUserTicketArgs {
      ticket_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findContactByUserTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ticketId", TType::String, 2))?;
    o_prot.write_string(&self.ticket_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindContactByUserTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactByUserTicketResult {
  result_value: Option<Contact>,
  e: Option<TalkException>,
}

impl TalkServiceFindContactByUserTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactByUserTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Contact> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindContactByUserTicketResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindContactByUserTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Contact> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindContactByUserTicket"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindContactsByEmailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactsByEmailArgs {
  emails: BTreeSet<String>,
}

impl TalkServiceFindContactsByEmailArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactsByEmailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<BTreeSet<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_145 = i_prot.read_string()?;
            val.insert(set_elem_145);
          }
          i_prot.read_set_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindContactsByEmailArgs.emails", &f_2)?;
    let ret = TalkServiceFindContactsByEmailArgs {
      emails: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findContactsByEmail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("emails", TType::Set, 2))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::String, self.emails.len() as i32))?;
    for e in &self.emails {
      o_prot.write_string(e)?;
      o_prot.write_set_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindContactsByEmailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactsByEmailResult {
  result_value: Option<BTreeMap<String, Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceFindContactsByEmailResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactsByEmailResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Contact> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_146 = i_prot.read_string()?;
            let map_val_147 = Contact::read_from_in_protocol(i_prot)?;
            val.insert(map_key_146, map_val_147);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindContactsByEmailResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindContactsByEmailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindContactsByEmail"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindContactsByPhoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactsByPhoneArgs {
  phones: BTreeSet<String>,
}

impl TalkServiceFindContactsByPhoneArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactsByPhoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<BTreeSet<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_148 = i_prot.read_string()?;
            val.insert(set_elem_148);
          }
          i_prot.read_set_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindContactsByPhoneArgs.phones", &f_2)?;
    let ret = TalkServiceFindContactsByPhoneArgs {
      phones: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findContactsByPhone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("phones", TType::Set, 2))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::String, self.phones.len() as i32))?;
    for e in &self.phones {
      o_prot.write_string(e)?;
      o_prot.write_set_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindContactsByPhoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindContactsByPhoneResult {
  result_value: Option<BTreeMap<String, Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceFindContactsByPhoneResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindContactsByPhoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Contact> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_149 = i_prot.read_string()?;
            let map_val_150 = Contact::read_from_in_protocol(i_prot)?;
            val.insert(map_key_149, map_val_150);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindContactsByPhoneResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindContactsByPhoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindContactsByPhone"
          )
        )
      )
    }
  }
}

//
// TalkServiceFindSnsIdUserStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindSnsIdUserStatusArgs {
  sns_id_type: SnsIdType,
  sns_access_token: String,
  udid_hash: String,
}

impl TalkServiceFindSnsIdUserStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindSnsIdUserStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFindSnsIdUserStatusArgs.sns_id_type", &f_2)?;
    verify_required_field_exists("TalkServiceFindSnsIdUserStatusArgs.sns_access_token", &f_3)?;
    verify_required_field_exists("TalkServiceFindSnsIdUserStatusArgs.udid_hash", &f_4)?;
    let ret = TalkServiceFindSnsIdUserStatusArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sns_access_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findSnsIdUserStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsAccessToken", TType::String, 3))?;
    o_prot.write_string(&self.sns_access_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 4))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFindSnsIdUserStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFindSnsIdUserStatusResult {
  result_value: Option<SnsIdUserStatus>,
  e: Option<TalkException>,
}

impl TalkServiceFindSnsIdUserStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFindSnsIdUserStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SnsIdUserStatus> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SnsIdUserStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFindSnsIdUserStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFindSnsIdUserStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SnsIdUserStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceFindSnsIdUserStatus"
          )
        )
      )
    }
  }
}

//
// TalkServiceFinishUpdateVerificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFinishUpdateVerificationArgs {
  session_id: String,
}

impl TalkServiceFinishUpdateVerificationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFinishUpdateVerificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceFinishUpdateVerificationArgs.session_id", &f_2)?;
    let ret = TalkServiceFinishUpdateVerificationArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("finishUpdateVerification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceFinishUpdateVerificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceFinishUpdateVerificationResult {
  e: Option<TalkException>,
}

impl TalkServiceFinishUpdateVerificationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceFinishUpdateVerificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceFinishUpdateVerificationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceFinishUpdateVerificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceGenerateUserTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGenerateUserTicketArgs {
  expiration_time: i64,
  max_use_count: i32,
}

impl TalkServiceGenerateUserTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGenerateUserTicketArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGenerateUserTicketArgs.expiration_time", &f_3)?;
    verify_required_field_exists("TalkServiceGenerateUserTicketArgs.max_use_count", &f_4)?;
    let ret = TalkServiceGenerateUserTicketArgs {
      expiration_time: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_use_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("generateUserTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expirationTime", TType::I64, 3))?;
    o_prot.write_i64(self.expiration_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxUseCount", TType::I32, 4))?;
    o_prot.write_i32(self.max_use_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGenerateUserTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGenerateUserTicketResult {
  result_value: Option<Ticket>,
  e: Option<TalkException>,
}

impl TalkServiceGenerateUserTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGenerateUserTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Ticket> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Ticket::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGenerateUserTicketResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGenerateUserTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Ticket> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGenerateUserTicket"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetAcceptedProximityMatchesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetAcceptedProximityMatchesArgs {
  session_id: String,
}

impl TalkServiceGetAcceptedProximityMatchesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetAcceptedProximityMatchesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetAcceptedProximityMatchesArgs.session_id", &f_2)?;
    let ret = TalkServiceGetAcceptedProximityMatchesArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getAcceptedProximityMatches_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetAcceptedProximityMatchesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetAcceptedProximityMatchesResult {
  result_value: Option<BTreeSet<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetAcceptedProximityMatchesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetAcceptedProximityMatchesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeSet<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_151 = i_prot.read_string()?;
            val.insert(set_elem_151);
          }
          i_prot.read_set_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetAcceptedProximityMatchesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetAcceptedProximityMatchesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Set, 0))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_set_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeSet<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetAcceptedProximityMatches"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetActiveBuddySubscriberIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetActiveBuddySubscriberIdsArgs {
}

impl TalkServiceGetActiveBuddySubscriberIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetActiveBuddySubscriberIdsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetActiveBuddySubscriberIdsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getActiveBuddySubscriberIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetActiveBuddySubscriberIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetActiveBuddySubscriberIdsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetActiveBuddySubscriberIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetActiveBuddySubscriberIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_152 = i_prot.read_string()?;
            val.push(list_elem_152);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetActiveBuddySubscriberIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetActiveBuddySubscriberIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetActiveBuddySubscriberIds"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetAllContactIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetAllContactIdsArgs {
}

impl TalkServiceGetAllContactIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetAllContactIdsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetAllContactIdsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getAllContactIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetAllContactIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetAllContactIdsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetAllContactIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetAllContactIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_153 = i_prot.read_string()?;
            val.push(list_elem_153);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetAllContactIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetAllContactIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetAllContactIds"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetAuthQrcodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetAuthQrcodeArgs {
  keep_logged_in: bool,
  system_name: String,
}

impl TalkServiceGetAuthQrcodeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetAuthQrcodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetAuthQrcodeArgs.keep_logged_in", &f_2)?;
    verify_required_field_exists("TalkServiceGetAuthQrcodeArgs.system_name", &f_3)?;
    let ret = TalkServiceGetAuthQrcodeArgs {
      keep_logged_in: f_2.expect("auto-generated code should have checked for presence of required fields"),
      system_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getAuthQrcode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("keepLoggedIn", TType::Bool, 2))?;
    o_prot.write_bool(self.keep_logged_in)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("systemName", TType::String, 3))?;
    o_prot.write_string(&self.system_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetAuthQrcodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetAuthQrcodeResult {
  result_value: Option<AuthQrcode>,
  e: Option<TalkException>,
}

impl TalkServiceGetAuthQrcodeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetAuthQrcodeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AuthQrcode> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AuthQrcode::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetAuthQrcodeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetAuthQrcodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AuthQrcode> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetAuthQrcode"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetBlockedContactIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBlockedContactIdsArgs {
}

impl TalkServiceGetBlockedContactIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBlockedContactIdsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBlockedContactIdsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBlockedContactIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetBlockedContactIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBlockedContactIdsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetBlockedContactIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBlockedContactIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_154 = i_prot.read_string()?;
            val.push(list_elem_154);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBlockedContactIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetBlockedContactIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetBlockedContactIds"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetBlockedContactIdsByRangeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBlockedContactIdsByRangeArgs {
  start: i32,
  count: i32,
}

impl TalkServiceGetBlockedContactIdsByRangeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBlockedContactIdsByRangeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetBlockedContactIdsByRangeArgs.start", &f_2)?;
    verify_required_field_exists("TalkServiceGetBlockedContactIdsByRangeArgs.count", &f_3)?;
    let ret = TalkServiceGetBlockedContactIdsByRangeArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBlockedContactIdsByRange_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I32, 2))?;
    o_prot.write_i32(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 3))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetBlockedContactIdsByRangeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBlockedContactIdsByRangeResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetBlockedContactIdsByRangeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBlockedContactIdsByRangeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_155 = i_prot.read_string()?;
            val.push(list_elem_155);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBlockedContactIdsByRangeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetBlockedContactIdsByRangeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetBlockedContactIdsByRange"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetBlockedRecommendationIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBlockedRecommendationIdsArgs {
}

impl TalkServiceGetBlockedRecommendationIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBlockedRecommendationIdsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBlockedRecommendationIdsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBlockedRecommendationIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetBlockedRecommendationIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBlockedRecommendationIdsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetBlockedRecommendationIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBlockedRecommendationIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_156 = i_prot.read_string()?;
            val.push(list_elem_156);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBlockedRecommendationIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetBlockedRecommendationIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetBlockedRecommendationIds"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetBuddyBlockerIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBuddyBlockerIdsArgs {
}

impl TalkServiceGetBuddyBlockerIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBuddyBlockerIdsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBuddyBlockerIdsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBuddyBlockerIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetBuddyBlockerIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBuddyBlockerIdsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetBuddyBlockerIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBuddyBlockerIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_157 = i_prot.read_string()?;
            val.push(list_elem_157);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBuddyBlockerIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetBuddyBlockerIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetBuddyBlockerIds"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetBuddyLocationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBuddyLocationArgs {
  mid: String,
  index: i32,
}

impl TalkServiceGetBuddyLocationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBuddyLocationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetBuddyLocationArgs.mid", &f_2)?;
    verify_required_field_exists("TalkServiceGetBuddyLocationArgs.index", &f_3)?;
    let ret = TalkServiceGetBuddyLocationArgs {
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBuddyLocation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index", TType::I32, 3))?;
    o_prot.write_i32(self.index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetBuddyLocationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetBuddyLocationResult {
  result_value: Option<Geolocation>,
  e: Option<TalkException>,
}

impl TalkServiceGetBuddyLocationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetBuddyLocationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Geolocation> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Geolocation::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetBuddyLocationResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetBuddyLocationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Geolocation> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetBuddyLocation"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetCompactContactsModifiedSinceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCompactContactsModifiedSinceArgs {
  timestamp: i64,
}

impl TalkServiceGetCompactContactsModifiedSinceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCompactContactsModifiedSinceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetCompactContactsModifiedSinceArgs.timestamp", &f_2)?;
    let ret = TalkServiceGetCompactContactsModifiedSinceArgs {
      timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCompactContactsModifiedSince_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 2))?;
    o_prot.write_i64(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetCompactContactsModifiedSinceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCompactContactsModifiedSinceResult {
  result_value: Option<Vec<CompactContact>>,
  e: Option<TalkException>,
}

impl TalkServiceGetCompactContactsModifiedSinceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCompactContactsModifiedSinceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<CompactContact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactContact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_158 = CompactContact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_158);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetCompactContactsModifiedSinceResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetCompactContactsModifiedSinceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<CompactContact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetCompactContactsModifiedSince"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetCompactGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCompactGroupArgs {
  group_id: String,
}

impl TalkServiceGetCompactGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCompactGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetCompactGroupArgs.group_id", &f_2)?;
    let ret = TalkServiceGetCompactGroupArgs {
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCompactGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetCompactGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCompactGroupResult {
  result_value: Option<Group>,
  e: Option<TalkException>,
}

impl TalkServiceGetCompactGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCompactGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Group> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Group::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetCompactGroupResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetCompactGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Group> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetCompactGroup"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetCompactRoomArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCompactRoomArgs {
  room_id: String,
}

impl TalkServiceGetCompactRoomArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCompactRoomArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetCompactRoomArgs.room_id", &f_2)?;
    let ret = TalkServiceGetCompactRoomArgs {
      room_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCompactRoom_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roomId", TType::String, 2))?;
    o_prot.write_string(&self.room_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetCompactRoomResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCompactRoomResult {
  result_value: Option<Room>,
  e: Option<TalkException>,
}

impl TalkServiceGetCompactRoomResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCompactRoomResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Room> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Room::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetCompactRoomResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetCompactRoomResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Room> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetCompactRoom"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetContactArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetContactArgs {
  id: String,
}

impl TalkServiceGetContactArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetContactArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetContactArgs.id", &f_2)?;
    let ret = TalkServiceGetContactArgs {
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getContact_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 2))?;
    o_prot.write_string(&self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetContactResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetContactResult {
  result_value: Option<Contact>,
  e: Option<TalkException>,
}

impl TalkServiceGetContactResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetContactResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Contact> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetContactResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetContactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Contact> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetContact"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetContactsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetContactsArgs {
  ids: Vec<String>,
}

impl TalkServiceGetContactsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetContactsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_159 = i_prot.read_string()?;
            val.push(list_elem_159);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetContactsArgs.ids", &f_2)?;
    let ret = TalkServiceGetContactsArgs {
      ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getContacts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.ids.len() as i32))?;
    for e in &self.ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetContactsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetContactsResult {
  result_value: Option<Vec<Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceGetContactsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetContactsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_160 = Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_160);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetContactsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetContactsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetContacts"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetCountryWithRequestIpArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCountryWithRequestIpArgs {
}

impl TalkServiceGetCountryWithRequestIpArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCountryWithRequestIpArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetCountryWithRequestIpArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCountryWithRequestIp_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetCountryWithRequestIpResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetCountryWithRequestIpResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceGetCountryWithRequestIpResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetCountryWithRequestIpResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetCountryWithRequestIpResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetCountryWithRequestIpResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetCountryWithRequestIp"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetFavoriteMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetFavoriteMidsArgs {
}

impl TalkServiceGetFavoriteMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetFavoriteMidsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetFavoriteMidsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getFavoriteMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetFavoriteMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetFavoriteMidsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetFavoriteMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetFavoriteMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_161 = i_prot.read_string()?;
            val.push(list_elem_161);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetFavoriteMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetFavoriteMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetFavoriteMids"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupArgs {
  group_id: String,
}

impl TalkServiceGetGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetGroupArgs.group_id", &f_2)?;
    let ret = TalkServiceGetGroupArgs {
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupResult {
  result_value: Option<Group>,
  e: Option<TalkException>,
}

impl TalkServiceGetGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Group> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Group::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetGroupResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Group> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetGroup"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetGroupIdsInvitedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupIdsInvitedArgs {
}

impl TalkServiceGetGroupIdsInvitedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupIdsInvitedArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetGroupIdsInvitedArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getGroupIdsInvited_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetGroupIdsInvitedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupIdsInvitedResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetGroupIdsInvitedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupIdsInvitedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_162 = i_prot.read_string()?;
            val.push(list_elem_162);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetGroupIdsInvitedResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetGroupIdsInvitedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetGroupIdsInvited"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetGroupIdsJoinedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupIdsJoinedArgs {
}

impl TalkServiceGetGroupIdsJoinedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupIdsJoinedArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetGroupIdsJoinedArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getGroupIdsJoined_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetGroupIdsJoinedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupIdsJoinedResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetGroupIdsJoinedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupIdsJoinedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_163 = i_prot.read_string()?;
            val.push(list_elem_163);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetGroupIdsJoinedResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetGroupIdsJoinedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetGroupIdsJoined"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetGroupsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupsArgs {
  group_ids: Vec<String>,
}

impl TalkServiceGetGroupsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_164 = i_prot.read_string()?;
            val.push(list_elem_164);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetGroupsArgs.group_ids", &f_2)?;
    let ret = TalkServiceGetGroupsArgs {
      group_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getGroups_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupIds", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.group_ids.len() as i32))?;
    for e in &self.group_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetGroupsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetGroupsResult {
  result_value: Option<Vec<Group>>,
  e: Option<TalkException>,
}

impl TalkServiceGetGroupsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetGroupsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Group>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Group> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_165 = Group::read_from_in_protocol(i_prot)?;
            val.push(list_elem_165);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetGroupsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetGroupsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Group>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetGroups"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetHiddenContactMidsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetHiddenContactMidsArgs {
}

impl TalkServiceGetHiddenContactMidsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetHiddenContactMidsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetHiddenContactMidsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getHiddenContactMids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetHiddenContactMidsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetHiddenContactMidsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetHiddenContactMidsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetHiddenContactMidsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_166 = i_prot.read_string()?;
            val.push(list_elem_166);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetHiddenContactMidsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetHiddenContactMidsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetHiddenContactMids"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetIdentityIdentifierArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetIdentityIdentifierArgs {
}

impl TalkServiceGetIdentityIdentifierArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetIdentityIdentifierArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetIdentityIdentifierArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getIdentityIdentifier_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetIdentityIdentifierResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetIdentityIdentifierResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceGetIdentityIdentifierResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetIdentityIdentifierResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetIdentityIdentifierResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetIdentityIdentifierResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetIdentityIdentifier"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetLastAnnouncementIndexArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetLastAnnouncementIndexArgs {
}

impl TalkServiceGetLastAnnouncementIndexArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetLastAnnouncementIndexArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetLastAnnouncementIndexArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getLastAnnouncementIndex_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetLastAnnouncementIndexResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetLastAnnouncementIndexResult {
  result_value: Option<i32>,
  e: Option<TalkException>,
}

impl TalkServiceGetLastAnnouncementIndexResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetLastAnnouncementIndexResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetLastAnnouncementIndexResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetLastAnnouncementIndexResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetLastAnnouncementIndex"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetLastOpRevisionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetLastOpRevisionArgs {
}

impl TalkServiceGetLastOpRevisionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetLastOpRevisionArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetLastOpRevisionArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getLastOpRevision_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetLastOpRevisionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetLastOpRevisionResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl TalkServiceGetLastOpRevisionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetLastOpRevisionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetLastOpRevisionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetLastOpRevisionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetLastOpRevision"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessageBoxArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxArgs {
  channel_id: String,
  message_box_id: String,
  last_messages_count: i32,
}

impl TalkServiceGetMessageBoxArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessageBoxArgs.channel_id", &f_2)?;
    verify_required_field_exists("TalkServiceGetMessageBoxArgs.message_box_id", &f_3)?;
    verify_required_field_exists("TalkServiceGetMessageBoxArgs.last_messages_count", &f_4)?;
    let ret = TalkServiceGetMessageBoxArgs {
      channel_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_box_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      last_messages_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessageBox_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 2))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxId", TType::String, 3))?;
    o_prot.write_string(&self.message_box_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastMessagesCount", TType::I32, 4))?;
    o_prot.write_i32(self.last_messages_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessageBoxResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxResult {
  result_value: Option<TMessageBox>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessageBoxResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TMessageBox> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TMessageBox::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessageBoxResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessageBoxResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TMessageBox> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessageBox"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessageBoxCompactWrapUpArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxCompactWrapUpArgs {
  mid: String,
}

impl TalkServiceGetMessageBoxCompactWrapUpArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxCompactWrapUpArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessageBoxCompactWrapUpArgs.mid", &f_2)?;
    let ret = TalkServiceGetMessageBoxCompactWrapUpArgs {
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessageBoxCompactWrapUp_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessageBoxCompactWrapUpResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxCompactWrapUpResult {
  result_value: Option<TMessageBoxWrapUp>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessageBoxCompactWrapUpResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxCompactWrapUpResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TMessageBoxWrapUp> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TMessageBoxWrapUp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessageBoxCompactWrapUpResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessageBoxCompactWrapUpResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TMessageBoxWrapUp> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessageBoxCompactWrapUp"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessageBoxCompactWrapUpListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxCompactWrapUpListArgs {
  start: i32,
  message_box_count: i32,
}

impl TalkServiceGetMessageBoxCompactWrapUpListArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxCompactWrapUpListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessageBoxCompactWrapUpListArgs.start", &f_2)?;
    verify_required_field_exists("TalkServiceGetMessageBoxCompactWrapUpListArgs.message_box_count", &f_3)?;
    let ret = TalkServiceGetMessageBoxCompactWrapUpListArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_box_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessageBoxCompactWrapUpList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I32, 2))?;
    o_prot.write_i32(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxCount", TType::I32, 3))?;
    o_prot.write_i32(self.message_box_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessageBoxCompactWrapUpListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxCompactWrapUpListResult {
  result_value: Option<TMessageBoxWrapUpResponse>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessageBoxCompactWrapUpListResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxCompactWrapUpListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TMessageBoxWrapUpResponse> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TMessageBoxWrapUpResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessageBoxCompactWrapUpListResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessageBoxCompactWrapUpListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TMessageBoxWrapUpResponse> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessageBoxCompactWrapUpList"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessageBoxListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxListArgs {
  channel_id: String,
  last_messages_count: i32,
}

impl TalkServiceGetMessageBoxListArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessageBoxListArgs.channel_id", &f_2)?;
    verify_required_field_exists("TalkServiceGetMessageBoxListArgs.last_messages_count", &f_3)?;
    let ret = TalkServiceGetMessageBoxListArgs {
      channel_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      last_messages_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessageBoxList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 2))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastMessagesCount", TType::I32, 3))?;
    o_prot.write_i32(self.last_messages_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessageBoxListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxListResult {
  result_value: Option<Vec<TMessageBox>>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessageBoxListResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TMessageBox>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TMessageBox> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_167 = TMessageBox::read_from_in_protocol(i_prot)?;
            val.push(list_elem_167);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessageBoxListResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessageBoxListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TMessageBox>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessageBoxList"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessageBoxListByStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxListByStatusArgs {
  channel_id: String,
  last_messages_count: i32,
  status: i32,
}

impl TalkServiceGetMessageBoxListByStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxListByStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessageBoxListByStatusArgs.channel_id", &f_2)?;
    verify_required_field_exists("TalkServiceGetMessageBoxListByStatusArgs.last_messages_count", &f_3)?;
    verify_required_field_exists("TalkServiceGetMessageBoxListByStatusArgs.status", &f_4)?;
    let ret = TalkServiceGetMessageBoxListByStatusArgs {
      channel_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      last_messages_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
      status: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessageBoxListByStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 2))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastMessagesCount", TType::I32, 3))?;
    o_prot.write_i32(self.last_messages_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 4))?;
    o_prot.write_i32(self.status)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessageBoxListByStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxListByStatusResult {
  result_value: Option<Vec<TMessageBox>>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessageBoxListByStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxListByStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TMessageBox>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TMessageBox> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_168 = TMessageBox::read_from_in_protocol(i_prot)?;
            val.push(list_elem_168);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessageBoxListByStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessageBoxListByStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TMessageBox>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessageBoxListByStatus"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessageBoxWrapUpArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxWrapUpArgs {
  mid: String,
}

impl TalkServiceGetMessageBoxWrapUpArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxWrapUpArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessageBoxWrapUpArgs.mid", &f_2)?;
    let ret = TalkServiceGetMessageBoxWrapUpArgs {
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessageBoxWrapUp_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessageBoxWrapUpResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxWrapUpResult {
  result_value: Option<TMessageBoxWrapUp>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessageBoxWrapUpResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxWrapUpResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TMessageBoxWrapUp> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TMessageBoxWrapUp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessageBoxWrapUpResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessageBoxWrapUpResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TMessageBoxWrapUp> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessageBoxWrapUp"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessageBoxWrapUpListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxWrapUpListArgs {
  start: i32,
  message_box_count: i32,
}

impl TalkServiceGetMessageBoxWrapUpListArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxWrapUpListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessageBoxWrapUpListArgs.start", &f_2)?;
    verify_required_field_exists("TalkServiceGetMessageBoxWrapUpListArgs.message_box_count", &f_3)?;
    let ret = TalkServiceGetMessageBoxWrapUpListArgs {
      start: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_box_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessageBoxWrapUpList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I32, 2))?;
    o_prot.write_i32(self.start)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxCount", TType::I32, 3))?;
    o_prot.write_i32(self.message_box_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessageBoxWrapUpListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessageBoxWrapUpListResult {
  result_value: Option<TMessageBoxWrapUpResponse>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessageBoxWrapUpListResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessageBoxWrapUpListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TMessageBoxWrapUpResponse> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TMessageBoxWrapUpResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessageBoxWrapUpListResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessageBoxWrapUpListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TMessageBoxWrapUpResponse> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessageBoxWrapUpList"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetMessagesBySequenceNumberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessagesBySequenceNumberArgs {
  channel_id: String,
  message_box_id: String,
  start_seq: i64,
  end_seq: i64,
}

impl TalkServiceGetMessagesBySequenceNumberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessagesBySequenceNumberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetMessagesBySequenceNumberArgs.channel_id", &f_2)?;
    verify_required_field_exists("TalkServiceGetMessagesBySequenceNumberArgs.message_box_id", &f_3)?;
    verify_required_field_exists("TalkServiceGetMessagesBySequenceNumberArgs.start_seq", &f_4)?;
    verify_required_field_exists("TalkServiceGetMessagesBySequenceNumberArgs.end_seq", &f_5)?;
    let ret = TalkServiceGetMessagesBySequenceNumberArgs {
      channel_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_box_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      start_seq: f_4.expect("auto-generated code should have checked for presence of required fields"),
      end_seq: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMessagesBySequenceNumber_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("channelId", TType::String, 2))?;
    o_prot.write_string(&self.channel_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxId", TType::String, 3))?;
    o_prot.write_string(&self.message_box_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startSeq", TType::I64, 4))?;
    o_prot.write_i64(self.start_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endSeq", TType::I64, 5))?;
    o_prot.write_i64(self.end_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetMessagesBySequenceNumberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetMessagesBySequenceNumberResult {
  result_value: Option<Vec<Message>>,
  e: Option<TalkException>,
}

impl TalkServiceGetMessagesBySequenceNumberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetMessagesBySequenceNumberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Message>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Message> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_169 = Message::read_from_in_protocol(i_prot)?;
            val.push(list_elem_169);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetMessagesBySequenceNumberResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetMessagesBySequenceNumberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Message>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetMessagesBySequenceNumber"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetNextMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetNextMessagesArgs {
  message_box_id: String,
  start_seq: i64,
  messages_count: i32,
}

impl TalkServiceGetNextMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetNextMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetNextMessagesArgs.message_box_id", &f_2)?;
    verify_required_field_exists("TalkServiceGetNextMessagesArgs.start_seq", &f_3)?;
    verify_required_field_exists("TalkServiceGetNextMessagesArgs.messages_count", &f_4)?;
    let ret = TalkServiceGetNextMessagesArgs {
      message_box_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_seq: f_3.expect("auto-generated code should have checked for presence of required fields"),
      messages_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNextMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxId", TType::String, 2))?;
    o_prot.write_string(&self.message_box_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startSeq", TType::I64, 3))?;
    o_prot.write_i64(self.start_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messagesCount", TType::I32, 4))?;
    o_prot.write_i32(self.messages_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetNextMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetNextMessagesResult {
  result_value: Option<Vec<Message>>,
  e: Option<TalkException>,
}

impl TalkServiceGetNextMessagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetNextMessagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Message>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Message> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_170 = Message::read_from_in_protocol(i_prot)?;
            val.push(list_elem_170);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetNextMessagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetNextMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Message>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetNextMessages"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetNotificationPolicyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetNotificationPolicyArgs {
  carrier: CarrierCode,
}

impl TalkServiceGetNotificationPolicyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetNotificationPolicyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CarrierCode> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CarrierCode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetNotificationPolicyArgs.carrier", &f_2)?;
    let ret = TalkServiceGetNotificationPolicyArgs {
      carrier: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNotificationPolicy_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("carrier", TType::I32, 2))?;
    self.carrier.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetNotificationPolicyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetNotificationPolicyResult {
  result_value: Option<Vec<NotificationType>>,
  e: Option<TalkException>,
}

impl TalkServiceGetNotificationPolicyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetNotificationPolicyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<NotificationType>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NotificationType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_171 = NotificationType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_171);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetNotificationPolicyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetNotificationPolicyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<NotificationType>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetNotificationPolicy"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetPreviousMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetPreviousMessagesArgs {
  message_box_id: String,
  end_seq: i64,
  messages_count: i32,
}

impl TalkServiceGetPreviousMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetPreviousMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetPreviousMessagesArgs.message_box_id", &f_2)?;
    verify_required_field_exists("TalkServiceGetPreviousMessagesArgs.end_seq", &f_3)?;
    verify_required_field_exists("TalkServiceGetPreviousMessagesArgs.messages_count", &f_4)?;
    let ret = TalkServiceGetPreviousMessagesArgs {
      message_box_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      end_seq: f_3.expect("auto-generated code should have checked for presence of required fields"),
      messages_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPreviousMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxId", TType::String, 2))?;
    o_prot.write_string(&self.message_box_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endSeq", TType::I64, 3))?;
    o_prot.write_i64(self.end_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messagesCount", TType::I32, 4))?;
    o_prot.write_i32(self.messages_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetPreviousMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetPreviousMessagesResult {
  result_value: Option<Vec<Message>>,
  e: Option<TalkException>,
}

impl TalkServiceGetPreviousMessagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetPreviousMessagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Message>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Message> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_172 = Message::read_from_in_protocol(i_prot)?;
            val.push(list_elem_172);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetPreviousMessagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetPreviousMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Message>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetPreviousMessages"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetProfileArgs {
}

impl TalkServiceGetProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetProfileArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetProfileArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetProfileResult {
  result_value: Option<Profile>,
  e: Option<TalkException>,
}

impl TalkServiceGetProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Profile> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Profile::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Profile> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetProfile"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetProximityMatchCandidateListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetProximityMatchCandidateListArgs {
  session_id: String,
}

impl TalkServiceGetProximityMatchCandidateListArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetProximityMatchCandidateListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetProximityMatchCandidateListArgs.session_id", &f_2)?;
    let ret = TalkServiceGetProximityMatchCandidateListArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProximityMatchCandidateList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetProximityMatchCandidateListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetProximityMatchCandidateListResult {
  result_value: Option<ProximityMatchCandidateResult>,
  e: Option<TalkException>,
}

impl TalkServiceGetProximityMatchCandidateListResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetProximityMatchCandidateListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ProximityMatchCandidateResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ProximityMatchCandidateResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetProximityMatchCandidateListResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetProximityMatchCandidateListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ProximityMatchCandidateResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetProximityMatchCandidateList"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetProximityMatchCandidatesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetProximityMatchCandidatesArgs {
  session_id: String,
}

impl TalkServiceGetProximityMatchCandidatesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetProximityMatchCandidatesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetProximityMatchCandidatesArgs.session_id", &f_2)?;
    let ret = TalkServiceGetProximityMatchCandidatesArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProximityMatchCandidates_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetProximityMatchCandidatesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetProximityMatchCandidatesResult {
  result_value: Option<BTreeSet<Contact>>,
  e: Option<TalkException>,
}

impl TalkServiceGetProximityMatchCandidatesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetProximityMatchCandidatesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeSet<Contact>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<Contact> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_173 = Contact::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_173);
          }
          i_prot.read_set_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetProximityMatchCandidatesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetProximityMatchCandidatesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Set, 0))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_set_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeSet<Contact>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetProximityMatchCandidates"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetRecentMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRecentMessagesArgs {
  message_box_id: String,
  messages_count: i32,
}

impl TalkServiceGetRecentMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRecentMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetRecentMessagesArgs.message_box_id", &f_2)?;
    verify_required_field_exists("TalkServiceGetRecentMessagesArgs.messages_count", &f_3)?;
    let ret = TalkServiceGetRecentMessagesArgs {
      message_box_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      messages_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getRecentMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageBoxId", TType::String, 2))?;
    o_prot.write_string(&self.message_box_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messagesCount", TType::I32, 3))?;
    o_prot.write_i32(self.messages_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetRecentMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRecentMessagesResult {
  result_value: Option<Vec<Message>>,
  e: Option<TalkException>,
}

impl TalkServiceGetRecentMessagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRecentMessagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Message>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Message> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_174 = Message::read_from_in_protocol(i_prot)?;
            val.push(list_elem_174);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetRecentMessagesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetRecentMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Message>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetRecentMessages"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetRecommendationIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRecommendationIdsArgs {
}

impl TalkServiceGetRecommendationIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRecommendationIdsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetRecommendationIdsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getRecommendationIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetRecommendationIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRecommendationIdsResult {
  result_value: Option<Vec<String>>,
  e: Option<TalkException>,
}

impl TalkServiceGetRecommendationIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRecommendationIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_175 = i_prot.read_string()?;
            val.push(list_elem_175);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetRecommendationIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetRecommendationIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetRecommendationIds"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetRoomArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRoomArgs {
  room_id: String,
}

impl TalkServiceGetRoomArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRoomArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetRoomArgs.room_id", &f_2)?;
    let ret = TalkServiceGetRoomArgs {
      room_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getRoom_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roomId", TType::String, 2))?;
    o_prot.write_string(&self.room_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetRoomResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRoomResult {
  result_value: Option<Room>,
  e: Option<TalkException>,
}

impl TalkServiceGetRoomResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRoomResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Room> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Room::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetRoomResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetRoomResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Room> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetRoom"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetRSAKeyInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRSAKeyInfoArgs {
  provider: IdentityProvider,
}

impl TalkServiceGetRSAKeyInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRSAKeyInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<IdentityProvider> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetRSAKeyInfoArgs.provider", &f_2)?;
    let ret = TalkServiceGetRSAKeyInfoArgs {
      provider: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getRSAKeyInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 2))?;
    self.provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetRSAKeyInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetRSAKeyInfoResult {
  result_value: Option<RSAKey>,
  e: Option<TalkException>,
}

impl TalkServiceGetRSAKeyInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetRSAKeyInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<RSAKey> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = RSAKey::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetRSAKeyInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetRSAKeyInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<RSAKey> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetRSAKeyInfo"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetServerTimeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetServerTimeArgs {
}

impl TalkServiceGetServerTimeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetServerTimeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetServerTimeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getServerTime_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetServerTimeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetServerTimeResult {
  result_value: Option<i64>,
  e: Option<TalkException>,
}

impl TalkServiceGetServerTimeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetServerTimeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetServerTimeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetServerTimeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetServerTime"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetSessionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSessionsArgs {
}

impl TalkServiceGetSessionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSessionsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetSessionsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSessions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetSessionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSessionsResult {
  result_value: Option<Vec<LoginSession>>,
  e: Option<TalkException>,
}

impl TalkServiceGetSessionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSessionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<LoginSession>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<LoginSession> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_176 = LoginSession::read_from_in_protocol(i_prot)?;
            val.push(list_elem_176);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetSessionsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetSessionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<LoginSession>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetSessions"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSettingsArgs {
}

impl TalkServiceGetSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSettingsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetSettingsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSettingsResult {
  result_value: Option<Settings>,
  e: Option<TalkException>,
}

impl TalkServiceGetSettingsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Settings> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Settings::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetSettingsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Settings> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetSettings"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetSettingsAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSettingsAttributesArgs {
  attr_bitset: i32,
}

impl TalkServiceGetSettingsAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSettingsAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetSettingsAttributesArgs.attr_bitset", &f_2)?;
    let ret = TalkServiceGetSettingsAttributesArgs {
      attr_bitset: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSettingsAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attrBitset", TType::I32, 2))?;
    o_prot.write_i32(self.attr_bitset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetSettingsAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSettingsAttributesResult {
  result_value: Option<Settings>,
  e: Option<TalkException>,
}

impl TalkServiceGetSettingsAttributesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSettingsAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Settings> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Settings::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetSettingsAttributesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetSettingsAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Settings> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetSettingsAttributes"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetSystemConfigurationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSystemConfigurationArgs {
}

impl TalkServiceGetSystemConfigurationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSystemConfigurationArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetSystemConfigurationArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSystemConfiguration_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetSystemConfigurationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetSystemConfigurationResult {
  result_value: Option<SystemConfiguration>,
  e: Option<TalkException>,
}

impl TalkServiceGetSystemConfigurationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetSystemConfigurationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SystemConfiguration> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SystemConfiguration::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetSystemConfigurationResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetSystemConfigurationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SystemConfiguration> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetSystemConfiguration"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetUserTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetUserTicketArgs {
}

impl TalkServiceGetUserTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetUserTicketArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetUserTicketArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUserTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetUserTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetUserTicketResult {
  result_value: Option<Ticket>,
  e: Option<TalkException>,
}

impl TalkServiceGetUserTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetUserTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Ticket> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Ticket::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetUserTicketResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetUserTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Ticket> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetUserTicket"
          )
        )
      )
    }
  }
}

//
// TalkServiceGetWapInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetWapInvitationArgs {
  invitation_hash: String,
}

impl TalkServiceGetWapInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetWapInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceGetWapInvitationArgs.invitation_hash", &f_2)?;
    let ret = TalkServiceGetWapInvitationArgs {
      invitation_hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getWapInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("invitationHash", TType::String, 2))?;
    o_prot.write_string(&self.invitation_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceGetWapInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceGetWapInvitationResult {
  result_value: Option<WapInvitation>,
  e: Option<TalkException>,
}

impl TalkServiceGetWapInvitationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceGetWapInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WapInvitation> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WapInvitation::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceGetWapInvitationResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceGetWapInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WapInvitation> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceGetWapInvitation"
          )
        )
      )
    }
  }
}

//
// TalkServiceInvalidateUserTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInvalidateUserTicketArgs {
}

impl TalkServiceInvalidateUserTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInvalidateUserTicketArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceInvalidateUserTicketArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("invalidateUserTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceInvalidateUserTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInvalidateUserTicketResult {
  e: Option<TalkException>,
}

impl TalkServiceInvalidateUserTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInvalidateUserTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceInvalidateUserTicketResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceInvalidateUserTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceInviteFriendsBySmsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteFriendsBySmsArgs {
  phone_number_list: Vec<String>,
}

impl TalkServiceInviteFriendsBySmsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteFriendsBySmsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_177 = i_prot.read_string()?;
            val.push(list_elem_177);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceInviteFriendsBySmsArgs.phone_number_list", &f_2)?;
    let ret = TalkServiceInviteFriendsBySmsArgs {
      phone_number_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("inviteFriendsBySms_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("phoneNumberList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.phone_number_list.len() as i32))?;
    for e in &self.phone_number_list {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceInviteFriendsBySmsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteFriendsBySmsResult {
  e: Option<TalkException>,
}

impl TalkServiceInviteFriendsBySmsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteFriendsBySmsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceInviteFriendsBySmsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceInviteFriendsBySmsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceInviteIntoGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteIntoGroupArgs {
  req_seq: i32,
  group_id: String,
  contact_ids: Vec<String>,
}

impl TalkServiceInviteIntoGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteIntoGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_178 = i_prot.read_string()?;
            val.push(list_elem_178);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceInviteIntoGroupArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceInviteIntoGroupArgs.group_id", &f_2)?;
    verify_required_field_exists("TalkServiceInviteIntoGroupArgs.contact_ids", &f_3)?;
    let ret = TalkServiceInviteIntoGroupArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      contact_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("inviteIntoGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.contact_ids.len() as i32))?;
    for e in &self.contact_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceInviteIntoGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteIntoGroupResult {
  e: Option<TalkException>,
}

impl TalkServiceInviteIntoGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteIntoGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceInviteIntoGroupResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceInviteIntoGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceInviteIntoRoomArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteIntoRoomArgs {
  req_seq: i32,
  room_id: String,
  contact_ids: Vec<String>,
}

impl TalkServiceInviteIntoRoomArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteIntoRoomArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_179 = i_prot.read_string()?;
            val.push(list_elem_179);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceInviteIntoRoomArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceInviteIntoRoomArgs.room_id", &f_2)?;
    verify_required_field_exists("TalkServiceInviteIntoRoomArgs.contact_ids", &f_3)?;
    let ret = TalkServiceInviteIntoRoomArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      room_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      contact_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("inviteIntoRoom_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roomId", TType::String, 2))?;
    o_prot.write_string(&self.room_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.contact_ids.len() as i32))?;
    for e in &self.contact_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceInviteIntoRoomResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteIntoRoomResult {
  e: Option<TalkException>,
}

impl TalkServiceInviteIntoRoomResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteIntoRoomResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceInviteIntoRoomResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceInviteIntoRoomResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceInviteViaEmailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteViaEmailArgs {
  req_seq: i32,
  email: String,
  name: String,
}

impl TalkServiceInviteViaEmailArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteViaEmailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceInviteViaEmailArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceInviteViaEmailArgs.email", &f_2)?;
    verify_required_field_exists("TalkServiceInviteViaEmailArgs.name", &f_3)?;
    let ret = TalkServiceInviteViaEmailArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      email: f_2.expect("auto-generated code should have checked for presence of required fields"),
      name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("inviteViaEmail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 2))?;
    o_prot.write_string(&self.email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 3))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceInviteViaEmailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceInviteViaEmailResult {
  e: Option<TalkException>,
}

impl TalkServiceInviteViaEmailResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceInviteViaEmailResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceInviteViaEmailResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceInviteViaEmailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceIsIdentityIdentifierAvailableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceIsIdentityIdentifierAvailableArgs {
  identifier: String,
  provider: IdentityProvider,
}

impl TalkServiceIsIdentityIdentifierAvailableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceIsIdentityIdentifierAvailableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<IdentityProvider> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceIsIdentityIdentifierAvailableArgs.identifier", &f_2)?;
    verify_required_field_exists("TalkServiceIsIdentityIdentifierAvailableArgs.provider", &f_3)?;
    let ret = TalkServiceIsIdentityIdentifierAvailableArgs {
      identifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      provider: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("isIdentityIdentifierAvailable_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 2))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 3))?;
    self.provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceIsIdentityIdentifierAvailableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceIsIdentityIdentifierAvailableResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl TalkServiceIsIdentityIdentifierAvailableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceIsIdentityIdentifierAvailableResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceIsIdentityIdentifierAvailableResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceIsIdentityIdentifierAvailableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceIsIdentityIdentifierAvailable"
          )
        )
      )
    }
  }
}

//
// TalkServiceIsUseridAvailableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceIsUseridAvailableArgs {
  userid: String,
}

impl TalkServiceIsUseridAvailableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceIsUseridAvailableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceIsUseridAvailableArgs.userid", &f_2)?;
    let ret = TalkServiceIsUseridAvailableArgs {
      userid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("isUseridAvailable_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userid", TType::String, 2))?;
    o_prot.write_string(&self.userid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceIsUseridAvailableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceIsUseridAvailableResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl TalkServiceIsUseridAvailableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceIsUseridAvailableResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceIsUseridAvailableResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceIsUseridAvailableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceIsUseridAvailable"
          )
        )
      )
    }
  }
}

//
// TalkServiceKickoutFromGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceKickoutFromGroupArgs {
  req_seq: i32,
  group_id: String,
  contact_ids: Vec<String>,
}

impl TalkServiceKickoutFromGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceKickoutFromGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_180 = i_prot.read_string()?;
            val.push(list_elem_180);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceKickoutFromGroupArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceKickoutFromGroupArgs.group_id", &f_2)?;
    verify_required_field_exists("TalkServiceKickoutFromGroupArgs.contact_ids", &f_3)?;
    let ret = TalkServiceKickoutFromGroupArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      contact_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("kickoutFromGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.contact_ids.len() as i32))?;
    for e in &self.contact_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceKickoutFromGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceKickoutFromGroupResult {
  e: Option<TalkException>,
}

impl TalkServiceKickoutFromGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceKickoutFromGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceKickoutFromGroupResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceKickoutFromGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceLeaveGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLeaveGroupArgs {
  req_seq: i32,
  group_id: String,
}

impl TalkServiceLeaveGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLeaveGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLeaveGroupArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceLeaveGroupArgs.group_id", &f_2)?;
    let ret = TalkServiceLeaveGroupArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("leaveGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLeaveGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLeaveGroupResult {
  e: Option<TalkException>,
}

impl TalkServiceLeaveGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLeaveGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLeaveGroupResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLeaveGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceLeaveRoomArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLeaveRoomArgs {
  req_seq: i32,
  room_id: String,
}

impl TalkServiceLeaveRoomArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLeaveRoomArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLeaveRoomArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceLeaveRoomArgs.room_id", &f_2)?;
    let ret = TalkServiceLeaveRoomArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      room_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("leaveRoom_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roomId", TType::String, 2))?;
    o_prot.write_string(&self.room_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLeaveRoomResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLeaveRoomResult {
  e: Option<TalkException>,
}

impl TalkServiceLeaveRoomResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLeaveRoomResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLeaveRoomResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLeaveRoomResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceLoginWithIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithIdentityCredentialArgs {
  identifier: String,
  password: String,
  keep_logged_in: bool,
  access_location: String,
  system_name: String,
  identity_provider: IdentityProvider,
  certificate: String,
}

impl TalkServiceLoginWithIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<IdentityProvider> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialArgs.identifier", &f_3)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialArgs.password", &f_4)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialArgs.keep_logged_in", &f_5)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialArgs.access_location", &f_6)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialArgs.system_name", &f_7)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialArgs.identity_provider", &f_8)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialArgs.certificate", &f_9)?;
    let ret = TalkServiceLoginWithIdentityCredentialArgs {
      identifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      password: f_4.expect("auto-generated code should have checked for presence of required fields"),
      keep_logged_in: f_5.expect("auto-generated code should have checked for presence of required fields"),
      access_location: f_6.expect("auto-generated code should have checked for presence of required fields"),
      system_name: f_7.expect("auto-generated code should have checked for presence of required fields"),
      identity_provider: f_8.expect("auto-generated code should have checked for presence of required fields"),
      certificate: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("loginWithIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 3))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 4))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("keepLoggedIn", TType::Bool, 5))?;
    o_prot.write_bool(self.keep_logged_in)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("accessLocation", TType::String, 6))?;
    o_prot.write_string(&self.access_location)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("systemName", TType::String, 7))?;
    o_prot.write_string(&self.system_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identityProvider", TType::I32, 8))?;
    self.identity_provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("certificate", TType::String, 9))?;
    o_prot.write_string(&self.certificate)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLoginWithIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithIdentityCredentialResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceLoginWithIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLoginWithIdentityCredentialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLoginWithIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceLoginWithIdentityCredential"
          )
        )
      )
    }
  }
}

//
// TalkServiceLoginWithIdentityCredentialForCertificateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithIdentityCredentialForCertificateArgs {
  identifier: String,
  password: String,
  keep_logged_in: bool,
  access_location: String,
  system_name: String,
  identity_provider: IdentityProvider,
  certificate: String,
}

impl TalkServiceLoginWithIdentityCredentialForCertificateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithIdentityCredentialForCertificateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<IdentityProvider> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialForCertificateArgs.identifier", &f_3)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialForCertificateArgs.password", &f_4)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialForCertificateArgs.keep_logged_in", &f_5)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialForCertificateArgs.access_location", &f_6)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialForCertificateArgs.system_name", &f_7)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialForCertificateArgs.identity_provider", &f_8)?;
    verify_required_field_exists("TalkServiceLoginWithIdentityCredentialForCertificateArgs.certificate", &f_9)?;
    let ret = TalkServiceLoginWithIdentityCredentialForCertificateArgs {
      identifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      password: f_4.expect("auto-generated code should have checked for presence of required fields"),
      keep_logged_in: f_5.expect("auto-generated code should have checked for presence of required fields"),
      access_location: f_6.expect("auto-generated code should have checked for presence of required fields"),
      system_name: f_7.expect("auto-generated code should have checked for presence of required fields"),
      identity_provider: f_8.expect("auto-generated code should have checked for presence of required fields"),
      certificate: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("loginWithIdentityCredentialForCertificate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 3))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 4))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("keepLoggedIn", TType::Bool, 5))?;
    o_prot.write_bool(self.keep_logged_in)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("accessLocation", TType::String, 6))?;
    o_prot.write_string(&self.access_location)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("systemName", TType::String, 7))?;
    o_prot.write_string(&self.system_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identityProvider", TType::I32, 8))?;
    self.identity_provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("certificate", TType::String, 9))?;
    o_prot.write_string(&self.certificate)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLoginWithIdentityCredentialForCertificateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithIdentityCredentialForCertificateResult {
  result_value: Option<LoginResult>,
  e: Option<TalkException>,
}

impl TalkServiceLoginWithIdentityCredentialForCertificateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithIdentityCredentialForCertificateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LoginResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LoginResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLoginWithIdentityCredentialForCertificateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLoginWithIdentityCredentialForCertificateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LoginResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceLoginWithIdentityCredentialForCertificate"
          )
        )
      )
    }
  }
}

//
// TalkServiceLoginWithVerifierArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithVerifierArgs {
  verifier: String,
}

impl TalkServiceLoginWithVerifierArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithVerifierArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLoginWithVerifierArgs.verifier", &f_3)?;
    let ret = TalkServiceLoginWithVerifierArgs {
      verifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("loginWithVerifier_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 3))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLoginWithVerifierResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithVerifierResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceLoginWithVerifierResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithVerifierResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLoginWithVerifierResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLoginWithVerifierResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceLoginWithVerifier"
          )
        )
      )
    }
  }
}

//
// TalkServiceLoginWithVerifierForCerificateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithVerifierForCerificateArgs {
  verifier: String,
}

impl TalkServiceLoginWithVerifierForCerificateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithVerifierForCerificateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLoginWithVerifierForCerificateArgs.verifier", &f_3)?;
    let ret = TalkServiceLoginWithVerifierForCerificateArgs {
      verifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("loginWithVerifierForCerificate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 3))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLoginWithVerifierForCerificateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithVerifierForCerificateResult {
  result_value: Option<LoginResult>,
  e: Option<TalkException>,
}

impl TalkServiceLoginWithVerifierForCerificateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithVerifierForCerificateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LoginResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LoginResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLoginWithVerifierForCerificateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLoginWithVerifierForCerificateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LoginResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceLoginWithVerifierForCerificate"
          )
        )
      )
    }
  }
}

//
// TalkServiceLoginWithVerifierForCertificateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithVerifierForCertificateArgs {
  verifier: String,
}

impl TalkServiceLoginWithVerifierForCertificateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithVerifierForCertificateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLoginWithVerifierForCertificateArgs.verifier", &f_3)?;
    let ret = TalkServiceLoginWithVerifierForCertificateArgs {
      verifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("loginWithVerifierForCertificate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 3))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLoginWithVerifierForCertificateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLoginWithVerifierForCertificateResult {
  result_value: Option<LoginResult>,
  e: Option<TalkException>,
}

impl TalkServiceLoginWithVerifierForCertificateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLoginWithVerifierForCertificateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LoginResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LoginResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLoginWithVerifierForCertificateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLoginWithVerifierForCertificateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LoginResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceLoginWithVerifierForCertificate"
          )
        )
      )
    }
  }
}

//
// TalkServiceLogoutArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLogoutArgs {
}

impl TalkServiceLogoutArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLogoutArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLogoutArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("logout_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLogoutResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLogoutResult {
  e: Option<TalkException>,
}

impl TalkServiceLogoutResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLogoutResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLogoutResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLogoutResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceLogoutSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLogoutSessionArgs {
  token_key: String,
}

impl TalkServiceLogoutSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLogoutSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceLogoutSessionArgs.token_key", &f_2)?;
    let ret = TalkServiceLogoutSessionArgs {
      token_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("logoutSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tokenKey", TType::String, 2))?;
    o_prot.write_string(&self.token_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceLogoutSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceLogoutSessionResult {
  e: Option<TalkException>,
}

impl TalkServiceLogoutSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceLogoutSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceLogoutSessionResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceLogoutSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceNoopArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNoopArgs {
}

impl TalkServiceNoopArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNoopArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNoopArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("noop_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNoopResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNoopResult {
  e: Option<TalkException>,
}

impl TalkServiceNoopResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNoopResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNoopResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNoopResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceNotifiedRedirectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifiedRedirectArgs {
  param_map: BTreeMap<String, String>,
}

impl TalkServiceNotifiedRedirectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifiedRedirectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_181 = i_prot.read_string()?;
            let map_val_182 = i_prot.read_string()?;
            val.insert(map_key_181, map_val_182);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceNotifiedRedirectArgs.param_map", &f_2)?;
    let ret = TalkServiceNotifiedRedirectArgs {
      param_map: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifiedRedirect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paramMap", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.param_map.len() as i32))?;
    for (k, v) in &self.param_map {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNotifiedRedirectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifiedRedirectResult {
  e: Option<TalkException>,
}

impl TalkServiceNotifiedRedirectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifiedRedirectResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNotifiedRedirectResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNotifiedRedirectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceNotifyBuddyOnAirArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyBuddyOnAirArgs {
  seq: i32,
  receiver_mids: Vec<String>,
}

impl TalkServiceNotifyBuddyOnAirArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyBuddyOnAirArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_183 = i_prot.read_string()?;
            val.push(list_elem_183);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceNotifyBuddyOnAirArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceNotifyBuddyOnAirArgs.receiver_mids", &f_2)?;
    let ret = TalkServiceNotifyBuddyOnAirArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      receiver_mids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyBuddyOnAir_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.receiver_mids.len() as i32))?;
    for e in &self.receiver_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNotifyBuddyOnAirResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyBuddyOnAirResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TalkException>,
}

impl TalkServiceNotifyBuddyOnAirResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyBuddyOnAirResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_184 = i_prot.read_string()?;
            let map_val_185 = i_prot.read_string()?;
            val.insert(map_key_184, map_val_185);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNotifyBuddyOnAirResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNotifyBuddyOnAirResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceNotifyBuddyOnAir"
          )
        )
      )
    }
  }
}

//
// TalkServiceNotifyIndividualEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyIndividualEventArgs {
  notification_status: NotificationStatus,
  receiver_mids: Vec<String>,
}

impl TalkServiceNotifyIndividualEventArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyIndividualEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<NotificationStatus> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = NotificationStatus::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_186 = i_prot.read_string()?;
            val.push(list_elem_186);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceNotifyIndividualEventArgs.notification_status", &f_2)?;
    verify_required_field_exists("TalkServiceNotifyIndividualEventArgs.receiver_mids", &f_3)?;
    let ret = TalkServiceNotifyIndividualEventArgs {
      notification_status: f_2.expect("auto-generated code should have checked for presence of required fields"),
      receiver_mids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyIndividualEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationStatus", TType::I32, 2))?;
    self.notification_status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMids", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.receiver_mids.len() as i32))?;
    for e in &self.receiver_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNotifyIndividualEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyIndividualEventResult {
  e: Option<TalkException>,
}

impl TalkServiceNotifyIndividualEventResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyIndividualEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNotifyIndividualEventResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNotifyIndividualEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceNotifyInstalledArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyInstalledArgs {
  udid_hash: String,
  application_type_with_extensions: String,
}

impl TalkServiceNotifyInstalledArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyInstalledArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceNotifyInstalledArgs.udid_hash", &f_2)?;
    verify_required_field_exists("TalkServiceNotifyInstalledArgs.application_type_with_extensions", &f_3)?;
    let ret = TalkServiceNotifyInstalledArgs {
      udid_hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
      application_type_with_extensions: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyInstalled_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 2))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("applicationTypeWithExtensions", TType::String, 3))?;
    o_prot.write_string(&self.application_type_with_extensions)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNotifyInstalledResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyInstalledResult {
}

impl TalkServiceNotifyInstalledResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyInstalledResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNotifyInstalledResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNotifyInstalledResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// TalkServiceNotifyRegistrationCompleteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyRegistrationCompleteArgs {
  udid_hash: String,
  application_type_with_extensions: String,
}

impl TalkServiceNotifyRegistrationCompleteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyRegistrationCompleteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceNotifyRegistrationCompleteArgs.udid_hash", &f_2)?;
    verify_required_field_exists("TalkServiceNotifyRegistrationCompleteArgs.application_type_with_extensions", &f_3)?;
    let ret = TalkServiceNotifyRegistrationCompleteArgs {
      udid_hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
      application_type_with_extensions: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyRegistrationComplete_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 2))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("applicationTypeWithExtensions", TType::String, 3))?;
    o_prot.write_string(&self.application_type_with_extensions)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNotifyRegistrationCompleteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyRegistrationCompleteResult {
}

impl TalkServiceNotifyRegistrationCompleteResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyRegistrationCompleteResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNotifyRegistrationCompleteResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNotifyRegistrationCompleteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// TalkServiceNotifySleepArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifySleepArgs {
  last_rev: i64,
  badge: i32,
}

impl TalkServiceNotifySleepArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifySleepArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceNotifySleepArgs.last_rev", &f_2)?;
    verify_required_field_exists("TalkServiceNotifySleepArgs.badge", &f_3)?;
    let ret = TalkServiceNotifySleepArgs {
      last_rev: f_2.expect("auto-generated code should have checked for presence of required fields"),
      badge: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifySleep_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastRev", TType::I64, 2))?;
    o_prot.write_i64(self.last_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("badge", TType::I32, 3))?;
    o_prot.write_i32(self.badge)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNotifySleepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifySleepResult {
  e: Option<TalkException>,
}

impl TalkServiceNotifySleepResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifySleepResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNotifySleepResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNotifySleepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceNotifyUpdatedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyUpdatedArgs {
  last_rev: i64,
  device_info: DeviceInfo,
}

impl TalkServiceNotifyUpdatedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyUpdatedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<DeviceInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceNotifyUpdatedArgs.last_rev", &f_2)?;
    verify_required_field_exists("TalkServiceNotifyUpdatedArgs.device_info", &f_3)?;
    let ret = TalkServiceNotifyUpdatedArgs {
      last_rev: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notifyUpdated_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastRev", TType::I64, 2))?;
    o_prot.write_i64(self.last_rev)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 3))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceNotifyUpdatedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceNotifyUpdatedResult {
  e: Option<TalkException>,
}

impl TalkServiceNotifyUpdatedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceNotifyUpdatedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceNotifyUpdatedResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceNotifyUpdatedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceOpenProximityMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceOpenProximityMatchArgs {
  location: Location,
}

impl TalkServiceOpenProximityMatchArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceOpenProximityMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Location> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = Location::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceOpenProximityMatchArgs.location", &f_2)?;
    let ret = TalkServiceOpenProximityMatchArgs {
      location: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("openProximityMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::Struct, 2))?;
    self.location.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceOpenProximityMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceOpenProximityMatchResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceOpenProximityMatchResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceOpenProximityMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceOpenProximityMatchResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceOpenProximityMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceOpenProximityMatch"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterBuddyUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterBuddyUserArgs {
  buddy_id: String,
  registrar_password: String,
}

impl TalkServiceRegisterBuddyUserArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterBuddyUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterBuddyUserArgs.buddy_id", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterBuddyUserArgs.registrar_password", &f_3)?;
    let ret = TalkServiceRegisterBuddyUserArgs {
      buddy_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      registrar_password: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerBuddyUser_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buddyId", TType::String, 2))?;
    o_prot.write_string(&self.buddy_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("registrarPassword", TType::String, 3))?;
    o_prot.write_string(&self.registrar_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterBuddyUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterBuddyUserResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterBuddyUserResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterBuddyUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterBuddyUserResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterBuddyUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterBuddyUser"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterBuddyUseridArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterBuddyUseridArgs {
  seq: i32,
  userid: String,
}

impl TalkServiceRegisterBuddyUseridArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterBuddyUseridArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterBuddyUseridArgs.seq", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterBuddyUseridArgs.userid", &f_3)?;
    let ret = TalkServiceRegisterBuddyUseridArgs {
      seq: f_2.expect("auto-generated code should have checked for presence of required fields"),
      userid: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerBuddyUserid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 2))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userid", TType::String, 3))?;
    o_prot.write_string(&self.userid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterBuddyUseridResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterBuddyUseridResult {
  e: Option<TalkException>,
}

impl TalkServiceRegisterBuddyUseridResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterBuddyUseridResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterBuddyUseridResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterBuddyUseridResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceRegisterDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceArgs {
  session_id: String,
}

impl TalkServiceRegisterDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterDeviceArgs.session_id", &f_2)?;
    let ret = TalkServiceRegisterDeviceArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterDeviceResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterDevice"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterDeviceWithIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceWithIdentityCredentialArgs {
  session_id: String,
  identifier: String,
  verifier: String,
  provider: IdentityProvider,
}

impl TalkServiceRegisterDeviceWithIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceWithIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<IdentityProvider> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithIdentityCredentialArgs.session_id", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithIdentityCredentialArgs.identifier", &f_3)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithIdentityCredentialArgs.verifier", &f_4)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithIdentityCredentialArgs.provider", &f_5)?;
    let ret = TalkServiceRegisterDeviceWithIdentityCredentialArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      identifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      verifier: f_4.expect("auto-generated code should have checked for presence of required fields"),
      provider: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerDeviceWithIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 3))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 4))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 5))?;
    self.provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterDeviceWithIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceWithIdentityCredentialResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterDeviceWithIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceWithIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterDeviceWithIdentityCredentialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterDeviceWithIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterDeviceWithIdentityCredential"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterDeviceWithoutPhoneNumberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceWithoutPhoneNumberArgs {
  region: String,
  udid_hash: String,
  device_info: DeviceInfo,
}

impl TalkServiceRegisterDeviceWithoutPhoneNumberArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceWithoutPhoneNumberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<DeviceInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberArgs.region", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberArgs.udid_hash", &f_3)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberArgs.device_info", &f_4)?;
    let ret = TalkServiceRegisterDeviceWithoutPhoneNumberArgs {
      region: f_2.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerDeviceWithoutPhoneNumber_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 2))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 3))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 4))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterDeviceWithoutPhoneNumberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceWithoutPhoneNumberResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterDeviceWithoutPhoneNumberResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceWithoutPhoneNumberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterDeviceWithoutPhoneNumberResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterDeviceWithoutPhoneNumberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterDeviceWithoutPhoneNumber"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs {
  region: String,
  udid_hash: String,
  device_info: DeviceInfo,
  provider: IdentityProvider,
  identifier: String,
  verifier: String,
  mid: String,
}

impl TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<DeviceInfo> = None;
    let mut f_5: Option<IdentityProvider> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs.region", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs.udid_hash", &f_3)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs.device_info", &f_4)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs.provider", &f_5)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs.identifier", &f_6)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs.verifier", &f_7)?;
    verify_required_field_exists("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs.mid", &f_8)?;
    let ret = TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialArgs {
      region: f_2.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_4.expect("auto-generated code should have checked for presence of required fields"),
      provider: f_5.expect("auto-generated code should have checked for presence of required fields"),
      identifier: f_6.expect("auto-generated code should have checked for presence of required fields"),
      verifier: f_7.expect("auto-generated code should have checked for presence of required fields"),
      mid: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerDeviceWithoutPhoneNumberWithIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 2))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 3))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 4))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 5))?;
    self.provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 6))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 7))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 8))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterDeviceWithoutPhoneNumberWithIdentityCredential"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterUseridArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterUseridArgs {
  req_seq: i32,
  userid: String,
}

impl TalkServiceRegisterUseridArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterUseridArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterUseridArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceRegisterUseridArgs.userid", &f_2)?;
    let ret = TalkServiceRegisterUseridArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      userid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerUserid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userid", TType::String, 2))?;
    o_prot.write_string(&self.userid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterUseridResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterUseridResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterUseridResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterUseridResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterUseridResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterUseridResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterUserid"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterWapDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWapDeviceArgs {
  invitation_hash: String,
  guid_hash: String,
  email: String,
  device_info: DeviceInfo,
}

impl TalkServiceRegisterWapDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWapDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<DeviceInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterWapDeviceArgs.invitation_hash", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterWapDeviceArgs.guid_hash", &f_3)?;
    verify_required_field_exists("TalkServiceRegisterWapDeviceArgs.email", &f_4)?;
    verify_required_field_exists("TalkServiceRegisterWapDeviceArgs.device_info", &f_5)?;
    let ret = TalkServiceRegisterWapDeviceArgs {
      invitation_hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
      guid_hash: f_3.expect("auto-generated code should have checked for presence of required fields"),
      email: f_4.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerWapDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("invitationHash", TType::String, 2))?;
    o_prot.write_string(&self.invitation_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guidHash", TType::String, 3))?;
    o_prot.write_string(&self.guid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 4))?;
    o_prot.write_string(&self.email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 5))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterWapDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWapDeviceResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterWapDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWapDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterWapDeviceResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterWapDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterWapDevice"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs {
  identity_credential: IdentityCredential,
  region: String,
  udid_hash: String,
  device_info: DeviceInfo,
}

impl TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<IdentityCredential> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<DeviceInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = IdentityCredential::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs.identity_credential", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs.region", &f_3)?;
    verify_required_field_exists("TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs.udid_hash", &f_4)?;
    verify_required_field_exists("TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs.device_info", &f_5)?;
    let ret = TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialArgs {
      identity_credential: f_2.expect("auto-generated code should have checked for presence of required fields"),
      region: f_3.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_4.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerWithExistingSnsIdAndIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identityCredential", TType::Struct, 2))?;
    self.identity_credential.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 3))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 4))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 5))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterWithExistingSnsIdAndIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterWithExistingSnsIdAndIdentityCredential"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterWithSnsIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWithSnsIdArgs {
  sns_id_type: SnsIdType,
  sns_access_token: String,
  region: String,
  udid_hash: String,
  device_info: DeviceInfo,
  mid: String,
}

impl TalkServiceRegisterWithSnsIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWithSnsIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<DeviceInfo> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdArgs.sns_id_type", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdArgs.sns_access_token", &f_3)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdArgs.region", &f_4)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdArgs.udid_hash", &f_5)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdArgs.device_info", &f_6)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdArgs.mid", &f_7)?;
    let ret = TalkServiceRegisterWithSnsIdArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sns_access_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
      region: f_4.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_5.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_6.expect("auto-generated code should have checked for presence of required fields"),
      mid: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerWithSnsId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsAccessToken", TType::String, 3))?;
    o_prot.write_string(&self.sns_access_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 4))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 5))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 6))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 7))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterWithSnsIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWithSnsIdResult {
  result_value: Option<RegisterWithSnsIdResult>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterWithSnsIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWithSnsIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<RegisterWithSnsIdResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = RegisterWithSnsIdResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterWithSnsIdResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterWithSnsIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<RegisterWithSnsIdResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterWithSnsId"
          )
        )
      )
    }
  }
}

//
// TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs {
  sns_id_type: SnsIdType,
  sns_access_token: String,
  identity_credential: IdentityCredential,
  region: String,
  udid_hash: String,
  device_info: DeviceInfo,
}

impl TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<IdentityCredential> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<DeviceInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = IdentityCredential::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs.sns_id_type", &f_2)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs.sns_access_token", &f_3)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs.identity_credential", &f_4)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs.region", &f_5)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs.udid_hash", &f_6)?;
    verify_required_field_exists("TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs.device_info", &f_7)?;
    let ret = TalkServiceRegisterWithSnsIdAndIdentityCredentialArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sns_access_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
      identity_credential: f_4.expect("auto-generated code should have checked for presence of required fields"),
      region: f_5.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_6.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerWithSnsIdAndIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsAccessToken", TType::String, 3))?;
    o_prot.write_string(&self.sns_access_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identityCredential", TType::Struct, 4))?;
    self.identity_credential.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 5))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 6))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 7))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRegisterWithSnsIdAndIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRegisterWithSnsIdAndIdentityCredentialResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRegisterWithSnsIdAndIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRegisterWithSnsIdAndIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRegisterWithSnsIdAndIdentityCredentialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRegisterWithSnsIdAndIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRegisterWithSnsIdAndIdentityCredential"
          )
        )
      )
    }
  }
}

//
// TalkServiceReissueDeviceCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReissueDeviceCredentialArgs {
}

impl TalkServiceReissueDeviceCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReissueDeviceCredentialArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReissueDeviceCredentialArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reissueDeviceCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReissueDeviceCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReissueDeviceCredentialResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceReissueDeviceCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReissueDeviceCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReissueDeviceCredentialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReissueDeviceCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceReissueDeviceCredential"
          )
        )
      )
    }
  }
}

//
// TalkServiceReissueUserTicketArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReissueUserTicketArgs {
  expiration_time: i64,
  max_use_count: i32,
}

impl TalkServiceReissueUserTicketArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReissueUserTicketArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReissueUserTicketArgs.expiration_time", &f_3)?;
    verify_required_field_exists("TalkServiceReissueUserTicketArgs.max_use_count", &f_4)?;
    let ret = TalkServiceReissueUserTicketArgs {
      expiration_time: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_use_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reissueUserTicket_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expirationTime", TType::I64, 3))?;
    o_prot.write_i64(self.expiration_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxUseCount", TType::I32, 4))?;
    o_prot.write_i32(self.max_use_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReissueUserTicketResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReissueUserTicketResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceReissueUserTicketResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReissueUserTicketResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReissueUserTicketResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReissueUserTicketResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceReissueUserTicket"
          )
        )
      )
    }
  }
}

//
// TalkServiceRejectGroupInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRejectGroupInvitationArgs {
  req_seq: i32,
  group_id: String,
}

impl TalkServiceRejectGroupInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRejectGroupInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRejectGroupInvitationArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceRejectGroupInvitationArgs.group_id", &f_2)?;
    let ret = TalkServiceRejectGroupInvitationArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("rejectGroupInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRejectGroupInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRejectGroupInvitationResult {
  e: Option<TalkException>,
}

impl TalkServiceRejectGroupInvitationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRejectGroupInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRejectGroupInvitationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRejectGroupInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceReleaseSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReleaseSessionArgs {
}

impl TalkServiceReleaseSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReleaseSessionArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReleaseSessionArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("releaseSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReleaseSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReleaseSessionResult {
  e: Option<TalkException>,
}

impl TalkServiceReleaseSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReleaseSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReleaseSessionResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReleaseSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceRemoveAllMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveAllMessagesArgs {
  seq: i32,
  last_message_id: String,
}

impl TalkServiceRemoveAllMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveAllMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRemoveAllMessagesArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceRemoveAllMessagesArgs.last_message_id", &f_2)?;
    let ret = TalkServiceRemoveAllMessagesArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      last_message_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeAllMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastMessageId", TType::String, 2))?;
    o_prot.write_string(&self.last_message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRemoveAllMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveAllMessagesResult {
  e: Option<TalkException>,
}

impl TalkServiceRemoveAllMessagesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveAllMessagesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRemoveAllMessagesResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRemoveAllMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceRemoveBuddyLocationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveBuddyLocationArgs {
  mid: String,
  index: i32,
}

impl TalkServiceRemoveBuddyLocationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveBuddyLocationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRemoveBuddyLocationArgs.mid", &f_2)?;
    verify_required_field_exists("TalkServiceRemoveBuddyLocationArgs.index", &f_3)?;
    let ret = TalkServiceRemoveBuddyLocationArgs {
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeBuddyLocation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index", TType::I32, 3))?;
    o_prot.write_i32(self.index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRemoveBuddyLocationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveBuddyLocationResult {
  e: Option<TalkException>,
}

impl TalkServiceRemoveBuddyLocationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveBuddyLocationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRemoveBuddyLocationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRemoveBuddyLocationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceRemoveMessageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveMessageArgs {
  message_id: String,
}

impl TalkServiceRemoveMessageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveMessageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRemoveMessageArgs.message_id", &f_2)?;
    let ret = TalkServiceRemoveMessageArgs {
      message_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeMessage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 2))?;
    o_prot.write_string(&self.message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRemoveMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveMessageResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl TalkServiceRemoveMessageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveMessageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRemoveMessageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRemoveMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRemoveMessage"
          )
        )
      )
    }
  }
}

//
// TalkServiceRemoveMessageFromMyHomeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveMessageFromMyHomeArgs {
  message_id: String,
}

impl TalkServiceRemoveMessageFromMyHomeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveMessageFromMyHomeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRemoveMessageFromMyHomeArgs.message_id", &f_2)?;
    let ret = TalkServiceRemoveMessageFromMyHomeArgs {
      message_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeMessageFromMyHome_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 2))?;
    o_prot.write_string(&self.message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRemoveMessageFromMyHomeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveMessageFromMyHomeResult {
  result_value: Option<bool>,
  e: Option<TalkException>,
}

impl TalkServiceRemoveMessageFromMyHomeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveMessageFromMyHomeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRemoveMessageFromMyHomeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRemoveMessageFromMyHomeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRemoveMessageFromMyHome"
          )
        )
      )
    }
  }
}

//
// TalkServiceRemoveSnsIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveSnsIdArgs {
  sns_id_type: SnsIdType,
}

impl TalkServiceRemoveSnsIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveSnsIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<SnsIdType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = SnsIdType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRemoveSnsIdArgs.sns_id_type", &f_2)?;
    let ret = TalkServiceRemoveSnsIdArgs {
      sns_id_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeSnsId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("snsIdType", TType::I32, 2))?;
    self.sns_id_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRemoveSnsIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRemoveSnsIdResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceRemoveSnsIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRemoveSnsIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRemoveSnsIdResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRemoveSnsIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRemoveSnsId"
          )
        )
      )
    }
  }
}

//
// TalkServiceReportArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportArgs {
  sync_op_revision: i64,
  category: SyncCategory,
  report: String,
}

impl TalkServiceReportArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<SyncCategory> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = SyncCategory::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReportArgs.sync_op_revision", &f_2)?;
    verify_required_field_exists("TalkServiceReportArgs.category", &f_3)?;
    verify_required_field_exists("TalkServiceReportArgs.report", &f_4)?;
    let ret = TalkServiceReportArgs {
      sync_op_revision: f_2.expect("auto-generated code should have checked for presence of required fields"),
      category: f_3.expect("auto-generated code should have checked for presence of required fields"),
      report: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("report_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("syncOpRevision", TType::I64, 2))?;
    o_prot.write_i64(self.sync_op_revision)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::I32, 3))?;
    self.category.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("report", TType::String, 4))?;
    o_prot.write_string(&self.report)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReportResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportResult {
  e: Option<TalkException>,
}

impl TalkServiceReportResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReportResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReportResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceReportContactsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportContactsArgs {
  sync_op_revision: i64,
  category: SyncCategory,
  contact_reports: Vec<ContactReport>,
  action_type: SyncActionType,
}

impl TalkServiceReportContactsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportContactsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<SyncCategory> = None;
    let mut f_4: Option<Vec<ContactReport>> = None;
    let mut f_5: Option<SyncActionType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = SyncCategory::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ContactReport> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_187 = ContactReport::read_from_in_protocol(i_prot)?;
            val.push(list_elem_187);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = SyncActionType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReportContactsArgs.sync_op_revision", &f_2)?;
    verify_required_field_exists("TalkServiceReportContactsArgs.category", &f_3)?;
    verify_required_field_exists("TalkServiceReportContactsArgs.contact_reports", &f_4)?;
    verify_required_field_exists("TalkServiceReportContactsArgs.action_type", &f_5)?;
    let ret = TalkServiceReportContactsArgs {
      sync_op_revision: f_2.expect("auto-generated code should have checked for presence of required fields"),
      category: f_3.expect("auto-generated code should have checked for presence of required fields"),
      contact_reports: f_4.expect("auto-generated code should have checked for presence of required fields"),
      action_type: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reportContacts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("syncOpRevision", TType::I64, 2))?;
    o_prot.write_i64(self.sync_op_revision)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::I32, 3))?;
    self.category.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactReports", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.contact_reports.len() as i32))?;
    for e in &self.contact_reports {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("actionType", TType::I32, 5))?;
    self.action_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReportContactsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportContactsResult {
  result_value: Option<Vec<ContactReportResult>>,
  e: Option<TalkException>,
}

impl TalkServiceReportContactsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportContactsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<ContactReportResult>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ContactReportResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_188 = ContactReportResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_188);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReportContactsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReportContactsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<ContactReportResult>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceReportContacts"
          )
        )
      )
    }
  }
}

//
// TalkServiceReportGroupsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportGroupsArgs {
  sync_op_revision: i64,
  groups: Vec<Group>,
}

impl TalkServiceReportGroupsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportGroupsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Vec<Group>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Group> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_189 = Group::read_from_in_protocol(i_prot)?;
            val.push(list_elem_189);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReportGroupsArgs.sync_op_revision", &f_2)?;
    verify_required_field_exists("TalkServiceReportGroupsArgs.groups", &f_3)?;
    let ret = TalkServiceReportGroupsArgs {
      sync_op_revision: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reportGroups_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("syncOpRevision", TType::I64, 2))?;
    o_prot.write_i64(self.sync_op_revision)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.groups.len() as i32))?;
    for e in &self.groups {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReportGroupsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportGroupsResult {
  e: Option<TalkException>,
}

impl TalkServiceReportGroupsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportGroupsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReportGroupsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReportGroupsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceReportProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportProfileArgs {
  sync_op_revision: i64,
  profile: Profile,
}

impl TalkServiceReportProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Profile> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Profile::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReportProfileArgs.sync_op_revision", &f_2)?;
    verify_required_field_exists("TalkServiceReportProfileArgs.profile", &f_3)?;
    let ret = TalkServiceReportProfileArgs {
      sync_op_revision: f_2.expect("auto-generated code should have checked for presence of required fields"),
      profile: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reportProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("syncOpRevision", TType::I64, 2))?;
    o_prot.write_i64(self.sync_op_revision)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profile", TType::Struct, 3))?;
    self.profile.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReportProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportProfileResult {
  e: Option<TalkException>,
}

impl TalkServiceReportProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReportProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReportProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceReportRoomsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportRoomsArgs {
  sync_op_revision: i64,
  rooms: Vec<Room>,
}

impl TalkServiceReportRoomsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportRoomsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Vec<Room>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Room> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_190 = Room::read_from_in_protocol(i_prot)?;
            val.push(list_elem_190);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReportRoomsArgs.sync_op_revision", &f_2)?;
    verify_required_field_exists("TalkServiceReportRoomsArgs.rooms", &f_3)?;
    let ret = TalkServiceReportRoomsArgs {
      sync_op_revision: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rooms: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reportRooms_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("syncOpRevision", TType::I64, 2))?;
    o_prot.write_i64(self.sync_op_revision)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rooms", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rooms.len() as i32))?;
    for e in &self.rooms {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReportRoomsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportRoomsResult {
  e: Option<TalkException>,
}

impl TalkServiceReportRoomsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportRoomsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReportRoomsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReportRoomsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceReportSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportSettingsArgs {
  sync_op_revision: i64,
  settings: Settings,
}

impl TalkServiceReportSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportSettingsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Settings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Settings::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReportSettingsArgs.sync_op_revision", &f_2)?;
    verify_required_field_exists("TalkServiceReportSettingsArgs.settings", &f_3)?;
    let ret = TalkServiceReportSettingsArgs {
      sync_op_revision: f_2.expect("auto-generated code should have checked for presence of required fields"),
      settings: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reportSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("syncOpRevision", TType::I64, 2))?;
    o_prot.write_i64(self.sync_op_revision)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::Struct, 3))?;
    self.settings.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReportSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportSettingsResult {
  e: Option<TalkException>,
}

impl TalkServiceReportSettingsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReportSettingsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReportSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceReportSpammerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportSpammerArgs {
  spammer_mid: String,
  spammer_reasons: Vec<SpammerReason>,
  spam_message_ids: Vec<String>,
}

impl TalkServiceReportSpammerArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportSpammerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<SpammerReason>> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpammerReason> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_191 = SpammerReason::read_from_in_protocol(i_prot)?;
            val.push(list_elem_191);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_192 = i_prot.read_string()?;
            val.push(list_elem_192);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceReportSpammerArgs.spammer_mid", &f_2)?;
    verify_required_field_exists("TalkServiceReportSpammerArgs.spammer_reasons", &f_3)?;
    verify_required_field_exists("TalkServiceReportSpammerArgs.spam_message_ids", &f_4)?;
    let ret = TalkServiceReportSpammerArgs {
      spammer_mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      spammer_reasons: f_3.expect("auto-generated code should have checked for presence of required fields"),
      spam_message_ids: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reportSpammer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spammerMid", TType::String, 2))?;
    o_prot.write_string(&self.spammer_mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spammerReasons", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.spammer_reasons.len() as i32))?;
    for e in &self.spammer_reasons {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spamMessageIds", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.spam_message_ids.len() as i32))?;
    for e in &self.spam_message_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceReportSpammerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceReportSpammerResult {
  e: Option<TalkException>,
}

impl TalkServiceReportSpammerResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceReportSpammerResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceReportSpammerResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceReportSpammerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceRequestAccountPasswordResetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRequestAccountPasswordResetArgs {
  identifier: String,
  provider: IdentityProvider,
  locale: String,
}

impl TalkServiceRequestAccountPasswordResetArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRequestAccountPasswordResetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_4: Option<IdentityProvider> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        4 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRequestAccountPasswordResetArgs.identifier", &f_2)?;
    verify_required_field_exists("TalkServiceRequestAccountPasswordResetArgs.provider", &f_4)?;
    verify_required_field_exists("TalkServiceRequestAccountPasswordResetArgs.locale", &f_5)?;
    let ret = TalkServiceRequestAccountPasswordResetArgs {
      identifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      provider: f_4.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestAccountPasswordReset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 2))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 4))?;
    self.provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 5))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRequestAccountPasswordResetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRequestAccountPasswordResetResult {
  e: Option<TalkException>,
}

impl TalkServiceRequestAccountPasswordResetResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRequestAccountPasswordResetResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRequestAccountPasswordResetResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRequestAccountPasswordResetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceRequestEmailConfirmationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRequestEmailConfirmationArgs {
  email_confirmation: EmailConfirmation,
}

impl TalkServiceRequestEmailConfirmationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRequestEmailConfirmationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<EmailConfirmation> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = EmailConfirmation::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRequestEmailConfirmationArgs.email_confirmation", &f_2)?;
    let ret = TalkServiceRequestEmailConfirmationArgs {
      email_confirmation: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestEmailConfirmation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("emailConfirmation", TType::Struct, 2))?;
    self.email_confirmation.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRequestEmailConfirmationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRequestEmailConfirmationResult {
  result_value: Option<EmailConfirmationSession>,
  e: Option<TalkException>,
}

impl TalkServiceRequestEmailConfirmationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRequestEmailConfirmationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<EmailConfirmationSession> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = EmailConfirmationSession::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRequestEmailConfirmationResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRequestEmailConfirmationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<EmailConfirmationSession> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceRequestEmailConfirmation"
          )
        )
      )
    }
  }
}

//
// TalkServiceRequestIdentityUnbindArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRequestIdentityUnbindArgs {
  identifier: String,
  provider: IdentityProvider,
}

impl TalkServiceRequestIdentityUnbindArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRequestIdentityUnbindArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_4: Option<IdentityProvider> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        4 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceRequestIdentityUnbindArgs.identifier", &f_2)?;
    verify_required_field_exists("TalkServiceRequestIdentityUnbindArgs.provider", &f_4)?;
    let ret = TalkServiceRequestIdentityUnbindArgs {
      identifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      provider: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestIdentityUnbind_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 2))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 4))?;
    self.provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceRequestIdentityUnbindResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceRequestIdentityUnbindResult {
  e: Option<TalkException>,
}

impl TalkServiceRequestIdentityUnbindResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceRequestIdentityUnbindResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceRequestIdentityUnbindResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceRequestIdentityUnbindResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceResendEmailConfirmationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceResendEmailConfirmationArgs {
  verifier: String,
}

impl TalkServiceResendEmailConfirmationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceResendEmailConfirmationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceResendEmailConfirmationArgs.verifier", &f_2)?;
    let ret = TalkServiceResendEmailConfirmationArgs {
      verifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("resendEmailConfirmation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 2))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceResendEmailConfirmationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceResendEmailConfirmationResult {
  result_value: Option<EmailConfirmationSession>,
  e: Option<TalkException>,
}

impl TalkServiceResendEmailConfirmationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceResendEmailConfirmationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<EmailConfirmationSession> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = EmailConfirmationSession::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceResendEmailConfirmationResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceResendEmailConfirmationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<EmailConfirmationSession> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceResendEmailConfirmation"
          )
        )
      )
    }
  }
}

//
// TalkServiceResendPinCodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceResendPinCodeArgs {
  session_id: String,
}

impl TalkServiceResendPinCodeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceResendPinCodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceResendPinCodeArgs.session_id", &f_2)?;
    let ret = TalkServiceResendPinCodeArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("resendPinCode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceResendPinCodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceResendPinCodeResult {
  e: Option<TalkException>,
}

impl TalkServiceResendPinCodeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceResendPinCodeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceResendPinCodeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceResendPinCodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceResendPinCodeBySMSArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceResendPinCodeBySMSArgs {
  session_id: String,
}

impl TalkServiceResendPinCodeBySMSArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceResendPinCodeBySMSArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceResendPinCodeBySMSArgs.session_id", &f_2)?;
    let ret = TalkServiceResendPinCodeBySMSArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("resendPinCodeBySMS_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceResendPinCodeBySMSResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceResendPinCodeBySMSResult {
  e: Option<TalkException>,
}

impl TalkServiceResendPinCodeBySMSResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceResendPinCodeBySMSResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceResendPinCodeBySMSResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceResendPinCodeBySMSResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSendChatCheckedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendChatCheckedArgs {
  seq: i32,
  consumer: String,
  last_message_id: String,
}

impl TalkServiceSendChatCheckedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendChatCheckedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendChatCheckedArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendChatCheckedArgs.consumer", &f_2)?;
    verify_required_field_exists("TalkServiceSendChatCheckedArgs.last_message_id", &f_3)?;
    let ret = TalkServiceSendChatCheckedArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      consumer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      last_message_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendChatChecked_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consumer", TType::String, 2))?;
    o_prot.write_string(&self.consumer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastMessageId", TType::String, 3))?;
    o_prot.write_string(&self.last_message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendChatCheckedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendChatCheckedResult {
  e: Option<TalkException>,
}

impl TalkServiceSendChatCheckedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendChatCheckedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendChatCheckedResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendChatCheckedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSendChatRemovedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendChatRemovedArgs {
  seq: i32,
  consumer: String,
  last_message_id: String,
}

impl TalkServiceSendChatRemovedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendChatRemovedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendChatRemovedArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendChatRemovedArgs.consumer", &f_2)?;
    verify_required_field_exists("TalkServiceSendChatRemovedArgs.last_message_id", &f_3)?;
    let ret = TalkServiceSendChatRemovedArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      consumer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      last_message_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendChatRemoved_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consumer", TType::String, 2))?;
    o_prot.write_string(&self.consumer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastMessageId", TType::String, 3))?;
    o_prot.write_string(&self.last_message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendChatRemovedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendChatRemovedResult {
  e: Option<TalkException>,
}

impl TalkServiceSendChatRemovedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendChatRemovedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendChatRemovedResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendChatRemovedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSendContentPreviewUpdatedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendContentPreviewUpdatedArgs {
  esq: i32,
  message_id: String,
  receiver_mids: Vec<String>,
}

impl TalkServiceSendContentPreviewUpdatedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendContentPreviewUpdatedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_193 = i_prot.read_string()?;
            val.push(list_elem_193);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendContentPreviewUpdatedArgs.esq", &f_1)?;
    verify_required_field_exists("TalkServiceSendContentPreviewUpdatedArgs.message_id", &f_2)?;
    verify_required_field_exists("TalkServiceSendContentPreviewUpdatedArgs.receiver_mids", &f_3)?;
    let ret = TalkServiceSendContentPreviewUpdatedArgs {
      esq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      receiver_mids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendContentPreviewUpdated_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("esq", TType::I32, 1))?;
    o_prot.write_i32(self.esq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 2))?;
    o_prot.write_string(&self.message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiverMids", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.receiver_mids.len() as i32))?;
    for e in &self.receiver_mids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendContentPreviewUpdatedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendContentPreviewUpdatedResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TalkException>,
}

impl TalkServiceSendContentPreviewUpdatedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendContentPreviewUpdatedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_194 = i_prot.read_string()?;
            let map_val_195 = i_prot.read_string()?;
            val.insert(map_key_194, map_val_195);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendContentPreviewUpdatedResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendContentPreviewUpdatedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceSendContentPreviewUpdated"
          )
        )
      )
    }
  }
}

//
// TalkServiceSendContentReceiptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendContentReceiptArgs {
  seq: i32,
  consumer: String,
  message_id: String,
}

impl TalkServiceSendContentReceiptArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendContentReceiptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendContentReceiptArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendContentReceiptArgs.consumer", &f_2)?;
    verify_required_field_exists("TalkServiceSendContentReceiptArgs.message_id", &f_3)?;
    let ret = TalkServiceSendContentReceiptArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      consumer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendContentReceipt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consumer", TType::String, 2))?;
    o_prot.write_string(&self.consumer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageId", TType::String, 3))?;
    o_prot.write_string(&self.message_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendContentReceiptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendContentReceiptResult {
  e: Option<TalkException>,
}

impl TalkServiceSendContentReceiptResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendContentReceiptResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendContentReceiptResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendContentReceiptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSendDummyPushArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendDummyPushArgs {
}

impl TalkServiceSendDummyPushArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendDummyPushArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendDummyPushArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendDummyPush_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendDummyPushResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendDummyPushResult {
  e: Option<TalkException>,
}

impl TalkServiceSendDummyPushResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendDummyPushResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendDummyPushResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendDummyPushResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSendEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendEventArgs {
  seq: i32,
  message: Message,
}

impl TalkServiceSendEventArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendEventArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendEventArgs.message", &f_2)?;
    let ret = TalkServiceSendEventArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 2))?;
    self.message.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendEventResult {
  result_value: Option<Message>,
  e: Option<TalkException>,
}

impl TalkServiceSendEventResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Message> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendEventResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Message> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceSendEvent"
          )
        )
      )
    }
  }
}

//
// TalkServiceSendMessageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageArgs {
  seq: i32,
  message: Message,
}

impl TalkServiceSendMessageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendMessageArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendMessageArgs.message", &f_2)?;
    let ret = TalkServiceSendMessageArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendMessage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 2))?;
    self.message.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageResult {
  result_value: Option<Message>,
  e: Option<TalkException>,
}

impl TalkServiceSendMessageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Message> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendMessageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Message> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceSendMessage"
          )
        )
      )
    }
  }
}

//
// TalkServiceSendMessageIgnoredArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageIgnoredArgs {
  seq: i32,
  consumer: String,
  message_ids: Vec<String>,
}

impl TalkServiceSendMessageIgnoredArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageIgnoredArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_196 = i_prot.read_string()?;
            val.push(list_elem_196);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendMessageIgnoredArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendMessageIgnoredArgs.consumer", &f_2)?;
    verify_required_field_exists("TalkServiceSendMessageIgnoredArgs.message_ids", &f_3)?;
    let ret = TalkServiceSendMessageIgnoredArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      consumer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendMessageIgnored_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consumer", TType::String, 2))?;
    o_prot.write_string(&self.consumer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.message_ids.len() as i32))?;
    for e in &self.message_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendMessageIgnoredResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageIgnoredResult {
  e: Option<TalkException>,
}

impl TalkServiceSendMessageIgnoredResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageIgnoredResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendMessageIgnoredResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendMessageIgnoredResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSendMessageReceiptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageReceiptArgs {
  seq: i32,
  consumer: String,
  message_ids: Vec<String>,
}

impl TalkServiceSendMessageReceiptArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageReceiptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_197 = i_prot.read_string()?;
            val.push(list_elem_197);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendMessageReceiptArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendMessageReceiptArgs.consumer", &f_2)?;
    verify_required_field_exists("TalkServiceSendMessageReceiptArgs.message_ids", &f_3)?;
    let ret = TalkServiceSendMessageReceiptArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      consumer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendMessageReceipt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consumer", TType::String, 2))?;
    o_prot.write_string(&self.consumer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("messageIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.message_ids.len() as i32))?;
    for e in &self.message_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendMessageReceiptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageReceiptResult {
  e: Option<TalkException>,
}

impl TalkServiceSendMessageReceiptResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageReceiptResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendMessageReceiptResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendMessageReceiptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSendMessageToMyHomeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageToMyHomeArgs {
  seq: i32,
  message: Message,
}

impl TalkServiceSendMessageToMyHomeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageToMyHomeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSendMessageToMyHomeArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceSendMessageToMyHomeArgs.message", &f_2)?;
    let ret = TalkServiceSendMessageToMyHomeArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sendMessageToMyHome_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 2))?;
    self.message.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSendMessageToMyHomeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSendMessageToMyHomeResult {
  result_value: Option<Message>,
  e: Option<TalkException>,
}

impl TalkServiceSendMessageToMyHomeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSendMessageToMyHomeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Message> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSendMessageToMyHomeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSendMessageToMyHomeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Message> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceSendMessageToMyHome"
          )
        )
      )
    }
  }
}

//
// TalkServiceSetBuddyLocationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSetBuddyLocationArgs {
  mid: String,
  index: i32,
  location: Geolocation,
}

impl TalkServiceSetBuddyLocationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSetBuddyLocationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Geolocation> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Geolocation::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSetBuddyLocationArgs.mid", &f_2)?;
    verify_required_field_exists("TalkServiceSetBuddyLocationArgs.index", &f_3)?;
    verify_required_field_exists("TalkServiceSetBuddyLocationArgs.location", &f_4)?;
    let ret = TalkServiceSetBuddyLocationArgs {
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      index: f_3.expect("auto-generated code should have checked for presence of required fields"),
      location: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setBuddyLocation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index", TType::I32, 3))?;
    o_prot.write_i32(self.index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::Struct, 4))?;
    self.location.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSetBuddyLocationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSetBuddyLocationResult {
  e: Option<TalkException>,
}

impl TalkServiceSetBuddyLocationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSetBuddyLocationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSetBuddyLocationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSetBuddyLocationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSetIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSetIdentityCredentialArgs {
  identifier: String,
  verifier: String,
  provider: IdentityProvider,
}

impl TalkServiceSetIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSetIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<IdentityProvider> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSetIdentityCredentialArgs.identifier", &f_2)?;
    verify_required_field_exists("TalkServiceSetIdentityCredentialArgs.verifier", &f_3)?;
    verify_required_field_exists("TalkServiceSetIdentityCredentialArgs.provider", &f_4)?;
    let ret = TalkServiceSetIdentityCredentialArgs {
      identifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      verifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      provider: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 2))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 3))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider", TType::I32, 4))?;
    self.provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSetIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSetIdentityCredentialResult {
  e: Option<TalkException>,
}

impl TalkServiceSetIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSetIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSetIdentityCredentialResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSetIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSetNotificationsEnabledArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSetNotificationsEnabledArgs {
  req_seq: i32,
  type_: MIDType,
  target: String,
  enablement: bool,
}

impl TalkServiceSetNotificationsEnabledArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSetNotificationsEnabledArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<MIDType> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = MIDType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSetNotificationsEnabledArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceSetNotificationsEnabledArgs.type_", &f_2)?;
    verify_required_field_exists("TalkServiceSetNotificationsEnabledArgs.target", &f_3)?;
    verify_required_field_exists("TalkServiceSetNotificationsEnabledArgs.enablement", &f_4)?;
    let ret = TalkServiceSetNotificationsEnabledArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_2.expect("auto-generated code should have checked for presence of required fields"),
      target: f_3.expect("auto-generated code should have checked for presence of required fields"),
      enablement: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setNotificationsEnabled_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 2))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("target", TType::String, 3))?;
    o_prot.write_string(&self.target)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("enablement", TType::Bool, 4))?;
    o_prot.write_bool(self.enablement)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSetNotificationsEnabledResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSetNotificationsEnabledResult {
  e: Option<TalkException>,
}

impl TalkServiceSetNotificationsEnabledResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSetNotificationsEnabledResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSetNotificationsEnabledResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSetNotificationsEnabledResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceStartUpdateVerificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceStartUpdateVerificationArgs {
  region: String,
  carrier: CarrierCode,
  phone: String,
  udid_hash: String,
  device_info: DeviceInfo,
  network_code: String,
  locale: String,
}

impl TalkServiceStartUpdateVerificationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceStartUpdateVerificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<CarrierCode> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<DeviceInfo> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = CarrierCode::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceStartUpdateVerificationArgs.region", &f_2)?;
    verify_required_field_exists("TalkServiceStartUpdateVerificationArgs.carrier", &f_3)?;
    verify_required_field_exists("TalkServiceStartUpdateVerificationArgs.phone", &f_4)?;
    verify_required_field_exists("TalkServiceStartUpdateVerificationArgs.udid_hash", &f_5)?;
    verify_required_field_exists("TalkServiceStartUpdateVerificationArgs.device_info", &f_6)?;
    verify_required_field_exists("TalkServiceStartUpdateVerificationArgs.network_code", &f_7)?;
    verify_required_field_exists("TalkServiceStartUpdateVerificationArgs.locale", &f_8)?;
    let ret = TalkServiceStartUpdateVerificationArgs {
      region: f_2.expect("auto-generated code should have checked for presence of required fields"),
      carrier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      phone: f_4.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_5.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_6.expect("auto-generated code should have checked for presence of required fields"),
      network_code: f_7.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("startUpdateVerification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 2))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("carrier", TType::I32, 3))?;
    self.carrier.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("phone", TType::String, 4))?;
    o_prot.write_string(&self.phone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 5))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 6))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("networkCode", TType::String, 7))?;
    o_prot.write_string(&self.network_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 8))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceStartUpdateVerificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceStartUpdateVerificationResult {
  result_value: Option<VerificationSessionData>,
  e: Option<TalkException>,
}

impl TalkServiceStartUpdateVerificationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceStartUpdateVerificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<VerificationSessionData> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = VerificationSessionData::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceStartUpdateVerificationResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceStartUpdateVerificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<VerificationSessionData> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceStartUpdateVerification"
          )
        )
      )
    }
  }
}

//
// TalkServiceStartVerificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceStartVerificationArgs {
  region: String,
  carrier: CarrierCode,
  phone: String,
  udid_hash: String,
  device_info: DeviceInfo,
  network_code: String,
  mid: String,
  locale: String,
}

impl TalkServiceStartVerificationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceStartVerificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<CarrierCode> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<DeviceInfo> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = CarrierCode::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.region", &f_2)?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.carrier", &f_3)?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.phone", &f_4)?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.udid_hash", &f_5)?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.device_info", &f_6)?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.network_code", &f_7)?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.mid", &f_8)?;
    verify_required_field_exists("TalkServiceStartVerificationArgs.locale", &f_9)?;
    let ret = TalkServiceStartVerificationArgs {
      region: f_2.expect("auto-generated code should have checked for presence of required fields"),
      carrier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      phone: f_4.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_5.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_6.expect("auto-generated code should have checked for presence of required fields"),
      network_code: f_7.expect("auto-generated code should have checked for presence of required fields"),
      mid: f_8.expect("auto-generated code should have checked for presence of required fields"),
      locale: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("startVerification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 2))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("carrier", TType::I32, 3))?;
    self.carrier.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("phone", TType::String, 4))?;
    o_prot.write_string(&self.phone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 5))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 6))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("networkCode", TType::String, 7))?;
    o_prot.write_string(&self.network_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 8))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 9))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceStartVerificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceStartVerificationResult {
  result_value: Option<VerificationSessionData>,
  e: Option<TalkException>,
}

impl TalkServiceStartVerificationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceStartVerificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<VerificationSessionData> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = VerificationSessionData::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceStartVerificationResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceStartVerificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<VerificationSessionData> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceStartVerification"
          )
        )
      )
    }
  }
}

//
// TalkServiceStoreUpdateProfileAttributeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceStoreUpdateProfileAttributeArgs {
  seq: i32,
  profile_attribute: ProfileAttribute,
  value: String,
}

impl TalkServiceStoreUpdateProfileAttributeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceStoreUpdateProfileAttributeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<ProfileAttribute> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = ProfileAttribute::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceStoreUpdateProfileAttributeArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceStoreUpdateProfileAttributeArgs.profile_attribute", &f_2)?;
    verify_required_field_exists("TalkServiceStoreUpdateProfileAttributeArgs.value", &f_3)?;
    let ret = TalkServiceStoreUpdateProfileAttributeArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_attribute: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("storeUpdateProfileAttribute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileAttribute", TType::I32, 2))?;
    self.profile_attribute.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceStoreUpdateProfileAttributeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceStoreUpdateProfileAttributeResult {
  e: Option<TalkException>,
}

impl TalkServiceStoreUpdateProfileAttributeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceStoreUpdateProfileAttributeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceStoreUpdateProfileAttributeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceStoreUpdateProfileAttributeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceSyncContactBySnsIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSyncContactBySnsIdsArgs {
  req_seq: i32,
  modifications: Vec<SnsFriendModification>,
}

impl TalkServiceSyncContactBySnsIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSyncContactBySnsIdsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<SnsFriendModification>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SnsFriendModification> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_198 = SnsFriendModification::read_from_in_protocol(i_prot)?;
            val.push(list_elem_198);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSyncContactBySnsIdsArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceSyncContactBySnsIdsArgs.modifications", &f_2)?;
    let ret = TalkServiceSyncContactBySnsIdsArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      modifications: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("syncContactBySnsIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("modifications", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.modifications.len() as i32))?;
    for e in &self.modifications {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSyncContactBySnsIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSyncContactBySnsIdsResult {
  result_value: Option<Vec<SnsFriendContactRegistration>>,
  e: Option<TalkException>,
}

impl TalkServiceSyncContactBySnsIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSyncContactBySnsIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<SnsFriendContactRegistration>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SnsFriendContactRegistration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_199 = SnsFriendContactRegistration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_199);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSyncContactBySnsIdsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSyncContactBySnsIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<SnsFriendContactRegistration>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceSyncContactBySnsIds"
          )
        )
      )
    }
  }
}

//
// TalkServiceSyncContactsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSyncContactsArgs {
  req_seq: i32,
  local_contacts: Vec<ContactModification>,
}

impl TalkServiceSyncContactsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSyncContactsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<ContactModification>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ContactModification> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_200 = ContactModification::read_from_in_protocol(i_prot)?;
            val.push(list_elem_200);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceSyncContactsArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceSyncContactsArgs.local_contacts", &f_2)?;
    let ret = TalkServiceSyncContactsArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      local_contacts: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("syncContacts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localContacts", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.local_contacts.len() as i32))?;
    for e in &self.local_contacts {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceSyncContactsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceSyncContactsResult {
  result_value: Option<BTreeMap<String, ContactRegistration>>,
  e: Option<TalkException>,
}

impl TalkServiceSyncContactsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceSyncContactsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, ContactRegistration>> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, ContactRegistration> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_201 = i_prot.read_string()?;
            let map_val_202 = ContactRegistration::read_from_in_protocol(i_prot)?;
            val.insert(map_key_201, map_val_202);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceSyncContactsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceSyncContactsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, ContactRegistration>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceSyncContacts"
          )
        )
      )
    }
  }
}

//
// TalkServiceTrySendMessageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceTrySendMessageArgs {
  seq: i32,
  message: Message,
}

impl TalkServiceTrySendMessageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceTrySendMessageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Message> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceTrySendMessageArgs.seq", &f_1)?;
    verify_required_field_exists("TalkServiceTrySendMessageArgs.message", &f_2)?;
    let ret = TalkServiceTrySendMessageArgs {
      seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("trySendMessage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
    o_prot.write_i32(self.seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 2))?;
    self.message.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceTrySendMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceTrySendMessageResult {
  result_value: Option<Message>,
  e: Option<TalkException>,
}

impl TalkServiceTrySendMessageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceTrySendMessageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Message> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Message::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceTrySendMessageResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceTrySendMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Message> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceTrySendMessage"
          )
        )
      )
    }
  }
}

//
// TalkServiceUnblockContactArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUnblockContactArgs {
  req_seq: i32,
  id: String,
}

impl TalkServiceUnblockContactArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUnblockContactArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUnblockContactArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUnblockContactArgs.id", &f_2)?;
    let ret = TalkServiceUnblockContactArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unblockContact_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 2))?;
    o_prot.write_string(&self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUnblockContactResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUnblockContactResult {
  e: Option<TalkException>,
}

impl TalkServiceUnblockContactResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUnblockContactResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUnblockContactResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUnblockContactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUnblockRecommendationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUnblockRecommendationArgs {
  req_seq: i32,
  id: String,
}

impl TalkServiceUnblockRecommendationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUnblockRecommendationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUnblockRecommendationArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUnblockRecommendationArgs.id", &f_2)?;
    let ret = TalkServiceUnblockRecommendationArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unblockRecommendation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 2))?;
    o_prot.write_string(&self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUnblockRecommendationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUnblockRecommendationResult {
  e: Option<TalkException>,
}

impl TalkServiceUnblockRecommendationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUnblockRecommendationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUnblockRecommendationResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUnblockRecommendationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUnregisterUserAndDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUnregisterUserAndDeviceArgs {
}

impl TalkServiceUnregisterUserAndDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUnregisterUserAndDeviceArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUnregisterUserAndDeviceArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unregisterUserAndDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUnregisterUserAndDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUnregisterUserAndDeviceResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceUnregisterUserAndDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUnregisterUserAndDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUnregisterUserAndDeviceResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUnregisterUserAndDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceUnregisterUserAndDevice"
          )
        )
      )
    }
  }
}

//
// TalkServiceUpdateApnsDeviceTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateApnsDeviceTokenArgs {
  apns_device_token: Vec<u8>,
}

impl TalkServiceUpdateApnsDeviceTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateApnsDeviceTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateApnsDeviceTokenArgs.apns_device_token", &f_2)?;
    let ret = TalkServiceUpdateApnsDeviceTokenArgs {
      apns_device_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateApnsDeviceToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("apnsDeviceToken", TType::String, 2))?;
    o_prot.write_bytes(&self.apns_device_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateApnsDeviceTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateApnsDeviceTokenResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateApnsDeviceTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateApnsDeviceTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateApnsDeviceTokenResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateApnsDeviceTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateBuddySettingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateBuddySettingArgs {
  key: String,
  value: String,
}

impl TalkServiceUpdateBuddySettingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateBuddySettingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateBuddySettingArgs.key", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateBuddySettingArgs.value", &f_3)?;
    let ret = TalkServiceUpdateBuddySettingArgs {
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBuddySetting_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateBuddySettingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateBuddySettingResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateBuddySettingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateBuddySettingResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateBuddySettingResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateBuddySettingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateC2DMRegistrationIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateC2DMRegistrationIdArgs {
  registration_id: String,
}

impl TalkServiceUpdateC2DMRegistrationIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateC2DMRegistrationIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateC2DMRegistrationIdArgs.registration_id", &f_2)?;
    let ret = TalkServiceUpdateC2DMRegistrationIdArgs {
      registration_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateC2DMRegistrationId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("registrationId", TType::String, 2))?;
    o_prot.write_string(&self.registration_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateC2DMRegistrationIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateC2DMRegistrationIdResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateC2DMRegistrationIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateC2DMRegistrationIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateC2DMRegistrationIdResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateC2DMRegistrationIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateContactSettingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateContactSettingArgs {
  req_seq: i32,
  mid: String,
  flag: ContactSetting,
  value: String,
}

impl TalkServiceUpdateContactSettingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateContactSettingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<ContactSetting> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ContactSetting::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateContactSettingArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateContactSettingArgs.mid", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateContactSettingArgs.flag", &f_3)?;
    verify_required_field_exists("TalkServiceUpdateContactSettingArgs.value", &f_4)?;
    let ret = TalkServiceUpdateContactSettingArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      flag: f_3.expect("auto-generated code should have checked for presence of required fields"),
      value: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateContactSetting_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::String, 2))?;
    o_prot.write_string(&self.mid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flag", TType::I32, 3))?;
    self.flag.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 4))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateContactSettingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateContactSettingResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateContactSettingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateContactSettingResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateContactSettingResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateContactSettingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateCustomModeSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateCustomModeSettingsArgs {
  custom_mode: CustomMode,
  param_map: BTreeMap<String, String>,
}

impl TalkServiceUpdateCustomModeSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateCustomModeSettingsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<CustomMode> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = CustomMode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_203 = i_prot.read_string()?;
            let map_val_204 = i_prot.read_string()?;
            val.insert(map_key_203, map_val_204);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateCustomModeSettingsArgs.custom_mode", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateCustomModeSettingsArgs.param_map", &f_3)?;
    let ret = TalkServiceUpdateCustomModeSettingsArgs {
      custom_mode: f_2.expect("auto-generated code should have checked for presence of required fields"),
      param_map: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateCustomModeSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customMode", TType::I32, 2))?;
    self.custom_mode.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paramMap", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.param_map.len() as i32))?;
    for (k, v) in &self.param_map {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateCustomModeSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateCustomModeSettingsResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateCustomModeSettingsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateCustomModeSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateCustomModeSettingsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateCustomModeSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateDeviceInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateDeviceInfoArgs {
  device_uid: String,
  device_info: DeviceInfo,
}

impl TalkServiceUpdateDeviceInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateDeviceInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<DeviceInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = DeviceInfo::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateDeviceInfoArgs.device_uid", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateDeviceInfoArgs.device_info", &f_3)?;
    let ret = TalkServiceUpdateDeviceInfoArgs {
      device_uid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_info: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateDeviceInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceUid", TType::String, 2))?;
    o_prot.write_string(&self.device_uid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceInfo", TType::Struct, 3))?;
    self.device_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateDeviceInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateDeviceInfoResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateDeviceInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateDeviceInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateDeviceInfoResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateDeviceInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateGroupArgs {
  req_seq: i32,
  group: Group,
}

impl TalkServiceUpdateGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Group> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Group::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateGroupArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateGroupArgs.group", &f_2)?;
    let ret = TalkServiceUpdateGroupArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group", TType::Struct, 2))?;
    self.group.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateGroupResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateGroupResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateNotificationTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateNotificationTokenArgs {
  token: String,
  type_: NotificationType,
}

impl TalkServiceUpdateNotificationTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateNotificationTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<NotificationType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = NotificationType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateNotificationTokenArgs.token", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateNotificationTokenArgs.type_", &f_3)?;
    let ret = TalkServiceUpdateNotificationTokenArgs {
      token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateNotificationToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 2))?;
    o_prot.write_string(&self.token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateNotificationTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateNotificationTokenResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateNotificationTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateNotificationTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateNotificationTokenResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateNotificationTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateNotificationTokenWithBytesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateNotificationTokenWithBytesArgs {
  token: Vec<u8>,
  type_: NotificationType,
}

impl TalkServiceUpdateNotificationTokenWithBytesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateNotificationTokenWithBytesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Vec<u8>> = None;
    let mut f_3: Option<NotificationType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = NotificationType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateNotificationTokenWithBytesArgs.token", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateNotificationTokenWithBytesArgs.type_", &f_3)?;
    let ret = TalkServiceUpdateNotificationTokenWithBytesArgs {
      token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateNotificationTokenWithBytes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 2))?;
    o_prot.write_bytes(&self.token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateNotificationTokenWithBytesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateNotificationTokenWithBytesResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateNotificationTokenWithBytesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateNotificationTokenWithBytesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateNotificationTokenWithBytesResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateNotificationTokenWithBytesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateProfileArgs {
  req_seq: i32,
  profile: Profile,
}

impl TalkServiceUpdateProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Profile> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Profile::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateProfileArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateProfileArgs.profile", &f_2)?;
    let ret = TalkServiceUpdateProfileArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profile", TType::Struct, 2))?;
    self.profile.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateProfileResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateProfileAttributeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateProfileAttributeArgs {
  req_seq: i32,
  attr: ProfileAttribute,
  value: String,
}

impl TalkServiceUpdateProfileAttributeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateProfileAttributeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<ProfileAttribute> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = ProfileAttribute::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateProfileAttributeArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateProfileAttributeArgs.attr", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateProfileAttributeArgs.value", &f_3)?;
    let ret = TalkServiceUpdateProfileAttributeArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      attr: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateProfileAttribute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attr", TType::I32, 2))?;
    self.attr.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateProfileAttributeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateProfileAttributeResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateProfileAttributeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateProfileAttributeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateProfileAttributeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateProfileAttributeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateRegionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateRegionArgs {
  region: String,
}

impl TalkServiceUpdateRegionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateRegionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateRegionArgs.region", &f_2)?;
    let ret = TalkServiceUpdateRegionArgs {
      region: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateRegion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 2))?;
    o_prot.write_string(&self.region)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateRegionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateRegionResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateRegionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateRegionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateRegionResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateRegionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettingsArgs {
  req_seq: i32,
  settings: Settings,
}

impl TalkServiceUpdateSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettingsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Settings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Settings::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateSettingsArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateSettingsArgs.settings", &f_2)?;
    let ret = TalkServiceUpdateSettingsArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      settings: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::Struct, 2))?;
    self.settings.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettingsResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateSettingsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateSettingsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateSettings2Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettings2Args {
  req_seq: i32,
  settings: Settings,
}

impl TalkServiceUpdateSettings2Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettings2Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Settings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Settings::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateSettings2Args.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateSettings2Args.settings", &f_2)?;
    let ret = TalkServiceUpdateSettings2Args {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      settings: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateSettings2_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::Struct, 2))?;
    self.settings.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateSettings2Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettings2Result {
  result_value: Option<i32>,
  e: Option<TalkException>,
}

impl TalkServiceUpdateSettings2Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettings2Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateSettings2Result {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateSettings2Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceUpdateSettings2"
          )
        )
      )
    }
  }
}

//
// TalkServiceUpdateSettingsAttributeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettingsAttributeArgs {
  req_seq: i32,
  attr: SettingsAttribute,
  value: String,
}

impl TalkServiceUpdateSettingsAttributeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettingsAttributeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<SettingsAttribute> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = SettingsAttribute::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateSettingsAttributeArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateSettingsAttributeArgs.attr", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateSettingsAttributeArgs.value", &f_3)?;
    let ret = TalkServiceUpdateSettingsAttributeArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      attr: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateSettingsAttribute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attr", TType::I32, 2))?;
    self.attr.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateSettingsAttributeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettingsAttributeResult {
  e: Option<TalkException>,
}

impl TalkServiceUpdateSettingsAttributeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettingsAttributeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateSettingsAttributeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateSettingsAttributeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceUpdateSettingsAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettingsAttributesArgs {
  req_seq: i32,
  attr_bitset: i32,
  settings: Settings,
}

impl TalkServiceUpdateSettingsAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettingsAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Settings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Settings::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceUpdateSettingsAttributesArgs.req_seq", &f_1)?;
    verify_required_field_exists("TalkServiceUpdateSettingsAttributesArgs.attr_bitset", &f_2)?;
    verify_required_field_exists("TalkServiceUpdateSettingsAttributesArgs.settings", &f_3)?;
    let ret = TalkServiceUpdateSettingsAttributesArgs {
      req_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
      attr_bitset: f_2.expect("auto-generated code should have checked for presence of required fields"),
      settings: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateSettingsAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reqSeq", TType::I32, 1))?;
    o_prot.write_i32(self.req_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attrBitset", TType::I32, 2))?;
    o_prot.write_i32(self.attr_bitset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::Struct, 3))?;
    self.settings.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceUpdateSettingsAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceUpdateSettingsAttributesResult {
  result_value: Option<i32>,
  e: Option<TalkException>,
}

impl TalkServiceUpdateSettingsAttributesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceUpdateSettingsAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceUpdateSettingsAttributesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceUpdateSettingsAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceUpdateSettingsAttributes"
          )
        )
      )
    }
  }
}

//
// TalkServiceVerifyIdentityCredentialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyIdentityCredentialArgs {
  identifier: String,
  password: String,
  identity_provider: IdentityProvider,
}

impl TalkServiceVerifyIdentityCredentialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyIdentityCredentialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_8: Option<IdentityProvider> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        8 => {
          let val = IdentityProvider::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceVerifyIdentityCredentialArgs.identifier", &f_3)?;
    verify_required_field_exists("TalkServiceVerifyIdentityCredentialArgs.password", &f_4)?;
    verify_required_field_exists("TalkServiceVerifyIdentityCredentialArgs.identity_provider", &f_8)?;
    let ret = TalkServiceVerifyIdentityCredentialArgs {
      identifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      password: f_4.expect("auto-generated code should have checked for presence of required fields"),
      identity_provider: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("verifyIdentityCredential_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identifier", TType::String, 3))?;
    o_prot.write_string(&self.identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 4))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identityProvider", TType::I32, 8))?;
    self.identity_provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceVerifyIdentityCredentialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyIdentityCredentialResult {
  e: Option<TalkException>,
}

impl TalkServiceVerifyIdentityCredentialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyIdentityCredentialResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceVerifyIdentityCredentialResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceVerifyIdentityCredentialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// TalkServiceVerifyIdentityCredentialWithResultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyIdentityCredentialWithResultArgs {
  identity_credential: IdentityCredential,
}

impl TalkServiceVerifyIdentityCredentialWithResultArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyIdentityCredentialWithResultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<IdentityCredential> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = IdentityCredential::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceVerifyIdentityCredentialWithResultArgs.identity_credential", &f_2)?;
    let ret = TalkServiceVerifyIdentityCredentialWithResultArgs {
      identity_credential: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("verifyIdentityCredentialWithResult_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("identityCredential", TType::Struct, 2))?;
    self.identity_credential.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceVerifyIdentityCredentialWithResultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyIdentityCredentialWithResultResult {
  result_value: Option<UserAuthStatus>,
  e: Option<TalkException>,
}

impl TalkServiceVerifyIdentityCredentialWithResultResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyIdentityCredentialWithResultResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UserAuthStatus> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UserAuthStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceVerifyIdentityCredentialWithResultResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceVerifyIdentityCredentialWithResultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<UserAuthStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceVerifyIdentityCredentialWithResult"
          )
        )
      )
    }
  }
}

//
// TalkServiceVerifyPhoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyPhoneArgs {
  session_id: String,
  pin_code: String,
  udid_hash: String,
}

impl TalkServiceVerifyPhoneArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyPhoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceVerifyPhoneArgs.session_id", &f_2)?;
    verify_required_field_exists("TalkServiceVerifyPhoneArgs.pin_code", &f_3)?;
    verify_required_field_exists("TalkServiceVerifyPhoneArgs.udid_hash", &f_4)?;
    let ret = TalkServiceVerifyPhoneArgs {
      session_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pin_code: f_3.expect("auto-generated code should have checked for presence of required fields"),
      udid_hash: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("verifyPhone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 2))?;
    o_prot.write_string(&self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pinCode", TType::String, 3))?;
    o_prot.write_string(&self.pin_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udidHash", TType::String, 4))?;
    o_prot.write_string(&self.udid_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceVerifyPhoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyPhoneResult {
  result_value: Option<VerificationResult>,
  e: Option<TalkException>,
}

impl TalkServiceVerifyPhoneResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyPhoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<VerificationResult> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = VerificationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceVerifyPhoneResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceVerifyPhoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<VerificationResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceVerifyPhone"
          )
        )
      )
    }
  }
}

//
// TalkServiceVerifyQrcodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyQrcodeArgs {
  verifier: String,
  pin_code: String,
}

impl TalkServiceVerifyQrcodeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyQrcodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TalkServiceVerifyQrcodeArgs.verifier", &f_2)?;
    verify_required_field_exists("TalkServiceVerifyQrcodeArgs.pin_code", &f_3)?;
    let ret = TalkServiceVerifyQrcodeArgs {
      verifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pin_code: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("verifyQrcode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("verifier", TType::String, 2))?;
    o_prot.write_string(&self.verifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pinCode", TType::String, 3))?;
    o_prot.write_string(&self.pin_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TalkServiceVerifyQrcodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TalkServiceVerifyQrcodeResult {
  result_value: Option<String>,
  e: Option<TalkException>,
}

impl TalkServiceVerifyQrcodeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TalkServiceVerifyQrcodeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TalkException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TalkException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TalkServiceVerifyQrcodeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TalkServiceVerifyQrcodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TalkServiceVerifyQrcode"
          )
        )
      )
    }
  }
}

//
// UniversalNotificationService service client
//

pub trait TUniversalNotificationServiceSyncClient {
  fn notify(&mut self, event: GlobalEvent) -> thrift::Result<()>;
}

pub trait TUniversalNotificationServiceSyncClientMarker {}

pub struct UniversalNotificationServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> UniversalNotificationServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> UniversalNotificationServiceSyncClient<IP, OP> {
    UniversalNotificationServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for UniversalNotificationServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TUniversalNotificationServiceSyncClientMarker for UniversalNotificationServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TUniversalNotificationServiceSyncClientMarker> TUniversalNotificationServiceSyncClient for C {
  fn notify(&mut self, event: GlobalEvent) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("notify", TMessageType::Call, self.sequence_number());
        let call_args = UniversalNotificationServiceNotifyArgs { event: event };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("notify", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UniversalNotificationServiceNotifyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// UniversalNotificationService service processor
//

pub trait UniversalNotificationServiceSyncHandler {
  fn handle_notify(&self, event: GlobalEvent) -> thrift::Result<()>;
}

pub struct UniversalNotificationServiceSyncProcessor<H: UniversalNotificationServiceSyncHandler> {
  handler: H,
}

impl <H: UniversalNotificationServiceSyncHandler> UniversalNotificationServiceSyncProcessor<H> {
  pub fn new(handler: H) -> UniversalNotificationServiceSyncProcessor<H> {
    UniversalNotificationServiceSyncProcessor {
      handler,
    }
  }
  fn process_notify(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUniversalNotificationServiceProcessFunctions::process_notify(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TUniversalNotificationServiceProcessFunctions;

impl TUniversalNotificationServiceProcessFunctions {
  pub fn process_notify<H: UniversalNotificationServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UniversalNotificationServiceNotifyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_notify(args.event) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("notify", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UniversalNotificationServiceNotifyResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<UniversalNotificationServiceException>().is_some() {
              let err = usr_err.downcast::<UniversalNotificationServiceException>().expect("downcast already checked");
              let ret_err = UniversalNotificationServiceNotifyResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("notify", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("notify", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("notify", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("notify", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: UniversalNotificationServiceSyncHandler> TProcessor for UniversalNotificationServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "notify" => {
        self.process_notify(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// UniversalNotificationServiceNotifyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UniversalNotificationServiceNotifyArgs {
  event: GlobalEvent,
}

impl UniversalNotificationServiceNotifyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UniversalNotificationServiceNotifyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<GlobalEvent> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = GlobalEvent::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UniversalNotificationServiceNotifyArgs.event", &f_2)?;
    let ret = UniversalNotificationServiceNotifyArgs {
      event: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notify_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("event", TType::Struct, 2))?;
    self.event.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UniversalNotificationServiceNotifyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UniversalNotificationServiceNotifyResult {
  e: Option<UniversalNotificationServiceException>,
}

impl UniversalNotificationServiceNotifyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UniversalNotificationServiceNotifyResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UniversalNotificationServiceException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = UniversalNotificationServiceException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UniversalNotificationServiceNotifyResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UniversalNotificationServiceNotifyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

