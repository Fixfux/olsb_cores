/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: AgeCheckDocomoResult, rhs: AgeCheckDocomoResult) -> Bool {
  return
    (lhs.authUrl == rhs.authUrl) &&
    (lhs.userAgeType == rhs.userAgeType)
}

extension AgeCheckDocomoResult : CustomStringConvertible {

  public var description : String {
    var desc = "AgeCheckDocomoResult("
    desc += "authUrl=\(String(describing: self.authUrl)), "
    desc += "userAgeType=\(String(describing: self.userAgeType))"
    return desc
  }

}

extension AgeCheckDocomoResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authUrl.hashValue)
    result = prime &* result &+ (userAgeType.hashValue)
    return result
  }

}

extension AgeCheckDocomoResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authUrl": 1, "userAgeType": 2, ]
  }

  public static var structName: String { return "AgeCheckDocomoResult" }

  public static func read(from proto: TProtocol) throws -> AgeCheckDocomoResult {
    _ = try proto.readStructBegin()
    var authUrl: String!
    var userAgeType: UserAgeType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           authUrl = try String.read(from: proto)
        case (2, .i32):             userAgeType = try UserAgeType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authUrl, named: "authUrl")
    try proto.validateValue(userAgeType, named: "userAgeType")

    return AgeCheckDocomoResult(authUrl: authUrl, userAgeType: userAgeType)
  }

}



public func ==(lhs: AgeCheckRequestResult, rhs: AgeCheckRequestResult) -> Bool {
  return
    (lhs.authUrl == rhs.authUrl) &&
    (lhs.sessionId == rhs.sessionId)
}

extension AgeCheckRequestResult : CustomStringConvertible {

  public var description : String {
    var desc = "AgeCheckRequestResult("
    desc += "authUrl=\(String(describing: self.authUrl)), "
    desc += "sessionId=\(String(describing: self.sessionId))"
    return desc
  }

}

extension AgeCheckRequestResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authUrl.hashValue)
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension AgeCheckRequestResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authUrl": 1, "sessionId": 2, ]
  }

  public static var structName: String { return "AgeCheckRequestResult" }

  public static func read(from proto: TProtocol) throws -> AgeCheckRequestResult {
    _ = try proto.readStructBegin()
    var authUrl: String!
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           authUrl = try String.read(from: proto)
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authUrl, named: "authUrl")
    try proto.validateValue(sessionId, named: "sessionId")

    return AgeCheckRequestResult(authUrl: authUrl, sessionId: sessionId)
  }

}



public func ==(lhs: Announcement, rhs: Announcement) -> Bool {
  return
    (lhs.index == rhs.index) &&
    (lhs.forceUpdate == rhs.forceUpdate) &&
    (lhs.title == rhs.title) &&
    (lhs.text == rhs.text) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.pictureUrl == rhs.pictureUrl) &&
    (lhs.thumbnailUrl == rhs.thumbnailUrl)
}

extension Announcement : CustomStringConvertible {

  public var description : String {
    var desc = "Announcement("
    desc += "index=\(String(describing: self.index)), "
    desc += "forceUpdate=\(String(describing: self.forceUpdate)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "text=\(String(describing: self.text)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "pictureUrl=\(String(describing: self.pictureUrl)), "
    desc += "thumbnailUrl=\(String(describing: self.thumbnailUrl))"
    return desc
  }

}

extension Announcement : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (index.hashValue)
    result = prime &* result &+ (forceUpdate.hashValue)
    result = prime &* result &+ (title.hashValue)
    result = prime &* result &+ (text.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (pictureUrl.hashValue)
    result = prime &* result &+ (thumbnailUrl.hashValue)
    return result
  }

}

extension Announcement : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["index": 1, "forceUpdate": 10, "title": 11, "text": 12, "createdTime": 13, "pictureUrl": 14, "thumbnailUrl": 15, ]
  }

  public static var structName: String { return "Announcement" }

  public static func read(from proto: TProtocol) throws -> Announcement {
    _ = try proto.readStructBegin()
    var index: Int32!
    var forceUpdate: Bool!
    var title: String!
    var text: String!
    var createdTime: Int64!
    var pictureUrl: String!
    var thumbnailUrl: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             index = try Int32.read(from: proto)
        case (10, .bool):            forceUpdate = try Bool.read(from: proto)
        case (11, .string):           title = try String.read(from: proto)
        case (12, .string):           text = try String.read(from: proto)
        case (13, .i64):             createdTime = try Int64.read(from: proto)
        case (14, .string):           pictureUrl = try String.read(from: proto)
        case (15, .string):           thumbnailUrl = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(index, named: "index")
    try proto.validateValue(forceUpdate, named: "forceUpdate")
    try proto.validateValue(title, named: "title")
    try proto.validateValue(text, named: "text")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(pictureUrl, named: "pictureUrl")
    try proto.validateValue(thumbnailUrl, named: "thumbnailUrl")

    return Announcement(index: index, forceUpdate: forceUpdate, title: title, text: text, createdTime: createdTime, pictureUrl: pictureUrl, thumbnailUrl: thumbnailUrl)
  }

}



public func ==(lhs: ChannelProvider, rhs: ChannelProvider) -> Bool {
  return
    (lhs.name == rhs.name)
}

extension ChannelProvider : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelProvider("
    desc += "name=\(String(describing: self.name))"
    return desc
  }

}

extension ChannelProvider : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (name.hashValue)
    return result
  }

}

extension ChannelProvider : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["name": 1, ]
  }

  public static var structName: String { return "ChannelProvider" }

  public static func read(from proto: TProtocol) throws -> ChannelProvider {
    _ = try proto.readStructBegin()
    var name: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")

    return ChannelProvider(name: name)
  }

}



public func ==(lhs: ChannelInfo, rhs: ChannelInfo) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.name == rhs.name) &&
    (lhs.entryPageUrl == rhs.entryPageUrl) &&
    (lhs.descriptionText == rhs.descriptionText) &&
    (lhs.provider == rhs.provider) &&
    (lhs.publicType == rhs.publicType) &&
    (lhs.iconImage == rhs.iconImage) &&
    (lhs.permissions == rhs.permissions) &&
    (lhs.iconThumbnailImage == rhs.iconThumbnailImage) &&
    (lhs.channelConfigurations == rhs.channelConfigurations)
}

extension ChannelInfo : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelInfo("
    desc += "channelId=\(String(describing: self.channelId)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "entryPageUrl=\(String(describing: self.entryPageUrl)), "
    desc += "descriptionText=\(String(describing: self.descriptionText)), "
    desc += "provider=\(String(describing: self.provider)), "
    desc += "publicType=\(String(describing: self.publicType)), "
    desc += "iconImage=\(String(describing: self.iconImage)), "
    desc += "permissions=\(String(describing: self.permissions)), "
    desc += "iconThumbnailImage=\(String(describing: self.iconThumbnailImage)), "
    desc += "channelConfigurations=\(String(describing: self.channelConfigurations))"
    return desc
  }

}

extension ChannelInfo : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (entryPageUrl.hashValue)
    result = prime &* result &+ (descriptionText.hashValue)
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (publicType.hashValue)
    result = prime &* result &+ (iconImage.hashValue)
    result = prime &* result &+ (permissions.hashValue)
    result = prime &* result &+ (iconThumbnailImage.hashValue)
    result = prime &* result &+ (channelConfigurations.hashValue)
    return result
  }

}

extension ChannelInfo : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelId": 1, "name": 3, "entryPageUrl": 4, "descriptionText": 5, "provider": 6, "publicType": 7, "iconImage": 8, "permissions": 9, "iconThumbnailImage": 11, "channelConfigurations": 12, ]
  }

  public static var structName: String { return "ChannelInfo" }

  public static func read(from proto: TProtocol) throws -> ChannelInfo {
    _ = try proto.readStructBegin()
    var channelId: String!
    var name: String!
    var entryPageUrl: String!
    var descriptionText: String!
    var provider: ChannelProvider!
    var publicType: PublicType!
    var iconImage: String!
    var permissions: TList<String>!
    var iconThumbnailImage: String!
    var channelConfigurations: TList<ChannelConfiguration>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (3, .string):           name = try String.read(from: proto)
        case (4, .string):           entryPageUrl = try String.read(from: proto)
        case (5, .string):           descriptionText = try String.read(from: proto)
        case (6, .struct):           provider = try ChannelProvider.read(from: proto)
        case (7, .i32):             publicType = try PublicType.read(from: proto)
        case (8, .string):           iconImage = try String.read(from: proto)
        case (9, .list):            permissions = try TList<String>.read(from: proto)
        case (11, .string):           iconThumbnailImage = try String.read(from: proto)
        case (12, .list):            channelConfigurations = try TList<ChannelConfiguration>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(entryPageUrl, named: "entryPageUrl")
    try proto.validateValue(descriptionText, named: "descriptionText")
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(publicType, named: "publicType")
    try proto.validateValue(iconImage, named: "iconImage")
    try proto.validateValue(permissions, named: "permissions")
    try proto.validateValue(iconThumbnailImage, named: "iconThumbnailImage")
    try proto.validateValue(channelConfigurations, named: "channelConfigurations")

    return ChannelInfo(channelId: channelId, name: name, entryPageUrl: entryPageUrl, descriptionText: descriptionText, provider: provider, publicType: publicType, iconImage: iconImage, permissions: permissions, iconThumbnailImage: iconThumbnailImage, channelConfigurations: channelConfigurations)
  }

}



public func ==(lhs: ApprovedChannelInfo, rhs: ApprovedChannelInfo) -> Bool {
  return
    (lhs.channelInfo == rhs.channelInfo) &&
    (lhs.approvedAt == rhs.approvedAt)
}

extension ApprovedChannelInfo : CustomStringConvertible {

  public var description : String {
    var desc = "ApprovedChannelInfo("
    desc += "channelInfo=\(String(describing: self.channelInfo)), "
    desc += "approvedAt=\(String(describing: self.approvedAt))"
    return desc
  }

}

extension ApprovedChannelInfo : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelInfo.hashValue)
    result = prime &* result &+ (approvedAt.hashValue)
    return result
  }

}

extension ApprovedChannelInfo : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelInfo": 1, "approvedAt": 2, ]
  }

  public static var structName: String { return "ApprovedChannelInfo" }

  public static func read(from proto: TProtocol) throws -> ApprovedChannelInfo {
    _ = try proto.readStructBegin()
    var channelInfo: ChannelInfo!
    var approvedAt: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           channelInfo = try ChannelInfo.read(from: proto)
        case (2, .i64):             approvedAt = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelInfo, named: "channelInfo")
    try proto.validateValue(approvedAt, named: "approvedAt")

    return ApprovedChannelInfo(channelInfo: channelInfo, approvedAt: approvedAt)
  }

}



public func ==(lhs: ApprovedChannelInfos, rhs: ApprovedChannelInfos) -> Bool {
  return
    (lhs.approvedChannelInfos == rhs.approvedChannelInfos) &&
    (lhs.revision == rhs.revision)
}

extension ApprovedChannelInfos : CustomStringConvertible {

  public var description : String {
    var desc = "ApprovedChannelInfos("
    desc += "approvedChannelInfos=\(String(describing: self.approvedChannelInfos)), "
    desc += "revision=\(String(describing: self.revision))"
    return desc
  }

}

extension ApprovedChannelInfos : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (approvedChannelInfos.hashValue)
    result = prime &* result &+ (revision.hashValue)
    return result
  }

}

extension ApprovedChannelInfos : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["approvedChannelInfos": 1, "revision": 2, ]
  }

  public static var structName: String { return "ApprovedChannelInfos" }

  public static func read(from proto: TProtocol) throws -> ApprovedChannelInfos {
    _ = try proto.readStructBegin()
    var approvedChannelInfos: TList<ApprovedChannelInfo>!
    var revision: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            approvedChannelInfos = try TList<ApprovedChannelInfo>.read(from: proto)
        case (2, .i64):             revision = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(approvedChannelInfos, named: "approvedChannelInfos")
    try proto.validateValue(revision, named: "revision")

    return ApprovedChannelInfos(approvedChannelInfos: approvedChannelInfos, revision: revision)
  }

}



public func ==(lhs: AuthQrcode, rhs: AuthQrcode) -> Bool {
  return
    (lhs.qrcode == rhs.qrcode) &&
    (lhs.verifier == rhs.verifier)
}

extension AuthQrcode : CustomStringConvertible {

  public var description : String {
    var desc = "AuthQrcode("
    desc += "qrcode=\(String(describing: self.qrcode)), "
    desc += "verifier=\(String(describing: self.verifier))"
    return desc
  }

}

extension AuthQrcode : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (qrcode.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension AuthQrcode : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["qrcode": 1, "verifier": 2, ]
  }

  public static var structName: String { return "AuthQrcode" }

  public static func read(from proto: TProtocol) throws -> AuthQrcode {
    _ = try proto.readStructBegin()
    var qrcode: String!
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           qrcode = try String.read(from: proto)
        case (2, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(qrcode, named: "qrcode")
    try proto.validateValue(verifier, named: "verifier")

    return AuthQrcode(qrcode: qrcode, verifier: verifier)
  }

}



public func ==(lhs: BuddyBanner, rhs: BuddyBanner) -> Bool {
  return
    (lhs.buddyBannerLinkType == rhs.buddyBannerLinkType) &&
    (lhs.buddyBannerLink == rhs.buddyBannerLink) &&
    (lhs.buddyBannerImageUrl == rhs.buddyBannerImageUrl)
}

extension BuddyBanner : CustomStringConvertible {

  public var description : String {
    var desc = "BuddyBanner("
    desc += "buddyBannerLinkType=\(String(describing: self.buddyBannerLinkType)), "
    desc += "buddyBannerLink=\(String(describing: self.buddyBannerLink)), "
    desc += "buddyBannerImageUrl=\(String(describing: self.buddyBannerImageUrl))"
    return desc
  }

}

extension BuddyBanner : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyBannerLinkType.hashValue)
    result = prime &* result &+ (buddyBannerLink.hashValue)
    result = prime &* result &+ (buddyBannerImageUrl.hashValue)
    return result
  }

}

extension BuddyBanner : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["buddyBannerLinkType": 1, "buddyBannerLink": 2, "buddyBannerImageUrl": 3, ]
  }

  public static var structName: String { return "BuddyBanner" }

  public static func read(from proto: TProtocol) throws -> BuddyBanner {
    _ = try proto.readStructBegin()
    var buddyBannerLinkType: BuddyBannerLinkType!
    var buddyBannerLink: String!
    var buddyBannerImageUrl: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             buddyBannerLinkType = try BuddyBannerLinkType.read(from: proto)
        case (2, .string):           buddyBannerLink = try String.read(from: proto)
        case (3, .string):           buddyBannerImageUrl = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyBannerLinkType, named: "buddyBannerLinkType")
    try proto.validateValue(buddyBannerLink, named: "buddyBannerLink")
    try proto.validateValue(buddyBannerImageUrl, named: "buddyBannerImageUrl")

    return BuddyBanner(buddyBannerLinkType: buddyBannerLinkType, buddyBannerLink: buddyBannerLink, buddyBannerImageUrl: buddyBannerImageUrl)
  }

}



public func ==(lhs: BuddyDetail, rhs: BuddyDetail) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.memberCount == rhs.memberCount) &&
    (lhs.onAir == rhs.onAir) &&
    (lhs.businessAccount == rhs.businessAccount) &&
    (lhs.addable == rhs.addable) &&
    (lhs.acceptableContentTypes == rhs.acceptableContentTypes) &&
    (lhs.capableMyhome == rhs.capableMyhome)
}

extension BuddyDetail : CustomStringConvertible {

  public var description : String {
    var desc = "BuddyDetail("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "memberCount=\(String(describing: self.memberCount)), "
    desc += "onAir=\(String(describing: self.onAir)), "
    desc += "businessAccount=\(String(describing: self.businessAccount)), "
    desc += "addable=\(String(describing: self.addable)), "
    desc += "acceptableContentTypes=\(String(describing: self.acceptableContentTypes)), "
    desc += "capableMyhome=\(String(describing: self.capableMyhome))"
    return desc
  }

}

extension BuddyDetail : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (memberCount.hashValue)
    result = prime &* result &+ (onAir.hashValue)
    result = prime &* result &+ (businessAccount.hashValue)
    result = prime &* result &+ (addable.hashValue)
    result = prime &* result &+ (acceptableContentTypes.hashValue)
    result = prime &* result &+ (capableMyhome.hashValue)
    return result
  }

}

extension BuddyDetail : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "memberCount": 2, "onAir": 3, "businessAccount": 4, "addable": 5, "acceptableContentTypes": 6, "capableMyhome": 7, ]
  }

  public static var structName: String { return "BuddyDetail" }

  public static func read(from proto: TProtocol) throws -> BuddyDetail {
    _ = try proto.readStructBegin()
    var mid: String!
    var memberCount: Int64!
    var onAir: Bool!
    var businessAccount: Bool!
    var addable: Bool!
    var acceptableContentTypes: TSet<ContentType>!
    var capableMyhome: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .i64):             memberCount = try Int64.read(from: proto)
        case (3, .bool):            onAir = try Bool.read(from: proto)
        case (4, .bool):            businessAccount = try Bool.read(from: proto)
        case (5, .bool):            addable = try Bool.read(from: proto)
        case (6, .set):             acceptableContentTypes = try TSet<ContentType>.read(from: proto)
        case (7, .bool):            capableMyhome = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(memberCount, named: "memberCount")
    try proto.validateValue(onAir, named: "onAir")
    try proto.validateValue(businessAccount, named: "businessAccount")
    try proto.validateValue(addable, named: "addable")
    try proto.validateValue(acceptableContentTypes, named: "acceptableContentTypes")
    try proto.validateValue(capableMyhome, named: "capableMyhome")

    return BuddyDetail(mid: mid, memberCount: memberCount, onAir: onAir, businessAccount: businessAccount, addable: addable, acceptableContentTypes: acceptableContentTypes, capableMyhome: capableMyhome)
  }

}



public func ==(lhs: Contact, rhs: Contact) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.type == rhs.type) &&
    (lhs.status == rhs.status) &&
    (lhs.relation == rhs.relation) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.phoneticName == rhs.phoneticName) &&
    (lhs.pictureStatus == rhs.pictureStatus) &&
    (lhs.thumbnailUrl == rhs.thumbnailUrl) &&
    (lhs.statusMessage == rhs.statusMessage) &&
    (lhs.displayNameOverridden == rhs.displayNameOverridden) &&
    (lhs.favoriteTime == rhs.favoriteTime) &&
    (lhs.capableVoiceCall == rhs.capableVoiceCall) &&
    (lhs.capableVideoCall == rhs.capableVideoCall) &&
    (lhs.capableMyhome == rhs.capableMyhome) &&
    (lhs.capableBuddy == rhs.capableBuddy) &&
    (lhs.attributes == rhs.attributes) &&
    (lhs.settings == rhs.settings) &&
    (lhs.picturePath == rhs.picturePath)
}

extension Contact : CustomStringConvertible {

  public var description : String {
    var desc = "Contact("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "type=\(String(describing: self.type)), "
    desc += "status=\(String(describing: self.status)), "
    desc += "relation=\(String(describing: self.relation)), "
    desc += "displayName=\(String(describing: self.displayName)), "
    desc += "phoneticName=\(String(describing: self.phoneticName)), "
    desc += "pictureStatus=\(String(describing: self.pictureStatus)), "
    desc += "thumbnailUrl=\(String(describing: self.thumbnailUrl)), "
    desc += "statusMessage=\(String(describing: self.statusMessage)), "
    desc += "displayNameOverridden=\(String(describing: self.displayNameOverridden)), "
    desc += "favoriteTime=\(String(describing: self.favoriteTime)), "
    desc += "capableVoiceCall=\(String(describing: self.capableVoiceCall)), "
    desc += "capableVideoCall=\(String(describing: self.capableVideoCall)), "
    desc += "capableMyhome=\(String(describing: self.capableMyhome)), "
    desc += "capableBuddy=\(String(describing: self.capableBuddy)), "
    desc += "attributes=\(String(describing: self.attributes)), "
    desc += "settings=\(String(describing: self.settings)), "
    desc += "picturePath=\(String(describing: self.picturePath))"
    return desc
  }

}

extension Contact : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (status.hashValue)
    result = prime &* result &+ (relation.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (phoneticName.hashValue)
    result = prime &* result &+ (pictureStatus.hashValue)
    result = prime &* result &+ (thumbnailUrl.hashValue)
    result = prime &* result &+ (statusMessage.hashValue)
    result = prime &* result &+ (displayNameOverridden.hashValue)
    result = prime &* result &+ (favoriteTime.hashValue)
    result = prime &* result &+ (capableVoiceCall.hashValue)
    result = prime &* result &+ (capableVideoCall.hashValue)
    result = prime &* result &+ (capableMyhome.hashValue)
    result = prime &* result &+ (capableBuddy.hashValue)
    result = prime &* result &+ (attributes.hashValue)
    result = prime &* result &+ (settings.hashValue)
    result = prime &* result &+ (picturePath.hashValue)
    return result
  }

}

extension Contact : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "createdTime": 2, "type": 10, "status": 11, "relation": 21, "displayName": 22, "phoneticName": 23, "pictureStatus": 24, "thumbnailUrl": 25, "statusMessage": 26, "displayNameOverridden": 27, "favoriteTime": 28, "capableVoiceCall": 31, "capableVideoCall": 32, "capableMyhome": 33, "capableBuddy": 34, "attributes": 35, "settings": 36, "picturePath": 37, ]
  }

  public static var structName: String { return "Contact" }

  public static func read(from proto: TProtocol) throws -> Contact {
    _ = try proto.readStructBegin()
    var mid: String!
    var createdTime: Int64!
    var type: ContactType!
    var status: ContactStatus!
    var relation: ContactRelation!
    var displayName: String!
    var phoneticName: String!
    var pictureStatus: String!
    var thumbnailUrl: String!
    var statusMessage: String!
    var displayNameOverridden: String!
    var favoriteTime: Int64!
    var capableVoiceCall: Bool!
    var capableVideoCall: Bool!
    var capableMyhome: Bool!
    var capableBuddy: Bool!
    var attributes: Int32!
    var settings: Int64!
    var picturePath: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .i64):             createdTime = try Int64.read(from: proto)
        case (10, .i32):             type = try ContactType.read(from: proto)
        case (11, .i32):             status = try ContactStatus.read(from: proto)
        case (21, .i32):             relation = try ContactRelation.read(from: proto)
        case (22, .string):           displayName = try String.read(from: proto)
        case (23, .string):           phoneticName = try String.read(from: proto)
        case (24, .string):           pictureStatus = try String.read(from: proto)
        case (25, .string):           thumbnailUrl = try String.read(from: proto)
        case (26, .string):           statusMessage = try String.read(from: proto)
        case (27, .string):           displayNameOverridden = try String.read(from: proto)
        case (28, .i64):             favoriteTime = try Int64.read(from: proto)
        case (31, .bool):            capableVoiceCall = try Bool.read(from: proto)
        case (32, .bool):            capableVideoCall = try Bool.read(from: proto)
        case (33, .bool):            capableMyhome = try Bool.read(from: proto)
        case (34, .bool):            capableBuddy = try Bool.read(from: proto)
        case (35, .i32):             attributes = try Int32.read(from: proto)
        case (36, .i64):             settings = try Int64.read(from: proto)
        case (37, .string):           picturePath = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(type, named: "type")
    try proto.validateValue(status, named: "status")
    try proto.validateValue(relation, named: "relation")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(phoneticName, named: "phoneticName")
    try proto.validateValue(pictureStatus, named: "pictureStatus")
    try proto.validateValue(thumbnailUrl, named: "thumbnailUrl")
    try proto.validateValue(statusMessage, named: "statusMessage")
    try proto.validateValue(displayNameOverridden, named: "displayNameOverridden")
    try proto.validateValue(favoriteTime, named: "favoriteTime")
    try proto.validateValue(capableVoiceCall, named: "capableVoiceCall")
    try proto.validateValue(capableVideoCall, named: "capableVideoCall")
    try proto.validateValue(capableMyhome, named: "capableMyhome")
    try proto.validateValue(capableBuddy, named: "capableBuddy")
    try proto.validateValue(attributes, named: "attributes")
    try proto.validateValue(settings, named: "settings")
    try proto.validateValue(picturePath, named: "picturePath")

    return Contact(mid: mid, createdTime: createdTime, type: type, status: status, relation: relation, displayName: displayName, phoneticName: phoneticName, pictureStatus: pictureStatus, thumbnailUrl: thumbnailUrl, statusMessage: statusMessage, displayNameOverridden: displayNameOverridden, favoriteTime: favoriteTime, capableVoiceCall: capableVoiceCall, capableVideoCall: capableVideoCall, capableMyhome: capableMyhome, capableBuddy: capableBuddy, attributes: attributes, settings: settings, picturePath: picturePath)
  }

}



public func ==(lhs: BuddyList, rhs: BuddyList) -> Bool {
  return
    (lhs.classification == rhs.classification) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.totalBuddyCount == rhs.totalBuddyCount) &&
    (lhs.popularContacts == rhs.popularContacts)
}

extension BuddyList : CustomStringConvertible {

  public var description : String {
    var desc = "BuddyList("
    desc += "classification=\(String(describing: self.classification)), "
    desc += "displayName=\(String(describing: self.displayName)), "
    desc += "totalBuddyCount=\(String(describing: self.totalBuddyCount)), "
    desc += "popularContacts=\(String(describing: self.popularContacts))"
    return desc
  }

}

extension BuddyList : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (classification.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (totalBuddyCount.hashValue)
    result = prime &* result &+ (popularContacts.hashValue)
    return result
  }

}

extension BuddyList : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["classification": 1, "displayName": 2, "totalBuddyCount": 3, "popularContacts": 4, ]
  }

  public static var structName: String { return "BuddyList" }

  public static func read(from proto: TProtocol) throws -> BuddyList {
    _ = try proto.readStructBegin()
    var classification: String!
    var displayName: String!
    var totalBuddyCount: Int32!
    var popularContacts: TList<Contact>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           classification = try String.read(from: proto)
        case (2, .string):           displayName = try String.read(from: proto)
        case (3, .i32):             totalBuddyCount = try Int32.read(from: proto)
        case (4, .list):            popularContacts = try TList<Contact>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(classification, named: "classification")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(totalBuddyCount, named: "totalBuddyCount")
    try proto.validateValue(popularContacts, named: "popularContacts")

    return BuddyList(classification: classification, displayName: displayName, totalBuddyCount: totalBuddyCount, popularContacts: popularContacts)
  }

}



public func ==(lhs: Location, rhs: Location) -> Bool {
  return
    (lhs.title == rhs.title) &&
    (lhs.address == rhs.address) &&
    (lhs.latitude == rhs.latitude) &&
    (lhs.longitude == rhs.longitude) &&
    (lhs.phone == rhs.phone)
}

extension Location : CustomStringConvertible {

  public var description : String {
    var desc = "Location("
    desc += "title=\(String(describing: self.title)), "
    desc += "address=\(String(describing: self.address)), "
    desc += "latitude=\(String(describing: self.latitude)), "
    desc += "longitude=\(String(describing: self.longitude)), "
    desc += "phone=\(String(describing: self.phone))"
    return desc
  }

}

extension Location : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (title.hashValue)
    result = prime &* result &+ (address.hashValue)
    result = prime &* result &+ (latitude.hashValue)
    result = prime &* result &+ (longitude.hashValue)
    result = prime &* result &+ (phone.hashValue)
    return result
  }

}

extension Location : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["title": 1, "address": 2, "latitude": 3, "longitude": 4, "phone": 5, ]
  }

  public static var structName: String { return "Location" }

  public static func read(from proto: TProtocol) throws -> Location {
    _ = try proto.readStructBegin()
    var title: String!
    var address: String!
    var latitude: Double!
    var longitude: Double!
    var phone: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           title = try String.read(from: proto)
        case (2, .string):           address = try String.read(from: proto)
        case (3, .double):           latitude = try Double.read(from: proto)
        case (4, .double):           longitude = try Double.read(from: proto)
        case (5, .string):           phone = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(title, named: "title")
    try proto.validateValue(address, named: "address")
    try proto.validateValue(latitude, named: "latitude")
    try proto.validateValue(longitude, named: "longitude")
    try proto.validateValue(phone, named: "phone")

    return Location(title: title, address: address, latitude: latitude, longitude: longitude, phone: phone)
  }

}



public func ==(lhs: BuddyMessageRequest, rhs: BuddyMessageRequest) -> Bool {
  return
    (lhs.contentType == rhs.contentType) &&
    (lhs.text == rhs.text) &&
    (lhs.location == rhs.location) &&
    (lhs.content == rhs.content) &&
    (lhs.contentMetadata == rhs.contentMetadata)
}

extension BuddyMessageRequest : CustomStringConvertible {

  public var description : String {
    var desc = "BuddyMessageRequest("
    desc += "contentType=\(String(describing: self.contentType)), "
    desc += "text=\(String(describing: self.text)), "
    desc += "location=\(String(describing: self.location)), "
    desc += "content=\(String(describing: self.content)), "
    desc += "contentMetadata=\(String(describing: self.contentMetadata))"
    return desc
  }

}

extension BuddyMessageRequest : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (contentType.hashValue)
    result = prime &* result &+ (text.hashValue)
    result = prime &* result &+ (location.hashValue)
    result = prime &* result &+ (content.hashValue)
    result = prime &* result &+ (contentMetadata.hashValue)
    return result
  }

}

extension BuddyMessageRequest : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["contentType": 1, "text": 2, "location": 3, "content": 4, "contentMetadata": 5, ]
  }

  public static var structName: String { return "BuddyMessageRequest" }

  public static func read(from proto: TProtocol) throws -> BuddyMessageRequest {
    _ = try proto.readStructBegin()
    var contentType: ContentType!
    var text: String!
    var location: Location!
    var content: Data!
    var contentMetadata: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             contentType = try ContentType.read(from: proto)
        case (2, .string):           text = try String.read(from: proto)
        case (3, .struct):           location = try Location.read(from: proto)
        case (4, .string):           content = try Data.read(from: proto)
        case (5, .map):             contentMetadata = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(contentType, named: "contentType")
    try proto.validateValue(text, named: "text")
    try proto.validateValue(location, named: "location")
    try proto.validateValue(content, named: "content")
    try proto.validateValue(contentMetadata, named: "contentMetadata")

    return BuddyMessageRequest(contentType: contentType, text: text, location: location, content: content, contentMetadata: contentMetadata)
  }

}



public func ==(lhs: BuddyOnAirUrls, rhs: BuddyOnAirUrls) -> Bool {
  return
    (lhs.hls == rhs.hls) &&
    (lhs.smoothStreaming == rhs.smoothStreaming)
}

extension BuddyOnAirUrls : CustomStringConvertible {

  public var description : String {
    var desc = "BuddyOnAirUrls("
    desc += "hls=\(String(describing: self.hls)), "
    desc += "smoothStreaming=\(String(describing: self.smoothStreaming))"
    return desc
  }

}

extension BuddyOnAirUrls : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (hls.hashValue)
    result = prime &* result &+ (smoothStreaming.hashValue)
    return result
  }

}

extension BuddyOnAirUrls : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["hls": 1, "smoothStreaming": 2, ]
  }

  public static var structName: String { return "BuddyOnAirUrls" }

  public static func read(from proto: TProtocol) throws -> BuddyOnAirUrls {
    _ = try proto.readStructBegin()
    var hls: TMap<String, String>!
    var smoothStreaming: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .map):             hls = try TMap<String, String>.read(from: proto)
        case (2, .map):             smoothStreaming = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(hls, named: "hls")
    try proto.validateValue(smoothStreaming, named: "smoothStreaming")

    return BuddyOnAirUrls(hls: hls, smoothStreaming: smoothStreaming)
  }

}



public func ==(lhs: BuddyOnAir, rhs: BuddyOnAir) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.freshnessLifetime == rhs.freshnessLifetime) &&
    (lhs.onAirId == rhs.onAirId) &&
    (lhs.onAir == rhs.onAir) &&
    (lhs.text == rhs.text) &&
    (lhs.viewerCount == rhs.viewerCount) &&
    (lhs.targetCount == rhs.targetCount) &&
    (lhs.onAirType == rhs.onAirType) &&
    (lhs.onAirUrls == rhs.onAirUrls)
}

extension BuddyOnAir : CustomStringConvertible {

  public var description : String {
    var desc = "BuddyOnAir("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "freshnessLifetime=\(String(describing: self.freshnessLifetime)), "
    desc += "onAirId=\(String(describing: self.onAirId)), "
    desc += "onAir=\(String(describing: self.onAir)), "
    desc += "text=\(String(describing: self.text)), "
    desc += "viewerCount=\(String(describing: self.viewerCount)), "
    desc += "targetCount=\(String(describing: self.targetCount)), "
    desc += "onAirType=\(String(describing: self.onAirType)), "
    desc += "onAirUrls=\(String(describing: self.onAirUrls))"
    return desc
  }

}

extension BuddyOnAir : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (freshnessLifetime.hashValue)
    result = prime &* result &+ (onAirId.hashValue)
    result = prime &* result &+ (onAir.hashValue)
    result = prime &* result &+ (text.hashValue)
    result = prime &* result &+ (viewerCount.hashValue)
    result = prime &* result &+ (targetCount.hashValue)
    result = prime &* result &+ (onAirType.hashValue)
    result = prime &* result &+ (onAirUrls.hashValue)
    return result
  }

}

extension BuddyOnAir : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "freshnessLifetime": 3, "onAirId": 4, "onAir": 5, "text": 11, "viewerCount": 12, "targetCount": 13, "onAirType": 31, "onAirUrls": 32, ]
  }

  public static var structName: String { return "BuddyOnAir" }

  public static func read(from proto: TProtocol) throws -> BuddyOnAir {
    _ = try proto.readStructBegin()
    var mid: String!
    var freshnessLifetime: Int64!
    var onAirId: String!
    var onAir: Bool!
    var text: String!
    var viewerCount: Int64!
    var targetCount: Int64!
    var onAirType: BuddyOnAirType!
    var onAirUrls: BuddyOnAirUrls!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (3, .i64):             freshnessLifetime = try Int64.read(from: proto)
        case (4, .string):           onAirId = try String.read(from: proto)
        case (5, .bool):            onAir = try Bool.read(from: proto)
        case (11, .string):           text = try String.read(from: proto)
        case (12, .i64):             viewerCount = try Int64.read(from: proto)
        case (13, .i64):             targetCount = try Int64.read(from: proto)
        case (31, .i32):             onAirType = try BuddyOnAirType.read(from: proto)
        case (32, .struct):           onAirUrls = try BuddyOnAirUrls.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(freshnessLifetime, named: "freshnessLifetime")
    try proto.validateValue(onAirId, named: "onAirId")
    try proto.validateValue(onAir, named: "onAir")
    try proto.validateValue(text, named: "text")
    try proto.validateValue(viewerCount, named: "viewerCount")
    try proto.validateValue(targetCount, named: "targetCount")
    try proto.validateValue(onAirType, named: "onAirType")
    try proto.validateValue(onAirUrls, named: "onAirUrls")

    return BuddyOnAir(mid: mid, freshnessLifetime: freshnessLifetime, onAirId: onAirId, onAir: onAir, text: text, viewerCount: viewerCount, targetCount: targetCount, onAirType: onAirType, onAirUrls: onAirUrls)
  }

}



public func ==(lhs: BuddyProfile, rhs: BuddyProfile) -> Bool {
  return
    (lhs.buddyId == rhs.buddyId) &&
    (lhs.mid == rhs.mid) &&
    (lhs.searchId == rhs.searchId) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.statusMessage == rhs.statusMessage) &&
    (lhs.contactCount == rhs.contactCount)
}

extension BuddyProfile : CustomStringConvertible {

  public var description : String {
    var desc = "BuddyProfile("
    desc += "buddyId=\(String(describing: self.buddyId)), "
    desc += "mid=\(String(describing: self.mid)), "
    desc += "searchId=\(String(describing: self.searchId)), "
    desc += "displayName=\(String(describing: self.displayName)), "
    desc += "statusMessage=\(String(describing: self.statusMessage)), "
    desc += "contactCount=\(String(describing: self.contactCount))"
    return desc
  }

}

extension BuddyProfile : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyId.hashValue)
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (searchId.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (statusMessage.hashValue)
    result = prime &* result &+ (contactCount.hashValue)
    return result
  }

}

extension BuddyProfile : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["buddyId": 1, "mid": 2, "searchId": 3, "displayName": 4, "statusMessage": 5, "contactCount": 11, ]
  }

  public static var structName: String { return "BuddyProfile" }

  public static func read(from proto: TProtocol) throws -> BuddyProfile {
    _ = try proto.readStructBegin()
    var buddyId: String!
    var mid: String!
    var searchId: String!
    var displayName: String!
    var statusMessage: String!
    var contactCount: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           buddyId = try String.read(from: proto)
        case (2, .string):           mid = try String.read(from: proto)
        case (3, .string):           searchId = try String.read(from: proto)
        case (4, .string):           displayName = try String.read(from: proto)
        case (5, .string):           statusMessage = try String.read(from: proto)
        case (11, .i64):             contactCount = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyId, named: "buddyId")
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(searchId, named: "searchId")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(statusMessage, named: "statusMessage")
    try proto.validateValue(contactCount, named: "contactCount")

    return BuddyProfile(buddyId: buddyId, mid: mid, searchId: searchId, displayName: displayName, statusMessage: statusMessage, contactCount: contactCount)
  }

}



public func ==(lhs: BuddySearchResult, rhs: BuddySearchResult) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.pictureStatus == rhs.pictureStatus) &&
    (lhs.picturePath == rhs.picturePath) &&
    (lhs.statusMessage == rhs.statusMessage) &&
    (lhs.businessAccount == rhs.businessAccount)
}

extension BuddySearchResult : CustomStringConvertible {

  public var description : String {
    var desc = "BuddySearchResult("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "displayName=\(String(describing: self.displayName)), "
    desc += "pictureStatus=\(String(describing: self.pictureStatus)), "
    desc += "picturePath=\(String(describing: self.picturePath)), "
    desc += "statusMessage=\(String(describing: self.statusMessage)), "
    desc += "businessAccount=\(String(describing: self.businessAccount))"
    return desc
  }

}

extension BuddySearchResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (pictureStatus.hashValue)
    result = prime &* result &+ (picturePath.hashValue)
    result = prime &* result &+ (statusMessage.hashValue)
    result = prime &* result &+ (businessAccount.hashValue)
    return result
  }

}

extension BuddySearchResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "displayName": 2, "pictureStatus": 3, "picturePath": 4, "statusMessage": 5, "businessAccount": 6, ]
  }

  public static var structName: String { return "BuddySearchResult" }

  public static func read(from proto: TProtocol) throws -> BuddySearchResult {
    _ = try proto.readStructBegin()
    var mid: String!
    var displayName: String!
    var pictureStatus: String!
    var picturePath: String!
    var statusMessage: String!
    var businessAccount: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .string):           displayName = try String.read(from: proto)
        case (3, .string):           pictureStatus = try String.read(from: proto)
        case (4, .string):           picturePath = try String.read(from: proto)
        case (5, .string):           statusMessage = try String.read(from: proto)
        case (6, .bool):            businessAccount = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(pictureStatus, named: "pictureStatus")
    try proto.validateValue(picturePath, named: "picturePath")
    try proto.validateValue(statusMessage, named: "statusMessage")
    try proto.validateValue(businessAccount, named: "businessAccount")

    return BuddySearchResult(mid: mid, displayName: displayName, pictureStatus: pictureStatus, picturePath: picturePath, statusMessage: statusMessage, businessAccount: businessAccount)
  }

}



public func ==(lhs: ChannelDomain, rhs: ChannelDomain) -> Bool {
  return
    (lhs.host == rhs.host) &&
    (lhs.removed == rhs.removed)
}

extension ChannelDomain : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelDomain("
    desc += "host=\(String(describing: self.host)), "
    desc += "removed=\(String(describing: self.removed))"
    return desc
  }

}

extension ChannelDomain : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (host.hashValue)
    result = prime &* result &+ (removed.hashValue)
    return result
  }

}

extension ChannelDomain : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["host": 1, "removed": 2, ]
  }

  public static var structName: String { return "ChannelDomain" }

  public static func read(from proto: TProtocol) throws -> ChannelDomain {
    _ = try proto.readStructBegin()
    var host: String!
    var removed: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           host = try String.read(from: proto)
        case (2, .bool):            removed = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(host, named: "host")
    try proto.validateValue(removed, named: "removed")

    return ChannelDomain(host: host, removed: removed)
  }

}



public func ==(lhs: ChannelDomains, rhs: ChannelDomains) -> Bool {
  return
    (lhs.channelDomains == rhs.channelDomains) &&
    (lhs.revision == rhs.revision)
}

extension ChannelDomains : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelDomains("
    desc += "channelDomains=\(String(describing: self.channelDomains)), "
    desc += "revision=\(String(describing: self.revision))"
    return desc
  }

}

extension ChannelDomains : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelDomains.hashValue)
    result = prime &* result &+ (revision.hashValue)
    return result
  }

}

extension ChannelDomains : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelDomains": 1, "revision": 2, ]
  }

  public static var structName: String { return "ChannelDomains" }

  public static func read(from proto: TProtocol) throws -> ChannelDomains {
    _ = try proto.readStructBegin()
    var channelDomains: TList<ChannelDomain>!
    var revision: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            channelDomains = try TList<ChannelDomain>.read(from: proto)
        case (2, .i64):             revision = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelDomains, named: "channelDomains")
    try proto.validateValue(revision, named: "revision")

    return ChannelDomains(channelDomains: channelDomains, revision: revision)
  }

}



public func ==(lhs: ChannelException, rhs: ChannelException) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.reason == rhs.reason) &&
    (lhs.parameterMap == rhs.parameterMap)
}

extension ChannelException : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelException("
    desc += "code=\(String(describing: self.code)), "
    desc += "reason=\(String(describing: self.reason)), "
    desc += "parameterMap=\(String(describing: self.parameterMap))"
    return desc
  }

}

extension ChannelException : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (code.hashValue)
    result = prime &* result &+ (reason.hashValue)
    result = prime &* result &+ (parameterMap.hashValue)
    return result
  }

}

extension ChannelException : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["code": 1, "reason": 2, "parameterMap": 3, ]
  }

  public static var structName: String { return "ChannelException" }

  public static func read(from proto: TProtocol) throws -> ChannelException {
    _ = try proto.readStructBegin()
    var code: ChannelErrorCode!
    var reason: String!
    var parameterMap: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             code = try ChannelErrorCode.read(from: proto)
        case (2, .string):           reason = try String.read(from: proto)
        case (3, .map):             parameterMap = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(reason, named: "reason")
    try proto.validateValue(parameterMap, named: "parameterMap")

    return ChannelException(code: code, reason: reason, parameterMap: parameterMap)
  }

}



public func ==(lhs: ChannelInfos, rhs: ChannelInfos) -> Bool {
  return
    (lhs.channelInfos == rhs.channelInfos) &&
    (lhs.revision == rhs.revision)
}

extension ChannelInfos : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelInfos("
    desc += "channelInfos=\(String(describing: self.channelInfos)), "
    desc += "revision=\(String(describing: self.revision))"
    return desc
  }

}

extension ChannelInfos : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelInfos.hashValue)
    result = prime &* result &+ (revision.hashValue)
    return result
  }

}

extension ChannelInfos : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelInfos": 1, "revision": 2, ]
  }

  public static var structName: String { return "ChannelInfos" }

  public static func read(from proto: TProtocol) throws -> ChannelInfos {
    _ = try proto.readStructBegin()
    var channelInfos: TList<ChannelInfo>!
    var revision: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            channelInfos = try TList<ChannelInfo>.read(from: proto)
        case (2, .i64):             revision = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelInfos, named: "channelInfos")
    try proto.validateValue(revision, named: "revision")

    return ChannelInfos(channelInfos: channelInfos, revision: revision)
  }

}



public func ==(lhs: ChannelNotificationSetting, rhs: ChannelNotificationSetting) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.name == rhs.name) &&
    (lhs.notificationReceivable == rhs.notificationReceivable) &&
    (lhs.messageReceivable == rhs.messageReceivable) &&
    (lhs.showDefault == rhs.showDefault)
}

extension ChannelNotificationSetting : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelNotificationSetting("
    desc += "channelId=\(String(describing: self.channelId)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "notificationReceivable=\(String(describing: self.notificationReceivable)), "
    desc += "messageReceivable=\(String(describing: self.messageReceivable)), "
    desc += "showDefault=\(String(describing: self.showDefault))"
    return desc
  }

}

extension ChannelNotificationSetting : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (notificationReceivable.hashValue)
    result = prime &* result &+ (messageReceivable.hashValue)
    result = prime &* result &+ (showDefault.hashValue)
    return result
  }

}

extension ChannelNotificationSetting : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelId": 1, "name": 2, "notificationReceivable": 3, "messageReceivable": 4, "showDefault": 5, ]
  }

  public static var structName: String { return "ChannelNotificationSetting" }

  public static func read(from proto: TProtocol) throws -> ChannelNotificationSetting {
    _ = try proto.readStructBegin()
    var channelId: String!
    var name: String!
    var notificationReceivable: Bool!
    var messageReceivable: Bool!
    var showDefault: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .bool):            notificationReceivable = try Bool.read(from: proto)
        case (4, .bool):            messageReceivable = try Bool.read(from: proto)
        case (5, .bool):            showDefault = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(notificationReceivable, named: "notificationReceivable")
    try proto.validateValue(messageReceivable, named: "messageReceivable")
    try proto.validateValue(showDefault, named: "showDefault")

    return ChannelNotificationSetting(channelId: channelId, name: name, notificationReceivable: notificationReceivable, messageReceivable: messageReceivable, showDefault: showDefault)
  }

}



public func ==(lhs: ChannelSyncDatas, rhs: ChannelSyncDatas) -> Bool {
  return
    (lhs.channelInfos == rhs.channelInfos) &&
    (lhs.channelDomains == rhs.channelDomains) &&
    (lhs.revision == rhs.revision) &&
    (lhs.expires == rhs.expires)
}

extension ChannelSyncDatas : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelSyncDatas("
    desc += "channelInfos=\(String(describing: self.channelInfos)), "
    desc += "channelDomains=\(String(describing: self.channelDomains)), "
    desc += "revision=\(String(describing: self.revision)), "
    desc += "expires=\(String(describing: self.expires))"
    return desc
  }

}

extension ChannelSyncDatas : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelInfos.hashValue)
    result = prime &* result &+ (channelDomains.hashValue)
    result = prime &* result &+ (revision.hashValue)
    result = prime &* result &+ (expires.hashValue)
    return result
  }

}

extension ChannelSyncDatas : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelInfos": 1, "channelDomains": 2, "revision": 3, "expires": 4, ]
  }

  public static var structName: String { return "ChannelSyncDatas" }

  public static func read(from proto: TProtocol) throws -> ChannelSyncDatas {
    _ = try proto.readStructBegin()
    var channelInfos: TList<ChannelInfo>!
    var channelDomains: TList<ChannelDomain>!
    var revision: Int64!
    var expires: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            channelInfos = try TList<ChannelInfo>.read(from: proto)
        case (2, .list):            channelDomains = try TList<ChannelDomain>.read(from: proto)
        case (3, .i64):             revision = try Int64.read(from: proto)
        case (4, .i64):             expires = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelInfos, named: "channelInfos")
    try proto.validateValue(channelDomains, named: "channelDomains")
    try proto.validateValue(revision, named: "revision")
    try proto.validateValue(expires, named: "expires")

    return ChannelSyncDatas(channelInfos: channelInfos, channelDomains: channelDomains, revision: revision, expires: expires)
  }

}



public func ==(lhs: ChannelToken, rhs: ChannelToken) -> Bool {
  return
    (lhs.token == rhs.token) &&
    (lhs.obsToken == rhs.obsToken) &&
    (lhs.expiration == rhs.expiration) &&
    (lhs.refreshToken == rhs.refreshToken) &&
    (lhs.channelAccessToken == rhs.channelAccessToken)
}

extension ChannelToken : CustomStringConvertible {

  public var description : String {
    var desc = "ChannelToken("
    desc += "token=\(String(describing: self.token)), "
    desc += "obsToken=\(String(describing: self.obsToken)), "
    desc += "expiration=\(String(describing: self.expiration)), "
    desc += "refreshToken=\(String(describing: self.refreshToken)), "
    desc += "channelAccessToken=\(String(describing: self.channelAccessToken))"
    return desc
  }

}

extension ChannelToken : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (token.hashValue)
    result = prime &* result &+ (obsToken.hashValue)
    result = prime &* result &+ (expiration.hashValue)
    result = prime &* result &+ (refreshToken.hashValue)
    result = prime &* result &+ (channelAccessToken.hashValue)
    return result
  }

}

extension ChannelToken : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["token": 1, "obsToken": 2, "expiration": 3, "refreshToken": 4, "channelAccessToken": 5, ]
  }

  public static var structName: String { return "ChannelToken" }

  public static func read(from proto: TProtocol) throws -> ChannelToken {
    _ = try proto.readStructBegin()
    var token: String!
    var obsToken: String!
    var expiration: Int64!
    var refreshToken: String!
    var channelAccessToken: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           token = try String.read(from: proto)
        case (2, .string):           obsToken = try String.read(from: proto)
        case (3, .i64):             expiration = try Int64.read(from: proto)
        case (4, .string):           refreshToken = try String.read(from: proto)
        case (5, .string):           channelAccessToken = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(token, named: "token")
    try proto.validateValue(obsToken, named: "obsToken")
    try proto.validateValue(expiration, named: "expiration")
    try proto.validateValue(refreshToken, named: "refreshToken")
    try proto.validateValue(channelAccessToken, named: "channelAccessToken")

    return ChannelToken(token: token, obsToken: obsToken, expiration: expiration, refreshToken: refreshToken, channelAccessToken: channelAccessToken)
  }

}



public func ==(lhs: Coin, rhs: Coin) -> Bool {
  return
    (lhs.freeCoinBalance == rhs.freeCoinBalance) &&
    (lhs.payedCoinBalance == rhs.payedCoinBalance) &&
    (lhs.totalCoinBalance == rhs.totalCoinBalance) &&
    (lhs.rewardCoinBalance == rhs.rewardCoinBalance)
}

extension Coin : CustomStringConvertible {

  public var description : String {
    var desc = "Coin("
    desc += "freeCoinBalance=\(String(describing: self.freeCoinBalance)), "
    desc += "payedCoinBalance=\(String(describing: self.payedCoinBalance)), "
    desc += "totalCoinBalance=\(String(describing: self.totalCoinBalance)), "
    desc += "rewardCoinBalance=\(String(describing: self.rewardCoinBalance))"
    return desc
  }

}

extension Coin : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (freeCoinBalance.hashValue)
    result = prime &* result &+ (payedCoinBalance.hashValue)
    result = prime &* result &+ (totalCoinBalance.hashValue)
    result = prime &* result &+ (rewardCoinBalance.hashValue)
    return result
  }

}

extension Coin : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["freeCoinBalance": 1, "payedCoinBalance": 2, "totalCoinBalance": 3, "rewardCoinBalance": 4, ]
  }

  public static var structName: String { return "Coin" }

  public static func read(from proto: TProtocol) throws -> Coin {
    _ = try proto.readStructBegin()
    var freeCoinBalance: Int32!
    var payedCoinBalance: Int32!
    var totalCoinBalance: Int32!
    var rewardCoinBalance: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             freeCoinBalance = try Int32.read(from: proto)
        case (2, .i32):             payedCoinBalance = try Int32.read(from: proto)
        case (3, .i32):             totalCoinBalance = try Int32.read(from: proto)
        case (4, .i32):             rewardCoinBalance = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(freeCoinBalance, named: "freeCoinBalance")
    try proto.validateValue(payedCoinBalance, named: "payedCoinBalance")
    try proto.validateValue(totalCoinBalance, named: "totalCoinBalance")
    try proto.validateValue(rewardCoinBalance, named: "rewardCoinBalance")

    return Coin(freeCoinBalance: freeCoinBalance, payedCoinBalance: payedCoinBalance, totalCoinBalance: totalCoinBalance, rewardCoinBalance: rewardCoinBalance)
  }

}



public func ==(lhs: CoinPayLoad, rhs: CoinPayLoad) -> Bool {
  return
    (lhs.payCoin == rhs.payCoin) &&
    (lhs.freeCoin == rhs.freeCoin) &&
    (lhs.type == rhs.type) &&
    (lhs.rewardCoin == rhs.rewardCoin)
}

extension CoinPayLoad : CustomStringConvertible {

  public var description : String {
    var desc = "CoinPayLoad("
    desc += "payCoin=\(String(describing: self.payCoin)), "
    desc += "freeCoin=\(String(describing: self.freeCoin)), "
    desc += "type=\(String(describing: self.type)), "
    desc += "rewardCoin=\(String(describing: self.rewardCoin))"
    return desc
  }

}

extension CoinPayLoad : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (payCoin.hashValue)
    result = prime &* result &+ (freeCoin.hashValue)
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (rewardCoin.hashValue)
    return result
  }

}

extension CoinPayLoad : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["payCoin": 1, "freeCoin": 2, "type": 3, "rewardCoin": 4, ]
  }

  public static var structName: String { return "CoinPayLoad" }

  public static func read(from proto: TProtocol) throws -> CoinPayLoad {
    _ = try proto.readStructBegin()
    var payCoin: Int32!
    var freeCoin: Int32!
    var type: PayloadType!
    var rewardCoin: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             payCoin = try Int32.read(from: proto)
        case (2, .i32):             freeCoin = try Int32.read(from: proto)
        case (3, .i32):             type = try PayloadType.read(from: proto)
        case (4, .i32):             rewardCoin = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(payCoin, named: "payCoin")
    try proto.validateValue(freeCoin, named: "freeCoin")
    try proto.validateValue(type, named: "type")
    try proto.validateValue(rewardCoin, named: "rewardCoin")

    return CoinPayLoad(payCoin: payCoin, freeCoin: freeCoin, type: type, rewardCoin: rewardCoin)
  }

}



public func ==(lhs: CoinHistory, rhs: CoinHistory) -> Bool {
  return
    (lhs.payDate == rhs.payDate) &&
    (lhs.coinBalance == rhs.coinBalance) &&
    (lhs.coin == rhs.coin) &&
    (lhs.price == rhs.price) &&
    (lhs.title == rhs.title) &&
    (lhs.refund == rhs.refund) &&
    (lhs.paySeq == rhs.paySeq) &&
    (lhs.currency == rhs.currency) &&
    (lhs.currencySign == rhs.currencySign) &&
    (lhs.displayPrice == rhs.displayPrice) &&
    (lhs.payload == rhs.payload) &&
    (lhs.channelId == rhs.channelId)
}

extension CoinHistory : CustomStringConvertible {

  public var description : String {
    var desc = "CoinHistory("
    desc += "payDate=\(String(describing: self.payDate)), "
    desc += "coinBalance=\(String(describing: self.coinBalance)), "
    desc += "coin=\(String(describing: self.coin)), "
    desc += "price=\(String(describing: self.price)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "refund=\(String(describing: self.refund)), "
    desc += "paySeq=\(String(describing: self.paySeq)), "
    desc += "currency=\(String(describing: self.currency)), "
    desc += "currencySign=\(String(describing: self.currencySign)), "
    desc += "displayPrice=\(String(describing: self.displayPrice)), "
    desc += "payload=\(String(describing: self.payload)), "
    desc += "channelId=\(String(describing: self.channelId))"
    return desc
  }

}

extension CoinHistory : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (payDate.hashValue)
    result = prime &* result &+ (coinBalance.hashValue)
    result = prime &* result &+ (coin.hashValue)
    result = prime &* result &+ (price.hashValue)
    result = prime &* result &+ (title.hashValue)
    result = prime &* result &+ (refund.hashValue)
    result = prime &* result &+ (paySeq.hashValue)
    result = prime &* result &+ (currency.hashValue)
    result = prime &* result &+ (currencySign.hashValue)
    result = prime &* result &+ (displayPrice.hashValue)
    result = prime &* result &+ (payload.hashValue)
    result = prime &* result &+ (channelId.hashValue)
    return result
  }

}

extension CoinHistory : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["payDate": 1, "coinBalance": 2, "coin": 3, "price": 4, "title": 5, "refund": 6, "paySeq": 7, "currency": 8, "currencySign": 9, "displayPrice": 10, "payload": 11, "channelId": 12, ]
  }

  public static var structName: String { return "CoinHistory" }

  public static func read(from proto: TProtocol) throws -> CoinHistory {
    _ = try proto.readStructBegin()
    var payDate: Int64!
    var coinBalance: Int32!
    var coin: Int32!
    var price: String!
    var title: String!
    var refund: Bool!
    var paySeq: String!
    var currency: String!
    var currencySign: String!
    var displayPrice: String!
    var payload: CoinPayLoad!
    var channelId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             payDate = try Int64.read(from: proto)
        case (2, .i32):             coinBalance = try Int32.read(from: proto)
        case (3, .i32):             coin = try Int32.read(from: proto)
        case (4, .string):           price = try String.read(from: proto)
        case (5, .string):           title = try String.read(from: proto)
        case (6, .bool):            refund = try Bool.read(from: proto)
        case (7, .string):           paySeq = try String.read(from: proto)
        case (8, .string):           currency = try String.read(from: proto)
        case (9, .string):           currencySign = try String.read(from: proto)
        case (10, .string):           displayPrice = try String.read(from: proto)
        case (11, .struct):           payload = try CoinPayLoad.read(from: proto)
        case (12, .string):           channelId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(payDate, named: "payDate")
    try proto.validateValue(coinBalance, named: "coinBalance")
    try proto.validateValue(coin, named: "coin")
    try proto.validateValue(price, named: "price")
    try proto.validateValue(title, named: "title")
    try proto.validateValue(refund, named: "refund")
    try proto.validateValue(paySeq, named: "paySeq")
    try proto.validateValue(currency, named: "currency")
    try proto.validateValue(currencySign, named: "currencySign")
    try proto.validateValue(displayPrice, named: "displayPrice")
    try proto.validateValue(payload, named: "payload")
    try proto.validateValue(channelId, named: "channelId")

    return CoinHistory(payDate: payDate, coinBalance: coinBalance, coin: coin, price: price, title: title, refund: refund, paySeq: paySeq, currency: currency, currencySign: currencySign, displayPrice: displayPrice, payload: payload, channelId: channelId)
  }

}



public func ==(lhs: CoinHistoryCondition, rhs: CoinHistoryCondition) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.eddt == rhs.eddt) &&
    (lhs.appStoreCode == rhs.appStoreCode)
}

extension CoinHistoryCondition : CustomStringConvertible {

  public var description : String {
    var desc = "CoinHistoryCondition("
    desc += "start=\(String(describing: self.start)), "
    desc += "size=\(String(describing: self.size)), "
    desc += "language=\(String(describing: self.language)), "
    desc += "eddt=\(String(describing: self.eddt)), "
    desc += "appStoreCode=\(String(describing: self.appStoreCode))"
    return desc
  }

}

extension CoinHistoryCondition : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (eddt.hashValue)
    result = prime &* result &+ (appStoreCode.hashValue)
    return result
  }

}

extension CoinHistoryCondition : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["start": 1, "size": 2, "language": 3, "eddt": 4, "appStoreCode": 5, ]
  }

  public static var structName: String { return "CoinHistoryCondition" }

  public static func read(from proto: TProtocol) throws -> CoinHistoryCondition {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var eddt: String!
    var appStoreCode: PaymentType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             start = try Int64.read(from: proto)
        case (2, .i32):             size = try Int32.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case (4, .string):           eddt = try String.read(from: proto)
        case (5, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(eddt, named: "eddt")
    try proto.validateValue(appStoreCode, named: "appStoreCode")

    return CoinHistoryCondition(start: start, size: size, language: language, eddt: eddt, appStoreCode: appStoreCode)
  }

}



public func ==(lhs: CoinHistoryResult, rhs: CoinHistoryResult) -> Bool {
  return
    (lhs.historys == rhs.historys) &&
    (lhs.balance == rhs.balance) &&
    (lhs.hasNext == rhs.hasNext)
}

extension CoinHistoryResult : CustomStringConvertible {

  public var description : String {
    var desc = "CoinHistoryResult("
    desc += "historys=\(String(describing: self.historys)), "
    desc += "balance=\(String(describing: self.balance)), "
    desc += "hasNext=\(String(describing: self.hasNext))"
    return desc
  }

}

extension CoinHistoryResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (historys.hashValue)
    result = prime &* result &+ (balance.hashValue)
    result = prime &* result &+ (hasNext.hashValue)
    return result
  }

}

extension CoinHistoryResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["historys": 1, "balance": 2, "hasNext": 3, ]
  }

  public static var structName: String { return "CoinHistoryResult" }

  public static func read(from proto: TProtocol) throws -> CoinHistoryResult {
    _ = try proto.readStructBegin()
    var historys: TList<CoinHistory>!
    var balance: Coin!
    var hasNext: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            historys = try TList<CoinHistory>.read(from: proto)
        case (2, .struct):           balance = try Coin.read(from: proto)
        case (3, .bool):            hasNext = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(historys, named: "historys")
    try proto.validateValue(balance, named: "balance")
    try proto.validateValue(hasNext, named: "hasNext")

    return CoinHistoryResult(historys: historys, balance: balance, hasNext: hasNext)
  }

}



public func ==(lhs: CoinProductItem, rhs: CoinProductItem) -> Bool {
  return
    (lhs.itemId == rhs.itemId) &&
    (lhs.coin == rhs.coin) &&
    (lhs.freeCoin == rhs.freeCoin) &&
    (lhs.currency == rhs.currency) &&
    (lhs.price == rhs.price) &&
    (lhs.displayPrice == rhs.displayPrice) &&
    (lhs.name == rhs.name) &&
    (lhs.desc == rhs.desc)
}

extension CoinProductItem : CustomStringConvertible {

  public var description : String {
    var desc = "CoinProductItem("
    desc += "itemId=\(String(describing: self.itemId)), "
    desc += "coin=\(String(describing: self.coin)), "
    desc += "freeCoin=\(String(describing: self.freeCoin)), "
    desc += "currency=\(String(describing: self.currency)), "
    desc += "price=\(String(describing: self.price)), "
    desc += "displayPrice=\(String(describing: self.displayPrice)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "desc=\(String(describing: self.desc))"
    return desc
  }

}

extension CoinProductItem : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (itemId.hashValue)
    result = prime &* result &+ (coin.hashValue)
    result = prime &* result &+ (freeCoin.hashValue)
    result = prime &* result &+ (currency.hashValue)
    result = prime &* result &+ (price.hashValue)
    result = prime &* result &+ (displayPrice.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (desc.hashValue)
    return result
  }

}

extension CoinProductItem : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["itemId": 1, "coin": 2, "freeCoin": 3, "currency": 5, "price": 6, "displayPrice": 7, "name": 8, "desc": 9, ]
  }

  public static var structName: String { return "CoinProductItem" }

  public static func read(from proto: TProtocol) throws -> CoinProductItem {
    _ = try proto.readStructBegin()
    var itemId: String!
    var coin: Int32!
    var freeCoin: Int32!
    var currency: String!
    var price: String!
    var displayPrice: String!
    var name: String!
    var desc: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           itemId = try String.read(from: proto)
        case (2, .i32):             coin = try Int32.read(from: proto)
        case (3, .i32):             freeCoin = try Int32.read(from: proto)
        case (5, .string):           currency = try String.read(from: proto)
        case (6, .string):           price = try String.read(from: proto)
        case (7, .string):           displayPrice = try String.read(from: proto)
        case (8, .string):           name = try String.read(from: proto)
        case (9, .string):           desc = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(itemId, named: "itemId")
    try proto.validateValue(coin, named: "coin")
    try proto.validateValue(freeCoin, named: "freeCoin")
    try proto.validateValue(currency, named: "currency")
    try proto.validateValue(price, named: "price")
    try proto.validateValue(displayPrice, named: "displayPrice")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(desc, named: "desc")

    return CoinProductItem(itemId: itemId, coin: coin, freeCoin: freeCoin, currency: currency, price: price, displayPrice: displayPrice, name: name, desc: desc)
  }

}



public func ==(lhs: CoinPurchaseConfirm, rhs: CoinPurchaseConfirm) -> Bool {
  return
    (lhs.orderId == rhs.orderId) &&
    (lhs.appStoreCode == rhs.appStoreCode) &&
    (lhs.receipt == rhs.receipt) &&
    (lhs.signature == rhs.signature) &&
    (lhs.seller == rhs.seller) &&
    (lhs.requestType == rhs.requestType) &&
    (lhs.ignoreReceipt == rhs.ignoreReceipt)
}

extension CoinPurchaseConfirm : CustomStringConvertible {

  public var description : String {
    var desc = "CoinPurchaseConfirm("
    desc += "orderId=\(String(describing: self.orderId)), "
    desc += "appStoreCode=\(String(describing: self.appStoreCode)), "
    desc += "receipt=\(String(describing: self.receipt)), "
    desc += "signature=\(String(describing: self.signature)), "
    desc += "seller=\(String(describing: self.seller)), "
    desc += "requestType=\(String(describing: self.requestType)), "
    desc += "ignoreReceipt=\(String(describing: self.ignoreReceipt))"
    return desc
  }

}

extension CoinPurchaseConfirm : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (orderId.hashValue)
    result = prime &* result &+ (appStoreCode.hashValue)
    result = prime &* result &+ (receipt.hashValue)
    result = prime &* result &+ (signature.hashValue)
    result = prime &* result &+ (seller.hashValue)
    result = prime &* result &+ (requestType.hashValue)
    result = prime &* result &+ (ignoreReceipt.hashValue)
    return result
  }

}

extension CoinPurchaseConfirm : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["orderId": 1, "appStoreCode": 2, "receipt": 3, "signature": 4, "seller": 5, "requestType": 6, "ignoreReceipt": 7, ]
  }

  public static var structName: String { return "CoinPurchaseConfirm" }

  public static func read(from proto: TProtocol) throws -> CoinPurchaseConfirm {
    _ = try proto.readStructBegin()
    var orderId: String!
    var appStoreCode: PaymentType!
    var receipt: String!
    var signature: String!
    var seller: String!
    var requestType: String!
    var ignoreReceipt: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           orderId = try String.read(from: proto)
        case (2, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case (3, .string):           receipt = try String.read(from: proto)
        case (4, .string):           signature = try String.read(from: proto)
        case (5, .string):           seller = try String.read(from: proto)
        case (6, .string):           requestType = try String.read(from: proto)
        case (7, .bool):            ignoreReceipt = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(orderId, named: "orderId")
    try proto.validateValue(appStoreCode, named: "appStoreCode")
    try proto.validateValue(receipt, named: "receipt")
    try proto.validateValue(signature, named: "signature")
    try proto.validateValue(seller, named: "seller")
    try proto.validateValue(requestType, named: "requestType")
    try proto.validateValue(ignoreReceipt, named: "ignoreReceipt")

    return CoinPurchaseConfirm(orderId: orderId, appStoreCode: appStoreCode, receipt: receipt, signature: signature, seller: seller, requestType: requestType, ignoreReceipt: ignoreReceipt)
  }

}



public func ==(lhs: CoinPurchaseReservation, rhs: CoinPurchaseReservation) -> Bool {
  return
    (lhs.productId == rhs.productId) &&
    (lhs.country == rhs.country) &&
    (lhs.currency == rhs.currency) &&
    (lhs.price == rhs.price) &&
    (lhs.appStoreCode == rhs.appStoreCode) &&
    (lhs.language == rhs.language) &&
    (lhs.pgCode == rhs.pgCode) &&
    (lhs.redirectUrl == rhs.redirectUrl)
}

extension CoinPurchaseReservation : CustomStringConvertible {

  public var description : String {
    var desc = "CoinPurchaseReservation("
    desc += "productId=\(String(describing: self.productId)), "
    desc += "country=\(String(describing: self.country)), "
    desc += "currency=\(String(describing: self.currency)), "
    desc += "price=\(String(describing: self.price)), "
    desc += "appStoreCode=\(String(describing: self.appStoreCode)), "
    desc += "language=\(String(describing: self.language)), "
    desc += "pgCode=\(String(describing: self.pgCode)), "
    desc += "redirectUrl=\(String(describing: self.redirectUrl))"
    return desc
  }

}

extension CoinPurchaseReservation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (productId.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (currency.hashValue)
    result = prime &* result &+ (price.hashValue)
    result = prime &* result &+ (appStoreCode.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (pgCode.hashValue)
    result = prime &* result &+ (redirectUrl.hashValue)
    return result
  }

}

extension CoinPurchaseReservation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["productId": 1, "country": 2, "currency": 3, "price": 4, "appStoreCode": 5, "language": 6, "pgCode": 7, "redirectUrl": 8, ]
  }

  public static var structName: String { return "CoinPurchaseReservation" }

  public static func read(from proto: TProtocol) throws -> CoinPurchaseReservation {
    _ = try proto.readStructBegin()
    var productId: String!
    var country: String!
    var currency: String!
    var price: String!
    var appStoreCode: PaymentType!
    var language: String!
    var pgCode: PaymentPgType!
    var redirectUrl: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           productId = try String.read(from: proto)
        case (2, .string):           country = try String.read(from: proto)
        case (3, .string):           currency = try String.read(from: proto)
        case (4, .string):           price = try String.read(from: proto)
        case (5, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case (6, .string):           language = try String.read(from: proto)
        case (7, .i32):             pgCode = try PaymentPgType.read(from: proto)
        case (8, .string):           redirectUrl = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(productId, named: "productId")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(currency, named: "currency")
    try proto.validateValue(price, named: "price")
    try proto.validateValue(appStoreCode, named: "appStoreCode")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(pgCode, named: "pgCode")
    try proto.validateValue(redirectUrl, named: "redirectUrl")

    return CoinPurchaseReservation(productId: productId, country: country, currency: currency, price: price, appStoreCode: appStoreCode, language: language, pgCode: pgCode, redirectUrl: redirectUrl)
  }

}



public func ==(lhs: CoinUseReservationItem, rhs: CoinUseReservationItem) -> Bool {
  return
    (lhs.itemId == rhs.itemId) &&
    (lhs.itemName == rhs.itemName) &&
    (lhs.amount == rhs.amount)
}

extension CoinUseReservationItem : CustomStringConvertible {

  public var description : String {
    var desc = "CoinUseReservationItem("
    desc += "itemId=\(String(describing: self.itemId)), "
    desc += "itemName=\(String(describing: self.itemName)), "
    desc += "amount=\(String(describing: self.amount))"
    return desc
  }

}

extension CoinUseReservationItem : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (itemId.hashValue)
    result = prime &* result &+ (itemName.hashValue)
    result = prime &* result &+ (amount.hashValue)
    return result
  }

}

extension CoinUseReservationItem : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["itemId": 1, "itemName": 2, "amount": 3, ]
  }

  public static var structName: String { return "CoinUseReservationItem" }

  public static func read(from proto: TProtocol) throws -> CoinUseReservationItem {
    _ = try proto.readStructBegin()
    var itemId: String!
    var itemName: String!
    var amount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           itemId = try String.read(from: proto)
        case (2, .string):           itemName = try String.read(from: proto)
        case (3, .i32):             amount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(itemId, named: "itemId")
    try proto.validateValue(itemName, named: "itemName")
    try proto.validateValue(amount, named: "amount")

    return CoinUseReservationItem(itemId: itemId, itemName: itemName, amount: amount)
  }

}



public func ==(lhs: CoinUseReservation, rhs: CoinUseReservation) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.shopOrderId == rhs.shopOrderId) &&
    (lhs.appStoreCode == rhs.appStoreCode) &&
    (lhs.items == rhs.items) &&
    (lhs.country == rhs.country)
}

extension CoinUseReservation : CustomStringConvertible {

  public var description : String {
    var desc = "CoinUseReservation("
    desc += "channelId=\(String(describing: self.channelId)), "
    desc += "shopOrderId=\(String(describing: self.shopOrderId)), "
    desc += "appStoreCode=\(String(describing: self.appStoreCode)), "
    desc += "items=\(String(describing: self.items)), "
    desc += "country=\(String(describing: self.country))"
    return desc
  }

}

extension CoinUseReservation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (shopOrderId.hashValue)
    result = prime &* result &+ (appStoreCode.hashValue)
    result = prime &* result &+ (items.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension CoinUseReservation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelId": 1, "shopOrderId": 2, "appStoreCode": 3, "items": 4, "country": 5, ]
  }

  public static var structName: String { return "CoinUseReservation" }

  public static func read(from proto: TProtocol) throws -> CoinUseReservation {
    _ = try proto.readStructBegin()
    var channelId: String!
    var shopOrderId: String!
    var appStoreCode: PaymentType!
    var items: TList<CoinUseReservationItem>!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (2, .string):           shopOrderId = try String.read(from: proto)
        case (3, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case (4, .list):            items = try TList<CoinUseReservationItem>.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(shopOrderId, named: "shopOrderId")
    try proto.validateValue(appStoreCode, named: "appStoreCode")
    try proto.validateValue(items, named: "items")
    try proto.validateValue(country, named: "country")

    return CoinUseReservation(channelId: channelId, shopOrderId: shopOrderId, appStoreCode: appStoreCode, items: items, country: country)
  }

}



public func ==(lhs: CompactContact, rhs: CompactContact) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.modifiedTime == rhs.modifiedTime) &&
    (lhs.status == rhs.status) &&
    (lhs.settings == rhs.settings) &&
    (lhs.displayNameOverridden == rhs.displayNameOverridden)
}

extension CompactContact : CustomStringConvertible {

  public var description : String {
    var desc = "CompactContact("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "modifiedTime=\(String(describing: self.modifiedTime)), "
    desc += "status=\(String(describing: self.status)), "
    desc += "settings=\(String(describing: self.settings)), "
    desc += "displayNameOverridden=\(String(describing: self.displayNameOverridden))"
    return desc
  }

}

extension CompactContact : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (modifiedTime.hashValue)
    result = prime &* result &+ (status.hashValue)
    result = prime &* result &+ (settings.hashValue)
    result = prime &* result &+ (displayNameOverridden.hashValue)
    return result
  }

}

extension CompactContact : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "createdTime": 2, "modifiedTime": 3, "status": 4, "settings": 5, "displayNameOverridden": 6, ]
  }

  public static var structName: String { return "CompactContact" }

  public static func read(from proto: TProtocol) throws -> CompactContact {
    _ = try proto.readStructBegin()
    var mid: String!
    var createdTime: Int64!
    var modifiedTime: Int64!
    var status: ContactStatus!
    var settings: Int64!
    var displayNameOverridden: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .i64):             createdTime = try Int64.read(from: proto)
        case (3, .i64):             modifiedTime = try Int64.read(from: proto)
        case (4, .i32):             status = try ContactStatus.read(from: proto)
        case (5, .i64):             settings = try Int64.read(from: proto)
        case (6, .string):           displayNameOverridden = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(modifiedTime, named: "modifiedTime")
    try proto.validateValue(status, named: "status")
    try proto.validateValue(settings, named: "settings")
    try proto.validateValue(displayNameOverridden, named: "displayNameOverridden")

    return CompactContact(mid: mid, createdTime: createdTime, modifiedTime: modifiedTime, status: status, settings: settings, displayNameOverridden: displayNameOverridden)
  }

}



public func ==(lhs: ContactModification, rhs: ContactModification) -> Bool {
  return
    (lhs.type == rhs.type) &&
    (lhs.luid == rhs.luid) &&
    (lhs.phones == rhs.phones) &&
    (lhs.emails == rhs.emails) &&
    (lhs.userids == rhs.userids)
}

extension ContactModification : CustomStringConvertible {

  public var description : String {
    var desc = "ContactModification("
    desc += "type=\(String(describing: self.type)), "
    desc += "luid=\(String(describing: self.luid)), "
    desc += "phones=\(String(describing: self.phones)), "
    desc += "emails=\(String(describing: self.emails)), "
    desc += "userids=\(String(describing: self.userids))"
    return desc
  }

}

extension ContactModification : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (luid.hashValue)
    result = prime &* result &+ (phones.hashValue)
    result = prime &* result &+ (emails.hashValue)
    result = prime &* result &+ (userids.hashValue)
    return result
  }

}

extension ContactModification : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["type": 1, "luid": 2, "phones": 11, "emails": 12, "userids": 13, ]
  }

  public static var structName: String { return "ContactModification" }

  public static func read(from proto: TProtocol) throws -> ContactModification {
    _ = try proto.readStructBegin()
    var type: ModificationType!
    var luid: String!
    var phones: TList<String>!
    var emails: TList<String>!
    var userids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             type = try ModificationType.read(from: proto)
        case (2, .string):           luid = try String.read(from: proto)
        case (11, .list):            phones = try TList<String>.read(from: proto)
        case (12, .list):            emails = try TList<String>.read(from: proto)
        case (13, .list):            userids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")
    try proto.validateValue(luid, named: "luid")
    try proto.validateValue(phones, named: "phones")
    try proto.validateValue(emails, named: "emails")
    try proto.validateValue(userids, named: "userids")

    return ContactModification(type: type, luid: luid, phones: phones, emails: emails, userids: userids)
  }

}



public func ==(lhs: ContactRegistration, rhs: ContactRegistration) -> Bool {
  return
    (lhs.contact == rhs.contact) &&
    (lhs.luid == rhs.luid) &&
    (lhs.contactType == rhs.contactType) &&
    (lhs.contactKey == rhs.contactKey)
}

extension ContactRegistration : CustomStringConvertible {

  public var description : String {
    var desc = "ContactRegistration("
    desc += "contact=\(String(describing: self.contact)), "
    desc += "luid=\(String(describing: self.luid)), "
    desc += "contactType=\(String(describing: self.contactType)), "
    desc += "contactKey=\(String(describing: self.contactKey))"
    return desc
  }

}

extension ContactRegistration : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (contact.hashValue)
    result = prime &* result &+ (luid.hashValue)
    result = prime &* result &+ (contactType.hashValue)
    result = prime &* result &+ (contactKey.hashValue)
    return result
  }

}

extension ContactRegistration : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["contact": 1, "luid": 10, "contactType": 11, "contactKey": 12, ]
  }

  public static var structName: String { return "ContactRegistration" }

  public static func read(from proto: TProtocol) throws -> ContactRegistration {
    _ = try proto.readStructBegin()
    var contact: Contact!
    var luid: String!
    var contactType: ContactType!
    var contactKey: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           contact = try Contact.read(from: proto)
        case (10, .string):           luid = try String.read(from: proto)
        case (11, .i32):             contactType = try ContactType.read(from: proto)
        case (12, .string):           contactKey = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(contact, named: "contact")
    try proto.validateValue(luid, named: "luid")
    try proto.validateValue(contactType, named: "contactType")
    try proto.validateValue(contactKey, named: "contactKey")

    return ContactRegistration(contact: contact, luid: luid, contactType: contactType, contactKey: contactKey)
  }

}



public func ==(lhs: ContactReport, rhs: ContactReport) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.exists == rhs.exists) &&
    (lhs.contact == rhs.contact)
}

extension ContactReport : CustomStringConvertible {

  public var description : String {
    var desc = "ContactReport("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "exists=\(String(describing: self.exists)), "
    desc += "contact=\(String(describing: self.contact))"
    return desc
  }

}

extension ContactReport : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (exists.hashValue)
    result = prime &* result &+ (contact.hashValue)
    return result
  }

}

extension ContactReport : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "exists": 2, "contact": 3, ]
  }

  public static var structName: String { return "ContactReport" }

  public static func read(from proto: TProtocol) throws -> ContactReport {
    _ = try proto.readStructBegin()
    var mid: String!
    var exists: Bool!
    var contact: Contact!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .bool):            exists = try Bool.read(from: proto)
        case (3, .struct):           contact = try Contact.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(exists, named: "exists")
    try proto.validateValue(contact, named: "contact")

    return ContactReport(mid: mid, exists: exists, contact: contact)
  }

}



public func ==(lhs: ContactReportResult, rhs: ContactReportResult) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.exists == rhs.exists)
}

extension ContactReportResult : CustomStringConvertible {

  public var description : String {
    var desc = "ContactReportResult("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "exists=\(String(describing: self.exists))"
    return desc
  }

}

extension ContactReportResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (exists.hashValue)
    return result
  }

}

extension ContactReportResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "exists": 2, ]
  }

  public static var structName: String { return "ContactReportResult" }

  public static func read(from proto: TProtocol) throws -> ContactReportResult {
    _ = try proto.readStructBegin()
    var mid: String!
    var exists: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .bool):            exists = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(exists, named: "exists")

    return ContactReportResult(mid: mid, exists: exists)
  }

}



public func ==(lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
  return
    (lhs.deviceName == rhs.deviceName) &&
    (lhs.systemName == rhs.systemName) &&
    (lhs.systemVersion == rhs.systemVersion) &&
    (lhs.model == rhs.model) &&
    (lhs.carrierCode == rhs.carrierCode) &&
    (lhs.carrierName == rhs.carrierName) &&
    (lhs.applicationType == rhs.applicationType)
}

extension DeviceInfo : CustomStringConvertible {

  public var description : String {
    var desc = "DeviceInfo("
    desc += "deviceName=\(String(describing: self.deviceName)), "
    desc += "systemName=\(String(describing: self.systemName)), "
    desc += "systemVersion=\(String(describing: self.systemVersion)), "
    desc += "model=\(String(describing: self.model)), "
    desc += "carrierCode=\(String(describing: self.carrierCode)), "
    desc += "carrierName=\(String(describing: self.carrierName)), "
    desc += "applicationType=\(String(describing: self.applicationType))"
    return desc
  }

}

extension DeviceInfo : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (deviceName.hashValue)
    result = prime &* result &+ (systemName.hashValue)
    result = prime &* result &+ (systemVersion.hashValue)
    result = prime &* result &+ (model.hashValue)
    result = prime &* result &+ (carrierCode.hashValue)
    result = prime &* result &+ (carrierName.hashValue)
    result = prime &* result &+ (applicationType.hashValue)
    return result
  }

}

extension DeviceInfo : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["deviceName": 1, "systemName": 2, "systemVersion": 3, "model": 4, "carrierCode": 10, "carrierName": 11, "applicationType": 20, ]
  }

  public static var structName: String { return "DeviceInfo" }

  public static func read(from proto: TProtocol) throws -> DeviceInfo {
    _ = try proto.readStructBegin()
    var deviceName: String!
    var systemName: String!
    var systemVersion: String!
    var model: String!
    var carrierCode: CarrierCode!
    var carrierName: String!
    var applicationType: ApplicationType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           deviceName = try String.read(from: proto)
        case (2, .string):           systemName = try String.read(from: proto)
        case (3, .string):           systemVersion = try String.read(from: proto)
        case (4, .string):           model = try String.read(from: proto)
        case (10, .i32):             carrierCode = try CarrierCode.read(from: proto)
        case (11, .string):           carrierName = try String.read(from: proto)
        case (20, .i32):             applicationType = try ApplicationType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(deviceName, named: "deviceName")
    try proto.validateValue(systemName, named: "systemName")
    try proto.validateValue(systemVersion, named: "systemVersion")
    try proto.validateValue(model, named: "model")
    try proto.validateValue(carrierCode, named: "carrierCode")
    try proto.validateValue(carrierName, named: "carrierName")
    try proto.validateValue(applicationType, named: "applicationType")

    return DeviceInfo(deviceName: deviceName, systemName: systemName, systemVersion: systemVersion, model: model, carrierCode: carrierCode, carrierName: carrierName, applicationType: applicationType)
  }

}



public func ==(lhs: EmailConfirmation, rhs: EmailConfirmation) -> Bool {
  return
    (lhs.usePasswordSet == rhs.usePasswordSet) &&
    (lhs.email == rhs.email) &&
    (lhs.password == rhs.password) &&
    (lhs.ignoreDuplication == rhs.ignoreDuplication)
}

extension EmailConfirmation : CustomStringConvertible {

  public var description : String {
    var desc = "EmailConfirmation("
    desc += "usePasswordSet=\(String(describing: self.usePasswordSet)), "
    desc += "email=\(String(describing: self.email)), "
    desc += "password=\(String(describing: self.password)), "
    desc += "ignoreDuplication=\(String(describing: self.ignoreDuplication))"
    return desc
  }

}

extension EmailConfirmation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (usePasswordSet.hashValue)
    result = prime &* result &+ (email.hashValue)
    result = prime &* result &+ (password.hashValue)
    result = prime &* result &+ (ignoreDuplication.hashValue)
    return result
  }

}

extension EmailConfirmation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["usePasswordSet": 1, "email": 2, "password": 3, "ignoreDuplication": 4, ]
  }

  public static var structName: String { return "EmailConfirmation" }

  public static func read(from proto: TProtocol) throws -> EmailConfirmation {
    _ = try proto.readStructBegin()
    var usePasswordSet: Bool!
    var email: String!
    var password: String!
    var ignoreDuplication: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            usePasswordSet = try Bool.read(from: proto)
        case (2, .string):           email = try String.read(from: proto)
        case (3, .string):           password = try String.read(from: proto)
        case (4, .bool):            ignoreDuplication = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(usePasswordSet, named: "usePasswordSet")
    try proto.validateValue(email, named: "email")
    try proto.validateValue(password, named: "password")
    try proto.validateValue(ignoreDuplication, named: "ignoreDuplication")

    return EmailConfirmation(usePasswordSet: usePasswordSet, email: email, password: password, ignoreDuplication: ignoreDuplication)
  }

}



public func ==(lhs: EmailConfirmationSession, rhs: EmailConfirmationSession) -> Bool {
  return
    (lhs.emailConfirmationType == rhs.emailConfirmationType) &&
    (lhs.verifier == rhs.verifier) &&
    (lhs.targetEmail == rhs.targetEmail)
}

extension EmailConfirmationSession : CustomStringConvertible {

  public var description : String {
    var desc = "EmailConfirmationSession("
    desc += "emailConfirmationType=\(String(describing: self.emailConfirmationType)), "
    desc += "verifier=\(String(describing: self.verifier)), "
    desc += "targetEmail=\(String(describing: self.targetEmail))"
    return desc
  }

}

extension EmailConfirmationSession : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (emailConfirmationType.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    result = prime &* result &+ (targetEmail.hashValue)
    return result
  }

}

extension EmailConfirmationSession : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["emailConfirmationType": 1, "verifier": 2, "targetEmail": 3, ]
  }

  public static var structName: String { return "EmailConfirmationSession" }

  public static func read(from proto: TProtocol) throws -> EmailConfirmationSession {
    _ = try proto.readStructBegin()
    var emailConfirmationType: EmailConfirmationType!
    var verifier: String!
    var targetEmail: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             emailConfirmationType = try EmailConfirmationType.read(from: proto)
        case (2, .string):           verifier = try String.read(from: proto)
        case (3, .string):           targetEmail = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(emailConfirmationType, named: "emailConfirmationType")
    try proto.validateValue(verifier, named: "verifier")
    try proto.validateValue(targetEmail, named: "targetEmail")

    return EmailConfirmationSession(emailConfirmationType: emailConfirmationType, verifier: verifier, targetEmail: targetEmail)
  }

}



public func ==(lhs: FriendChannelMatrix, rhs: FriendChannelMatrix) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.representMid == rhs.representMid) &&
    (lhs.count == rhs.count)
}

extension FriendChannelMatrix : CustomStringConvertible {

  public var description : String {
    var desc = "FriendChannelMatrix("
    desc += "channelId=\(String(describing: self.channelId)), "
    desc += "representMid=\(String(describing: self.representMid)), "
    desc += "count=\(String(describing: self.count))"
    return desc
  }

}

extension FriendChannelMatrix : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (representMid.hashValue)
    result = prime &* result &+ (count.hashValue)
    return result
  }

}

extension FriendChannelMatrix : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["channelId": 1, "representMid": 2, "count": 3, ]
  }

  public static var structName: String { return "FriendChannelMatrix" }

  public static func read(from proto: TProtocol) throws -> FriendChannelMatrix {
    _ = try proto.readStructBegin()
    var channelId: String!
    var representMid: String!
    var count: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (2, .string):           representMid = try String.read(from: proto)
        case (3, .i32):             count = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(representMid, named: "representMid")
    try proto.validateValue(count, named: "count")

    return FriendChannelMatrix(channelId: channelId, representMid: representMid, count: count)
  }

}



public func ==(lhs: FriendChannelMatricesResponse, rhs: FriendChannelMatricesResponse) -> Bool {
  return
    (lhs.expires == rhs.expires) &&
    (lhs.matrices == rhs.matrices)
}

extension FriendChannelMatricesResponse : CustomStringConvertible {

  public var description : String {
    var desc = "FriendChannelMatricesResponse("
    desc += "expires=\(String(describing: self.expires)), "
    desc += "matrices=\(String(describing: self.matrices))"
    return desc
  }

}

extension FriendChannelMatricesResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (expires.hashValue)
    result = prime &* result &+ (matrices.hashValue)
    return result
  }

}

extension FriendChannelMatricesResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["expires": 1, "matrices": 2, ]
  }

  public static var structName: String { return "FriendChannelMatricesResponse" }

  public static func read(from proto: TProtocol) throws -> FriendChannelMatricesResponse {
    _ = try proto.readStructBegin()
    var expires: Int64!
    var matrices: TList<FriendChannelMatrix>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             expires = try Int64.read(from: proto)
        case (2, .list):            matrices = try TList<FriendChannelMatrix>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(expires, named: "expires")
    try proto.validateValue(matrices, named: "matrices")

    return FriendChannelMatricesResponse(expires: expires, matrices: matrices)
  }

}



public func ==(lhs: Geolocation, rhs: Geolocation) -> Bool {
  return
    (lhs.longitude == rhs.longitude) &&
    (lhs.latitude == rhs.latitude)
}

extension Geolocation : CustomStringConvertible {

  public var description : String {
    var desc = "Geolocation("
    desc += "longitude=\(String(describing: self.longitude)), "
    desc += "latitude=\(String(describing: self.latitude))"
    return desc
  }

}

extension Geolocation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (longitude.hashValue)
    result = prime &* result &+ (latitude.hashValue)
    return result
  }

}

extension Geolocation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["longitude": 1, "latitude": 2, ]
  }

  public static var structName: String { return "Geolocation" }

  public static func read(from proto: TProtocol) throws -> Geolocation {
    _ = try proto.readStructBegin()
    var longitude: Double!
    var latitude: Double!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .double):           longitude = try Double.read(from: proto)
        case (2, .double):           latitude = try Double.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(longitude, named: "longitude")
    try proto.validateValue(latitude, named: "latitude")

    return Geolocation(longitude: longitude, latitude: latitude)
  }

}



public func ==(lhs: NotificationTarget, rhs: NotificationTarget) -> Bool {
  return
    (lhs.applicationType == rhs.applicationType) &&
    (lhs.applicationVersion == rhs.applicationVersion) &&
    (lhs.region == rhs.region)
}

extension NotificationTarget : CustomStringConvertible {

  public var description : String {
    var desc = "NotificationTarget("
    desc += "applicationType=\(String(describing: self.applicationType)), "
    desc += "applicationVersion=\(String(describing: self.applicationVersion)), "
    desc += "region=\(String(describing: self.region))"
    return desc
  }

}

extension NotificationTarget : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (applicationType.hashValue)
    result = prime &* result &+ (applicationVersion.hashValue)
    result = prime &* result &+ (region.hashValue)
    return result
  }

}

extension NotificationTarget : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["applicationType": 1, "applicationVersion": 2, "region": 3, ]
  }

  public static var structName: String { return "NotificationTarget" }

  public static func read(from proto: TProtocol) throws -> NotificationTarget {
    _ = try proto.readStructBegin()
    var applicationType: String!
    var applicationVersion: String!
    var region: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           applicationType = try String.read(from: proto)
        case (2, .string):           applicationVersion = try String.read(from: proto)
        case (3, .string):           region = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(applicationType, named: "applicationType")
    try proto.validateValue(applicationVersion, named: "applicationVersion")
    try proto.validateValue(region, named: "region")

    return NotificationTarget(applicationType: applicationType, applicationVersion: applicationVersion, region: region)
  }

}



public func ==(lhs: GlobalEvent, rhs: GlobalEvent) -> Bool {
  return
    (lhs.key == rhs.key) &&
    (lhs.targets == rhs.targets) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.data == rhs.data) &&
    (lhs.maxDelay == rhs.maxDelay)
}

extension GlobalEvent : CustomStringConvertible {

  public var description : String {
    var desc = "GlobalEvent("
    desc += "key=\(String(describing: self.key)), "
    desc += "targets=\(String(describing: self.targets)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "data=\(String(describing: self.data)), "
    desc += "maxDelay=\(String(describing: self.maxDelay))"
    return desc
  }

}

extension GlobalEvent : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (key.hashValue)
    result = prime &* result &+ (targets.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (data.hashValue)
    result = prime &* result &+ (maxDelay.hashValue)
    return result
  }

}

extension GlobalEvent : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["key": 1, "targets": 2, "createdTime": 3, "data": 4, "maxDelay": 5, ]
  }

  public static var structName: String { return "GlobalEvent" }

  public static func read(from proto: TProtocol) throws -> GlobalEvent {
    _ = try proto.readStructBegin()
    var key: String!
    var targets: TList<NotificationTarget>!
    var createdTime: Int64!
    var data: Int64!
    var maxDelay: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           key = try String.read(from: proto)
        case (2, .list):            targets = try TList<NotificationTarget>.read(from: proto)
        case (3, .i64):             createdTime = try Int64.read(from: proto)
        case (4, .i64):             data = try Int64.read(from: proto)
        case (5, .i32):             maxDelay = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(key, named: "key")
    try proto.validateValue(targets, named: "targets")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(data, named: "data")
    try proto.validateValue(maxDelay, named: "maxDelay")

    return GlobalEvent(key: key, targets: targets, createdTime: createdTime, data: data, maxDelay: maxDelay)
  }

}



public func ==(lhs: Group, rhs: Group) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.name == rhs.name) &&
    (lhs.pictureStatus == rhs.pictureStatus) &&
    (lhs.members == rhs.members) &&
    (lhs.creator == rhs.creator) &&
    (lhs.invitee == rhs.invitee) &&
    (lhs.notificationDisabled == rhs.notificationDisabled)
}

extension Group : CustomStringConvertible {

  public var description : String {
    var desc = "Group("
    desc += "id=\(String(describing: self.id)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "pictureStatus=\(String(describing: self.pictureStatus)), "
    desc += "members=\(String(describing: self.members)), "
    desc += "creator=\(String(describing: self.creator)), "
    desc += "invitee=\(String(describing: self.invitee)), "
    desc += "notificationDisabled=\(String(describing: self.notificationDisabled))"
    return desc
  }

}

extension Group : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (pictureStatus.hashValue)
    result = prime &* result &+ (members.hashValue)
    result = prime &* result &+ (creator.hashValue)
    result = prime &* result &+ (invitee.hashValue)
    result = prime &* result &+ (notificationDisabled.hashValue)
    return result
  }

}

extension Group : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "createdTime": 2, "name": 10, "pictureStatus": 11, "members": 20, "creator": 21, "invitee": 22, "notificationDisabled": 31, ]
  }

  public static var structName: String { return "Group" }

  public static func read(from proto: TProtocol) throws -> Group {
    _ = try proto.readStructBegin()
    var id: String!
    var createdTime: Int64!
    var name: String!
    var pictureStatus: String!
    var members: TList<Contact>!
    var creator: Contact!
    var invitee: TList<Contact>!
    var notificationDisabled: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .i64):             createdTime = try Int64.read(from: proto)
        case (10, .string):           name = try String.read(from: proto)
        case (11, .string):           pictureStatus = try String.read(from: proto)
        case (20, .list):            members = try TList<Contact>.read(from: proto)
        case (21, .struct):           creator = try Contact.read(from: proto)
        case (22, .list):            invitee = try TList<Contact>.read(from: proto)
        case (31, .bool):            notificationDisabled = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(pictureStatus, named: "pictureStatus")
    try proto.validateValue(members, named: "members")
    try proto.validateValue(creator, named: "creator")
    try proto.validateValue(invitee, named: "invitee")
    try proto.validateValue(notificationDisabled, named: "notificationDisabled")

    return Group(id: id, createdTime: createdTime, name: name, pictureStatus: pictureStatus, members: members, creator: creator, invitee: invitee, notificationDisabled: notificationDisabled)
  }

}



public func ==(lhs: IdentityCredential, rhs: IdentityCredential) -> Bool {
  return
    (lhs.provider == rhs.provider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.password == rhs.password)
}

extension IdentityCredential : CustomStringConvertible {

  public var description : String {
    var desc = "IdentityCredential("
    desc += "provider=\(String(describing: self.provider)), "
    desc += "identifier=\(String(describing: self.identifier)), "
    desc += "password=\(String(describing: self.password))"
    return desc
  }

}

extension IdentityCredential : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (password.hashValue)
    return result
  }

}

extension IdentityCredential : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["provider": 1, "identifier": 2, "password": 3, ]
  }

  public static var structName: String { return "IdentityCredential" }

  public static func read(from proto: TProtocol) throws -> IdentityCredential {
    _ = try proto.readStructBegin()
    var provider: IdentityProvider!
    var identifier: String!
    var password: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             provider = try IdentityProvider.read(from: proto)
        case (2, .string):           identifier = try String.read(from: proto)
        case (3, .string):           password = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(password, named: "password")

    return IdentityCredential(provider: provider, identifier: identifier, password: password)
  }

}



public func ==(lhs: LastReadMessageId, rhs: LastReadMessageId) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.lastReadMessageId == rhs.lastReadMessageId)
}

extension LastReadMessageId : CustomStringConvertible {

  public var description : String {
    var desc = "LastReadMessageId("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "lastReadMessageId=\(String(describing: self.lastReadMessageId))"
    return desc
  }

}

extension LastReadMessageId : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (lastReadMessageId.hashValue)
    return result
  }

}

extension LastReadMessageId : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "lastReadMessageId": 2, ]
  }

  public static var structName: String { return "LastReadMessageId" }

  public static func read(from proto: TProtocol) throws -> LastReadMessageId {
    _ = try proto.readStructBegin()
    var mid: String!
    var lastReadMessageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .string):           lastReadMessageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(lastReadMessageId, named: "lastReadMessageId")

    return LastReadMessageId(mid: mid, lastReadMessageId: lastReadMessageId)
  }

}



public func ==(lhs: LastReadMessageIds, rhs: LastReadMessageIds) -> Bool {
  return
    (lhs.chatId == rhs.chatId) &&
    (lhs.lastReadMessageIds == rhs.lastReadMessageIds)
}

extension LastReadMessageIds : CustomStringConvertible {

  public var description : String {
    var desc = "LastReadMessageIds("
    desc += "chatId=\(String(describing: self.chatId)), "
    desc += "lastReadMessageIds=\(String(describing: self.lastReadMessageIds))"
    return desc
  }

}

extension LastReadMessageIds : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (chatId.hashValue)
    result = prime &* result &+ (lastReadMessageIds.hashValue)
    return result
  }

}

extension LastReadMessageIds : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["chatId": 1, "lastReadMessageIds": 2, ]
  }

  public static var structName: String { return "LastReadMessageIds" }

  public static func read(from proto: TProtocol) throws -> LastReadMessageIds {
    _ = try proto.readStructBegin()
    var chatId: String!
    var lastReadMessageIds: TList<LastReadMessageId>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           chatId = try String.read(from: proto)
        case (2, .list):            lastReadMessageIds = try TList<LastReadMessageId>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(chatId, named: "chatId")
    try proto.validateValue(lastReadMessageIds, named: "lastReadMessageIds")

    return LastReadMessageIds(chatId: chatId, lastReadMessageIds: lastReadMessageIds)
  }

}



public func ==(lhs: LoginResult, rhs: LoginResult) -> Bool {
  return
    (lhs.authToken == rhs.authToken) &&
    (lhs.certificate == rhs.certificate) &&
    (lhs.verifier == rhs.verifier) &&
    (lhs.pinCode == rhs.pinCode) &&
    (lhs.type == rhs.type)
}

extension LoginResult : CustomStringConvertible {

  public var description : String {
    var desc = "LoginResult("
    desc += "authToken=\(String(describing: self.authToken)), "
    desc += "certificate=\(String(describing: self.certificate)), "
    desc += "verifier=\(String(describing: self.verifier)), "
    desc += "pinCode=\(String(describing: self.pinCode)), "
    desc += "type=\(String(describing: self.type))"
    return desc
  }

}

extension LoginResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authToken.hashValue)
    result = prime &* result &+ (certificate.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    result = prime &* result &+ (pinCode.hashValue)
    result = prime &* result &+ (type.hashValue)
    return result
  }

}

extension LoginResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authToken": 1, "certificate": 2, "verifier": 3, "pinCode": 4, "type": 5, ]
  }

  public static var structName: String { return "LoginResult" }

  public static func read(from proto: TProtocol) throws -> LoginResult {
    _ = try proto.readStructBegin()
    var authToken: String!
    var certificate: String!
    var verifier: String!
    var pinCode: String!
    var type: LoginResultType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           authToken = try String.read(from: proto)
        case (2, .string):           certificate = try String.read(from: proto)
        case (3, .string):           verifier = try String.read(from: proto)
        case (4, .string):           pinCode = try String.read(from: proto)
        case (5, .i32):             type = try LoginResultType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authToken, named: "authToken")
    try proto.validateValue(certificate, named: "certificate")
    try proto.validateValue(verifier, named: "verifier")
    try proto.validateValue(pinCode, named: "pinCode")
    try proto.validateValue(type, named: "type")

    return LoginResult(authToken: authToken, certificate: certificate, verifier: verifier, pinCode: pinCode, type: type)
  }

}



public func ==(lhs: LoginSession, rhs: LoginSession) -> Bool {
  return
    (lhs.tokenKey == rhs.tokenKey) &&
    (lhs.expirationTime == rhs.expirationTime) &&
    (lhs.applicationType == rhs.applicationType) &&
    (lhs.systemName == rhs.systemName) &&
    (lhs.accessLocation == rhs.accessLocation)
}

extension LoginSession : CustomStringConvertible {

  public var description : String {
    var desc = "LoginSession("
    desc += "tokenKey=\(String(describing: self.tokenKey)), "
    desc += "expirationTime=\(String(describing: self.expirationTime)), "
    desc += "applicationType=\(String(describing: self.applicationType)), "
    desc += "systemName=\(String(describing: self.systemName)), "
    desc += "accessLocation=\(String(describing: self.accessLocation))"
    return desc
  }

}

extension LoginSession : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (tokenKey.hashValue)
    result = prime &* result &+ (expirationTime.hashValue)
    result = prime &* result &+ (applicationType.hashValue)
    result = prime &* result &+ (systemName.hashValue)
    result = prime &* result &+ (accessLocation.hashValue)
    return result
  }

}

extension LoginSession : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["tokenKey": 1, "expirationTime": 3, "applicationType": 11, "systemName": 12, "accessLocation": 22, ]
  }

  public static var structName: String { return "LoginSession" }

  public static func read(from proto: TProtocol) throws -> LoginSession {
    _ = try proto.readStructBegin()
    var tokenKey: String!
    var expirationTime: Int64!
    var applicationType: ApplicationType!
    var systemName: String!
    var accessLocation: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           tokenKey = try String.read(from: proto)
        case (3, .i64):             expirationTime = try Int64.read(from: proto)
        case (11, .i32):             applicationType = try ApplicationType.read(from: proto)
        case (12, .string):           systemName = try String.read(from: proto)
        case (22, .string):           accessLocation = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(tokenKey, named: "tokenKey")
    try proto.validateValue(expirationTime, named: "expirationTime")
    try proto.validateValue(applicationType, named: "applicationType")
    try proto.validateValue(systemName, named: "systemName")
    try proto.validateValue(accessLocation, named: "accessLocation")

    return LoginSession(tokenKey: tokenKey, expirationTime: expirationTime, applicationType: applicationType, systemName: systemName, accessLocation: accessLocation)
  }

}



public func ==(lhs: Message, rhs: Message) -> Bool {
  return
    (lhs.from_ == rhs.from_) &&
    (lhs.to == rhs.to) &&
    (lhs.toType == rhs.toType) &&
    (lhs.id == rhs.id) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.deliveredTime == rhs.deliveredTime) &&
    (lhs.text == rhs.text) &&
    (lhs.location == rhs.location) &&
    (lhs.hasContent == rhs.hasContent) &&
    (lhs.contentType == rhs.contentType) &&
    (lhs.contentPreview == rhs.contentPreview) &&
    (lhs.contentMetadata == rhs.contentMetadata)
}

extension Message : CustomStringConvertible {

  public var description : String {
    var desc = "Message("
    desc += "from_=\(String(describing: self.from_)), "
    desc += "to=\(String(describing: self.to)), "
    desc += "toType=\(String(describing: self.toType)), "
    desc += "id=\(String(describing: self.id)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "deliveredTime=\(String(describing: self.deliveredTime)), "
    desc += "text=\(String(describing: self.text)), "
    desc += "location=\(String(describing: self.location)), "
    desc += "hasContent=\(String(describing: self.hasContent)), "
    desc += "contentType=\(String(describing: self.contentType)), "
    desc += "contentPreview=\(String(describing: self.contentPreview)), "
    desc += "contentMetadata=\(String(describing: self.contentMetadata))"
    return desc
  }

}

extension Message : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (from_.hashValue)
    result = prime &* result &+ (to.hashValue)
    result = prime &* result &+ (toType.hashValue)
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (deliveredTime.hashValue)
    result = prime &* result &+ (text.hashValue)
    result = prime &* result &+ (location.hashValue)
    result = prime &* result &+ (hasContent.hashValue)
    result = prime &* result &+ (contentType.hashValue)
    result = prime &* result &+ (contentPreview.hashValue)
    result = prime &* result &+ (contentMetadata.hashValue)
    return result
  }

}

extension Message : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["from_": 1, "to": 2, "toType": 3, "id": 4, "createdTime": 5, "deliveredTime": 6, "text": 10, "location": 11, "hasContent": 14, "contentType": 15, "contentPreview": 17, "contentMetadata": 18, ]
  }

  public static var structName: String { return "Message" }

  public static func read(from proto: TProtocol) throws -> Message {
    _ = try proto.readStructBegin()
    var from_: String!
    var to: String!
    var toType: MIDType!
    var id: String!
    var createdTime: Int64!
    var deliveredTime: Int64!
    var text: String!
    var location: Location!
    var hasContent: Bool!
    var contentType: ContentType!
    var contentPreview: Data!
    var contentMetadata: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           from_ = try String.read(from: proto)
        case (2, .string):           to = try String.read(from: proto)
        case (3, .i32):             toType = try MIDType.read(from: proto)
        case (4, .string):           id = try String.read(from: proto)
        case (5, .i64):             createdTime = try Int64.read(from: proto)
        case (6, .i64):             deliveredTime = try Int64.read(from: proto)
        case (10, .string):           text = try String.read(from: proto)
        case (11, .struct):           location = try Location.read(from: proto)
        case (14, .bool):            hasContent = try Bool.read(from: proto)
        case (15, .i32):             contentType = try ContentType.read(from: proto)
        case (17, .string):           contentPreview = try Data.read(from: proto)
        case (18, .map):             contentMetadata = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(from_, named: "from_")
    try proto.validateValue(to, named: "to")
    try proto.validateValue(toType, named: "toType")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(deliveredTime, named: "deliveredTime")
    try proto.validateValue(text, named: "text")
    try proto.validateValue(location, named: "location")
    try proto.validateValue(hasContent, named: "hasContent")
    try proto.validateValue(contentType, named: "contentType")
    try proto.validateValue(contentPreview, named: "contentPreview")
    try proto.validateValue(contentMetadata, named: "contentMetadata")

    return Message(from_: from_, to: to, toType: toType, id: id, createdTime: createdTime, deliveredTime: deliveredTime, text: text, location: location, hasContent: hasContent, contentType: contentType, contentPreview: contentPreview, contentMetadata: contentMetadata)
  }

}



public func ==(lhs: MessageOperation, rhs: MessageOperation) -> Bool {
  return
    (lhs.revision == rhs.revision) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.type == rhs.type) &&
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.status == rhs.status) &&
    (lhs.param1 == rhs.param1) &&
    (lhs.param2 == rhs.param2) &&
    (lhs.param3 == rhs.param3) &&
    (lhs.message == rhs.message)
}

extension MessageOperation : CustomStringConvertible {

  public var description : String {
    var desc = "MessageOperation("
    desc += "revision=\(String(describing: self.revision)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "type=\(String(describing: self.type)), "
    desc += "reqSeq=\(String(describing: self.reqSeq)), "
    desc += "status=\(String(describing: self.status)), "
    desc += "param1=\(String(describing: self.param1)), "
    desc += "param2=\(String(describing: self.param2)), "
    desc += "param3=\(String(describing: self.param3)), "
    desc += "message=\(String(describing: self.message))"
    return desc
  }

}

extension MessageOperation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (revision.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (status.hashValue)
    result = prime &* result &+ (param1.hashValue)
    result = prime &* result &+ (param2.hashValue)
    result = prime &* result &+ (param3.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension MessageOperation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["revision": 1, "createdTime": 2, "type": 3, "reqSeq": 4, "status": 5, "param1": 10, "param2": 11, "param3": 12, "message": 20, ]
  }

  public static var structName: String { return "MessageOperation" }

  public static func read(from proto: TProtocol) throws -> MessageOperation {
    _ = try proto.readStructBegin()
    var revision: Int64!
    var createdTime: Int64!
    var type: MessageOperationType!
    var reqSeq: Int32!
    var status: OpStatus!
    var param1: String!
    var param2: String!
    var param3: String!
    var message: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             revision = try Int64.read(from: proto)
        case (2, .i64):             createdTime = try Int64.read(from: proto)
        case (3, .i32):             type = try MessageOperationType.read(from: proto)
        case (4, .i32):             reqSeq = try Int32.read(from: proto)
        case (5, .i32):             status = try OpStatus.read(from: proto)
        case (10, .string):           param1 = try String.read(from: proto)
        case (11, .string):           param2 = try String.read(from: proto)
        case (12, .string):           param3 = try String.read(from: proto)
        case (20, .struct):           message = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(revision, named: "revision")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(type, named: "type")
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(status, named: "status")
    try proto.validateValue(param1, named: "param1")
    try proto.validateValue(param2, named: "param2")
    try proto.validateValue(param3, named: "param3")
    try proto.validateValue(message, named: "message")

    return MessageOperation(revision: revision, createdTime: createdTime, type: type, reqSeq: reqSeq, status: status, param1: param1, param2: param2, param3: param3, message: message)
  }

}



public func ==(lhs: MessageOperations, rhs: MessageOperations) -> Bool {
  return
    (lhs.operations == rhs.operations) &&
    (lhs.endFlag == rhs.endFlag)
}

extension MessageOperations : CustomStringConvertible {

  public var description : String {
    var desc = "MessageOperations("
    desc += "operations=\(String(describing: self.operations)), "
    desc += "endFlag=\(String(describing: self.endFlag))"
    return desc
  }

}

extension MessageOperations : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (operations.hashValue)
    result = prime &* result &+ (endFlag.hashValue)
    return result
  }

}

extension MessageOperations : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["operations": 1, "endFlag": 2, ]
  }

  public static var structName: String { return "MessageOperations" }

  public static func read(from proto: TProtocol) throws -> MessageOperations {
    _ = try proto.readStructBegin()
    var operations: TList<MessageOperation>!
    var endFlag: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            operations = try TList<MessageOperation>.read(from: proto)
        case (2, .bool):            endFlag = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(operations, named: "operations")
    try proto.validateValue(endFlag, named: "endFlag")

    return MessageOperations(operations: operations, endFlag: endFlag)
  }

}



public func ==(lhs: MetaProfile, rhs: MetaProfile) -> Bool {
  return
    (lhs.createTime == rhs.createTime) &&
    (lhs.regionCode == rhs.regionCode) &&
    (lhs.identities == rhs.identities)
}

extension MetaProfile : CustomStringConvertible {

  public var description : String {
    var desc = "MetaProfile("
    desc += "createTime=\(String(describing: self.createTime)), "
    desc += "regionCode=\(String(describing: self.regionCode)), "
    desc += "identities=\(String(describing: self.identities))"
    return desc
  }

}

extension MetaProfile : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (createTime.hashValue)
    result = prime &* result &+ (regionCode.hashValue)
    result = prime &* result &+ (identities.hashValue)
    return result
  }

}

extension MetaProfile : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["createTime": 1, "regionCode": 2, "identities": 3, ]
  }

  public static var structName: String { return "MetaProfile" }

  public static func read(from proto: TProtocol) throws -> MetaProfile {
    _ = try proto.readStructBegin()
    var createTime: Int64!
    var regionCode: String!
    var identities: TMap<RegistrationType, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             createTime = try Int64.read(from: proto)
        case (2, .string):           regionCode = try String.read(from: proto)
        case (3, .map):             identities = try TMap<RegistrationType, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(createTime, named: "createTime")
    try proto.validateValue(regionCode, named: "regionCode")
    try proto.validateValue(identities, named: "identities")

    return MetaProfile(createTime: createTime, regionCode: regionCode, identities: identities)
  }

}



public func ==(lhs: NotificationItem, rhs: NotificationItem) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.from_ == rhs.from_) &&
    (lhs.to == rhs.to) &&
    (lhs.fromChannel == rhs.fromChannel) &&
    (lhs.toChannel == rhs.toChannel) &&
    (lhs.revision == rhs.revision) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.content == rhs.content)
}

extension NotificationItem : CustomStringConvertible {

  public var description : String {
    var desc = "NotificationItem("
    desc += "id=\(String(describing: self.id)), "
    desc += "from_=\(String(describing: self.from_)), "
    desc += "to=\(String(describing: self.to)), "
    desc += "fromChannel=\(String(describing: self.fromChannel)), "
    desc += "toChannel=\(String(describing: self.toChannel)), "
    desc += "revision=\(String(describing: self.revision)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "content=\(String(describing: self.content))"
    return desc
  }

}

extension NotificationItem : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (from_.hashValue)
    result = prime &* result &+ (to.hashValue)
    result = prime &* result &+ (fromChannel.hashValue)
    result = prime &* result &+ (toChannel.hashValue)
    result = prime &* result &+ (revision.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (content.hashValue)
    return result
  }

}

extension NotificationItem : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "from_": 2, "to": 3, "fromChannel": 4, "toChannel": 5, "revision": 7, "createdTime": 8, "content": 9, ]
  }

  public static var structName: String { return "NotificationItem" }

  public static func read(from proto: TProtocol) throws -> NotificationItem {
    _ = try proto.readStructBegin()
    var id: String!
    var from_: String!
    var to: String!
    var fromChannel: String!
    var toChannel: String!
    var revision: Int64!
    var createdTime: Int64!
    var content: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           from_ = try String.read(from: proto)
        case (3, .string):           to = try String.read(from: proto)
        case (4, .string):           fromChannel = try String.read(from: proto)
        case (5, .string):           toChannel = try String.read(from: proto)
        case (7, .i64):             revision = try Int64.read(from: proto)
        case (8, .i64):             createdTime = try Int64.read(from: proto)
        case (9, .map):             content = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(from_, named: "from_")
    try proto.validateValue(to, named: "to")
    try proto.validateValue(fromChannel, named: "fromChannel")
    try proto.validateValue(toChannel, named: "toChannel")
    try proto.validateValue(revision, named: "revision")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(content, named: "content")

    return NotificationItem(id: id, from_: from_, to: to, fromChannel: fromChannel, toChannel: toChannel, revision: revision, createdTime: createdTime, content: content)
  }

}



public func ==(lhs: NotificationFetchResult, rhs: NotificationFetchResult) -> Bool {
  return
    (lhs.fetchMode == rhs.fetchMode) &&
    (lhs.itemList == rhs.itemList)
}

extension NotificationFetchResult : CustomStringConvertible {

  public var description : String {
    var desc = "NotificationFetchResult("
    desc += "fetchMode=\(String(describing: self.fetchMode)), "
    desc += "itemList=\(String(describing: self.itemList))"
    return desc
  }

}

extension NotificationFetchResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (fetchMode.hashValue)
    result = prime &* result &+ (itemList.hashValue)
    return result
  }

}

extension NotificationFetchResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["fetchMode": 1, "itemList": 2, ]
  }

  public static var structName: String { return "NotificationFetchResult" }

  public static func read(from proto: TProtocol) throws -> NotificationFetchResult {
    _ = try proto.readStructBegin()
    var fetchMode: NotificationItemFetchMode!
    var itemList: TList<NotificationItem>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             fetchMode = try NotificationItemFetchMode.read(from: proto)
        case (2, .list):            itemList = try TList<NotificationItem>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(fetchMode, named: "fetchMode")
    try proto.validateValue(itemList, named: "itemList")

    return NotificationFetchResult(fetchMode: fetchMode, itemList: itemList)
  }

}



public func ==(lhs: Operation, rhs: Operation) -> Bool {
  return
    (lhs.revision == rhs.revision) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.type == rhs.type) &&
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.checksum == rhs.checksum) &&
    (lhs.status == rhs.status) &&
    (lhs.param1 == rhs.param1) &&
    (lhs.param2 == rhs.param2) &&
    (lhs.param3 == rhs.param3) &&
    (lhs.message == rhs.message)
}

extension Operation : CustomStringConvertible {

  public var description : String {
    var desc = "Operation("
    desc += "revision=\(String(describing: self.revision)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "type=\(String(describing: self.type)), "
    desc += "reqSeq=\(String(describing: self.reqSeq)), "
    desc += "checksum=\(String(describing: self.checksum)), "
    desc += "status=\(String(describing: self.status)), "
    desc += "param1=\(String(describing: self.param1)), "
    desc += "param2=\(String(describing: self.param2)), "
    desc += "param3=\(String(describing: self.param3)), "
    desc += "message=\(String(describing: self.message))"
    return desc
  }

}

extension Operation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (revision.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (checksum.hashValue)
    result = prime &* result &+ (status.hashValue)
    result = prime &* result &+ (param1.hashValue)
    result = prime &* result &+ (param2.hashValue)
    result = prime &* result &+ (param3.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension Operation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["revision": 1, "createdTime": 2, "type": 3, "reqSeq": 4, "checksum": 5, "status": 7, "param1": 10, "param2": 11, "param3": 12, "message": 20, ]
  }

  public static var structName: String { return "Operation" }

  public static func read(from proto: TProtocol) throws -> Operation {
    _ = try proto.readStructBegin()
    var revision: Int64!
    var createdTime: Int64!
    var type: OpType!
    var reqSeq: Int32!
    var checksum: String!
    var status: OpStatus!
    var param1: String!
    var param2: String!
    var param3: String!
    var message: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             revision = try Int64.read(from: proto)
        case (2, .i64):             createdTime = try Int64.read(from: proto)
        case (3, .i32):             type = try OpType.read(from: proto)
        case (4, .i32):             reqSeq = try Int32.read(from: proto)
        case (5, .string):           checksum = try String.read(from: proto)
        case (7, .i32):             status = try OpStatus.read(from: proto)
        case (10, .string):           param1 = try String.read(from: proto)
        case (11, .string):           param2 = try String.read(from: proto)
        case (12, .string):           param3 = try String.read(from: proto)
        case (20, .struct):           message = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(revision, named: "revision")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(type, named: "type")
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(checksum, named: "checksum")
    try proto.validateValue(status, named: "status")
    try proto.validateValue(param1, named: "param1")
    try proto.validateValue(param2, named: "param2")
    try proto.validateValue(param3, named: "param3")
    try proto.validateValue(message, named: "message")

    return Operation(revision: revision, createdTime: createdTime, type: type, reqSeq: reqSeq, checksum: checksum, status: status, param1: param1, param2: param2, param3: param3, message: message)
  }

}



public func ==(lhs: PaymentReservation, rhs: PaymentReservation) -> Bool {
  return
    (lhs.receiverMid == rhs.receiverMid) &&
    (lhs.productId == rhs.productId) &&
    (lhs.language == rhs.language) &&
    (lhs.location == rhs.location) &&
    (lhs.currency == rhs.currency) &&
    (lhs.price == rhs.price) &&
    (lhs.appStoreCode == rhs.appStoreCode) &&
    (lhs.messageText == rhs.messageText) &&
    (lhs.messageTemplate == rhs.messageTemplate) &&
    (lhs.packageId == rhs.packageId)
}

extension PaymentReservation : CustomStringConvertible {

  public var description : String {
    var desc = "PaymentReservation("
    desc += "receiverMid=\(String(describing: self.receiverMid)), "
    desc += "productId=\(String(describing: self.productId)), "
    desc += "language=\(String(describing: self.language)), "
    desc += "location=\(String(describing: self.location)), "
    desc += "currency=\(String(describing: self.currency)), "
    desc += "price=\(String(describing: self.price)), "
    desc += "appStoreCode=\(String(describing: self.appStoreCode)), "
    desc += "messageText=\(String(describing: self.messageText)), "
    desc += "messageTemplate=\(String(describing: self.messageTemplate)), "
    desc += "packageId=\(String(describing: self.packageId))"
    return desc
  }

}

extension PaymentReservation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (receiverMid.hashValue)
    result = prime &* result &+ (productId.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (location.hashValue)
    result = prime &* result &+ (currency.hashValue)
    result = prime &* result &+ (price.hashValue)
    result = prime &* result &+ (appStoreCode.hashValue)
    result = prime &* result &+ (messageText.hashValue)
    result = prime &* result &+ (messageTemplate.hashValue)
    result = prime &* result &+ (packageId.hashValue)
    return result
  }

}

extension PaymentReservation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["receiverMid": 1, "productId": 2, "language": 3, "location": 4, "currency": 5, "price": 6, "appStoreCode": 7, "messageText": 8, "messageTemplate": 9, "packageId": 10, ]
  }

  public static var structName: String { return "PaymentReservation" }

  public static func read(from proto: TProtocol) throws -> PaymentReservation {
    _ = try proto.readStructBegin()
    var receiverMid: String!
    var productId: String!
    var language: String!
    var location: String!
    var currency: String!
    var price: String!
    var appStoreCode: PaymentType!
    var messageText: String!
    var messageTemplate: Int32!
    var packageId: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           receiverMid = try String.read(from: proto)
        case (2, .string):           productId = try String.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case (4, .string):           location = try String.read(from: proto)
        case (5, .string):           currency = try String.read(from: proto)
        case (6, .string):           price = try String.read(from: proto)
        case (7, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case (8, .string):           messageText = try String.read(from: proto)
        case (9, .i32):             messageTemplate = try Int32.read(from: proto)
        case (10, .i64):             packageId = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(receiverMid, named: "receiverMid")
    try proto.validateValue(productId, named: "productId")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(location, named: "location")
    try proto.validateValue(currency, named: "currency")
    try proto.validateValue(price, named: "price")
    try proto.validateValue(appStoreCode, named: "appStoreCode")
    try proto.validateValue(messageText, named: "messageText")
    try proto.validateValue(messageTemplate, named: "messageTemplate")
    try proto.validateValue(packageId, named: "packageId")

    return PaymentReservation(receiverMid: receiverMid, productId: productId, language: language, location: location, currency: currency, price: price, appStoreCode: appStoreCode, messageText: messageText, messageTemplate: messageTemplate, packageId: packageId)
  }

}



public func ==(lhs: PaymentReservationResult, rhs: PaymentReservationResult) -> Bool {
  return
    (lhs.orderId == rhs.orderId) &&
    (lhs.confirmUrl == rhs.confirmUrl) &&
    (lhs.extras == rhs.extras)
}

extension PaymentReservationResult : CustomStringConvertible {

  public var description : String {
    var desc = "PaymentReservationResult("
    desc += "orderId=\(String(describing: self.orderId)), "
    desc += "confirmUrl=\(String(describing: self.confirmUrl)), "
    desc += "extras=\(String(describing: self.extras))"
    return desc
  }

}

extension PaymentReservationResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (orderId.hashValue)
    result = prime &* result &+ (confirmUrl.hashValue)
    result = prime &* result &+ (extras.hashValue)
    return result
  }

}

extension PaymentReservationResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["orderId": 1, "confirmUrl": 2, "extras": 3, ]
  }

  public static var structName: String { return "PaymentReservationResult" }

  public static func read(from proto: TProtocol) throws -> PaymentReservationResult {
    _ = try proto.readStructBegin()
    var orderId: String!
    var confirmUrl: String!
    var extras: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           orderId = try String.read(from: proto)
        case (2, .string):           confirmUrl = try String.read(from: proto)
        case (3, .map):             extras = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(orderId, named: "orderId")
    try proto.validateValue(confirmUrl, named: "confirmUrl")
    try proto.validateValue(extras, named: "extras")

    return PaymentReservationResult(orderId: orderId, confirmUrl: confirmUrl, extras: extras)
  }

}



public func ==(lhs: Product, rhs: Product) -> Bool {
  return
    (lhs.productId == rhs.productId) &&
    (lhs.packageId == rhs.packageId) &&
    (lhs.version == rhs.version) &&
    (lhs.authorName == rhs.authorName) &&
    (lhs.onSale == rhs.onSale) &&
    (lhs.validDays == rhs.validDays) &&
    (lhs.saleType == rhs.saleType) &&
    (lhs.copyright == rhs.copyright) &&
    (lhs.title == rhs.title) &&
    (lhs.descriptionText == rhs.descriptionText) &&
    (lhs.shopOrderId == rhs.shopOrderId) &&
    (lhs.fromMid == rhs.fromMid) &&
    (lhs.toMid == rhs.toMid) &&
    (lhs.validUntil == rhs.validUntil) &&
    (lhs.priceTier == rhs.priceTier) &&
    (lhs.price == rhs.price) &&
    (lhs.currency == rhs.currency) &&
    (lhs.currencySymbol == rhs.currencySymbol) &&
    (lhs.paymentType == rhs.paymentType) &&
    (lhs.createDate == rhs.createDate) &&
    (lhs.ownFlag == rhs.ownFlag) &&
    (lhs.eventType == rhs.eventType) &&
    (lhs.urlSchema == rhs.urlSchema) &&
    (lhs.downloadUrl == rhs.downloadUrl) &&
    (lhs.buddyMid == rhs.buddyMid) &&
    (lhs.publishSince == rhs.publishSince) &&
    (lhs.newFlag == rhs.newFlag) &&
    (lhs.missionFlag == rhs.missionFlag)
}

extension Product : CustomStringConvertible {

  public var description : String {
    var desc = "Product("
    desc += "productId=\(String(describing: self.productId)), "
    desc += "packageId=\(String(describing: self.packageId)), "
    desc += "version=\(String(describing: self.version)), "
    desc += "authorName=\(String(describing: self.authorName)), "
    desc += "onSale=\(String(describing: self.onSale)), "
    desc += "validDays=\(String(describing: self.validDays)), "
    desc += "saleType=\(String(describing: self.saleType)), "
    desc += "copyright=\(String(describing: self.copyright)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "descriptionText=\(String(describing: self.descriptionText)), "
    desc += "shopOrderId=\(String(describing: self.shopOrderId)), "
    desc += "fromMid=\(String(describing: self.fromMid)), "
    desc += "toMid=\(String(describing: self.toMid)), "
    desc += "validUntil=\(String(describing: self.validUntil)), "
    desc += "priceTier=\(String(describing: self.priceTier)), "
    desc += "price=\(String(describing: self.price)), "
    desc += "currency=\(String(describing: self.currency)), "
    desc += "currencySymbol=\(String(describing: self.currencySymbol)), "
    desc += "paymentType=\(String(describing: self.paymentType)), "
    desc += "createDate=\(String(describing: self.createDate)), "
    desc += "ownFlag=\(String(describing: self.ownFlag)), "
    desc += "eventType=\(String(describing: self.eventType)), "
    desc += "urlSchema=\(String(describing: self.urlSchema)), "
    desc += "downloadUrl=\(String(describing: self.downloadUrl)), "
    desc += "buddyMid=\(String(describing: self.buddyMid)), "
    desc += "publishSince=\(String(describing: self.publishSince)), "
    desc += "newFlag=\(String(describing: self.newFlag)), "
    desc += "missionFlag=\(String(describing: self.missionFlag))"
    return desc
  }

}

extension Product : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (productId.hashValue)
    result = prime &* result &+ (packageId.hashValue)
    result = prime &* result &+ (version.hashValue)
    result = prime &* result &+ (authorName.hashValue)
    result = prime &* result &+ (onSale.hashValue)
    result = prime &* result &+ (validDays.hashValue)
    result = prime &* result &+ (saleType.hashValue)
    result = prime &* result &+ (copyright.hashValue)
    result = prime &* result &+ (title.hashValue)
    result = prime &* result &+ (descriptionText.hashValue)
    result = prime &* result &+ (shopOrderId.hashValue)
    result = prime &* result &+ (fromMid.hashValue)
    result = prime &* result &+ (toMid.hashValue)
    result = prime &* result &+ (validUntil.hashValue)
    result = prime &* result &+ (priceTier.hashValue)
    result = prime &* result &+ (price.hashValue)
    result = prime &* result &+ (currency.hashValue)
    result = prime &* result &+ (currencySymbol.hashValue)
    result = prime &* result &+ (paymentType.hashValue)
    result = prime &* result &+ (createDate.hashValue)
    result = prime &* result &+ (ownFlag.hashValue)
    result = prime &* result &+ (eventType.hashValue)
    result = prime &* result &+ (urlSchema.hashValue)
    result = prime &* result &+ (downloadUrl.hashValue)
    result = prime &* result &+ (buddyMid.hashValue)
    result = prime &* result &+ (publishSince.hashValue)
    result = prime &* result &+ (newFlag.hashValue)
    result = prime &* result &+ (missionFlag.hashValue)
    return result
  }

}

extension Product : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["productId": 1, "packageId": 2, "version": 3, "authorName": 4, "onSale": 5, "validDays": 6, "saleType": 7, "copyright": 8, "title": 9, "descriptionText": 10, "shopOrderId": 11, "fromMid": 12, "toMid": 13, "validUntil": 14, "priceTier": 15, "price": 16, "currency": 17, "currencySymbol": 18, "paymentType": 19, "createDate": 20, "ownFlag": 21, "eventType": 22, "urlSchema": 23, "downloadUrl": 24, "buddyMid": 25, "publishSince": 26, "newFlag": 27, "missionFlag": 28, ]
  }

  public static var structName: String { return "Product" }

  public static func read(from proto: TProtocol) throws -> Product {
    _ = try proto.readStructBegin()
    var productId: String!
    var packageId: Int64!
    var version: Int32!
    var authorName: String!
    var onSale: Bool!
    var validDays: Int32!
    var saleType: Int32!
    var copyright: String!
    var title: String!
    var descriptionText: String!
    var shopOrderId: Int64!
    var fromMid: String!
    var toMid: String!
    var validUntil: Int64!
    var priceTier: Int32!
    var price: String!
    var currency: String!
    var currencySymbol: String!
    var paymentType: PaymentType!
    var createDate: Int64!
    var ownFlag: Bool!
    var eventType: ProductEventType!
    var urlSchema: String!
    var downloadUrl: String!
    var buddyMid: String!
    var publishSince: Int64!
    var newFlag: Bool!
    var missionFlag: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           productId = try String.read(from: proto)
        case (2, .i64):             packageId = try Int64.read(from: proto)
        case (3, .i32):             version = try Int32.read(from: proto)
        case (4, .string):           authorName = try String.read(from: proto)
        case (5, .bool):            onSale = try Bool.read(from: proto)
        case (6, .i32):             validDays = try Int32.read(from: proto)
        case (7, .i32):             saleType = try Int32.read(from: proto)
        case (8, .string):           copyright = try String.read(from: proto)
        case (9, .string):           title = try String.read(from: proto)
        case (10, .string):           descriptionText = try String.read(from: proto)
        case (11, .i64):             shopOrderId = try Int64.read(from: proto)
        case (12, .string):           fromMid = try String.read(from: proto)
        case (13, .string):           toMid = try String.read(from: proto)
        case (14, .i64):             validUntil = try Int64.read(from: proto)
        case (15, .i32):             priceTier = try Int32.read(from: proto)
        case (16, .string):           price = try String.read(from: proto)
        case (17, .string):           currency = try String.read(from: proto)
        case (18, .string):           currencySymbol = try String.read(from: proto)
        case (19, .i32):             paymentType = try PaymentType.read(from: proto)
        case (20, .i64):             createDate = try Int64.read(from: proto)
        case (21, .bool):            ownFlag = try Bool.read(from: proto)
        case (22, .i32):             eventType = try ProductEventType.read(from: proto)
        case (23, .string):           urlSchema = try String.read(from: proto)
        case (24, .string):           downloadUrl = try String.read(from: proto)
        case (25, .string):           buddyMid = try String.read(from: proto)
        case (26, .i64):             publishSince = try Int64.read(from: proto)
        case (27, .bool):            newFlag = try Bool.read(from: proto)
        case (28, .bool):            missionFlag = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(productId, named: "productId")
    try proto.validateValue(packageId, named: "packageId")
    try proto.validateValue(version, named: "version")
    try proto.validateValue(authorName, named: "authorName")
    try proto.validateValue(onSale, named: "onSale")
    try proto.validateValue(validDays, named: "validDays")
    try proto.validateValue(saleType, named: "saleType")
    try proto.validateValue(copyright, named: "copyright")
    try proto.validateValue(title, named: "title")
    try proto.validateValue(descriptionText, named: "descriptionText")
    try proto.validateValue(shopOrderId, named: "shopOrderId")
    try proto.validateValue(fromMid, named: "fromMid")
    try proto.validateValue(toMid, named: "toMid")
    try proto.validateValue(validUntil, named: "validUntil")
    try proto.validateValue(priceTier, named: "priceTier")
    try proto.validateValue(price, named: "price")
    try proto.validateValue(currency, named: "currency")
    try proto.validateValue(currencySymbol, named: "currencySymbol")
    try proto.validateValue(paymentType, named: "paymentType")
    try proto.validateValue(createDate, named: "createDate")
    try proto.validateValue(ownFlag, named: "ownFlag")
    try proto.validateValue(eventType, named: "eventType")
    try proto.validateValue(urlSchema, named: "urlSchema")
    try proto.validateValue(downloadUrl, named: "downloadUrl")
    try proto.validateValue(buddyMid, named: "buddyMid")
    try proto.validateValue(publishSince, named: "publishSince")
    try proto.validateValue(newFlag, named: "newFlag")
    try proto.validateValue(missionFlag, named: "missionFlag")

    return Product(productId: productId, packageId: packageId, version: version, authorName: authorName, onSale: onSale, validDays: validDays, saleType: saleType, copyright: copyright, title: title, descriptionText: descriptionText, shopOrderId: shopOrderId, fromMid: fromMid, toMid: toMid, validUntil: validUntil, priceTier: priceTier, price: price, currency: currency, currencySymbol: currencySymbol, paymentType: paymentType, createDate: createDate, ownFlag: ownFlag, eventType: eventType, urlSchema: urlSchema, downloadUrl: downloadUrl, buddyMid: buddyMid, publishSince: publishSince, newFlag: newFlag, missionFlag: missionFlag)
  }

}



public func ==(lhs: ProductList, rhs: ProductList) -> Bool {
  return
    (lhs.hasNext == rhs.hasNext) &&
    (lhs.bannerSequence == rhs.bannerSequence) &&
    (lhs.bannerTargetType == rhs.bannerTargetType) &&
    (lhs.bannerTargetPath == rhs.bannerTargetPath) &&
    (lhs.productList == rhs.productList) &&
    (lhs.bannerLang == rhs.bannerLang)
}

extension ProductList : CustomStringConvertible {

  public var description : String {
    var desc = "ProductList("
    desc += "hasNext=\(String(describing: self.hasNext)), "
    desc += "bannerSequence=\(String(describing: self.bannerSequence)), "
    desc += "bannerTargetType=\(String(describing: self.bannerTargetType)), "
    desc += "bannerTargetPath=\(String(describing: self.bannerTargetPath)), "
    desc += "productList=\(String(describing: self.productList)), "
    desc += "bannerLang=\(String(describing: self.bannerLang))"
    return desc
  }

}

extension ProductList : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (hasNext.hashValue)
    result = prime &* result &+ (bannerSequence.hashValue)
    result = prime &* result &+ (bannerTargetType.hashValue)
    result = prime &* result &+ (bannerTargetPath.hashValue)
    result = prime &* result &+ (productList.hashValue)
    result = prime &* result &+ (bannerLang.hashValue)
    return result
  }

}

extension ProductList : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["hasNext": 1, "bannerSequence": 4, "bannerTargetType": 5, "bannerTargetPath": 6, "productList": 7, "bannerLang": 8, ]
  }

  public static var structName: String { return "ProductList" }

  public static func read(from proto: TProtocol) throws -> ProductList {
    _ = try proto.readStructBegin()
    var hasNext: Bool!
    var bannerSequence: Int64!
    var bannerTargetType: ProductBannerLinkType!
    var bannerTargetPath: String!
    var productList: TList<Product>!
    var bannerLang: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            hasNext = try Bool.read(from: proto)
        case (4, .i64):             bannerSequence = try Int64.read(from: proto)
        case (5, .i32):             bannerTargetType = try ProductBannerLinkType.read(from: proto)
        case (6, .string):           bannerTargetPath = try String.read(from: proto)
        case (7, .list):            productList = try TList<Product>.read(from: proto)
        case (8, .string):           bannerLang = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(hasNext, named: "hasNext")
    try proto.validateValue(bannerSequence, named: "bannerSequence")
    try proto.validateValue(bannerTargetType, named: "bannerTargetType")
    try proto.validateValue(bannerTargetPath, named: "bannerTargetPath")
    try proto.validateValue(productList, named: "productList")
    try proto.validateValue(bannerLang, named: "bannerLang")

    return ProductList(hasNext: hasNext, bannerSequence: bannerSequence, bannerTargetType: bannerTargetType, bannerTargetPath: bannerTargetPath, productList: productList, bannerLang: bannerLang)
  }

}



public func ==(lhs: ProductSimple, rhs: ProductSimple) -> Bool {
  return
    (lhs.productId == rhs.productId) &&
    (lhs.packageId == rhs.packageId) &&
    (lhs.version == rhs.version) &&
    (lhs.onSale == rhs.onSale) &&
    (lhs.validUntil == rhs.validUntil)
}

extension ProductSimple : CustomStringConvertible {

  public var description : String {
    var desc = "ProductSimple("
    desc += "productId=\(String(describing: self.productId)), "
    desc += "packageId=\(String(describing: self.packageId)), "
    desc += "version=\(String(describing: self.version)), "
    desc += "onSale=\(String(describing: self.onSale)), "
    desc += "validUntil=\(String(describing: self.validUntil))"
    return desc
  }

}

extension ProductSimple : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (productId.hashValue)
    result = prime &* result &+ (packageId.hashValue)
    result = prime &* result &+ (version.hashValue)
    result = prime &* result &+ (onSale.hashValue)
    result = prime &* result &+ (validUntil.hashValue)
    return result
  }

}

extension ProductSimple : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["productId": 1, "packageId": 2, "version": 3, "onSale": 4, "validUntil": 5, ]
  }

  public static var structName: String { return "ProductSimple" }

  public static func read(from proto: TProtocol) throws -> ProductSimple {
    _ = try proto.readStructBegin()
    var productId: String!
    var packageId: Int64!
    var version: Int32!
    var onSale: Bool!
    var validUntil: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           productId = try String.read(from: proto)
        case (2, .i64):             packageId = try Int64.read(from: proto)
        case (3, .i32):             version = try Int32.read(from: proto)
        case (4, .bool):            onSale = try Bool.read(from: proto)
        case (5, .i64):             validUntil = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(productId, named: "productId")
    try proto.validateValue(packageId, named: "packageId")
    try proto.validateValue(version, named: "version")
    try proto.validateValue(onSale, named: "onSale")
    try proto.validateValue(validUntil, named: "validUntil")

    return ProductSimple(productId: productId, packageId: packageId, version: version, onSale: onSale, validUntil: validUntil)
  }

}



public func ==(lhs: ProductSimpleList, rhs: ProductSimpleList) -> Bool {
  return
    (lhs.hasNext == rhs.hasNext) &&
    (lhs.reinvokeHour == rhs.reinvokeHour) &&
    (lhs.lastVersionSeq == rhs.lastVersionSeq) &&
    (lhs.productList == rhs.productList) &&
    (lhs.recentNewReleaseDate == rhs.recentNewReleaseDate) &&
    (lhs.recentEventReleaseDate == rhs.recentEventReleaseDate)
}

extension ProductSimpleList : CustomStringConvertible {

  public var description : String {
    var desc = "ProductSimpleList("
    desc += "hasNext=\(String(describing: self.hasNext)), "
    desc += "reinvokeHour=\(String(describing: self.reinvokeHour)), "
    desc += "lastVersionSeq=\(String(describing: self.lastVersionSeq)), "
    desc += "productList=\(String(describing: self.productList)), "
    desc += "recentNewReleaseDate=\(String(describing: self.recentNewReleaseDate)), "
    desc += "recentEventReleaseDate=\(String(describing: self.recentEventReleaseDate))"
    return desc
  }

}

extension ProductSimpleList : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (hasNext.hashValue)
    result = prime &* result &+ (reinvokeHour.hashValue)
    result = prime &* result &+ (lastVersionSeq.hashValue)
    result = prime &* result &+ (productList.hashValue)
    result = prime &* result &+ (recentNewReleaseDate.hashValue)
    result = prime &* result &+ (recentEventReleaseDate.hashValue)
    return result
  }

}

extension ProductSimpleList : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["hasNext": 1, "reinvokeHour": 2, "lastVersionSeq": 3, "productList": 4, "recentNewReleaseDate": 5, "recentEventReleaseDate": 6, ]
  }

  public static var structName: String { return "ProductSimpleList" }

  public static func read(from proto: TProtocol) throws -> ProductSimpleList {
    _ = try proto.readStructBegin()
    var hasNext: Bool!
    var reinvokeHour: Int32!
    var lastVersionSeq: Int64!
    var productList: TList<ProductSimple>!
    var recentNewReleaseDate: Int64!
    var recentEventReleaseDate: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            hasNext = try Bool.read(from: proto)
        case (2, .i32):             reinvokeHour = try Int32.read(from: proto)
        case (3, .i64):             lastVersionSeq = try Int64.read(from: proto)
        case (4, .list):            productList = try TList<ProductSimple>.read(from: proto)
        case (5, .i64):             recentNewReleaseDate = try Int64.read(from: proto)
        case (6, .i64):             recentEventReleaseDate = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(hasNext, named: "hasNext")
    try proto.validateValue(reinvokeHour, named: "reinvokeHour")
    try proto.validateValue(lastVersionSeq, named: "lastVersionSeq")
    try proto.validateValue(productList, named: "productList")
    try proto.validateValue(recentNewReleaseDate, named: "recentNewReleaseDate")
    try proto.validateValue(recentEventReleaseDate, named: "recentEventReleaseDate")

    return ProductSimpleList(hasNext: hasNext, reinvokeHour: reinvokeHour, lastVersionSeq: lastVersionSeq, productList: productList, recentNewReleaseDate: recentNewReleaseDate, recentEventReleaseDate: recentEventReleaseDate)
  }

}



public func ==(lhs: Profile, rhs: Profile) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.userid == rhs.userid) &&
    (lhs.phone == rhs.phone) &&
    (lhs.email == rhs.email) &&
    (lhs.regionCode == rhs.regionCode) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.phoneticName == rhs.phoneticName) &&
    (lhs.pictureStatus == rhs.pictureStatus) &&
    (lhs.thumbnailUrl == rhs.thumbnailUrl) &&
    (lhs.statusMessage == rhs.statusMessage) &&
    (lhs.allowSearchByUserid == rhs.allowSearchByUserid) &&
    (lhs.allowSearchByEmail == rhs.allowSearchByEmail) &&
    (lhs.picturePath == rhs.picturePath)
}

extension Profile : CustomStringConvertible {

  public var description : String {
    var desc = "Profile("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "userid=\(String(describing: self.userid)), "
    desc += "phone=\(String(describing: self.phone)), "
    desc += "email=\(String(describing: self.email)), "
    desc += "regionCode=\(String(describing: self.regionCode)), "
    desc += "displayName=\(String(describing: self.displayName)), "
    desc += "phoneticName=\(String(describing: self.phoneticName)), "
    desc += "pictureStatus=\(String(describing: self.pictureStatus)), "
    desc += "thumbnailUrl=\(String(describing: self.thumbnailUrl)), "
    desc += "statusMessage=\(String(describing: self.statusMessage)), "
    desc += "allowSearchByUserid=\(String(describing: self.allowSearchByUserid)), "
    desc += "allowSearchByEmail=\(String(describing: self.allowSearchByEmail)), "
    desc += "picturePath=\(String(describing: self.picturePath))"
    return desc
  }

}

extension Profile : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (userid.hashValue)
    result = prime &* result &+ (phone.hashValue)
    result = prime &* result &+ (email.hashValue)
    result = prime &* result &+ (regionCode.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (phoneticName.hashValue)
    result = prime &* result &+ (pictureStatus.hashValue)
    result = prime &* result &+ (thumbnailUrl.hashValue)
    result = prime &* result &+ (statusMessage.hashValue)
    result = prime &* result &+ (allowSearchByUserid.hashValue)
    result = prime &* result &+ (allowSearchByEmail.hashValue)
    result = prime &* result &+ (picturePath.hashValue)
    return result
  }

}

extension Profile : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "userid": 3, "phone": 10, "email": 11, "regionCode": 12, "displayName": 20, "phoneticName": 21, "pictureStatus": 22, "thumbnailUrl": 23, "statusMessage": 24, "allowSearchByUserid": 31, "allowSearchByEmail": 32, "picturePath": 33, ]
  }

  public static var structName: String { return "Profile" }

  public static func read(from proto: TProtocol) throws -> Profile {
    _ = try proto.readStructBegin()
    var mid: String!
    var userid: String!
    var phone: String!
    var email: String!
    var regionCode: String!
    var displayName: String!
    var phoneticName: String!
    var pictureStatus: String!
    var thumbnailUrl: String!
    var statusMessage: String!
    var allowSearchByUserid: Bool!
    var allowSearchByEmail: Bool!
    var picturePath: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (3, .string):           userid = try String.read(from: proto)
        case (10, .string):           phone = try String.read(from: proto)
        case (11, .string):           email = try String.read(from: proto)
        case (12, .string):           regionCode = try String.read(from: proto)
        case (20, .string):           displayName = try String.read(from: proto)
        case (21, .string):           phoneticName = try String.read(from: proto)
        case (22, .string):           pictureStatus = try String.read(from: proto)
        case (23, .string):           thumbnailUrl = try String.read(from: proto)
        case (24, .string):           statusMessage = try String.read(from: proto)
        case (31, .bool):            allowSearchByUserid = try Bool.read(from: proto)
        case (32, .bool):            allowSearchByEmail = try Bool.read(from: proto)
        case (33, .string):           picturePath = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(userid, named: "userid")
    try proto.validateValue(phone, named: "phone")
    try proto.validateValue(email, named: "email")
    try proto.validateValue(regionCode, named: "regionCode")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(phoneticName, named: "phoneticName")
    try proto.validateValue(pictureStatus, named: "pictureStatus")
    try proto.validateValue(thumbnailUrl, named: "thumbnailUrl")
    try proto.validateValue(statusMessage, named: "statusMessage")
    try proto.validateValue(allowSearchByUserid, named: "allowSearchByUserid")
    try proto.validateValue(allowSearchByEmail, named: "allowSearchByEmail")
    try proto.validateValue(picturePath, named: "picturePath")

    return Profile(mid: mid, userid: userid, phone: phone, email: email, regionCode: regionCode, displayName: displayName, phoneticName: phoneticName, pictureStatus: pictureStatus, thumbnailUrl: thumbnailUrl, statusMessage: statusMessage, allowSearchByUserid: allowSearchByUserid, allowSearchByEmail: allowSearchByEmail, picturePath: picturePath)
  }

}



public func ==(lhs: ProximityMatchCandidateResult, rhs: ProximityMatchCandidateResult) -> Bool {
  return
    (lhs.users == rhs.users) &&
    (lhs.buddies == rhs.buddies)
}

extension ProximityMatchCandidateResult : CustomStringConvertible {

  public var description : String {
    var desc = "ProximityMatchCandidateResult("
    desc += "users=\(String(describing: self.users)), "
    desc += "buddies=\(String(describing: self.buddies))"
    return desc
  }

}

extension ProximityMatchCandidateResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (users.hashValue)
    result = prime &* result &+ (buddies.hashValue)
    return result
  }

}

extension ProximityMatchCandidateResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["users": 1, "buddies": 2, ]
  }

  public static var structName: String { return "ProximityMatchCandidateResult" }

  public static func read(from proto: TProtocol) throws -> ProximityMatchCandidateResult {
    _ = try proto.readStructBegin()
    var users: TList<Contact>!
    var buddies: TList<Contact>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            users = try TList<Contact>.read(from: proto)
        case (2, .list):            buddies = try TList<Contact>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(users, named: "users")
    try proto.validateValue(buddies, named: "buddies")

    return ProximityMatchCandidateResult(users: users, buddies: buddies)
  }

}



public func ==(lhs: RegisterWithSnsIdResult, rhs: RegisterWithSnsIdResult) -> Bool {
  return
    (lhs.authToken == rhs.authToken) &&
    (lhs.userCreated == rhs.userCreated)
}

extension RegisterWithSnsIdResult : CustomStringConvertible {

  public var description : String {
    var desc = "RegisterWithSnsIdResult("
    desc += "authToken=\(String(describing: self.authToken)), "
    desc += "userCreated=\(String(describing: self.userCreated))"
    return desc
  }

}

extension RegisterWithSnsIdResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authToken.hashValue)
    result = prime &* result &+ (userCreated.hashValue)
    return result
  }

}

extension RegisterWithSnsIdResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authToken": 1, "userCreated": 2, ]
  }

  public static var structName: String { return "RegisterWithSnsIdResult" }

  public static func read(from proto: TProtocol) throws -> RegisterWithSnsIdResult {
    _ = try proto.readStructBegin()
    var authToken: String!
    var userCreated: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           authToken = try String.read(from: proto)
        case (2, .bool):            userCreated = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authToken, named: "authToken")
    try proto.validateValue(userCreated, named: "userCreated")

    return RegisterWithSnsIdResult(authToken: authToken, userCreated: userCreated)
  }

}



public func ==(lhs: RequestTokenResponse, rhs: RequestTokenResponse) -> Bool {
  return
    (lhs.requestToken == rhs.requestToken) &&
    (lhs.returnUrl == rhs.returnUrl)
}

extension RequestTokenResponse : CustomStringConvertible {

  public var description : String {
    var desc = "RequestTokenResponse("
    desc += "requestToken=\(String(describing: self.requestToken)), "
    desc += "returnUrl=\(String(describing: self.returnUrl))"
    return desc
  }

}

extension RequestTokenResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestToken.hashValue)
    result = prime &* result &+ (returnUrl.hashValue)
    return result
  }

}

extension RequestTokenResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["requestToken": 1, "returnUrl": 2, ]
  }

  public static var structName: String { return "RequestTokenResponse" }

  public static func read(from proto: TProtocol) throws -> RequestTokenResponse {
    _ = try proto.readStructBegin()
    var requestToken: String!
    var returnUrl: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestToken = try String.read(from: proto)
        case (2, .string):           returnUrl = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestToken, named: "requestToken")
    try proto.validateValue(returnUrl, named: "returnUrl")

    return RequestTokenResponse(requestToken: requestToken, returnUrl: returnUrl)
  }

}



public func ==(lhs: Room, rhs: Room) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.createdTime == rhs.createdTime) &&
    (lhs.contacts == rhs.contacts) &&
    (lhs.notificationDisabled == rhs.notificationDisabled)
}

extension Room : CustomStringConvertible {

  public var description : String {
    var desc = "Room("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "createdTime=\(String(describing: self.createdTime)), "
    desc += "contacts=\(String(describing: self.contacts)), "
    desc += "notificationDisabled=\(String(describing: self.notificationDisabled))"
    return desc
  }

}

extension Room : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (createdTime.hashValue)
    result = prime &* result &+ (contacts.hashValue)
    result = prime &* result &+ (notificationDisabled.hashValue)
    return result
  }

}

extension Room : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "createdTime": 2, "contacts": 10, "notificationDisabled": 31, ]
  }

  public static var structName: String { return "Room" }

  public static func read(from proto: TProtocol) throws -> Room {
    _ = try proto.readStructBegin()
    var mid: String!
    var createdTime: Int64!
    var contacts: TList<Contact>!
    var notificationDisabled: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .i64):             createdTime = try Int64.read(from: proto)
        case (10, .list):            contacts = try TList<Contact>.read(from: proto)
        case (31, .bool):            notificationDisabled = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(createdTime, named: "createdTime")
    try proto.validateValue(contacts, named: "contacts")
    try proto.validateValue(notificationDisabled, named: "notificationDisabled")

    return Room(mid: mid, createdTime: createdTime, contacts: contacts, notificationDisabled: notificationDisabled)
  }

}



public func ==(lhs: RSAKey, rhs: RSAKey) -> Bool {
  return
    (lhs.keynm == rhs.keynm) &&
    (lhs.nvalue == rhs.nvalue) &&
    (lhs.evalue == rhs.evalue) &&
    (lhs.sessionKey == rhs.sessionKey)
}

extension RSAKey : CustomStringConvertible {

  public var description : String {
    var desc = "RSAKey("
    desc += "keynm=\(String(describing: self.keynm)), "
    desc += "nvalue=\(String(describing: self.nvalue)), "
    desc += "evalue=\(String(describing: self.evalue)), "
    desc += "sessionKey=\(String(describing: self.sessionKey))"
    return desc
  }

}

extension RSAKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (keynm.hashValue)
    result = prime &* result &+ (nvalue.hashValue)
    result = prime &* result &+ (evalue.hashValue)
    result = prime &* result &+ (sessionKey.hashValue)
    return result
  }

}

extension RSAKey : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["keynm": 1, "nvalue": 2, "evalue": 3, "sessionKey": 4, ]
  }

  public static var structName: String { return "RSAKey" }

  public static func read(from proto: TProtocol) throws -> RSAKey {
    _ = try proto.readStructBegin()
    var keynm: String!
    var nvalue: String!
    var evalue: String!
    var sessionKey: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           keynm = try String.read(from: proto)
        case (2, .string):           nvalue = try String.read(from: proto)
        case (3, .string):           evalue = try String.read(from: proto)
        case (4, .string):           sessionKey = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(keynm, named: "keynm")
    try proto.validateValue(nvalue, named: "nvalue")
    try proto.validateValue(evalue, named: "evalue")
    try proto.validateValue(sessionKey, named: "sessionKey")

    return RSAKey(keynm: keynm, nvalue: nvalue, evalue: evalue, sessionKey: sessionKey)
  }

}



public func ==(lhs: SendBuddyMessageResult, rhs: SendBuddyMessageResult) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.state == rhs.state) &&
    (lhs.messageId == rhs.messageId) &&
    (lhs.eventNo == rhs.eventNo) &&
    (lhs.receiverCount == rhs.receiverCount) &&
    (lhs.successCount == rhs.successCount) &&
    (lhs.failCount == rhs.failCount) &&
    (lhs.cancelCount == rhs.cancelCount) &&
    (lhs.blockCount == rhs.blockCount) &&
    (lhs.unregisterCount == rhs.unregisterCount) &&
    (lhs.timestamp == rhs.timestamp) &&
    (lhs.message == rhs.message)
}

extension SendBuddyMessageResult : CustomStringConvertible {

  public var description : String {
    var desc = "SendBuddyMessageResult("
    desc += "requestId=\(String(describing: self.requestId)), "
    desc += "state=\(String(describing: self.state)), "
    desc += "messageId=\(String(describing: self.messageId)), "
    desc += "eventNo=\(String(describing: self.eventNo)), "
    desc += "receiverCount=\(String(describing: self.receiverCount)), "
    desc += "successCount=\(String(describing: self.successCount)), "
    desc += "failCount=\(String(describing: self.failCount)), "
    desc += "cancelCount=\(String(describing: self.cancelCount)), "
    desc += "blockCount=\(String(describing: self.blockCount)), "
    desc += "unregisterCount=\(String(describing: self.unregisterCount)), "
    desc += "timestamp=\(String(describing: self.timestamp)), "
    desc += "message=\(String(describing: self.message))"
    return desc
  }

}

extension SendBuddyMessageResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (state.hashValue)
    result = prime &* result &+ (messageId.hashValue)
    result = prime &* result &+ (eventNo.hashValue)
    result = prime &* result &+ (receiverCount.hashValue)
    result = prime &* result &+ (successCount.hashValue)
    result = prime &* result &+ (failCount.hashValue)
    result = prime &* result &+ (cancelCount.hashValue)
    result = prime &* result &+ (blockCount.hashValue)
    result = prime &* result &+ (unregisterCount.hashValue)
    result = prime &* result &+ (timestamp.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension SendBuddyMessageResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["requestId": 1, "state": 2, "messageId": 3, "eventNo": 4, "receiverCount": 11, "successCount": 12, "failCount": 13, "cancelCount": 14, "blockCount": 15, "unregisterCount": 16, "timestamp": 21, "message": 22, ]
  }

  public static var structName: String { return "SendBuddyMessageResult" }

  public static func read(from proto: TProtocol) throws -> SendBuddyMessageResult {
    _ = try proto.readStructBegin()
    var requestId: String!
    var state: BuddyResultState!
    var messageId: String!
    var eventNo: Int32!
    var receiverCount: Int64!
    var successCount: Int64!
    var failCount: Int64!
    var cancelCount: Int64!
    var blockCount: Int64!
    var unregisterCount: Int64!
    var timestamp: Int64!
    var message: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .i32):             state = try BuddyResultState.read(from: proto)
        case (3, .string):           messageId = try String.read(from: proto)
        case (4, .i32):             eventNo = try Int32.read(from: proto)
        case (11, .i64):             receiverCount = try Int64.read(from: proto)
        case (12, .i64):             successCount = try Int64.read(from: proto)
        case (13, .i64):             failCount = try Int64.read(from: proto)
        case (14, .i64):             cancelCount = try Int64.read(from: proto)
        case (15, .i64):             blockCount = try Int64.read(from: proto)
        case (16, .i64):             unregisterCount = try Int64.read(from: proto)
        case (21, .i64):             timestamp = try Int64.read(from: proto)
        case (22, .string):           message = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(state, named: "state")
    try proto.validateValue(messageId, named: "messageId")
    try proto.validateValue(eventNo, named: "eventNo")
    try proto.validateValue(receiverCount, named: "receiverCount")
    try proto.validateValue(successCount, named: "successCount")
    try proto.validateValue(failCount, named: "failCount")
    try proto.validateValue(cancelCount, named: "cancelCount")
    try proto.validateValue(blockCount, named: "blockCount")
    try proto.validateValue(unregisterCount, named: "unregisterCount")
    try proto.validateValue(timestamp, named: "timestamp")
    try proto.validateValue(message, named: "message")

    return SendBuddyMessageResult(requestId: requestId, state: state, messageId: messageId, eventNo: eventNo, receiverCount: receiverCount, successCount: successCount, failCount: failCount, cancelCount: cancelCount, blockCount: blockCount, unregisterCount: unregisterCount, timestamp: timestamp, message: message)
  }

}



public func ==(lhs: SetBuddyOnAirResult, rhs: SetBuddyOnAirResult) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.state == rhs.state) &&
    (lhs.eventNo == rhs.eventNo) &&
    (lhs.receiverCount == rhs.receiverCount) &&
    (lhs.successCount == rhs.successCount) &&
    (lhs.failCount == rhs.failCount) &&
    (lhs.cancelCount == rhs.cancelCount) &&
    (lhs.unregisterCount == rhs.unregisterCount) &&
    (lhs.timestamp == rhs.timestamp) &&
    (lhs.message == rhs.message)
}

extension SetBuddyOnAirResult : CustomStringConvertible {

  public var description : String {
    var desc = "SetBuddyOnAirResult("
    desc += "requestId=\(String(describing: self.requestId)), "
    desc += "state=\(String(describing: self.state)), "
    desc += "eventNo=\(String(describing: self.eventNo)), "
    desc += "receiverCount=\(String(describing: self.receiverCount)), "
    desc += "successCount=\(String(describing: self.successCount)), "
    desc += "failCount=\(String(describing: self.failCount)), "
    desc += "cancelCount=\(String(describing: self.cancelCount)), "
    desc += "unregisterCount=\(String(describing: self.unregisterCount)), "
    desc += "timestamp=\(String(describing: self.timestamp)), "
    desc += "message=\(String(describing: self.message))"
    return desc
  }

}

extension SetBuddyOnAirResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (state.hashValue)
    result = prime &* result &+ (eventNo.hashValue)
    result = prime &* result &+ (receiverCount.hashValue)
    result = prime &* result &+ (successCount.hashValue)
    result = prime &* result &+ (failCount.hashValue)
    result = prime &* result &+ (cancelCount.hashValue)
    result = prime &* result &+ (unregisterCount.hashValue)
    result = prime &* result &+ (timestamp.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension SetBuddyOnAirResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["requestId": 1, "state": 2, "eventNo": 3, "receiverCount": 11, "successCount": 12, "failCount": 13, "cancelCount": 14, "unregisterCount": 15, "timestamp": 21, "message": 22, ]
  }

  public static var structName: String { return "SetBuddyOnAirResult" }

  public static func read(from proto: TProtocol) throws -> SetBuddyOnAirResult {
    _ = try proto.readStructBegin()
    var requestId: String!
    var state: BuddyResultState!
    var eventNo: Int32!
    var receiverCount: Int64!
    var successCount: Int64!
    var failCount: Int64!
    var cancelCount: Int64!
    var unregisterCount: Int64!
    var timestamp: Int64!
    var message: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .i32):             state = try BuddyResultState.read(from: proto)
        case (3, .i32):             eventNo = try Int32.read(from: proto)
        case (11, .i64):             receiverCount = try Int64.read(from: proto)
        case (12, .i64):             successCount = try Int64.read(from: proto)
        case (13, .i64):             failCount = try Int64.read(from: proto)
        case (14, .i64):             cancelCount = try Int64.read(from: proto)
        case (15, .i64):             unregisterCount = try Int64.read(from: proto)
        case (21, .i64):             timestamp = try Int64.read(from: proto)
        case (22, .string):           message = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(state, named: "state")
    try proto.validateValue(eventNo, named: "eventNo")
    try proto.validateValue(receiverCount, named: "receiverCount")
    try proto.validateValue(successCount, named: "successCount")
    try proto.validateValue(failCount, named: "failCount")
    try proto.validateValue(cancelCount, named: "cancelCount")
    try proto.validateValue(unregisterCount, named: "unregisterCount")
    try proto.validateValue(timestamp, named: "timestamp")
    try proto.validateValue(message, named: "message")

    return SetBuddyOnAirResult(requestId: requestId, state: state, eventNo: eventNo, receiverCount: receiverCount, successCount: successCount, failCount: failCount, cancelCount: cancelCount, unregisterCount: unregisterCount, timestamp: timestamp, message: message)
  }

}



public func ==(lhs: Settings, rhs: Settings) -> Bool {
  return
    (lhs.notificationEnable == rhs.notificationEnable) &&
    (lhs.notificationMuteExpiration == rhs.notificationMuteExpiration) &&
    (lhs.notificationNewMessage == rhs.notificationNewMessage) &&
    (lhs.notificationGroupInvitation == rhs.notificationGroupInvitation) &&
    (lhs.notificationShowMessage == rhs.notificationShowMessage) &&
    (lhs.notificationIncomingCall == rhs.notificationIncomingCall) &&
    (lhs.notificationSoundMessage == rhs.notificationSoundMessage) &&
    (lhs.notificationSoundGroup == rhs.notificationSoundGroup) &&
    (lhs.notificationDisabledWithSub == rhs.notificationDisabledWithSub) &&
    (lhs.privacySyncContacts == rhs.privacySyncContacts) &&
    (lhs.privacySearchByPhoneNumber == rhs.privacySearchByPhoneNumber) &&
    (lhs.privacySearchByUserid == rhs.privacySearchByUserid) &&
    (lhs.privacySearchByEmail == rhs.privacySearchByEmail) &&
    (lhs.privacyAllowSecondaryDeviceLogin == rhs.privacyAllowSecondaryDeviceLogin) &&
    (lhs.privacyProfileImagePostToMyhome == rhs.privacyProfileImagePostToMyhome) &&
    (lhs.privacyReceiveMessagesFromNotFriend == rhs.privacyReceiveMessagesFromNotFriend) &&
    (lhs.contactMyTicket == rhs.contactMyTicket) &&
    (lhs.identityProvider == rhs.identityProvider) &&
    (lhs.identityIdentifier == rhs.identityIdentifier) &&
    (lhs.snsAccounts == rhs.snsAccounts) &&
    (lhs.phoneRegistration == rhs.phoneRegistration) &&
    (lhs.emailConfirmationStatus == rhs.emailConfirmationStatus) &&
    (lhs.preferenceLocale == rhs.preferenceLocale) &&
    (lhs.customModes == rhs.customModes)
}

extension Settings : CustomStringConvertible {

  public var description : String {
    var desc = "Settings("
    desc += "notificationEnable=\(String(describing: self.notificationEnable)), "
    desc += "notificationMuteExpiration=\(String(describing: self.notificationMuteExpiration)), "
    desc += "notificationNewMessage=\(String(describing: self.notificationNewMessage)), "
    desc += "notificationGroupInvitation=\(String(describing: self.notificationGroupInvitation)), "
    desc += "notificationShowMessage=\(String(describing: self.notificationShowMessage)), "
    desc += "notificationIncomingCall=\(String(describing: self.notificationIncomingCall)), "
    desc += "notificationSoundMessage=\(String(describing: self.notificationSoundMessage)), "
    desc += "notificationSoundGroup=\(String(describing: self.notificationSoundGroup)), "
    desc += "notificationDisabledWithSub=\(String(describing: self.notificationDisabledWithSub)), "
    desc += "privacySyncContacts=\(String(describing: self.privacySyncContacts)), "
    desc += "privacySearchByPhoneNumber=\(String(describing: self.privacySearchByPhoneNumber)), "
    desc += "privacySearchByUserid=\(String(describing: self.privacySearchByUserid)), "
    desc += "privacySearchByEmail=\(String(describing: self.privacySearchByEmail)), "
    desc += "privacyAllowSecondaryDeviceLogin=\(String(describing: self.privacyAllowSecondaryDeviceLogin)), "
    desc += "privacyProfileImagePostToMyhome=\(String(describing: self.privacyProfileImagePostToMyhome)), "
    desc += "privacyReceiveMessagesFromNotFriend=\(String(describing: self.privacyReceiveMessagesFromNotFriend)), "
    desc += "contactMyTicket=\(String(describing: self.contactMyTicket)), "
    desc += "identityProvider=\(String(describing: self.identityProvider)), "
    desc += "identityIdentifier=\(String(describing: self.identityIdentifier)), "
    desc += "snsAccounts=\(String(describing: self.snsAccounts)), "
    desc += "phoneRegistration=\(String(describing: self.phoneRegistration)), "
    desc += "emailConfirmationStatus=\(String(describing: self.emailConfirmationStatus)), "
    desc += "preferenceLocale=\(String(describing: self.preferenceLocale)), "
    desc += "customModes=\(String(describing: self.customModes))"
    return desc
  }

}

extension Settings : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (notificationEnable.hashValue)
    result = prime &* result &+ (notificationMuteExpiration.hashValue)
    result = prime &* result &+ (notificationNewMessage.hashValue)
    result = prime &* result &+ (notificationGroupInvitation.hashValue)
    result = prime &* result &+ (notificationShowMessage.hashValue)
    result = prime &* result &+ (notificationIncomingCall.hashValue)
    result = prime &* result &+ (notificationSoundMessage.hashValue)
    result = prime &* result &+ (notificationSoundGroup.hashValue)
    result = prime &* result &+ (notificationDisabledWithSub.hashValue)
    result = prime &* result &+ (privacySyncContacts.hashValue)
    result = prime &* result &+ (privacySearchByPhoneNumber.hashValue)
    result = prime &* result &+ (privacySearchByUserid.hashValue)
    result = prime &* result &+ (privacySearchByEmail.hashValue)
    result = prime &* result &+ (privacyAllowSecondaryDeviceLogin.hashValue)
    result = prime &* result &+ (privacyProfileImagePostToMyhome.hashValue)
    result = prime &* result &+ (privacyReceiveMessagesFromNotFriend.hashValue)
    result = prime &* result &+ (contactMyTicket.hashValue)
    result = prime &* result &+ (identityProvider.hashValue)
    result = prime &* result &+ (identityIdentifier.hashValue)
    result = prime &* result &+ (snsAccounts.hashValue)
    result = prime &* result &+ (phoneRegistration.hashValue)
    result = prime &* result &+ (emailConfirmationStatus.hashValue)
    result = prime &* result &+ (preferenceLocale.hashValue)
    result = prime &* result &+ (customModes.hashValue)
    return result
  }

}

extension Settings : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["notificationEnable": 10, "notificationMuteExpiration": 11, "notificationNewMessage": 12, "notificationGroupInvitation": 13, "notificationShowMessage": 14, "notificationIncomingCall": 15, "notificationSoundMessage": 16, "notificationSoundGroup": 17, "notificationDisabledWithSub": 18, "privacySyncContacts": 20, "privacySearchByPhoneNumber": 21, "privacySearchByUserid": 22, "privacySearchByEmail": 23, "privacyAllowSecondaryDeviceLogin": 24, "privacyProfileImagePostToMyhome": 25, "privacyReceiveMessagesFromNotFriend": 26, "contactMyTicket": 30, "identityProvider": 40, "identityIdentifier": 41, "snsAccounts": 42, "phoneRegistration": 43, "emailConfirmationStatus": 44, "preferenceLocale": 50, "customModes": 60, ]
  }

  public static var structName: String { return "Settings" }

  public static func read(from proto: TProtocol) throws -> Settings {
    _ = try proto.readStructBegin()
    var notificationEnable: Bool!
    var notificationMuteExpiration: Int64!
    var notificationNewMessage: Bool!
    var notificationGroupInvitation: Bool!
    var notificationShowMessage: Bool!
    var notificationIncomingCall: Bool!
    var notificationSoundMessage: String!
    var notificationSoundGroup: String!
    var notificationDisabledWithSub: Bool!
    var privacySyncContacts: Bool!
    var privacySearchByPhoneNumber: Bool!
    var privacySearchByUserid: Bool!
    var privacySearchByEmail: Bool!
    var privacyAllowSecondaryDeviceLogin: Bool!
    var privacyProfileImagePostToMyhome: Bool!
    var privacyReceiveMessagesFromNotFriend: Bool!
    var contactMyTicket: String!
    var identityProvider: IdentityProvider!
    var identityIdentifier: String!
    var snsAccounts: TMap<SnsIdType, String>!
    var phoneRegistration: Bool!
    var emailConfirmationStatus: EmailConfirmationStatus!
    var preferenceLocale: String!
    var customModes: TMap<CustomMode, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (10, .bool):            notificationEnable = try Bool.read(from: proto)
        case (11, .i64):             notificationMuteExpiration = try Int64.read(from: proto)
        case (12, .bool):            notificationNewMessage = try Bool.read(from: proto)
        case (13, .bool):            notificationGroupInvitation = try Bool.read(from: proto)
        case (14, .bool):            notificationShowMessage = try Bool.read(from: proto)
        case (15, .bool):            notificationIncomingCall = try Bool.read(from: proto)
        case (16, .string):           notificationSoundMessage = try String.read(from: proto)
        case (17, .string):           notificationSoundGroup = try String.read(from: proto)
        case (18, .bool):            notificationDisabledWithSub = try Bool.read(from: proto)
        case (20, .bool):            privacySyncContacts = try Bool.read(from: proto)
        case (21, .bool):            privacySearchByPhoneNumber = try Bool.read(from: proto)
        case (22, .bool):            privacySearchByUserid = try Bool.read(from: proto)
        case (23, .bool):            privacySearchByEmail = try Bool.read(from: proto)
        case (24, .bool):            privacyAllowSecondaryDeviceLogin = try Bool.read(from: proto)
        case (25, .bool):            privacyProfileImagePostToMyhome = try Bool.read(from: proto)
        case (26, .bool):            privacyReceiveMessagesFromNotFriend = try Bool.read(from: proto)
        case (30, .string):           contactMyTicket = try String.read(from: proto)
        case (40, .i32):             identityProvider = try IdentityProvider.read(from: proto)
        case (41, .string):           identityIdentifier = try String.read(from: proto)
        case (42, .map):             snsAccounts = try TMap<SnsIdType, String>.read(from: proto)
        case (43, .bool):            phoneRegistration = try Bool.read(from: proto)
        case (44, .i32):             emailConfirmationStatus = try EmailConfirmationStatus.read(from: proto)
        case (50, .string):           preferenceLocale = try String.read(from: proto)
        case (60, .map):             customModes = try TMap<CustomMode, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(notificationEnable, named: "notificationEnable")
    try proto.validateValue(notificationMuteExpiration, named: "notificationMuteExpiration")
    try proto.validateValue(notificationNewMessage, named: "notificationNewMessage")
    try proto.validateValue(notificationGroupInvitation, named: "notificationGroupInvitation")
    try proto.validateValue(notificationShowMessage, named: "notificationShowMessage")
    try proto.validateValue(notificationIncomingCall, named: "notificationIncomingCall")
    try proto.validateValue(notificationSoundMessage, named: "notificationSoundMessage")
    try proto.validateValue(notificationSoundGroup, named: "notificationSoundGroup")
    try proto.validateValue(notificationDisabledWithSub, named: "notificationDisabledWithSub")
    try proto.validateValue(privacySyncContacts, named: "privacySyncContacts")
    try proto.validateValue(privacySearchByPhoneNumber, named: "privacySearchByPhoneNumber")
    try proto.validateValue(privacySearchByUserid, named: "privacySearchByUserid")
    try proto.validateValue(privacySearchByEmail, named: "privacySearchByEmail")
    try proto.validateValue(privacyAllowSecondaryDeviceLogin, named: "privacyAllowSecondaryDeviceLogin")
    try proto.validateValue(privacyProfileImagePostToMyhome, named: "privacyProfileImagePostToMyhome")
    try proto.validateValue(privacyReceiveMessagesFromNotFriend, named: "privacyReceiveMessagesFromNotFriend")
    try proto.validateValue(contactMyTicket, named: "contactMyTicket")
    try proto.validateValue(identityProvider, named: "identityProvider")
    try proto.validateValue(identityIdentifier, named: "identityIdentifier")
    try proto.validateValue(snsAccounts, named: "snsAccounts")
    try proto.validateValue(phoneRegistration, named: "phoneRegistration")
    try proto.validateValue(emailConfirmationStatus, named: "emailConfirmationStatus")
    try proto.validateValue(preferenceLocale, named: "preferenceLocale")
    try proto.validateValue(customModes, named: "customModes")

    return Settings(notificationEnable: notificationEnable, notificationMuteExpiration: notificationMuteExpiration, notificationNewMessage: notificationNewMessage, notificationGroupInvitation: notificationGroupInvitation, notificationShowMessage: notificationShowMessage, notificationIncomingCall: notificationIncomingCall, notificationSoundMessage: notificationSoundMessage, notificationSoundGroup: notificationSoundGroup, notificationDisabledWithSub: notificationDisabledWithSub, privacySyncContacts: privacySyncContacts, privacySearchByPhoneNumber: privacySearchByPhoneNumber, privacySearchByUserid: privacySearchByUserid, privacySearchByEmail: privacySearchByEmail, privacyAllowSecondaryDeviceLogin: privacyAllowSecondaryDeviceLogin, privacyProfileImagePostToMyhome: privacyProfileImagePostToMyhome, privacyReceiveMessagesFromNotFriend: privacyReceiveMessagesFromNotFriend, contactMyTicket: contactMyTicket, identityProvider: identityProvider, identityIdentifier: identityIdentifier, snsAccounts: snsAccounts, phoneRegistration: phoneRegistration, emailConfirmationStatus: emailConfirmationStatus, preferenceLocale: preferenceLocale, customModes: customModes)
  }

}



public func ==(lhs: SimpleChannelClient, rhs: SimpleChannelClient) -> Bool {
  return
    (lhs.applicationType == rhs.applicationType) &&
    (lhs.applicationVersion == rhs.applicationVersion) &&
    (lhs.locale == rhs.locale)
}

extension SimpleChannelClient : CustomStringConvertible {

  public var description : String {
    var desc = "SimpleChannelClient("
    desc += "applicationType=\(String(describing: self.applicationType)), "
    desc += "applicationVersion=\(String(describing: self.applicationVersion)), "
    desc += "locale=\(String(describing: self.locale))"
    return desc
  }

}

extension SimpleChannelClient : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (applicationType.hashValue)
    result = prime &* result &+ (applicationVersion.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension SimpleChannelClient : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["applicationType": 1, "applicationVersion": 2, "locale": 3, ]
  }

  public static var structName: String { return "SimpleChannelClient" }

  public static func read(from proto: TProtocol) throws -> SimpleChannelClient {
    _ = try proto.readStructBegin()
    var applicationType: String!
    var applicationVersion: String!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           applicationType = try String.read(from: proto)
        case (2, .string):           applicationVersion = try String.read(from: proto)
        case (3, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(applicationType, named: "applicationType")
    try proto.validateValue(applicationVersion, named: "applicationVersion")
    try proto.validateValue(locale, named: "locale")

    return SimpleChannelClient(applicationType: applicationType, applicationVersion: applicationVersion, locale: locale)
  }

}



public func ==(lhs: SimpleChannelContact, rhs: SimpleChannelContact) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.pictureStatus == rhs.pictureStatus) &&
    (lhs.picturePath == rhs.picturePath) &&
    (lhs.statusMessage == rhs.statusMessage)
}

extension SimpleChannelContact : CustomStringConvertible {

  public var description : String {
    var desc = "SimpleChannelContact("
    desc += "mid=\(String(describing: self.mid)), "
    desc += "displayName=\(String(describing: self.displayName)), "
    desc += "pictureStatus=\(String(describing: self.pictureStatus)), "
    desc += "picturePath=\(String(describing: self.picturePath)), "
    desc += "statusMessage=\(String(describing: self.statusMessage))"
    return desc
  }

}

extension SimpleChannelContact : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (pictureStatus.hashValue)
    result = prime &* result &+ (picturePath.hashValue)
    result = prime &* result &+ (statusMessage.hashValue)
    return result
  }

}

extension SimpleChannelContact : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["mid": 1, "displayName": 2, "pictureStatus": 3, "picturePath": 4, "statusMessage": 5, ]
  }

  public static var structName: String { return "SimpleChannelContact" }

  public static func read(from proto: TProtocol) throws -> SimpleChannelContact {
    _ = try proto.readStructBegin()
    var mid: String!
    var displayName: String!
    var pictureStatus: String!
    var picturePath: String!
    var statusMessage: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           mid = try String.read(from: proto)
        case (2, .string):           displayName = try String.read(from: proto)
        case (3, .string):           pictureStatus = try String.read(from: proto)
        case (4, .string):           picturePath = try String.read(from: proto)
        case (5, .string):           statusMessage = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(pictureStatus, named: "pictureStatus")
    try proto.validateValue(picturePath, named: "picturePath")
    try proto.validateValue(statusMessage, named: "statusMessage")

    return SimpleChannelContact(mid: mid, displayName: displayName, pictureStatus: pictureStatus, picturePath: picturePath, statusMessage: statusMessage)
  }

}



public func ==(lhs: SnsFriend, rhs: SnsFriend) -> Bool {
  return
    (lhs.snsUserId == rhs.snsUserId) &&
    (lhs.snsUserName == rhs.snsUserName) &&
    (lhs.snsIdType == rhs.snsIdType)
}

extension SnsFriend : CustomStringConvertible {

  public var description : String {
    var desc = "SnsFriend("
    desc += "snsUserId=\(String(describing: self.snsUserId)), "
    desc += "snsUserName=\(String(describing: self.snsUserName)), "
    desc += "snsIdType=\(String(describing: self.snsIdType))"
    return desc
  }

}

extension SnsFriend : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsUserId.hashValue)
    result = prime &* result &+ (snsUserName.hashValue)
    result = prime &* result &+ (snsIdType.hashValue)
    return result
  }

}

extension SnsFriend : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["snsUserId": 1, "snsUserName": 2, "snsIdType": 3, ]
  }

  public static var structName: String { return "SnsFriend" }

  public static func read(from proto: TProtocol) throws -> SnsFriend {
    _ = try proto.readStructBegin()
    var snsUserId: String!
    var snsUserName: String!
    var snsIdType: SnsIdType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           snsUserId = try String.read(from: proto)
        case (2, .string):           snsUserName = try String.read(from: proto)
        case (3, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsUserId, named: "snsUserId")
    try proto.validateValue(snsUserName, named: "snsUserName")
    try proto.validateValue(snsIdType, named: "snsIdType")

    return SnsFriend(snsUserId: snsUserId, snsUserName: snsUserName, snsIdType: snsIdType)
  }

}



public func ==(lhs: SnsFriendContactRegistration, rhs: SnsFriendContactRegistration) -> Bool {
  return
    (lhs.contact == rhs.contact) &&
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsUserId == rhs.snsUserId)
}

extension SnsFriendContactRegistration : CustomStringConvertible {

  public var description : String {
    var desc = "SnsFriendContactRegistration("
    desc += "contact=\(String(describing: self.contact)), "
    desc += "snsIdType=\(String(describing: self.snsIdType)), "
    desc += "snsUserId=\(String(describing: self.snsUserId))"
    return desc
  }

}

extension SnsFriendContactRegistration : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (contact.hashValue)
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsUserId.hashValue)
    return result
  }

}

extension SnsFriendContactRegistration : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["contact": 1, "snsIdType": 2, "snsUserId": 3, ]
  }

  public static var structName: String { return "SnsFriendContactRegistration" }

  public static func read(from proto: TProtocol) throws -> SnsFriendContactRegistration {
    _ = try proto.readStructBegin()
    var contact: Contact!
    var snsIdType: SnsIdType!
    var snsUserId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           contact = try Contact.read(from: proto)
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsUserId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(contact, named: "contact")
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsUserId, named: "snsUserId")

    return SnsFriendContactRegistration(contact: contact, snsIdType: snsIdType, snsUserId: snsUserId)
  }

}



public func ==(lhs: SnsFriendModification, rhs: SnsFriendModification) -> Bool {
  return
    (lhs.type == rhs.type) &&
    (lhs.snsFriend == rhs.snsFriend)
}

extension SnsFriendModification : CustomStringConvertible {

  public var description : String {
    var desc = "SnsFriendModification("
    desc += "type=\(String(describing: self.type)), "
    desc += "snsFriend=\(String(describing: self.snsFriend))"
    return desc
  }

}

extension SnsFriendModification : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (snsFriend.hashValue)
    return result
  }

}

extension SnsFriendModification : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["type": 1, "snsFriend": 2, ]
  }

  public static var structName: String { return "SnsFriendModification" }

  public static func read(from proto: TProtocol) throws -> SnsFriendModification {
    _ = try proto.readStructBegin()
    var type: ModificationType!
    var snsFriend: SnsFriend!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             type = try ModificationType.read(from: proto)
        case (2, .struct):           snsFriend = try SnsFriend.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")
    try proto.validateValue(snsFriend, named: "snsFriend")

    return SnsFriendModification(type: type, snsFriend: snsFriend)
  }

}



public func ==(lhs: SnsFriends, rhs: SnsFriends) -> Bool {
  return
    (lhs.snsFriends == rhs.snsFriends) &&
    (lhs.hasMore == rhs.hasMore)
}

extension SnsFriends : CustomStringConvertible {

  public var description : String {
    var desc = "SnsFriends("
    desc += "snsFriends=\(String(describing: self.snsFriends)), "
    desc += "hasMore=\(String(describing: self.hasMore))"
    return desc
  }

}

extension SnsFriends : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsFriends.hashValue)
    result = prime &* result &+ (hasMore.hashValue)
    return result
  }

}

extension SnsFriends : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["snsFriends": 1, "hasMore": 2, ]
  }

  public static var structName: String { return "SnsFriends" }

  public static func read(from proto: TProtocol) throws -> SnsFriends {
    _ = try proto.readStructBegin()
    var snsFriends: TList<SnsFriend>!
    var hasMore: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            snsFriends = try TList<SnsFriend>.read(from: proto)
        case (2, .bool):            hasMore = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsFriends, named: "snsFriends")
    try proto.validateValue(hasMore, named: "hasMore")

    return SnsFriends(snsFriends: snsFriends, hasMore: hasMore)
  }

}



public func ==(lhs: SnsIdUserStatus, rhs: SnsIdUserStatus) -> Bool {
  return
    (lhs.userExisting == rhs.userExisting) &&
    (lhs.phoneNumberRegistered == rhs.phoneNumberRegistered) &&
    (lhs.sameDevice == rhs.sameDevice)
}

extension SnsIdUserStatus : CustomStringConvertible {

  public var description : String {
    var desc = "SnsIdUserStatus("
    desc += "userExisting=\(String(describing: self.userExisting)), "
    desc += "phoneNumberRegistered=\(String(describing: self.phoneNumberRegistered)), "
    desc += "sameDevice=\(String(describing: self.sameDevice))"
    return desc
  }

}

extension SnsIdUserStatus : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (userExisting.hashValue)
    result = prime &* result &+ (phoneNumberRegistered.hashValue)
    result = prime &* result &+ (sameDevice.hashValue)
    return result
  }

}

extension SnsIdUserStatus : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["userExisting": 1, "phoneNumberRegistered": 2, "sameDevice": 3, ]
  }

  public static var structName: String { return "SnsIdUserStatus" }

  public static func read(from proto: TProtocol) throws -> SnsIdUserStatus {
    _ = try proto.readStructBegin()
    var userExisting: Bool!
    var phoneNumberRegistered: Bool!
    var sameDevice: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            userExisting = try Bool.read(from: proto)
        case (2, .bool):            phoneNumberRegistered = try Bool.read(from: proto)
        case (3, .bool):            sameDevice = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(userExisting, named: "userExisting")
    try proto.validateValue(phoneNumberRegistered, named: "phoneNumberRegistered")
    try proto.validateValue(sameDevice, named: "sameDevice")

    return SnsIdUserStatus(userExisting: userExisting, phoneNumberRegistered: phoneNumberRegistered, sameDevice: sameDevice)
  }

}



public func ==(lhs: SnsProfile, rhs: SnsProfile) -> Bool {
  return
    (lhs.snsUserId == rhs.snsUserId) &&
    (lhs.snsUserName == rhs.snsUserName) &&
    (lhs.email == rhs.email) &&
    (lhs.thumbnailUrl == rhs.thumbnailUrl)
}

extension SnsProfile : CustomStringConvertible {

  public var description : String {
    var desc = "SnsProfile("
    desc += "snsUserId=\(String(describing: self.snsUserId)), "
    desc += "snsUserName=\(String(describing: self.snsUserName)), "
    desc += "email=\(String(describing: self.email)), "
    desc += "thumbnailUrl=\(String(describing: self.thumbnailUrl))"
    return desc
  }

}

extension SnsProfile : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsUserId.hashValue)
    result = prime &* result &+ (snsUserName.hashValue)
    result = prime &* result &+ (email.hashValue)
    result = prime &* result &+ (thumbnailUrl.hashValue)
    return result
  }

}

extension SnsProfile : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["snsUserId": 1, "snsUserName": 2, "email": 3, "thumbnailUrl": 4, ]
  }

  public static var structName: String { return "SnsProfile" }

  public static func read(from proto: TProtocol) throws -> SnsProfile {
    _ = try proto.readStructBegin()
    var snsUserId: String!
    var snsUserName: String!
    var email: String!
    var thumbnailUrl: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           snsUserId = try String.read(from: proto)
        case (2, .string):           snsUserName = try String.read(from: proto)
        case (3, .string):           email = try String.read(from: proto)
        case (4, .string):           thumbnailUrl = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsUserId, named: "snsUserId")
    try proto.validateValue(snsUserName, named: "snsUserName")
    try proto.validateValue(email, named: "email")
    try proto.validateValue(thumbnailUrl, named: "thumbnailUrl")

    return SnsProfile(snsUserId: snsUserId, snsUserName: snsUserName, email: email, thumbnailUrl: thumbnailUrl)
  }

}



public func ==(lhs: SystemConfiguration, rhs: SystemConfiguration) -> Bool {
  return
    (lhs.endpoint == rhs.endpoint) &&
    (lhs.endpointSsl == rhs.endpointSsl) &&
    (lhs.updateUrl == rhs.updateUrl) &&
    (lhs.c2dmAccount == rhs.c2dmAccount) &&
    (lhs.nniServer == rhs.nniServer)
}

extension SystemConfiguration : CustomStringConvertible {

  public var description : String {
    var desc = "SystemConfiguration("
    desc += "endpoint=\(String(describing: self.endpoint)), "
    desc += "endpointSsl=\(String(describing: self.endpointSsl)), "
    desc += "updateUrl=\(String(describing: self.updateUrl)), "
    desc += "c2dmAccount=\(String(describing: self.c2dmAccount)), "
    desc += "nniServer=\(String(describing: self.nniServer))"
    return desc
  }

}

extension SystemConfiguration : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (endpoint.hashValue)
    result = prime &* result &+ (endpointSsl.hashValue)
    result = prime &* result &+ (updateUrl.hashValue)
    result = prime &* result &+ (c2dmAccount.hashValue)
    result = prime &* result &+ (nniServer.hashValue)
    return result
  }

}

extension SystemConfiguration : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["endpoint": 1, "endpointSsl": 2, "updateUrl": 3, "c2dmAccount": 11, "nniServer": 12, ]
  }

  public static var structName: String { return "SystemConfiguration" }

  public static func read(from proto: TProtocol) throws -> SystemConfiguration {
    _ = try proto.readStructBegin()
    var endpoint: String!
    var endpointSsl: String!
    var updateUrl: String!
    var c2dmAccount: String!
    var nniServer: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           endpoint = try String.read(from: proto)
        case (2, .string):           endpointSsl = try String.read(from: proto)
        case (3, .string):           updateUrl = try String.read(from: proto)
        case (11, .string):           c2dmAccount = try String.read(from: proto)
        case (12, .string):           nniServer = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(endpoint, named: "endpoint")
    try proto.validateValue(endpointSsl, named: "endpointSsl")
    try proto.validateValue(updateUrl, named: "updateUrl")
    try proto.validateValue(c2dmAccount, named: "c2dmAccount")
    try proto.validateValue(nniServer, named: "nniServer")

    return SystemConfiguration(endpoint: endpoint, endpointSsl: endpointSsl, updateUrl: updateUrl, c2dmAccount: c2dmAccount, nniServer: nniServer)
  }

}



public func ==(lhs: TalkException, rhs: TalkException) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.reason == rhs.reason) &&
    (lhs.parameterMap == rhs.parameterMap)
}

extension TalkException : CustomStringConvertible {

  public var description : String {
    var desc = "TalkException("
    desc += "code=\(String(describing: self.code)), "
    desc += "reason=\(String(describing: self.reason)), "
    desc += "parameterMap=\(String(describing: self.parameterMap))"
    return desc
  }

}

extension TalkException : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (code.hashValue)
    result = prime &* result &+ (reason.hashValue)
    result = prime &* result &+ (parameterMap.hashValue)
    return result
  }

}

extension TalkException : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["code": 1, "reason": 2, "parameterMap": 3, ]
  }

  public static var structName: String { return "TalkException" }

  public static func read(from proto: TProtocol) throws -> TalkException {
    _ = try proto.readStructBegin()
    var code: ErrorCode!
    var reason: String!
    var parameterMap: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             code = try ErrorCode.read(from: proto)
        case (2, .string):           reason = try String.read(from: proto)
        case (3, .map):             parameterMap = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(reason, named: "reason")
    try proto.validateValue(parameterMap, named: "parameterMap")

    return TalkException(code: code, reason: reason, parameterMap: parameterMap)
  }

}



public func ==(lhs: Ticket, rhs: Ticket) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.expirationTime == rhs.expirationTime) &&
    (lhs.maxUseCount == rhs.maxUseCount)
}

extension Ticket : CustomStringConvertible {

  public var description : String {
    var desc = "Ticket("
    desc += "id=\(String(describing: self.id)), "
    desc += "expirationTime=\(String(describing: self.expirationTime)), "
    desc += "maxUseCount=\(String(describing: self.maxUseCount))"
    return desc
  }

}

extension Ticket : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (expirationTime.hashValue)
    result = prime &* result &+ (maxUseCount.hashValue)
    return result
  }

}

extension Ticket : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "expirationTime": 10, "maxUseCount": 21, ]
  }

  public static var structName: String { return "Ticket" }

  public static func read(from proto: TProtocol) throws -> Ticket {
    _ = try proto.readStructBegin()
    var id: String!
    var expirationTime: Int64!
    var maxUseCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (10, .i64):             expirationTime = try Int64.read(from: proto)
        case (21, .i32):             maxUseCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(expirationTime, named: "expirationTime")
    try proto.validateValue(maxUseCount, named: "maxUseCount")

    return Ticket(id: id, expirationTime: expirationTime, maxUseCount: maxUseCount)
  }

}



public func ==(lhs: TMessageBox, rhs: TMessageBox) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.channelId == rhs.channelId) &&
    (lhs.lastSeq == rhs.lastSeq) &&
    (lhs.unreadCount == rhs.unreadCount) &&
    (lhs.lastModifiedTime == rhs.lastModifiedTime) &&
    (lhs.status == rhs.status) &&
    (lhs.midType == rhs.midType) &&
    (lhs.lastMessages == rhs.lastMessages)
}

extension TMessageBox : CustomStringConvertible {

  public var description : String {
    var desc = "TMessageBox("
    desc += "id=\(String(describing: self.id)), "
    desc += "channelId=\(String(describing: self.channelId)), "
    desc += "lastSeq=\(String(describing: self.lastSeq)), "
    desc += "unreadCount=\(String(describing: self.unreadCount)), "
    desc += "lastModifiedTime=\(String(describing: self.lastModifiedTime)), "
    desc += "status=\(String(describing: self.status)), "
    desc += "midType=\(String(describing: self.midType)), "
    desc += "lastMessages=\(String(describing: self.lastMessages))"
    return desc
  }

}

extension TMessageBox : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (lastSeq.hashValue)
    result = prime &* result &+ (unreadCount.hashValue)
    result = prime &* result &+ (lastModifiedTime.hashValue)
    result = prime &* result &+ (status.hashValue)
    result = prime &* result &+ (midType.hashValue)
    result = prime &* result &+ (lastMessages.hashValue)
    return result
  }

}

extension TMessageBox : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "channelId": 2, "lastSeq": 5, "unreadCount": 6, "lastModifiedTime": 7, "status": 8, "midType": 9, "lastMessages": 10, ]
  }

  public static var structName: String { return "TMessageBox" }

  public static func read(from proto: TProtocol) throws -> TMessageBox {
    _ = try proto.readStructBegin()
    var id: String!
    var channelId: String!
    var lastSeq: Int64!
    var unreadCount: Int64!
    var lastModifiedTime: Int64!
    var status: Int32!
    var midType: MIDType!
    var lastMessages: TList<Message>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           channelId = try String.read(from: proto)
        case (5, .i64):             lastSeq = try Int64.read(from: proto)
        case (6, .i64):             unreadCount = try Int64.read(from: proto)
        case (7, .i64):             lastModifiedTime = try Int64.read(from: proto)
        case (8, .i32):             status = try Int32.read(from: proto)
        case (9, .i32):             midType = try MIDType.read(from: proto)
        case (10, .list):            lastMessages = try TList<Message>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(lastSeq, named: "lastSeq")
    try proto.validateValue(unreadCount, named: "unreadCount")
    try proto.validateValue(lastModifiedTime, named: "lastModifiedTime")
    try proto.validateValue(status, named: "status")
    try proto.validateValue(midType, named: "midType")
    try proto.validateValue(lastMessages, named: "lastMessages")

    return TMessageBox(id: id, channelId: channelId, lastSeq: lastSeq, unreadCount: unreadCount, lastModifiedTime: lastModifiedTime, status: status, midType: midType, lastMessages: lastMessages)
  }

}



public func ==(lhs: TMessageBoxWrapUp, rhs: TMessageBoxWrapUp) -> Bool {
  return
    (lhs.messageBox == rhs.messageBox) &&
    (lhs.name == rhs.name) &&
    (lhs.contacts == rhs.contacts) &&
    (lhs.pictureRevision == rhs.pictureRevision)
}

extension TMessageBoxWrapUp : CustomStringConvertible {

  public var description : String {
    var desc = "TMessageBoxWrapUp("
    desc += "messageBox=\(String(describing: self.messageBox)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "contacts=\(String(describing: self.contacts)), "
    desc += "pictureRevision=\(String(describing: self.pictureRevision))"
    return desc
  }

}

extension TMessageBoxWrapUp : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (messageBox.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (contacts.hashValue)
    result = prime &* result &+ (pictureRevision.hashValue)
    return result
  }

}

extension TMessageBoxWrapUp : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["messageBox": 1, "name": 2, "contacts": 3, "pictureRevision": 4, ]
  }

  public static var structName: String { return "TMessageBoxWrapUp" }

  public static func read(from proto: TProtocol) throws -> TMessageBoxWrapUp {
    _ = try proto.readStructBegin()
    var messageBox: TMessageBox!
    var name: String!
    var contacts: TList<Contact>!
    var pictureRevision: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           messageBox = try TMessageBox.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .list):            contacts = try TList<Contact>.read(from: proto)
        case (4, .string):           pictureRevision = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(messageBox, named: "messageBox")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(contacts, named: "contacts")
    try proto.validateValue(pictureRevision, named: "pictureRevision")

    return TMessageBoxWrapUp(messageBox: messageBox, name: name, contacts: contacts, pictureRevision: pictureRevision)
  }

}



public func ==(lhs: TMessageBoxWrapUpResponse, rhs: TMessageBoxWrapUpResponse) -> Bool {
  return
    (lhs.messageBoxWrapUpList == rhs.messageBoxWrapUpList) &&
    (lhs.totalSize == rhs.totalSize)
}

extension TMessageBoxWrapUpResponse : CustomStringConvertible {

  public var description : String {
    var desc = "TMessageBoxWrapUpResponse("
    desc += "messageBoxWrapUpList=\(String(describing: self.messageBoxWrapUpList)), "
    desc += "totalSize=\(String(describing: self.totalSize))"
    return desc
  }

}

extension TMessageBoxWrapUpResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (messageBoxWrapUpList.hashValue)
    result = prime &* result &+ (totalSize.hashValue)
    return result
  }

}

extension TMessageBoxWrapUpResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["messageBoxWrapUpList": 1, "totalSize": 2, ]
  }

  public static var structName: String { return "TMessageBoxWrapUpResponse" }

  public static func read(from proto: TProtocol) throws -> TMessageBoxWrapUpResponse {
    _ = try proto.readStructBegin()
    var messageBoxWrapUpList: TList<TMessageBoxWrapUp>!
    var totalSize: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            messageBoxWrapUpList = try TList<TMessageBoxWrapUp>.read(from: proto)
        case (2, .i32):             totalSize = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(messageBoxWrapUpList, named: "messageBoxWrapUpList")
    try proto.validateValue(totalSize, named: "totalSize")

    return TMessageBoxWrapUpResponse(messageBoxWrapUpList: messageBoxWrapUpList, totalSize: totalSize)
  }

}



public func ==(lhs: UniversalNotificationServiceException, rhs: UniversalNotificationServiceException) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.reason == rhs.reason) &&
    (lhs.parameterMap == rhs.parameterMap)
}

extension UniversalNotificationServiceException : CustomStringConvertible {

  public var description : String {
    var desc = "UniversalNotificationServiceException("
    desc += "code=\(String(describing: self.code)), "
    desc += "reason=\(String(describing: self.reason)), "
    desc += "parameterMap=\(String(describing: self.parameterMap))"
    return desc
  }

}

extension UniversalNotificationServiceException : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (code.hashValue)
    result = prime &* result &+ (reason.hashValue)
    result = prime &* result &+ (parameterMap.hashValue)
    return result
  }

}

extension UniversalNotificationServiceException : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["code": 1, "reason": 2, "parameterMap": 3, ]
  }

  public static var structName: String { return "UniversalNotificationServiceException" }

  public static func read(from proto: TProtocol) throws -> UniversalNotificationServiceException {
    _ = try proto.readStructBegin()
    var code: UniversalNotificationServiceErrorCode!
    var reason: String!
    var parameterMap: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             code = try UniversalNotificationServiceErrorCode.read(from: proto)
        case (2, .string):           reason = try String.read(from: proto)
        case (3, .map):             parameterMap = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(reason, named: "reason")
    try proto.validateValue(parameterMap, named: "parameterMap")

    return UniversalNotificationServiceException(code: code, reason: reason, parameterMap: parameterMap)
  }

}



public func ==(lhs: UpdateBuddyProfileResult, rhs: UpdateBuddyProfileResult) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.state == rhs.state) &&
    (lhs.eventNo == rhs.eventNo) &&
    (lhs.receiverCount == rhs.receiverCount) &&
    (lhs.successCount == rhs.successCount) &&
    (lhs.failCount == rhs.failCount) &&
    (lhs.cancelCount == rhs.cancelCount) &&
    (lhs.unregisterCount == rhs.unregisterCount) &&
    (lhs.timestamp == rhs.timestamp) &&
    (lhs.message == rhs.message)
}

extension UpdateBuddyProfileResult : CustomStringConvertible {

  public var description : String {
    var desc = "UpdateBuddyProfileResult("
    desc += "requestId=\(String(describing: self.requestId)), "
    desc += "state=\(String(describing: self.state)), "
    desc += "eventNo=\(String(describing: self.eventNo)), "
    desc += "receiverCount=\(String(describing: self.receiverCount)), "
    desc += "successCount=\(String(describing: self.successCount)), "
    desc += "failCount=\(String(describing: self.failCount)), "
    desc += "cancelCount=\(String(describing: self.cancelCount)), "
    desc += "unregisterCount=\(String(describing: self.unregisterCount)), "
    desc += "timestamp=\(String(describing: self.timestamp)), "
    desc += "message=\(String(describing: self.message))"
    return desc
  }

}

extension UpdateBuddyProfileResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (state.hashValue)
    result = prime &* result &+ (eventNo.hashValue)
    result = prime &* result &+ (receiverCount.hashValue)
    result = prime &* result &+ (successCount.hashValue)
    result = prime &* result &+ (failCount.hashValue)
    result = prime &* result &+ (cancelCount.hashValue)
    result = prime &* result &+ (unregisterCount.hashValue)
    result = prime &* result &+ (timestamp.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension UpdateBuddyProfileResult : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["requestId": 1, "state": 2, "eventNo": 3, "receiverCount": 11, "successCount": 12, "failCount": 13, "cancelCount": 14, "unregisterCount": 15, "timestamp": 21, "message": 22, ]
  }

  public static var structName: String { return "UpdateBuddyProfileResult" }

  public static func read(from proto: TProtocol) throws -> UpdateBuddyProfileResult {
    _ = try proto.readStructBegin()
    var requestId: String!
    var state: BuddyResultState!
    var eventNo: Int32!
    var receiverCount: Int64!
    var successCount: Int64!
    var failCount: Int64!
    var cancelCount: Int64!
    var unregisterCount: Int64!
    var timestamp: Int64!
    var message: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .i32):             state = try BuddyResultState.read(from: proto)
        case (3, .i32):             eventNo = try Int32.read(from: proto)
        case (11, .i64):             receiverCount = try Int64.read(from: proto)
        case (12, .i64):             successCount = try Int64.read(from: proto)
        case (13, .i64):             failCount = try Int64.read(from: proto)
        case (14, .i64):             cancelCount = try Int64.read(from: proto)
        case (15, .i64):             unregisterCount = try Int64.read(from: proto)
        case (21, .i64):             timestamp = try Int64.read(from: proto)
        case (22, .string):           message = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(state, named: "state")
    try proto.validateValue(eventNo, named: "eventNo")
    try proto.validateValue(receiverCount, named: "receiverCount")
    try proto.validateValue(successCount, named: "successCount")
    try proto.validateValue(failCount, named: "failCount")
    try proto.validateValue(cancelCount, named: "cancelCount")
    try proto.validateValue(unregisterCount, named: "unregisterCount")
    try proto.validateValue(timestamp, named: "timestamp")
    try proto.validateValue(message, named: "message")

    return UpdateBuddyProfileResult(requestId: requestId, state: state, eventNo: eventNo, receiverCount: receiverCount, successCount: successCount, failCount: failCount, cancelCount: cancelCount, unregisterCount: unregisterCount, timestamp: timestamp, message: message)
  }

}



public func ==(lhs: UserAuthStatus, rhs: UserAuthStatus) -> Bool {
  return
    (lhs.phoneNumberRegistered == rhs.phoneNumberRegistered) &&
    (lhs.registeredSnsIdTypes == rhs.registeredSnsIdTypes)
}

extension UserAuthStatus : CustomStringConvertible {

  public var description : String {
    var desc = "UserAuthStatus("
    desc += "phoneNumberRegistered=\(String(describing: self.phoneNumberRegistered)), "
    desc += "registeredSnsIdTypes=\(String(describing: self.registeredSnsIdTypes))"
    return desc
  }

}

extension UserAuthStatus : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (phoneNumberRegistered.hashValue)
    result = prime &* result &+ (registeredSnsIdTypes.hashValue)
    return result
  }

}

extension UserAuthStatus : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["phoneNumberRegistered": 1, "registeredSnsIdTypes": 2, ]
  }

  public static var structName: String { return "UserAuthStatus" }

  public static func read(from proto: TProtocol) throws -> UserAuthStatus {
    _ = try proto.readStructBegin()
    var phoneNumberRegistered: Bool!
    var registeredSnsIdTypes: TList<SnsIdType>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            phoneNumberRegistered = try Bool.read(from: proto)
        case (2, .list):            registeredSnsIdTypes = try TList<SnsIdType>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(phoneNumberRegistered, named: "phoneNumberRegistered")
    try proto.validateValue(registeredSnsIdTypes, named: "registeredSnsIdTypes")

    return UserAuthStatus(phoneNumberRegistered: phoneNumberRegistered, registeredSnsIdTypes: registeredSnsIdTypes)
  }

}



public func ==(lhs: VerificationSessionData, rhs: VerificationSessionData) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId) &&
    (lhs.method == rhs.method) &&
    (lhs.callback == rhs.callback) &&
    (lhs.normalizedPhone == rhs.normalizedPhone) &&
    (lhs.countryCode == rhs.countryCode) &&
    (lhs.nationalSignificantNumber == rhs.nationalSignificantNumber) &&
    (lhs.availableVerificationMethods == rhs.availableVerificationMethods)
}

extension VerificationSessionData : CustomStringConvertible {

  public var description : String {
    var desc = "VerificationSessionData("
    desc += "sessionId=\(String(describing: self.sessionId)), "
    desc += "method=\(String(describing: self.method)), "
    desc += "callback=\(String(describing: self.callback)), "
    desc += "normalizedPhone=\(String(describing: self.normalizedPhone)), "
    desc += "countryCode=\(String(describing: self.countryCode)), "
    desc += "nationalSignificantNumber=\(String(describing: self.nationalSignificantNumber)), "
    desc += "availableVerificationMethods=\(String(describing: self.availableVerificationMethods))"
    return desc
  }

}

extension VerificationSessionData : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    result = prime &* result &+ (method.hashValue)
    result = prime &* result &+ (callback.hashValue)
    result = prime &* result &+ (normalizedPhone.hashValue)
    result = prime &* result &+ (countryCode.hashValue)
    result = prime &* result &+ (nationalSignificantNumber.hashValue)
    result = prime &* result &+ (availableVerificationMethods.hashValue)
    return result
  }

}

extension VerificationSessionData : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["sessionId": 1, "method": 2, "callback": 3, "normalizedPhone": 4, "countryCode": 5, "nationalSignificantNumber": 6, "availableVerificationMethods": 7, ]
  }

  public static var structName: String { return "VerificationSessionData" }

  public static func read(from proto: TProtocol) throws -> VerificationSessionData {
    _ = try proto.readStructBegin()
    var sessionId: String!
    var method: VerificationMethod!
    var callback: String!
    var normalizedPhone: String!
    var countryCode: String!
    var nationalSignificantNumber: String!
    var availableVerificationMethods: TList<VerificationMethod>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           sessionId = try String.read(from: proto)
        case (2, .i32):             method = try VerificationMethod.read(from: proto)
        case (3, .string):           callback = try String.read(from: proto)
        case (4, .string):           normalizedPhone = try String.read(from: proto)
        case (5, .string):           countryCode = try String.read(from: proto)
        case (6, .string):           nationalSignificantNumber = try String.read(from: proto)
        case (7, .list):            availableVerificationMethods = try TList<VerificationMethod>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")
    try proto.validateValue(method, named: "method")
    try proto.validateValue(callback, named: "callback")
    try proto.validateValue(normalizedPhone, named: "normalizedPhone")
    try proto.validateValue(countryCode, named: "countryCode")
    try proto.validateValue(nationalSignificantNumber, named: "nationalSignificantNumber")
    try proto.validateValue(availableVerificationMethods, named: "availableVerificationMethods")

    return VerificationSessionData(sessionId: sessionId, method: method, callback: callback, normalizedPhone: normalizedPhone, countryCode: countryCode, nationalSignificantNumber: nationalSignificantNumber, availableVerificationMethods: availableVerificationMethods)
  }

}



public func ==(lhs: WapInvitation, rhs: WapInvitation) -> Bool {
  return
    (lhs.type == rhs.type) &&
    (lhs.inviteeEmail == rhs.inviteeEmail) &&
    (lhs.inviterMid == rhs.inviterMid) &&
    (lhs.roomMid == rhs.roomMid)
}

extension WapInvitation : CustomStringConvertible {

  public var description : String {
    var desc = "WapInvitation("
    desc += "type=\(String(describing: self.type)), "
    desc += "inviteeEmail=\(String(describing: self.inviteeEmail)), "
    desc += "inviterMid=\(String(describing: self.inviterMid)), "
    desc += "roomMid=\(String(describing: self.roomMid))"
    return desc
  }

}

extension WapInvitation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (inviteeEmail.hashValue)
    result = prime &* result &+ (inviterMid.hashValue)
    result = prime &* result &+ (roomMid.hashValue)
    return result
  }

}

extension WapInvitation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["type": 1, "inviteeEmail": 10, "inviterMid": 11, "roomMid": 12, ]
  }

  public static var structName: String { return "WapInvitation" }

  public static func read(from proto: TProtocol) throws -> WapInvitation {
    _ = try proto.readStructBegin()
    var type: WapInvitationType!
    var inviteeEmail: String!
    var inviterMid: String!
    var roomMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             type = try WapInvitationType.read(from: proto)
        case (10, .string):           inviteeEmail = try String.read(from: proto)
        case (11, .string):           inviterMid = try String.read(from: proto)
        case (12, .string):           roomMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")
    try proto.validateValue(inviteeEmail, named: "inviteeEmail")
    try proto.validateValue(inviterMid, named: "inviterMid")
    try proto.validateValue(roomMid, named: "roomMid")

    return WapInvitation(type: type, inviteeEmail: inviteeEmail, inviterMid: inviterMid, roomMid: roomMid)
  }

}



fileprivate final class AccountSupervisorService_getRSAKey_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: AccountSupervisorService_getRSAKey_args, rhs: AccountSupervisorService_getRSAKey_args) -> Bool {
  return true
}

extension AccountSupervisorService_getRSAKey_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AccountSupervisorService_getRSAKey_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_getRSAKey_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_getRSAKey_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AccountSupervisorService_getRSAKey_args()
  }

}



fileprivate final class AccountSupervisorService_getRSAKey_result {

  fileprivate var success: RSAKey?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: RSAKey?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: AccountSupervisorService_getRSAKey_result, rhs: AccountSupervisorService_getRSAKey_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension AccountSupervisorService_getRSAKey_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AccountSupervisorService_getRSAKey_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_getRSAKey_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_getRSAKey_result {
    _ = try proto.readStructBegin()
    var success: RSAKey?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try RSAKey.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AccountSupervisorService_getRSAKey_result(success: success, e: e)
  }

}



fileprivate final class AccountSupervisorService_notifyEmailConfirmationResult_args {

  fileprivate var parameterMap: TMap<String, String>


  fileprivate init(parameterMap: TMap<String, String>) {
    self.parameterMap = parameterMap
  }

}

fileprivate func ==(lhs: AccountSupervisorService_notifyEmailConfirmationResult_args, rhs: AccountSupervisorService_notifyEmailConfirmationResult_args) -> Bool {
  return
    (lhs.parameterMap == rhs.parameterMap)
}

extension AccountSupervisorService_notifyEmailConfirmationResult_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (parameterMap.hashValue)
    return result
  }

}

extension AccountSupervisorService_notifyEmailConfirmationResult_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["parameterMap": 2, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_notifyEmailConfirmationResult_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_notifyEmailConfirmationResult_args {
    _ = try proto.readStructBegin()
    var parameterMap: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .map):             parameterMap = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(parameterMap, named: "parameterMap")

    return AccountSupervisorService_notifyEmailConfirmationResult_args(parameterMap: parameterMap)
  }

}



fileprivate final class AccountSupervisorService_notifyEmailConfirmationResult_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: AccountSupervisorService_notifyEmailConfirmationResult_result, rhs: AccountSupervisorService_notifyEmailConfirmationResult_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension AccountSupervisorService_notifyEmailConfirmationResult_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AccountSupervisorService_notifyEmailConfirmationResult_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_notifyEmailConfirmationResult_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_notifyEmailConfirmationResult_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AccountSupervisorService_notifyEmailConfirmationResult_result(e: e)
  }

}



fileprivate final class AccountSupervisorService_registerVirtualAccount_args {

  fileprivate var locale: String

  fileprivate var encryptedVirtualUserId: String

  fileprivate var encryptedPassword: String


  fileprivate init(locale: String, encryptedVirtualUserId: String, encryptedPassword: String) {
    self.locale = locale
    self.encryptedVirtualUserId = encryptedVirtualUserId
    self.encryptedPassword = encryptedPassword
  }

}

fileprivate func ==(lhs: AccountSupervisorService_registerVirtualAccount_args, rhs: AccountSupervisorService_registerVirtualAccount_args) -> Bool {
  return
    (lhs.locale == rhs.locale) &&
    (lhs.encryptedVirtualUserId == rhs.encryptedVirtualUserId) &&
    (lhs.encryptedPassword == rhs.encryptedPassword)
}

extension AccountSupervisorService_registerVirtualAccount_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (locale.hashValue)
    result = prime &* result &+ (encryptedVirtualUserId.hashValue)
    result = prime &* result &+ (encryptedPassword.hashValue)
    return result
  }

}

extension AccountSupervisorService_registerVirtualAccount_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["locale": 2, "encryptedVirtualUserId": 3, "encryptedPassword": 4, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_registerVirtualAccount_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_registerVirtualAccount_args {
    _ = try proto.readStructBegin()
    var locale: String!
    var encryptedVirtualUserId: String!
    var encryptedPassword: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           locale = try String.read(from: proto)
        case (3, .string):           encryptedVirtualUserId = try String.read(from: proto)
        case (4, .string):           encryptedPassword = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(locale, named: "locale")
    try proto.validateValue(encryptedVirtualUserId, named: "encryptedVirtualUserId")
    try proto.validateValue(encryptedPassword, named: "encryptedPassword")

    return AccountSupervisorService_registerVirtualAccount_args(locale: locale, encryptedVirtualUserId: encryptedVirtualUserId, encryptedPassword: encryptedPassword)
  }

}



fileprivate final class AccountSupervisorService_registerVirtualAccount_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: AccountSupervisorService_registerVirtualAccount_result, rhs: AccountSupervisorService_registerVirtualAccount_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension AccountSupervisorService_registerVirtualAccount_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AccountSupervisorService_registerVirtualAccount_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_registerVirtualAccount_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_registerVirtualAccount_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AccountSupervisorService_registerVirtualAccount_result(success: success, e: e)
  }

}



fileprivate final class AccountSupervisorService_requestVirtualAccountPasswordChange_args {

  fileprivate var virtualMid: String

  fileprivate var encryptedVirtualUserId: String

  fileprivate var encryptedOldPassword: String

  fileprivate var encryptedNewPassword: String


  fileprivate init(virtualMid: String, encryptedVirtualUserId: String, encryptedOldPassword: String, encryptedNewPassword: String) {
    self.virtualMid = virtualMid
    self.encryptedVirtualUserId = encryptedVirtualUserId
    self.encryptedOldPassword = encryptedOldPassword
    self.encryptedNewPassword = encryptedNewPassword
  }

}

fileprivate func ==(lhs: AccountSupervisorService_requestVirtualAccountPasswordChange_args, rhs: AccountSupervisorService_requestVirtualAccountPasswordChange_args) -> Bool {
  return
    (lhs.virtualMid == rhs.virtualMid) &&
    (lhs.encryptedVirtualUserId == rhs.encryptedVirtualUserId) &&
    (lhs.encryptedOldPassword == rhs.encryptedOldPassword) &&
    (lhs.encryptedNewPassword == rhs.encryptedNewPassword)
}

extension AccountSupervisorService_requestVirtualAccountPasswordChange_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (virtualMid.hashValue)
    result = prime &* result &+ (encryptedVirtualUserId.hashValue)
    result = prime &* result &+ (encryptedOldPassword.hashValue)
    result = prime &* result &+ (encryptedNewPassword.hashValue)
    return result
  }

}

extension AccountSupervisorService_requestVirtualAccountPasswordChange_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["virtualMid": 2, "encryptedVirtualUserId": 3, "encryptedOldPassword": 4, "encryptedNewPassword": 5, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_requestVirtualAccountPasswordChange_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_requestVirtualAccountPasswordChange_args {
    _ = try proto.readStructBegin()
    var virtualMid: String!
    var encryptedVirtualUserId: String!
    var encryptedOldPassword: String!
    var encryptedNewPassword: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           virtualMid = try String.read(from: proto)
        case (3, .string):           encryptedVirtualUserId = try String.read(from: proto)
        case (4, .string):           encryptedOldPassword = try String.read(from: proto)
        case (5, .string):           encryptedNewPassword = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(virtualMid, named: "virtualMid")
    try proto.validateValue(encryptedVirtualUserId, named: "encryptedVirtualUserId")
    try proto.validateValue(encryptedOldPassword, named: "encryptedOldPassword")
    try proto.validateValue(encryptedNewPassword, named: "encryptedNewPassword")

    return AccountSupervisorService_requestVirtualAccountPasswordChange_args(virtualMid: virtualMid, encryptedVirtualUserId: encryptedVirtualUserId, encryptedOldPassword: encryptedOldPassword, encryptedNewPassword: encryptedNewPassword)
  }

}



fileprivate final class AccountSupervisorService_requestVirtualAccountPasswordChange_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: AccountSupervisorService_requestVirtualAccountPasswordChange_result, rhs: AccountSupervisorService_requestVirtualAccountPasswordChange_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension AccountSupervisorService_requestVirtualAccountPasswordChange_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AccountSupervisorService_requestVirtualAccountPasswordChange_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_requestVirtualAccountPasswordChange_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_requestVirtualAccountPasswordChange_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AccountSupervisorService_requestVirtualAccountPasswordChange_result(e: e)
  }

}



fileprivate final class AccountSupervisorService_requestVirtualAccountPasswordSet_args {

  fileprivate var virtualMid: String

  fileprivate var encryptedVirtualUserId: String

  fileprivate var encryptedNewPassword: String


  fileprivate init(virtualMid: String, encryptedVirtualUserId: String, encryptedNewPassword: String) {
    self.virtualMid = virtualMid
    self.encryptedVirtualUserId = encryptedVirtualUserId
    self.encryptedNewPassword = encryptedNewPassword
  }

}

fileprivate func ==(lhs: AccountSupervisorService_requestVirtualAccountPasswordSet_args, rhs: AccountSupervisorService_requestVirtualAccountPasswordSet_args) -> Bool {
  return
    (lhs.virtualMid == rhs.virtualMid) &&
    (lhs.encryptedVirtualUserId == rhs.encryptedVirtualUserId) &&
    (lhs.encryptedNewPassword == rhs.encryptedNewPassword)
}

extension AccountSupervisorService_requestVirtualAccountPasswordSet_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (virtualMid.hashValue)
    result = prime &* result &+ (encryptedVirtualUserId.hashValue)
    result = prime &* result &+ (encryptedNewPassword.hashValue)
    return result
  }

}

extension AccountSupervisorService_requestVirtualAccountPasswordSet_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["virtualMid": 2, "encryptedVirtualUserId": 3, "encryptedNewPassword": 4, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_requestVirtualAccountPasswordSet_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_requestVirtualAccountPasswordSet_args {
    _ = try proto.readStructBegin()
    var virtualMid: String!
    var encryptedVirtualUserId: String!
    var encryptedNewPassword: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           virtualMid = try String.read(from: proto)
        case (3, .string):           encryptedVirtualUserId = try String.read(from: proto)
        case (4, .string):           encryptedNewPassword = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(virtualMid, named: "virtualMid")
    try proto.validateValue(encryptedVirtualUserId, named: "encryptedVirtualUserId")
    try proto.validateValue(encryptedNewPassword, named: "encryptedNewPassword")

    return AccountSupervisorService_requestVirtualAccountPasswordSet_args(virtualMid: virtualMid, encryptedVirtualUserId: encryptedVirtualUserId, encryptedNewPassword: encryptedNewPassword)
  }

}



fileprivate final class AccountSupervisorService_requestVirtualAccountPasswordSet_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: AccountSupervisorService_requestVirtualAccountPasswordSet_result, rhs: AccountSupervisorService_requestVirtualAccountPasswordSet_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension AccountSupervisorService_requestVirtualAccountPasswordSet_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AccountSupervisorService_requestVirtualAccountPasswordSet_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_requestVirtualAccountPasswordSet_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_requestVirtualAccountPasswordSet_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AccountSupervisorService_requestVirtualAccountPasswordSet_result(e: e)
  }

}



fileprivate final class AccountSupervisorService_unregisterVirtualAccount_args {

  fileprivate var virtualMid: String


  fileprivate init(virtualMid: String) {
    self.virtualMid = virtualMid
  }

}

fileprivate func ==(lhs: AccountSupervisorService_unregisterVirtualAccount_args, rhs: AccountSupervisorService_unregisterVirtualAccount_args) -> Bool {
  return
    (lhs.virtualMid == rhs.virtualMid)
}

extension AccountSupervisorService_unregisterVirtualAccount_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (virtualMid.hashValue)
    return result
  }

}

extension AccountSupervisorService_unregisterVirtualAccount_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["virtualMid": 2, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_unregisterVirtualAccount_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_unregisterVirtualAccount_args {
    _ = try proto.readStructBegin()
    var virtualMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           virtualMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(virtualMid, named: "virtualMid")

    return AccountSupervisorService_unregisterVirtualAccount_args(virtualMid: virtualMid)
  }

}



fileprivate final class AccountSupervisorService_unregisterVirtualAccount_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: AccountSupervisorService_unregisterVirtualAccount_result, rhs: AccountSupervisorService_unregisterVirtualAccount_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension AccountSupervisorService_unregisterVirtualAccount_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AccountSupervisorService_unregisterVirtualAccount_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "AccountSupervisorService_unregisterVirtualAccount_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AccountSupervisorService_unregisterVirtualAccount_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AccountSupervisorService_unregisterVirtualAccount_result(e: e)
  }

}



extension AccountSupervisorServiceClient : AccountSupervisorService {

  private func send_getRSAKey() throws {
    try outProtocol.writeMessageBegin(name: "getRSAKey", type: .call, sequenceID: 0)
    let args = AccountSupervisorService_getRSAKey_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getRSAKey() throws -> RSAKey {
    try inProtocol.readResultMessageBegin() 
    let result = try AccountSupervisorService_getRSAKey_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getRSAKey"))
  }

  public func getRSAKey() throws -> RSAKey {
    try send_getRSAKey()
    try outProtocol.transport.flush()
    return try recv_getRSAKey()
  }

  private func send_notifyEmailConfirmationResult(parameterMap: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "notifyEmailConfirmationResult", type: .call, sequenceID: 0)
    let args = AccountSupervisorService_notifyEmailConfirmationResult_args(parameterMap: parameterMap)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyEmailConfirmationResult() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AccountSupervisorService_notifyEmailConfirmationResult_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notifyEmailConfirmationResult(parameterMap: TMap<String, String>) throws {
    try send_notifyEmailConfirmationResult(parameterMap: parameterMap)
    try outProtocol.transport.flush()
    try recv_notifyEmailConfirmationResult()
  }

  private func send_registerVirtualAccount(locale: String, encryptedVirtualUserId: String, encryptedPassword: String) throws {
    try outProtocol.writeMessageBegin(name: "registerVirtualAccount", type: .call, sequenceID: 0)
    let args = AccountSupervisorService_registerVirtualAccount_args(locale: locale, encryptedVirtualUserId: encryptedVirtualUserId, encryptedPassword: encryptedPassword)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerVirtualAccount() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try AccountSupervisorService_registerVirtualAccount_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerVirtualAccount"))
  }

  public func registerVirtualAccount(locale: String, encryptedVirtualUserId: String, encryptedPassword: String) throws -> String {
    try send_registerVirtualAccount(locale: locale, encryptedVirtualUserId: encryptedVirtualUserId, encryptedPassword: encryptedPassword)
    try outProtocol.transport.flush()
    return try recv_registerVirtualAccount()
  }

  private func send_requestVirtualAccountPasswordChange(virtualMid: String, encryptedVirtualUserId: String, encryptedOldPassword: String, encryptedNewPassword: String) throws {
    try outProtocol.writeMessageBegin(name: "requestVirtualAccountPasswordChange", type: .call, sequenceID: 0)
    let args = AccountSupervisorService_requestVirtualAccountPasswordChange_args(virtualMid: virtualMid, encryptedVirtualUserId: encryptedVirtualUserId, encryptedOldPassword: encryptedOldPassword, encryptedNewPassword: encryptedNewPassword)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_requestVirtualAccountPasswordChange() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AccountSupervisorService_requestVirtualAccountPasswordChange_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func requestVirtualAccountPasswordChange(virtualMid: String, encryptedVirtualUserId: String, encryptedOldPassword: String, encryptedNewPassword: String) throws {
    try send_requestVirtualAccountPasswordChange(virtualMid: virtualMid, encryptedVirtualUserId: encryptedVirtualUserId, encryptedOldPassword: encryptedOldPassword, encryptedNewPassword: encryptedNewPassword)
    try outProtocol.transport.flush()
    try recv_requestVirtualAccountPasswordChange()
  }

  private func send_requestVirtualAccountPasswordSet(virtualMid: String, encryptedVirtualUserId: String, encryptedNewPassword: String) throws {
    try outProtocol.writeMessageBegin(name: "requestVirtualAccountPasswordSet", type: .call, sequenceID: 0)
    let args = AccountSupervisorService_requestVirtualAccountPasswordSet_args(virtualMid: virtualMid, encryptedVirtualUserId: encryptedVirtualUserId, encryptedNewPassword: encryptedNewPassword)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_requestVirtualAccountPasswordSet() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AccountSupervisorService_requestVirtualAccountPasswordSet_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func requestVirtualAccountPasswordSet(virtualMid: String, encryptedVirtualUserId: String, encryptedNewPassword: String) throws {
    try send_requestVirtualAccountPasswordSet(virtualMid: virtualMid, encryptedVirtualUserId: encryptedVirtualUserId, encryptedNewPassword: encryptedNewPassword)
    try outProtocol.transport.flush()
    try recv_requestVirtualAccountPasswordSet()
  }

  private func send_unregisterVirtualAccount(virtualMid: String) throws {
    try outProtocol.writeMessageBegin(name: "unregisterVirtualAccount", type: .call, sequenceID: 0)
    let args = AccountSupervisorService_unregisterVirtualAccount_args(virtualMid: virtualMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unregisterVirtualAccount() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AccountSupervisorService_unregisterVirtualAccount_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func unregisterVirtualAccount(virtualMid: String) throws {
    try send_unregisterVirtualAccount(virtualMid: virtualMid)
    try outProtocol.transport.flush()
    try recv_unregisterVirtualAccount()
  }

}

extension AccountSupervisorServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["getRSAKey"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AccountSupervisorService_getRSAKey_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AccountSupervisorService_getRSAKey_result()
      do {
        result.success = try handler.getRSAKey()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getRSAKey", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyEmailConfirmationResult"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AccountSupervisorService_notifyEmailConfirmationResult_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AccountSupervisorService_notifyEmailConfirmationResult_result()
      do {
        try handler.notifyEmailConfirmationResult(parameterMap: args.parameterMap)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyEmailConfirmationResult", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerVirtualAccount"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AccountSupervisorService_registerVirtualAccount_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AccountSupervisorService_registerVirtualAccount_result()
      do {
        result.success = try handler.registerVirtualAccount(locale: args.locale, encryptedVirtualUserId: args.encryptedVirtualUserId, encryptedPassword: args.encryptedPassword)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerVirtualAccount", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["requestVirtualAccountPasswordChange"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AccountSupervisorService_requestVirtualAccountPasswordChange_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AccountSupervisorService_requestVirtualAccountPasswordChange_result()
      do {
        try handler.requestVirtualAccountPasswordChange(virtualMid: args.virtualMid, encryptedVirtualUserId: args.encryptedVirtualUserId, encryptedOldPassword: args.encryptedOldPassword, encryptedNewPassword: args.encryptedNewPassword)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "requestVirtualAccountPasswordChange", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["requestVirtualAccountPasswordSet"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AccountSupervisorService_requestVirtualAccountPasswordSet_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AccountSupervisorService_requestVirtualAccountPasswordSet_result()
      do {
        try handler.requestVirtualAccountPasswordSet(virtualMid: args.virtualMid, encryptedVirtualUserId: args.encryptedVirtualUserId, encryptedNewPassword: args.encryptedNewPassword)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "requestVirtualAccountPasswordSet", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unregisterVirtualAccount"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AccountSupervisorService_unregisterVirtualAccount_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AccountSupervisorService_unregisterVirtualAccount_result()
      do {
        try handler.unregisterVirtualAccount(virtualMid: args.virtualMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unregisterVirtualAccount", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AccountSupervisorServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class AgeCheckService_checkUserAge_args {

  fileprivate var carrier: CarrierCode

  fileprivate var sessionId: String

  fileprivate var verifier: String

  fileprivate var standardAge: Int32


  fileprivate init(carrier: CarrierCode, sessionId: String, verifier: String, standardAge: Int32) {
    self.carrier = carrier
    self.sessionId = sessionId
    self.verifier = verifier
    self.standardAge = standardAge
  }

}

fileprivate func ==(lhs: AgeCheckService_checkUserAge_args, rhs: AgeCheckService_checkUserAge_args) -> Bool {
  return
    (lhs.carrier == rhs.carrier) &&
    (lhs.sessionId == rhs.sessionId) &&
    (lhs.verifier == rhs.verifier) &&
    (lhs.standardAge == rhs.standardAge)
}

extension AgeCheckService_checkUserAge_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (carrier.hashValue)
    result = prime &* result &+ (sessionId.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    result = prime &* result &+ (standardAge.hashValue)
    return result
  }

}

extension AgeCheckService_checkUserAge_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["carrier": 2, "sessionId": 3, "verifier": 4, "standardAge": 5, ]
  }

  fileprivate static var structName: String { return "AgeCheckService_checkUserAge_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_checkUserAge_args {
    _ = try proto.readStructBegin()
    var carrier: CarrierCode!
    var sessionId: String!
    var verifier: String!
    var standardAge: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             carrier = try CarrierCode.read(from: proto)
        case (3, .string):           sessionId = try String.read(from: proto)
        case (4, .string):           verifier = try String.read(from: proto)
        case (5, .i32):             standardAge = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(carrier, named: "carrier")
    try proto.validateValue(sessionId, named: "sessionId")
    try proto.validateValue(verifier, named: "verifier")
    try proto.validateValue(standardAge, named: "standardAge")

    return AgeCheckService_checkUserAge_args(carrier: carrier, sessionId: sessionId, verifier: verifier, standardAge: standardAge)
  }

}



fileprivate final class AgeCheckService_checkUserAge_result {

  fileprivate var success: UserAgeType?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: UserAgeType?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: AgeCheckService_checkUserAge_result, rhs: AgeCheckService_checkUserAge_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension AgeCheckService_checkUserAge_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AgeCheckService_checkUserAge_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "AgeCheckService_checkUserAge_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_checkUserAge_result {
    _ = try proto.readStructBegin()
    var success: UserAgeType?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try UserAgeType.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AgeCheckService_checkUserAge_result(success: success, e: e)
  }

}



fileprivate final class AgeCheckService_checkUserAgeWithDocomo_args {

  fileprivate var openIdRedirectUrl: String

  fileprivate var standardAge: Int32

  fileprivate var verifier: String


  fileprivate init(openIdRedirectUrl: String, standardAge: Int32, verifier: String) {
    self.openIdRedirectUrl = openIdRedirectUrl
    self.standardAge = standardAge
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: AgeCheckService_checkUserAgeWithDocomo_args, rhs: AgeCheckService_checkUserAgeWithDocomo_args) -> Bool {
  return
    (lhs.openIdRedirectUrl == rhs.openIdRedirectUrl) &&
    (lhs.standardAge == rhs.standardAge) &&
    (lhs.verifier == rhs.verifier)
}

extension AgeCheckService_checkUserAgeWithDocomo_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (openIdRedirectUrl.hashValue)
    result = prime &* result &+ (standardAge.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension AgeCheckService_checkUserAgeWithDocomo_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["openIdRedirectUrl": 2, "standardAge": 3, "verifier": 4, ]
  }

  fileprivate static var structName: String { return "AgeCheckService_checkUserAgeWithDocomo_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_checkUserAgeWithDocomo_args {
    _ = try proto.readStructBegin()
    var openIdRedirectUrl: String!
    var standardAge: Int32!
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           openIdRedirectUrl = try String.read(from: proto)
        case (3, .i32):             standardAge = try Int32.read(from: proto)
        case (4, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(openIdRedirectUrl, named: "openIdRedirectUrl")
    try proto.validateValue(standardAge, named: "standardAge")
    try proto.validateValue(verifier, named: "verifier")

    return AgeCheckService_checkUserAgeWithDocomo_args(openIdRedirectUrl: openIdRedirectUrl, standardAge: standardAge, verifier: verifier)
  }

}



fileprivate final class AgeCheckService_checkUserAgeWithDocomo_result {

  fileprivate var success: AgeCheckDocomoResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: AgeCheckDocomoResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: AgeCheckService_checkUserAgeWithDocomo_result, rhs: AgeCheckService_checkUserAgeWithDocomo_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension AgeCheckService_checkUserAgeWithDocomo_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AgeCheckService_checkUserAgeWithDocomo_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "AgeCheckService_checkUserAgeWithDocomo_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_checkUserAgeWithDocomo_result {
    _ = try proto.readStructBegin()
    var success: AgeCheckDocomoResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try AgeCheckDocomoResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AgeCheckService_checkUserAgeWithDocomo_result(success: success, e: e)
  }

}



fileprivate final class AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args, rhs: AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args) -> Bool {
  return true
}

extension AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args()
  }

}



fileprivate final class AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result, rhs: AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result(success: success, e: e)
  }

}



fileprivate final class AgeCheckService_retrieveRequestToken_args {

  fileprivate var carrier: CarrierCode


  fileprivate init(carrier: CarrierCode) {
    self.carrier = carrier
  }

}

fileprivate func ==(lhs: AgeCheckService_retrieveRequestToken_args, rhs: AgeCheckService_retrieveRequestToken_args) -> Bool {
  return
    (lhs.carrier == rhs.carrier)
}

extension AgeCheckService_retrieveRequestToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (carrier.hashValue)
    return result
  }

}

extension AgeCheckService_retrieveRequestToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["carrier": 2, ]
  }

  fileprivate static var structName: String { return "AgeCheckService_retrieveRequestToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_retrieveRequestToken_args {
    _ = try proto.readStructBegin()
    var carrier: CarrierCode!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             carrier = try CarrierCode.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(carrier, named: "carrier")

    return AgeCheckService_retrieveRequestToken_args(carrier: carrier)
  }

}



fileprivate final class AgeCheckService_retrieveRequestToken_result {

  fileprivate var success: AgeCheckRequestResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: AgeCheckRequestResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: AgeCheckService_retrieveRequestToken_result, rhs: AgeCheckService_retrieveRequestToken_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension AgeCheckService_retrieveRequestToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension AgeCheckService_retrieveRequestToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "AgeCheckService_retrieveRequestToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AgeCheckService_retrieveRequestToken_result {
    _ = try proto.readStructBegin()
    var success: AgeCheckRequestResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try AgeCheckRequestResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AgeCheckService_retrieveRequestToken_result(success: success, e: e)
  }

}



extension AgeCheckServiceClient : AgeCheckService {

  private func send_checkUserAge(carrier: CarrierCode, sessionId: String, verifier: String, standardAge: Int32) throws {
    try outProtocol.writeMessageBegin(name: "checkUserAge", type: .call, sequenceID: 0)
    let args = AgeCheckService_checkUserAge_args(carrier: carrier, sessionId: sessionId, verifier: verifier, standardAge: standardAge)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_checkUserAge() throws -> UserAgeType {
    try inProtocol.readResultMessageBegin() 
    let result = try AgeCheckService_checkUserAge_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "checkUserAge"))
  }

  public func checkUserAge(carrier: CarrierCode, sessionId: String, verifier: String, standardAge: Int32) throws -> UserAgeType {
    try send_checkUserAge(carrier: carrier, sessionId: sessionId, verifier: verifier, standardAge: standardAge)
    try outProtocol.transport.flush()
    return try recv_checkUserAge()
  }

  private func send_checkUserAgeWithDocomo(openIdRedirectUrl: String, standardAge: Int32, verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "checkUserAgeWithDocomo", type: .call, sequenceID: 0)
    let args = AgeCheckService_checkUserAgeWithDocomo_args(openIdRedirectUrl: openIdRedirectUrl, standardAge: standardAge, verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_checkUserAgeWithDocomo() throws -> AgeCheckDocomoResult {
    try inProtocol.readResultMessageBegin() 
    let result = try AgeCheckService_checkUserAgeWithDocomo_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "checkUserAgeWithDocomo"))
  }

  public func checkUserAgeWithDocomo(openIdRedirectUrl: String, standardAge: Int32, verifier: String) throws -> AgeCheckDocomoResult {
    try send_checkUserAgeWithDocomo(openIdRedirectUrl: openIdRedirectUrl, standardAge: standardAge, verifier: verifier)
    try outProtocol.transport.flush()
    return try recv_checkUserAgeWithDocomo()
  }

  private func send_retrieveOpenIdAuthUrlWithDocomo() throws {
    try outProtocol.writeMessageBegin(name: "retrieveOpenIdAuthUrlWithDocomo", type: .call, sequenceID: 0)
    let args = AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_retrieveOpenIdAuthUrlWithDocomo() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "retrieveOpenIdAuthUrlWithDocomo"))
  }

  public func retrieveOpenIdAuthUrlWithDocomo() throws -> String {
    try send_retrieveOpenIdAuthUrlWithDocomo()
    try outProtocol.transport.flush()
    return try recv_retrieveOpenIdAuthUrlWithDocomo()
  }

  private func send_retrieveRequestToken(carrier: CarrierCode) throws {
    try outProtocol.writeMessageBegin(name: "retrieveRequestToken", type: .call, sequenceID: 0)
    let args = AgeCheckService_retrieveRequestToken_args(carrier: carrier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_retrieveRequestToken() throws -> AgeCheckRequestResult {
    try inProtocol.readResultMessageBegin() 
    let result = try AgeCheckService_retrieveRequestToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "retrieveRequestToken"))
  }

  public func retrieveRequestToken(carrier: CarrierCode) throws -> AgeCheckRequestResult {
    try send_retrieveRequestToken(carrier: carrier)
    try outProtocol.transport.flush()
    return try recv_retrieveRequestToken()
  }

}

extension AgeCheckServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["checkUserAge"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AgeCheckService_checkUserAge_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AgeCheckService_checkUserAge_result()
      do {
        result.success = try handler.checkUserAge(carrier: args.carrier, sessionId: args.sessionId, verifier: args.verifier, standardAge: args.standardAge)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "checkUserAge", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["checkUserAgeWithDocomo"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AgeCheckService_checkUserAgeWithDocomo_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AgeCheckService_checkUserAgeWithDocomo_result()
      do {
        result.success = try handler.checkUserAgeWithDocomo(openIdRedirectUrl: args.openIdRedirectUrl, standardAge: args.standardAge, verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "checkUserAgeWithDocomo", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["retrieveOpenIdAuthUrlWithDocomo"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AgeCheckService_retrieveOpenIdAuthUrlWithDocomo_result()
      do {
        result.success = try handler.retrieveOpenIdAuthUrlWithDocomo()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "retrieveOpenIdAuthUrlWithDocomo", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["retrieveRequestToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AgeCheckService_retrieveRequestToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AgeCheckService_retrieveRequestToken_result()
      do {
        result.success = try handler.retrieveRequestToken(carrier: args.carrier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "retrieveRequestToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AgeCheckServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class BuddyManagementService_addBuddyMember_args {

  fileprivate var requestId: String

  fileprivate var userMid: String


  fileprivate init(requestId: String, userMid: String) {
    self.requestId = requestId
    self.userMid = userMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_addBuddyMember_args, rhs: BuddyManagementService_addBuddyMember_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.userMid == rhs.userMid)
}

extension BuddyManagementService_addBuddyMember_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (userMid.hashValue)
    return result
  }

}

extension BuddyManagementService_addBuddyMember_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "userMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_addBuddyMember_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_addBuddyMember_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var userMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           userMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(userMid, named: "userMid")

    return BuddyManagementService_addBuddyMember_args(requestId: requestId, userMid: userMid)
  }

}



fileprivate final class BuddyManagementService_addBuddyMember_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_addBuddyMember_result, rhs: BuddyManagementService_addBuddyMember_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_addBuddyMember_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_addBuddyMember_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_addBuddyMember_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_addBuddyMember_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_addBuddyMember_result(e: e)
  }

}



fileprivate final class BuddyManagementService_addBuddyMembers_args {

  fileprivate var requestId: String

  fileprivate var userMids: TList<String>


  fileprivate init(requestId: String, userMids: TList<String>) {
    self.requestId = requestId
    self.userMids = userMids
  }

}

fileprivate func ==(lhs: BuddyManagementService_addBuddyMembers_args, rhs: BuddyManagementService_addBuddyMembers_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.userMids == rhs.userMids)
}

extension BuddyManagementService_addBuddyMembers_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (userMids.hashValue)
    return result
  }

}

extension BuddyManagementService_addBuddyMembers_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "userMids": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_addBuddyMembers_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_addBuddyMembers_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var userMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .list):            userMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(userMids, named: "userMids")

    return BuddyManagementService_addBuddyMembers_args(requestId: requestId, userMids: userMids)
  }

}



fileprivate final class BuddyManagementService_addBuddyMembers_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_addBuddyMembers_result, rhs: BuddyManagementService_addBuddyMembers_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_addBuddyMembers_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_addBuddyMembers_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_addBuddyMembers_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_addBuddyMembers_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_addBuddyMembers_result(e: e)
  }

}



fileprivate final class BuddyManagementService_blockBuddyMember_args {

  fileprivate var requestId: String

  fileprivate var mid: String


  fileprivate init(requestId: String, mid: String) {
    self.requestId = requestId
    self.mid = mid
  }

}

fileprivate func ==(lhs: BuddyManagementService_blockBuddyMember_args, rhs: BuddyManagementService_blockBuddyMember_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.mid == rhs.mid)
}

extension BuddyManagementService_blockBuddyMember_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension BuddyManagementService_blockBuddyMember_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "mid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_blockBuddyMember_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_blockBuddyMember_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(mid, named: "mid")

    return BuddyManagementService_blockBuddyMember_args(requestId: requestId, mid: mid)
  }

}



fileprivate final class BuddyManagementService_blockBuddyMember_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_blockBuddyMember_result, rhs: BuddyManagementService_blockBuddyMember_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_blockBuddyMember_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_blockBuddyMember_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_blockBuddyMember_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_blockBuddyMember_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_blockBuddyMember_result(e: e)
  }

}



fileprivate final class BuddyManagementService_commitSendMessagesToAll_args {

  fileprivate var requestIdList: TList<String>


  fileprivate init(requestIdList: TList<String>) {
    self.requestIdList = requestIdList
  }

}

fileprivate func ==(lhs: BuddyManagementService_commitSendMessagesToAll_args, rhs: BuddyManagementService_commitSendMessagesToAll_args) -> Bool {
  return
    (lhs.requestIdList == rhs.requestIdList)
}

extension BuddyManagementService_commitSendMessagesToAll_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestIdList.hashValue)
    return result
  }

}

extension BuddyManagementService_commitSendMessagesToAll_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestIdList": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_commitSendMessagesToAll_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_commitSendMessagesToAll_args {
    _ = try proto.readStructBegin()
    var requestIdList: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            requestIdList = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestIdList, named: "requestIdList")

    return BuddyManagementService_commitSendMessagesToAll_args(requestIdList: requestIdList)
  }

}



fileprivate final class BuddyManagementService_commitSendMessagesToAll_result {

  fileprivate var success: TList<SendBuddyMessageResult>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<SendBuddyMessageResult>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_commitSendMessagesToAll_result, rhs: BuddyManagementService_commitSendMessagesToAll_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_commitSendMessagesToAll_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_commitSendMessagesToAll_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_commitSendMessagesToAll_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_commitSendMessagesToAll_result {
    _ = try proto.readStructBegin()
    var success: TList<SendBuddyMessageResult>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<SendBuddyMessageResult>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_commitSendMessagesToAll_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_commitSendMessagesToMids_args {

  fileprivate var requestIdList: TList<String>

  fileprivate var mids: TList<String>


  fileprivate init(requestIdList: TList<String>, mids: TList<String>) {
    self.requestIdList = requestIdList
    self.mids = mids
  }

}

fileprivate func ==(lhs: BuddyManagementService_commitSendMessagesToMids_args, rhs: BuddyManagementService_commitSendMessagesToMids_args) -> Bool {
  return
    (lhs.requestIdList == rhs.requestIdList) &&
    (lhs.mids == rhs.mids)
}

extension BuddyManagementService_commitSendMessagesToMids_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestIdList.hashValue)
    result = prime &* result &+ (mids.hashValue)
    return result
  }

}

extension BuddyManagementService_commitSendMessagesToMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestIdList": 1, "mids": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_commitSendMessagesToMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_commitSendMessagesToMids_args {
    _ = try proto.readStructBegin()
    var requestIdList: TList<String>!
    var mids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            requestIdList = try TList<String>.read(from: proto)
        case (2, .list):            mids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestIdList, named: "requestIdList")
    try proto.validateValue(mids, named: "mids")

    return BuddyManagementService_commitSendMessagesToMids_args(requestIdList: requestIdList, mids: mids)
  }

}



fileprivate final class BuddyManagementService_commitSendMessagesToMids_result {

  fileprivate var success: TList<SendBuddyMessageResult>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<SendBuddyMessageResult>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_commitSendMessagesToMids_result, rhs: BuddyManagementService_commitSendMessagesToMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_commitSendMessagesToMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_commitSendMessagesToMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_commitSendMessagesToMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_commitSendMessagesToMids_result {
    _ = try proto.readStructBegin()
    var success: TList<SendBuddyMessageResult>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<SendBuddyMessageResult>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_commitSendMessagesToMids_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_containsBuddyMember_args {

  fileprivate var requestId: String

  fileprivate var userMid: String


  fileprivate init(requestId: String, userMid: String) {
    self.requestId = requestId
    self.userMid = userMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_containsBuddyMember_args, rhs: BuddyManagementService_containsBuddyMember_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.userMid == rhs.userMid)
}

extension BuddyManagementService_containsBuddyMember_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (userMid.hashValue)
    return result
  }

}

extension BuddyManagementService_containsBuddyMember_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "userMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_containsBuddyMember_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_containsBuddyMember_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var userMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           userMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(userMid, named: "userMid")

    return BuddyManagementService_containsBuddyMember_args(requestId: requestId, userMid: userMid)
  }

}



fileprivate final class BuddyManagementService_containsBuddyMember_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_containsBuddyMember_result, rhs: BuddyManagementService_containsBuddyMember_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_containsBuddyMember_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_containsBuddyMember_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_containsBuddyMember_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_containsBuddyMember_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_containsBuddyMember_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_downloadMessageContent_args {

  fileprivate var requestId: String

  fileprivate var messageId: String


  fileprivate init(requestId: String, messageId: String) {
    self.requestId = requestId
    self.messageId = messageId
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadMessageContent_args, rhs: BuddyManagementService_downloadMessageContent_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.messageId == rhs.messageId)
}

extension BuddyManagementService_downloadMessageContent_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (messageId.hashValue)
    return result
  }

}

extension BuddyManagementService_downloadMessageContent_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "messageId": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadMessageContent_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadMessageContent_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var messageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           messageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(messageId, named: "messageId")

    return BuddyManagementService_downloadMessageContent_args(requestId: requestId, messageId: messageId)
  }

}



fileprivate final class BuddyManagementService_downloadMessageContent_result {

  fileprivate var success: Data?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Data?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadMessageContent_result, rhs: BuddyManagementService_downloadMessageContent_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_downloadMessageContent_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_downloadMessageContent_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadMessageContent_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadMessageContent_result {
    _ = try proto.readStructBegin()
    var success: Data?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_downloadMessageContent_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_downloadMessageContentPreview_args {

  fileprivate var requestId: String

  fileprivate var messageId: String


  fileprivate init(requestId: String, messageId: String) {
    self.requestId = requestId
    self.messageId = messageId
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadMessageContentPreview_args, rhs: BuddyManagementService_downloadMessageContentPreview_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.messageId == rhs.messageId)
}

extension BuddyManagementService_downloadMessageContentPreview_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (messageId.hashValue)
    return result
  }

}

extension BuddyManagementService_downloadMessageContentPreview_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "messageId": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadMessageContentPreview_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadMessageContentPreview_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var messageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           messageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(messageId, named: "messageId")

    return BuddyManagementService_downloadMessageContentPreview_args(requestId: requestId, messageId: messageId)
  }

}



fileprivate final class BuddyManagementService_downloadMessageContentPreview_result {

  fileprivate var success: Data?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Data?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadMessageContentPreview_result, rhs: BuddyManagementService_downloadMessageContentPreview_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_downloadMessageContentPreview_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_downloadMessageContentPreview_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadMessageContentPreview_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadMessageContentPreview_result {
    _ = try proto.readStructBegin()
    var success: Data?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_downloadMessageContentPreview_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_downloadProfileImage_args {

  fileprivate var requestId: String


  fileprivate init(requestId: String) {
    self.requestId = requestId
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadProfileImage_args, rhs: BuddyManagementService_downloadProfileImage_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId)
}

extension BuddyManagementService_downloadProfileImage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    return result
  }

}

extension BuddyManagementService_downloadProfileImage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadProfileImage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadProfileImage_args {
    _ = try proto.readStructBegin()
    var requestId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")

    return BuddyManagementService_downloadProfileImage_args(requestId: requestId)
  }

}



fileprivate final class BuddyManagementService_downloadProfileImage_result {

  fileprivate var success: Data?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Data?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadProfileImage_result, rhs: BuddyManagementService_downloadProfileImage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_downloadProfileImage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_downloadProfileImage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadProfileImage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadProfileImage_result {
    _ = try proto.readStructBegin()
    var success: Data?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_downloadProfileImage_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_downloadProfileImagePreview_args {

  fileprivate var requestId: String


  fileprivate init(requestId: String) {
    self.requestId = requestId
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadProfileImagePreview_args, rhs: BuddyManagementService_downloadProfileImagePreview_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId)
}

extension BuddyManagementService_downloadProfileImagePreview_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    return result
  }

}

extension BuddyManagementService_downloadProfileImagePreview_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadProfileImagePreview_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadProfileImagePreview_args {
    _ = try proto.readStructBegin()
    var requestId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")

    return BuddyManagementService_downloadProfileImagePreview_args(requestId: requestId)
  }

}



fileprivate final class BuddyManagementService_downloadProfileImagePreview_result {

  fileprivate var success: Data?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Data?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_downloadProfileImagePreview_result, rhs: BuddyManagementService_downloadProfileImagePreview_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_downloadProfileImagePreview_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_downloadProfileImagePreview_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_downloadProfileImagePreview_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_downloadProfileImagePreview_result {
    _ = try proto.readStructBegin()
    var success: Data?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_downloadProfileImagePreview_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getActiveMemberCountByBuddyMid_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_getActiveMemberCountByBuddyMid_args, rhs: BuddyManagementService_getActiveMemberCountByBuddyMid_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyManagementService_getActiveMemberCountByBuddyMid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyManagementService_getActiveMemberCountByBuddyMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getActiveMemberCountByBuddyMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getActiveMemberCountByBuddyMid_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyManagementService_getActiveMemberCountByBuddyMid_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyManagementService_getActiveMemberCountByBuddyMid_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getActiveMemberCountByBuddyMid_result, rhs: BuddyManagementService_getActiveMemberCountByBuddyMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getActiveMemberCountByBuddyMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getActiveMemberCountByBuddyMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getActiveMemberCountByBuddyMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getActiveMemberCountByBuddyMid_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getActiveMemberCountByBuddyMid_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getActiveMemberMidsByBuddyMid_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_getActiveMemberMidsByBuddyMid_args, rhs: BuddyManagementService_getActiveMemberMidsByBuddyMid_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyManagementService_getActiveMemberMidsByBuddyMid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyManagementService_getActiveMemberMidsByBuddyMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getActiveMemberMidsByBuddyMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getActiveMemberMidsByBuddyMid_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyManagementService_getActiveMemberMidsByBuddyMid_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyManagementService_getActiveMemberMidsByBuddyMid_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getActiveMemberMidsByBuddyMid_result, rhs: BuddyManagementService_getActiveMemberMidsByBuddyMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getActiveMemberMidsByBuddyMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getActiveMemberMidsByBuddyMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getActiveMemberMidsByBuddyMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getActiveMemberMidsByBuddyMid_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getActiveMemberMidsByBuddyMid_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getAllBuddyMembers_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: BuddyManagementService_getAllBuddyMembers_args, rhs: BuddyManagementService_getAllBuddyMembers_args) -> Bool {
  return true
}

extension BuddyManagementService_getAllBuddyMembers_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension BuddyManagementService_getAllBuddyMembers_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getAllBuddyMembers_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getAllBuddyMembers_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getAllBuddyMembers_args()
  }

}



fileprivate final class BuddyManagementService_getAllBuddyMembers_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getAllBuddyMembers_result, rhs: BuddyManagementService_getAllBuddyMembers_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getAllBuddyMembers_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getAllBuddyMembers_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getAllBuddyMembers_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getAllBuddyMembers_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getAllBuddyMembers_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getBlockedBuddyMembers_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: BuddyManagementService_getBlockedBuddyMembers_args, rhs: BuddyManagementService_getBlockedBuddyMembers_args) -> Bool {
  return true
}

extension BuddyManagementService_getBlockedBuddyMembers_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension BuddyManagementService_getBlockedBuddyMembers_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBlockedBuddyMembers_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBlockedBuddyMembers_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getBlockedBuddyMembers_args()
  }

}



fileprivate final class BuddyManagementService_getBlockedBuddyMembers_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getBlockedBuddyMembers_result, rhs: BuddyManagementService_getBlockedBuddyMembers_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getBlockedBuddyMembers_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getBlockedBuddyMembers_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBlockedBuddyMembers_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBlockedBuddyMembers_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getBlockedBuddyMembers_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getBlockerCountByBuddyMid_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_getBlockerCountByBuddyMid_args, rhs: BuddyManagementService_getBlockerCountByBuddyMid_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyManagementService_getBlockerCountByBuddyMid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyManagementService_getBlockerCountByBuddyMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBlockerCountByBuddyMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBlockerCountByBuddyMid_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyManagementService_getBlockerCountByBuddyMid_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyManagementService_getBlockerCountByBuddyMid_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getBlockerCountByBuddyMid_result, rhs: BuddyManagementService_getBlockerCountByBuddyMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getBlockerCountByBuddyMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getBlockerCountByBuddyMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBlockerCountByBuddyMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBlockerCountByBuddyMid_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getBlockerCountByBuddyMid_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getBuddyDetailByMid_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_getBuddyDetailByMid_args, rhs: BuddyManagementService_getBuddyDetailByMid_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyManagementService_getBuddyDetailByMid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyManagementService_getBuddyDetailByMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBuddyDetailByMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBuddyDetailByMid_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyManagementService_getBuddyDetailByMid_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyManagementService_getBuddyDetailByMid_result {

  fileprivate var success: BuddyDetail?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: BuddyDetail?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getBuddyDetailByMid_result, rhs: BuddyManagementService_getBuddyDetailByMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getBuddyDetailByMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getBuddyDetailByMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBuddyDetailByMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBuddyDetailByMid_result {
    _ = try proto.readStructBegin()
    var success: BuddyDetail?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try BuddyDetail.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getBuddyDetailByMid_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getBuddyProfile_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: BuddyManagementService_getBuddyProfile_args, rhs: BuddyManagementService_getBuddyProfile_args) -> Bool {
  return true
}

extension BuddyManagementService_getBuddyProfile_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension BuddyManagementService_getBuddyProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBuddyProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBuddyProfile_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getBuddyProfile_args()
  }

}



fileprivate final class BuddyManagementService_getBuddyProfile_result {

  fileprivate var success: BuddyProfile?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: BuddyProfile?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getBuddyProfile_result, rhs: BuddyManagementService_getBuddyProfile_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getBuddyProfile_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getBuddyProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getBuddyProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getBuddyProfile_result {
    _ = try proto.readStructBegin()
    var success: BuddyProfile?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try BuddyProfile.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getBuddyProfile_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getContactTicket_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: BuddyManagementService_getContactTicket_args, rhs: BuddyManagementService_getContactTicket_args) -> Bool {
  return true
}

extension BuddyManagementService_getContactTicket_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension BuddyManagementService_getContactTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getContactTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getContactTicket_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getContactTicket_args()
  }

}



fileprivate final class BuddyManagementService_getContactTicket_result {

  fileprivate var success: Ticket?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Ticket?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getContactTicket_result, rhs: BuddyManagementService_getContactTicket_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getContactTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getContactTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getContactTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getContactTicket_result {
    _ = try proto.readStructBegin()
    var success: Ticket?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Ticket.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getContactTicket_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getMemberCountByBuddyMid_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_getMemberCountByBuddyMid_args, rhs: BuddyManagementService_getMemberCountByBuddyMid_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyManagementService_getMemberCountByBuddyMid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyManagementService_getMemberCountByBuddyMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getMemberCountByBuddyMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getMemberCountByBuddyMid_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyManagementService_getMemberCountByBuddyMid_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyManagementService_getMemberCountByBuddyMid_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getMemberCountByBuddyMid_result, rhs: BuddyManagementService_getMemberCountByBuddyMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getMemberCountByBuddyMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getMemberCountByBuddyMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getMemberCountByBuddyMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getMemberCountByBuddyMid_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getMemberCountByBuddyMid_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getSendBuddyMessageResult_args {

  fileprivate var sendBuddyMessageRequestId: String


  fileprivate init(sendBuddyMessageRequestId: String) {
    self.sendBuddyMessageRequestId = sendBuddyMessageRequestId
  }

}

fileprivate func ==(lhs: BuddyManagementService_getSendBuddyMessageResult_args, rhs: BuddyManagementService_getSendBuddyMessageResult_args) -> Bool {
  return
    (lhs.sendBuddyMessageRequestId == rhs.sendBuddyMessageRequestId)
}

extension BuddyManagementService_getSendBuddyMessageResult_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sendBuddyMessageRequestId.hashValue)
    return result
  }

}

extension BuddyManagementService_getSendBuddyMessageResult_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sendBuddyMessageRequestId": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getSendBuddyMessageResult_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getSendBuddyMessageResult_args {
    _ = try proto.readStructBegin()
    var sendBuddyMessageRequestId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           sendBuddyMessageRequestId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sendBuddyMessageRequestId, named: "sendBuddyMessageRequestId")

    return BuddyManagementService_getSendBuddyMessageResult_args(sendBuddyMessageRequestId: sendBuddyMessageRequestId)
  }

}



fileprivate final class BuddyManagementService_getSendBuddyMessageResult_result {

  fileprivate var success: SendBuddyMessageResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SendBuddyMessageResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getSendBuddyMessageResult_result, rhs: BuddyManagementService_getSendBuddyMessageResult_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getSendBuddyMessageResult_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getSendBuddyMessageResult_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getSendBuddyMessageResult_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getSendBuddyMessageResult_result {
    _ = try proto.readStructBegin()
    var success: SendBuddyMessageResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SendBuddyMessageResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getSendBuddyMessageResult_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getSetBuddyOnAirResult_args {

  fileprivate var setBuddyOnAirRequestId: String


  fileprivate init(setBuddyOnAirRequestId: String) {
    self.setBuddyOnAirRequestId = setBuddyOnAirRequestId
  }

}

fileprivate func ==(lhs: BuddyManagementService_getSetBuddyOnAirResult_args, rhs: BuddyManagementService_getSetBuddyOnAirResult_args) -> Bool {
  return
    (lhs.setBuddyOnAirRequestId == rhs.setBuddyOnAirRequestId)
}

extension BuddyManagementService_getSetBuddyOnAirResult_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (setBuddyOnAirRequestId.hashValue)
    return result
  }

}

extension BuddyManagementService_getSetBuddyOnAirResult_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["setBuddyOnAirRequestId": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getSetBuddyOnAirResult_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getSetBuddyOnAirResult_args {
    _ = try proto.readStructBegin()
    var setBuddyOnAirRequestId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           setBuddyOnAirRequestId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(setBuddyOnAirRequestId, named: "setBuddyOnAirRequestId")

    return BuddyManagementService_getSetBuddyOnAirResult_args(setBuddyOnAirRequestId: setBuddyOnAirRequestId)
  }

}



fileprivate final class BuddyManagementService_getSetBuddyOnAirResult_result {

  fileprivate var success: SetBuddyOnAirResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SetBuddyOnAirResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getSetBuddyOnAirResult_result, rhs: BuddyManagementService_getSetBuddyOnAirResult_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getSetBuddyOnAirResult_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getSetBuddyOnAirResult_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getSetBuddyOnAirResult_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getSetBuddyOnAirResult_result {
    _ = try proto.readStructBegin()
    var success: SetBuddyOnAirResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SetBuddyOnAirResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getSetBuddyOnAirResult_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_getUpdateBuddyProfileResult_args {

  fileprivate var updateBuddyProfileRequestId: String


  fileprivate init(updateBuddyProfileRequestId: String) {
    self.updateBuddyProfileRequestId = updateBuddyProfileRequestId
  }

}

fileprivate func ==(lhs: BuddyManagementService_getUpdateBuddyProfileResult_args, rhs: BuddyManagementService_getUpdateBuddyProfileResult_args) -> Bool {
  return
    (lhs.updateBuddyProfileRequestId == rhs.updateBuddyProfileRequestId)
}

extension BuddyManagementService_getUpdateBuddyProfileResult_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (updateBuddyProfileRequestId.hashValue)
    return result
  }

}

extension BuddyManagementService_getUpdateBuddyProfileResult_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["updateBuddyProfileRequestId": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getUpdateBuddyProfileResult_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getUpdateBuddyProfileResult_args {
    _ = try proto.readStructBegin()
    var updateBuddyProfileRequestId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           updateBuddyProfileRequestId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(updateBuddyProfileRequestId, named: "updateBuddyProfileRequestId")

    return BuddyManagementService_getUpdateBuddyProfileResult_args(updateBuddyProfileRequestId: updateBuddyProfileRequestId)
  }

}



fileprivate final class BuddyManagementService_getUpdateBuddyProfileResult_result {

  fileprivate var success: UpdateBuddyProfileResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: UpdateBuddyProfileResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_getUpdateBuddyProfileResult_result, rhs: BuddyManagementService_getUpdateBuddyProfileResult_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_getUpdateBuddyProfileResult_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_getUpdateBuddyProfileResult_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_getUpdateBuddyProfileResult_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_getUpdateBuddyProfileResult_result {
    _ = try proto.readStructBegin()
    var success: UpdateBuddyProfileResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try UpdateBuddyProfileResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_getUpdateBuddyProfileResult_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_isBuddyOnAirByMid_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_isBuddyOnAirByMid_args, rhs: BuddyManagementService_isBuddyOnAirByMid_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyManagementService_isBuddyOnAirByMid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyManagementService_isBuddyOnAirByMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_isBuddyOnAirByMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_isBuddyOnAirByMid_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyManagementService_isBuddyOnAirByMid_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyManagementService_isBuddyOnAirByMid_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_isBuddyOnAirByMid_result, rhs: BuddyManagementService_isBuddyOnAirByMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_isBuddyOnAirByMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_isBuddyOnAirByMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_isBuddyOnAirByMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_isBuddyOnAirByMid_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_isBuddyOnAirByMid_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var sourceContentId: String


  fileprivate init(requestId: String, msg: Message, sourceContentId: String) {
    self.requestId = requestId
    self.msg = msg
    self.sourceContentId = sourceContentId
  }

}

fileprivate func ==(lhs: BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args, rhs: BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.sourceContentId == rhs.sourceContentId)
}

extension BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (sourceContentId.hashValue)
    return result
  }

}

extension BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "sourceContentId": 3, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var sourceContentId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .string):           sourceContentId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(sourceContentId, named: "sourceContentId")

    return BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args(requestId: requestId, msg: msg, sourceContentId: sourceContentId)
  }

}



fileprivate final class BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result, rhs: BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_linkAndSendBuddyContentMessageToMids_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var sourceContentId: String

  fileprivate var mids: TList<String>


  fileprivate init(requestId: String, msg: Message, sourceContentId: String, mids: TList<String>) {
    self.requestId = requestId
    self.msg = msg
    self.sourceContentId = sourceContentId
    self.mids = mids
  }

}

fileprivate func ==(lhs: BuddyManagementService_linkAndSendBuddyContentMessageToMids_args, rhs: BuddyManagementService_linkAndSendBuddyContentMessageToMids_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.sourceContentId == rhs.sourceContentId) &&
    (lhs.mids == rhs.mids)
}

extension BuddyManagementService_linkAndSendBuddyContentMessageToMids_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (sourceContentId.hashValue)
    result = prime &* result &+ (mids.hashValue)
    return result
  }

}

extension BuddyManagementService_linkAndSendBuddyContentMessageToMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "sourceContentId": 3, "mids": 4, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_linkAndSendBuddyContentMessageToMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_linkAndSendBuddyContentMessageToMids_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var sourceContentId: String!
    var mids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .string):           sourceContentId = try String.read(from: proto)
        case (4, .list):            mids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(sourceContentId, named: "sourceContentId")
    try proto.validateValue(mids, named: "mids")

    return BuddyManagementService_linkAndSendBuddyContentMessageToMids_args(requestId: requestId, msg: msg, sourceContentId: sourceContentId, mids: mids)
  }

}



fileprivate final class BuddyManagementService_linkAndSendBuddyContentMessageToMids_result {

  fileprivate var success: SendBuddyMessageResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SendBuddyMessageResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_linkAndSendBuddyContentMessageToMids_result, rhs: BuddyManagementService_linkAndSendBuddyContentMessageToMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_linkAndSendBuddyContentMessageToMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_linkAndSendBuddyContentMessageToMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_linkAndSendBuddyContentMessageToMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_linkAndSendBuddyContentMessageToMids_result {
    _ = try proto.readStructBegin()
    var success: SendBuddyMessageResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SendBuddyMessageResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_linkAndSendBuddyContentMessageToMids_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_notifyBuddyBlocked_args {

  fileprivate var buddyMid: String

  fileprivate var blockerMid: String


  fileprivate init(buddyMid: String, blockerMid: String) {
    self.buddyMid = buddyMid
    self.blockerMid = blockerMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_notifyBuddyBlocked_args, rhs: BuddyManagementService_notifyBuddyBlocked_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid) &&
    (lhs.blockerMid == rhs.blockerMid)
}

extension BuddyManagementService_notifyBuddyBlocked_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    result = prime &* result &+ (blockerMid.hashValue)
    return result
  }

}

extension BuddyManagementService_notifyBuddyBlocked_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 1, "blockerMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_notifyBuddyBlocked_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_notifyBuddyBlocked_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!
    var blockerMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           buddyMid = try String.read(from: proto)
        case (2, .string):           blockerMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")
    try proto.validateValue(blockerMid, named: "blockerMid")

    return BuddyManagementService_notifyBuddyBlocked_args(buddyMid: buddyMid, blockerMid: blockerMid)
  }

}



fileprivate final class BuddyManagementService_notifyBuddyBlocked_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_notifyBuddyBlocked_result, rhs: BuddyManagementService_notifyBuddyBlocked_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_notifyBuddyBlocked_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_notifyBuddyBlocked_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_notifyBuddyBlocked_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_notifyBuddyBlocked_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_notifyBuddyBlocked_result(e: e)
  }

}



fileprivate final class BuddyManagementService_notifyBuddyUnblocked_args {

  fileprivate var buddyMid: String

  fileprivate var blockerMid: String


  fileprivate init(buddyMid: String, blockerMid: String) {
    self.buddyMid = buddyMid
    self.blockerMid = blockerMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_notifyBuddyUnblocked_args, rhs: BuddyManagementService_notifyBuddyUnblocked_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid) &&
    (lhs.blockerMid == rhs.blockerMid)
}

extension BuddyManagementService_notifyBuddyUnblocked_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    result = prime &* result &+ (blockerMid.hashValue)
    return result
  }

}

extension BuddyManagementService_notifyBuddyUnblocked_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 1, "blockerMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_notifyBuddyUnblocked_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_notifyBuddyUnblocked_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!
    var blockerMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           buddyMid = try String.read(from: proto)
        case (2, .string):           blockerMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")
    try proto.validateValue(blockerMid, named: "blockerMid")

    return BuddyManagementService_notifyBuddyUnblocked_args(buddyMid: buddyMid, blockerMid: blockerMid)
  }

}



fileprivate final class BuddyManagementService_notifyBuddyUnblocked_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_notifyBuddyUnblocked_result, rhs: BuddyManagementService_notifyBuddyUnblocked_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_notifyBuddyUnblocked_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_notifyBuddyUnblocked_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_notifyBuddyUnblocked_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_notifyBuddyUnblocked_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_notifyBuddyUnblocked_result(e: e)
  }

}



fileprivate final class BuddyManagementService_registerBuddy_args {

  fileprivate var buddyId: String

  fileprivate var searchId: String

  fileprivate var displayName: String

  fileprivate var statusMeessage: String

  fileprivate var picture: Data

  fileprivate var settings: TMap<String, String>


  fileprivate init(buddyId: String, searchId: String, displayName: String, statusMeessage: String, picture: Data, settings: TMap<String, String>) {
    self.buddyId = buddyId
    self.searchId = searchId
    self.displayName = displayName
    self.statusMeessage = statusMeessage
    self.picture = picture
    self.settings = settings
  }

}

fileprivate func ==(lhs: BuddyManagementService_registerBuddy_args, rhs: BuddyManagementService_registerBuddy_args) -> Bool {
  return
    (lhs.buddyId == rhs.buddyId) &&
    (lhs.searchId == rhs.searchId) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.statusMeessage == rhs.statusMeessage) &&
    (lhs.picture == rhs.picture) &&
    (lhs.settings == rhs.settings)
}

extension BuddyManagementService_registerBuddy_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyId.hashValue)
    result = prime &* result &+ (searchId.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (statusMeessage.hashValue)
    result = prime &* result &+ (picture.hashValue)
    result = prime &* result &+ (settings.hashValue)
    return result
  }

}

extension BuddyManagementService_registerBuddy_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyId": 2, "searchId": 3, "displayName": 4, "statusMeessage": 5, "picture": 6, "settings": 7, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_registerBuddy_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_registerBuddy_args {
    _ = try proto.readStructBegin()
    var buddyId: String!
    var searchId: String!
    var displayName: String!
    var statusMeessage: String!
    var picture: Data!
    var settings: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyId = try String.read(from: proto)
        case (3, .string):           searchId = try String.read(from: proto)
        case (4, .string):           displayName = try String.read(from: proto)
        case (5, .string):           statusMeessage = try String.read(from: proto)
        case (6, .string):           picture = try Data.read(from: proto)
        case (7, .map):             settings = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyId, named: "buddyId")
    try proto.validateValue(searchId, named: "searchId")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(statusMeessage, named: "statusMeessage")
    try proto.validateValue(picture, named: "picture")
    try proto.validateValue(settings, named: "settings")

    return BuddyManagementService_registerBuddy_args(buddyId: buddyId, searchId: searchId, displayName: displayName, statusMeessage: statusMeessage, picture: picture, settings: settings)
  }

}



fileprivate final class BuddyManagementService_registerBuddy_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_registerBuddy_result, rhs: BuddyManagementService_registerBuddy_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_registerBuddy_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_registerBuddy_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_registerBuddy_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_registerBuddy_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_registerBuddy_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_registerBuddyAdmin_args {

  fileprivate var buddyId: String

  fileprivate var searchId: String

  fileprivate var displayName: String

  fileprivate var statusMessage: String

  fileprivate var picture: Data


  fileprivate init(buddyId: String, searchId: String, displayName: String, statusMessage: String, picture: Data) {
    self.buddyId = buddyId
    self.searchId = searchId
    self.displayName = displayName
    self.statusMessage = statusMessage
    self.picture = picture
  }

}

fileprivate func ==(lhs: BuddyManagementService_registerBuddyAdmin_args, rhs: BuddyManagementService_registerBuddyAdmin_args) -> Bool {
  return
    (lhs.buddyId == rhs.buddyId) &&
    (lhs.searchId == rhs.searchId) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.statusMessage == rhs.statusMessage) &&
    (lhs.picture == rhs.picture)
}

extension BuddyManagementService_registerBuddyAdmin_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyId.hashValue)
    result = prime &* result &+ (searchId.hashValue)
    result = prime &* result &+ (displayName.hashValue)
    result = prime &* result &+ (statusMessage.hashValue)
    result = prime &* result &+ (picture.hashValue)
    return result
  }

}

extension BuddyManagementService_registerBuddyAdmin_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyId": 2, "searchId": 3, "displayName": 4, "statusMessage": 5, "picture": 6, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_registerBuddyAdmin_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_registerBuddyAdmin_args {
    _ = try proto.readStructBegin()
    var buddyId: String!
    var searchId: String!
    var displayName: String!
    var statusMessage: String!
    var picture: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyId = try String.read(from: proto)
        case (3, .string):           searchId = try String.read(from: proto)
        case (4, .string):           displayName = try String.read(from: proto)
        case (5, .string):           statusMessage = try String.read(from: proto)
        case (6, .string):           picture = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyId, named: "buddyId")
    try proto.validateValue(searchId, named: "searchId")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(statusMessage, named: "statusMessage")
    try proto.validateValue(picture, named: "picture")

    return BuddyManagementService_registerBuddyAdmin_args(buddyId: buddyId, searchId: searchId, displayName: displayName, statusMessage: statusMessage, picture: picture)
  }

}



fileprivate final class BuddyManagementService_registerBuddyAdmin_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_registerBuddyAdmin_result, rhs: BuddyManagementService_registerBuddyAdmin_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_registerBuddyAdmin_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_registerBuddyAdmin_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_registerBuddyAdmin_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_registerBuddyAdmin_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_registerBuddyAdmin_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_reissueContactTicket_args {

  fileprivate var expirationTime: Int64

  fileprivate var maxUseCount: Int32


  fileprivate init(expirationTime: Int64, maxUseCount: Int32) {
    self.expirationTime = expirationTime
    self.maxUseCount = maxUseCount
  }

}

fileprivate func ==(lhs: BuddyManagementService_reissueContactTicket_args, rhs: BuddyManagementService_reissueContactTicket_args) -> Bool {
  return
    (lhs.expirationTime == rhs.expirationTime) &&
    (lhs.maxUseCount == rhs.maxUseCount)
}

extension BuddyManagementService_reissueContactTicket_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (expirationTime.hashValue)
    result = prime &* result &+ (maxUseCount.hashValue)
    return result
  }

}

extension BuddyManagementService_reissueContactTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["expirationTime": 3, "maxUseCount": 4, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_reissueContactTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_reissueContactTicket_args {
    _ = try proto.readStructBegin()
    var expirationTime: Int64!
    var maxUseCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .i64):             expirationTime = try Int64.read(from: proto)
        case (4, .i32):             maxUseCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(expirationTime, named: "expirationTime")
    try proto.validateValue(maxUseCount, named: "maxUseCount")

    return BuddyManagementService_reissueContactTicket_args(expirationTime: expirationTime, maxUseCount: maxUseCount)
  }

}



fileprivate final class BuddyManagementService_reissueContactTicket_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_reissueContactTicket_result, rhs: BuddyManagementService_reissueContactTicket_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_reissueContactTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_reissueContactTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_reissueContactTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_reissueContactTicket_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_reissueContactTicket_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_removeBuddyMember_args {

  fileprivate var requestId: String

  fileprivate var userMid: String


  fileprivate init(requestId: String, userMid: String) {
    self.requestId = requestId
    self.userMid = userMid
  }

}

fileprivate func ==(lhs: BuddyManagementService_removeBuddyMember_args, rhs: BuddyManagementService_removeBuddyMember_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.userMid == rhs.userMid)
}

extension BuddyManagementService_removeBuddyMember_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (userMid.hashValue)
    return result
  }

}

extension BuddyManagementService_removeBuddyMember_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "userMid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_removeBuddyMember_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_removeBuddyMember_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var userMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           userMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(userMid, named: "userMid")

    return BuddyManagementService_removeBuddyMember_args(requestId: requestId, userMid: userMid)
  }

}



fileprivate final class BuddyManagementService_removeBuddyMember_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_removeBuddyMember_result, rhs: BuddyManagementService_removeBuddyMember_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_removeBuddyMember_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_removeBuddyMember_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_removeBuddyMember_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_removeBuddyMember_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_removeBuddyMember_result(e: e)
  }

}



fileprivate final class BuddyManagementService_removeBuddyMembers_args {

  fileprivate var requestId: String

  fileprivate var userMids: TList<String>


  fileprivate init(requestId: String, userMids: TList<String>) {
    self.requestId = requestId
    self.userMids = userMids
  }

}

fileprivate func ==(lhs: BuddyManagementService_removeBuddyMembers_args, rhs: BuddyManagementService_removeBuddyMembers_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.userMids == rhs.userMids)
}

extension BuddyManagementService_removeBuddyMembers_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (userMids.hashValue)
    return result
  }

}

extension BuddyManagementService_removeBuddyMembers_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "userMids": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_removeBuddyMembers_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_removeBuddyMembers_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var userMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .list):            userMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(userMids, named: "userMids")

    return BuddyManagementService_removeBuddyMembers_args(requestId: requestId, userMids: userMids)
  }

}



fileprivate final class BuddyManagementService_removeBuddyMembers_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_removeBuddyMembers_result, rhs: BuddyManagementService_removeBuddyMembers_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_removeBuddyMembers_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_removeBuddyMembers_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_removeBuddyMembers_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_removeBuddyMembers_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_removeBuddyMembers_result(e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToAll_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var content: Data


  fileprivate init(requestId: String, msg: Message, content: Data) {
    self.requestId = requestId
    self.msg = msg
    self.content = content
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToAll_args, rhs: BuddyManagementService_sendBuddyContentMessageToAll_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.content == rhs.content)
}

extension BuddyManagementService_sendBuddyContentMessageToAll_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (content.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToAll_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "content": 3, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToAll_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToAll_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var content: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .string):           content = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(content, named: "content")

    return BuddyManagementService_sendBuddyContentMessageToAll_args(requestId: requestId, msg: msg, content: content)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToAll_result {

  fileprivate var success: SendBuddyMessageResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SendBuddyMessageResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToAll_result, rhs: BuddyManagementService_sendBuddyContentMessageToAll_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyContentMessageToAll_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToAll_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToAll_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToAll_result {
    _ = try proto.readStructBegin()
    var success: SendBuddyMessageResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SendBuddyMessageResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyContentMessageToAll_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToAllAsync_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var content: Data


  fileprivate init(requestId: String, msg: Message, content: Data) {
    self.requestId = requestId
    self.msg = msg
    self.content = content
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToAllAsync_args, rhs: BuddyManagementService_sendBuddyContentMessageToAllAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.content == rhs.content)
}

extension BuddyManagementService_sendBuddyContentMessageToAllAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (content.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToAllAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "content": 3, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToAllAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToAllAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var content: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .string):           content = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(content, named: "content")

    return BuddyManagementService_sendBuddyContentMessageToAllAsync_args(requestId: requestId, msg: msg, content: content)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToAllAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToAllAsync_result, rhs: BuddyManagementService_sendBuddyContentMessageToAllAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyContentMessageToAllAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToAllAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToAllAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToAllAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyContentMessageToAllAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToMids_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var content: Data

  fileprivate var mids: TList<String>


  fileprivate init(requestId: String, msg: Message, content: Data, mids: TList<String>) {
    self.requestId = requestId
    self.msg = msg
    self.content = content
    self.mids = mids
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToMids_args, rhs: BuddyManagementService_sendBuddyContentMessageToMids_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.content == rhs.content) &&
    (lhs.mids == rhs.mids)
}

extension BuddyManagementService_sendBuddyContentMessageToMids_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (content.hashValue)
    result = prime &* result &+ (mids.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "content": 3, "mids": 4, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToMids_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var content: Data!
    var mids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .string):           content = try Data.read(from: proto)
        case (4, .list):            mids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(content, named: "content")
    try proto.validateValue(mids, named: "mids")

    return BuddyManagementService_sendBuddyContentMessageToMids_args(requestId: requestId, msg: msg, content: content, mids: mids)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToMids_result {

  fileprivate var success: SendBuddyMessageResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SendBuddyMessageResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToMids_result, rhs: BuddyManagementService_sendBuddyContentMessageToMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyContentMessageToMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToMids_result {
    _ = try proto.readStructBegin()
    var success: SendBuddyMessageResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SendBuddyMessageResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyContentMessageToMids_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToMidsAsync_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var content: Data

  fileprivate var mids: TList<String>


  fileprivate init(requestId: String, msg: Message, content: Data, mids: TList<String>) {
    self.requestId = requestId
    self.msg = msg
    self.content = content
    self.mids = mids
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToMidsAsync_args, rhs: BuddyManagementService_sendBuddyContentMessageToMidsAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.content == rhs.content) &&
    (lhs.mids == rhs.mids)
}

extension BuddyManagementService_sendBuddyContentMessageToMidsAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (content.hashValue)
    result = prime &* result &+ (mids.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToMidsAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "content": 3, "mids": 4, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToMidsAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToMidsAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var content: Data!
    var mids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .string):           content = try Data.read(from: proto)
        case (4, .list):            mids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(content, named: "content")
    try proto.validateValue(mids, named: "mids")

    return BuddyManagementService_sendBuddyContentMessageToMidsAsync_args(requestId: requestId, msg: msg, content: content, mids: mids)
  }

}



fileprivate final class BuddyManagementService_sendBuddyContentMessageToMidsAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyContentMessageToMidsAsync_result, rhs: BuddyManagementService_sendBuddyContentMessageToMidsAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyContentMessageToMidsAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyContentMessageToMidsAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyContentMessageToMidsAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyContentMessageToMidsAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyContentMessageToMidsAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToAll_args {

  fileprivate var requestId: String

  fileprivate var msg: Message


  fileprivate init(requestId: String, msg: Message) {
    self.requestId = requestId
    self.msg = msg
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToAll_args, rhs: BuddyManagementService_sendBuddyMessageToAll_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg)
}

extension BuddyManagementService_sendBuddyMessageToAll_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToAll_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToAll_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToAll_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")

    return BuddyManagementService_sendBuddyMessageToAll_args(requestId: requestId, msg: msg)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToAll_result {

  fileprivate var success: SendBuddyMessageResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SendBuddyMessageResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToAll_result, rhs: BuddyManagementService_sendBuddyMessageToAll_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyMessageToAll_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToAll_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToAll_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToAll_result {
    _ = try proto.readStructBegin()
    var success: SendBuddyMessageResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SendBuddyMessageResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyMessageToAll_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToAllAsync_args {

  fileprivate var requestId: String

  fileprivate var msg: Message


  fileprivate init(requestId: String, msg: Message) {
    self.requestId = requestId
    self.msg = msg
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToAllAsync_args, rhs: BuddyManagementService_sendBuddyMessageToAllAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg)
}

extension BuddyManagementService_sendBuddyMessageToAllAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToAllAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToAllAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToAllAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")

    return BuddyManagementService_sendBuddyMessageToAllAsync_args(requestId: requestId, msg: msg)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToAllAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToAllAsync_result, rhs: BuddyManagementService_sendBuddyMessageToAllAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyMessageToAllAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToAllAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToAllAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToAllAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyMessageToAllAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToMids_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var mids: TList<String>


  fileprivate init(requestId: String, msg: Message, mids: TList<String>) {
    self.requestId = requestId
    self.msg = msg
    self.mids = mids
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToMids_args, rhs: BuddyManagementService_sendBuddyMessageToMids_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.mids == rhs.mids)
}

extension BuddyManagementService_sendBuddyMessageToMids_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (mids.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "mids": 3, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToMids_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var mids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .list):            mids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(mids, named: "mids")

    return BuddyManagementService_sendBuddyMessageToMids_args(requestId: requestId, msg: msg, mids: mids)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToMids_result {

  fileprivate var success: SendBuddyMessageResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SendBuddyMessageResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToMids_result, rhs: BuddyManagementService_sendBuddyMessageToMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyMessageToMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToMids_result {
    _ = try proto.readStructBegin()
    var success: SendBuddyMessageResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SendBuddyMessageResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyMessageToMids_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToMidsAsync_args {

  fileprivate var requestId: String

  fileprivate var msg: Message

  fileprivate var mids: TList<String>


  fileprivate init(requestId: String, msg: Message, mids: TList<String>) {
    self.requestId = requestId
    self.msg = msg
    self.mids = mids
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToMidsAsync_args, rhs: BuddyManagementService_sendBuddyMessageToMidsAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.msg == rhs.msg) &&
    (lhs.mids == rhs.mids)
}

extension BuddyManagementService_sendBuddyMessageToMidsAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (msg.hashValue)
    result = prime &* result &+ (mids.hashValue)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToMidsAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "msg": 2, "mids": 3, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToMidsAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToMidsAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var msg: Message!
    var mids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           msg = try Message.read(from: proto)
        case (3, .list):            mids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(msg, named: "msg")
    try proto.validateValue(mids, named: "mids")

    return BuddyManagementService_sendBuddyMessageToMidsAsync_args(requestId: requestId, msg: msg, mids: mids)
  }

}



fileprivate final class BuddyManagementService_sendBuddyMessageToMidsAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendBuddyMessageToMidsAsync_result, rhs: BuddyManagementService_sendBuddyMessageToMidsAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendBuddyMessageToMidsAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendBuddyMessageToMidsAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendBuddyMessageToMidsAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendBuddyMessageToMidsAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendBuddyMessageToMidsAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_sendIndividualEventToAllAsync_args {

  fileprivate var requestId: String

  fileprivate var buddyMid: String

  fileprivate var notificationStatus: NotificationStatus


  fileprivate init(requestId: String, buddyMid: String, notificationStatus: NotificationStatus) {
    self.requestId = requestId
    self.buddyMid = buddyMid
    self.notificationStatus = notificationStatus
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendIndividualEventToAllAsync_args, rhs: BuddyManagementService_sendIndividualEventToAllAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.buddyMid == rhs.buddyMid) &&
    (lhs.notificationStatus == rhs.notificationStatus)
}

extension BuddyManagementService_sendIndividualEventToAllAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (buddyMid.hashValue)
    result = prime &* result &+ (notificationStatus.hashValue)
    return result
  }

}

extension BuddyManagementService_sendIndividualEventToAllAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "buddyMid": 2, "notificationStatus": 3, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendIndividualEventToAllAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendIndividualEventToAllAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var buddyMid: String!
    var notificationStatus: NotificationStatus!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           buddyMid = try String.read(from: proto)
        case (3, .i32):             notificationStatus = try NotificationStatus.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(buddyMid, named: "buddyMid")
    try proto.validateValue(notificationStatus, named: "notificationStatus")

    return BuddyManagementService_sendIndividualEventToAllAsync_args(requestId: requestId, buddyMid: buddyMid, notificationStatus: notificationStatus)
  }

}



fileprivate final class BuddyManagementService_sendIndividualEventToAllAsync_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_sendIndividualEventToAllAsync_result, rhs: BuddyManagementService_sendIndividualEventToAllAsync_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_sendIndividualEventToAllAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_sendIndividualEventToAllAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_sendIndividualEventToAllAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_sendIndividualEventToAllAsync_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_sendIndividualEventToAllAsync_result(e: e)
  }

}



fileprivate final class BuddyManagementService_setBuddyOnAir_args {

  fileprivate var requestId: String

  fileprivate var onAir: Bool


  fileprivate init(requestId: String, onAir: Bool) {
    self.requestId = requestId
    self.onAir = onAir
  }

}

fileprivate func ==(lhs: BuddyManagementService_setBuddyOnAir_args, rhs: BuddyManagementService_setBuddyOnAir_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.onAir == rhs.onAir)
}

extension BuddyManagementService_setBuddyOnAir_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (onAir.hashValue)
    return result
  }

}

extension BuddyManagementService_setBuddyOnAir_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "onAir": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_setBuddyOnAir_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_setBuddyOnAir_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var onAir: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .bool):            onAir = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(onAir, named: "onAir")

    return BuddyManagementService_setBuddyOnAir_args(requestId: requestId, onAir: onAir)
  }

}



fileprivate final class BuddyManagementService_setBuddyOnAir_result {

  fileprivate var success: SetBuddyOnAirResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SetBuddyOnAirResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_setBuddyOnAir_result, rhs: BuddyManagementService_setBuddyOnAir_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_setBuddyOnAir_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_setBuddyOnAir_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_setBuddyOnAir_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_setBuddyOnAir_result {
    _ = try proto.readStructBegin()
    var success: SetBuddyOnAirResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SetBuddyOnAirResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_setBuddyOnAir_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_setBuddyOnAirAsync_args {

  fileprivate var requestId: String

  fileprivate var onAir: Bool


  fileprivate init(requestId: String, onAir: Bool) {
    self.requestId = requestId
    self.onAir = onAir
  }

}

fileprivate func ==(lhs: BuddyManagementService_setBuddyOnAirAsync_args, rhs: BuddyManagementService_setBuddyOnAirAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.onAir == rhs.onAir)
}

extension BuddyManagementService_setBuddyOnAirAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (onAir.hashValue)
    return result
  }

}

extension BuddyManagementService_setBuddyOnAirAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "onAir": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_setBuddyOnAirAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_setBuddyOnAirAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var onAir: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .bool):            onAir = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(onAir, named: "onAir")

    return BuddyManagementService_setBuddyOnAirAsync_args(requestId: requestId, onAir: onAir)
  }

}



fileprivate final class BuddyManagementService_setBuddyOnAirAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_setBuddyOnAirAsync_result, rhs: BuddyManagementService_setBuddyOnAirAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_setBuddyOnAirAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_setBuddyOnAirAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_setBuddyOnAirAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_setBuddyOnAirAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_setBuddyOnAirAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_storeMessage_args {

  fileprivate var requestId: String

  fileprivate var messageRequest: BuddyMessageRequest


  fileprivate init(requestId: String, messageRequest: BuddyMessageRequest) {
    self.requestId = requestId
    self.messageRequest = messageRequest
  }

}

fileprivate func ==(lhs: BuddyManagementService_storeMessage_args, rhs: BuddyManagementService_storeMessage_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.messageRequest == rhs.messageRequest)
}

extension BuddyManagementService_storeMessage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (messageRequest.hashValue)
    return result
  }

}

extension BuddyManagementService_storeMessage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "messageRequest": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_storeMessage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_storeMessage_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var messageRequest: BuddyMessageRequest!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .struct):           messageRequest = try BuddyMessageRequest.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(messageRequest, named: "messageRequest")

    return BuddyManagementService_storeMessage_args(requestId: requestId, messageRequest: messageRequest)
  }

}



fileprivate final class BuddyManagementService_storeMessage_result {

  fileprivate var success: SendBuddyMessageResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SendBuddyMessageResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_storeMessage_result, rhs: BuddyManagementService_storeMessage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_storeMessage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_storeMessage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_storeMessage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_storeMessage_result {
    _ = try proto.readStructBegin()
    var success: SendBuddyMessageResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SendBuddyMessageResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_storeMessage_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_unblockBuddyMember_args {

  fileprivate var requestId: String

  fileprivate var mid: String


  fileprivate init(requestId: String, mid: String) {
    self.requestId = requestId
    self.mid = mid
  }

}

fileprivate func ==(lhs: BuddyManagementService_unblockBuddyMember_args, rhs: BuddyManagementService_unblockBuddyMember_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.mid == rhs.mid)
}

extension BuddyManagementService_unblockBuddyMember_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension BuddyManagementService_unblockBuddyMember_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "mid": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_unblockBuddyMember_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_unblockBuddyMember_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(mid, named: "mid")

    return BuddyManagementService_unblockBuddyMember_args(requestId: requestId, mid: mid)
  }

}



fileprivate final class BuddyManagementService_unblockBuddyMember_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_unblockBuddyMember_result, rhs: BuddyManagementService_unblockBuddyMember_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_unblockBuddyMember_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_unblockBuddyMember_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_unblockBuddyMember_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_unblockBuddyMember_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_unblockBuddyMember_result(e: e)
  }

}



fileprivate final class BuddyManagementService_unregisterBuddy_args {

  fileprivate var requestId: String


  fileprivate init(requestId: String) {
    self.requestId = requestId
  }

}

fileprivate func ==(lhs: BuddyManagementService_unregisterBuddy_args, rhs: BuddyManagementService_unregisterBuddy_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId)
}

extension BuddyManagementService_unregisterBuddy_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    return result
  }

}

extension BuddyManagementService_unregisterBuddy_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_unregisterBuddy_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_unregisterBuddy_args {
    _ = try proto.readStructBegin()
    var requestId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")

    return BuddyManagementService_unregisterBuddy_args(requestId: requestId)
  }

}



fileprivate final class BuddyManagementService_unregisterBuddy_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_unregisterBuddy_result, rhs: BuddyManagementService_unregisterBuddy_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_unregisterBuddy_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_unregisterBuddy_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_unregisterBuddy_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_unregisterBuddy_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_unregisterBuddy_result(e: e)
  }

}



fileprivate final class BuddyManagementService_unregisterBuddyAdmin_args {

  fileprivate var requestId: String


  fileprivate init(requestId: String) {
    self.requestId = requestId
  }

}

fileprivate func ==(lhs: BuddyManagementService_unregisterBuddyAdmin_args, rhs: BuddyManagementService_unregisterBuddyAdmin_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId)
}

extension BuddyManagementService_unregisterBuddyAdmin_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    return result
  }

}

extension BuddyManagementService_unregisterBuddyAdmin_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_unregisterBuddyAdmin_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_unregisterBuddyAdmin_args {
    _ = try proto.readStructBegin()
    var requestId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")

    return BuddyManagementService_unregisterBuddyAdmin_args(requestId: requestId)
  }

}



fileprivate final class BuddyManagementService_unregisterBuddyAdmin_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_unregisterBuddyAdmin_result, rhs: BuddyManagementService_unregisterBuddyAdmin_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_unregisterBuddyAdmin_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_unregisterBuddyAdmin_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_unregisterBuddyAdmin_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_unregisterBuddyAdmin_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_unregisterBuddyAdmin_result(e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddyAdminProfileAttribute_args {

  fileprivate var requestId: String

  fileprivate var attributes: TMap<String, String>


  fileprivate init(requestId: String, attributes: TMap<String, String>) {
    self.requestId = requestId
    self.attributes = attributes
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyAdminProfileAttribute_args, rhs: BuddyManagementService_updateBuddyAdminProfileAttribute_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.attributes == rhs.attributes)
}

extension BuddyManagementService_updateBuddyAdminProfileAttribute_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (attributes.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddyAdminProfileAttribute_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "attributes": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyAdminProfileAttribute_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyAdminProfileAttribute_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var attributes: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .map):             attributes = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(attributes, named: "attributes")

    return BuddyManagementService_updateBuddyAdminProfileAttribute_args(requestId: requestId, attributes: attributes)
  }

}



fileprivate final class BuddyManagementService_updateBuddyAdminProfileAttribute_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyAdminProfileAttribute_result, rhs: BuddyManagementService_updateBuddyAdminProfileAttribute_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddyAdminProfileAttribute_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddyAdminProfileAttribute_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyAdminProfileAttribute_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyAdminProfileAttribute_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddyAdminProfileAttribute_result(e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddyAdminProfileImage_args {

  fileprivate var requestId: String

  fileprivate var picture: Data


  fileprivate init(requestId: String, picture: Data) {
    self.requestId = requestId
    self.picture = picture
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyAdminProfileImage_args, rhs: BuddyManagementService_updateBuddyAdminProfileImage_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.picture == rhs.picture)
}

extension BuddyManagementService_updateBuddyAdminProfileImage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (picture.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddyAdminProfileImage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "picture": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyAdminProfileImage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyAdminProfileImage_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var picture: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           picture = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(picture, named: "picture")

    return BuddyManagementService_updateBuddyAdminProfileImage_args(requestId: requestId, picture: picture)
  }

}



fileprivate final class BuddyManagementService_updateBuddyAdminProfileImage_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyAdminProfileImage_result, rhs: BuddyManagementService_updateBuddyAdminProfileImage_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddyAdminProfileImage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddyAdminProfileImage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyAdminProfileImage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyAdminProfileImage_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddyAdminProfileImage_result(e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileAttributes_args {

  fileprivate var requestId: String

  fileprivate var attributes: TMap<String, String>


  fileprivate init(requestId: String, attributes: TMap<String, String>) {
    self.requestId = requestId
    self.attributes = attributes
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileAttributes_args, rhs: BuddyManagementService_updateBuddyProfileAttributes_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.attributes == rhs.attributes)
}

extension BuddyManagementService_updateBuddyProfileAttributes_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (attributes.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileAttributes_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "attributes": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileAttributes_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileAttributes_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var attributes: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .map):             attributes = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(attributes, named: "attributes")

    return BuddyManagementService_updateBuddyProfileAttributes_args(requestId: requestId, attributes: attributes)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileAttributes_result {

  fileprivate var success: UpdateBuddyProfileResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: UpdateBuddyProfileResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileAttributes_result, rhs: BuddyManagementService_updateBuddyProfileAttributes_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddyProfileAttributes_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileAttributes_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileAttributes_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileAttributes_result {
    _ = try proto.readStructBegin()
    var success: UpdateBuddyProfileResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try UpdateBuddyProfileResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddyProfileAttributes_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileAttributesAsync_args {

  fileprivate var requestId: String

  fileprivate var attributes: TMap<String, String>


  fileprivate init(requestId: String, attributes: TMap<String, String>) {
    self.requestId = requestId
    self.attributes = attributes
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileAttributesAsync_args, rhs: BuddyManagementService_updateBuddyProfileAttributesAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.attributes == rhs.attributes)
}

extension BuddyManagementService_updateBuddyProfileAttributesAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (attributes.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileAttributesAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "attributes": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileAttributesAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileAttributesAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var attributes: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .map):             attributes = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(attributes, named: "attributes")

    return BuddyManagementService_updateBuddyProfileAttributesAsync_args(requestId: requestId, attributes: attributes)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileAttributesAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileAttributesAsync_result, rhs: BuddyManagementService_updateBuddyProfileAttributesAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddyProfileAttributesAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileAttributesAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileAttributesAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileAttributesAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddyProfileAttributesAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileImage_args {

  fileprivate var requestId: String

  fileprivate var image: Data


  fileprivate init(requestId: String, image: Data) {
    self.requestId = requestId
    self.image = image
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileImage_args, rhs: BuddyManagementService_updateBuddyProfileImage_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.image == rhs.image)
}

extension BuddyManagementService_updateBuddyProfileImage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (image.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileImage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "image": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileImage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileImage_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var image: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           image = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(image, named: "image")

    return BuddyManagementService_updateBuddyProfileImage_args(requestId: requestId, image: image)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileImage_result {

  fileprivate var success: UpdateBuddyProfileResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: UpdateBuddyProfileResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileImage_result, rhs: BuddyManagementService_updateBuddyProfileImage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddyProfileImage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileImage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileImage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileImage_result {
    _ = try proto.readStructBegin()
    var success: UpdateBuddyProfileResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try UpdateBuddyProfileResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddyProfileImage_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileImageAsync_args {

  fileprivate var requestId: String

  fileprivate var image: Data


  fileprivate init(requestId: String, image: Data) {
    self.requestId = requestId
    self.image = image
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileImageAsync_args, rhs: BuddyManagementService_updateBuddyProfileImageAsync_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.image == rhs.image)
}

extension BuddyManagementService_updateBuddyProfileImageAsync_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (image.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileImageAsync_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "image": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileImageAsync_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileImageAsync_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var image: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           image = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(image, named: "image")

    return BuddyManagementService_updateBuddyProfileImageAsync_args(requestId: requestId, image: image)
  }

}



fileprivate final class BuddyManagementService_updateBuddyProfileImageAsync_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddyProfileImageAsync_result, rhs: BuddyManagementService_updateBuddyProfileImageAsync_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddyProfileImageAsync_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddyProfileImageAsync_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddyProfileImageAsync_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddyProfileImageAsync_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddyProfileImageAsync_result(success: success, e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddySearchId_args {

  fileprivate var requestId: String

  fileprivate var searchId: String


  fileprivate init(requestId: String, searchId: String) {
    self.requestId = requestId
    self.searchId = searchId
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddySearchId_args, rhs: BuddyManagementService_updateBuddySearchId_args) -> Bool {
  return
    (lhs.requestId == rhs.requestId) &&
    (lhs.searchId == rhs.searchId)
}

extension BuddyManagementService_updateBuddySearchId_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (requestId.hashValue)
    result = prime &* result &+ (searchId.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddySearchId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["requestId": 1, "searchId": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddySearchId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddySearchId_args {
    _ = try proto.readStructBegin()
    var requestId: String!
    var searchId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           requestId = try String.read(from: proto)
        case (2, .string):           searchId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestId, named: "requestId")
    try proto.validateValue(searchId, named: "searchId")

    return BuddyManagementService_updateBuddySearchId_args(requestId: requestId, searchId: searchId)
  }

}



fileprivate final class BuddyManagementService_updateBuddySearchId_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddySearchId_result, rhs: BuddyManagementService_updateBuddySearchId_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddySearchId_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddySearchId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddySearchId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddySearchId_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddySearchId_result(e: e)
  }

}



fileprivate final class BuddyManagementService_updateBuddySettings_args {

  fileprivate var settings: TMap<String, String>


  fileprivate init(settings: TMap<String, String>) {
    self.settings = settings
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddySettings_args, rhs: BuddyManagementService_updateBuddySettings_args) -> Bool {
  return
    (lhs.settings == rhs.settings)
}

extension BuddyManagementService_updateBuddySettings_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (settings.hashValue)
    return result
  }

}

extension BuddyManagementService_updateBuddySettings_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["settings": 2, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddySettings_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddySettings_args {
    _ = try proto.readStructBegin()
    var settings: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .map):             settings = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(settings, named: "settings")

    return BuddyManagementService_updateBuddySettings_args(settings: settings)
  }

}



fileprivate final class BuddyManagementService_updateBuddySettings_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_updateBuddySettings_result, rhs: BuddyManagementService_updateBuddySettings_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension BuddyManagementService_updateBuddySettings_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_updateBuddySettings_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_updateBuddySettings_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_updateBuddySettings_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_updateBuddySettings_result(e: e)
  }

}



fileprivate final class BuddyManagementService_uploadBuddyContent_args {

  fileprivate var contentType: ContentType

  fileprivate var content: Data


  fileprivate init(contentType: ContentType, content: Data) {
    self.contentType = contentType
    self.content = content
  }

}

fileprivate func ==(lhs: BuddyManagementService_uploadBuddyContent_args, rhs: BuddyManagementService_uploadBuddyContent_args) -> Bool {
  return
    (lhs.contentType == rhs.contentType) &&
    (lhs.content == rhs.content)
}

extension BuddyManagementService_uploadBuddyContent_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (contentType.hashValue)
    result = prime &* result &+ (content.hashValue)
    return result
  }

}

extension BuddyManagementService_uploadBuddyContent_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["contentType": 2, "content": 3, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_uploadBuddyContent_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_uploadBuddyContent_args {
    _ = try proto.readStructBegin()
    var contentType: ContentType!
    var content: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             contentType = try ContentType.read(from: proto)
        case (3, .string):           content = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(contentType, named: "contentType")
    try proto.validateValue(content, named: "content")

    return BuddyManagementService_uploadBuddyContent_args(contentType: contentType, content: content)
  }

}



fileprivate final class BuddyManagementService_uploadBuddyContent_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyManagementService_uploadBuddyContent_result, rhs: BuddyManagementService_uploadBuddyContent_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyManagementService_uploadBuddyContent_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyManagementService_uploadBuddyContent_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyManagementService_uploadBuddyContent_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyManagementService_uploadBuddyContent_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyManagementService_uploadBuddyContent_result(success: success, e: e)
  }

}



extension BuddyManagementServiceClient : BuddyManagementService {

  private func send_addBuddyMember(requestId: String, userMid: String) throws {
    try outProtocol.writeMessageBegin(name: "addBuddyMember", type: .call, sequenceID: 0)
    let args = BuddyManagementService_addBuddyMember_args(requestId: requestId, userMid: userMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_addBuddyMember() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_addBuddyMember_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func addBuddyMember(requestId: String, userMid: String) throws {
    try send_addBuddyMember(requestId: requestId, userMid: userMid)
    try outProtocol.transport.flush()
    try recv_addBuddyMember()
  }

  private func send_addBuddyMembers(requestId: String, userMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "addBuddyMembers", type: .call, sequenceID: 0)
    let args = BuddyManagementService_addBuddyMembers_args(requestId: requestId, userMids: userMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_addBuddyMembers() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_addBuddyMembers_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func addBuddyMembers(requestId: String, userMids: TList<String>) throws {
    try send_addBuddyMembers(requestId: requestId, userMids: userMids)
    try outProtocol.transport.flush()
    try recv_addBuddyMembers()
  }

  private func send_blockBuddyMember(requestId: String, mid: String) throws {
    try outProtocol.writeMessageBegin(name: "blockBuddyMember", type: .call, sequenceID: 0)
    let args = BuddyManagementService_blockBuddyMember_args(requestId: requestId, mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_blockBuddyMember() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_blockBuddyMember_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func blockBuddyMember(requestId: String, mid: String) throws {
    try send_blockBuddyMember(requestId: requestId, mid: mid)
    try outProtocol.transport.flush()
    try recv_blockBuddyMember()
  }

  private func send_commitSendMessagesToAll(requestIdList: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "commitSendMessagesToAll", type: .call, sequenceID: 0)
    let args = BuddyManagementService_commitSendMessagesToAll_args(requestIdList: requestIdList)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_commitSendMessagesToAll() throws -> TList<SendBuddyMessageResult> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_commitSendMessagesToAll_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "commitSendMessagesToAll"))
  }

  public func commitSendMessagesToAll(requestIdList: TList<String>) throws -> TList<SendBuddyMessageResult> {
    try send_commitSendMessagesToAll(requestIdList: requestIdList)
    try outProtocol.transport.flush()
    return try recv_commitSendMessagesToAll()
  }

  private func send_commitSendMessagesToMids(requestIdList: TList<String>, mids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "commitSendMessagesToMids", type: .call, sequenceID: 0)
    let args = BuddyManagementService_commitSendMessagesToMids_args(requestIdList: requestIdList, mids: mids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_commitSendMessagesToMids() throws -> TList<SendBuddyMessageResult> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_commitSendMessagesToMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "commitSendMessagesToMids"))
  }

  public func commitSendMessagesToMids(requestIdList: TList<String>, mids: TList<String>) throws -> TList<SendBuddyMessageResult> {
    try send_commitSendMessagesToMids(requestIdList: requestIdList, mids: mids)
    try outProtocol.transport.flush()
    return try recv_commitSendMessagesToMids()
  }

  private func send_containsBuddyMember(requestId: String, userMid: String) throws {
    try outProtocol.writeMessageBegin(name: "containsBuddyMember", type: .call, sequenceID: 0)
    let args = BuddyManagementService_containsBuddyMember_args(requestId: requestId, userMid: userMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_containsBuddyMember() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_containsBuddyMember_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "containsBuddyMember"))
  }

  public func containsBuddyMember(requestId: String, userMid: String) throws -> Bool {
    try send_containsBuddyMember(requestId: requestId, userMid: userMid)
    try outProtocol.transport.flush()
    return try recv_containsBuddyMember()
  }

  private func send_downloadMessageContent(requestId: String, messageId: String) throws {
    try outProtocol.writeMessageBegin(name: "downloadMessageContent", type: .call, sequenceID: 0)
    let args = BuddyManagementService_downloadMessageContent_args(requestId: requestId, messageId: messageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_downloadMessageContent() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_downloadMessageContent_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "downloadMessageContent"))
  }

  public func downloadMessageContent(requestId: String, messageId: String) throws -> Data {
    try send_downloadMessageContent(requestId: requestId, messageId: messageId)
    try outProtocol.transport.flush()
    return try recv_downloadMessageContent()
  }

  private func send_downloadMessageContentPreview(requestId: String, messageId: String) throws {
    try outProtocol.writeMessageBegin(name: "downloadMessageContentPreview", type: .call, sequenceID: 0)
    let args = BuddyManagementService_downloadMessageContentPreview_args(requestId: requestId, messageId: messageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_downloadMessageContentPreview() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_downloadMessageContentPreview_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "downloadMessageContentPreview"))
  }

  public func downloadMessageContentPreview(requestId: String, messageId: String) throws -> Data {
    try send_downloadMessageContentPreview(requestId: requestId, messageId: messageId)
    try outProtocol.transport.flush()
    return try recv_downloadMessageContentPreview()
  }

  private func send_downloadProfileImage(requestId: String) throws {
    try outProtocol.writeMessageBegin(name: "downloadProfileImage", type: .call, sequenceID: 0)
    let args = BuddyManagementService_downloadProfileImage_args(requestId: requestId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_downloadProfileImage() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_downloadProfileImage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "downloadProfileImage"))
  }

  public func downloadProfileImage(requestId: String) throws -> Data {
    try send_downloadProfileImage(requestId: requestId)
    try outProtocol.transport.flush()
    return try recv_downloadProfileImage()
  }

  private func send_downloadProfileImagePreview(requestId: String) throws {
    try outProtocol.writeMessageBegin(name: "downloadProfileImagePreview", type: .call, sequenceID: 0)
    let args = BuddyManagementService_downloadProfileImagePreview_args(requestId: requestId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_downloadProfileImagePreview() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_downloadProfileImagePreview_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "downloadProfileImagePreview"))
  }

  public func downloadProfileImagePreview(requestId: String) throws -> Data {
    try send_downloadProfileImagePreview(requestId: requestId)
    try outProtocol.transport.flush()
    return try recv_downloadProfileImagePreview()
  }

  private func send_getActiveMemberCountByBuddyMid(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "getActiveMemberCountByBuddyMid", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getActiveMemberCountByBuddyMid_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getActiveMemberCountByBuddyMid() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getActiveMemberCountByBuddyMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getActiveMemberCountByBuddyMid"))
  }

  public func getActiveMemberCountByBuddyMid(buddyMid: String) throws -> Int64 {
    try send_getActiveMemberCountByBuddyMid(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_getActiveMemberCountByBuddyMid()
  }

  private func send_getActiveMemberMidsByBuddyMid(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "getActiveMemberMidsByBuddyMid", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getActiveMemberMidsByBuddyMid_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getActiveMemberMidsByBuddyMid() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getActiveMemberMidsByBuddyMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getActiveMemberMidsByBuddyMid"))
  }

  public func getActiveMemberMidsByBuddyMid(buddyMid: String) throws -> TList<String> {
    try send_getActiveMemberMidsByBuddyMid(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_getActiveMemberMidsByBuddyMid()
  }

  private func send_getAllBuddyMembers() throws {
    try outProtocol.writeMessageBegin(name: "getAllBuddyMembers", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getAllBuddyMembers_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getAllBuddyMembers() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getAllBuddyMembers_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getAllBuddyMembers"))
  }

  public func getAllBuddyMembers() throws -> TList<String> {
    try send_getAllBuddyMembers()
    try outProtocol.transport.flush()
    return try recv_getAllBuddyMembers()
  }

  private func send_getBlockedBuddyMembers() throws {
    try outProtocol.writeMessageBegin(name: "getBlockedBuddyMembers", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getBlockedBuddyMembers_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBlockedBuddyMembers() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getBlockedBuddyMembers_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBlockedBuddyMembers"))
  }

  public func getBlockedBuddyMembers() throws -> TList<String> {
    try send_getBlockedBuddyMembers()
    try outProtocol.transport.flush()
    return try recv_getBlockedBuddyMembers()
  }

  private func send_getBlockerCountByBuddyMid(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "getBlockerCountByBuddyMid", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getBlockerCountByBuddyMid_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBlockerCountByBuddyMid() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getBlockerCountByBuddyMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBlockerCountByBuddyMid"))
  }

  public func getBlockerCountByBuddyMid(buddyMid: String) throws -> Int64 {
    try send_getBlockerCountByBuddyMid(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_getBlockerCountByBuddyMid()
  }

  private func send_getBuddyDetailByMid(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "getBuddyDetailByMid", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getBuddyDetailByMid_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBuddyDetailByMid() throws -> BuddyDetail {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getBuddyDetailByMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBuddyDetailByMid"))
  }

  public func getBuddyDetailByMid(buddyMid: String) throws -> BuddyDetail {
    try send_getBuddyDetailByMid(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_getBuddyDetailByMid()
  }

  private func send_getBuddyProfile() throws {
    try outProtocol.writeMessageBegin(name: "getBuddyProfile", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getBuddyProfile_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBuddyProfile() throws -> BuddyProfile {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getBuddyProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBuddyProfile"))
  }

  public func getBuddyProfile() throws -> BuddyProfile {
    try send_getBuddyProfile()
    try outProtocol.transport.flush()
    return try recv_getBuddyProfile()
  }

  private func send_getContactTicket() throws {
    try outProtocol.writeMessageBegin(name: "getContactTicket", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getContactTicket_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getContactTicket() throws -> Ticket {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getContactTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getContactTicket"))
  }

  public func getContactTicket() throws -> Ticket {
    try send_getContactTicket()
    try outProtocol.transport.flush()
    return try recv_getContactTicket()
  }

  private func send_getMemberCountByBuddyMid(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "getMemberCountByBuddyMid", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getMemberCountByBuddyMid_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMemberCountByBuddyMid() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getMemberCountByBuddyMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMemberCountByBuddyMid"))
  }

  public func getMemberCountByBuddyMid(buddyMid: String) throws -> Int64 {
    try send_getMemberCountByBuddyMid(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_getMemberCountByBuddyMid()
  }

  private func send_getSendBuddyMessageResult(sendBuddyMessageRequestId: String) throws {
    try outProtocol.writeMessageBegin(name: "getSendBuddyMessageResult", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getSendBuddyMessageResult_args(sendBuddyMessageRequestId: sendBuddyMessageRequestId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSendBuddyMessageResult() throws -> SendBuddyMessageResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getSendBuddyMessageResult_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSendBuddyMessageResult"))
  }

  public func getSendBuddyMessageResult(sendBuddyMessageRequestId: String) throws -> SendBuddyMessageResult {
    try send_getSendBuddyMessageResult(sendBuddyMessageRequestId: sendBuddyMessageRequestId)
    try outProtocol.transport.flush()
    return try recv_getSendBuddyMessageResult()
  }

  private func send_getSetBuddyOnAirResult(setBuddyOnAirRequestId: String) throws {
    try outProtocol.writeMessageBegin(name: "getSetBuddyOnAirResult", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getSetBuddyOnAirResult_args(setBuddyOnAirRequestId: setBuddyOnAirRequestId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSetBuddyOnAirResult() throws -> SetBuddyOnAirResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getSetBuddyOnAirResult_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSetBuddyOnAirResult"))
  }

  public func getSetBuddyOnAirResult(setBuddyOnAirRequestId: String) throws -> SetBuddyOnAirResult {
    try send_getSetBuddyOnAirResult(setBuddyOnAirRequestId: setBuddyOnAirRequestId)
    try outProtocol.transport.flush()
    return try recv_getSetBuddyOnAirResult()
  }

  private func send_getUpdateBuddyProfileResult(updateBuddyProfileRequestId: String) throws {
    try outProtocol.writeMessageBegin(name: "getUpdateBuddyProfileResult", type: .call, sequenceID: 0)
    let args = BuddyManagementService_getUpdateBuddyProfileResult_args(updateBuddyProfileRequestId: updateBuddyProfileRequestId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUpdateBuddyProfileResult() throws -> UpdateBuddyProfileResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_getUpdateBuddyProfileResult_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getUpdateBuddyProfileResult"))
  }

  public func getUpdateBuddyProfileResult(updateBuddyProfileRequestId: String) throws -> UpdateBuddyProfileResult {
    try send_getUpdateBuddyProfileResult(updateBuddyProfileRequestId: updateBuddyProfileRequestId)
    try outProtocol.transport.flush()
    return try recv_getUpdateBuddyProfileResult()
  }

  private func send_isBuddyOnAirByMid(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "isBuddyOnAirByMid", type: .call, sequenceID: 0)
    let args = BuddyManagementService_isBuddyOnAirByMid_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isBuddyOnAirByMid() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_isBuddyOnAirByMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "isBuddyOnAirByMid"))
  }

  public func isBuddyOnAirByMid(buddyMid: String) throws -> Bool {
    try send_isBuddyOnAirByMid(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_isBuddyOnAirByMid()
  }

  private func send_linkAndSendBuddyContentMessageToAllAsync(requestId: String, msg: Message, sourceContentId: String) throws {
    try outProtocol.writeMessageBegin(name: "linkAndSendBuddyContentMessageToAllAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args(requestId: requestId, msg: msg, sourceContentId: sourceContentId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_linkAndSendBuddyContentMessageToAllAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "linkAndSendBuddyContentMessageToAllAsync"))
  }

  public func linkAndSendBuddyContentMessageToAllAsync(requestId: String, msg: Message, sourceContentId: String) throws -> String {
    try send_linkAndSendBuddyContentMessageToAllAsync(requestId: requestId, msg: msg, sourceContentId: sourceContentId)
    try outProtocol.transport.flush()
    return try recv_linkAndSendBuddyContentMessageToAllAsync()
  }

  private func send_linkAndSendBuddyContentMessageToMids(requestId: String, msg: Message, sourceContentId: String, mids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "linkAndSendBuddyContentMessageToMids", type: .call, sequenceID: 0)
    let args = BuddyManagementService_linkAndSendBuddyContentMessageToMids_args(requestId: requestId, msg: msg, sourceContentId: sourceContentId, mids: mids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_linkAndSendBuddyContentMessageToMids() throws -> SendBuddyMessageResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_linkAndSendBuddyContentMessageToMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "linkAndSendBuddyContentMessageToMids"))
  }

  public func linkAndSendBuddyContentMessageToMids(requestId: String, msg: Message, sourceContentId: String, mids: TList<String>) throws -> SendBuddyMessageResult {
    try send_linkAndSendBuddyContentMessageToMids(requestId: requestId, msg: msg, sourceContentId: sourceContentId, mids: mids)
    try outProtocol.transport.flush()
    return try recv_linkAndSendBuddyContentMessageToMids()
  }

  private func send_notifyBuddyBlocked(buddyMid: String, blockerMid: String) throws {
    try outProtocol.writeMessageBegin(name: "notifyBuddyBlocked", type: .call, sequenceID: 0)
    let args = BuddyManagementService_notifyBuddyBlocked_args(buddyMid: buddyMid, blockerMid: blockerMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyBuddyBlocked() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_notifyBuddyBlocked_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notifyBuddyBlocked(buddyMid: String, blockerMid: String) throws {
    try send_notifyBuddyBlocked(buddyMid: buddyMid, blockerMid: blockerMid)
    try outProtocol.transport.flush()
    try recv_notifyBuddyBlocked()
  }

  private func send_notifyBuddyUnblocked(buddyMid: String, blockerMid: String) throws {
    try outProtocol.writeMessageBegin(name: "notifyBuddyUnblocked", type: .call, sequenceID: 0)
    let args = BuddyManagementService_notifyBuddyUnblocked_args(buddyMid: buddyMid, blockerMid: blockerMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyBuddyUnblocked() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_notifyBuddyUnblocked_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notifyBuddyUnblocked(buddyMid: String, blockerMid: String) throws {
    try send_notifyBuddyUnblocked(buddyMid: buddyMid, blockerMid: blockerMid)
    try outProtocol.transport.flush()
    try recv_notifyBuddyUnblocked()
  }

  private func send_registerBuddy(buddyId: String, searchId: String, displayName: String, statusMeessage: String, picture: Data, settings: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "registerBuddy", type: .call, sequenceID: 0)
    let args = BuddyManagementService_registerBuddy_args(buddyId: buddyId, searchId: searchId, displayName: displayName, statusMeessage: statusMeessage, picture: picture, settings: settings)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerBuddy() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_registerBuddy_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerBuddy"))
  }

  public func registerBuddy(buddyId: String, searchId: String, displayName: String, statusMeessage: String, picture: Data, settings: TMap<String, String>) throws -> String {
    try send_registerBuddy(buddyId: buddyId, searchId: searchId, displayName: displayName, statusMeessage: statusMeessage, picture: picture, settings: settings)
    try outProtocol.transport.flush()
    return try recv_registerBuddy()
  }

  private func send_registerBuddyAdmin(buddyId: String, searchId: String, displayName: String, statusMessage: String, picture: Data) throws {
    try outProtocol.writeMessageBegin(name: "registerBuddyAdmin", type: .call, sequenceID: 0)
    let args = BuddyManagementService_registerBuddyAdmin_args(buddyId: buddyId, searchId: searchId, displayName: displayName, statusMessage: statusMessage, picture: picture)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerBuddyAdmin() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_registerBuddyAdmin_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerBuddyAdmin"))
  }

  public func registerBuddyAdmin(buddyId: String, searchId: String, displayName: String, statusMessage: String, picture: Data) throws -> String {
    try send_registerBuddyAdmin(buddyId: buddyId, searchId: searchId, displayName: displayName, statusMessage: statusMessage, picture: picture)
    try outProtocol.transport.flush()
    return try recv_registerBuddyAdmin()
  }

  private func send_reissueContactTicket(expirationTime: Int64, maxUseCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "reissueContactTicket", type: .call, sequenceID: 0)
    let args = BuddyManagementService_reissueContactTicket_args(expirationTime: expirationTime, maxUseCount: maxUseCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reissueContactTicket() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_reissueContactTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "reissueContactTicket"))
  }

  public func reissueContactTicket(expirationTime: Int64, maxUseCount: Int32) throws -> String {
    try send_reissueContactTicket(expirationTime: expirationTime, maxUseCount: maxUseCount)
    try outProtocol.transport.flush()
    return try recv_reissueContactTicket()
  }

  private func send_removeBuddyMember(requestId: String, userMid: String) throws {
    try outProtocol.writeMessageBegin(name: "removeBuddyMember", type: .call, sequenceID: 0)
    let args = BuddyManagementService_removeBuddyMember_args(requestId: requestId, userMid: userMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeBuddyMember() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_removeBuddyMember_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func removeBuddyMember(requestId: String, userMid: String) throws {
    try send_removeBuddyMember(requestId: requestId, userMid: userMid)
    try outProtocol.transport.flush()
    try recv_removeBuddyMember()
  }

  private func send_removeBuddyMembers(requestId: String, userMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "removeBuddyMembers", type: .call, sequenceID: 0)
    let args = BuddyManagementService_removeBuddyMembers_args(requestId: requestId, userMids: userMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeBuddyMembers() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_removeBuddyMembers_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func removeBuddyMembers(requestId: String, userMids: TList<String>) throws {
    try send_removeBuddyMembers(requestId: requestId, userMids: userMids)
    try outProtocol.transport.flush()
    try recv_removeBuddyMembers()
  }

  private func send_sendBuddyContentMessageToAll(requestId: String, msg: Message, content: Data) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToAll", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyContentMessageToAll_args(requestId: requestId, msg: msg, content: content)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyContentMessageToAll() throws -> SendBuddyMessageResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyContentMessageToAll_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyContentMessageToAll"))
  }

  public func sendBuddyContentMessageToAll(requestId: String, msg: Message, content: Data) throws -> SendBuddyMessageResult {
    try send_sendBuddyContentMessageToAll(requestId: requestId, msg: msg, content: content)
    try outProtocol.transport.flush()
    return try recv_sendBuddyContentMessageToAll()
  }

  private func send_sendBuddyContentMessageToAllAsync(requestId: String, msg: Message, content: Data) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToAllAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyContentMessageToAllAsync_args(requestId: requestId, msg: msg, content: content)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyContentMessageToAllAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyContentMessageToAllAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyContentMessageToAllAsync"))
  }

  public func sendBuddyContentMessageToAllAsync(requestId: String, msg: Message, content: Data) throws -> String {
    try send_sendBuddyContentMessageToAllAsync(requestId: requestId, msg: msg, content: content)
    try outProtocol.transport.flush()
    return try recv_sendBuddyContentMessageToAllAsync()
  }

  private func send_sendBuddyContentMessageToMids(requestId: String, msg: Message, content: Data, mids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToMids", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyContentMessageToMids_args(requestId: requestId, msg: msg, content: content, mids: mids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyContentMessageToMids() throws -> SendBuddyMessageResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyContentMessageToMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyContentMessageToMids"))
  }

  public func sendBuddyContentMessageToMids(requestId: String, msg: Message, content: Data, mids: TList<String>) throws -> SendBuddyMessageResult {
    try send_sendBuddyContentMessageToMids(requestId: requestId, msg: msg, content: content, mids: mids)
    try outProtocol.transport.flush()
    return try recv_sendBuddyContentMessageToMids()
  }

  private func send_sendBuddyContentMessageToMidsAsync(requestId: String, msg: Message, content: Data, mids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToMidsAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyContentMessageToMidsAsync_args(requestId: requestId, msg: msg, content: content, mids: mids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyContentMessageToMidsAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyContentMessageToMidsAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyContentMessageToMidsAsync"))
  }

  public func sendBuddyContentMessageToMidsAsync(requestId: String, msg: Message, content: Data, mids: TList<String>) throws -> String {
    try send_sendBuddyContentMessageToMidsAsync(requestId: requestId, msg: msg, content: content, mids: mids)
    try outProtocol.transport.flush()
    return try recv_sendBuddyContentMessageToMidsAsync()
  }

  private func send_sendBuddyMessageToAll(requestId: String, msg: Message) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyMessageToAll", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyMessageToAll_args(requestId: requestId, msg: msg)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyMessageToAll() throws -> SendBuddyMessageResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyMessageToAll_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyMessageToAll"))
  }

  public func sendBuddyMessageToAll(requestId: String, msg: Message) throws -> SendBuddyMessageResult {
    try send_sendBuddyMessageToAll(requestId: requestId, msg: msg)
    try outProtocol.transport.flush()
    return try recv_sendBuddyMessageToAll()
  }

  private func send_sendBuddyMessageToAllAsync(requestId: String, msg: Message) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyMessageToAllAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyMessageToAllAsync_args(requestId: requestId, msg: msg)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyMessageToAllAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyMessageToAllAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyMessageToAllAsync"))
  }

  public func sendBuddyMessageToAllAsync(requestId: String, msg: Message) throws -> String {
    try send_sendBuddyMessageToAllAsync(requestId: requestId, msg: msg)
    try outProtocol.transport.flush()
    return try recv_sendBuddyMessageToAllAsync()
  }

  private func send_sendBuddyMessageToMids(requestId: String, msg: Message, mids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyMessageToMids", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyMessageToMids_args(requestId: requestId, msg: msg, mids: mids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyMessageToMids() throws -> SendBuddyMessageResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyMessageToMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyMessageToMids"))
  }

  public func sendBuddyMessageToMids(requestId: String, msg: Message, mids: TList<String>) throws -> SendBuddyMessageResult {
    try send_sendBuddyMessageToMids(requestId: requestId, msg: msg, mids: mids)
    try outProtocol.transport.flush()
    return try recv_sendBuddyMessageToMids()
  }

  private func send_sendBuddyMessageToMidsAsync(requestId: String, msg: Message, mids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "sendBuddyMessageToMidsAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendBuddyMessageToMidsAsync_args(requestId: requestId, msg: msg, mids: mids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendBuddyMessageToMidsAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendBuddyMessageToMidsAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendBuddyMessageToMidsAsync"))
  }

  public func sendBuddyMessageToMidsAsync(requestId: String, msg: Message, mids: TList<String>) throws -> String {
    try send_sendBuddyMessageToMidsAsync(requestId: requestId, msg: msg, mids: mids)
    try outProtocol.transport.flush()
    return try recv_sendBuddyMessageToMidsAsync()
  }

  private func send_sendIndividualEventToAllAsync(requestId: String, buddyMid: String, notificationStatus: NotificationStatus) throws {
    try outProtocol.writeMessageBegin(name: "sendIndividualEventToAllAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_sendIndividualEventToAllAsync_args(requestId: requestId, buddyMid: buddyMid, notificationStatus: notificationStatus)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendIndividualEventToAllAsync() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_sendIndividualEventToAllAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendIndividualEventToAllAsync(requestId: String, buddyMid: String, notificationStatus: NotificationStatus) throws {
    try send_sendIndividualEventToAllAsync(requestId: requestId, buddyMid: buddyMid, notificationStatus: notificationStatus)
    try outProtocol.transport.flush()
    try recv_sendIndividualEventToAllAsync()
  }

  private func send_setBuddyOnAir(requestId: String, onAir: Bool) throws {
    try outProtocol.writeMessageBegin(name: "setBuddyOnAir", type: .call, sequenceID: 0)
    let args = BuddyManagementService_setBuddyOnAir_args(requestId: requestId, onAir: onAir)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_setBuddyOnAir() throws -> SetBuddyOnAirResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_setBuddyOnAir_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "setBuddyOnAir"))
  }

  public func setBuddyOnAir(requestId: String, onAir: Bool) throws -> SetBuddyOnAirResult {
    try send_setBuddyOnAir(requestId: requestId, onAir: onAir)
    try outProtocol.transport.flush()
    return try recv_setBuddyOnAir()
  }

  private func send_setBuddyOnAirAsync(requestId: String, onAir: Bool) throws {
    try outProtocol.writeMessageBegin(name: "setBuddyOnAirAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_setBuddyOnAirAsync_args(requestId: requestId, onAir: onAir)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_setBuddyOnAirAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_setBuddyOnAirAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "setBuddyOnAirAsync"))
  }

  public func setBuddyOnAirAsync(requestId: String, onAir: Bool) throws -> String {
    try send_setBuddyOnAirAsync(requestId: requestId, onAir: onAir)
    try outProtocol.transport.flush()
    return try recv_setBuddyOnAirAsync()
  }

  private func send_storeMessage(requestId: String, messageRequest: BuddyMessageRequest) throws {
    try outProtocol.writeMessageBegin(name: "storeMessage", type: .call, sequenceID: 0)
    let args = BuddyManagementService_storeMessage_args(requestId: requestId, messageRequest: messageRequest)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_storeMessage() throws -> SendBuddyMessageResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_storeMessage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "storeMessage"))
  }

  public func storeMessage(requestId: String, messageRequest: BuddyMessageRequest) throws -> SendBuddyMessageResult {
    try send_storeMessage(requestId: requestId, messageRequest: messageRequest)
    try outProtocol.transport.flush()
    return try recv_storeMessage()
  }

  private func send_unblockBuddyMember(requestId: String, mid: String) throws {
    try outProtocol.writeMessageBegin(name: "unblockBuddyMember", type: .call, sequenceID: 0)
    let args = BuddyManagementService_unblockBuddyMember_args(requestId: requestId, mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unblockBuddyMember() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_unblockBuddyMember_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func unblockBuddyMember(requestId: String, mid: String) throws {
    try send_unblockBuddyMember(requestId: requestId, mid: mid)
    try outProtocol.transport.flush()
    try recv_unblockBuddyMember()
  }

  private func send_unregisterBuddy(requestId: String) throws {
    try outProtocol.writeMessageBegin(name: "unregisterBuddy", type: .call, sequenceID: 0)
    let args = BuddyManagementService_unregisterBuddy_args(requestId: requestId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unregisterBuddy() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_unregisterBuddy_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func unregisterBuddy(requestId: String) throws {
    try send_unregisterBuddy(requestId: requestId)
    try outProtocol.transport.flush()
    try recv_unregisterBuddy()
  }

  private func send_unregisterBuddyAdmin(requestId: String) throws {
    try outProtocol.writeMessageBegin(name: "unregisterBuddyAdmin", type: .call, sequenceID: 0)
    let args = BuddyManagementService_unregisterBuddyAdmin_args(requestId: requestId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unregisterBuddyAdmin() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_unregisterBuddyAdmin_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func unregisterBuddyAdmin(requestId: String) throws {
    try send_unregisterBuddyAdmin(requestId: requestId)
    try outProtocol.transport.flush()
    try recv_unregisterBuddyAdmin()
  }

  private func send_updateBuddyAdminProfileAttribute(requestId: String, attributes: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddyAdminProfileAttribute", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddyAdminProfileAttribute_args(requestId: requestId, attributes: attributes)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddyAdminProfileAttribute() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddyAdminProfileAttribute_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateBuddyAdminProfileAttribute(requestId: String, attributes: TMap<String, String>) throws {
    try send_updateBuddyAdminProfileAttribute(requestId: requestId, attributes: attributes)
    try outProtocol.transport.flush()
    try recv_updateBuddyAdminProfileAttribute()
  }

  private func send_updateBuddyAdminProfileImage(requestId: String, picture: Data) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddyAdminProfileImage", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddyAdminProfileImage_args(requestId: requestId, picture: picture)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddyAdminProfileImage() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddyAdminProfileImage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateBuddyAdminProfileImage(requestId: String, picture: Data) throws {
    try send_updateBuddyAdminProfileImage(requestId: requestId, picture: picture)
    try outProtocol.transport.flush()
    try recv_updateBuddyAdminProfileImage()
  }

  private func send_updateBuddyProfileAttributes(requestId: String, attributes: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddyProfileAttributes", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddyProfileAttributes_args(requestId: requestId, attributes: attributes)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddyProfileAttributes() throws -> UpdateBuddyProfileResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddyProfileAttributes_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "updateBuddyProfileAttributes"))
  }

  public func updateBuddyProfileAttributes(requestId: String, attributes: TMap<String, String>) throws -> UpdateBuddyProfileResult {
    try send_updateBuddyProfileAttributes(requestId: requestId, attributes: attributes)
    try outProtocol.transport.flush()
    return try recv_updateBuddyProfileAttributes()
  }

  private func send_updateBuddyProfileAttributesAsync(requestId: String, attributes: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddyProfileAttributesAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddyProfileAttributesAsync_args(requestId: requestId, attributes: attributes)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddyProfileAttributesAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddyProfileAttributesAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "updateBuddyProfileAttributesAsync"))
  }

  public func updateBuddyProfileAttributesAsync(requestId: String, attributes: TMap<String, String>) throws -> String {
    try send_updateBuddyProfileAttributesAsync(requestId: requestId, attributes: attributes)
    try outProtocol.transport.flush()
    return try recv_updateBuddyProfileAttributesAsync()
  }

  private func send_updateBuddyProfileImage(requestId: String, image: Data) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddyProfileImage", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddyProfileImage_args(requestId: requestId, image: image)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddyProfileImage() throws -> UpdateBuddyProfileResult {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddyProfileImage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "updateBuddyProfileImage"))
  }

  public func updateBuddyProfileImage(requestId: String, image: Data) throws -> UpdateBuddyProfileResult {
    try send_updateBuddyProfileImage(requestId: requestId, image: image)
    try outProtocol.transport.flush()
    return try recv_updateBuddyProfileImage()
  }

  private func send_updateBuddyProfileImageAsync(requestId: String, image: Data) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddyProfileImageAsync", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddyProfileImageAsync_args(requestId: requestId, image: image)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddyProfileImageAsync() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddyProfileImageAsync_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "updateBuddyProfileImageAsync"))
  }

  public func updateBuddyProfileImageAsync(requestId: String, image: Data) throws -> String {
    try send_updateBuddyProfileImageAsync(requestId: requestId, image: image)
    try outProtocol.transport.flush()
    return try recv_updateBuddyProfileImageAsync()
  }

  private func send_updateBuddySearchId(requestId: String, searchId: String) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddySearchId", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddySearchId_args(requestId: requestId, searchId: searchId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddySearchId() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddySearchId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateBuddySearchId(requestId: String, searchId: String) throws {
    try send_updateBuddySearchId(requestId: requestId, searchId: searchId)
    try outProtocol.transport.flush()
    try recv_updateBuddySearchId()
  }

  private func send_updateBuddySettings(settings: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddySettings", type: .call, sequenceID: 0)
    let args = BuddyManagementService_updateBuddySettings_args(settings: settings)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddySettings() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_updateBuddySettings_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateBuddySettings(settings: TMap<String, String>) throws {
    try send_updateBuddySettings(settings: settings)
    try outProtocol.transport.flush()
    try recv_updateBuddySettings()
  }

  private func send_uploadBuddyContent(contentType: ContentType, content: Data) throws {
    try outProtocol.writeMessageBegin(name: "uploadBuddyContent", type: .call, sequenceID: 0)
    let args = BuddyManagementService_uploadBuddyContent_args(contentType: contentType, content: content)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_uploadBuddyContent() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyManagementService_uploadBuddyContent_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "uploadBuddyContent"))
  }

  public func uploadBuddyContent(contentType: ContentType, content: Data) throws -> String {
    try send_uploadBuddyContent(contentType: contentType, content: content)
    try outProtocol.transport.flush()
    return try recv_uploadBuddyContent()
  }

}

extension BuddyManagementServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["addBuddyMember"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_addBuddyMember_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_addBuddyMember_result()
      do {
        try handler.addBuddyMember(requestId: args.requestId, userMid: args.userMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "addBuddyMember", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["addBuddyMembers"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_addBuddyMembers_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_addBuddyMembers_result()
      do {
        try handler.addBuddyMembers(requestId: args.requestId, userMids: args.userMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "addBuddyMembers", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["blockBuddyMember"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_blockBuddyMember_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_blockBuddyMember_result()
      do {
        try handler.blockBuddyMember(requestId: args.requestId, mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "blockBuddyMember", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["commitSendMessagesToAll"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_commitSendMessagesToAll_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_commitSendMessagesToAll_result()
      do {
        result.success = try handler.commitSendMessagesToAll(requestIdList: args.requestIdList)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "commitSendMessagesToAll", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["commitSendMessagesToMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_commitSendMessagesToMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_commitSendMessagesToMids_result()
      do {
        result.success = try handler.commitSendMessagesToMids(requestIdList: args.requestIdList, mids: args.mids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "commitSendMessagesToMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["containsBuddyMember"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_containsBuddyMember_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_containsBuddyMember_result()
      do {
        result.success = try handler.containsBuddyMember(requestId: args.requestId, userMid: args.userMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "containsBuddyMember", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["downloadMessageContent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_downloadMessageContent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_downloadMessageContent_result()
      do {
        result.success = try handler.downloadMessageContent(requestId: args.requestId, messageId: args.messageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "downloadMessageContent", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["downloadMessageContentPreview"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_downloadMessageContentPreview_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_downloadMessageContentPreview_result()
      do {
        result.success = try handler.downloadMessageContentPreview(requestId: args.requestId, messageId: args.messageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "downloadMessageContentPreview", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["downloadProfileImage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_downloadProfileImage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_downloadProfileImage_result()
      do {
        result.success = try handler.downloadProfileImage(requestId: args.requestId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "downloadProfileImage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["downloadProfileImagePreview"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_downloadProfileImagePreview_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_downloadProfileImagePreview_result()
      do {
        result.success = try handler.downloadProfileImagePreview(requestId: args.requestId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "downloadProfileImagePreview", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getActiveMemberCountByBuddyMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getActiveMemberCountByBuddyMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getActiveMemberCountByBuddyMid_result()
      do {
        result.success = try handler.getActiveMemberCountByBuddyMid(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getActiveMemberCountByBuddyMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getActiveMemberMidsByBuddyMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getActiveMemberMidsByBuddyMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getActiveMemberMidsByBuddyMid_result()
      do {
        result.success = try handler.getActiveMemberMidsByBuddyMid(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getActiveMemberMidsByBuddyMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getAllBuddyMembers"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getAllBuddyMembers_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getAllBuddyMembers_result()
      do {
        result.success = try handler.getAllBuddyMembers()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getAllBuddyMembers", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBlockedBuddyMembers"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getBlockedBuddyMembers_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getBlockedBuddyMembers_result()
      do {
        result.success = try handler.getBlockedBuddyMembers()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBlockedBuddyMembers", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBlockerCountByBuddyMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getBlockerCountByBuddyMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getBlockerCountByBuddyMid_result()
      do {
        result.success = try handler.getBlockerCountByBuddyMid(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBlockerCountByBuddyMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBuddyDetailByMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getBuddyDetailByMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getBuddyDetailByMid_result()
      do {
        result.success = try handler.getBuddyDetailByMid(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBuddyDetailByMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBuddyProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getBuddyProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getBuddyProfile_result()
      do {
        result.success = try handler.getBuddyProfile()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBuddyProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getContactTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getContactTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getContactTicket_result()
      do {
        result.success = try handler.getContactTicket()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getContactTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMemberCountByBuddyMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getMemberCountByBuddyMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getMemberCountByBuddyMid_result()
      do {
        result.success = try handler.getMemberCountByBuddyMid(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMemberCountByBuddyMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSendBuddyMessageResult"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getSendBuddyMessageResult_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getSendBuddyMessageResult_result()
      do {
        result.success = try handler.getSendBuddyMessageResult(sendBuddyMessageRequestId: args.sendBuddyMessageRequestId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSendBuddyMessageResult", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSetBuddyOnAirResult"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getSetBuddyOnAirResult_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getSetBuddyOnAirResult_result()
      do {
        result.success = try handler.getSetBuddyOnAirResult(setBuddyOnAirRequestId: args.setBuddyOnAirRequestId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSetBuddyOnAirResult", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getUpdateBuddyProfileResult"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_getUpdateBuddyProfileResult_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_getUpdateBuddyProfileResult_result()
      do {
        result.success = try handler.getUpdateBuddyProfileResult(updateBuddyProfileRequestId: args.updateBuddyProfileRequestId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUpdateBuddyProfileResult", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["isBuddyOnAirByMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_isBuddyOnAirByMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_isBuddyOnAirByMid_result()
      do {
        result.success = try handler.isBuddyOnAirByMid(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isBuddyOnAirByMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["linkAndSendBuddyContentMessageToAllAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_linkAndSendBuddyContentMessageToAllAsync_result()
      do {
        result.success = try handler.linkAndSendBuddyContentMessageToAllAsync(requestId: args.requestId, msg: args.msg, sourceContentId: args.sourceContentId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "linkAndSendBuddyContentMessageToAllAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["linkAndSendBuddyContentMessageToMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_linkAndSendBuddyContentMessageToMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_linkAndSendBuddyContentMessageToMids_result()
      do {
        result.success = try handler.linkAndSendBuddyContentMessageToMids(requestId: args.requestId, msg: args.msg, sourceContentId: args.sourceContentId, mids: args.mids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "linkAndSendBuddyContentMessageToMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyBuddyBlocked"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_notifyBuddyBlocked_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_notifyBuddyBlocked_result()
      do {
        try handler.notifyBuddyBlocked(buddyMid: args.buddyMid, blockerMid: args.blockerMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyBuddyBlocked", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyBuddyUnblocked"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_notifyBuddyUnblocked_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_notifyBuddyUnblocked_result()
      do {
        try handler.notifyBuddyUnblocked(buddyMid: args.buddyMid, blockerMid: args.blockerMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyBuddyUnblocked", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerBuddy"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_registerBuddy_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_registerBuddy_result()
      do {
        result.success = try handler.registerBuddy(buddyId: args.buddyId, searchId: args.searchId, displayName: args.displayName, statusMeessage: args.statusMeessage, picture: args.picture, settings: args.settings)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerBuddy", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerBuddyAdmin"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_registerBuddyAdmin_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_registerBuddyAdmin_result()
      do {
        result.success = try handler.registerBuddyAdmin(buddyId: args.buddyId, searchId: args.searchId, displayName: args.displayName, statusMessage: args.statusMessage, picture: args.picture)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerBuddyAdmin", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reissueContactTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_reissueContactTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_reissueContactTicket_result()
      do {
        result.success = try handler.reissueContactTicket(expirationTime: args.expirationTime, maxUseCount: args.maxUseCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reissueContactTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeBuddyMember"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_removeBuddyMember_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_removeBuddyMember_result()
      do {
        try handler.removeBuddyMember(requestId: args.requestId, userMid: args.userMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeBuddyMember", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeBuddyMembers"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_removeBuddyMembers_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_removeBuddyMembers_result()
      do {
        try handler.removeBuddyMembers(requestId: args.requestId, userMids: args.userMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeBuddyMembers", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyContentMessageToAll"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyContentMessageToAll_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyContentMessageToAll_result()
      do {
        result.success = try handler.sendBuddyContentMessageToAll(requestId: args.requestId, msg: args.msg, content: args.content)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToAll", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyContentMessageToAllAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyContentMessageToAllAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyContentMessageToAllAsync_result()
      do {
        result.success = try handler.sendBuddyContentMessageToAllAsync(requestId: args.requestId, msg: args.msg, content: args.content)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToAllAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyContentMessageToMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyContentMessageToMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyContentMessageToMids_result()
      do {
        result.success = try handler.sendBuddyContentMessageToMids(requestId: args.requestId, msg: args.msg, content: args.content, mids: args.mids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyContentMessageToMidsAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyContentMessageToMidsAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyContentMessageToMidsAsync_result()
      do {
        result.success = try handler.sendBuddyContentMessageToMidsAsync(requestId: args.requestId, msg: args.msg, content: args.content, mids: args.mids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyContentMessageToMidsAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyMessageToAll"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyMessageToAll_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyMessageToAll_result()
      do {
        result.success = try handler.sendBuddyMessageToAll(requestId: args.requestId, msg: args.msg)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyMessageToAll", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyMessageToAllAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyMessageToAllAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyMessageToAllAsync_result()
      do {
        result.success = try handler.sendBuddyMessageToAllAsync(requestId: args.requestId, msg: args.msg)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyMessageToAllAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyMessageToMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyMessageToMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyMessageToMids_result()
      do {
        result.success = try handler.sendBuddyMessageToMids(requestId: args.requestId, msg: args.msg, mids: args.mids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyMessageToMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendBuddyMessageToMidsAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendBuddyMessageToMidsAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendBuddyMessageToMidsAsync_result()
      do {
        result.success = try handler.sendBuddyMessageToMidsAsync(requestId: args.requestId, msg: args.msg, mids: args.mids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendBuddyMessageToMidsAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendIndividualEventToAllAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_sendIndividualEventToAllAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_sendIndividualEventToAllAsync_result()
      do {
        try handler.sendIndividualEventToAllAsync(requestId: args.requestId, buddyMid: args.buddyMid, notificationStatus: args.notificationStatus)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendIndividualEventToAllAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["setBuddyOnAir"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_setBuddyOnAir_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_setBuddyOnAir_result()
      do {
        result.success = try handler.setBuddyOnAir(requestId: args.requestId, onAir: args.onAir)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "setBuddyOnAir", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["setBuddyOnAirAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_setBuddyOnAirAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_setBuddyOnAirAsync_result()
      do {
        result.success = try handler.setBuddyOnAirAsync(requestId: args.requestId, onAir: args.onAir)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "setBuddyOnAirAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["storeMessage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_storeMessage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_storeMessage_result()
      do {
        result.success = try handler.storeMessage(requestId: args.requestId, messageRequest: args.messageRequest)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "storeMessage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unblockBuddyMember"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_unblockBuddyMember_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_unblockBuddyMember_result()
      do {
        try handler.unblockBuddyMember(requestId: args.requestId, mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unblockBuddyMember", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unregisterBuddy"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_unregisterBuddy_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_unregisterBuddy_result()
      do {
        try handler.unregisterBuddy(requestId: args.requestId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unregisterBuddy", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unregisterBuddyAdmin"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_unregisterBuddyAdmin_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_unregisterBuddyAdmin_result()
      do {
        try handler.unregisterBuddyAdmin(requestId: args.requestId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unregisterBuddyAdmin", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddyAdminProfileAttribute"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddyAdminProfileAttribute_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddyAdminProfileAttribute_result()
      do {
        try handler.updateBuddyAdminProfileAttribute(requestId: args.requestId, attributes: args.attributes)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddyAdminProfileAttribute", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddyAdminProfileImage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddyAdminProfileImage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddyAdminProfileImage_result()
      do {
        try handler.updateBuddyAdminProfileImage(requestId: args.requestId, picture: args.picture)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddyAdminProfileImage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddyProfileAttributes"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddyProfileAttributes_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddyProfileAttributes_result()
      do {
        result.success = try handler.updateBuddyProfileAttributes(requestId: args.requestId, attributes: args.attributes)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddyProfileAttributes", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddyProfileAttributesAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddyProfileAttributesAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddyProfileAttributesAsync_result()
      do {
        result.success = try handler.updateBuddyProfileAttributesAsync(requestId: args.requestId, attributes: args.attributes)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddyProfileAttributesAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddyProfileImage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddyProfileImage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddyProfileImage_result()
      do {
        result.success = try handler.updateBuddyProfileImage(requestId: args.requestId, image: args.image)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddyProfileImage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddyProfileImageAsync"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddyProfileImageAsync_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddyProfileImageAsync_result()
      do {
        result.success = try handler.updateBuddyProfileImageAsync(requestId: args.requestId, image: args.image)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddyProfileImageAsync", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddySearchId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddySearchId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddySearchId_result()
      do {
        try handler.updateBuddySearchId(requestId: args.requestId, searchId: args.searchId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddySearchId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddySettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_updateBuddySettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_updateBuddySettings_result()
      do {
        try handler.updateBuddySettings(settings: args.settings)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddySettings", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["uploadBuddyContent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyManagementService_uploadBuddyContent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyManagementService_uploadBuddyContent_result()
      do {
        result.success = try handler.uploadBuddyContent(contentType: args.contentType, content: args.content)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "uploadBuddyContent", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = BuddyManagementServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class BuddyService_findBuddyContactsByQuery_args {

  fileprivate var language: String

  fileprivate var country: String

  fileprivate var query: String

  fileprivate var fromIndex: Int32

  fileprivate var count: Int32

  fileprivate var requestSource: BuddySearchRequestSource


  fileprivate init(language: String, country: String, query: String, fromIndex: Int32, count: Int32, requestSource: BuddySearchRequestSource) {
    self.language = language
    self.country = country
    self.query = query
    self.fromIndex = fromIndex
    self.count = count
    self.requestSource = requestSource
  }

}

fileprivate func ==(lhs: BuddyService_findBuddyContactsByQuery_args, rhs: BuddyService_findBuddyContactsByQuery_args) -> Bool {
  return
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country) &&
    (lhs.query == rhs.query) &&
    (lhs.fromIndex == rhs.fromIndex) &&
    (lhs.count == rhs.count) &&
    (lhs.requestSource == rhs.requestSource)
}

extension BuddyService_findBuddyContactsByQuery_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (query.hashValue)
    result = prime &* result &+ (fromIndex.hashValue)
    result = prime &* result &+ (count.hashValue)
    result = prime &* result &+ (requestSource.hashValue)
    return result
  }

}

extension BuddyService_findBuddyContactsByQuery_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["language": 2, "country": 3, "query": 4, "fromIndex": 5, "count": 6, "requestSource": 7, ]
  }

  fileprivate static var structName: String { return "BuddyService_findBuddyContactsByQuery_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_findBuddyContactsByQuery_args {
    _ = try proto.readStructBegin()
    var language: String!
    var country: String!
    var query: String!
    var fromIndex: Int32!
    var count: Int32!
    var requestSource: BuddySearchRequestSource!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           language = try String.read(from: proto)
        case (3, .string):           country = try String.read(from: proto)
        case (4, .string):           query = try String.read(from: proto)
        case (5, .i32):             fromIndex = try Int32.read(from: proto)
        case (6, .i32):             count = try Int32.read(from: proto)
        case (7, .i32):             requestSource = try BuddySearchRequestSource.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(query, named: "query")
    try proto.validateValue(fromIndex, named: "fromIndex")
    try proto.validateValue(count, named: "count")
    try proto.validateValue(requestSource, named: "requestSource")

    return BuddyService_findBuddyContactsByQuery_args(language: language, country: country, query: query, fromIndex: fromIndex, count: count, requestSource: requestSource)
  }

}



fileprivate final class BuddyService_findBuddyContactsByQuery_result {

  fileprivate var success: TList<BuddySearchResult>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<BuddySearchResult>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_findBuddyContactsByQuery_result, rhs: BuddyService_findBuddyContactsByQuery_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_findBuddyContactsByQuery_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_findBuddyContactsByQuery_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_findBuddyContactsByQuery_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_findBuddyContactsByQuery_result {
    _ = try proto.readStructBegin()
    var success: TList<BuddySearchResult>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<BuddySearchResult>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_findBuddyContactsByQuery_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getBuddyContacts_args {

  fileprivate var language: String

  fileprivate var country: String

  fileprivate var classification: String

  fileprivate var fromIndex: Int32

  fileprivate var count: Int32


  fileprivate init(language: String, country: String, classification: String, fromIndex: Int32, count: Int32) {
    self.language = language
    self.country = country
    self.classification = classification
    self.fromIndex = fromIndex
    self.count = count
  }

}

fileprivate func ==(lhs: BuddyService_getBuddyContacts_args, rhs: BuddyService_getBuddyContacts_args) -> Bool {
  return
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country) &&
    (lhs.classification == rhs.classification) &&
    (lhs.fromIndex == rhs.fromIndex) &&
    (lhs.count == rhs.count)
}

extension BuddyService_getBuddyContacts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (classification.hashValue)
    result = prime &* result &+ (fromIndex.hashValue)
    result = prime &* result &+ (count.hashValue)
    return result
  }

}

extension BuddyService_getBuddyContacts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["language": 2, "country": 3, "classification": 4, "fromIndex": 5, "count": 6, ]
  }

  fileprivate static var structName: String { return "BuddyService_getBuddyContacts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getBuddyContacts_args {
    _ = try proto.readStructBegin()
    var language: String!
    var country: String!
    var classification: String!
    var fromIndex: Int32!
    var count: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           language = try String.read(from: proto)
        case (3, .string):           country = try String.read(from: proto)
        case (4, .string):           classification = try String.read(from: proto)
        case (5, .i32):             fromIndex = try Int32.read(from: proto)
        case (6, .i32):             count = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(classification, named: "classification")
    try proto.validateValue(fromIndex, named: "fromIndex")
    try proto.validateValue(count, named: "count")

    return BuddyService_getBuddyContacts_args(language: language, country: country, classification: classification, fromIndex: fromIndex, count: count)
  }

}



fileprivate final class BuddyService_getBuddyContacts_result {

  fileprivate var success: TList<Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getBuddyContacts_result, rhs: BuddyService_getBuddyContacts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getBuddyContacts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getBuddyContacts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getBuddyContacts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getBuddyContacts_result {
    _ = try proto.readStructBegin()
    var success: TList<Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getBuddyContacts_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getBuddyDetail_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyService_getBuddyDetail_args, rhs: BuddyService_getBuddyDetail_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyService_getBuddyDetail_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyService_getBuddyDetail_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 4, ]
  }

  fileprivate static var structName: String { return "BuddyService_getBuddyDetail_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getBuddyDetail_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (4, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyService_getBuddyDetail_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyService_getBuddyDetail_result {

  fileprivate var success: BuddyDetail?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: BuddyDetail?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getBuddyDetail_result, rhs: BuddyService_getBuddyDetail_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getBuddyDetail_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getBuddyDetail_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getBuddyDetail_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getBuddyDetail_result {
    _ = try proto.readStructBegin()
    var success: BuddyDetail?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try BuddyDetail.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getBuddyDetail_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getBuddyOnAir_args {

  fileprivate var buddyMid: String


  fileprivate init(buddyMid: String) {
    self.buddyMid = buddyMid
  }

}

fileprivate func ==(lhs: BuddyService_getBuddyOnAir_args, rhs: BuddyService_getBuddyOnAir_args) -> Bool {
  return
    (lhs.buddyMid == rhs.buddyMid)
}

extension BuddyService_getBuddyOnAir_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyMid.hashValue)
    return result
  }

}

extension BuddyService_getBuddyOnAir_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyMid": 4, ]
  }

  fileprivate static var structName: String { return "BuddyService_getBuddyOnAir_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getBuddyOnAir_args {
    _ = try proto.readStructBegin()
    var buddyMid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (4, .string):           buddyMid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyMid, named: "buddyMid")

    return BuddyService_getBuddyOnAir_args(buddyMid: buddyMid)
  }

}



fileprivate final class BuddyService_getBuddyOnAir_result {

  fileprivate var success: BuddyOnAir?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: BuddyOnAir?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getBuddyOnAir_result, rhs: BuddyService_getBuddyOnAir_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getBuddyOnAir_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getBuddyOnAir_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getBuddyOnAir_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getBuddyOnAir_result {
    _ = try proto.readStructBegin()
    var success: BuddyOnAir?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try BuddyOnAir.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getBuddyOnAir_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getCountriesHavingBuddy_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: BuddyService_getCountriesHavingBuddy_args, rhs: BuddyService_getCountriesHavingBuddy_args) -> Bool {
  return true
}

extension BuddyService_getCountriesHavingBuddy_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension BuddyService_getCountriesHavingBuddy_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "BuddyService_getCountriesHavingBuddy_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getCountriesHavingBuddy_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getCountriesHavingBuddy_args()
  }

}



fileprivate final class BuddyService_getCountriesHavingBuddy_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getCountriesHavingBuddy_result, rhs: BuddyService_getCountriesHavingBuddy_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getCountriesHavingBuddy_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getCountriesHavingBuddy_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getCountriesHavingBuddy_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getCountriesHavingBuddy_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getCountriesHavingBuddy_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getNewlyReleasedBuddyIds_args {

  fileprivate var country: String


  fileprivate init(country: String) {
    self.country = country
  }

}

fileprivate func ==(lhs: BuddyService_getNewlyReleasedBuddyIds_args, rhs: BuddyService_getNewlyReleasedBuddyIds_args) -> Bool {
  return
    (lhs.country == rhs.country)
}

extension BuddyService_getNewlyReleasedBuddyIds_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension BuddyService_getNewlyReleasedBuddyIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["country": 3, ]
  }

  fileprivate static var structName: String { return "BuddyService_getNewlyReleasedBuddyIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getNewlyReleasedBuddyIds_args {
    _ = try proto.readStructBegin()
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(country, named: "country")

    return BuddyService_getNewlyReleasedBuddyIds_args(country: country)
  }

}



fileprivate final class BuddyService_getNewlyReleasedBuddyIds_result {

  fileprivate var success: TMap<String, Int64>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, Int64>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getNewlyReleasedBuddyIds_result, rhs: BuddyService_getNewlyReleasedBuddyIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getNewlyReleasedBuddyIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getNewlyReleasedBuddyIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getNewlyReleasedBuddyIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getNewlyReleasedBuddyIds_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, Int64>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, Int64>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getNewlyReleasedBuddyIds_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getPopularBuddyBanner_args {

  fileprivate var language: String

  fileprivate var country: String

  fileprivate var applicationType: ApplicationType

  fileprivate var resourceSpecification: String


  fileprivate init(language: String, country: String, applicationType: ApplicationType, resourceSpecification: String) {
    self.language = language
    self.country = country
    self.applicationType = applicationType
    self.resourceSpecification = resourceSpecification
  }

}

fileprivate func ==(lhs: BuddyService_getPopularBuddyBanner_args, rhs: BuddyService_getPopularBuddyBanner_args) -> Bool {
  return
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country) &&
    (lhs.applicationType == rhs.applicationType) &&
    (lhs.resourceSpecification == rhs.resourceSpecification)
}

extension BuddyService_getPopularBuddyBanner_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (applicationType.hashValue)
    result = prime &* result &+ (resourceSpecification.hashValue)
    return result
  }

}

extension BuddyService_getPopularBuddyBanner_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["language": 2, "country": 3, "applicationType": 4, "resourceSpecification": 5, ]
  }

  fileprivate static var structName: String { return "BuddyService_getPopularBuddyBanner_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getPopularBuddyBanner_args {
    _ = try proto.readStructBegin()
    var language: String!
    var country: String!
    var applicationType: ApplicationType!
    var resourceSpecification: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           language = try String.read(from: proto)
        case (3, .string):           country = try String.read(from: proto)
        case (4, .i32):             applicationType = try ApplicationType.read(from: proto)
        case (5, .string):           resourceSpecification = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(applicationType, named: "applicationType")
    try proto.validateValue(resourceSpecification, named: "resourceSpecification")

    return BuddyService_getPopularBuddyBanner_args(language: language, country: country, applicationType: applicationType, resourceSpecification: resourceSpecification)
  }

}



fileprivate final class BuddyService_getPopularBuddyBanner_result {

  fileprivate var success: BuddyBanner?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: BuddyBanner?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getPopularBuddyBanner_result, rhs: BuddyService_getPopularBuddyBanner_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getPopularBuddyBanner_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getPopularBuddyBanner_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getPopularBuddyBanner_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getPopularBuddyBanner_result {
    _ = try proto.readStructBegin()
    var success: BuddyBanner?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try BuddyBanner.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getPopularBuddyBanner_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getPopularBuddyLists_args {

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(language: String, country: String) {
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: BuddyService_getPopularBuddyLists_args, rhs: BuddyService_getPopularBuddyLists_args) -> Bool {
  return
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension BuddyService_getPopularBuddyLists_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension BuddyService_getPopularBuddyLists_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["language": 2, "country": 3, ]
  }

  fileprivate static var structName: String { return "BuddyService_getPopularBuddyLists_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getPopularBuddyLists_args {
    _ = try proto.readStructBegin()
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           language = try String.read(from: proto)
        case (3, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return BuddyService_getPopularBuddyLists_args(language: language, country: country)
  }

}



fileprivate final class BuddyService_getPopularBuddyLists_result {

  fileprivate var success: TList<BuddyList>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<BuddyList>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getPopularBuddyLists_result, rhs: BuddyService_getPopularBuddyLists_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getPopularBuddyLists_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getPopularBuddyLists_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getPopularBuddyLists_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getPopularBuddyLists_result {
    _ = try proto.readStructBegin()
    var success: TList<BuddyList>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<BuddyList>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getPopularBuddyLists_result(success: success, e: e)
  }

}



fileprivate final class BuddyService_getPromotedBuddyContacts_args {

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(language: String, country: String) {
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: BuddyService_getPromotedBuddyContacts_args, rhs: BuddyService_getPromotedBuddyContacts_args) -> Bool {
  return
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension BuddyService_getPromotedBuddyContacts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension BuddyService_getPromotedBuddyContacts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["language": 2, "country": 3, ]
  }

  fileprivate static var structName: String { return "BuddyService_getPromotedBuddyContacts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getPromotedBuddyContacts_args {
    _ = try proto.readStructBegin()
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           language = try String.read(from: proto)
        case (3, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return BuddyService_getPromotedBuddyContacts_args(language: language, country: country)
  }

}



fileprivate final class BuddyService_getPromotedBuddyContacts_result {

  fileprivate var success: TList<Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: BuddyService_getPromotedBuddyContacts_result, rhs: BuddyService_getPromotedBuddyContacts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension BuddyService_getPromotedBuddyContacts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension BuddyService_getPromotedBuddyContacts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "BuddyService_getPromotedBuddyContacts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> BuddyService_getPromotedBuddyContacts_result {
    _ = try proto.readStructBegin()
    var success: TList<Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return BuddyService_getPromotedBuddyContacts_result(success: success, e: e)
  }

}



extension BuddyServiceClient : BuddyService {

  private func send_findBuddyContactsByQuery(language: String, country: String, query: String, fromIndex: Int32, count: Int32, requestSource: BuddySearchRequestSource) throws {
    try outProtocol.writeMessageBegin(name: "findBuddyContactsByQuery", type: .call, sequenceID: 0)
    let args = BuddyService_findBuddyContactsByQuery_args(language: language, country: country, query: query, fromIndex: fromIndex, count: count, requestSource: requestSource)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findBuddyContactsByQuery() throws -> TList<BuddySearchResult> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_findBuddyContactsByQuery_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findBuddyContactsByQuery"))
  }

  public func findBuddyContactsByQuery(language: String, country: String, query: String, fromIndex: Int32, count: Int32, requestSource: BuddySearchRequestSource) throws -> TList<BuddySearchResult> {
    try send_findBuddyContactsByQuery(language: language, country: country, query: query, fromIndex: fromIndex, count: count, requestSource: requestSource)
    try outProtocol.transport.flush()
    return try recv_findBuddyContactsByQuery()
  }

  private func send_getBuddyContacts(language: String, country: String, classification: String, fromIndex: Int32, count: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getBuddyContacts", type: .call, sequenceID: 0)
    let args = BuddyService_getBuddyContacts_args(language: language, country: country, classification: classification, fromIndex: fromIndex, count: count)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBuddyContacts() throws -> TList<Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getBuddyContacts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBuddyContacts"))
  }

  public func getBuddyContacts(language: String, country: String, classification: String, fromIndex: Int32, count: Int32) throws -> TList<Contact> {
    try send_getBuddyContacts(language: language, country: country, classification: classification, fromIndex: fromIndex, count: count)
    try outProtocol.transport.flush()
    return try recv_getBuddyContacts()
  }

  private func send_getBuddyDetail(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "getBuddyDetail", type: .call, sequenceID: 0)
    let args = BuddyService_getBuddyDetail_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBuddyDetail() throws -> BuddyDetail {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getBuddyDetail_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBuddyDetail"))
  }

  public func getBuddyDetail(buddyMid: String) throws -> BuddyDetail {
    try send_getBuddyDetail(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_getBuddyDetail()
  }

  private func send_getBuddyOnAir(buddyMid: String) throws {
    try outProtocol.writeMessageBegin(name: "getBuddyOnAir", type: .call, sequenceID: 0)
    let args = BuddyService_getBuddyOnAir_args(buddyMid: buddyMid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBuddyOnAir() throws -> BuddyOnAir {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getBuddyOnAir_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBuddyOnAir"))
  }

  public func getBuddyOnAir(buddyMid: String) throws -> BuddyOnAir {
    try send_getBuddyOnAir(buddyMid: buddyMid)
    try outProtocol.transport.flush()
    return try recv_getBuddyOnAir()
  }

  private func send_getCountriesHavingBuddy() throws {
    try outProtocol.writeMessageBegin(name: "getCountriesHavingBuddy", type: .call, sequenceID: 0)
    let args = BuddyService_getCountriesHavingBuddy_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCountriesHavingBuddy() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getCountriesHavingBuddy_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCountriesHavingBuddy"))
  }

  public func getCountriesHavingBuddy() throws -> TList<String> {
    try send_getCountriesHavingBuddy()
    try outProtocol.transport.flush()
    return try recv_getCountriesHavingBuddy()
  }

  private func send_getNewlyReleasedBuddyIds(country: String) throws {
    try outProtocol.writeMessageBegin(name: "getNewlyReleasedBuddyIds", type: .call, sequenceID: 0)
    let args = BuddyService_getNewlyReleasedBuddyIds_args(country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getNewlyReleasedBuddyIds() throws -> TMap<String, Int64> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getNewlyReleasedBuddyIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getNewlyReleasedBuddyIds"))
  }

  public func getNewlyReleasedBuddyIds(country: String) throws -> TMap<String, Int64> {
    try send_getNewlyReleasedBuddyIds(country: country)
    try outProtocol.transport.flush()
    return try recv_getNewlyReleasedBuddyIds()
  }

  private func send_getPopularBuddyBanner(language: String, country: String, applicationType: ApplicationType, resourceSpecification: String) throws {
    try outProtocol.writeMessageBegin(name: "getPopularBuddyBanner", type: .call, sequenceID: 0)
    let args = BuddyService_getPopularBuddyBanner_args(language: language, country: country, applicationType: applicationType, resourceSpecification: resourceSpecification)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPopularBuddyBanner() throws -> BuddyBanner {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getPopularBuddyBanner_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPopularBuddyBanner"))
  }

  public func getPopularBuddyBanner(language: String, country: String, applicationType: ApplicationType, resourceSpecification: String) throws -> BuddyBanner {
    try send_getPopularBuddyBanner(language: language, country: country, applicationType: applicationType, resourceSpecification: resourceSpecification)
    try outProtocol.transport.flush()
    return try recv_getPopularBuddyBanner()
  }

  private func send_getPopularBuddyLists(language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getPopularBuddyLists", type: .call, sequenceID: 0)
    let args = BuddyService_getPopularBuddyLists_args(language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPopularBuddyLists() throws -> TList<BuddyList> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getPopularBuddyLists_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPopularBuddyLists"))
  }

  public func getPopularBuddyLists(language: String, country: String) throws -> TList<BuddyList> {
    try send_getPopularBuddyLists(language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getPopularBuddyLists()
  }

  private func send_getPromotedBuddyContacts(language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getPromotedBuddyContacts", type: .call, sequenceID: 0)
    let args = BuddyService_getPromotedBuddyContacts_args(language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPromotedBuddyContacts() throws -> TList<Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try BuddyService_getPromotedBuddyContacts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPromotedBuddyContacts"))
  }

  public func getPromotedBuddyContacts(language: String, country: String) throws -> TList<Contact> {
    try send_getPromotedBuddyContacts(language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getPromotedBuddyContacts()
  }

}

extension BuddyServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["findBuddyContactsByQuery"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_findBuddyContactsByQuery_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_findBuddyContactsByQuery_result()
      do {
        result.success = try handler.findBuddyContactsByQuery(language: args.language, country: args.country, query: args.query, fromIndex: args.fromIndex, count: args.count, requestSource: args.requestSource)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findBuddyContactsByQuery", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBuddyContacts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getBuddyContacts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getBuddyContacts_result()
      do {
        result.success = try handler.getBuddyContacts(language: args.language, country: args.country, classification: args.classification, fromIndex: args.fromIndex, count: args.count)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBuddyContacts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBuddyDetail"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getBuddyDetail_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getBuddyDetail_result()
      do {
        result.success = try handler.getBuddyDetail(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBuddyDetail", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBuddyOnAir"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getBuddyOnAir_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getBuddyOnAir_result()
      do {
        result.success = try handler.getBuddyOnAir(buddyMid: args.buddyMid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBuddyOnAir", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCountriesHavingBuddy"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getCountriesHavingBuddy_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getCountriesHavingBuddy_result()
      do {
        result.success = try handler.getCountriesHavingBuddy()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCountriesHavingBuddy", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getNewlyReleasedBuddyIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getNewlyReleasedBuddyIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getNewlyReleasedBuddyIds_result()
      do {
        result.success = try handler.getNewlyReleasedBuddyIds(country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getNewlyReleasedBuddyIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPopularBuddyBanner"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getPopularBuddyBanner_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getPopularBuddyBanner_result()
      do {
        result.success = try handler.getPopularBuddyBanner(language: args.language, country: args.country, applicationType: args.applicationType, resourceSpecification: args.resourceSpecification)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPopularBuddyBanner", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPopularBuddyLists"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getPopularBuddyLists_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getPopularBuddyLists_result()
      do {
        result.success = try handler.getPopularBuddyLists(language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPopularBuddyLists", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPromotedBuddyContacts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try BuddyService_getPromotedBuddyContacts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = BuddyService_getPromotedBuddyContacts_result()
      do {
        result.success = try handler.getPromotedBuddyContacts(language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPromotedBuddyContacts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = BuddyServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class ChannelApplicationProvidedService_activeBuddySubscriberCount_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_activeBuddySubscriberCount_args, rhs: ChannelApplicationProvidedService_activeBuddySubscriberCount_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_activeBuddySubscriberCount_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_activeBuddySubscriberCount_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_activeBuddySubscriberCount_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_activeBuddySubscriberCount_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_activeBuddySubscriberCount_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_activeBuddySubscriberCount_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_activeBuddySubscriberCount_result, rhs: ChannelApplicationProvidedService_activeBuddySubscriberCount_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_activeBuddySubscriberCount_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_activeBuddySubscriberCount_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_activeBuddySubscriberCount_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_activeBuddySubscriberCount_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_activeBuddySubscriberCount_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_addOperationForChannel_args {

  fileprivate var opType: OpType

  fileprivate var param1: String

  fileprivate var param2: String

  fileprivate var param3: String


  fileprivate init(opType: OpType, param1: String, param2: String, param3: String) {
    self.opType = opType
    self.param1 = param1
    self.param2 = param2
    self.param3 = param3
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_addOperationForChannel_args, rhs: ChannelApplicationProvidedService_addOperationForChannel_args) -> Bool {
  return
    (lhs.opType == rhs.opType) &&
    (lhs.param1 == rhs.param1) &&
    (lhs.param2 == rhs.param2) &&
    (lhs.param3 == rhs.param3)
}

extension ChannelApplicationProvidedService_addOperationForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (opType.hashValue)
    result = prime &* result &+ (param1.hashValue)
    result = prime &* result &+ (param2.hashValue)
    result = prime &* result &+ (param3.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_addOperationForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["opType": 1, "param1": 2, "param2": 3, "param3": 4, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_addOperationForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_addOperationForChannel_args {
    _ = try proto.readStructBegin()
    var opType: OpType!
    var param1: String!
    var param2: String!
    var param3: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             opType = try OpType.read(from: proto)
        case (2, .string):           param1 = try String.read(from: proto)
        case (3, .string):           param2 = try String.read(from: proto)
        case (4, .string):           param3 = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(opType, named: "opType")
    try proto.validateValue(param1, named: "param1")
    try proto.validateValue(param2, named: "param2")
    try proto.validateValue(param3, named: "param3")

    return ChannelApplicationProvidedService_addOperationForChannel_args(opType: opType, param1: param1, param2: param2, param3: param3)
  }

}



fileprivate final class ChannelApplicationProvidedService_addOperationForChannel_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_addOperationForChannel_result, rhs: ChannelApplicationProvidedService_addOperationForChannel_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_addOperationForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_addOperationForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_addOperationForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_addOperationForChannel_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_addOperationForChannel_result(e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_displayBuddySubscriberCount_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_displayBuddySubscriberCount_args, rhs: ChannelApplicationProvidedService_displayBuddySubscriberCount_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_displayBuddySubscriberCount_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_displayBuddySubscriberCount_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_displayBuddySubscriberCount_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_displayBuddySubscriberCount_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_displayBuddySubscriberCount_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_displayBuddySubscriberCount_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_displayBuddySubscriberCount_result, rhs: ChannelApplicationProvidedService_displayBuddySubscriberCount_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_displayBuddySubscriberCount_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_displayBuddySubscriberCount_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_displayBuddySubscriberCount_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_displayBuddySubscriberCount_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_displayBuddySubscriberCount_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args {

  fileprivate var userid: String


  fileprivate init(userid: String) {
    self.userid = userid
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args, rhs: ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args) -> Bool {
  return
    (lhs.userid == rhs.userid)
}

extension ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (userid.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["userid": 2, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args {
    _ = try proto.readStructBegin()
    var userid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           userid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(userid, named: "userid")

    return ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args(userid: userid)
  }

}



fileprivate final class ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result {

  fileprivate var success: Contact?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Contact?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result, rhs: ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result {
    _ = try proto.readStructBegin()
    var success: Contact?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Contact.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getAllContactIdsForChannel_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getAllContactIdsForChannel_args, rhs: ChannelApplicationProvidedService_getAllContactIdsForChannel_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getAllContactIdsForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getAllContactIdsForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getAllContactIdsForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getAllContactIdsForChannel_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getAllContactIdsForChannel_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getAllContactIdsForChannel_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getAllContactIdsForChannel_result, rhs: ChannelApplicationProvidedService_getAllContactIdsForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getAllContactIdsForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getAllContactIdsForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getAllContactIdsForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getAllContactIdsForChannel_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getAllContactIdsForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getCompactContacts_args {

  fileprivate var lastModifiedTimestamp: Int64


  fileprivate init(lastModifiedTimestamp: Int64) {
    self.lastModifiedTimestamp = lastModifiedTimestamp
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getCompactContacts_args, rhs: ChannelApplicationProvidedService_getCompactContacts_args) -> Bool {
  return
    (lhs.lastModifiedTimestamp == rhs.lastModifiedTimestamp)
}

extension ChannelApplicationProvidedService_getCompactContacts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastModifiedTimestamp.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_getCompactContacts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastModifiedTimestamp": 2, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getCompactContacts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getCompactContacts_args {
    _ = try proto.readStructBegin()
    var lastModifiedTimestamp: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             lastModifiedTimestamp = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastModifiedTimestamp, named: "lastModifiedTimestamp")

    return ChannelApplicationProvidedService_getCompactContacts_args(lastModifiedTimestamp: lastModifiedTimestamp)
  }

}



fileprivate final class ChannelApplicationProvidedService_getCompactContacts_result {

  fileprivate var success: TList<CompactContact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<CompactContact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getCompactContacts_result, rhs: ChannelApplicationProvidedService_getCompactContacts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getCompactContacts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getCompactContacts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getCompactContacts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getCompactContacts_result {
    _ = try proto.readStructBegin()
    var success: TList<CompactContact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<CompactContact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getCompactContacts_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getContactsForChannel_args {

  fileprivate var ids: TList<String>


  fileprivate init(ids: TList<String>) {
    self.ids = ids
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getContactsForChannel_args, rhs: ChannelApplicationProvidedService_getContactsForChannel_args) -> Bool {
  return
    (lhs.ids == rhs.ids)
}

extension ChannelApplicationProvidedService_getContactsForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ids.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_getContactsForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ids": 2, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getContactsForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getContactsForChannel_args {
    _ = try proto.readStructBegin()
    var ids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .list):            ids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ids, named: "ids")

    return ChannelApplicationProvidedService_getContactsForChannel_args(ids: ids)
  }

}



fileprivate final class ChannelApplicationProvidedService_getContactsForChannel_result {

  fileprivate var success: TList<Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getContactsForChannel_result, rhs: ChannelApplicationProvidedService_getContactsForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getContactsForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getContactsForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getContactsForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getContactsForChannel_result {
    _ = try proto.readStructBegin()
    var success: TList<Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getContactsForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getDisplayName_args {

  fileprivate var mid: String


  fileprivate init(mid: String) {
    self.mid = mid
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getDisplayName_args, rhs: ChannelApplicationProvidedService_getDisplayName_args) -> Bool {
  return
    (lhs.mid == rhs.mid)
}

extension ChannelApplicationProvidedService_getDisplayName_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_getDisplayName_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["mid": 2, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getDisplayName_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getDisplayName_args {
    _ = try proto.readStructBegin()
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")

    return ChannelApplicationProvidedService_getDisplayName_args(mid: mid)
  }

}



fileprivate final class ChannelApplicationProvidedService_getDisplayName_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getDisplayName_result, rhs: ChannelApplicationProvidedService_getDisplayName_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getDisplayName_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getDisplayName_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getDisplayName_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getDisplayName_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getDisplayName_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getFavoriteMidsForChannel_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getFavoriteMidsForChannel_args, rhs: ChannelApplicationProvidedService_getFavoriteMidsForChannel_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getFavoriteMidsForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getFavoriteMidsForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getFavoriteMidsForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getFavoriteMidsForChannel_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getFavoriteMidsForChannel_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getFavoriteMidsForChannel_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getFavoriteMidsForChannel_result, rhs: ChannelApplicationProvidedService_getFavoriteMidsForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getFavoriteMidsForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getFavoriteMidsForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getFavoriteMidsForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getFavoriteMidsForChannel_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getFavoriteMidsForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getFriendMids_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getFriendMids_args, rhs: ChannelApplicationProvidedService_getFriendMids_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getFriendMids_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getFriendMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getFriendMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getFriendMids_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getFriendMids_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getFriendMids_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getFriendMids_result, rhs: ChannelApplicationProvidedService_getFriendMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getFriendMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getFriendMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getFriendMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getFriendMids_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getFriendMids_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getGroupMemberMids_args {

  fileprivate var groupId: String


  fileprivate init(groupId: String) {
    self.groupId = groupId
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getGroupMemberMids_args, rhs: ChannelApplicationProvidedService_getGroupMemberMids_args) -> Bool {
  return
    (lhs.groupId == rhs.groupId)
}

extension ChannelApplicationProvidedService_getGroupMemberMids_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (groupId.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_getGroupMemberMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["groupId": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getGroupMemberMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getGroupMemberMids_args {
    _ = try proto.readStructBegin()
    var groupId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           groupId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(groupId, named: "groupId")

    return ChannelApplicationProvidedService_getGroupMemberMids_args(groupId: groupId)
  }

}



fileprivate final class ChannelApplicationProvidedService_getGroupMemberMids_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getGroupMemberMids_result, rhs: ChannelApplicationProvidedService_getGroupMemberMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getGroupMemberMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getGroupMemberMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getGroupMemberMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getGroupMemberMids_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getGroupMemberMids_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getGroupsForChannel_args {

  fileprivate var groupIds: TList<String>


  fileprivate init(groupIds: TList<String>) {
    self.groupIds = groupIds
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getGroupsForChannel_args, rhs: ChannelApplicationProvidedService_getGroupsForChannel_args) -> Bool {
  return
    (lhs.groupIds == rhs.groupIds)
}

extension ChannelApplicationProvidedService_getGroupsForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (groupIds.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_getGroupsForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["groupIds": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getGroupsForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getGroupsForChannel_args {
    _ = try proto.readStructBegin()
    var groupIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            groupIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(groupIds, named: "groupIds")

    return ChannelApplicationProvidedService_getGroupsForChannel_args(groupIds: groupIds)
  }

}



fileprivate final class ChannelApplicationProvidedService_getGroupsForChannel_result {

  fileprivate var success: TList<Group>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Group>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getGroupsForChannel_result, rhs: ChannelApplicationProvidedService_getGroupsForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getGroupsForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getGroupsForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getGroupsForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getGroupsForChannel_result {
    _ = try proto.readStructBegin()
    var success: TList<Group>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Group>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getGroupsForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getIdentityCredential_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getIdentityCredential_args, rhs: ChannelApplicationProvidedService_getIdentityCredential_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getIdentityCredential_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getIdentityCredential_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getIdentityCredential_result {

  fileprivate var success: IdentityCredential?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: IdentityCredential?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getIdentityCredential_result, rhs: ChannelApplicationProvidedService_getIdentityCredential_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getIdentityCredential_result {
    _ = try proto.readStructBegin()
    var success: IdentityCredential?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try IdentityCredential.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getIdentityCredential_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args, rhs: ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result, rhs: ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getMetaProfile_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getMetaProfile_args, rhs: ChannelApplicationProvidedService_getMetaProfile_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getMetaProfile_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getMetaProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getMetaProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getMetaProfile_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getMetaProfile_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getMetaProfile_result {

  fileprivate var success: MetaProfile?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: MetaProfile?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getMetaProfile_result, rhs: ChannelApplicationProvidedService_getMetaProfile_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getMetaProfile_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getMetaProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getMetaProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getMetaProfile_result {
    _ = try proto.readStructBegin()
    var success: MetaProfile?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try MetaProfile.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getMetaProfile_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getMid_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getMid_args, rhs: ChannelApplicationProvidedService_getMid_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getMid_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getMid_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getMid_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getMid_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getMid_result, rhs: ChannelApplicationProvidedService_getMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getMid_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getMid_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getPrimaryClientForChannel_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getPrimaryClientForChannel_args, rhs: ChannelApplicationProvidedService_getPrimaryClientForChannel_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getPrimaryClientForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getPrimaryClientForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getPrimaryClientForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getPrimaryClientForChannel_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getPrimaryClientForChannel_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getPrimaryClientForChannel_result {

  fileprivate var success: SimpleChannelClient?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SimpleChannelClient?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getPrimaryClientForChannel_result, rhs: ChannelApplicationProvidedService_getPrimaryClientForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getPrimaryClientForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getPrimaryClientForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getPrimaryClientForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getPrimaryClientForChannel_result {
    _ = try proto.readStructBegin()
    var success: SimpleChannelClient?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SimpleChannelClient.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getPrimaryClientForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getProfileForChannel_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getProfileForChannel_args, rhs: ChannelApplicationProvidedService_getProfileForChannel_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getProfileForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getProfileForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getProfileForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getProfileForChannel_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getProfileForChannel_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getProfileForChannel_result {

  fileprivate var success: Profile?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Profile?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getProfileForChannel_result, rhs: ChannelApplicationProvidedService_getProfileForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getProfileForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getProfileForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getProfileForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getProfileForChannel_result {
    _ = try proto.readStructBegin()
    var success: Profile?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Profile.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getProfileForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getSimpleChannelContacts_args {

  fileprivate var ids: TList<String>


  fileprivate init(ids: TList<String>) {
    self.ids = ids
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getSimpleChannelContacts_args, rhs: ChannelApplicationProvidedService_getSimpleChannelContacts_args) -> Bool {
  return
    (lhs.ids == rhs.ids)
}

extension ChannelApplicationProvidedService_getSimpleChannelContacts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ids.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_getSimpleChannelContacts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ids": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getSimpleChannelContacts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getSimpleChannelContacts_args {
    _ = try proto.readStructBegin()
    var ids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            ids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ids, named: "ids")

    return ChannelApplicationProvidedService_getSimpleChannelContacts_args(ids: ids)
  }

}



fileprivate final class ChannelApplicationProvidedService_getSimpleChannelContacts_result {

  fileprivate var success: TList<SimpleChannelContact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<SimpleChannelContact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getSimpleChannelContacts_result, rhs: ChannelApplicationProvidedService_getSimpleChannelContacts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getSimpleChannelContacts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getSimpleChannelContacts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getSimpleChannelContacts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getSimpleChannelContacts_result {
    _ = try proto.readStructBegin()
    var success: TList<SimpleChannelContact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<SimpleChannelContact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getSimpleChannelContacts_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserCountryForBilling_args {

  fileprivate var country: String

  fileprivate var remoteIp: String


  fileprivate init(country: String, remoteIp: String) {
    self.country = country
    self.remoteIp = remoteIp
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserCountryForBilling_args, rhs: ChannelApplicationProvidedService_getUserCountryForBilling_args) -> Bool {
  return
    (lhs.country == rhs.country) &&
    (lhs.remoteIp == rhs.remoteIp)
}

extension ChannelApplicationProvidedService_getUserCountryForBilling_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (remoteIp.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_getUserCountryForBilling_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["country": 2, "remoteIp": 3, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserCountryForBilling_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserCountryForBilling_args {
    _ = try proto.readStructBegin()
    var country: String!
    var remoteIp: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           country = try String.read(from: proto)
        case (3, .string):           remoteIp = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(country, named: "country")
    try proto.validateValue(remoteIp, named: "remoteIp")

    return ChannelApplicationProvidedService_getUserCountryForBilling_args(country: country, remoteIp: remoteIp)
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserCountryForBilling_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserCountryForBilling_result, rhs: ChannelApplicationProvidedService_getUserCountryForBilling_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getUserCountryForBilling_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getUserCountryForBilling_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserCountryForBilling_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserCountryForBilling_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserCountryForBilling_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserCreateTime_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserCreateTime_args, rhs: ChannelApplicationProvidedService_getUserCreateTime_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getUserCreateTime_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getUserCreateTime_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserCreateTime_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserCreateTime_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserCreateTime_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserCreateTime_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserCreateTime_result, rhs: ChannelApplicationProvidedService_getUserCreateTime_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getUserCreateTime_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getUserCreateTime_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserCreateTime_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserCreateTime_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserCreateTime_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserIdentities_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserIdentities_args, rhs: ChannelApplicationProvidedService_getUserIdentities_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getUserIdentities_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getUserIdentities_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserIdentities_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserIdentities_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserIdentities_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserIdentities_result {

  fileprivate var success: TMap<RegistrationType, String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<RegistrationType, String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserIdentities_result, rhs: ChannelApplicationProvidedService_getUserIdentities_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getUserIdentities_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getUserIdentities_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserIdentities_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserIdentities_result {
    _ = try proto.readStructBegin()
    var success: TMap<RegistrationType, String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<RegistrationType, String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserIdentities_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserLanguage_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserLanguage_args, rhs: ChannelApplicationProvidedService_getUserLanguage_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getUserLanguage_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getUserLanguage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserLanguage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserLanguage_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserLanguage_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserLanguage_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserLanguage_result, rhs: ChannelApplicationProvidedService_getUserLanguage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getUserLanguage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getUserLanguage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserLanguage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserLanguage_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserLanguage_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args, rhs: ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args) -> Bool {
  return true
}

extension ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args()
  }

}



fileprivate final class ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result, rhs: ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_isGroupMember_args {

  fileprivate var groupId: String


  fileprivate init(groupId: String) {
    self.groupId = groupId
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_isGroupMember_args, rhs: ChannelApplicationProvidedService_isGroupMember_args) -> Bool {
  return
    (lhs.groupId == rhs.groupId)
}

extension ChannelApplicationProvidedService_isGroupMember_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (groupId.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_isGroupMember_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["groupId": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_isGroupMember_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_isGroupMember_args {
    _ = try proto.readStructBegin()
    var groupId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           groupId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(groupId, named: "groupId")

    return ChannelApplicationProvidedService_isGroupMember_args(groupId: groupId)
  }

}



fileprivate final class ChannelApplicationProvidedService_isGroupMember_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_isGroupMember_result, rhs: ChannelApplicationProvidedService_isGroupMember_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_isGroupMember_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_isGroupMember_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_isGroupMember_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_isGroupMember_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_isGroupMember_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_isInContact_args {

  fileprivate var mid: String


  fileprivate init(mid: String) {
    self.mid = mid
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_isInContact_args, rhs: ChannelApplicationProvidedService_isInContact_args) -> Bool {
  return
    (lhs.mid == rhs.mid)
}

extension ChannelApplicationProvidedService_isInContact_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_isInContact_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["mid": 2, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_isInContact_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_isInContact_args {
    _ = try proto.readStructBegin()
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")

    return ChannelApplicationProvidedService_isInContact_args(mid: mid)
  }

}



fileprivate final class ChannelApplicationProvidedService_isInContact_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_isInContact_result, rhs: ChannelApplicationProvidedService_isInContact_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_isInContact_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_isInContact_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_isInContact_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_isInContact_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_isInContact_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_registerChannelCP_args {

  fileprivate var cpId: String

  fileprivate var registerPassword: String


  fileprivate init(cpId: String, registerPassword: String) {
    self.cpId = cpId
    self.registerPassword = registerPassword
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_registerChannelCP_args, rhs: ChannelApplicationProvidedService_registerChannelCP_args) -> Bool {
  return
    (lhs.cpId == rhs.cpId) &&
    (lhs.registerPassword == rhs.registerPassword)
}

extension ChannelApplicationProvidedService_registerChannelCP_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (cpId.hashValue)
    result = prime &* result &+ (registerPassword.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_registerChannelCP_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["cpId": 2, "registerPassword": 3, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_registerChannelCP_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_registerChannelCP_args {
    _ = try proto.readStructBegin()
    var cpId: String!
    var registerPassword: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           cpId = try String.read(from: proto)
        case (3, .string):           registerPassword = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(cpId, named: "cpId")
    try proto.validateValue(registerPassword, named: "registerPassword")

    return ChannelApplicationProvidedService_registerChannelCP_args(cpId: cpId, registerPassword: registerPassword)
  }

}



fileprivate final class ChannelApplicationProvidedService_registerChannelCP_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_registerChannelCP_result, rhs: ChannelApplicationProvidedService_registerChannelCP_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_registerChannelCP_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_registerChannelCP_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_registerChannelCP_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_registerChannelCP_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_registerChannelCP_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_removeNotificationStatus_args {

  fileprivate var notificationStatus: NotificationStatus


  fileprivate init(notificationStatus: NotificationStatus) {
    self.notificationStatus = notificationStatus
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_removeNotificationStatus_args, rhs: ChannelApplicationProvidedService_removeNotificationStatus_args) -> Bool {
  return
    (lhs.notificationStatus == rhs.notificationStatus)
}

extension ChannelApplicationProvidedService_removeNotificationStatus_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (notificationStatus.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_removeNotificationStatus_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["notificationStatus": 2, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_removeNotificationStatus_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_removeNotificationStatus_args {
    _ = try proto.readStructBegin()
    var notificationStatus: NotificationStatus!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             notificationStatus = try NotificationStatus.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(notificationStatus, named: "notificationStatus")

    return ChannelApplicationProvidedService_removeNotificationStatus_args(notificationStatus: notificationStatus)
  }

}



fileprivate final class ChannelApplicationProvidedService_removeNotificationStatus_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_removeNotificationStatus_result, rhs: ChannelApplicationProvidedService_removeNotificationStatus_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_removeNotificationStatus_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_removeNotificationStatus_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_removeNotificationStatus_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_removeNotificationStatus_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_removeNotificationStatus_result(e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_sendMessageForChannel_args {

  fileprivate var message: Message


  fileprivate init(message: Message) {
    self.message = message
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_sendMessageForChannel_args, rhs: ChannelApplicationProvidedService_sendMessageForChannel_args) -> Bool {
  return
    (lhs.message == rhs.message)
}

extension ChannelApplicationProvidedService_sendMessageForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_sendMessageForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["message": 2, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_sendMessageForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_sendMessageForChannel_args {
    _ = try proto.readStructBegin()
    var message: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           message = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(message, named: "message")

    return ChannelApplicationProvidedService_sendMessageForChannel_args(message: message)
  }

}



fileprivate final class ChannelApplicationProvidedService_sendMessageForChannel_result {

  fileprivate var success: Message?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Message?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_sendMessageForChannel_result, rhs: ChannelApplicationProvidedService_sendMessageForChannel_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_sendMessageForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_sendMessageForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_sendMessageForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_sendMessageForChannel_result {
    _ = try proto.readStructBegin()
    var success: Message?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Message.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_sendMessageForChannel_result(success: success, e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_sendPinCodeOperation_args {

  fileprivate var verifier: String


  fileprivate init(verifier: String) {
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_sendPinCodeOperation_args, rhs: ChannelApplicationProvidedService_sendPinCodeOperation_args) -> Bool {
  return
    (lhs.verifier == rhs.verifier)
}

extension ChannelApplicationProvidedService_sendPinCodeOperation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_sendPinCodeOperation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["verifier": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_sendPinCodeOperation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_sendPinCodeOperation_args {
    _ = try proto.readStructBegin()
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(verifier, named: "verifier")

    return ChannelApplicationProvidedService_sendPinCodeOperation_args(verifier: verifier)
  }

}



fileprivate final class ChannelApplicationProvidedService_sendPinCodeOperation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_sendPinCodeOperation_result, rhs: ChannelApplicationProvidedService_sendPinCodeOperation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_sendPinCodeOperation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_sendPinCodeOperation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_sendPinCodeOperation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_sendPinCodeOperation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_sendPinCodeOperation_result(e: e)
  }

}



fileprivate final class ChannelApplicationProvidedService_updateProfileAttributeForChannel_args {

  fileprivate var profileAttribute: ProfileAttribute

  fileprivate var value: String


  fileprivate init(profileAttribute: ProfileAttribute, value: String) {
    self.profileAttribute = profileAttribute
    self.value = value
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_updateProfileAttributeForChannel_args, rhs: ChannelApplicationProvidedService_updateProfileAttributeForChannel_args) -> Bool {
  return
    (lhs.profileAttribute == rhs.profileAttribute) &&
    (lhs.value == rhs.value)
}

extension ChannelApplicationProvidedService_updateProfileAttributeForChannel_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (profileAttribute.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension ChannelApplicationProvidedService_updateProfileAttributeForChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["profileAttribute": 2, "value": 3, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_updateProfileAttributeForChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_updateProfileAttributeForChannel_args {
    _ = try proto.readStructBegin()
    var profileAttribute: ProfileAttribute!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             profileAttribute = try ProfileAttribute.read(from: proto)
        case (3, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(profileAttribute, named: "profileAttribute")
    try proto.validateValue(value, named: "value")

    return ChannelApplicationProvidedService_updateProfileAttributeForChannel_args(profileAttribute: profileAttribute, value: value)
  }

}



fileprivate final class ChannelApplicationProvidedService_updateProfileAttributeForChannel_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelApplicationProvidedService_updateProfileAttributeForChannel_result, rhs: ChannelApplicationProvidedService_updateProfileAttributeForChannel_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ChannelApplicationProvidedService_updateProfileAttributeForChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelApplicationProvidedService_updateProfileAttributeForChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelApplicationProvidedService_updateProfileAttributeForChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelApplicationProvidedService_updateProfileAttributeForChannel_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelApplicationProvidedService_updateProfileAttributeForChannel_result(e: e)
  }

}



extension ChannelApplicationProvidedServiceClient : ChannelApplicationProvidedService {

  private func send_activeBuddySubscriberCount() throws {
    try outProtocol.writeMessageBegin(name: "activeBuddySubscriberCount", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_activeBuddySubscriberCount_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_activeBuddySubscriberCount() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_activeBuddySubscriberCount_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "activeBuddySubscriberCount"))
  }

  public func activeBuddySubscriberCount() throws -> Int64 {
    try send_activeBuddySubscriberCount()
    try outProtocol.transport.flush()
    return try recv_activeBuddySubscriberCount()
  }

  private func send_addOperationForChannel(opType: OpType, param1: String, param2: String, param3: String) throws {
    try outProtocol.writeMessageBegin(name: "addOperationForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_addOperationForChannel_args(opType: opType, param1: param1, param2: param2, param3: param3)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_addOperationForChannel() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_addOperationForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func addOperationForChannel(opType: OpType, param1: String, param2: String, param3: String) throws {
    try send_addOperationForChannel(opType: opType, param1: param1, param2: param2, param3: param3)
    try outProtocol.transport.flush()
    try recv_addOperationForChannel()
  }

  private func send_displayBuddySubscriberCount() throws {
    try outProtocol.writeMessageBegin(name: "displayBuddySubscriberCount", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_displayBuddySubscriberCount_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_displayBuddySubscriberCount() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_displayBuddySubscriberCount_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "displayBuddySubscriberCount"))
  }

  public func displayBuddySubscriberCount() throws -> Int64 {
    try send_displayBuddySubscriberCount()
    try outProtocol.transport.flush()
    return try recv_displayBuddySubscriberCount()
  }

  private func send_findContactByUseridWithoutAbuseBlockForChannel(userid: String) throws {
    try outProtocol.writeMessageBegin(name: "findContactByUseridWithoutAbuseBlockForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args(userid: userid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findContactByUseridWithoutAbuseBlockForChannel() throws -> Contact {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findContactByUseridWithoutAbuseBlockForChannel"))
  }

  public func findContactByUseridWithoutAbuseBlockForChannel(userid: String) throws -> Contact {
    try send_findContactByUseridWithoutAbuseBlockForChannel(userid: userid)
    try outProtocol.transport.flush()
    return try recv_findContactByUseridWithoutAbuseBlockForChannel()
  }

  private func send_getAllContactIdsForChannel() throws {
    try outProtocol.writeMessageBegin(name: "getAllContactIdsForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getAllContactIdsForChannel_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getAllContactIdsForChannel() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getAllContactIdsForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getAllContactIdsForChannel"))
  }

  public func getAllContactIdsForChannel() throws -> TList<String> {
    try send_getAllContactIdsForChannel()
    try outProtocol.transport.flush()
    return try recv_getAllContactIdsForChannel()
  }

  private func send_getCompactContacts(lastModifiedTimestamp: Int64) throws {
    try outProtocol.writeMessageBegin(name: "getCompactContacts", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getCompactContacts_args(lastModifiedTimestamp: lastModifiedTimestamp)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCompactContacts() throws -> TList<CompactContact> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getCompactContacts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCompactContacts"))
  }

  public func getCompactContacts(lastModifiedTimestamp: Int64) throws -> TList<CompactContact> {
    try send_getCompactContacts(lastModifiedTimestamp: lastModifiedTimestamp)
    try outProtocol.transport.flush()
    return try recv_getCompactContacts()
  }

  private func send_getContactsForChannel(ids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "getContactsForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getContactsForChannel_args(ids: ids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getContactsForChannel() throws -> TList<Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getContactsForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getContactsForChannel"))
  }

  public func getContactsForChannel(ids: TList<String>) throws -> TList<Contact> {
    try send_getContactsForChannel(ids: ids)
    try outProtocol.transport.flush()
    return try recv_getContactsForChannel()
  }

  private func send_getDisplayName(mid: String) throws {
    try outProtocol.writeMessageBegin(name: "getDisplayName", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getDisplayName_args(mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getDisplayName() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getDisplayName_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getDisplayName"))
  }

  public func getDisplayName(mid: String) throws -> String {
    try send_getDisplayName(mid: mid)
    try outProtocol.transport.flush()
    return try recv_getDisplayName()
  }

  private func send_getFavoriteMidsForChannel() throws {
    try outProtocol.writeMessageBegin(name: "getFavoriteMidsForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getFavoriteMidsForChannel_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getFavoriteMidsForChannel() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getFavoriteMidsForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getFavoriteMidsForChannel"))
  }

  public func getFavoriteMidsForChannel() throws -> TList<String> {
    try send_getFavoriteMidsForChannel()
    try outProtocol.transport.flush()
    return try recv_getFavoriteMidsForChannel()
  }

  private func send_getFriendMids() throws {
    try outProtocol.writeMessageBegin(name: "getFriendMids", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getFriendMids_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getFriendMids() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getFriendMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getFriendMids"))
  }

  public func getFriendMids() throws -> TList<String> {
    try send_getFriendMids()
    try outProtocol.transport.flush()
    return try recv_getFriendMids()
  }

  private func send_getGroupMemberMids(groupId: String) throws {
    try outProtocol.writeMessageBegin(name: "getGroupMemberMids", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getGroupMemberMids_args(groupId: groupId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getGroupMemberMids() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getGroupMemberMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getGroupMemberMids"))
  }

  public func getGroupMemberMids(groupId: String) throws -> TList<String> {
    try send_getGroupMemberMids(groupId: groupId)
    try outProtocol.transport.flush()
    return try recv_getGroupMemberMids()
  }

  private func send_getGroupsForChannel(groupIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "getGroupsForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getGroupsForChannel_args(groupIds: groupIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getGroupsForChannel() throws -> TList<Group> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getGroupsForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getGroupsForChannel"))
  }

  public func getGroupsForChannel(groupIds: TList<String>) throws -> TList<Group> {
    try send_getGroupsForChannel(groupIds: groupIds)
    try outProtocol.transport.flush()
    return try recv_getGroupsForChannel()
  }

  private func send_getIdentityCredential() throws {
    try outProtocol.writeMessageBegin(name: "getIdentityCredential", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getIdentityCredential_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getIdentityCredential() throws -> IdentityCredential {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getIdentityCredential"))
  }

  public func getIdentityCredential() throws -> IdentityCredential {
    try send_getIdentityCredential()
    try outProtocol.transport.flush()
    return try recv_getIdentityCredential()
  }

  private func send_getJoinedGroupIdsForChannel() throws {
    try outProtocol.writeMessageBegin(name: "getJoinedGroupIdsForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getJoinedGroupIdsForChannel() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getJoinedGroupIdsForChannel"))
  }

  public func getJoinedGroupIdsForChannel() throws -> TList<String> {
    try send_getJoinedGroupIdsForChannel()
    try outProtocol.transport.flush()
    return try recv_getJoinedGroupIdsForChannel()
  }

  private func send_getMetaProfile() throws {
    try outProtocol.writeMessageBegin(name: "getMetaProfile", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getMetaProfile_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMetaProfile() throws -> MetaProfile {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getMetaProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMetaProfile"))
  }

  public func getMetaProfile() throws -> MetaProfile {
    try send_getMetaProfile()
    try outProtocol.transport.flush()
    return try recv_getMetaProfile()
  }

  private func send_getMid() throws {
    try outProtocol.writeMessageBegin(name: "getMid", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getMid_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMid() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMid"))
  }

  public func getMid() throws -> String {
    try send_getMid()
    try outProtocol.transport.flush()
    return try recv_getMid()
  }

  private func send_getPrimaryClientForChannel() throws {
    try outProtocol.writeMessageBegin(name: "getPrimaryClientForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getPrimaryClientForChannel_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPrimaryClientForChannel() throws -> SimpleChannelClient {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getPrimaryClientForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPrimaryClientForChannel"))
  }

  public func getPrimaryClientForChannel() throws -> SimpleChannelClient {
    try send_getPrimaryClientForChannel()
    try outProtocol.transport.flush()
    return try recv_getPrimaryClientForChannel()
  }

  private func send_getProfileForChannel() throws {
    try outProtocol.writeMessageBegin(name: "getProfileForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getProfileForChannel_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProfileForChannel() throws -> Profile {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getProfileForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProfileForChannel"))
  }

  public func getProfileForChannel() throws -> Profile {
    try send_getProfileForChannel()
    try outProtocol.transport.flush()
    return try recv_getProfileForChannel()
  }

  private func send_getSimpleChannelContacts(ids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "getSimpleChannelContacts", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getSimpleChannelContacts_args(ids: ids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSimpleChannelContacts() throws -> TList<SimpleChannelContact> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getSimpleChannelContacts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSimpleChannelContacts"))
  }

  public func getSimpleChannelContacts(ids: TList<String>) throws -> TList<SimpleChannelContact> {
    try send_getSimpleChannelContacts(ids: ids)
    try outProtocol.transport.flush()
    return try recv_getSimpleChannelContacts()
  }

  private func send_getUserCountryForBilling(country: String, remoteIp: String) throws {
    try outProtocol.writeMessageBegin(name: "getUserCountryForBilling", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getUserCountryForBilling_args(country: country, remoteIp: remoteIp)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUserCountryForBilling() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getUserCountryForBilling_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getUserCountryForBilling"))
  }

  public func getUserCountryForBilling(country: String, remoteIp: String) throws -> String {
    try send_getUserCountryForBilling(country: country, remoteIp: remoteIp)
    try outProtocol.transport.flush()
    return try recv_getUserCountryForBilling()
  }

  private func send_getUserCreateTime() throws {
    try outProtocol.writeMessageBegin(name: "getUserCreateTime", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getUserCreateTime_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUserCreateTime() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getUserCreateTime_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getUserCreateTime"))
  }

  public func getUserCreateTime() throws -> Int64 {
    try send_getUserCreateTime()
    try outProtocol.transport.flush()
    return try recv_getUserCreateTime()
  }

  private func send_getUserIdentities() throws {
    try outProtocol.writeMessageBegin(name: "getUserIdentities", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getUserIdentities_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUserIdentities() throws -> TMap<RegistrationType, String> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getUserIdentities_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getUserIdentities"))
  }

  public func getUserIdentities() throws -> TMap<RegistrationType, String> {
    try send_getUserIdentities()
    try outProtocol.transport.flush()
    return try recv_getUserIdentities()
  }

  private func send_getUserLanguage() throws {
    try outProtocol.writeMessageBegin(name: "getUserLanguage", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getUserLanguage_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUserLanguage() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getUserLanguage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getUserLanguage"))
  }

  public func getUserLanguage() throws -> String {
    try send_getUserLanguage()
    try outProtocol.transport.flush()
    return try recv_getUserLanguage()
  }

  private func send_getUserMidsWhoAddedMe() throws {
    try outProtocol.writeMessageBegin(name: "getUserMidsWhoAddedMe", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUserMidsWhoAddedMe() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getUserMidsWhoAddedMe"))
  }

  public func getUserMidsWhoAddedMe() throws -> TList<String> {
    try send_getUserMidsWhoAddedMe()
    try outProtocol.transport.flush()
    return try recv_getUserMidsWhoAddedMe()
  }

  private func send_isGroupMember(groupId: String) throws {
    try outProtocol.writeMessageBegin(name: "isGroupMember", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_isGroupMember_args(groupId: groupId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isGroupMember() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_isGroupMember_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "isGroupMember"))
  }

  public func isGroupMember(groupId: String) throws -> Bool {
    try send_isGroupMember(groupId: groupId)
    try outProtocol.transport.flush()
    return try recv_isGroupMember()
  }

  private func send_isInContact(mid: String) throws {
    try outProtocol.writeMessageBegin(name: "isInContact", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_isInContact_args(mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isInContact() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_isInContact_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "isInContact"))
  }

  public func isInContact(mid: String) throws -> Bool {
    try send_isInContact(mid: mid)
    try outProtocol.transport.flush()
    return try recv_isInContact()
  }

  private func send_registerChannelCP(cpId: String, registerPassword: String) throws {
    try outProtocol.writeMessageBegin(name: "registerChannelCP", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_registerChannelCP_args(cpId: cpId, registerPassword: registerPassword)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerChannelCP() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_registerChannelCP_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerChannelCP"))
  }

  public func registerChannelCP(cpId: String, registerPassword: String) throws -> String {
    try send_registerChannelCP(cpId: cpId, registerPassword: registerPassword)
    try outProtocol.transport.flush()
    return try recv_registerChannelCP()
  }

  private func send_removeNotificationStatus(notificationStatus: NotificationStatus) throws {
    try outProtocol.writeMessageBegin(name: "removeNotificationStatus", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_removeNotificationStatus_args(notificationStatus: notificationStatus)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeNotificationStatus() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_removeNotificationStatus_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func removeNotificationStatus(notificationStatus: NotificationStatus) throws {
    try send_removeNotificationStatus(notificationStatus: notificationStatus)
    try outProtocol.transport.flush()
    try recv_removeNotificationStatus()
  }

  private func send_sendMessageForChannel(message: Message) throws {
    try outProtocol.writeMessageBegin(name: "sendMessageForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_sendMessageForChannel_args(message: message)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMessageForChannel() throws -> Message {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_sendMessageForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendMessageForChannel"))
  }

  public func sendMessageForChannel(message: Message) throws -> Message {
    try send_sendMessageForChannel(message: message)
    try outProtocol.transport.flush()
    return try recv_sendMessageForChannel()
  }

  private func send_sendPinCodeOperation(verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "sendPinCodeOperation", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_sendPinCodeOperation_args(verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendPinCodeOperation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_sendPinCodeOperation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendPinCodeOperation(verifier: String) throws {
    try send_sendPinCodeOperation(verifier: verifier)
    try outProtocol.transport.flush()
    try recv_sendPinCodeOperation()
  }

  private func send_updateProfileAttributeForChannel(profileAttribute: ProfileAttribute, value: String) throws {
    try outProtocol.writeMessageBegin(name: "updateProfileAttributeForChannel", type: .call, sequenceID: 0)
    let args = ChannelApplicationProvidedService_updateProfileAttributeForChannel_args(profileAttribute: profileAttribute, value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateProfileAttributeForChannel() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelApplicationProvidedService_updateProfileAttributeForChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateProfileAttributeForChannel(profileAttribute: ProfileAttribute, value: String) throws {
    try send_updateProfileAttributeForChannel(profileAttribute: profileAttribute, value: value)
    try outProtocol.transport.flush()
    try recv_updateProfileAttributeForChannel()
  }

}

extension ChannelApplicationProvidedServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["activeBuddySubscriberCount"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_activeBuddySubscriberCount_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_activeBuddySubscriberCount_result()
      do {
        result.success = try handler.activeBuddySubscriberCount()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "activeBuddySubscriberCount", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["addOperationForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_addOperationForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_addOperationForChannel_result()
      do {
        try handler.addOperationForChannel(opType: args.opType, param1: args.param1, param2: args.param2, param3: args.param3)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "addOperationForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["displayBuddySubscriberCount"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_displayBuddySubscriberCount_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_displayBuddySubscriberCount_result()
      do {
        result.success = try handler.displayBuddySubscriberCount()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "displayBuddySubscriberCount", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findContactByUseridWithoutAbuseBlockForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result()
      do {
        result.success = try handler.findContactByUseridWithoutAbuseBlockForChannel(userid: args.userid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findContactByUseridWithoutAbuseBlockForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getAllContactIdsForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getAllContactIdsForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getAllContactIdsForChannel_result()
      do {
        result.success = try handler.getAllContactIdsForChannel()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getAllContactIdsForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCompactContacts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getCompactContacts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getCompactContacts_result()
      do {
        result.success = try handler.getCompactContacts(lastModifiedTimestamp: args.lastModifiedTimestamp)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCompactContacts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getContactsForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getContactsForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getContactsForChannel_result()
      do {
        result.success = try handler.getContactsForChannel(ids: args.ids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getContactsForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getDisplayName"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getDisplayName_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getDisplayName_result()
      do {
        result.success = try handler.getDisplayName(mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getDisplayName", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getFavoriteMidsForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getFavoriteMidsForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getFavoriteMidsForChannel_result()
      do {
        result.success = try handler.getFavoriteMidsForChannel()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getFavoriteMidsForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getFriendMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getFriendMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getFriendMids_result()
      do {
        result.success = try handler.getFriendMids()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getFriendMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getGroupMemberMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getGroupMemberMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getGroupMemberMids_result()
      do {
        result.success = try handler.getGroupMemberMids(groupId: args.groupId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getGroupMemberMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getGroupsForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getGroupsForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getGroupsForChannel_result()
      do {
        result.success = try handler.getGroupsForChannel(groupIds: args.groupIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getGroupsForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getIdentityCredential_result()
      do {
        result.success = try handler.getIdentityCredential()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getJoinedGroupIdsForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result()
      do {
        result.success = try handler.getJoinedGroupIdsForChannel()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getJoinedGroupIdsForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMetaProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getMetaProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getMetaProfile_result()
      do {
        result.success = try handler.getMetaProfile()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMetaProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getMid_result()
      do {
        result.success = try handler.getMid()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPrimaryClientForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getPrimaryClientForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getPrimaryClientForChannel_result()
      do {
        result.success = try handler.getPrimaryClientForChannel()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPrimaryClientForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProfileForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getProfileForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getProfileForChannel_result()
      do {
        result.success = try handler.getProfileForChannel()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProfileForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSimpleChannelContacts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getSimpleChannelContacts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getSimpleChannelContacts_result()
      do {
        result.success = try handler.getSimpleChannelContacts(ids: args.ids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSimpleChannelContacts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getUserCountryForBilling"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getUserCountryForBilling_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getUserCountryForBilling_result()
      do {
        result.success = try handler.getUserCountryForBilling(country: args.country, remoteIp: args.remoteIp)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUserCountryForBilling", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getUserCreateTime"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getUserCreateTime_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getUserCreateTime_result()
      do {
        result.success = try handler.getUserCreateTime()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUserCreateTime", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getUserIdentities"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getUserIdentities_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getUserIdentities_result()
      do {
        result.success = try handler.getUserIdentities()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUserIdentities", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getUserLanguage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getUserLanguage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getUserLanguage_result()
      do {
        result.success = try handler.getUserLanguage()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUserLanguage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getUserMidsWhoAddedMe"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result()
      do {
        result.success = try handler.getUserMidsWhoAddedMe()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUserMidsWhoAddedMe", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["isGroupMember"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_isGroupMember_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_isGroupMember_result()
      do {
        result.success = try handler.isGroupMember(groupId: args.groupId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isGroupMember", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["isInContact"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_isInContact_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_isInContact_result()
      do {
        result.success = try handler.isInContact(mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isInContact", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerChannelCP"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_registerChannelCP_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_registerChannelCP_result()
      do {
        result.success = try handler.registerChannelCP(cpId: args.cpId, registerPassword: args.registerPassword)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerChannelCP", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeNotificationStatus"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_removeNotificationStatus_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_removeNotificationStatus_result()
      do {
        try handler.removeNotificationStatus(notificationStatus: args.notificationStatus)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeNotificationStatus", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendMessageForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_sendMessageForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_sendMessageForChannel_result()
      do {
        result.success = try handler.sendMessageForChannel(message: args.message)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMessageForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendPinCodeOperation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_sendPinCodeOperation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_sendPinCodeOperation_result()
      do {
        try handler.sendPinCodeOperation(verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendPinCodeOperation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateProfileAttributeForChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelApplicationProvidedService_updateProfileAttributeForChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelApplicationProvidedService_updateProfileAttributeForChannel_result()
      do {
        try handler.updateProfileAttributeForChannel(profileAttribute: args.profileAttribute, value: args.value)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateProfileAttributeForChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = ChannelApplicationProvidedServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class ChannelService_approveChannelAndIssueChannelToken_args {

  fileprivate var channelId: String


  fileprivate init(channelId: String) {
    self.channelId = channelId
  }

}

fileprivate func ==(lhs: ChannelService_approveChannelAndIssueChannelToken_args, rhs: ChannelService_approveChannelAndIssueChannelToken_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId)
}

extension ChannelService_approveChannelAndIssueChannelToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    return result
  }

}

extension ChannelService_approveChannelAndIssueChannelToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_approveChannelAndIssueChannelToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_approveChannelAndIssueChannelToken_args {
    _ = try proto.readStructBegin()
    var channelId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")

    return ChannelService_approveChannelAndIssueChannelToken_args(channelId: channelId)
  }

}



fileprivate final class ChannelService_approveChannelAndIssueChannelToken_result {

  fileprivate var success: ChannelToken?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ChannelToken?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_approveChannelAndIssueChannelToken_result, rhs: ChannelService_approveChannelAndIssueChannelToken_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_approveChannelAndIssueChannelToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_approveChannelAndIssueChannelToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_approveChannelAndIssueChannelToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_approveChannelAndIssueChannelToken_result {
    _ = try proto.readStructBegin()
    var success: ChannelToken?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ChannelToken.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_approveChannelAndIssueChannelToken_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_approveChannelAndIssueRequestToken_args {

  fileprivate var channelId: String

  fileprivate var otpId: String


  fileprivate init(channelId: String, otpId: String) {
    self.channelId = channelId
    self.otpId = otpId
  }

}

fileprivate func ==(lhs: ChannelService_approveChannelAndIssueRequestToken_args, rhs: ChannelService_approveChannelAndIssueRequestToken_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.otpId == rhs.otpId)
}

extension ChannelService_approveChannelAndIssueRequestToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (otpId.hashValue)
    return result
  }

}

extension ChannelService_approveChannelAndIssueRequestToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 1, "otpId": 2, ]
  }

  fileprivate static var structName: String { return "ChannelService_approveChannelAndIssueRequestToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_approveChannelAndIssueRequestToken_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var otpId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (2, .string):           otpId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(otpId, named: "otpId")

    return ChannelService_approveChannelAndIssueRequestToken_args(channelId: channelId, otpId: otpId)
  }

}



fileprivate final class ChannelService_approveChannelAndIssueRequestToken_result {

  fileprivate var success: String?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: String?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_approveChannelAndIssueRequestToken_result, rhs: ChannelService_approveChannelAndIssueRequestToken_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_approveChannelAndIssueRequestToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_approveChannelAndIssueRequestToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_approveChannelAndIssueRequestToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_approveChannelAndIssueRequestToken_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_approveChannelAndIssueRequestToken_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_fetchNotificationItems_args {

  fileprivate var localRev: Int64


  fileprivate init(localRev: Int64) {
    self.localRev = localRev
  }

}

fileprivate func ==(lhs: ChannelService_fetchNotificationItems_args, rhs: ChannelService_fetchNotificationItems_args) -> Bool {
  return
    (lhs.localRev == rhs.localRev)
}

extension ChannelService_fetchNotificationItems_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (localRev.hashValue)
    return result
  }

}

extension ChannelService_fetchNotificationItems_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["localRev": 2, ]
  }

  fileprivate static var structName: String { return "ChannelService_fetchNotificationItems_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_fetchNotificationItems_args {
    _ = try proto.readStructBegin()
    var localRev: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             localRev = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(localRev, named: "localRev")

    return ChannelService_fetchNotificationItems_args(localRev: localRev)
  }

}



fileprivate final class ChannelService_fetchNotificationItems_result {

  fileprivate var success: NotificationFetchResult?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: NotificationFetchResult?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_fetchNotificationItems_result, rhs: ChannelService_fetchNotificationItems_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_fetchNotificationItems_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_fetchNotificationItems_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_fetchNotificationItems_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_fetchNotificationItems_result {
    _ = try proto.readStructBegin()
    var success: NotificationFetchResult?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NotificationFetchResult.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_fetchNotificationItems_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getApprovedChannels_args {

  fileprivate var lastSynced: Int64

  fileprivate var locale: String


  fileprivate init(lastSynced: Int64, locale: String) {
    self.lastSynced = lastSynced
    self.locale = locale
  }

}

fileprivate func ==(lhs: ChannelService_getApprovedChannels_args, rhs: ChannelService_getApprovedChannels_args) -> Bool {
  return
    (lhs.lastSynced == rhs.lastSynced) &&
    (lhs.locale == rhs.locale)
}

extension ChannelService_getApprovedChannels_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastSynced.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension ChannelService_getApprovedChannels_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastSynced": 2, "locale": 3, ]
  }

  fileprivate static var structName: String { return "ChannelService_getApprovedChannels_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getApprovedChannels_args {
    _ = try proto.readStructBegin()
    var lastSynced: Int64!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             lastSynced = try Int64.read(from: proto)
        case (3, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastSynced, named: "lastSynced")
    try proto.validateValue(locale, named: "locale")

    return ChannelService_getApprovedChannels_args(lastSynced: lastSynced, locale: locale)
  }

}



fileprivate final class ChannelService_getApprovedChannels_result {

  fileprivate var success: ApprovedChannelInfos?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ApprovedChannelInfos?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getApprovedChannels_result, rhs: ChannelService_getApprovedChannels_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getApprovedChannels_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getApprovedChannels_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getApprovedChannels_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getApprovedChannels_result {
    _ = try proto.readStructBegin()
    var success: ApprovedChannelInfos?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ApprovedChannelInfos.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getApprovedChannels_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getChannelInfo_args {

  fileprivate var channelId: String

  fileprivate var locale: String


  fileprivate init(channelId: String, locale: String) {
    self.channelId = channelId
    self.locale = locale
  }

}

fileprivate func ==(lhs: ChannelService_getChannelInfo_args, rhs: ChannelService_getChannelInfo_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.locale == rhs.locale)
}

extension ChannelService_getChannelInfo_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension ChannelService_getChannelInfo_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 2, "locale": 3, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannelInfo_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannelInfo_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           channelId = try String.read(from: proto)
        case (3, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(locale, named: "locale")

    return ChannelService_getChannelInfo_args(channelId: channelId, locale: locale)
  }

}



fileprivate final class ChannelService_getChannelInfo_result {

  fileprivate var success: ChannelInfo?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ChannelInfo?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getChannelInfo_result, rhs: ChannelService_getChannelInfo_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getChannelInfo_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getChannelInfo_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannelInfo_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannelInfo_result {
    _ = try proto.readStructBegin()
    var success: ChannelInfo?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ChannelInfo.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getChannelInfo_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getChannelNotificationSetting_args {

  fileprivate var channelId: String

  fileprivate var locale: String


  fileprivate init(channelId: String, locale: String) {
    self.channelId = channelId
    self.locale = locale
  }

}

fileprivate func ==(lhs: ChannelService_getChannelNotificationSetting_args, rhs: ChannelService_getChannelNotificationSetting_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.locale == rhs.locale)
}

extension ChannelService_getChannelNotificationSetting_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension ChannelService_getChannelNotificationSetting_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 1, "locale": 2, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannelNotificationSetting_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannelNotificationSetting_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (2, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(locale, named: "locale")

    return ChannelService_getChannelNotificationSetting_args(channelId: channelId, locale: locale)
  }

}



fileprivate final class ChannelService_getChannelNotificationSetting_result {

  fileprivate var success: ChannelNotificationSetting?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ChannelNotificationSetting?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getChannelNotificationSetting_result, rhs: ChannelService_getChannelNotificationSetting_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getChannelNotificationSetting_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getChannelNotificationSetting_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannelNotificationSetting_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannelNotificationSetting_result {
    _ = try proto.readStructBegin()
    var success: ChannelNotificationSetting?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ChannelNotificationSetting.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getChannelNotificationSetting_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getChannelNotificationSettings_args {

  fileprivate var locale: String


  fileprivate init(locale: String) {
    self.locale = locale
  }

}

fileprivate func ==(lhs: ChannelService_getChannelNotificationSettings_args, rhs: ChannelService_getChannelNotificationSettings_args) -> Bool {
  return
    (lhs.locale == rhs.locale)
}

extension ChannelService_getChannelNotificationSettings_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension ChannelService_getChannelNotificationSettings_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["locale": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannelNotificationSettings_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannelNotificationSettings_args {
    _ = try proto.readStructBegin()
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(locale, named: "locale")

    return ChannelService_getChannelNotificationSettings_args(locale: locale)
  }

}



fileprivate final class ChannelService_getChannelNotificationSettings_result {

  fileprivate var success: TList<ChannelNotificationSetting>?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: TList<ChannelNotificationSetting>?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getChannelNotificationSettings_result, rhs: ChannelService_getChannelNotificationSettings_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getChannelNotificationSettings_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getChannelNotificationSettings_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannelNotificationSettings_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannelNotificationSettings_result {
    _ = try proto.readStructBegin()
    var success: TList<ChannelNotificationSetting>?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<ChannelNotificationSetting>.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getChannelNotificationSettings_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getChannels_args {

  fileprivate var lastSynced: Int64

  fileprivate var locale: String


  fileprivate init(lastSynced: Int64, locale: String) {
    self.lastSynced = lastSynced
    self.locale = locale
  }

}

fileprivate func ==(lhs: ChannelService_getChannels_args, rhs: ChannelService_getChannels_args) -> Bool {
  return
    (lhs.lastSynced == rhs.lastSynced) &&
    (lhs.locale == rhs.locale)
}

extension ChannelService_getChannels_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastSynced.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension ChannelService_getChannels_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastSynced": 2, "locale": 3, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannels_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannels_args {
    _ = try proto.readStructBegin()
    var lastSynced: Int64!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             lastSynced = try Int64.read(from: proto)
        case (3, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastSynced, named: "lastSynced")
    try proto.validateValue(locale, named: "locale")

    return ChannelService_getChannels_args(lastSynced: lastSynced, locale: locale)
  }

}



fileprivate final class ChannelService_getChannels_result {

  fileprivate var success: ChannelInfos?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ChannelInfos?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getChannels_result, rhs: ChannelService_getChannels_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getChannels_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getChannels_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getChannels_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getChannels_result {
    _ = try proto.readStructBegin()
    var success: ChannelInfos?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ChannelInfos.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getChannels_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getDomains_args {

  fileprivate var lastSynced: Int64


  fileprivate init(lastSynced: Int64) {
    self.lastSynced = lastSynced
  }

}

fileprivate func ==(lhs: ChannelService_getDomains_args, rhs: ChannelService_getDomains_args) -> Bool {
  return
    (lhs.lastSynced == rhs.lastSynced)
}

extension ChannelService_getDomains_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastSynced.hashValue)
    return result
  }

}

extension ChannelService_getDomains_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastSynced": 2, ]
  }

  fileprivate static var structName: String { return "ChannelService_getDomains_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getDomains_args {
    _ = try proto.readStructBegin()
    var lastSynced: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             lastSynced = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastSynced, named: "lastSynced")

    return ChannelService_getDomains_args(lastSynced: lastSynced)
  }

}



fileprivate final class ChannelService_getDomains_result {

  fileprivate var success: ChannelDomains?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ChannelDomains?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getDomains_result, rhs: ChannelService_getDomains_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getDomains_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getDomains_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getDomains_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getDomains_result {
    _ = try proto.readStructBegin()
    var success: ChannelDomains?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ChannelDomains.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getDomains_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getFriendChannelMatrices_args {

  fileprivate var channelIds: TList<String>


  fileprivate init(channelIds: TList<String>) {
    self.channelIds = channelIds
  }

}

fileprivate func ==(lhs: ChannelService_getFriendChannelMatrices_args, rhs: ChannelService_getFriendChannelMatrices_args) -> Bool {
  return
    (lhs.channelIds == rhs.channelIds)
}

extension ChannelService_getFriendChannelMatrices_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelIds.hashValue)
    return result
  }

}

extension ChannelService_getFriendChannelMatrices_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelIds": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getFriendChannelMatrices_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getFriendChannelMatrices_args {
    _ = try proto.readStructBegin()
    var channelIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            channelIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelIds, named: "channelIds")

    return ChannelService_getFriendChannelMatrices_args(channelIds: channelIds)
  }

}



fileprivate final class ChannelService_getFriendChannelMatrices_result {

  fileprivate var success: FriendChannelMatricesResponse?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: FriendChannelMatricesResponse?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getFriendChannelMatrices_result, rhs: ChannelService_getFriendChannelMatrices_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getFriendChannelMatrices_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getFriendChannelMatrices_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getFriendChannelMatrices_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getFriendChannelMatrices_result {
    _ = try proto.readStructBegin()
    var success: FriendChannelMatricesResponse?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FriendChannelMatricesResponse.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getFriendChannelMatrices_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_getNotificationBadgeCount_args {

  fileprivate var localRev: Int64


  fileprivate init(localRev: Int64) {
    self.localRev = localRev
  }

}

fileprivate func ==(lhs: ChannelService_getNotificationBadgeCount_args, rhs: ChannelService_getNotificationBadgeCount_args) -> Bool {
  return
    (lhs.localRev == rhs.localRev)
}

extension ChannelService_getNotificationBadgeCount_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (localRev.hashValue)
    return result
  }

}

extension ChannelService_getNotificationBadgeCount_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["localRev": 2, ]
  }

  fileprivate static var structName: String { return "ChannelService_getNotificationBadgeCount_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getNotificationBadgeCount_args {
    _ = try proto.readStructBegin()
    var localRev: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             localRev = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(localRev, named: "localRev")

    return ChannelService_getNotificationBadgeCount_args(localRev: localRev)
  }

}



fileprivate final class ChannelService_getNotificationBadgeCount_result {

  fileprivate var success: Int32?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: Int32?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_getNotificationBadgeCount_result, rhs: ChannelService_getNotificationBadgeCount_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_getNotificationBadgeCount_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_getNotificationBadgeCount_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_getNotificationBadgeCount_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_getNotificationBadgeCount_result {
    _ = try proto.readStructBegin()
    var success: Int32?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_getNotificationBadgeCount_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_issueChannelToken_args {

  fileprivate var channelId: String


  fileprivate init(channelId: String) {
    self.channelId = channelId
  }

}

fileprivate func ==(lhs: ChannelService_issueChannelToken_args, rhs: ChannelService_issueChannelToken_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId)
}

extension ChannelService_issueChannelToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    return result
  }

}

extension ChannelService_issueChannelToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_issueChannelToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_issueChannelToken_args {
    _ = try proto.readStructBegin()
    var channelId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")

    return ChannelService_issueChannelToken_args(channelId: channelId)
  }

}



fileprivate final class ChannelService_issueChannelToken_result {

  fileprivate var success: ChannelToken?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ChannelToken?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_issueChannelToken_result, rhs: ChannelService_issueChannelToken_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_issueChannelToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_issueChannelToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_issueChannelToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_issueChannelToken_result {
    _ = try proto.readStructBegin()
    var success: ChannelToken?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ChannelToken.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_issueChannelToken_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_issueRequestToken_args {

  fileprivate var channelId: String

  fileprivate var otpId: String


  fileprivate init(channelId: String, otpId: String) {
    self.channelId = channelId
    self.otpId = otpId
  }

}

fileprivate func ==(lhs: ChannelService_issueRequestToken_args, rhs: ChannelService_issueRequestToken_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.otpId == rhs.otpId)
}

extension ChannelService_issueRequestToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (otpId.hashValue)
    return result
  }

}

extension ChannelService_issueRequestToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 1, "otpId": 2, ]
  }

  fileprivate static var structName: String { return "ChannelService_issueRequestToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_issueRequestToken_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var otpId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (2, .string):           otpId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(otpId, named: "otpId")

    return ChannelService_issueRequestToken_args(channelId: channelId, otpId: otpId)
  }

}



fileprivate final class ChannelService_issueRequestToken_result {

  fileprivate var success: String?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: String?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_issueRequestToken_result, rhs: ChannelService_issueRequestToken_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_issueRequestToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_issueRequestToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_issueRequestToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_issueRequestToken_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_issueRequestToken_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_issueRequestTokenWithAuthScheme_args {

  fileprivate var channelId: String

  fileprivate var otpId: String

  fileprivate var authScheme: TList<String>

  fileprivate var returnUrl: String


  fileprivate init(channelId: String, otpId: String, authScheme: TList<String>, returnUrl: String) {
    self.channelId = channelId
    self.otpId = otpId
    self.authScheme = authScheme
    self.returnUrl = returnUrl
  }

}

fileprivate func ==(lhs: ChannelService_issueRequestTokenWithAuthScheme_args, rhs: ChannelService_issueRequestTokenWithAuthScheme_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.otpId == rhs.otpId) &&
    (lhs.authScheme == rhs.authScheme) &&
    (lhs.returnUrl == rhs.returnUrl)
}

extension ChannelService_issueRequestTokenWithAuthScheme_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (otpId.hashValue)
    result = prime &* result &+ (authScheme.hashValue)
    result = prime &* result &+ (returnUrl.hashValue)
    return result
  }

}

extension ChannelService_issueRequestTokenWithAuthScheme_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 1, "otpId": 2, "authScheme": 3, "returnUrl": 4, ]
  }

  fileprivate static var structName: String { return "ChannelService_issueRequestTokenWithAuthScheme_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_issueRequestTokenWithAuthScheme_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var otpId: String!
    var authScheme: TList<String>!
    var returnUrl: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case (2, .string):           otpId = try String.read(from: proto)
        case (3, .list):            authScheme = try TList<String>.read(from: proto)
        case (4, .string):           returnUrl = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(otpId, named: "otpId")
    try proto.validateValue(authScheme, named: "authScheme")
    try proto.validateValue(returnUrl, named: "returnUrl")

    return ChannelService_issueRequestTokenWithAuthScheme_args(channelId: channelId, otpId: otpId, authScheme: authScheme, returnUrl: returnUrl)
  }

}



fileprivate final class ChannelService_issueRequestTokenWithAuthScheme_result {

  fileprivate var success: RequestTokenResponse?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: RequestTokenResponse?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_issueRequestTokenWithAuthScheme_result, rhs: ChannelService_issueRequestTokenWithAuthScheme_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_issueRequestTokenWithAuthScheme_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_issueRequestTokenWithAuthScheme_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_issueRequestTokenWithAuthScheme_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_issueRequestTokenWithAuthScheme_result {
    _ = try proto.readStructBegin()
    var success: RequestTokenResponse?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try RequestTokenResponse.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_issueRequestTokenWithAuthScheme_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_reserveCoinUse_args {

  fileprivate var request: CoinUseReservation

  fileprivate var locale: String


  fileprivate init(request: CoinUseReservation, locale: String) {
    self.request = request
    self.locale = locale
  }

}

fileprivate func ==(lhs: ChannelService_reserveCoinUse_args, rhs: ChannelService_reserveCoinUse_args) -> Bool {
  return
    (lhs.request == rhs.request) &&
    (lhs.locale == rhs.locale)
}

extension ChannelService_reserveCoinUse_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (request.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension ChannelService_reserveCoinUse_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["request": 2, "locale": 3, ]
  }

  fileprivate static var structName: String { return "ChannelService_reserveCoinUse_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_reserveCoinUse_args {
    _ = try proto.readStructBegin()
    var request: CoinUseReservation!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           request = try CoinUseReservation.read(from: proto)
        case (3, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(request, named: "request")
    try proto.validateValue(locale, named: "locale")

    return ChannelService_reserveCoinUse_args(request: request, locale: locale)
  }

}



fileprivate final class ChannelService_reserveCoinUse_result {

  fileprivate var success: String?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: String?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_reserveCoinUse_result, rhs: ChannelService_reserveCoinUse_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_reserveCoinUse_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_reserveCoinUse_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_reserveCoinUse_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_reserveCoinUse_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_reserveCoinUse_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_revokeChannel_args {

  fileprivate var channelId: String


  fileprivate init(channelId: String) {
    self.channelId = channelId
  }

}

fileprivate func ==(lhs: ChannelService_revokeChannel_args, rhs: ChannelService_revokeChannel_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId)
}

extension ChannelService_revokeChannel_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    return result
  }

}

extension ChannelService_revokeChannel_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_revokeChannel_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_revokeChannel_args {
    _ = try proto.readStructBegin()
    var channelId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           channelId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")

    return ChannelService_revokeChannel_args(channelId: channelId)
  }

}



fileprivate final class ChannelService_revokeChannel_result {

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(e: ChannelException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_revokeChannel_result, rhs: ChannelService_revokeChannel_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ChannelService_revokeChannel_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_revokeChannel_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_revokeChannel_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_revokeChannel_result {
    _ = try proto.readStructBegin()
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_revokeChannel_result(e: e)
  }

}



fileprivate final class ChannelService_syncChannelData_args {

  fileprivate var lastSynced: Int64

  fileprivate var locale: String


  fileprivate init(lastSynced: Int64, locale: String) {
    self.lastSynced = lastSynced
    self.locale = locale
  }

}

fileprivate func ==(lhs: ChannelService_syncChannelData_args, rhs: ChannelService_syncChannelData_args) -> Bool {
  return
    (lhs.lastSynced == rhs.lastSynced) &&
    (lhs.locale == rhs.locale)
}

extension ChannelService_syncChannelData_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastSynced.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension ChannelService_syncChannelData_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastSynced": 2, "locale": 3, ]
  }

  fileprivate static var structName: String { return "ChannelService_syncChannelData_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_syncChannelData_args {
    _ = try proto.readStructBegin()
    var lastSynced: Int64!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             lastSynced = try Int64.read(from: proto)
        case (3, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastSynced, named: "lastSynced")
    try proto.validateValue(locale, named: "locale")

    return ChannelService_syncChannelData_args(lastSynced: lastSynced, locale: locale)
  }

}



fileprivate final class ChannelService_syncChannelData_result {

  fileprivate var success: ChannelSyncDatas?

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(success: ChannelSyncDatas?, e: ChannelException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_syncChannelData_result, rhs: ChannelService_syncChannelData_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ChannelService_syncChannelData_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_syncChannelData_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_syncChannelData_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_syncChannelData_result {
    _ = try proto.readStructBegin()
    var success: ChannelSyncDatas?
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ChannelSyncDatas.read(from: proto)
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_syncChannelData_result(success: success, e: e)
  }

}



fileprivate final class ChannelService_updateChannelNotificationSetting_args {

  fileprivate var setting: TList<ChannelNotificationSetting>


  fileprivate init(setting: TList<ChannelNotificationSetting>) {
    self.setting = setting
  }

}

fileprivate func ==(lhs: ChannelService_updateChannelNotificationSetting_args, rhs: ChannelService_updateChannelNotificationSetting_args) -> Bool {
  return
    (lhs.setting == rhs.setting)
}

extension ChannelService_updateChannelNotificationSetting_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (setting.hashValue)
    return result
  }

}

extension ChannelService_updateChannelNotificationSetting_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["setting": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_updateChannelNotificationSetting_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_updateChannelNotificationSetting_args {
    _ = try proto.readStructBegin()
    var setting: TList<ChannelNotificationSetting>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            setting = try TList<ChannelNotificationSetting>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(setting, named: "setting")

    return ChannelService_updateChannelNotificationSetting_args(setting: setting)
  }

}



fileprivate final class ChannelService_updateChannelNotificationSetting_result {

  fileprivate var e: ChannelException?


  fileprivate init() { }
  fileprivate init(e: ChannelException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ChannelService_updateChannelNotificationSetting_result, rhs: ChannelService_updateChannelNotificationSetting_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ChannelService_updateChannelNotificationSetting_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ChannelService_updateChannelNotificationSetting_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ChannelService_updateChannelNotificationSetting_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ChannelService_updateChannelNotificationSetting_result {
    _ = try proto.readStructBegin()
    var e: ChannelException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try ChannelException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ChannelService_updateChannelNotificationSetting_result(e: e)
  }

}



extension ChannelServiceClient : ChannelService {

  private func send_approveChannelAndIssueChannelToken(channelId: String) throws {
    try outProtocol.writeMessageBegin(name: "approveChannelAndIssueChannelToken", type: .call, sequenceID: 0)
    let args = ChannelService_approveChannelAndIssueChannelToken_args(channelId: channelId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_approveChannelAndIssueChannelToken() throws -> ChannelToken {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_approveChannelAndIssueChannelToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "approveChannelAndIssueChannelToken"))
  }

  public func approveChannelAndIssueChannelToken(channelId: String) throws -> ChannelToken {
    try send_approveChannelAndIssueChannelToken(channelId: channelId)
    try outProtocol.transport.flush()
    return try recv_approveChannelAndIssueChannelToken()
  }

  private func send_approveChannelAndIssueRequestToken(channelId: String, otpId: String) throws {
    try outProtocol.writeMessageBegin(name: "approveChannelAndIssueRequestToken", type: .call, sequenceID: 0)
    let args = ChannelService_approveChannelAndIssueRequestToken_args(channelId: channelId, otpId: otpId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_approveChannelAndIssueRequestToken() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_approveChannelAndIssueRequestToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "approveChannelAndIssueRequestToken"))
  }

  public func approveChannelAndIssueRequestToken(channelId: String, otpId: String) throws -> String {
    try send_approveChannelAndIssueRequestToken(channelId: channelId, otpId: otpId)
    try outProtocol.transport.flush()
    return try recv_approveChannelAndIssueRequestToken()
  }

  private func send_fetchNotificationItems(localRev: Int64) throws {
    try outProtocol.writeMessageBegin(name: "fetchNotificationItems", type: .call, sequenceID: 0)
    let args = ChannelService_fetchNotificationItems_args(localRev: localRev)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_fetchNotificationItems() throws -> NotificationFetchResult {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_fetchNotificationItems_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "fetchNotificationItems"))
  }

  public func fetchNotificationItems(localRev: Int64) throws -> NotificationFetchResult {
    try send_fetchNotificationItems(localRev: localRev)
    try outProtocol.transport.flush()
    return try recv_fetchNotificationItems()
  }

  private func send_getApprovedChannels(lastSynced: Int64, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "getApprovedChannels", type: .call, sequenceID: 0)
    let args = ChannelService_getApprovedChannels_args(lastSynced: lastSynced, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getApprovedChannels() throws -> ApprovedChannelInfos {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getApprovedChannels_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getApprovedChannels"))
  }

  public func getApprovedChannels(lastSynced: Int64, locale: String) throws -> ApprovedChannelInfos {
    try send_getApprovedChannels(lastSynced: lastSynced, locale: locale)
    try outProtocol.transport.flush()
    return try recv_getApprovedChannels()
  }

  private func send_getChannelInfo(channelId: String, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "getChannelInfo", type: .call, sequenceID: 0)
    let args = ChannelService_getChannelInfo_args(channelId: channelId, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getChannelInfo() throws -> ChannelInfo {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getChannelInfo_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getChannelInfo"))
  }

  public func getChannelInfo(channelId: String, locale: String) throws -> ChannelInfo {
    try send_getChannelInfo(channelId: channelId, locale: locale)
    try outProtocol.transport.flush()
    return try recv_getChannelInfo()
  }

  private func send_getChannelNotificationSetting(channelId: String, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "getChannelNotificationSetting", type: .call, sequenceID: 0)
    let args = ChannelService_getChannelNotificationSetting_args(channelId: channelId, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getChannelNotificationSetting() throws -> ChannelNotificationSetting {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getChannelNotificationSetting_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getChannelNotificationSetting"))
  }

  public func getChannelNotificationSetting(channelId: String, locale: String) throws -> ChannelNotificationSetting {
    try send_getChannelNotificationSetting(channelId: channelId, locale: locale)
    try outProtocol.transport.flush()
    return try recv_getChannelNotificationSetting()
  }

  private func send_getChannelNotificationSettings(locale: String) throws {
    try outProtocol.writeMessageBegin(name: "getChannelNotificationSettings", type: .call, sequenceID: 0)
    let args = ChannelService_getChannelNotificationSettings_args(locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getChannelNotificationSettings() throws -> TList<ChannelNotificationSetting> {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getChannelNotificationSettings_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getChannelNotificationSettings"))
  }

  public func getChannelNotificationSettings(locale: String) throws -> TList<ChannelNotificationSetting> {
    try send_getChannelNotificationSettings(locale: locale)
    try outProtocol.transport.flush()
    return try recv_getChannelNotificationSettings()
  }

  private func send_getChannels(lastSynced: Int64, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "getChannels", type: .call, sequenceID: 0)
    let args = ChannelService_getChannels_args(lastSynced: lastSynced, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getChannels() throws -> ChannelInfos {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getChannels_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getChannels"))
  }

  public func getChannels(lastSynced: Int64, locale: String) throws -> ChannelInfos {
    try send_getChannels(lastSynced: lastSynced, locale: locale)
    try outProtocol.transport.flush()
    return try recv_getChannels()
  }

  private func send_getDomains(lastSynced: Int64) throws {
    try outProtocol.writeMessageBegin(name: "getDomains", type: .call, sequenceID: 0)
    let args = ChannelService_getDomains_args(lastSynced: lastSynced)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getDomains() throws -> ChannelDomains {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getDomains_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getDomains"))
  }

  public func getDomains(lastSynced: Int64) throws -> ChannelDomains {
    try send_getDomains(lastSynced: lastSynced)
    try outProtocol.transport.flush()
    return try recv_getDomains()
  }

  private func send_getFriendChannelMatrices(channelIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "getFriendChannelMatrices", type: .call, sequenceID: 0)
    let args = ChannelService_getFriendChannelMatrices_args(channelIds: channelIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getFriendChannelMatrices() throws -> FriendChannelMatricesResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getFriendChannelMatrices_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getFriendChannelMatrices"))
  }

  public func getFriendChannelMatrices(channelIds: TList<String>) throws -> FriendChannelMatricesResponse {
    try send_getFriendChannelMatrices(channelIds: channelIds)
    try outProtocol.transport.flush()
    return try recv_getFriendChannelMatrices()
  }

  private func send_getNotificationBadgeCount(localRev: Int64) throws {
    try outProtocol.writeMessageBegin(name: "getNotificationBadgeCount", type: .call, sequenceID: 0)
    let args = ChannelService_getNotificationBadgeCount_args(localRev: localRev)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getNotificationBadgeCount() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_getNotificationBadgeCount_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getNotificationBadgeCount"))
  }

  public func getNotificationBadgeCount(localRev: Int64) throws -> Int32 {
    try send_getNotificationBadgeCount(localRev: localRev)
    try outProtocol.transport.flush()
    return try recv_getNotificationBadgeCount()
  }

  private func send_issueChannelToken(channelId: String) throws {
    try outProtocol.writeMessageBegin(name: "issueChannelToken", type: .call, sequenceID: 0)
    let args = ChannelService_issueChannelToken_args(channelId: channelId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_issueChannelToken() throws -> ChannelToken {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_issueChannelToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "issueChannelToken"))
  }

  public func issueChannelToken(channelId: String) throws -> ChannelToken {
    try send_issueChannelToken(channelId: channelId)
    try outProtocol.transport.flush()
    return try recv_issueChannelToken()
  }

  private func send_issueRequestToken(channelId: String, otpId: String) throws {
    try outProtocol.writeMessageBegin(name: "issueRequestToken", type: .call, sequenceID: 0)
    let args = ChannelService_issueRequestToken_args(channelId: channelId, otpId: otpId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_issueRequestToken() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_issueRequestToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "issueRequestToken"))
  }

  public func issueRequestToken(channelId: String, otpId: String) throws -> String {
    try send_issueRequestToken(channelId: channelId, otpId: otpId)
    try outProtocol.transport.flush()
    return try recv_issueRequestToken()
  }

  private func send_issueRequestTokenWithAuthScheme(channelId: String, otpId: String, authScheme: TList<String>, returnUrl: String) throws {
    try outProtocol.writeMessageBegin(name: "issueRequestTokenWithAuthScheme", type: .call, sequenceID: 0)
    let args = ChannelService_issueRequestTokenWithAuthScheme_args(channelId: channelId, otpId: otpId, authScheme: authScheme, returnUrl: returnUrl)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_issueRequestTokenWithAuthScheme() throws -> RequestTokenResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_issueRequestTokenWithAuthScheme_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "issueRequestTokenWithAuthScheme"))
  }

  public func issueRequestTokenWithAuthScheme(channelId: String, otpId: String, authScheme: TList<String>, returnUrl: String) throws -> RequestTokenResponse {
    try send_issueRequestTokenWithAuthScheme(channelId: channelId, otpId: otpId, authScheme: authScheme, returnUrl: returnUrl)
    try outProtocol.transport.flush()
    return try recv_issueRequestTokenWithAuthScheme()
  }

  private func send_reserveCoinUse(request: CoinUseReservation, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "reserveCoinUse", type: .call, sequenceID: 0)
    let args = ChannelService_reserveCoinUse_args(request: request, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reserveCoinUse() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_reserveCoinUse_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "reserveCoinUse"))
  }

  public func reserveCoinUse(request: CoinUseReservation, locale: String) throws -> String {
    try send_reserveCoinUse(request: request, locale: locale)
    try outProtocol.transport.flush()
    return try recv_reserveCoinUse()
  }

  private func send_revokeChannel(channelId: String) throws {
    try outProtocol.writeMessageBegin(name: "revokeChannel", type: .call, sequenceID: 0)
    let args = ChannelService_revokeChannel_args(channelId: channelId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_revokeChannel() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_revokeChannel_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func revokeChannel(channelId: String) throws {
    try send_revokeChannel(channelId: channelId)
    try outProtocol.transport.flush()
    try recv_revokeChannel()
  }

  private func send_syncChannelData(lastSynced: Int64, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "syncChannelData", type: .call, sequenceID: 0)
    let args = ChannelService_syncChannelData_args(lastSynced: lastSynced, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_syncChannelData() throws -> ChannelSyncDatas {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_syncChannelData_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "syncChannelData"))
  }

  public func syncChannelData(lastSynced: Int64, locale: String) throws -> ChannelSyncDatas {
    try send_syncChannelData(lastSynced: lastSynced, locale: locale)
    try outProtocol.transport.flush()
    return try recv_syncChannelData()
  }

  private func send_updateChannelNotificationSetting(setting: TList<ChannelNotificationSetting>) throws {
    try outProtocol.writeMessageBegin(name: "updateChannelNotificationSetting", type: .call, sequenceID: 0)
    let args = ChannelService_updateChannelNotificationSetting_args(setting: setting)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateChannelNotificationSetting() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ChannelService_updateChannelNotificationSetting_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateChannelNotificationSetting(setting: TList<ChannelNotificationSetting>) throws {
    try send_updateChannelNotificationSetting(setting: setting)
    try outProtocol.transport.flush()
    try recv_updateChannelNotificationSetting()
  }

}

extension ChannelServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["approveChannelAndIssueChannelToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_approveChannelAndIssueChannelToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_approveChannelAndIssueChannelToken_result()
      do {
        result.success = try handler.approveChannelAndIssueChannelToken(channelId: args.channelId)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "approveChannelAndIssueChannelToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["approveChannelAndIssueRequestToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_approveChannelAndIssueRequestToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_approveChannelAndIssueRequestToken_result()
      do {
        result.success = try handler.approveChannelAndIssueRequestToken(channelId: args.channelId, otpId: args.otpId)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "approveChannelAndIssueRequestToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["fetchNotificationItems"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_fetchNotificationItems_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_fetchNotificationItems_result()
      do {
        result.success = try handler.fetchNotificationItems(localRev: args.localRev)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "fetchNotificationItems", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getApprovedChannels"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getApprovedChannels_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getApprovedChannels_result()
      do {
        result.success = try handler.getApprovedChannels(lastSynced: args.lastSynced, locale: args.locale)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getApprovedChannels", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getChannelInfo"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getChannelInfo_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getChannelInfo_result()
      do {
        result.success = try handler.getChannelInfo(channelId: args.channelId, locale: args.locale)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getChannelInfo", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getChannelNotificationSetting"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getChannelNotificationSetting_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getChannelNotificationSetting_result()
      do {
        result.success = try handler.getChannelNotificationSetting(channelId: args.channelId, locale: args.locale)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getChannelNotificationSetting", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getChannelNotificationSettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getChannelNotificationSettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getChannelNotificationSettings_result()
      do {
        result.success = try handler.getChannelNotificationSettings(locale: args.locale)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getChannelNotificationSettings", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getChannels"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getChannels_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getChannels_result()
      do {
        result.success = try handler.getChannels(lastSynced: args.lastSynced, locale: args.locale)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getChannels", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getDomains"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getDomains_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getDomains_result()
      do {
        result.success = try handler.getDomains(lastSynced: args.lastSynced)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getDomains", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getFriendChannelMatrices"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getFriendChannelMatrices_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getFriendChannelMatrices_result()
      do {
        result.success = try handler.getFriendChannelMatrices(channelIds: args.channelIds)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getFriendChannelMatrices", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getNotificationBadgeCount"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_getNotificationBadgeCount_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_getNotificationBadgeCount_result()
      do {
        result.success = try handler.getNotificationBadgeCount(localRev: args.localRev)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getNotificationBadgeCount", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["issueChannelToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_issueChannelToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_issueChannelToken_result()
      do {
        result.success = try handler.issueChannelToken(channelId: args.channelId)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "issueChannelToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["issueRequestToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_issueRequestToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_issueRequestToken_result()
      do {
        result.success = try handler.issueRequestToken(channelId: args.channelId, otpId: args.otpId)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "issueRequestToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["issueRequestTokenWithAuthScheme"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_issueRequestTokenWithAuthScheme_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_issueRequestTokenWithAuthScheme_result()
      do {
        result.success = try handler.issueRequestTokenWithAuthScheme(channelId: args.channelId, otpId: args.otpId, authScheme: args.authScheme, returnUrl: args.returnUrl)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "issueRequestTokenWithAuthScheme", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reserveCoinUse"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_reserveCoinUse_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_reserveCoinUse_result()
      do {
        result.success = try handler.reserveCoinUse(request: args.request, locale: args.locale)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reserveCoinUse", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["revokeChannel"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_revokeChannel_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_revokeChannel_result()
      do {
        try handler.revokeChannel(channelId: args.channelId)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "revokeChannel", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["syncChannelData"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_syncChannelData_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_syncChannelData_result()
      do {
        result.success = try handler.syncChannelData(lastSynced: args.lastSynced, locale: args.locale)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "syncChannelData", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateChannelNotificationSetting"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ChannelService_updateChannelNotificationSetting_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ChannelService_updateChannelNotificationSetting_result()
      do {
        try handler.updateChannelNotificationSetting(setting: args.setting)
      }
      catch let error as ChannelException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateChannelNotificationSetting", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = ChannelServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class MessageService_fetchMessageOperations_args {

  fileprivate var localRevision: Int64

  fileprivate var lastOpTimestamp: Int64

  fileprivate var count: Int32


  fileprivate init(localRevision: Int64, lastOpTimestamp: Int64, count: Int32) {
    self.localRevision = localRevision
    self.lastOpTimestamp = lastOpTimestamp
    self.count = count
  }

}

fileprivate func ==(lhs: MessageService_fetchMessageOperations_args, rhs: MessageService_fetchMessageOperations_args) -> Bool {
  return
    (lhs.localRevision == rhs.localRevision) &&
    (lhs.lastOpTimestamp == rhs.lastOpTimestamp) &&
    (lhs.count == rhs.count)
}

extension MessageService_fetchMessageOperations_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (localRevision.hashValue)
    result = prime &* result &+ (lastOpTimestamp.hashValue)
    result = prime &* result &+ (count.hashValue)
    return result
  }

}

extension MessageService_fetchMessageOperations_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["localRevision": 2, "lastOpTimestamp": 3, "count": 4, ]
  }

  fileprivate static var structName: String { return "MessageService_fetchMessageOperations_args" }

  fileprivate static func read(from proto: TProtocol) throws -> MessageService_fetchMessageOperations_args {
    _ = try proto.readStructBegin()
    var localRevision: Int64!
    var lastOpTimestamp: Int64!
    var count: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             localRevision = try Int64.read(from: proto)
        case (3, .i64):             lastOpTimestamp = try Int64.read(from: proto)
        case (4, .i32):             count = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(localRevision, named: "localRevision")
    try proto.validateValue(lastOpTimestamp, named: "lastOpTimestamp")
    try proto.validateValue(count, named: "count")

    return MessageService_fetchMessageOperations_args(localRevision: localRevision, lastOpTimestamp: lastOpTimestamp, count: count)
  }

}



fileprivate final class MessageService_fetchMessageOperations_result {

  fileprivate var success: MessageOperations?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: MessageOperations?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: MessageService_fetchMessageOperations_result, rhs: MessageService_fetchMessageOperations_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension MessageService_fetchMessageOperations_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension MessageService_fetchMessageOperations_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "MessageService_fetchMessageOperations_result" }

  fileprivate static func read(from proto: TProtocol) throws -> MessageService_fetchMessageOperations_result {
    _ = try proto.readStructBegin()
    var success: MessageOperations?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try MessageOperations.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return MessageService_fetchMessageOperations_result(success: success, e: e)
  }

}



fileprivate final class MessageService_getLastReadMessageIds_args {

  fileprivate var chatId: String


  fileprivate init(chatId: String) {
    self.chatId = chatId
  }

}

fileprivate func ==(lhs: MessageService_getLastReadMessageIds_args, rhs: MessageService_getLastReadMessageIds_args) -> Bool {
  return
    (lhs.chatId == rhs.chatId)
}

extension MessageService_getLastReadMessageIds_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (chatId.hashValue)
    return result
  }

}

extension MessageService_getLastReadMessageIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["chatId": 2, ]
  }

  fileprivate static var structName: String { return "MessageService_getLastReadMessageIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> MessageService_getLastReadMessageIds_args {
    _ = try proto.readStructBegin()
    var chatId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           chatId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(chatId, named: "chatId")

    return MessageService_getLastReadMessageIds_args(chatId: chatId)
  }

}



fileprivate final class MessageService_getLastReadMessageIds_result {

  fileprivate var success: LastReadMessageIds?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: LastReadMessageIds?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: MessageService_getLastReadMessageIds_result, rhs: MessageService_getLastReadMessageIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension MessageService_getLastReadMessageIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension MessageService_getLastReadMessageIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "MessageService_getLastReadMessageIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> MessageService_getLastReadMessageIds_result {
    _ = try proto.readStructBegin()
    var success: LastReadMessageIds?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LastReadMessageIds.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return MessageService_getLastReadMessageIds_result(success: success, e: e)
  }

}



fileprivate final class MessageService_multiGetLastReadMessageIds_args {

  fileprivate var chatIds: TList<String>


  fileprivate init(chatIds: TList<String>) {
    self.chatIds = chatIds
  }

}

fileprivate func ==(lhs: MessageService_multiGetLastReadMessageIds_args, rhs: MessageService_multiGetLastReadMessageIds_args) -> Bool {
  return
    (lhs.chatIds == rhs.chatIds)
}

extension MessageService_multiGetLastReadMessageIds_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (chatIds.hashValue)
    return result
  }

}

extension MessageService_multiGetLastReadMessageIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["chatIds": 2, ]
  }

  fileprivate static var structName: String { return "MessageService_multiGetLastReadMessageIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> MessageService_multiGetLastReadMessageIds_args {
    _ = try proto.readStructBegin()
    var chatIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .list):            chatIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(chatIds, named: "chatIds")

    return MessageService_multiGetLastReadMessageIds_args(chatIds: chatIds)
  }

}



fileprivate final class MessageService_multiGetLastReadMessageIds_result {

  fileprivate var success: TList<LastReadMessageIds>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<LastReadMessageIds>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: MessageService_multiGetLastReadMessageIds_result, rhs: MessageService_multiGetLastReadMessageIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension MessageService_multiGetLastReadMessageIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension MessageService_multiGetLastReadMessageIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "MessageService_multiGetLastReadMessageIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> MessageService_multiGetLastReadMessageIds_result {
    _ = try proto.readStructBegin()
    var success: TList<LastReadMessageIds>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<LastReadMessageIds>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return MessageService_multiGetLastReadMessageIds_result(success: success, e: e)
  }

}



extension MessageServiceClient : MessageService {

  private func send_fetchMessageOperations(localRevision: Int64, lastOpTimestamp: Int64, count: Int32) throws {
    try outProtocol.writeMessageBegin(name: "fetchMessageOperations", type: .call, sequenceID: 0)
    let args = MessageService_fetchMessageOperations_args(localRevision: localRevision, lastOpTimestamp: lastOpTimestamp, count: count)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_fetchMessageOperations() throws -> MessageOperations {
    try inProtocol.readResultMessageBegin() 
    let result = try MessageService_fetchMessageOperations_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "fetchMessageOperations"))
  }

  public func fetchMessageOperations(localRevision: Int64, lastOpTimestamp: Int64, count: Int32) throws -> MessageOperations {
    try send_fetchMessageOperations(localRevision: localRevision, lastOpTimestamp: lastOpTimestamp, count: count)
    try outProtocol.transport.flush()
    return try recv_fetchMessageOperations()
  }

  private func send_getLastReadMessageIds(chatId: String) throws {
    try outProtocol.writeMessageBegin(name: "getLastReadMessageIds", type: .call, sequenceID: 0)
    let args = MessageService_getLastReadMessageIds_args(chatId: chatId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getLastReadMessageIds() throws -> LastReadMessageIds {
    try inProtocol.readResultMessageBegin() 
    let result = try MessageService_getLastReadMessageIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getLastReadMessageIds"))
  }

  public func getLastReadMessageIds(chatId: String) throws -> LastReadMessageIds {
    try send_getLastReadMessageIds(chatId: chatId)
    try outProtocol.transport.flush()
    return try recv_getLastReadMessageIds()
  }

  private func send_multiGetLastReadMessageIds(chatIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "multiGetLastReadMessageIds", type: .call, sequenceID: 0)
    let args = MessageService_multiGetLastReadMessageIds_args(chatIds: chatIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_multiGetLastReadMessageIds() throws -> TList<LastReadMessageIds> {
    try inProtocol.readResultMessageBegin() 
    let result = try MessageService_multiGetLastReadMessageIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "multiGetLastReadMessageIds"))
  }

  public func multiGetLastReadMessageIds(chatIds: TList<String>) throws -> TList<LastReadMessageIds> {
    try send_multiGetLastReadMessageIds(chatIds: chatIds)
    try outProtocol.transport.flush()
    return try recv_multiGetLastReadMessageIds()
  }

}

extension MessageServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["fetchMessageOperations"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try MessageService_fetchMessageOperations_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = MessageService_fetchMessageOperations_result()
      do {
        result.success = try handler.fetchMessageOperations(localRevision: args.localRevision, lastOpTimestamp: args.lastOpTimestamp, count: args.count)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "fetchMessageOperations", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getLastReadMessageIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try MessageService_getLastReadMessageIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = MessageService_getLastReadMessageIds_result()
      do {
        result.success = try handler.getLastReadMessageIds(chatId: args.chatId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getLastReadMessageIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["multiGetLastReadMessageIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try MessageService_multiGetLastReadMessageIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = MessageService_multiGetLastReadMessageIds_result()
      do {
        result.success = try handler.multiGetLastReadMessageIds(chatIds: args.chatIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "multiGetLastReadMessageIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = MessageServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class ShopService_buyCoinProduct_args {

  fileprivate var paymentReservation: PaymentReservation


  fileprivate init(paymentReservation: PaymentReservation) {
    self.paymentReservation = paymentReservation
  }

}

fileprivate func ==(lhs: ShopService_buyCoinProduct_args, rhs: ShopService_buyCoinProduct_args) -> Bool {
  return
    (lhs.paymentReservation == rhs.paymentReservation)
}

extension ShopService_buyCoinProduct_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (paymentReservation.hashValue)
    return result
  }

}

extension ShopService_buyCoinProduct_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["paymentReservation": 2, ]
  }

  fileprivate static var structName: String { return "ShopService_buyCoinProduct_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_buyCoinProduct_args {
    _ = try proto.readStructBegin()
    var paymentReservation: PaymentReservation!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           paymentReservation = try PaymentReservation.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(paymentReservation, named: "paymentReservation")

    return ShopService_buyCoinProduct_args(paymentReservation: paymentReservation)
  }

}



fileprivate final class ShopService_buyCoinProduct_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_buyCoinProduct_result, rhs: ShopService_buyCoinProduct_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ShopService_buyCoinProduct_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_buyCoinProduct_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_buyCoinProduct_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_buyCoinProduct_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_buyCoinProduct_result(e: e)
  }

}



fileprivate final class ShopService_buyFreeProduct_args {

  fileprivate var receiverMid: String

  fileprivate var productId: String

  fileprivate var messageTemplate: Int32

  fileprivate var language: String

  fileprivate var country: String

  fileprivate var packageId: Int64


  fileprivate init(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64) {
    self.receiverMid = receiverMid
    self.productId = productId
    self.messageTemplate = messageTemplate
    self.language = language
    self.country = country
    self.packageId = packageId
  }

}

fileprivate func ==(lhs: ShopService_buyFreeProduct_args, rhs: ShopService_buyFreeProduct_args) -> Bool {
  return
    (lhs.receiverMid == rhs.receiverMid) &&
    (lhs.productId == rhs.productId) &&
    (lhs.messageTemplate == rhs.messageTemplate) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country) &&
    (lhs.packageId == rhs.packageId)
}

extension ShopService_buyFreeProduct_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (receiverMid.hashValue)
    result = prime &* result &+ (productId.hashValue)
    result = prime &* result &+ (messageTemplate.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (packageId.hashValue)
    return result
  }

}

extension ShopService_buyFreeProduct_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["receiverMid": 2, "productId": 3, "messageTemplate": 4, "language": 5, "country": 6, "packageId": 7, ]
  }

  fileprivate static var structName: String { return "ShopService_buyFreeProduct_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_buyFreeProduct_args {
    _ = try proto.readStructBegin()
    var receiverMid: String!
    var productId: String!
    var messageTemplate: Int32!
    var language: String!
    var country: String!
    var packageId: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           receiverMid = try String.read(from: proto)
        case (3, .string):           productId = try String.read(from: proto)
        case (4, .i32):             messageTemplate = try Int32.read(from: proto)
        case (5, .string):           language = try String.read(from: proto)
        case (6, .string):           country = try String.read(from: proto)
        case (7, .i64):             packageId = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(receiverMid, named: "receiverMid")
    try proto.validateValue(productId, named: "productId")
    try proto.validateValue(messageTemplate, named: "messageTemplate")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(packageId, named: "packageId")

    return ShopService_buyFreeProduct_args(receiverMid: receiverMid, productId: productId, messageTemplate: messageTemplate, language: language, country: country, packageId: packageId)
  }

}



fileprivate final class ShopService_buyFreeProduct_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_buyFreeProduct_result, rhs: ShopService_buyFreeProduct_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ShopService_buyFreeProduct_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_buyFreeProduct_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_buyFreeProduct_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_buyFreeProduct_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_buyFreeProduct_result(e: e)
  }

}



fileprivate final class ShopService_buyMustbuyProduct_args {

  fileprivate var receiverMid: String

  fileprivate var productId: String

  fileprivate var messageTemplate: Int32

  fileprivate var language: String

  fileprivate var country: String

  fileprivate var packageId: Int64

  fileprivate var serialNumber: String


  fileprivate init(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64, serialNumber: String) {
    self.receiverMid = receiverMid
    self.productId = productId
    self.messageTemplate = messageTemplate
    self.language = language
    self.country = country
    self.packageId = packageId
    self.serialNumber = serialNumber
  }

}

fileprivate func ==(lhs: ShopService_buyMustbuyProduct_args, rhs: ShopService_buyMustbuyProduct_args) -> Bool {
  return
    (lhs.receiverMid == rhs.receiverMid) &&
    (lhs.productId == rhs.productId) &&
    (lhs.messageTemplate == rhs.messageTemplate) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country) &&
    (lhs.packageId == rhs.packageId) &&
    (lhs.serialNumber == rhs.serialNumber)
}

extension ShopService_buyMustbuyProduct_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (receiverMid.hashValue)
    result = prime &* result &+ (productId.hashValue)
    result = prime &* result &+ (messageTemplate.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (packageId.hashValue)
    result = prime &* result &+ (serialNumber.hashValue)
    return result
  }

}

extension ShopService_buyMustbuyProduct_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["receiverMid": 2, "productId": 3, "messageTemplate": 4, "language": 5, "country": 6, "packageId": 7, "serialNumber": 8, ]
  }

  fileprivate static var structName: String { return "ShopService_buyMustbuyProduct_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_buyMustbuyProduct_args {
    _ = try proto.readStructBegin()
    var receiverMid: String!
    var productId: String!
    var messageTemplate: Int32!
    var language: String!
    var country: String!
    var packageId: Int64!
    var serialNumber: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           receiverMid = try String.read(from: proto)
        case (3, .string):           productId = try String.read(from: proto)
        case (4, .i32):             messageTemplate = try Int32.read(from: proto)
        case (5, .string):           language = try String.read(from: proto)
        case (6, .string):           country = try String.read(from: proto)
        case (7, .i64):             packageId = try Int64.read(from: proto)
        case (8, .string):           serialNumber = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(receiverMid, named: "receiverMid")
    try proto.validateValue(productId, named: "productId")
    try proto.validateValue(messageTemplate, named: "messageTemplate")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(packageId, named: "packageId")
    try proto.validateValue(serialNumber, named: "serialNumber")

    return ShopService_buyMustbuyProduct_args(receiverMid: receiverMid, productId: productId, messageTemplate: messageTemplate, language: language, country: country, packageId: packageId, serialNumber: serialNumber)
  }

}



fileprivate final class ShopService_buyMustbuyProduct_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_buyMustbuyProduct_result, rhs: ShopService_buyMustbuyProduct_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ShopService_buyMustbuyProduct_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_buyMustbuyProduct_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_buyMustbuyProduct_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_buyMustbuyProduct_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_buyMustbuyProduct_result(e: e)
  }

}



fileprivate final class ShopService_checkCanReceivePresent_args {

  fileprivate var recipientMid: String

  fileprivate var packageId: Int64

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(recipientMid: String, packageId: Int64, language: String, country: String) {
    self.recipientMid = recipientMid
    self.packageId = packageId
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_checkCanReceivePresent_args, rhs: ShopService_checkCanReceivePresent_args) -> Bool {
  return
    (lhs.recipientMid == rhs.recipientMid) &&
    (lhs.packageId == rhs.packageId) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_checkCanReceivePresent_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (recipientMid.hashValue)
    result = prime &* result &+ (packageId.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_checkCanReceivePresent_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["recipientMid": 2, "packageId": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_checkCanReceivePresent_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_checkCanReceivePresent_args {
    _ = try proto.readStructBegin()
    var recipientMid: String!
    var packageId: Int64!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           recipientMid = try String.read(from: proto)
        case (3, .i64):             packageId = try Int64.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(recipientMid, named: "recipientMid")
    try proto.validateValue(packageId, named: "packageId")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_checkCanReceivePresent_args(recipientMid: recipientMid, packageId: packageId, language: language, country: country)
  }

}



fileprivate final class ShopService_checkCanReceivePresent_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_checkCanReceivePresent_result, rhs: ShopService_checkCanReceivePresent_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension ShopService_checkCanReceivePresent_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_checkCanReceivePresent_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_checkCanReceivePresent_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_checkCanReceivePresent_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_checkCanReceivePresent_result(e: e)
  }

}



fileprivate final class ShopService_getActivePurchases_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getActivePurchases_args, rhs: ShopService_getActivePurchases_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getActivePurchases_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getActivePurchases_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getActivePurchases_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getActivePurchases_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getActivePurchases_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getActivePurchases_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getActivePurchases_result, rhs: ShopService_getActivePurchases_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getActivePurchases_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getActivePurchases_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getActivePurchases_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getActivePurchases_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getActivePurchases_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getActivePurchaseVersions_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getActivePurchaseVersions_args, rhs: ShopService_getActivePurchaseVersions_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getActivePurchaseVersions_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getActivePurchaseVersions_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getActivePurchaseVersions_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getActivePurchaseVersions_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getActivePurchaseVersions_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getActivePurchaseVersions_result {

  fileprivate var success: ProductSimpleList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductSimpleList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getActivePurchaseVersions_result, rhs: ShopService_getActivePurchaseVersions_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getActivePurchaseVersions_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getActivePurchaseVersions_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getActivePurchaseVersions_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getActivePurchaseVersions_result {
    _ = try proto.readStructBegin()
    var success: ProductSimpleList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductSimpleList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getActivePurchaseVersions_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getCoinProducts_args {

  fileprivate var appStoreCode: PaymentType

  fileprivate var country: String

  fileprivate var language: String


  fileprivate init(appStoreCode: PaymentType, country: String, language: String) {
    self.appStoreCode = appStoreCode
    self.country = country
    self.language = language
  }

}

fileprivate func ==(lhs: ShopService_getCoinProducts_args, rhs: ShopService_getCoinProducts_args) -> Bool {
  return
    (lhs.appStoreCode == rhs.appStoreCode) &&
    (lhs.country == rhs.country) &&
    (lhs.language == rhs.language)
}

extension ShopService_getCoinProducts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (appStoreCode.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (language.hashValue)
    return result
  }

}

extension ShopService_getCoinProducts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["appStoreCode": 2, "country": 3, "language": 4, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinProducts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinProducts_args {
    _ = try proto.readStructBegin()
    var appStoreCode: PaymentType!
    var country: String!
    var language: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case (3, .string):           country = try String.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(appStoreCode, named: "appStoreCode")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(language, named: "language")

    return ShopService_getCoinProducts_args(appStoreCode: appStoreCode, country: country, language: language)
  }

}



fileprivate final class ShopService_getCoinProducts_result {

  fileprivate var success: TList<CoinProductItem>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<CoinProductItem>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getCoinProducts_result, rhs: ShopService_getCoinProducts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getCoinProducts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getCoinProducts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinProducts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinProducts_result {
    _ = try proto.readStructBegin()
    var success: TList<CoinProductItem>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<CoinProductItem>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getCoinProducts_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getCoinProductsByPgCode_args {

  fileprivate var appStoreCode: PaymentType

  fileprivate var pgCode: PaymentPgType

  fileprivate var country: String

  fileprivate var language: String


  fileprivate init(appStoreCode: PaymentType, pgCode: PaymentPgType, country: String, language: String) {
    self.appStoreCode = appStoreCode
    self.pgCode = pgCode
    self.country = country
    self.language = language
  }

}

fileprivate func ==(lhs: ShopService_getCoinProductsByPgCode_args, rhs: ShopService_getCoinProductsByPgCode_args) -> Bool {
  return
    (lhs.appStoreCode == rhs.appStoreCode) &&
    (lhs.pgCode == rhs.pgCode) &&
    (lhs.country == rhs.country) &&
    (lhs.language == rhs.language)
}

extension ShopService_getCoinProductsByPgCode_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (appStoreCode.hashValue)
    result = prime &* result &+ (pgCode.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (language.hashValue)
    return result
  }

}

extension ShopService_getCoinProductsByPgCode_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["appStoreCode": 2, "pgCode": 3, "country": 4, "language": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinProductsByPgCode_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinProductsByPgCode_args {
    _ = try proto.readStructBegin()
    var appStoreCode: PaymentType!
    var pgCode: PaymentPgType!
    var country: String!
    var language: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case (3, .i32):             pgCode = try PaymentPgType.read(from: proto)
        case (4, .string):           country = try String.read(from: proto)
        case (5, .string):           language = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(appStoreCode, named: "appStoreCode")
    try proto.validateValue(pgCode, named: "pgCode")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(language, named: "language")

    return ShopService_getCoinProductsByPgCode_args(appStoreCode: appStoreCode, pgCode: pgCode, country: country, language: language)
  }

}



fileprivate final class ShopService_getCoinProductsByPgCode_result {

  fileprivate var success: TList<CoinProductItem>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<CoinProductItem>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getCoinProductsByPgCode_result, rhs: ShopService_getCoinProductsByPgCode_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getCoinProductsByPgCode_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getCoinProductsByPgCode_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinProductsByPgCode_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinProductsByPgCode_result {
    _ = try proto.readStructBegin()
    var success: TList<CoinProductItem>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<CoinProductItem>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getCoinProductsByPgCode_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getCoinPurchaseHistory_args {

  fileprivate var request: CoinHistoryCondition


  fileprivate init(request: CoinHistoryCondition) {
    self.request = request
  }

}

fileprivate func ==(lhs: ShopService_getCoinPurchaseHistory_args, rhs: ShopService_getCoinPurchaseHistory_args) -> Bool {
  return
    (lhs.request == rhs.request)
}

extension ShopService_getCoinPurchaseHistory_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (request.hashValue)
    return result
  }

}

extension ShopService_getCoinPurchaseHistory_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["request": 2, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinPurchaseHistory_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinPurchaseHistory_args {
    _ = try proto.readStructBegin()
    var request: CoinHistoryCondition!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           request = try CoinHistoryCondition.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(request, named: "request")

    return ShopService_getCoinPurchaseHistory_args(request: request)
  }

}



fileprivate final class ShopService_getCoinPurchaseHistory_result {

  fileprivate var success: CoinHistoryResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: CoinHistoryResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getCoinPurchaseHistory_result, rhs: ShopService_getCoinPurchaseHistory_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getCoinPurchaseHistory_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getCoinPurchaseHistory_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinPurchaseHistory_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinPurchaseHistory_result {
    _ = try proto.readStructBegin()
    var success: CoinHistoryResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try CoinHistoryResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getCoinPurchaseHistory_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getCoinUseAndRefundHistory_args {

  fileprivate var request: CoinHistoryCondition


  fileprivate init(request: CoinHistoryCondition) {
    self.request = request
  }

}

fileprivate func ==(lhs: ShopService_getCoinUseAndRefundHistory_args, rhs: ShopService_getCoinUseAndRefundHistory_args) -> Bool {
  return
    (lhs.request == rhs.request)
}

extension ShopService_getCoinUseAndRefundHistory_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (request.hashValue)
    return result
  }

}

extension ShopService_getCoinUseAndRefundHistory_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["request": 2, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinUseAndRefundHistory_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinUseAndRefundHistory_args {
    _ = try proto.readStructBegin()
    var request: CoinHistoryCondition!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           request = try CoinHistoryCondition.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(request, named: "request")

    return ShopService_getCoinUseAndRefundHistory_args(request: request)
  }

}



fileprivate final class ShopService_getCoinUseAndRefundHistory_result {

  fileprivate var success: CoinHistoryResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: CoinHistoryResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getCoinUseAndRefundHistory_result, rhs: ShopService_getCoinUseAndRefundHistory_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getCoinUseAndRefundHistory_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getCoinUseAndRefundHistory_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getCoinUseAndRefundHistory_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getCoinUseAndRefundHistory_result {
    _ = try proto.readStructBegin()
    var success: CoinHistoryResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try CoinHistoryResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getCoinUseAndRefundHistory_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getDownloads_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getDownloads_args, rhs: ShopService_getDownloads_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getDownloads_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getDownloads_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getDownloads_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getDownloads_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getDownloads_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getDownloads_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getDownloads_result, rhs: ShopService_getDownloads_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getDownloads_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getDownloads_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getDownloads_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getDownloads_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getDownloads_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getEventPackages_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getEventPackages_args, rhs: ShopService_getEventPackages_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getEventPackages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getEventPackages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getEventPackages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getEventPackages_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getEventPackages_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getEventPackages_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getEventPackages_result, rhs: ShopService_getEventPackages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getEventPackages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getEventPackages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getEventPackages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getEventPackages_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getEventPackages_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getNewlyReleasedPackages_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getNewlyReleasedPackages_args, rhs: ShopService_getNewlyReleasedPackages_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getNewlyReleasedPackages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getNewlyReleasedPackages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getNewlyReleasedPackages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getNewlyReleasedPackages_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getNewlyReleasedPackages_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getNewlyReleasedPackages_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getNewlyReleasedPackages_result, rhs: ShopService_getNewlyReleasedPackages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getNewlyReleasedPackages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getNewlyReleasedPackages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getNewlyReleasedPackages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getNewlyReleasedPackages_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getNewlyReleasedPackages_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getPopularPackages_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getPopularPackages_args, rhs: ShopService_getPopularPackages_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getPopularPackages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getPopularPackages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getPopularPackages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPopularPackages_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getPopularPackages_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getPopularPackages_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getPopularPackages_result, rhs: ShopService_getPopularPackages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getPopularPackages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getPopularPackages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getPopularPackages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPopularPackages_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getPopularPackages_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getPresentsReceived_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getPresentsReceived_args, rhs: ShopService_getPresentsReceived_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getPresentsReceived_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getPresentsReceived_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getPresentsReceived_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPresentsReceived_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getPresentsReceived_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getPresentsReceived_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getPresentsReceived_result, rhs: ShopService_getPresentsReceived_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getPresentsReceived_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getPresentsReceived_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getPresentsReceived_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPresentsReceived_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getPresentsReceived_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getPresentsSent_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getPresentsSent_args, rhs: ShopService_getPresentsSent_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getPresentsSent_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getPresentsSent_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getPresentsSent_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPresentsSent_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getPresentsSent_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getPresentsSent_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getPresentsSent_result, rhs: ShopService_getPresentsSent_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getPresentsSent_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getPresentsSent_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getPresentsSent_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPresentsSent_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getPresentsSent_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getProduct_args {

  fileprivate var packageID: Int64

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(packageID: Int64, language: String, country: String) {
    self.packageID = packageID
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getProduct_args, rhs: ShopService_getProduct_args) -> Bool {
  return
    (lhs.packageID == rhs.packageID) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getProduct_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (packageID.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getProduct_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["packageID": 2, "language": 3, "country": 4, ]
  }

  fileprivate static var structName: String { return "ShopService_getProduct_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProduct_args {
    _ = try proto.readStructBegin()
    var packageID: Int64!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             packageID = try Int64.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case (4, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(packageID, named: "packageID")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getProduct_args(packageID: packageID, language: language, country: country)
  }

}



fileprivate final class ShopService_getProduct_result {

  fileprivate var success: Product?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Product?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getProduct_result, rhs: ShopService_getProduct_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getProduct_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getProduct_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getProduct_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProduct_result {
    _ = try proto.readStructBegin()
    var success: Product?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Product.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getProduct_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getProductList_args {

  fileprivate var productIdList: TList<String>

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(productIdList: TList<String>, language: String, country: String) {
    self.productIdList = productIdList
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getProductList_args, rhs: ShopService_getProductList_args) -> Bool {
  return
    (lhs.productIdList == rhs.productIdList) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getProductList_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (productIdList.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getProductList_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["productIdList": 2, "language": 3, "country": 4, ]
  }

  fileprivate static var structName: String { return "ShopService_getProductList_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProductList_args {
    _ = try proto.readStructBegin()
    var productIdList: TList<String>!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .list):            productIdList = try TList<String>.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case (4, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(productIdList, named: "productIdList")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getProductList_args(productIdList: productIdList, language: language, country: country)
  }

}



fileprivate final class ShopService_getProductList_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getProductList_result, rhs: ShopService_getProductList_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getProductList_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getProductList_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getProductList_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProductList_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getProductList_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getProductListWithCarrier_args {

  fileprivate var productIdList: TList<String>

  fileprivate var language: String

  fileprivate var country: String

  fileprivate var carrierCode: String


  fileprivate init(productIdList: TList<String>, language: String, country: String, carrierCode: String) {
    self.productIdList = productIdList
    self.language = language
    self.country = country
    self.carrierCode = carrierCode
  }

}

fileprivate func ==(lhs: ShopService_getProductListWithCarrier_args, rhs: ShopService_getProductListWithCarrier_args) -> Bool {
  return
    (lhs.productIdList == rhs.productIdList) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country) &&
    (lhs.carrierCode == rhs.carrierCode)
}

extension ShopService_getProductListWithCarrier_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (productIdList.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (carrierCode.hashValue)
    return result
  }

}

extension ShopService_getProductListWithCarrier_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["productIdList": 2, "language": 3, "country": 4, "carrierCode": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getProductListWithCarrier_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProductListWithCarrier_args {
    _ = try proto.readStructBegin()
    var productIdList: TList<String>!
    var language: String!
    var country: String!
    var carrierCode: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .list):            productIdList = try TList<String>.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case (4, .string):           country = try String.read(from: proto)
        case (5, .string):           carrierCode = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(productIdList, named: "productIdList")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(carrierCode, named: "carrierCode")

    return ShopService_getProductListWithCarrier_args(productIdList: productIdList, language: language, country: country, carrierCode: carrierCode)
  }

}



fileprivate final class ShopService_getProductListWithCarrier_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getProductListWithCarrier_result, rhs: ShopService_getProductListWithCarrier_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getProductListWithCarrier_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getProductListWithCarrier_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getProductListWithCarrier_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProductListWithCarrier_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getProductListWithCarrier_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getProductWithCarrier_args {

  fileprivate var packageID: Int64

  fileprivate var language: String

  fileprivate var country: String

  fileprivate var carrierCode: String


  fileprivate init(packageID: Int64, language: String, country: String, carrierCode: String) {
    self.packageID = packageID
    self.language = language
    self.country = country
    self.carrierCode = carrierCode
  }

}

fileprivate func ==(lhs: ShopService_getProductWithCarrier_args, rhs: ShopService_getProductWithCarrier_args) -> Bool {
  return
    (lhs.packageID == rhs.packageID) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country) &&
    (lhs.carrierCode == rhs.carrierCode)
}

extension ShopService_getProductWithCarrier_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (packageID.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    result = prime &* result &+ (carrierCode.hashValue)
    return result
  }

}

extension ShopService_getProductWithCarrier_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["packageID": 2, "language": 3, "country": 4, "carrierCode": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getProductWithCarrier_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProductWithCarrier_args {
    _ = try proto.readStructBegin()
    var packageID: Int64!
    var language: String!
    var country: String!
    var carrierCode: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             packageID = try Int64.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case (4, .string):           country = try String.read(from: proto)
        case (5, .string):           carrierCode = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(packageID, named: "packageID")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")
    try proto.validateValue(carrierCode, named: "carrierCode")

    return ShopService_getProductWithCarrier_args(packageID: packageID, language: language, country: country, carrierCode: carrierCode)
  }

}



fileprivate final class ShopService_getProductWithCarrier_result {

  fileprivate var success: Product?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Product?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getProductWithCarrier_result, rhs: ShopService_getProductWithCarrier_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getProductWithCarrier_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getProductWithCarrier_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getProductWithCarrier_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getProductWithCarrier_result {
    _ = try proto.readStructBegin()
    var success: Product?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Product.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getProductWithCarrier_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getPurchaseHistory_args {

  fileprivate var start: Int64

  fileprivate var size: Int32

  fileprivate var language: String

  fileprivate var country: String


  fileprivate init(start: Int64, size: Int32, language: String, country: String) {
    self.start = start
    self.size = size
    self.language = language
    self.country = country
  }

}

fileprivate func ==(lhs: ShopService_getPurchaseHistory_args, rhs: ShopService_getPurchaseHistory_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.size == rhs.size) &&
    (lhs.language == rhs.language) &&
    (lhs.country == rhs.country)
}

extension ShopService_getPurchaseHistory_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (size.hashValue)
    result = prime &* result &+ (language.hashValue)
    result = prime &* result &+ (country.hashValue)
    return result
  }

}

extension ShopService_getPurchaseHistory_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "size": 3, "language": 4, "country": 5, ]
  }

  fileprivate static var structName: String { return "ShopService_getPurchaseHistory_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPurchaseHistory_args {
    _ = try proto.readStructBegin()
    var start: Int64!
    var size: Int32!
    var language: String!
    var country: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             start = try Int64.read(from: proto)
        case (3, .i32):             size = try Int32.read(from: proto)
        case (4, .string):           language = try String.read(from: proto)
        case (5, .string):           country = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(size, named: "size")
    try proto.validateValue(language, named: "language")
    try proto.validateValue(country, named: "country")

    return ShopService_getPurchaseHistory_args(start: start, size: size, language: language, country: country)
  }

}



fileprivate final class ShopService_getPurchaseHistory_result {

  fileprivate var success: ProductList?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProductList?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getPurchaseHistory_result, rhs: ShopService_getPurchaseHistory_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getPurchaseHistory_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getPurchaseHistory_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getPurchaseHistory_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getPurchaseHistory_result {
    _ = try proto.readStructBegin()
    var success: ProductList?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProductList.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getPurchaseHistory_result(success: success, e: e)
  }

}



fileprivate final class ShopService_getTotalBalance_args {

  fileprivate var appStoreCode: PaymentType


  fileprivate init(appStoreCode: PaymentType) {
    self.appStoreCode = appStoreCode
  }

}

fileprivate func ==(lhs: ShopService_getTotalBalance_args, rhs: ShopService_getTotalBalance_args) -> Bool {
  return
    (lhs.appStoreCode == rhs.appStoreCode)
}

extension ShopService_getTotalBalance_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (appStoreCode.hashValue)
    return result
  }

}

extension ShopService_getTotalBalance_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["appStoreCode": 2, ]
  }

  fileprivate static var structName: String { return "ShopService_getTotalBalance_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getTotalBalance_args {
    _ = try proto.readStructBegin()
    var appStoreCode: PaymentType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             appStoreCode = try PaymentType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(appStoreCode, named: "appStoreCode")

    return ShopService_getTotalBalance_args(appStoreCode: appStoreCode)
  }

}



fileprivate final class ShopService_getTotalBalance_result {

  fileprivate var success: Coin?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Coin?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_getTotalBalance_result, rhs: ShopService_getTotalBalance_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_getTotalBalance_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_getTotalBalance_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_getTotalBalance_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_getTotalBalance_result {
    _ = try proto.readStructBegin()
    var success: Coin?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Coin.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_getTotalBalance_result(success: success, e: e)
  }

}



fileprivate final class ShopService_notifyDownloaded_args {

  fileprivate var packageId: Int64

  fileprivate var language: String


  fileprivate init(packageId: Int64, language: String) {
    self.packageId = packageId
    self.language = language
  }

}

fileprivate func ==(lhs: ShopService_notifyDownloaded_args, rhs: ShopService_notifyDownloaded_args) -> Bool {
  return
    (lhs.packageId == rhs.packageId) &&
    (lhs.language == rhs.language)
}

extension ShopService_notifyDownloaded_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (packageId.hashValue)
    result = prime &* result &+ (language.hashValue)
    return result
  }

}

extension ShopService_notifyDownloaded_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["packageId": 2, "language": 3, ]
  }

  fileprivate static var structName: String { return "ShopService_notifyDownloaded_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_notifyDownloaded_args {
    _ = try proto.readStructBegin()
    var packageId: Int64!
    var language: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             packageId = try Int64.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(packageId, named: "packageId")
    try proto.validateValue(language, named: "language")

    return ShopService_notifyDownloaded_args(packageId: packageId, language: language)
  }

}



fileprivate final class ShopService_notifyDownloaded_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_notifyDownloaded_result, rhs: ShopService_notifyDownloaded_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_notifyDownloaded_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_notifyDownloaded_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_notifyDownloaded_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_notifyDownloaded_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_notifyDownloaded_result(success: success, e: e)
  }

}



fileprivate final class ShopService_reserveCoinPurchase_args {

  fileprivate var request: CoinPurchaseReservation


  fileprivate init(request: CoinPurchaseReservation) {
    self.request = request
  }

}

fileprivate func ==(lhs: ShopService_reserveCoinPurchase_args, rhs: ShopService_reserveCoinPurchase_args) -> Bool {
  return
    (lhs.request == rhs.request)
}

extension ShopService_reserveCoinPurchase_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (request.hashValue)
    return result
  }

}

extension ShopService_reserveCoinPurchase_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["request": 2, ]
  }

  fileprivate static var structName: String { return "ShopService_reserveCoinPurchase_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_reserveCoinPurchase_args {
    _ = try proto.readStructBegin()
    var request: CoinPurchaseReservation!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           request = try CoinPurchaseReservation.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(request, named: "request")

    return ShopService_reserveCoinPurchase_args(request: request)
  }

}



fileprivate final class ShopService_reserveCoinPurchase_result {

  fileprivate var success: PaymentReservationResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: PaymentReservationResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_reserveCoinPurchase_result, rhs: ShopService_reserveCoinPurchase_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_reserveCoinPurchase_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_reserveCoinPurchase_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_reserveCoinPurchase_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_reserveCoinPurchase_result {
    _ = try proto.readStructBegin()
    var success: PaymentReservationResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try PaymentReservationResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_reserveCoinPurchase_result(success: success, e: e)
  }

}



fileprivate final class ShopService_reservePayment_args {

  fileprivate var paymentReservation: PaymentReservation


  fileprivate init(paymentReservation: PaymentReservation) {
    self.paymentReservation = paymentReservation
  }

}

fileprivate func ==(lhs: ShopService_reservePayment_args, rhs: ShopService_reservePayment_args) -> Bool {
  return
    (lhs.paymentReservation == rhs.paymentReservation)
}

extension ShopService_reservePayment_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (paymentReservation.hashValue)
    return result
  }

}

extension ShopService_reservePayment_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["paymentReservation": 2, ]
  }

  fileprivate static var structName: String { return "ShopService_reservePayment_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_reservePayment_args {
    _ = try proto.readStructBegin()
    var paymentReservation: PaymentReservation!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           paymentReservation = try PaymentReservation.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(paymentReservation, named: "paymentReservation")

    return ShopService_reservePayment_args(paymentReservation: paymentReservation)
  }

}



fileprivate final class ShopService_reservePayment_result {

  fileprivate var success: PaymentReservationResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: PaymentReservationResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: ShopService_reservePayment_result, rhs: ShopService_reservePayment_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension ShopService_reservePayment_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension ShopService_reservePayment_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "ShopService_reservePayment_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ShopService_reservePayment_result {
    _ = try proto.readStructBegin()
    var success: PaymentReservationResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try PaymentReservationResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ShopService_reservePayment_result(success: success, e: e)
  }

}



extension ShopServiceClient : ShopService {

  private func send_buyCoinProduct(paymentReservation: PaymentReservation) throws {
    try outProtocol.writeMessageBegin(name: "buyCoinProduct", type: .call, sequenceID: 0)
    let args = ShopService_buyCoinProduct_args(paymentReservation: paymentReservation)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_buyCoinProduct() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_buyCoinProduct_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func buyCoinProduct(paymentReservation: PaymentReservation) throws {
    try send_buyCoinProduct(paymentReservation: paymentReservation)
    try outProtocol.transport.flush()
    try recv_buyCoinProduct()
  }

  private func send_buyFreeProduct(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64) throws {
    try outProtocol.writeMessageBegin(name: "buyFreeProduct", type: .call, sequenceID: 0)
    let args = ShopService_buyFreeProduct_args(receiverMid: receiverMid, productId: productId, messageTemplate: messageTemplate, language: language, country: country, packageId: packageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_buyFreeProduct() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_buyFreeProduct_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func buyFreeProduct(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64) throws {
    try send_buyFreeProduct(receiverMid: receiverMid, productId: productId, messageTemplate: messageTemplate, language: language, country: country, packageId: packageId)
    try outProtocol.transport.flush()
    try recv_buyFreeProduct()
  }

  private func send_buyMustbuyProduct(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64, serialNumber: String) throws {
    try outProtocol.writeMessageBegin(name: "buyMustbuyProduct", type: .call, sequenceID: 0)
    let args = ShopService_buyMustbuyProduct_args(receiverMid: receiverMid, productId: productId, messageTemplate: messageTemplate, language: language, country: country, packageId: packageId, serialNumber: serialNumber)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_buyMustbuyProduct() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_buyMustbuyProduct_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func buyMustbuyProduct(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64, serialNumber: String) throws {
    try send_buyMustbuyProduct(receiverMid: receiverMid, productId: productId, messageTemplate: messageTemplate, language: language, country: country, packageId: packageId, serialNumber: serialNumber)
    try outProtocol.transport.flush()
    try recv_buyMustbuyProduct()
  }

  private func send_checkCanReceivePresent(recipientMid: String, packageId: Int64, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "checkCanReceivePresent", type: .call, sequenceID: 0)
    let args = ShopService_checkCanReceivePresent_args(recipientMid: recipientMid, packageId: packageId, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_checkCanReceivePresent() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_checkCanReceivePresent_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func checkCanReceivePresent(recipientMid: String, packageId: Int64, language: String, country: String) throws {
    try send_checkCanReceivePresent(recipientMid: recipientMid, packageId: packageId, language: language, country: country)
    try outProtocol.transport.flush()
    try recv_checkCanReceivePresent()
  }

  private func send_getActivePurchases(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getActivePurchases", type: .call, sequenceID: 0)
    let args = ShopService_getActivePurchases_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getActivePurchases() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getActivePurchases_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getActivePurchases"))
  }

  public func getActivePurchases(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getActivePurchases(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getActivePurchases()
  }

  private func send_getActivePurchaseVersions(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getActivePurchaseVersions", type: .call, sequenceID: 0)
    let args = ShopService_getActivePurchaseVersions_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getActivePurchaseVersions() throws -> ProductSimpleList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getActivePurchaseVersions_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getActivePurchaseVersions"))
  }

  public func getActivePurchaseVersions(start: Int64, size: Int32, language: String, country: String) throws -> ProductSimpleList {
    try send_getActivePurchaseVersions(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getActivePurchaseVersions()
  }

  private func send_getCoinProducts(appStoreCode: PaymentType, country: String, language: String) throws {
    try outProtocol.writeMessageBegin(name: "getCoinProducts", type: .call, sequenceID: 0)
    let args = ShopService_getCoinProducts_args(appStoreCode: appStoreCode, country: country, language: language)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCoinProducts() throws -> TList<CoinProductItem> {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getCoinProducts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCoinProducts"))
  }

  public func getCoinProducts(appStoreCode: PaymentType, country: String, language: String) throws -> TList<CoinProductItem> {
    try send_getCoinProducts(appStoreCode: appStoreCode, country: country, language: language)
    try outProtocol.transport.flush()
    return try recv_getCoinProducts()
  }

  private func send_getCoinProductsByPgCode(appStoreCode: PaymentType, pgCode: PaymentPgType, country: String, language: String) throws {
    try outProtocol.writeMessageBegin(name: "getCoinProductsByPgCode", type: .call, sequenceID: 0)
    let args = ShopService_getCoinProductsByPgCode_args(appStoreCode: appStoreCode, pgCode: pgCode, country: country, language: language)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCoinProductsByPgCode() throws -> TList<CoinProductItem> {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getCoinProductsByPgCode_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCoinProductsByPgCode"))
  }

  public func getCoinProductsByPgCode(appStoreCode: PaymentType, pgCode: PaymentPgType, country: String, language: String) throws -> TList<CoinProductItem> {
    try send_getCoinProductsByPgCode(appStoreCode: appStoreCode, pgCode: pgCode, country: country, language: language)
    try outProtocol.transport.flush()
    return try recv_getCoinProductsByPgCode()
  }

  private func send_getCoinPurchaseHistory(request: CoinHistoryCondition) throws {
    try outProtocol.writeMessageBegin(name: "getCoinPurchaseHistory", type: .call, sequenceID: 0)
    let args = ShopService_getCoinPurchaseHistory_args(request: request)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCoinPurchaseHistory() throws -> CoinHistoryResult {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getCoinPurchaseHistory_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCoinPurchaseHistory"))
  }

  public func getCoinPurchaseHistory(request: CoinHistoryCondition) throws -> CoinHistoryResult {
    try send_getCoinPurchaseHistory(request: request)
    try outProtocol.transport.flush()
    return try recv_getCoinPurchaseHistory()
  }

  private func send_getCoinUseAndRefundHistory(request: CoinHistoryCondition) throws {
    try outProtocol.writeMessageBegin(name: "getCoinUseAndRefundHistory", type: .call, sequenceID: 0)
    let args = ShopService_getCoinUseAndRefundHistory_args(request: request)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCoinUseAndRefundHistory() throws -> CoinHistoryResult {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getCoinUseAndRefundHistory_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCoinUseAndRefundHistory"))
  }

  public func getCoinUseAndRefundHistory(request: CoinHistoryCondition) throws -> CoinHistoryResult {
    try send_getCoinUseAndRefundHistory(request: request)
    try outProtocol.transport.flush()
    return try recv_getCoinUseAndRefundHistory()
  }

  private func send_getDownloads(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getDownloads", type: .call, sequenceID: 0)
    let args = ShopService_getDownloads_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getDownloads() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getDownloads_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getDownloads"))
  }

  public func getDownloads(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getDownloads(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getDownloads()
  }

  private func send_getEventPackages(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getEventPackages", type: .call, sequenceID: 0)
    let args = ShopService_getEventPackages_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getEventPackages() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getEventPackages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getEventPackages"))
  }

  public func getEventPackages(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getEventPackages(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getEventPackages()
  }

  private func send_getNewlyReleasedPackages(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getNewlyReleasedPackages", type: .call, sequenceID: 0)
    let args = ShopService_getNewlyReleasedPackages_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getNewlyReleasedPackages() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getNewlyReleasedPackages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getNewlyReleasedPackages"))
  }

  public func getNewlyReleasedPackages(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getNewlyReleasedPackages(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getNewlyReleasedPackages()
  }

  private func send_getPopularPackages(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getPopularPackages", type: .call, sequenceID: 0)
    let args = ShopService_getPopularPackages_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPopularPackages() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getPopularPackages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPopularPackages"))
  }

  public func getPopularPackages(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getPopularPackages(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getPopularPackages()
  }

  private func send_getPresentsReceived(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getPresentsReceived", type: .call, sequenceID: 0)
    let args = ShopService_getPresentsReceived_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPresentsReceived() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getPresentsReceived_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPresentsReceived"))
  }

  public func getPresentsReceived(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getPresentsReceived(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getPresentsReceived()
  }

  private func send_getPresentsSent(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getPresentsSent", type: .call, sequenceID: 0)
    let args = ShopService_getPresentsSent_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPresentsSent() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getPresentsSent_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPresentsSent"))
  }

  public func getPresentsSent(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getPresentsSent(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getPresentsSent()
  }

  private func send_getProduct(packageID: Int64, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getProduct", type: .call, sequenceID: 0)
    let args = ShopService_getProduct_args(packageID: packageID, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProduct() throws -> Product {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getProduct_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProduct"))
  }

  public func getProduct(packageID: Int64, language: String, country: String) throws -> Product {
    try send_getProduct(packageID: packageID, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getProduct()
  }

  private func send_getProductList(productIdList: TList<String>, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getProductList", type: .call, sequenceID: 0)
    let args = ShopService_getProductList_args(productIdList: productIdList, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProductList() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getProductList_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProductList"))
  }

  public func getProductList(productIdList: TList<String>, language: String, country: String) throws -> ProductList {
    try send_getProductList(productIdList: productIdList, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getProductList()
  }

  private func send_getProductListWithCarrier(productIdList: TList<String>, language: String, country: String, carrierCode: String) throws {
    try outProtocol.writeMessageBegin(name: "getProductListWithCarrier", type: .call, sequenceID: 0)
    let args = ShopService_getProductListWithCarrier_args(productIdList: productIdList, language: language, country: country, carrierCode: carrierCode)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProductListWithCarrier() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getProductListWithCarrier_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProductListWithCarrier"))
  }

  public func getProductListWithCarrier(productIdList: TList<String>, language: String, country: String, carrierCode: String) throws -> ProductList {
    try send_getProductListWithCarrier(productIdList: productIdList, language: language, country: country, carrierCode: carrierCode)
    try outProtocol.transport.flush()
    return try recv_getProductListWithCarrier()
  }

  private func send_getProductWithCarrier(packageID: Int64, language: String, country: String, carrierCode: String) throws {
    try outProtocol.writeMessageBegin(name: "getProductWithCarrier", type: .call, sequenceID: 0)
    let args = ShopService_getProductWithCarrier_args(packageID: packageID, language: language, country: country, carrierCode: carrierCode)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProductWithCarrier() throws -> Product {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getProductWithCarrier_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProductWithCarrier"))
  }

  public func getProductWithCarrier(packageID: Int64, language: String, country: String, carrierCode: String) throws -> Product {
    try send_getProductWithCarrier(packageID: packageID, language: language, country: country, carrierCode: carrierCode)
    try outProtocol.transport.flush()
    return try recv_getProductWithCarrier()
  }

  private func send_getPurchaseHistory(start: Int64, size: Int32, language: String, country: String) throws {
    try outProtocol.writeMessageBegin(name: "getPurchaseHistory", type: .call, sequenceID: 0)
    let args = ShopService_getPurchaseHistory_args(start: start, size: size, language: language, country: country)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPurchaseHistory() throws -> ProductList {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getPurchaseHistory_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPurchaseHistory"))
  }

  public func getPurchaseHistory(start: Int64, size: Int32, language: String, country: String) throws -> ProductList {
    try send_getPurchaseHistory(start: start, size: size, language: language, country: country)
    try outProtocol.transport.flush()
    return try recv_getPurchaseHistory()
  }

  private func send_getTotalBalance(appStoreCode: PaymentType) throws {
    try outProtocol.writeMessageBegin(name: "getTotalBalance", type: .call, sequenceID: 0)
    let args = ShopService_getTotalBalance_args(appStoreCode: appStoreCode)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getTotalBalance() throws -> Coin {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_getTotalBalance_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getTotalBalance"))
  }

  public func getTotalBalance(appStoreCode: PaymentType) throws -> Coin {
    try send_getTotalBalance(appStoreCode: appStoreCode)
    try outProtocol.transport.flush()
    return try recv_getTotalBalance()
  }

  private func send_notifyDownloaded(packageId: Int64, language: String) throws {
    try outProtocol.writeMessageBegin(name: "notifyDownloaded", type: .call, sequenceID: 0)
    let args = ShopService_notifyDownloaded_args(packageId: packageId, language: language)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyDownloaded() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_notifyDownloaded_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "notifyDownloaded"))
  }

  public func notifyDownloaded(packageId: Int64, language: String) throws -> Int64 {
    try send_notifyDownloaded(packageId: packageId, language: language)
    try outProtocol.transport.flush()
    return try recv_notifyDownloaded()
  }

  private func send_reserveCoinPurchase(request: CoinPurchaseReservation) throws {
    try outProtocol.writeMessageBegin(name: "reserveCoinPurchase", type: .call, sequenceID: 0)
    let args = ShopService_reserveCoinPurchase_args(request: request)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reserveCoinPurchase() throws -> PaymentReservationResult {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_reserveCoinPurchase_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "reserveCoinPurchase"))
  }

  public func reserveCoinPurchase(request: CoinPurchaseReservation) throws -> PaymentReservationResult {
    try send_reserveCoinPurchase(request: request)
    try outProtocol.transport.flush()
    return try recv_reserveCoinPurchase()
  }

  private func send_reservePayment(paymentReservation: PaymentReservation) throws {
    try outProtocol.writeMessageBegin(name: "reservePayment", type: .call, sequenceID: 0)
    let args = ShopService_reservePayment_args(paymentReservation: paymentReservation)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reservePayment() throws -> PaymentReservationResult {
    try inProtocol.readResultMessageBegin() 
    let result = try ShopService_reservePayment_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "reservePayment"))
  }

  public func reservePayment(paymentReservation: PaymentReservation) throws -> PaymentReservationResult {
    try send_reservePayment(paymentReservation: paymentReservation)
    try outProtocol.transport.flush()
    return try recv_reservePayment()
  }

}

extension ShopServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["buyCoinProduct"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_buyCoinProduct_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_buyCoinProduct_result()
      do {
        try handler.buyCoinProduct(paymentReservation: args.paymentReservation)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "buyCoinProduct", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["buyFreeProduct"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_buyFreeProduct_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_buyFreeProduct_result()
      do {
        try handler.buyFreeProduct(receiverMid: args.receiverMid, productId: args.productId, messageTemplate: args.messageTemplate, language: args.language, country: args.country, packageId: args.packageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "buyFreeProduct", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["buyMustbuyProduct"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_buyMustbuyProduct_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_buyMustbuyProduct_result()
      do {
        try handler.buyMustbuyProduct(receiverMid: args.receiverMid, productId: args.productId, messageTemplate: args.messageTemplate, language: args.language, country: args.country, packageId: args.packageId, serialNumber: args.serialNumber)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "buyMustbuyProduct", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["checkCanReceivePresent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_checkCanReceivePresent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_checkCanReceivePresent_result()
      do {
        try handler.checkCanReceivePresent(recipientMid: args.recipientMid, packageId: args.packageId, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "checkCanReceivePresent", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getActivePurchases"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getActivePurchases_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getActivePurchases_result()
      do {
        result.success = try handler.getActivePurchases(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getActivePurchases", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getActivePurchaseVersions"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getActivePurchaseVersions_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getActivePurchaseVersions_result()
      do {
        result.success = try handler.getActivePurchaseVersions(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getActivePurchaseVersions", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCoinProducts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getCoinProducts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getCoinProducts_result()
      do {
        result.success = try handler.getCoinProducts(appStoreCode: args.appStoreCode, country: args.country, language: args.language)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCoinProducts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCoinProductsByPgCode"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getCoinProductsByPgCode_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getCoinProductsByPgCode_result()
      do {
        result.success = try handler.getCoinProductsByPgCode(appStoreCode: args.appStoreCode, pgCode: args.pgCode, country: args.country, language: args.language)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCoinProductsByPgCode", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCoinPurchaseHistory"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getCoinPurchaseHistory_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getCoinPurchaseHistory_result()
      do {
        result.success = try handler.getCoinPurchaseHistory(request: args.request)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCoinPurchaseHistory", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCoinUseAndRefundHistory"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getCoinUseAndRefundHistory_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getCoinUseAndRefundHistory_result()
      do {
        result.success = try handler.getCoinUseAndRefundHistory(request: args.request)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCoinUseAndRefundHistory", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getDownloads"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getDownloads_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getDownloads_result()
      do {
        result.success = try handler.getDownloads(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getDownloads", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getEventPackages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getEventPackages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getEventPackages_result()
      do {
        result.success = try handler.getEventPackages(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getEventPackages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getNewlyReleasedPackages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getNewlyReleasedPackages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getNewlyReleasedPackages_result()
      do {
        result.success = try handler.getNewlyReleasedPackages(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getNewlyReleasedPackages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPopularPackages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getPopularPackages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getPopularPackages_result()
      do {
        result.success = try handler.getPopularPackages(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPopularPackages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPresentsReceived"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getPresentsReceived_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getPresentsReceived_result()
      do {
        result.success = try handler.getPresentsReceived(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPresentsReceived", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPresentsSent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getPresentsSent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getPresentsSent_result()
      do {
        result.success = try handler.getPresentsSent(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPresentsSent", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProduct"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getProduct_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getProduct_result()
      do {
        result.success = try handler.getProduct(packageID: args.packageID, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProduct", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProductList"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getProductList_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getProductList_result()
      do {
        result.success = try handler.getProductList(productIdList: args.productIdList, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProductList", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProductListWithCarrier"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getProductListWithCarrier_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getProductListWithCarrier_result()
      do {
        result.success = try handler.getProductListWithCarrier(productIdList: args.productIdList, language: args.language, country: args.country, carrierCode: args.carrierCode)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProductListWithCarrier", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProductWithCarrier"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getProductWithCarrier_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getProductWithCarrier_result()
      do {
        result.success = try handler.getProductWithCarrier(packageID: args.packageID, language: args.language, country: args.country, carrierCode: args.carrierCode)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProductWithCarrier", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPurchaseHistory"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getPurchaseHistory_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getPurchaseHistory_result()
      do {
        result.success = try handler.getPurchaseHistory(start: args.start, size: args.size, language: args.language, country: args.country)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPurchaseHistory", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getTotalBalance"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_getTotalBalance_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_getTotalBalance_result()
      do {
        result.success = try handler.getTotalBalance(appStoreCode: args.appStoreCode)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getTotalBalance", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyDownloaded"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_notifyDownloaded_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_notifyDownloaded_result()
      do {
        result.success = try handler.notifyDownloaded(packageId: args.packageId, language: args.language)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyDownloaded", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reserveCoinPurchase"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_reserveCoinPurchase_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_reserveCoinPurchase_result()
      do {
        result.success = try handler.reserveCoinPurchase(request: args.request)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reserveCoinPurchase", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reservePayment"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ShopService_reservePayment_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ShopService_reservePayment_result()
      do {
        result.success = try handler.reservePayment(paymentReservation: args.paymentReservation)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reservePayment", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = ShopServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class SnsAdaptorService_getSnsFriends_args {

  fileprivate var snsIdType: SnsIdType

  fileprivate var snsAccessToken: String

  fileprivate var startIdx: Int32

  fileprivate var limit: Int32


  fileprivate init(snsIdType: SnsIdType, snsAccessToken: String, startIdx: Int32, limit: Int32) {
    self.snsIdType = snsIdType
    self.snsAccessToken = snsAccessToken
    self.startIdx = startIdx
    self.limit = limit
  }

}

fileprivate func ==(lhs: SnsAdaptorService_getSnsFriends_args, rhs: SnsAdaptorService_getSnsFriends_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsAccessToken == rhs.snsAccessToken) &&
    (lhs.startIdx == rhs.startIdx) &&
    (lhs.limit == rhs.limit)
}

extension SnsAdaptorService_getSnsFriends_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsAccessToken.hashValue)
    result = prime &* result &+ (startIdx.hashValue)
    result = prime &* result &+ (limit.hashValue)
    return result
  }

}

extension SnsAdaptorService_getSnsFriends_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, "snsAccessToken": 3, "startIdx": 4, "limit": 5, ]
  }

  fileprivate static var structName: String { return "SnsAdaptorService_getSnsFriends_args" }

  fileprivate static func read(from proto: TProtocol) throws -> SnsAdaptorService_getSnsFriends_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!
    var snsAccessToken: String!
    var startIdx: Int32!
    var limit: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsAccessToken = try String.read(from: proto)
        case (4, .i32):             startIdx = try Int32.read(from: proto)
        case (5, .i32):             limit = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsAccessToken, named: "snsAccessToken")
    try proto.validateValue(startIdx, named: "startIdx")
    try proto.validateValue(limit, named: "limit")

    return SnsAdaptorService_getSnsFriends_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, startIdx: startIdx, limit: limit)
  }

}



fileprivate final class SnsAdaptorService_getSnsFriends_result {

  fileprivate var success: SnsFriends?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SnsFriends?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: SnsAdaptorService_getSnsFriends_result, rhs: SnsAdaptorService_getSnsFriends_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension SnsAdaptorService_getSnsFriends_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension SnsAdaptorService_getSnsFriends_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "SnsAdaptorService_getSnsFriends_result" }

  fileprivate static func read(from proto: TProtocol) throws -> SnsAdaptorService_getSnsFriends_result {
    _ = try proto.readStructBegin()
    var success: SnsFriends?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SnsFriends.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return SnsAdaptorService_getSnsFriends_result(success: success, e: e)
  }

}



fileprivate final class SnsAdaptorService_getSnsMyProfile_args {

  fileprivate var snsIdType: SnsIdType

  fileprivate var snsAccessToken: String


  fileprivate init(snsIdType: SnsIdType, snsAccessToken: String) {
    self.snsIdType = snsIdType
    self.snsAccessToken = snsAccessToken
  }

}

fileprivate func ==(lhs: SnsAdaptorService_getSnsMyProfile_args, rhs: SnsAdaptorService_getSnsMyProfile_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsAccessToken == rhs.snsAccessToken)
}

extension SnsAdaptorService_getSnsMyProfile_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsAccessToken.hashValue)
    return result
  }

}

extension SnsAdaptorService_getSnsMyProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, "snsAccessToken": 3, ]
  }

  fileprivate static var structName: String { return "SnsAdaptorService_getSnsMyProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> SnsAdaptorService_getSnsMyProfile_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!
    var snsAccessToken: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsAccessToken = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsAccessToken, named: "snsAccessToken")

    return SnsAdaptorService_getSnsMyProfile_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken)
  }

}



fileprivate final class SnsAdaptorService_getSnsMyProfile_result {

  fileprivate var success: SnsProfile?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SnsProfile?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: SnsAdaptorService_getSnsMyProfile_result, rhs: SnsAdaptorService_getSnsMyProfile_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension SnsAdaptorService_getSnsMyProfile_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension SnsAdaptorService_getSnsMyProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "SnsAdaptorService_getSnsMyProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> SnsAdaptorService_getSnsMyProfile_result {
    _ = try proto.readStructBegin()
    var success: SnsProfile?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SnsProfile.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return SnsAdaptorService_getSnsMyProfile_result(success: success, e: e)
  }

}



fileprivate final class SnsAdaptorService_postSnsInvitationMessage_args {

  fileprivate var snsIdType: SnsIdType

  fileprivate var snsAccessToken: String

  fileprivate var toSnsUserId: String


  fileprivate init(snsIdType: SnsIdType, snsAccessToken: String, toSnsUserId: String) {
    self.snsIdType = snsIdType
    self.snsAccessToken = snsAccessToken
    self.toSnsUserId = toSnsUserId
  }

}

fileprivate func ==(lhs: SnsAdaptorService_postSnsInvitationMessage_args, rhs: SnsAdaptorService_postSnsInvitationMessage_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsAccessToken == rhs.snsAccessToken) &&
    (lhs.toSnsUserId == rhs.toSnsUserId)
}

extension SnsAdaptorService_postSnsInvitationMessage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsAccessToken.hashValue)
    result = prime &* result &+ (toSnsUserId.hashValue)
    return result
  }

}

extension SnsAdaptorService_postSnsInvitationMessage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, "snsAccessToken": 3, "toSnsUserId": 4, ]
  }

  fileprivate static var structName: String { return "SnsAdaptorService_postSnsInvitationMessage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> SnsAdaptorService_postSnsInvitationMessage_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!
    var snsAccessToken: String!
    var toSnsUserId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsAccessToken = try String.read(from: proto)
        case (4, .string):           toSnsUserId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsAccessToken, named: "snsAccessToken")
    try proto.validateValue(toSnsUserId, named: "toSnsUserId")

    return SnsAdaptorService_postSnsInvitationMessage_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, toSnsUserId: toSnsUserId)
  }

}



fileprivate final class SnsAdaptorService_postSnsInvitationMessage_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: SnsAdaptorService_postSnsInvitationMessage_result, rhs: SnsAdaptorService_postSnsInvitationMessage_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension SnsAdaptorService_postSnsInvitationMessage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension SnsAdaptorService_postSnsInvitationMessage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "SnsAdaptorService_postSnsInvitationMessage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> SnsAdaptorService_postSnsInvitationMessage_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return SnsAdaptorService_postSnsInvitationMessage_result(e: e)
  }

}



extension SnsAdaptorServiceClient : SnsAdaptorService {

  private func send_getSnsFriends(snsIdType: SnsIdType, snsAccessToken: String, startIdx: Int32, limit: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getSnsFriends", type: .call, sequenceID: 0)
    let args = SnsAdaptorService_getSnsFriends_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, startIdx: startIdx, limit: limit)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSnsFriends() throws -> SnsFriends {
    try inProtocol.readResultMessageBegin() 
    let result = try SnsAdaptorService_getSnsFriends_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSnsFriends"))
  }

  public func getSnsFriends(snsIdType: SnsIdType, snsAccessToken: String, startIdx: Int32, limit: Int32) throws -> SnsFriends {
    try send_getSnsFriends(snsIdType: snsIdType, snsAccessToken: snsAccessToken, startIdx: startIdx, limit: limit)
    try outProtocol.transport.flush()
    return try recv_getSnsFriends()
  }

  private func send_getSnsMyProfile(snsIdType: SnsIdType, snsAccessToken: String) throws {
    try outProtocol.writeMessageBegin(name: "getSnsMyProfile", type: .call, sequenceID: 0)
    let args = SnsAdaptorService_getSnsMyProfile_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSnsMyProfile() throws -> SnsProfile {
    try inProtocol.readResultMessageBegin() 
    let result = try SnsAdaptorService_getSnsMyProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSnsMyProfile"))
  }

  public func getSnsMyProfile(snsIdType: SnsIdType, snsAccessToken: String) throws -> SnsProfile {
    try send_getSnsMyProfile(snsIdType: snsIdType, snsAccessToken: snsAccessToken)
    try outProtocol.transport.flush()
    return try recv_getSnsMyProfile()
  }

  private func send_postSnsInvitationMessage(snsIdType: SnsIdType, snsAccessToken: String, toSnsUserId: String) throws {
    try outProtocol.writeMessageBegin(name: "postSnsInvitationMessage", type: .call, sequenceID: 0)
    let args = SnsAdaptorService_postSnsInvitationMessage_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, toSnsUserId: toSnsUserId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_postSnsInvitationMessage() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try SnsAdaptorService_postSnsInvitationMessage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func postSnsInvitationMessage(snsIdType: SnsIdType, snsAccessToken: String, toSnsUserId: String) throws {
    try send_postSnsInvitationMessage(snsIdType: snsIdType, snsAccessToken: snsAccessToken, toSnsUserId: toSnsUserId)
    try outProtocol.transport.flush()
    try recv_postSnsInvitationMessage()
  }

}

extension SnsAdaptorServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["getSnsFriends"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try SnsAdaptorService_getSnsFriends_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = SnsAdaptorService_getSnsFriends_result()
      do {
        result.success = try handler.getSnsFriends(snsIdType: args.snsIdType, snsAccessToken: args.snsAccessToken, startIdx: args.startIdx, limit: args.limit)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSnsFriends", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSnsMyProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try SnsAdaptorService_getSnsMyProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = SnsAdaptorService_getSnsMyProfile_result()
      do {
        result.success = try handler.getSnsMyProfile(snsIdType: args.snsIdType, snsAccessToken: args.snsAccessToken)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSnsMyProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["postSnsInvitationMessage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try SnsAdaptorService_postSnsInvitationMessage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = SnsAdaptorService_postSnsInvitationMessage_result()
      do {
        try handler.postSnsInvitationMessage(snsIdType: args.snsIdType, snsAccessToken: args.snsAccessToken, toSnsUserId: args.toSnsUserId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "postSnsInvitationMessage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = SnsAdaptorServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class TalkService_acceptGroupInvitation_args {

  fileprivate var reqSeq: Int32

  fileprivate var groupId: String


  fileprivate init(reqSeq: Int32, groupId: String) {
    self.reqSeq = reqSeq
    self.groupId = groupId
  }

}

fileprivate func ==(lhs: TalkService_acceptGroupInvitation_args, rhs: TalkService_acceptGroupInvitation_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.groupId == rhs.groupId)
}

extension TalkService_acceptGroupInvitation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (groupId.hashValue)
    return result
  }

}

extension TalkService_acceptGroupInvitation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "groupId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_acceptGroupInvitation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acceptGroupInvitation_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var groupId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           groupId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(groupId, named: "groupId")

    return TalkService_acceptGroupInvitation_args(reqSeq: reqSeq, groupId: groupId)
  }

}



fileprivate final class TalkService_acceptGroupInvitation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_acceptGroupInvitation_result, rhs: TalkService_acceptGroupInvitation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_acceptGroupInvitation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_acceptGroupInvitation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_acceptGroupInvitation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acceptGroupInvitation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_acceptGroupInvitation_result(e: e)
  }

}



fileprivate final class TalkService_acceptProximityMatches_args {

  fileprivate var sessionId: String

  fileprivate var ids: TSet<String>


  fileprivate init(sessionId: String, ids: TSet<String>) {
    self.sessionId = sessionId
    self.ids = ids
  }

}

fileprivate func ==(lhs: TalkService_acceptProximityMatches_args, rhs: TalkService_acceptProximityMatches_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId) &&
    (lhs.ids == rhs.ids)
}

extension TalkService_acceptProximityMatches_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    result = prime &* result &+ (ids.hashValue)
    return result
  }

}

extension TalkService_acceptProximityMatches_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, "ids": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_acceptProximityMatches_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acceptProximityMatches_args {
    _ = try proto.readStructBegin()
    var sessionId: String!
    var ids: TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case (3, .set):             ids = try TSet<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")
    try proto.validateValue(ids, named: "ids")

    return TalkService_acceptProximityMatches_args(sessionId: sessionId, ids: ids)
  }

}



fileprivate final class TalkService_acceptProximityMatches_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_acceptProximityMatches_result, rhs: TalkService_acceptProximityMatches_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_acceptProximityMatches_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_acceptProximityMatches_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_acceptProximityMatches_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acceptProximityMatches_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_acceptProximityMatches_result(e: e)
  }

}



fileprivate final class TalkService_acquireCallRoute_args {

  fileprivate var to: String


  fileprivate init(to: String) {
    self.to = to
  }

}

fileprivate func ==(lhs: TalkService_acquireCallRoute_args, rhs: TalkService_acquireCallRoute_args) -> Bool {
  return
    (lhs.to == rhs.to)
}

extension TalkService_acquireCallRoute_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (to.hashValue)
    return result
  }

}

extension TalkService_acquireCallRoute_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["to": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_acquireCallRoute_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acquireCallRoute_args {
    _ = try proto.readStructBegin()
    var to: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           to = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(to, named: "to")

    return TalkService_acquireCallRoute_args(to: to)
  }

}



fileprivate final class TalkService_acquireCallRoute_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_acquireCallRoute_result, rhs: TalkService_acquireCallRoute_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_acquireCallRoute_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_acquireCallRoute_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_acquireCallRoute_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acquireCallRoute_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_acquireCallRoute_result(success: success, e: e)
  }

}



fileprivate final class TalkService_acquireCallTicket_args {

  fileprivate var to: String


  fileprivate init(to: String) {
    self.to = to
  }

}

fileprivate func ==(lhs: TalkService_acquireCallTicket_args, rhs: TalkService_acquireCallTicket_args) -> Bool {
  return
    (lhs.to == rhs.to)
}

extension TalkService_acquireCallTicket_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (to.hashValue)
    return result
  }

}

extension TalkService_acquireCallTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["to": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_acquireCallTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acquireCallTicket_args {
    _ = try proto.readStructBegin()
    var to: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           to = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(to, named: "to")

    return TalkService_acquireCallTicket_args(to: to)
  }

}



fileprivate final class TalkService_acquireCallTicket_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_acquireCallTicket_result, rhs: TalkService_acquireCallTicket_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_acquireCallTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_acquireCallTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_acquireCallTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acquireCallTicket_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_acquireCallTicket_result(success: success, e: e)
  }

}



fileprivate final class TalkService_acquireEncryptedAccessToken_args {

  fileprivate var featureType: FeatureType


  fileprivate init(featureType: FeatureType) {
    self.featureType = featureType
  }

}

fileprivate func ==(lhs: TalkService_acquireEncryptedAccessToken_args, rhs: TalkService_acquireEncryptedAccessToken_args) -> Bool {
  return
    (lhs.featureType == rhs.featureType)
}

extension TalkService_acquireEncryptedAccessToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (featureType.hashValue)
    return result
  }

}

extension TalkService_acquireEncryptedAccessToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["featureType": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_acquireEncryptedAccessToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acquireEncryptedAccessToken_args {
    _ = try proto.readStructBegin()
    var featureType: FeatureType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             featureType = try FeatureType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(featureType, named: "featureType")

    return TalkService_acquireEncryptedAccessToken_args(featureType: featureType)
  }

}



fileprivate final class TalkService_acquireEncryptedAccessToken_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_acquireEncryptedAccessToken_result, rhs: TalkService_acquireEncryptedAccessToken_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_acquireEncryptedAccessToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_acquireEncryptedAccessToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_acquireEncryptedAccessToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_acquireEncryptedAccessToken_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_acquireEncryptedAccessToken_result(success: success, e: e)
  }

}



fileprivate final class TalkService_addSnsId_args {

  fileprivate var snsIdType: SnsIdType

  fileprivate var snsAccessToken: String


  fileprivate init(snsIdType: SnsIdType, snsAccessToken: String) {
    self.snsIdType = snsIdType
    self.snsAccessToken = snsAccessToken
  }

}

fileprivate func ==(lhs: TalkService_addSnsId_args, rhs: TalkService_addSnsId_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsAccessToken == rhs.snsAccessToken)
}

extension TalkService_addSnsId_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsAccessToken.hashValue)
    return result
  }

}

extension TalkService_addSnsId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, "snsAccessToken": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_addSnsId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_addSnsId_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!
    var snsAccessToken: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsAccessToken = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsAccessToken, named: "snsAccessToken")

    return TalkService_addSnsId_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken)
  }

}



fileprivate final class TalkService_addSnsId_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_addSnsId_result, rhs: TalkService_addSnsId_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_addSnsId_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_addSnsId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_addSnsId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_addSnsId_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_addSnsId_result(success: success, e: e)
  }

}



fileprivate final class TalkService_blockContact_args {

  fileprivate var reqSeq: Int32

  fileprivate var id: String


  fileprivate init(reqSeq: Int32, id: String) {
    self.reqSeq = reqSeq
    self.id = id
  }

}

fileprivate func ==(lhs: TalkService_blockContact_args, rhs: TalkService_blockContact_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.id == rhs.id)
}

extension TalkService_blockContact_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (id.hashValue)
    return result
  }

}

extension TalkService_blockContact_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "id": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_blockContact_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_blockContact_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var id: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           id = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(id, named: "id")

    return TalkService_blockContact_args(reqSeq: reqSeq, id: id)
  }

}



fileprivate final class TalkService_blockContact_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_blockContact_result, rhs: TalkService_blockContact_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_blockContact_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_blockContact_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_blockContact_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_blockContact_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_blockContact_result(e: e)
  }

}



fileprivate final class TalkService_blockRecommendation_args {

  fileprivate var reqSeq: Int32

  fileprivate var id: String


  fileprivate init(reqSeq: Int32, id: String) {
    self.reqSeq = reqSeq
    self.id = id
  }

}

fileprivate func ==(lhs: TalkService_blockRecommendation_args, rhs: TalkService_blockRecommendation_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.id == rhs.id)
}

extension TalkService_blockRecommendation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (id.hashValue)
    return result
  }

}

extension TalkService_blockRecommendation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "id": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_blockRecommendation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_blockRecommendation_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var id: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           id = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(id, named: "id")

    return TalkService_blockRecommendation_args(reqSeq: reqSeq, id: id)
  }

}



fileprivate final class TalkService_blockRecommendation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_blockRecommendation_result, rhs: TalkService_blockRecommendation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_blockRecommendation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_blockRecommendation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_blockRecommendation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_blockRecommendation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_blockRecommendation_result(e: e)
  }

}



fileprivate final class TalkService_cancelGroupInvitation_args {

  fileprivate var reqSeq: Int32

  fileprivate var groupId: String

  fileprivate var contactIds: TList<String>


  fileprivate init(reqSeq: Int32, groupId: String, contactIds: TList<String>) {
    self.reqSeq = reqSeq
    self.groupId = groupId
    self.contactIds = contactIds
  }

}

fileprivate func ==(lhs: TalkService_cancelGroupInvitation_args, rhs: TalkService_cancelGroupInvitation_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.groupId == rhs.groupId) &&
    (lhs.contactIds == rhs.contactIds)
}

extension TalkService_cancelGroupInvitation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (groupId.hashValue)
    result = prime &* result &+ (contactIds.hashValue)
    return result
  }

}

extension TalkService_cancelGroupInvitation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "groupId": 2, "contactIds": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_cancelGroupInvitation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_cancelGroupInvitation_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var groupId: String!
    var contactIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           groupId = try String.read(from: proto)
        case (3, .list):            contactIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(groupId, named: "groupId")
    try proto.validateValue(contactIds, named: "contactIds")

    return TalkService_cancelGroupInvitation_args(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
  }

}



fileprivate final class TalkService_cancelGroupInvitation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_cancelGroupInvitation_result, rhs: TalkService_cancelGroupInvitation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_cancelGroupInvitation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_cancelGroupInvitation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_cancelGroupInvitation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_cancelGroupInvitation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_cancelGroupInvitation_result(e: e)
  }

}



fileprivate final class TalkService_changeVerificationMethod_args {

  fileprivate var sessionId: String

  fileprivate var method: VerificationMethod


  fileprivate init(sessionId: String, method: VerificationMethod) {
    self.sessionId = sessionId
    self.method = method
  }

}

fileprivate func ==(lhs: TalkService_changeVerificationMethod_args, rhs: TalkService_changeVerificationMethod_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId) &&
    (lhs.method == rhs.method)
}

extension TalkService_changeVerificationMethod_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    result = prime &* result &+ (method.hashValue)
    return result
  }

}

extension TalkService_changeVerificationMethod_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, "method": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_changeVerificationMethod_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_changeVerificationMethod_args {
    _ = try proto.readStructBegin()
    var sessionId: String!
    var method: VerificationMethod!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case (3, .i32):             method = try VerificationMethod.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")
    try proto.validateValue(method, named: "method")

    return TalkService_changeVerificationMethod_args(sessionId: sessionId, method: method)
  }

}



fileprivate final class TalkService_changeVerificationMethod_result {

  fileprivate var success: VerificationSessionData?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: VerificationSessionData?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_changeVerificationMethod_result, rhs: TalkService_changeVerificationMethod_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_changeVerificationMethod_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_changeVerificationMethod_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_changeVerificationMethod_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_changeVerificationMethod_result {
    _ = try proto.readStructBegin()
    var success: VerificationSessionData?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try VerificationSessionData.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_changeVerificationMethod_result(success: success, e: e)
  }

}



fileprivate final class TalkService_clearIdentityCredential_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_clearIdentityCredential_args, rhs: TalkService_clearIdentityCredential_args) -> Bool {
  return true
}

extension TalkService_clearIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_clearIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_clearIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_clearIdentityCredential_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_clearIdentityCredential_args()
  }

}



fileprivate final class TalkService_clearIdentityCredential_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_clearIdentityCredential_result, rhs: TalkService_clearIdentityCredential_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_clearIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_clearIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_clearIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_clearIdentityCredential_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_clearIdentityCredential_result(e: e)
  }

}



fileprivate final class TalkService_clearMessageBox_args {

  fileprivate var channelId: String

  fileprivate var messageBoxId: String


  fileprivate init(channelId: String, messageBoxId: String) {
    self.channelId = channelId
    self.messageBoxId = messageBoxId
  }

}

fileprivate func ==(lhs: TalkService_clearMessageBox_args, rhs: TalkService_clearMessageBox_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.messageBoxId == rhs.messageBoxId)
}

extension TalkService_clearMessageBox_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (messageBoxId.hashValue)
    return result
  }

}

extension TalkService_clearMessageBox_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 2, "messageBoxId": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_clearMessageBox_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_clearMessageBox_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var messageBoxId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           channelId = try String.read(from: proto)
        case (3, .string):           messageBoxId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(messageBoxId, named: "messageBoxId")

    return TalkService_clearMessageBox_args(channelId: channelId, messageBoxId: messageBoxId)
  }

}



fileprivate final class TalkService_clearMessageBox_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_clearMessageBox_result, rhs: TalkService_clearMessageBox_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_clearMessageBox_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_clearMessageBox_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_clearMessageBox_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_clearMessageBox_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_clearMessageBox_result(e: e)
  }

}



fileprivate final class TalkService_closeProximityMatch_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_closeProximityMatch_args, rhs: TalkService_closeProximityMatch_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_closeProximityMatch_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_closeProximityMatch_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_closeProximityMatch_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_closeProximityMatch_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_closeProximityMatch_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_closeProximityMatch_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_closeProximityMatch_result, rhs: TalkService_closeProximityMatch_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_closeProximityMatch_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_closeProximityMatch_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_closeProximityMatch_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_closeProximityMatch_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_closeProximityMatch_result(e: e)
  }

}



fileprivate final class TalkService_commitSendMessage_args {

  fileprivate var seq: Int32

  fileprivate var messageId: String

  fileprivate var receiverMids: TList<String>


  fileprivate init(seq: Int32, messageId: String, receiverMids: TList<String>) {
    self.seq = seq
    self.messageId = messageId
    self.receiverMids = receiverMids
  }

}

fileprivate func ==(lhs: TalkService_commitSendMessage_args, rhs: TalkService_commitSendMessage_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.messageId == rhs.messageId) &&
    (lhs.receiverMids == rhs.receiverMids)
}

extension TalkService_commitSendMessage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (messageId.hashValue)
    result = prime &* result &+ (receiverMids.hashValue)
    return result
  }

}

extension TalkService_commitSendMessage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "messageId": 2, "receiverMids": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_commitSendMessage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_commitSendMessage_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var messageId: String!
    var receiverMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           messageId = try String.read(from: proto)
        case (3, .list):            receiverMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(messageId, named: "messageId")
    try proto.validateValue(receiverMids, named: "receiverMids")

    return TalkService_commitSendMessage_args(seq: seq, messageId: messageId, receiverMids: receiverMids)
  }

}



fileprivate final class TalkService_commitSendMessage_result {

  fileprivate var success: TMap<String, String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_commitSendMessage_result, rhs: TalkService_commitSendMessage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_commitSendMessage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_commitSendMessage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_commitSendMessage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_commitSendMessage_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_commitSendMessage_result(success: success, e: e)
  }

}



fileprivate final class TalkService_commitSendMessages_args {

  fileprivate var seq: Int32

  fileprivate var messageIds: TList<String>

  fileprivate var receiverMids: TList<String>


  fileprivate init(seq: Int32, messageIds: TList<String>, receiverMids: TList<String>) {
    self.seq = seq
    self.messageIds = messageIds
    self.receiverMids = receiverMids
  }

}

fileprivate func ==(lhs: TalkService_commitSendMessages_args, rhs: TalkService_commitSendMessages_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.messageIds == rhs.messageIds) &&
    (lhs.receiverMids == rhs.receiverMids)
}

extension TalkService_commitSendMessages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (messageIds.hashValue)
    result = prime &* result &+ (receiverMids.hashValue)
    return result
  }

}

extension TalkService_commitSendMessages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "messageIds": 2, "receiverMids": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_commitSendMessages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_commitSendMessages_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var messageIds: TList<String>!
    var receiverMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .list):            messageIds = try TList<String>.read(from: proto)
        case (3, .list):            receiverMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(messageIds, named: "messageIds")
    try proto.validateValue(receiverMids, named: "receiverMids")

    return TalkService_commitSendMessages_args(seq: seq, messageIds: messageIds, receiverMids: receiverMids)
  }

}



fileprivate final class TalkService_commitSendMessages_result {

  fileprivate var success: TMap<String, String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_commitSendMessages_result, rhs: TalkService_commitSendMessages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_commitSendMessages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_commitSendMessages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_commitSendMessages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_commitSendMessages_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_commitSendMessages_result(success: success, e: e)
  }

}



fileprivate final class TalkService_commitUpdateProfile_args {

  fileprivate var seq: Int32

  fileprivate var attrs: TList<ProfileAttribute>

  fileprivate var receiverMids: TList<String>


  fileprivate init(seq: Int32, attrs: TList<ProfileAttribute>, receiverMids: TList<String>) {
    self.seq = seq
    self.attrs = attrs
    self.receiverMids = receiverMids
  }

}

fileprivate func ==(lhs: TalkService_commitUpdateProfile_args, rhs: TalkService_commitUpdateProfile_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.attrs == rhs.attrs) &&
    (lhs.receiverMids == rhs.receiverMids)
}

extension TalkService_commitUpdateProfile_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (attrs.hashValue)
    result = prime &* result &+ (receiverMids.hashValue)
    return result
  }

}

extension TalkService_commitUpdateProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "attrs": 2, "receiverMids": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_commitUpdateProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_commitUpdateProfile_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var attrs: TList<ProfileAttribute>!
    var receiverMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .list):            attrs = try TList<ProfileAttribute>.read(from: proto)
        case (3, .list):            receiverMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(attrs, named: "attrs")
    try proto.validateValue(receiverMids, named: "receiverMids")

    return TalkService_commitUpdateProfile_args(seq: seq, attrs: attrs, receiverMids: receiverMids)
  }

}



fileprivate final class TalkService_commitUpdateProfile_result {

  fileprivate var success: TMap<String, String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_commitUpdateProfile_result, rhs: TalkService_commitUpdateProfile_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_commitUpdateProfile_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_commitUpdateProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_commitUpdateProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_commitUpdateProfile_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_commitUpdateProfile_result(success: success, e: e)
  }

}



fileprivate final class TalkService_confirmEmail_args {

  fileprivate var verifier: String

  fileprivate var pinCode: String


  fileprivate init(verifier: String, pinCode: String) {
    self.verifier = verifier
    self.pinCode = pinCode
  }

}

fileprivate func ==(lhs: TalkService_confirmEmail_args, rhs: TalkService_confirmEmail_args) -> Bool {
  return
    (lhs.verifier == rhs.verifier) &&
    (lhs.pinCode == rhs.pinCode)
}

extension TalkService_confirmEmail_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (verifier.hashValue)
    result = prime &* result &+ (pinCode.hashValue)
    return result
  }

}

extension TalkService_confirmEmail_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["verifier": 2, "pinCode": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_confirmEmail_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_confirmEmail_args {
    _ = try proto.readStructBegin()
    var verifier: String!
    var pinCode: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           verifier = try String.read(from: proto)
        case (3, .string):           pinCode = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(verifier, named: "verifier")
    try proto.validateValue(pinCode, named: "pinCode")

    return TalkService_confirmEmail_args(verifier: verifier, pinCode: pinCode)
  }

}



fileprivate final class TalkService_confirmEmail_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_confirmEmail_result, rhs: TalkService_confirmEmail_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_confirmEmail_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_confirmEmail_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_confirmEmail_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_confirmEmail_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_confirmEmail_result(e: e)
  }

}



fileprivate final class TalkService_createGroup_args {

  fileprivate var seq: Int32

  fileprivate var name: String

  fileprivate var contactIds: TList<String>


  fileprivate init(seq: Int32, name: String, contactIds: TList<String>) {
    self.seq = seq
    self.name = name
    self.contactIds = contactIds
  }

}

fileprivate func ==(lhs: TalkService_createGroup_args, rhs: TalkService_createGroup_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.name == rhs.name) &&
    (lhs.contactIds == rhs.contactIds)
}

extension TalkService_createGroup_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (contactIds.hashValue)
    return result
  }

}

extension TalkService_createGroup_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "name": 2, "contactIds": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_createGroup_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createGroup_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var name: String!
    var contactIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .list):            contactIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(contactIds, named: "contactIds")

    return TalkService_createGroup_args(seq: seq, name: name, contactIds: contactIds)
  }

}



fileprivate final class TalkService_createGroup_result {

  fileprivate var success: Group?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Group?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_createGroup_result, rhs: TalkService_createGroup_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_createGroup_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_createGroup_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_createGroup_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createGroup_result {
    _ = try proto.readStructBegin()
    var success: Group?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Group.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_createGroup_result(success: success, e: e)
  }

}



fileprivate final class TalkService_createQrcodeBase64Image_args {

  fileprivate var url: String

  fileprivate var characterSet: String

  fileprivate var imageSize: Int32

  fileprivate var x: Int32

  fileprivate var y: Int32

  fileprivate var width: Int32

  fileprivate var height: Int32


  fileprivate init(url: String, characterSet: String, imageSize: Int32, x: Int32, y: Int32, width: Int32, height: Int32) {
    self.url = url
    self.characterSet = characterSet
    self.imageSize = imageSize
    self.x = x
    self.y = y
    self.width = width
    self.height = height
  }

}

fileprivate func ==(lhs: TalkService_createQrcodeBase64Image_args, rhs: TalkService_createQrcodeBase64Image_args) -> Bool {
  return
    (lhs.url == rhs.url) &&
    (lhs.characterSet == rhs.characterSet) &&
    (lhs.imageSize == rhs.imageSize) &&
    (lhs.x == rhs.x) &&
    (lhs.y == rhs.y) &&
    (lhs.width == rhs.width) &&
    (lhs.height == rhs.height)
}

extension TalkService_createQrcodeBase64Image_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (url.hashValue)
    result = prime &* result &+ (characterSet.hashValue)
    result = prime &* result &+ (imageSize.hashValue)
    result = prime &* result &+ (x.hashValue)
    result = prime &* result &+ (y.hashValue)
    result = prime &* result &+ (width.hashValue)
    result = prime &* result &+ (height.hashValue)
    return result
  }

}

extension TalkService_createQrcodeBase64Image_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["url": 2, "characterSet": 3, "imageSize": 4, "x": 5, "y": 6, "width": 7, "height": 8, ]
  }

  fileprivate static var structName: String { return "TalkService_createQrcodeBase64Image_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createQrcodeBase64Image_args {
    _ = try proto.readStructBegin()
    var url: String!
    var characterSet: String!
    var imageSize: Int32!
    var x: Int32!
    var y: Int32!
    var width: Int32!
    var height: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           url = try String.read(from: proto)
        case (3, .string):           characterSet = try String.read(from: proto)
        case (4, .i32):             imageSize = try Int32.read(from: proto)
        case (5, .i32):             x = try Int32.read(from: proto)
        case (6, .i32):             y = try Int32.read(from: proto)
        case (7, .i32):             width = try Int32.read(from: proto)
        case (8, .i32):             height = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(url, named: "url")
    try proto.validateValue(characterSet, named: "characterSet")
    try proto.validateValue(imageSize, named: "imageSize")
    try proto.validateValue(x, named: "x")
    try proto.validateValue(y, named: "y")
    try proto.validateValue(width, named: "width")
    try proto.validateValue(height, named: "height")

    return TalkService_createQrcodeBase64Image_args(url: url, characterSet: characterSet, imageSize: imageSize, x: x, y: y, width: width, height: height)
  }

}



fileprivate final class TalkService_createQrcodeBase64Image_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_createQrcodeBase64Image_result, rhs: TalkService_createQrcodeBase64Image_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_createQrcodeBase64Image_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_createQrcodeBase64Image_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_createQrcodeBase64Image_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createQrcodeBase64Image_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_createQrcodeBase64Image_result(success: success, e: e)
  }

}



fileprivate final class TalkService_createRoom_args {

  fileprivate var reqSeq: Int32

  fileprivate var contactIds: TList<String>


  fileprivate init(reqSeq: Int32, contactIds: TList<String>) {
    self.reqSeq = reqSeq
    self.contactIds = contactIds
  }

}

fileprivate func ==(lhs: TalkService_createRoom_args, rhs: TalkService_createRoom_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.contactIds == rhs.contactIds)
}

extension TalkService_createRoom_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (contactIds.hashValue)
    return result
  }

}

extension TalkService_createRoom_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "contactIds": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_createRoom_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createRoom_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var contactIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .list):            contactIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(contactIds, named: "contactIds")

    return TalkService_createRoom_args(reqSeq: reqSeq, contactIds: contactIds)
  }

}



fileprivate final class TalkService_createRoom_result {

  fileprivate var success: Room?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Room?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_createRoom_result, rhs: TalkService_createRoom_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_createRoom_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_createRoom_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_createRoom_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createRoom_result {
    _ = try proto.readStructBegin()
    var success: Room?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Room.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_createRoom_result(success: success, e: e)
  }

}



fileprivate final class TalkService_createSession_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_createSession_args, rhs: TalkService_createSession_args) -> Bool {
  return true
}

extension TalkService_createSession_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_createSession_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_createSession_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createSession_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_createSession_args()
  }

}



fileprivate final class TalkService_createSession_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_createSession_result, rhs: TalkService_createSession_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_createSession_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_createSession_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_createSession_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_createSession_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_createSession_result(success: success, e: e)
  }

}



fileprivate final class TalkService_fetchAnnouncements_args {

  fileprivate var lastFetchedIndex: Int32


  fileprivate init(lastFetchedIndex: Int32) {
    self.lastFetchedIndex = lastFetchedIndex
  }

}

fileprivate func ==(lhs: TalkService_fetchAnnouncements_args, rhs: TalkService_fetchAnnouncements_args) -> Bool {
  return
    (lhs.lastFetchedIndex == rhs.lastFetchedIndex)
}

extension TalkService_fetchAnnouncements_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastFetchedIndex.hashValue)
    return result
  }

}

extension TalkService_fetchAnnouncements_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastFetchedIndex": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchAnnouncements_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchAnnouncements_args {
    _ = try proto.readStructBegin()
    var lastFetchedIndex: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             lastFetchedIndex = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastFetchedIndex, named: "lastFetchedIndex")

    return TalkService_fetchAnnouncements_args(lastFetchedIndex: lastFetchedIndex)
  }

}



fileprivate final class TalkService_fetchAnnouncements_result {

  fileprivate var success: TList<Announcement>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Announcement>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_fetchAnnouncements_result, rhs: TalkService_fetchAnnouncements_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_fetchAnnouncements_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_fetchAnnouncements_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchAnnouncements_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchAnnouncements_result {
    _ = try proto.readStructBegin()
    var success: TList<Announcement>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Announcement>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_fetchAnnouncements_result(success: success, e: e)
  }

}



fileprivate final class TalkService_fetchMessages_args {

  fileprivate var localTs: Int64

  fileprivate var count: Int32


  fileprivate init(localTs: Int64, count: Int32) {
    self.localTs = localTs
    self.count = count
  }

}

fileprivate func ==(lhs: TalkService_fetchMessages_args, rhs: TalkService_fetchMessages_args) -> Bool {
  return
    (lhs.localTs == rhs.localTs) &&
    (lhs.count == rhs.count)
}

extension TalkService_fetchMessages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (localTs.hashValue)
    result = prime &* result &+ (count.hashValue)
    return result
  }

}

extension TalkService_fetchMessages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["localTs": 2, "count": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchMessages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchMessages_args {
    _ = try proto.readStructBegin()
    var localTs: Int64!
    var count: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             localTs = try Int64.read(from: proto)
        case (3, .i32):             count = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(localTs, named: "localTs")
    try proto.validateValue(count, named: "count")

    return TalkService_fetchMessages_args(localTs: localTs, count: count)
  }

}



fileprivate final class TalkService_fetchMessages_result {

  fileprivate var success: TList<Message>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Message>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_fetchMessages_result, rhs: TalkService_fetchMessages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_fetchMessages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_fetchMessages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchMessages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchMessages_result {
    _ = try proto.readStructBegin()
    var success: TList<Message>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Message>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_fetchMessages_result(success: success, e: e)
  }

}



fileprivate final class TalkService_fetchOperations_args {

  fileprivate var localRev: Int64

  fileprivate var count: Int32


  fileprivate init(localRev: Int64, count: Int32) {
    self.localRev = localRev
    self.count = count
  }

}

fileprivate func ==(lhs: TalkService_fetchOperations_args, rhs: TalkService_fetchOperations_args) -> Bool {
  return
    (lhs.localRev == rhs.localRev) &&
    (lhs.count == rhs.count)
}

extension TalkService_fetchOperations_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (localRev.hashValue)
    result = prime &* result &+ (count.hashValue)
    return result
  }

}

extension TalkService_fetchOperations_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["localRev": 2, "count": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchOperations_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchOperations_args {
    _ = try proto.readStructBegin()
    var localRev: Int64!
    var count: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             localRev = try Int64.read(from: proto)
        case (3, .i32):             count = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(localRev, named: "localRev")
    try proto.validateValue(count, named: "count")

    return TalkService_fetchOperations_args(localRev: localRev, count: count)
  }

}



fileprivate final class TalkService_fetchOperations_result {

  fileprivate var success: TList<Operation>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Operation>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_fetchOperations_result, rhs: TalkService_fetchOperations_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_fetchOperations_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_fetchOperations_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchOperations_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchOperations_result {
    _ = try proto.readStructBegin()
    var success: TList<Operation>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Operation>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_fetchOperations_result(success: success, e: e)
  }

}



fileprivate final class TalkService_fetchOps_args {

  fileprivate var localRev: Int64

  fileprivate var count: Int32

  fileprivate var globalRev: Int64

  fileprivate var individualRev: Int64


  fileprivate init(localRev: Int64, count: Int32, globalRev: Int64, individualRev: Int64) {
    self.localRev = localRev
    self.count = count
    self.globalRev = globalRev
    self.individualRev = individualRev
  }

}

fileprivate func ==(lhs: TalkService_fetchOps_args, rhs: TalkService_fetchOps_args) -> Bool {
  return
    (lhs.localRev == rhs.localRev) &&
    (lhs.count == rhs.count) &&
    (lhs.globalRev == rhs.globalRev) &&
    (lhs.individualRev == rhs.individualRev)
}

extension TalkService_fetchOps_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (localRev.hashValue)
    result = prime &* result &+ (count.hashValue)
    result = prime &* result &+ (globalRev.hashValue)
    result = prime &* result &+ (individualRev.hashValue)
    return result
  }

}

extension TalkService_fetchOps_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["localRev": 2, "count": 3, "globalRev": 4, "individualRev": 5, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchOps_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchOps_args {
    _ = try proto.readStructBegin()
    var localRev: Int64!
    var count: Int32!
    var globalRev: Int64!
    var individualRev: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             localRev = try Int64.read(from: proto)
        case (3, .i32):             count = try Int32.read(from: proto)
        case (4, .i64):             globalRev = try Int64.read(from: proto)
        case (5, .i64):             individualRev = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(localRev, named: "localRev")
    try proto.validateValue(count, named: "count")
    try proto.validateValue(globalRev, named: "globalRev")
    try proto.validateValue(individualRev, named: "individualRev")

    return TalkService_fetchOps_args(localRev: localRev, count: count, globalRev: globalRev, individualRev: individualRev)
  }

}



fileprivate final class TalkService_fetchOps_result {

  fileprivate var success: TList<Operation>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Operation>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_fetchOps_result, rhs: TalkService_fetchOps_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_fetchOps_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_fetchOps_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_fetchOps_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_fetchOps_result {
    _ = try proto.readStructBegin()
    var success: TList<Operation>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Operation>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_fetchOps_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findAndAddContactsByEmail_args {

  fileprivate var reqSeq: Int32

  fileprivate var emails: TSet<String>


  fileprivate init(reqSeq: Int32, emails: TSet<String>) {
    self.reqSeq = reqSeq
    self.emails = emails
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByEmail_args, rhs: TalkService_findAndAddContactsByEmail_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.emails == rhs.emails)
}

extension TalkService_findAndAddContactsByEmail_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (emails.hashValue)
    return result
  }

}

extension TalkService_findAndAddContactsByEmail_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "emails": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByEmail_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByEmail_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var emails: TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .set):             emails = try TSet<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(emails, named: "emails")

    return TalkService_findAndAddContactsByEmail_args(reqSeq: reqSeq, emails: emails)
  }

}



fileprivate final class TalkService_findAndAddContactsByEmail_result {

  fileprivate var success: TMap<String, Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByEmail_result, rhs: TalkService_findAndAddContactsByEmail_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findAndAddContactsByEmail_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findAndAddContactsByEmail_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByEmail_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByEmail_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findAndAddContactsByEmail_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findAndAddContactsByMid_args {

  fileprivate var reqSeq: Int32

  fileprivate var mid: String


  fileprivate init(reqSeq: Int32, mid: String) {
    self.reqSeq = reqSeq
    self.mid = mid
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByMid_args, rhs: TalkService_findAndAddContactsByMid_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.mid == rhs.mid)
}

extension TalkService_findAndAddContactsByMid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension TalkService_findAndAddContactsByMid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "mid": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByMid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByMid_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(mid, named: "mid")

    return TalkService_findAndAddContactsByMid_args(reqSeq: reqSeq, mid: mid)
  }

}



fileprivate final class TalkService_findAndAddContactsByMid_result {

  fileprivate var success: TMap<String, Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByMid_result, rhs: TalkService_findAndAddContactsByMid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findAndAddContactsByMid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findAndAddContactsByMid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByMid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByMid_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findAndAddContactsByMid_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findAndAddContactsByPhone_args {

  fileprivate var reqSeq: Int32

  fileprivate var phones: TSet<String>


  fileprivate init(reqSeq: Int32, phones: TSet<String>) {
    self.reqSeq = reqSeq
    self.phones = phones
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByPhone_args, rhs: TalkService_findAndAddContactsByPhone_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.phones == rhs.phones)
}

extension TalkService_findAndAddContactsByPhone_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (phones.hashValue)
    return result
  }

}

extension TalkService_findAndAddContactsByPhone_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "phones": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByPhone_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByPhone_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var phones: TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .set):             phones = try TSet<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(phones, named: "phones")

    return TalkService_findAndAddContactsByPhone_args(reqSeq: reqSeq, phones: phones)
  }

}



fileprivate final class TalkService_findAndAddContactsByPhone_result {

  fileprivate var success: TMap<String, Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByPhone_result, rhs: TalkService_findAndAddContactsByPhone_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findAndAddContactsByPhone_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findAndAddContactsByPhone_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByPhone_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByPhone_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findAndAddContactsByPhone_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findAndAddContactsByUserid_args {

  fileprivate var reqSeq: Int32

  fileprivate var userid: String


  fileprivate init(reqSeq: Int32, userid: String) {
    self.reqSeq = reqSeq
    self.userid = userid
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByUserid_args, rhs: TalkService_findAndAddContactsByUserid_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.userid == rhs.userid)
}

extension TalkService_findAndAddContactsByUserid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (userid.hashValue)
    return result
  }

}

extension TalkService_findAndAddContactsByUserid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "userid": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByUserid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByUserid_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var userid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           userid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(userid, named: "userid")

    return TalkService_findAndAddContactsByUserid_args(reqSeq: reqSeq, userid: userid)
  }

}



fileprivate final class TalkService_findAndAddContactsByUserid_result {

  fileprivate var success: TMap<String, Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findAndAddContactsByUserid_result, rhs: TalkService_findAndAddContactsByUserid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findAndAddContactsByUserid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findAndAddContactsByUserid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findAndAddContactsByUserid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findAndAddContactsByUserid_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findAndAddContactsByUserid_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findContactByUserid_args {

  fileprivate var userid: String


  fileprivate init(userid: String) {
    self.userid = userid
  }

}

fileprivate func ==(lhs: TalkService_findContactByUserid_args, rhs: TalkService_findContactByUserid_args) -> Bool {
  return
    (lhs.userid == rhs.userid)
}

extension TalkService_findContactByUserid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (userid.hashValue)
    return result
  }

}

extension TalkService_findContactByUserid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["userid": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactByUserid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactByUserid_args {
    _ = try proto.readStructBegin()
    var userid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           userid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(userid, named: "userid")

    return TalkService_findContactByUserid_args(userid: userid)
  }

}



fileprivate final class TalkService_findContactByUserid_result {

  fileprivate var success: Contact?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Contact?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findContactByUserid_result, rhs: TalkService_findContactByUserid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findContactByUserid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findContactByUserid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactByUserid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactByUserid_result {
    _ = try proto.readStructBegin()
    var success: Contact?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Contact.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findContactByUserid_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findContactByUserTicket_args {

  fileprivate var ticketId: String


  fileprivate init(ticketId: String) {
    self.ticketId = ticketId
  }

}

fileprivate func ==(lhs: TalkService_findContactByUserTicket_args, rhs: TalkService_findContactByUserTicket_args) -> Bool {
  return
    (lhs.ticketId == rhs.ticketId)
}

extension TalkService_findContactByUserTicket_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ticketId.hashValue)
    return result
  }

}

extension TalkService_findContactByUserTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ticketId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactByUserTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactByUserTicket_args {
    _ = try proto.readStructBegin()
    var ticketId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           ticketId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ticketId, named: "ticketId")

    return TalkService_findContactByUserTicket_args(ticketId: ticketId)
  }

}



fileprivate final class TalkService_findContactByUserTicket_result {

  fileprivate var success: Contact?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Contact?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findContactByUserTicket_result, rhs: TalkService_findContactByUserTicket_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findContactByUserTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findContactByUserTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactByUserTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactByUserTicket_result {
    _ = try proto.readStructBegin()
    var success: Contact?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Contact.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findContactByUserTicket_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findContactsByEmail_args {

  fileprivate var emails: TSet<String>


  fileprivate init(emails: TSet<String>) {
    self.emails = emails
  }

}

fileprivate func ==(lhs: TalkService_findContactsByEmail_args, rhs: TalkService_findContactsByEmail_args) -> Bool {
  return
    (lhs.emails == rhs.emails)
}

extension TalkService_findContactsByEmail_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (emails.hashValue)
    return result
  }

}

extension TalkService_findContactsByEmail_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["emails": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactsByEmail_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactsByEmail_args {
    _ = try proto.readStructBegin()
    var emails: TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .set):             emails = try TSet<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(emails, named: "emails")

    return TalkService_findContactsByEmail_args(emails: emails)
  }

}



fileprivate final class TalkService_findContactsByEmail_result {

  fileprivate var success: TMap<String, Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findContactsByEmail_result, rhs: TalkService_findContactsByEmail_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findContactsByEmail_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findContactsByEmail_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactsByEmail_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactsByEmail_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findContactsByEmail_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findContactsByPhone_args {

  fileprivate var phones: TSet<String>


  fileprivate init(phones: TSet<String>) {
    self.phones = phones
  }

}

fileprivate func ==(lhs: TalkService_findContactsByPhone_args, rhs: TalkService_findContactsByPhone_args) -> Bool {
  return
    (lhs.phones == rhs.phones)
}

extension TalkService_findContactsByPhone_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (phones.hashValue)
    return result
  }

}

extension TalkService_findContactsByPhone_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["phones": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactsByPhone_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactsByPhone_args {
    _ = try proto.readStructBegin()
    var phones: TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .set):             phones = try TSet<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(phones, named: "phones")

    return TalkService_findContactsByPhone_args(phones: phones)
  }

}



fileprivate final class TalkService_findContactsByPhone_result {

  fileprivate var success: TMap<String, Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findContactsByPhone_result, rhs: TalkService_findContactsByPhone_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findContactsByPhone_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findContactsByPhone_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findContactsByPhone_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findContactsByPhone_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findContactsByPhone_result(success: success, e: e)
  }

}



fileprivate final class TalkService_findSnsIdUserStatus_args {

  fileprivate var snsIdType: SnsIdType

  fileprivate var snsAccessToken: String

  fileprivate var udidHash: String


  fileprivate init(snsIdType: SnsIdType, snsAccessToken: String, udidHash: String) {
    self.snsIdType = snsIdType
    self.snsAccessToken = snsAccessToken
    self.udidHash = udidHash
  }

}

fileprivate func ==(lhs: TalkService_findSnsIdUserStatus_args, rhs: TalkService_findSnsIdUserStatus_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsAccessToken == rhs.snsAccessToken) &&
    (lhs.udidHash == rhs.udidHash)
}

extension TalkService_findSnsIdUserStatus_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsAccessToken.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    return result
  }

}

extension TalkService_findSnsIdUserStatus_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, "snsAccessToken": 3, "udidHash": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_findSnsIdUserStatus_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findSnsIdUserStatus_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!
    var snsAccessToken: String!
    var udidHash: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsAccessToken = try String.read(from: proto)
        case (4, .string):           udidHash = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsAccessToken, named: "snsAccessToken")
    try proto.validateValue(udidHash, named: "udidHash")

    return TalkService_findSnsIdUserStatus_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, udidHash: udidHash)
  }

}



fileprivate final class TalkService_findSnsIdUserStatus_result {

  fileprivate var success: SnsIdUserStatus?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SnsIdUserStatus?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_findSnsIdUserStatus_result, rhs: TalkService_findSnsIdUserStatus_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_findSnsIdUserStatus_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_findSnsIdUserStatus_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_findSnsIdUserStatus_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_findSnsIdUserStatus_result {
    _ = try proto.readStructBegin()
    var success: SnsIdUserStatus?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SnsIdUserStatus.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_findSnsIdUserStatus_result(success: success, e: e)
  }

}



fileprivate final class TalkService_finishUpdateVerification_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_finishUpdateVerification_args, rhs: TalkService_finishUpdateVerification_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_finishUpdateVerification_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_finishUpdateVerification_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_finishUpdateVerification_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_finishUpdateVerification_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_finishUpdateVerification_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_finishUpdateVerification_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_finishUpdateVerification_result, rhs: TalkService_finishUpdateVerification_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_finishUpdateVerification_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_finishUpdateVerification_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_finishUpdateVerification_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_finishUpdateVerification_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_finishUpdateVerification_result(e: e)
  }

}



fileprivate final class TalkService_generateUserTicket_args {

  fileprivate var expirationTime: Int64

  fileprivate var maxUseCount: Int32


  fileprivate init(expirationTime: Int64, maxUseCount: Int32) {
    self.expirationTime = expirationTime
    self.maxUseCount = maxUseCount
  }

}

fileprivate func ==(lhs: TalkService_generateUserTicket_args, rhs: TalkService_generateUserTicket_args) -> Bool {
  return
    (lhs.expirationTime == rhs.expirationTime) &&
    (lhs.maxUseCount == rhs.maxUseCount)
}

extension TalkService_generateUserTicket_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (expirationTime.hashValue)
    result = prime &* result &+ (maxUseCount.hashValue)
    return result
  }

}

extension TalkService_generateUserTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["expirationTime": 3, "maxUseCount": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_generateUserTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_generateUserTicket_args {
    _ = try proto.readStructBegin()
    var expirationTime: Int64!
    var maxUseCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .i64):             expirationTime = try Int64.read(from: proto)
        case (4, .i32):             maxUseCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(expirationTime, named: "expirationTime")
    try proto.validateValue(maxUseCount, named: "maxUseCount")

    return TalkService_generateUserTicket_args(expirationTime: expirationTime, maxUseCount: maxUseCount)
  }

}



fileprivate final class TalkService_generateUserTicket_result {

  fileprivate var success: Ticket?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Ticket?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_generateUserTicket_result, rhs: TalkService_generateUserTicket_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_generateUserTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_generateUserTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_generateUserTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_generateUserTicket_result {
    _ = try proto.readStructBegin()
    var success: Ticket?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Ticket.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_generateUserTicket_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getAcceptedProximityMatches_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_getAcceptedProximityMatches_args, rhs: TalkService_getAcceptedProximityMatches_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_getAcceptedProximityMatches_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_getAcceptedProximityMatches_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getAcceptedProximityMatches_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getAcceptedProximityMatches_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_getAcceptedProximityMatches_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_getAcceptedProximityMatches_result {

  fileprivate var success: TSet<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TSet<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getAcceptedProximityMatches_result, rhs: TalkService_getAcceptedProximityMatches_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getAcceptedProximityMatches_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getAcceptedProximityMatches_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getAcceptedProximityMatches_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getAcceptedProximityMatches_result {
    _ = try proto.readStructBegin()
    var success: TSet<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .set):             success = try TSet<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getAcceptedProximityMatches_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getActiveBuddySubscriberIds_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getActiveBuddySubscriberIds_args, rhs: TalkService_getActiveBuddySubscriberIds_args) -> Bool {
  return true
}

extension TalkService_getActiveBuddySubscriberIds_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getActiveBuddySubscriberIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getActiveBuddySubscriberIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getActiveBuddySubscriberIds_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getActiveBuddySubscriberIds_args()
  }

}



fileprivate final class TalkService_getActiveBuddySubscriberIds_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getActiveBuddySubscriberIds_result, rhs: TalkService_getActiveBuddySubscriberIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getActiveBuddySubscriberIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getActiveBuddySubscriberIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getActiveBuddySubscriberIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getActiveBuddySubscriberIds_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getActiveBuddySubscriberIds_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getAllContactIds_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getAllContactIds_args, rhs: TalkService_getAllContactIds_args) -> Bool {
  return true
}

extension TalkService_getAllContactIds_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getAllContactIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getAllContactIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getAllContactIds_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getAllContactIds_args()
  }

}



fileprivate final class TalkService_getAllContactIds_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getAllContactIds_result, rhs: TalkService_getAllContactIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getAllContactIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getAllContactIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getAllContactIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getAllContactIds_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getAllContactIds_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getAuthQrcode_args {

  fileprivate var keepLoggedIn: Bool

  fileprivate var systemName: String


  fileprivate init(keepLoggedIn: Bool, systemName: String) {
    self.keepLoggedIn = keepLoggedIn
    self.systemName = systemName
  }

}

fileprivate func ==(lhs: TalkService_getAuthQrcode_args, rhs: TalkService_getAuthQrcode_args) -> Bool {
  return
    (lhs.keepLoggedIn == rhs.keepLoggedIn) &&
    (lhs.systemName == rhs.systemName)
}

extension TalkService_getAuthQrcode_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (keepLoggedIn.hashValue)
    result = prime &* result &+ (systemName.hashValue)
    return result
  }

}

extension TalkService_getAuthQrcode_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["keepLoggedIn": 2, "systemName": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_getAuthQrcode_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getAuthQrcode_args {
    _ = try proto.readStructBegin()
    var keepLoggedIn: Bool!
    var systemName: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .bool):            keepLoggedIn = try Bool.read(from: proto)
        case (3, .string):           systemName = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(keepLoggedIn, named: "keepLoggedIn")
    try proto.validateValue(systemName, named: "systemName")

    return TalkService_getAuthQrcode_args(keepLoggedIn: keepLoggedIn, systemName: systemName)
  }

}



fileprivate final class TalkService_getAuthQrcode_result {

  fileprivate var success: AuthQrcode?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: AuthQrcode?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getAuthQrcode_result, rhs: TalkService_getAuthQrcode_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getAuthQrcode_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getAuthQrcode_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getAuthQrcode_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getAuthQrcode_result {
    _ = try proto.readStructBegin()
    var success: AuthQrcode?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try AuthQrcode.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getAuthQrcode_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getBlockedContactIds_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getBlockedContactIds_args, rhs: TalkService_getBlockedContactIds_args) -> Bool {
  return true
}

extension TalkService_getBlockedContactIds_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getBlockedContactIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getBlockedContactIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBlockedContactIds_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBlockedContactIds_args()
  }

}



fileprivate final class TalkService_getBlockedContactIds_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getBlockedContactIds_result, rhs: TalkService_getBlockedContactIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getBlockedContactIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getBlockedContactIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getBlockedContactIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBlockedContactIds_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBlockedContactIds_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getBlockedContactIdsByRange_args {

  fileprivate var start: Int32

  fileprivate var count: Int32


  fileprivate init(start: Int32, count: Int32) {
    self.start = start
    self.count = count
  }

}

fileprivate func ==(lhs: TalkService_getBlockedContactIdsByRange_args, rhs: TalkService_getBlockedContactIdsByRange_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.count == rhs.count)
}

extension TalkService_getBlockedContactIdsByRange_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (count.hashValue)
    return result
  }

}

extension TalkService_getBlockedContactIdsByRange_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "count": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_getBlockedContactIdsByRange_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBlockedContactIdsByRange_args {
    _ = try proto.readStructBegin()
    var start: Int32!
    var count: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             start = try Int32.read(from: proto)
        case (3, .i32):             count = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(count, named: "count")

    return TalkService_getBlockedContactIdsByRange_args(start: start, count: count)
  }

}



fileprivate final class TalkService_getBlockedContactIdsByRange_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getBlockedContactIdsByRange_result, rhs: TalkService_getBlockedContactIdsByRange_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getBlockedContactIdsByRange_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getBlockedContactIdsByRange_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getBlockedContactIdsByRange_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBlockedContactIdsByRange_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBlockedContactIdsByRange_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getBlockedRecommendationIds_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getBlockedRecommendationIds_args, rhs: TalkService_getBlockedRecommendationIds_args) -> Bool {
  return true
}

extension TalkService_getBlockedRecommendationIds_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getBlockedRecommendationIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getBlockedRecommendationIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBlockedRecommendationIds_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBlockedRecommendationIds_args()
  }

}



fileprivate final class TalkService_getBlockedRecommendationIds_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getBlockedRecommendationIds_result, rhs: TalkService_getBlockedRecommendationIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getBlockedRecommendationIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getBlockedRecommendationIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getBlockedRecommendationIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBlockedRecommendationIds_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBlockedRecommendationIds_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getBuddyBlockerIds_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getBuddyBlockerIds_args, rhs: TalkService_getBuddyBlockerIds_args) -> Bool {
  return true
}

extension TalkService_getBuddyBlockerIds_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getBuddyBlockerIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getBuddyBlockerIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBuddyBlockerIds_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBuddyBlockerIds_args()
  }

}



fileprivate final class TalkService_getBuddyBlockerIds_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getBuddyBlockerIds_result, rhs: TalkService_getBuddyBlockerIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getBuddyBlockerIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getBuddyBlockerIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getBuddyBlockerIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBuddyBlockerIds_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBuddyBlockerIds_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getBuddyLocation_args {

  fileprivate var mid: String

  fileprivate var index: Int32


  fileprivate init(mid: String, index: Int32) {
    self.mid = mid
    self.index = index
  }

}

fileprivate func ==(lhs: TalkService_getBuddyLocation_args, rhs: TalkService_getBuddyLocation_args) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.index == rhs.index)
}

extension TalkService_getBuddyLocation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (index.hashValue)
    return result
  }

}

extension TalkService_getBuddyLocation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["mid": 2, "index": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_getBuddyLocation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBuddyLocation_args {
    _ = try proto.readStructBegin()
    var mid: String!
    var index: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           mid = try String.read(from: proto)
        case (3, .i32):             index = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(index, named: "index")

    return TalkService_getBuddyLocation_args(mid: mid, index: index)
  }

}



fileprivate final class TalkService_getBuddyLocation_result {

  fileprivate var success: Geolocation?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Geolocation?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getBuddyLocation_result, rhs: TalkService_getBuddyLocation_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getBuddyLocation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getBuddyLocation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getBuddyLocation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getBuddyLocation_result {
    _ = try proto.readStructBegin()
    var success: Geolocation?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Geolocation.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getBuddyLocation_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getCompactContactsModifiedSince_args {

  fileprivate var timestamp: Int64


  fileprivate init(timestamp: Int64) {
    self.timestamp = timestamp
  }

}

fileprivate func ==(lhs: TalkService_getCompactContactsModifiedSince_args, rhs: TalkService_getCompactContactsModifiedSince_args) -> Bool {
  return
    (lhs.timestamp == rhs.timestamp)
}

extension TalkService_getCompactContactsModifiedSince_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (timestamp.hashValue)
    return result
  }

}

extension TalkService_getCompactContactsModifiedSince_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["timestamp": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getCompactContactsModifiedSince_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCompactContactsModifiedSince_args {
    _ = try proto.readStructBegin()
    var timestamp: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             timestamp = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(timestamp, named: "timestamp")

    return TalkService_getCompactContactsModifiedSince_args(timestamp: timestamp)
  }

}



fileprivate final class TalkService_getCompactContactsModifiedSince_result {

  fileprivate var success: TList<CompactContact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<CompactContact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getCompactContactsModifiedSince_result, rhs: TalkService_getCompactContactsModifiedSince_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getCompactContactsModifiedSince_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getCompactContactsModifiedSince_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getCompactContactsModifiedSince_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCompactContactsModifiedSince_result {
    _ = try proto.readStructBegin()
    var success: TList<CompactContact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<CompactContact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getCompactContactsModifiedSince_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getCompactGroup_args {

  fileprivate var groupId: String


  fileprivate init(groupId: String) {
    self.groupId = groupId
  }

}

fileprivate func ==(lhs: TalkService_getCompactGroup_args, rhs: TalkService_getCompactGroup_args) -> Bool {
  return
    (lhs.groupId == rhs.groupId)
}

extension TalkService_getCompactGroup_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (groupId.hashValue)
    return result
  }

}

extension TalkService_getCompactGroup_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["groupId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getCompactGroup_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCompactGroup_args {
    _ = try proto.readStructBegin()
    var groupId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           groupId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(groupId, named: "groupId")

    return TalkService_getCompactGroup_args(groupId: groupId)
  }

}



fileprivate final class TalkService_getCompactGroup_result {

  fileprivate var success: Group?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Group?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getCompactGroup_result, rhs: TalkService_getCompactGroup_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getCompactGroup_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getCompactGroup_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getCompactGroup_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCompactGroup_result {
    _ = try proto.readStructBegin()
    var success: Group?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Group.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getCompactGroup_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getCompactRoom_args {

  fileprivate var roomId: String


  fileprivate init(roomId: String) {
    self.roomId = roomId
  }

}

fileprivate func ==(lhs: TalkService_getCompactRoom_args, rhs: TalkService_getCompactRoom_args) -> Bool {
  return
    (lhs.roomId == rhs.roomId)
}

extension TalkService_getCompactRoom_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (roomId.hashValue)
    return result
  }

}

extension TalkService_getCompactRoom_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["roomId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getCompactRoom_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCompactRoom_args {
    _ = try proto.readStructBegin()
    var roomId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           roomId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(roomId, named: "roomId")

    return TalkService_getCompactRoom_args(roomId: roomId)
  }

}



fileprivate final class TalkService_getCompactRoom_result {

  fileprivate var success: Room?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Room?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getCompactRoom_result, rhs: TalkService_getCompactRoom_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getCompactRoom_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getCompactRoom_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getCompactRoom_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCompactRoom_result {
    _ = try proto.readStructBegin()
    var success: Room?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Room.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getCompactRoom_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getContact_args {

  fileprivate var id: String


  fileprivate init(id: String) {
    self.id = id
  }

}

fileprivate func ==(lhs: TalkService_getContact_args, rhs: TalkService_getContact_args) -> Bool {
  return
    (lhs.id == rhs.id)
}

extension TalkService_getContact_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    return result
  }

}

extension TalkService_getContact_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getContact_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getContact_args {
    _ = try proto.readStructBegin()
    var id: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           id = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")

    return TalkService_getContact_args(id: id)
  }

}



fileprivate final class TalkService_getContact_result {

  fileprivate var success: Contact?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Contact?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getContact_result, rhs: TalkService_getContact_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getContact_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getContact_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getContact_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getContact_result {
    _ = try proto.readStructBegin()
    var success: Contact?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Contact.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getContact_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getContacts_args {

  fileprivate var ids: TList<String>


  fileprivate init(ids: TList<String>) {
    self.ids = ids
  }

}

fileprivate func ==(lhs: TalkService_getContacts_args, rhs: TalkService_getContacts_args) -> Bool {
  return
    (lhs.ids == rhs.ids)
}

extension TalkService_getContacts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ids.hashValue)
    return result
  }

}

extension TalkService_getContacts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ids": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getContacts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getContacts_args {
    _ = try proto.readStructBegin()
    var ids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .list):            ids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ids, named: "ids")

    return TalkService_getContacts_args(ids: ids)
  }

}



fileprivate final class TalkService_getContacts_result {

  fileprivate var success: TList<Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getContacts_result, rhs: TalkService_getContacts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getContacts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getContacts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getContacts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getContacts_result {
    _ = try proto.readStructBegin()
    var success: TList<Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getContacts_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getCountryWithRequestIp_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getCountryWithRequestIp_args, rhs: TalkService_getCountryWithRequestIp_args) -> Bool {
  return true
}

extension TalkService_getCountryWithRequestIp_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getCountryWithRequestIp_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getCountryWithRequestIp_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCountryWithRequestIp_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getCountryWithRequestIp_args()
  }

}



fileprivate final class TalkService_getCountryWithRequestIp_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getCountryWithRequestIp_result, rhs: TalkService_getCountryWithRequestIp_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getCountryWithRequestIp_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getCountryWithRequestIp_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getCountryWithRequestIp_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getCountryWithRequestIp_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getCountryWithRequestIp_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getFavoriteMids_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getFavoriteMids_args, rhs: TalkService_getFavoriteMids_args) -> Bool {
  return true
}

extension TalkService_getFavoriteMids_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getFavoriteMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getFavoriteMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getFavoriteMids_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getFavoriteMids_args()
  }

}



fileprivate final class TalkService_getFavoriteMids_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getFavoriteMids_result, rhs: TalkService_getFavoriteMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getFavoriteMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getFavoriteMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getFavoriteMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getFavoriteMids_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getFavoriteMids_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getGroup_args {

  fileprivate var groupId: String


  fileprivate init(groupId: String) {
    self.groupId = groupId
  }

}

fileprivate func ==(lhs: TalkService_getGroup_args, rhs: TalkService_getGroup_args) -> Bool {
  return
    (lhs.groupId == rhs.groupId)
}

extension TalkService_getGroup_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (groupId.hashValue)
    return result
  }

}

extension TalkService_getGroup_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["groupId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getGroup_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroup_args {
    _ = try proto.readStructBegin()
    var groupId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           groupId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(groupId, named: "groupId")

    return TalkService_getGroup_args(groupId: groupId)
  }

}



fileprivate final class TalkService_getGroup_result {

  fileprivate var success: Group?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Group?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getGroup_result, rhs: TalkService_getGroup_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getGroup_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getGroup_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getGroup_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroup_result {
    _ = try proto.readStructBegin()
    var success: Group?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Group.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getGroup_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getGroupIdsInvited_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getGroupIdsInvited_args, rhs: TalkService_getGroupIdsInvited_args) -> Bool {
  return true
}

extension TalkService_getGroupIdsInvited_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getGroupIdsInvited_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getGroupIdsInvited_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroupIdsInvited_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getGroupIdsInvited_args()
  }

}



fileprivate final class TalkService_getGroupIdsInvited_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getGroupIdsInvited_result, rhs: TalkService_getGroupIdsInvited_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getGroupIdsInvited_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getGroupIdsInvited_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getGroupIdsInvited_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroupIdsInvited_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getGroupIdsInvited_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getGroupIdsJoined_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getGroupIdsJoined_args, rhs: TalkService_getGroupIdsJoined_args) -> Bool {
  return true
}

extension TalkService_getGroupIdsJoined_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getGroupIdsJoined_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getGroupIdsJoined_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroupIdsJoined_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getGroupIdsJoined_args()
  }

}



fileprivate final class TalkService_getGroupIdsJoined_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getGroupIdsJoined_result, rhs: TalkService_getGroupIdsJoined_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getGroupIdsJoined_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getGroupIdsJoined_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getGroupIdsJoined_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroupIdsJoined_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getGroupIdsJoined_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getGroups_args {

  fileprivate var groupIds: TList<String>


  fileprivate init(groupIds: TList<String>) {
    self.groupIds = groupIds
  }

}

fileprivate func ==(lhs: TalkService_getGroups_args, rhs: TalkService_getGroups_args) -> Bool {
  return
    (lhs.groupIds == rhs.groupIds)
}

extension TalkService_getGroups_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (groupIds.hashValue)
    return result
  }

}

extension TalkService_getGroups_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["groupIds": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getGroups_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroups_args {
    _ = try proto.readStructBegin()
    var groupIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .list):            groupIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(groupIds, named: "groupIds")

    return TalkService_getGroups_args(groupIds: groupIds)
  }

}



fileprivate final class TalkService_getGroups_result {

  fileprivate var success: TList<Group>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Group>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getGroups_result, rhs: TalkService_getGroups_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getGroups_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getGroups_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getGroups_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getGroups_result {
    _ = try proto.readStructBegin()
    var success: TList<Group>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Group>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getGroups_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getHiddenContactMids_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getHiddenContactMids_args, rhs: TalkService_getHiddenContactMids_args) -> Bool {
  return true
}

extension TalkService_getHiddenContactMids_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getHiddenContactMids_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getHiddenContactMids_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getHiddenContactMids_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getHiddenContactMids_args()
  }

}



fileprivate final class TalkService_getHiddenContactMids_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getHiddenContactMids_result, rhs: TalkService_getHiddenContactMids_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getHiddenContactMids_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getHiddenContactMids_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getHiddenContactMids_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getHiddenContactMids_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getHiddenContactMids_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getIdentityIdentifier_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getIdentityIdentifier_args, rhs: TalkService_getIdentityIdentifier_args) -> Bool {
  return true
}

extension TalkService_getIdentityIdentifier_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getIdentityIdentifier_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getIdentityIdentifier_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getIdentityIdentifier_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getIdentityIdentifier_args()
  }

}



fileprivate final class TalkService_getIdentityIdentifier_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getIdentityIdentifier_result, rhs: TalkService_getIdentityIdentifier_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getIdentityIdentifier_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getIdentityIdentifier_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getIdentityIdentifier_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getIdentityIdentifier_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getIdentityIdentifier_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getLastAnnouncementIndex_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getLastAnnouncementIndex_args, rhs: TalkService_getLastAnnouncementIndex_args) -> Bool {
  return true
}

extension TalkService_getLastAnnouncementIndex_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getLastAnnouncementIndex_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getLastAnnouncementIndex_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getLastAnnouncementIndex_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getLastAnnouncementIndex_args()
  }

}



fileprivate final class TalkService_getLastAnnouncementIndex_result {

  fileprivate var success: Int32?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int32?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getLastAnnouncementIndex_result, rhs: TalkService_getLastAnnouncementIndex_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getLastAnnouncementIndex_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getLastAnnouncementIndex_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getLastAnnouncementIndex_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getLastAnnouncementIndex_result {
    _ = try proto.readStructBegin()
    var success: Int32?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getLastAnnouncementIndex_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getLastOpRevision_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getLastOpRevision_args, rhs: TalkService_getLastOpRevision_args) -> Bool {
  return true
}

extension TalkService_getLastOpRevision_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getLastOpRevision_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getLastOpRevision_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getLastOpRevision_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getLastOpRevision_args()
  }

}



fileprivate final class TalkService_getLastOpRevision_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getLastOpRevision_result, rhs: TalkService_getLastOpRevision_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getLastOpRevision_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getLastOpRevision_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getLastOpRevision_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getLastOpRevision_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getLastOpRevision_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessageBox_args {

  fileprivate var channelId: String

  fileprivate var messageBoxId: String

  fileprivate var lastMessagesCount: Int32


  fileprivate init(channelId: String, messageBoxId: String, lastMessagesCount: Int32) {
    self.channelId = channelId
    self.messageBoxId = messageBoxId
    self.lastMessagesCount = lastMessagesCount
  }

}

fileprivate func ==(lhs: TalkService_getMessageBox_args, rhs: TalkService_getMessageBox_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.messageBoxId == rhs.messageBoxId) &&
    (lhs.lastMessagesCount == rhs.lastMessagesCount)
}

extension TalkService_getMessageBox_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (messageBoxId.hashValue)
    result = prime &* result &+ (lastMessagesCount.hashValue)
    return result
  }

}

extension TalkService_getMessageBox_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 2, "messageBoxId": 3, "lastMessagesCount": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBox_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBox_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var messageBoxId: String!
    var lastMessagesCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           channelId = try String.read(from: proto)
        case (3, .string):           messageBoxId = try String.read(from: proto)
        case (4, .i32):             lastMessagesCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(messageBoxId, named: "messageBoxId")
    try proto.validateValue(lastMessagesCount, named: "lastMessagesCount")

    return TalkService_getMessageBox_args(channelId: channelId, messageBoxId: messageBoxId, lastMessagesCount: lastMessagesCount)
  }

}



fileprivate final class TalkService_getMessageBox_result {

  fileprivate var success: TMessageBox?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMessageBox?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessageBox_result, rhs: TalkService_getMessageBox_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessageBox_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessageBox_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBox_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBox_result {
    _ = try proto.readStructBegin()
    var success: TMessageBox?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try TMessageBox.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessageBox_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessageBoxCompactWrapUp_args {

  fileprivate var mid: String


  fileprivate init(mid: String) {
    self.mid = mid
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxCompactWrapUp_args, rhs: TalkService_getMessageBoxCompactWrapUp_args) -> Bool {
  return
    (lhs.mid == rhs.mid)
}

extension TalkService_getMessageBoxCompactWrapUp_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension TalkService_getMessageBoxCompactWrapUp_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["mid": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxCompactWrapUp_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxCompactWrapUp_args {
    _ = try proto.readStructBegin()
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")

    return TalkService_getMessageBoxCompactWrapUp_args(mid: mid)
  }

}



fileprivate final class TalkService_getMessageBoxCompactWrapUp_result {

  fileprivate var success: TMessageBoxWrapUp?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMessageBoxWrapUp?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxCompactWrapUp_result, rhs: TalkService_getMessageBoxCompactWrapUp_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessageBoxCompactWrapUp_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessageBoxCompactWrapUp_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxCompactWrapUp_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxCompactWrapUp_result {
    _ = try proto.readStructBegin()
    var success: TMessageBoxWrapUp?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try TMessageBoxWrapUp.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessageBoxCompactWrapUp_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessageBoxCompactWrapUpList_args {

  fileprivate var start: Int32

  fileprivate var messageBoxCount: Int32


  fileprivate init(start: Int32, messageBoxCount: Int32) {
    self.start = start
    self.messageBoxCount = messageBoxCount
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxCompactWrapUpList_args, rhs: TalkService_getMessageBoxCompactWrapUpList_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.messageBoxCount == rhs.messageBoxCount)
}

extension TalkService_getMessageBoxCompactWrapUpList_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (messageBoxCount.hashValue)
    return result
  }

}

extension TalkService_getMessageBoxCompactWrapUpList_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "messageBoxCount": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxCompactWrapUpList_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxCompactWrapUpList_args {
    _ = try proto.readStructBegin()
    var start: Int32!
    var messageBoxCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             start = try Int32.read(from: proto)
        case (3, .i32):             messageBoxCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(messageBoxCount, named: "messageBoxCount")

    return TalkService_getMessageBoxCompactWrapUpList_args(start: start, messageBoxCount: messageBoxCount)
  }

}



fileprivate final class TalkService_getMessageBoxCompactWrapUpList_result {

  fileprivate var success: TMessageBoxWrapUpResponse?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMessageBoxWrapUpResponse?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxCompactWrapUpList_result, rhs: TalkService_getMessageBoxCompactWrapUpList_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessageBoxCompactWrapUpList_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessageBoxCompactWrapUpList_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxCompactWrapUpList_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxCompactWrapUpList_result {
    _ = try proto.readStructBegin()
    var success: TMessageBoxWrapUpResponse?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try TMessageBoxWrapUpResponse.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessageBoxCompactWrapUpList_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessageBoxList_args {

  fileprivate var channelId: String

  fileprivate var lastMessagesCount: Int32


  fileprivate init(channelId: String, lastMessagesCount: Int32) {
    self.channelId = channelId
    self.lastMessagesCount = lastMessagesCount
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxList_args, rhs: TalkService_getMessageBoxList_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.lastMessagesCount == rhs.lastMessagesCount)
}

extension TalkService_getMessageBoxList_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (lastMessagesCount.hashValue)
    return result
  }

}

extension TalkService_getMessageBoxList_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 2, "lastMessagesCount": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxList_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxList_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var lastMessagesCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           channelId = try String.read(from: proto)
        case (3, .i32):             lastMessagesCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(lastMessagesCount, named: "lastMessagesCount")

    return TalkService_getMessageBoxList_args(channelId: channelId, lastMessagesCount: lastMessagesCount)
  }

}



fileprivate final class TalkService_getMessageBoxList_result {

  fileprivate var success: TList<TMessageBox>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<TMessageBox>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxList_result, rhs: TalkService_getMessageBoxList_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessageBoxList_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessageBoxList_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxList_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxList_result {
    _ = try proto.readStructBegin()
    var success: TList<TMessageBox>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<TMessageBox>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessageBoxList_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessageBoxListByStatus_args {

  fileprivate var channelId: String

  fileprivate var lastMessagesCount: Int32

  fileprivate var status: Int32


  fileprivate init(channelId: String, lastMessagesCount: Int32, status: Int32) {
    self.channelId = channelId
    self.lastMessagesCount = lastMessagesCount
    self.status = status
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxListByStatus_args, rhs: TalkService_getMessageBoxListByStatus_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.lastMessagesCount == rhs.lastMessagesCount) &&
    (lhs.status == rhs.status)
}

extension TalkService_getMessageBoxListByStatus_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (lastMessagesCount.hashValue)
    result = prime &* result &+ (status.hashValue)
    return result
  }

}

extension TalkService_getMessageBoxListByStatus_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 2, "lastMessagesCount": 3, "status": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxListByStatus_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxListByStatus_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var lastMessagesCount: Int32!
    var status: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           channelId = try String.read(from: proto)
        case (3, .i32):             lastMessagesCount = try Int32.read(from: proto)
        case (4, .i32):             status = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(lastMessagesCount, named: "lastMessagesCount")
    try proto.validateValue(status, named: "status")

    return TalkService_getMessageBoxListByStatus_args(channelId: channelId, lastMessagesCount: lastMessagesCount, status: status)
  }

}



fileprivate final class TalkService_getMessageBoxListByStatus_result {

  fileprivate var success: TList<TMessageBox>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<TMessageBox>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxListByStatus_result, rhs: TalkService_getMessageBoxListByStatus_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessageBoxListByStatus_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessageBoxListByStatus_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxListByStatus_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxListByStatus_result {
    _ = try proto.readStructBegin()
    var success: TList<TMessageBox>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<TMessageBox>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessageBoxListByStatus_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessageBoxWrapUp_args {

  fileprivate var mid: String


  fileprivate init(mid: String) {
    self.mid = mid
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxWrapUp_args, rhs: TalkService_getMessageBoxWrapUp_args) -> Bool {
  return
    (lhs.mid == rhs.mid)
}

extension TalkService_getMessageBoxWrapUp_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension TalkService_getMessageBoxWrapUp_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["mid": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxWrapUp_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxWrapUp_args {
    _ = try proto.readStructBegin()
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")

    return TalkService_getMessageBoxWrapUp_args(mid: mid)
  }

}



fileprivate final class TalkService_getMessageBoxWrapUp_result {

  fileprivate var success: TMessageBoxWrapUp?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMessageBoxWrapUp?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxWrapUp_result, rhs: TalkService_getMessageBoxWrapUp_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessageBoxWrapUp_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessageBoxWrapUp_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxWrapUp_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxWrapUp_result {
    _ = try proto.readStructBegin()
    var success: TMessageBoxWrapUp?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try TMessageBoxWrapUp.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessageBoxWrapUp_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessageBoxWrapUpList_args {

  fileprivate var start: Int32

  fileprivate var messageBoxCount: Int32


  fileprivate init(start: Int32, messageBoxCount: Int32) {
    self.start = start
    self.messageBoxCount = messageBoxCount
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxWrapUpList_args, rhs: TalkService_getMessageBoxWrapUpList_args) -> Bool {
  return
    (lhs.start == rhs.start) &&
    (lhs.messageBoxCount == rhs.messageBoxCount)
}

extension TalkService_getMessageBoxWrapUpList_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (start.hashValue)
    result = prime &* result &+ (messageBoxCount.hashValue)
    return result
  }

}

extension TalkService_getMessageBoxWrapUpList_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["start": 2, "messageBoxCount": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxWrapUpList_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxWrapUpList_args {
    _ = try proto.readStructBegin()
    var start: Int32!
    var messageBoxCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             start = try Int32.read(from: proto)
        case (3, .i32):             messageBoxCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(start, named: "start")
    try proto.validateValue(messageBoxCount, named: "messageBoxCount")

    return TalkService_getMessageBoxWrapUpList_args(start: start, messageBoxCount: messageBoxCount)
  }

}



fileprivate final class TalkService_getMessageBoxWrapUpList_result {

  fileprivate var success: TMessageBoxWrapUpResponse?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMessageBoxWrapUpResponse?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessageBoxWrapUpList_result, rhs: TalkService_getMessageBoxWrapUpList_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessageBoxWrapUpList_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessageBoxWrapUpList_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessageBoxWrapUpList_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessageBoxWrapUpList_result {
    _ = try proto.readStructBegin()
    var success: TMessageBoxWrapUpResponse?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try TMessageBoxWrapUpResponse.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessageBoxWrapUpList_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getMessagesBySequenceNumber_args {

  fileprivate var channelId: String

  fileprivate var messageBoxId: String

  fileprivate var startSeq: Int64

  fileprivate var endSeq: Int64


  fileprivate init(channelId: String, messageBoxId: String, startSeq: Int64, endSeq: Int64) {
    self.channelId = channelId
    self.messageBoxId = messageBoxId
    self.startSeq = startSeq
    self.endSeq = endSeq
  }

}

fileprivate func ==(lhs: TalkService_getMessagesBySequenceNumber_args, rhs: TalkService_getMessagesBySequenceNumber_args) -> Bool {
  return
    (lhs.channelId == rhs.channelId) &&
    (lhs.messageBoxId == rhs.messageBoxId) &&
    (lhs.startSeq == rhs.startSeq) &&
    (lhs.endSeq == rhs.endSeq)
}

extension TalkService_getMessagesBySequenceNumber_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (channelId.hashValue)
    result = prime &* result &+ (messageBoxId.hashValue)
    result = prime &* result &+ (startSeq.hashValue)
    result = prime &* result &+ (endSeq.hashValue)
    return result
  }

}

extension TalkService_getMessagesBySequenceNumber_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["channelId": 2, "messageBoxId": 3, "startSeq": 4, "endSeq": 5, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessagesBySequenceNumber_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessagesBySequenceNumber_args {
    _ = try proto.readStructBegin()
    var channelId: String!
    var messageBoxId: String!
    var startSeq: Int64!
    var endSeq: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           channelId = try String.read(from: proto)
        case (3, .string):           messageBoxId = try String.read(from: proto)
        case (4, .i64):             startSeq = try Int64.read(from: proto)
        case (5, .i64):             endSeq = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(channelId, named: "channelId")
    try proto.validateValue(messageBoxId, named: "messageBoxId")
    try proto.validateValue(startSeq, named: "startSeq")
    try proto.validateValue(endSeq, named: "endSeq")

    return TalkService_getMessagesBySequenceNumber_args(channelId: channelId, messageBoxId: messageBoxId, startSeq: startSeq, endSeq: endSeq)
  }

}



fileprivate final class TalkService_getMessagesBySequenceNumber_result {

  fileprivate var success: TList<Message>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Message>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getMessagesBySequenceNumber_result, rhs: TalkService_getMessagesBySequenceNumber_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getMessagesBySequenceNumber_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getMessagesBySequenceNumber_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getMessagesBySequenceNumber_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getMessagesBySequenceNumber_result {
    _ = try proto.readStructBegin()
    var success: TList<Message>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Message>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getMessagesBySequenceNumber_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getNextMessages_args {

  fileprivate var messageBoxId: String

  fileprivate var startSeq: Int64

  fileprivate var messagesCount: Int32


  fileprivate init(messageBoxId: String, startSeq: Int64, messagesCount: Int32) {
    self.messageBoxId = messageBoxId
    self.startSeq = startSeq
    self.messagesCount = messagesCount
  }

}

fileprivate func ==(lhs: TalkService_getNextMessages_args, rhs: TalkService_getNextMessages_args) -> Bool {
  return
    (lhs.messageBoxId == rhs.messageBoxId) &&
    (lhs.startSeq == rhs.startSeq) &&
    (lhs.messagesCount == rhs.messagesCount)
}

extension TalkService_getNextMessages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (messageBoxId.hashValue)
    result = prime &* result &+ (startSeq.hashValue)
    result = prime &* result &+ (messagesCount.hashValue)
    return result
  }

}

extension TalkService_getNextMessages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["messageBoxId": 2, "startSeq": 3, "messagesCount": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_getNextMessages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getNextMessages_args {
    _ = try proto.readStructBegin()
    var messageBoxId: String!
    var startSeq: Int64!
    var messagesCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           messageBoxId = try String.read(from: proto)
        case (3, .i64):             startSeq = try Int64.read(from: proto)
        case (4, .i32):             messagesCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(messageBoxId, named: "messageBoxId")
    try proto.validateValue(startSeq, named: "startSeq")
    try proto.validateValue(messagesCount, named: "messagesCount")

    return TalkService_getNextMessages_args(messageBoxId: messageBoxId, startSeq: startSeq, messagesCount: messagesCount)
  }

}



fileprivate final class TalkService_getNextMessages_result {

  fileprivate var success: TList<Message>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Message>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getNextMessages_result, rhs: TalkService_getNextMessages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getNextMessages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getNextMessages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getNextMessages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getNextMessages_result {
    _ = try proto.readStructBegin()
    var success: TList<Message>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Message>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getNextMessages_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getNotificationPolicy_args {

  fileprivate var carrier: CarrierCode


  fileprivate init(carrier: CarrierCode) {
    self.carrier = carrier
  }

}

fileprivate func ==(lhs: TalkService_getNotificationPolicy_args, rhs: TalkService_getNotificationPolicy_args) -> Bool {
  return
    (lhs.carrier == rhs.carrier)
}

extension TalkService_getNotificationPolicy_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (carrier.hashValue)
    return result
  }

}

extension TalkService_getNotificationPolicy_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["carrier": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getNotificationPolicy_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getNotificationPolicy_args {
    _ = try proto.readStructBegin()
    var carrier: CarrierCode!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             carrier = try CarrierCode.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(carrier, named: "carrier")

    return TalkService_getNotificationPolicy_args(carrier: carrier)
  }

}



fileprivate final class TalkService_getNotificationPolicy_result {

  fileprivate var success: TList<NotificationType>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<NotificationType>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getNotificationPolicy_result, rhs: TalkService_getNotificationPolicy_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getNotificationPolicy_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getNotificationPolicy_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getNotificationPolicy_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getNotificationPolicy_result {
    _ = try proto.readStructBegin()
    var success: TList<NotificationType>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<NotificationType>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getNotificationPolicy_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getPreviousMessages_args {

  fileprivate var messageBoxId: String

  fileprivate var endSeq: Int64

  fileprivate var messagesCount: Int32


  fileprivate init(messageBoxId: String, endSeq: Int64, messagesCount: Int32) {
    self.messageBoxId = messageBoxId
    self.endSeq = endSeq
    self.messagesCount = messagesCount
  }

}

fileprivate func ==(lhs: TalkService_getPreviousMessages_args, rhs: TalkService_getPreviousMessages_args) -> Bool {
  return
    (lhs.messageBoxId == rhs.messageBoxId) &&
    (lhs.endSeq == rhs.endSeq) &&
    (lhs.messagesCount == rhs.messagesCount)
}

extension TalkService_getPreviousMessages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (messageBoxId.hashValue)
    result = prime &* result &+ (endSeq.hashValue)
    result = prime &* result &+ (messagesCount.hashValue)
    return result
  }

}

extension TalkService_getPreviousMessages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["messageBoxId": 2, "endSeq": 3, "messagesCount": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_getPreviousMessages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getPreviousMessages_args {
    _ = try proto.readStructBegin()
    var messageBoxId: String!
    var endSeq: Int64!
    var messagesCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           messageBoxId = try String.read(from: proto)
        case (3, .i64):             endSeq = try Int64.read(from: proto)
        case (4, .i32):             messagesCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(messageBoxId, named: "messageBoxId")
    try proto.validateValue(endSeq, named: "endSeq")
    try proto.validateValue(messagesCount, named: "messagesCount")

    return TalkService_getPreviousMessages_args(messageBoxId: messageBoxId, endSeq: endSeq, messagesCount: messagesCount)
  }

}



fileprivate final class TalkService_getPreviousMessages_result {

  fileprivate var success: TList<Message>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Message>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getPreviousMessages_result, rhs: TalkService_getPreviousMessages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getPreviousMessages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getPreviousMessages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getPreviousMessages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getPreviousMessages_result {
    _ = try proto.readStructBegin()
    var success: TList<Message>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Message>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getPreviousMessages_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getProfile_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getProfile_args, rhs: TalkService_getProfile_args) -> Bool {
  return true
}

extension TalkService_getProfile_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getProfile_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getProfile_args()
  }

}



fileprivate final class TalkService_getProfile_result {

  fileprivate var success: Profile?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Profile?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getProfile_result, rhs: TalkService_getProfile_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getProfile_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getProfile_result {
    _ = try proto.readStructBegin()
    var success: Profile?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Profile.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getProfile_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getProximityMatchCandidateList_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_getProximityMatchCandidateList_args, rhs: TalkService_getProximityMatchCandidateList_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_getProximityMatchCandidateList_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_getProximityMatchCandidateList_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getProximityMatchCandidateList_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getProximityMatchCandidateList_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_getProximityMatchCandidateList_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_getProximityMatchCandidateList_result {

  fileprivate var success: ProximityMatchCandidateResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: ProximityMatchCandidateResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getProximityMatchCandidateList_result, rhs: TalkService_getProximityMatchCandidateList_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getProximityMatchCandidateList_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getProximityMatchCandidateList_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getProximityMatchCandidateList_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getProximityMatchCandidateList_result {
    _ = try proto.readStructBegin()
    var success: ProximityMatchCandidateResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ProximityMatchCandidateResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getProximityMatchCandidateList_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getProximityMatchCandidates_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_getProximityMatchCandidates_args, rhs: TalkService_getProximityMatchCandidates_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_getProximityMatchCandidates_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_getProximityMatchCandidates_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getProximityMatchCandidates_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getProximityMatchCandidates_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_getProximityMatchCandidates_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_getProximityMatchCandidates_result {

  fileprivate var success: TSet<Contact>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TSet<Contact>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getProximityMatchCandidates_result, rhs: TalkService_getProximityMatchCandidates_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getProximityMatchCandidates_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getProximityMatchCandidates_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getProximityMatchCandidates_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getProximityMatchCandidates_result {
    _ = try proto.readStructBegin()
    var success: TSet<Contact>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .set):             success = try TSet<Contact>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getProximityMatchCandidates_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getRecentMessages_args {

  fileprivate var messageBoxId: String

  fileprivate var messagesCount: Int32


  fileprivate init(messageBoxId: String, messagesCount: Int32) {
    self.messageBoxId = messageBoxId
    self.messagesCount = messagesCount
  }

}

fileprivate func ==(lhs: TalkService_getRecentMessages_args, rhs: TalkService_getRecentMessages_args) -> Bool {
  return
    (lhs.messageBoxId == rhs.messageBoxId) &&
    (lhs.messagesCount == rhs.messagesCount)
}

extension TalkService_getRecentMessages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (messageBoxId.hashValue)
    result = prime &* result &+ (messagesCount.hashValue)
    return result
  }

}

extension TalkService_getRecentMessages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["messageBoxId": 2, "messagesCount": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_getRecentMessages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRecentMessages_args {
    _ = try proto.readStructBegin()
    var messageBoxId: String!
    var messagesCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           messageBoxId = try String.read(from: proto)
        case (3, .i32):             messagesCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(messageBoxId, named: "messageBoxId")
    try proto.validateValue(messagesCount, named: "messagesCount")

    return TalkService_getRecentMessages_args(messageBoxId: messageBoxId, messagesCount: messagesCount)
  }

}



fileprivate final class TalkService_getRecentMessages_result {

  fileprivate var success: TList<Message>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<Message>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getRecentMessages_result, rhs: TalkService_getRecentMessages_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getRecentMessages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getRecentMessages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getRecentMessages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRecentMessages_result {
    _ = try proto.readStructBegin()
    var success: TList<Message>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<Message>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getRecentMessages_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getRecommendationIds_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getRecommendationIds_args, rhs: TalkService_getRecommendationIds_args) -> Bool {
  return true
}

extension TalkService_getRecommendationIds_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getRecommendationIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getRecommendationIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRecommendationIds_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getRecommendationIds_args()
  }

}



fileprivate final class TalkService_getRecommendationIds_result {

  fileprivate var success: TList<String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getRecommendationIds_result, rhs: TalkService_getRecommendationIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getRecommendationIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getRecommendationIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getRecommendationIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRecommendationIds_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getRecommendationIds_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getRoom_args {

  fileprivate var roomId: String


  fileprivate init(roomId: String) {
    self.roomId = roomId
  }

}

fileprivate func ==(lhs: TalkService_getRoom_args, rhs: TalkService_getRoom_args) -> Bool {
  return
    (lhs.roomId == rhs.roomId)
}

extension TalkService_getRoom_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (roomId.hashValue)
    return result
  }

}

extension TalkService_getRoom_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["roomId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getRoom_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRoom_args {
    _ = try proto.readStructBegin()
    var roomId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           roomId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(roomId, named: "roomId")

    return TalkService_getRoom_args(roomId: roomId)
  }

}



fileprivate final class TalkService_getRoom_result {

  fileprivate var success: Room?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Room?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getRoom_result, rhs: TalkService_getRoom_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getRoom_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getRoom_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getRoom_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRoom_result {
    _ = try proto.readStructBegin()
    var success: Room?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Room.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getRoom_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getRSAKeyInfo_args {

  fileprivate var provider: IdentityProvider


  fileprivate init(provider: IdentityProvider) {
    self.provider = provider
  }

}

fileprivate func ==(lhs: TalkService_getRSAKeyInfo_args, rhs: TalkService_getRSAKeyInfo_args) -> Bool {
  return
    (lhs.provider == rhs.provider)
}

extension TalkService_getRSAKeyInfo_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (provider.hashValue)
    return result
  }

}

extension TalkService_getRSAKeyInfo_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["provider": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getRSAKeyInfo_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRSAKeyInfo_args {
    _ = try proto.readStructBegin()
    var provider: IdentityProvider!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             provider = try IdentityProvider.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(provider, named: "provider")

    return TalkService_getRSAKeyInfo_args(provider: provider)
  }

}



fileprivate final class TalkService_getRSAKeyInfo_result {

  fileprivate var success: RSAKey?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: RSAKey?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getRSAKeyInfo_result, rhs: TalkService_getRSAKeyInfo_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getRSAKeyInfo_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getRSAKeyInfo_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getRSAKeyInfo_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getRSAKeyInfo_result {
    _ = try proto.readStructBegin()
    var success: RSAKey?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try RSAKey.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getRSAKeyInfo_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getServerTime_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getServerTime_args, rhs: TalkService_getServerTime_args) -> Bool {
  return true
}

extension TalkService_getServerTime_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getServerTime_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getServerTime_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getServerTime_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getServerTime_args()
  }

}



fileprivate final class TalkService_getServerTime_result {

  fileprivate var success: Int64?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int64?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getServerTime_result, rhs: TalkService_getServerTime_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getServerTime_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getServerTime_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getServerTime_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getServerTime_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getServerTime_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getSessions_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getSessions_args, rhs: TalkService_getSessions_args) -> Bool {
  return true
}

extension TalkService_getSessions_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getSessions_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getSessions_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSessions_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getSessions_args()
  }

}



fileprivate final class TalkService_getSessions_result {

  fileprivate var success: TList<LoginSession>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<LoginSession>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getSessions_result, rhs: TalkService_getSessions_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getSessions_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getSessions_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getSessions_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSessions_result {
    _ = try proto.readStructBegin()
    var success: TList<LoginSession>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<LoginSession>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getSessions_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getSettings_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getSettings_args, rhs: TalkService_getSettings_args) -> Bool {
  return true
}

extension TalkService_getSettings_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getSettings_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getSettings_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSettings_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getSettings_args()
  }

}



fileprivate final class TalkService_getSettings_result {

  fileprivate var success: Settings?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Settings?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getSettings_result, rhs: TalkService_getSettings_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getSettings_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getSettings_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getSettings_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSettings_result {
    _ = try proto.readStructBegin()
    var success: Settings?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Settings.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getSettings_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getSettingsAttributes_args {

  fileprivate var attrBitset: Int32


  fileprivate init(attrBitset: Int32) {
    self.attrBitset = attrBitset
  }

}

fileprivate func ==(lhs: TalkService_getSettingsAttributes_args, rhs: TalkService_getSettingsAttributes_args) -> Bool {
  return
    (lhs.attrBitset == rhs.attrBitset)
}

extension TalkService_getSettingsAttributes_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (attrBitset.hashValue)
    return result
  }

}

extension TalkService_getSettingsAttributes_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["attrBitset": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getSettingsAttributes_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSettingsAttributes_args {
    _ = try proto.readStructBegin()
    var attrBitset: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             attrBitset = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(attrBitset, named: "attrBitset")

    return TalkService_getSettingsAttributes_args(attrBitset: attrBitset)
  }

}



fileprivate final class TalkService_getSettingsAttributes_result {

  fileprivate var success: Settings?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Settings?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getSettingsAttributes_result, rhs: TalkService_getSettingsAttributes_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getSettingsAttributes_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getSettingsAttributes_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getSettingsAttributes_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSettingsAttributes_result {
    _ = try proto.readStructBegin()
    var success: Settings?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Settings.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getSettingsAttributes_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getSystemConfiguration_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getSystemConfiguration_args, rhs: TalkService_getSystemConfiguration_args) -> Bool {
  return true
}

extension TalkService_getSystemConfiguration_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getSystemConfiguration_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getSystemConfiguration_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSystemConfiguration_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getSystemConfiguration_args()
  }

}



fileprivate final class TalkService_getSystemConfiguration_result {

  fileprivate var success: SystemConfiguration?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: SystemConfiguration?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getSystemConfiguration_result, rhs: TalkService_getSystemConfiguration_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getSystemConfiguration_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getSystemConfiguration_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getSystemConfiguration_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getSystemConfiguration_result {
    _ = try proto.readStructBegin()
    var success: SystemConfiguration?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SystemConfiguration.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getSystemConfiguration_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getUserTicket_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_getUserTicket_args, rhs: TalkService_getUserTicket_args) -> Bool {
  return true
}

extension TalkService_getUserTicket_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_getUserTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_getUserTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getUserTicket_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getUserTicket_args()
  }

}



fileprivate final class TalkService_getUserTicket_result {

  fileprivate var success: Ticket?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Ticket?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getUserTicket_result, rhs: TalkService_getUserTicket_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getUserTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getUserTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getUserTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getUserTicket_result {
    _ = try proto.readStructBegin()
    var success: Ticket?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Ticket.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getUserTicket_result(success: success, e: e)
  }

}



fileprivate final class TalkService_getWapInvitation_args {

  fileprivate var invitationHash: String


  fileprivate init(invitationHash: String) {
    self.invitationHash = invitationHash
  }

}

fileprivate func ==(lhs: TalkService_getWapInvitation_args, rhs: TalkService_getWapInvitation_args) -> Bool {
  return
    (lhs.invitationHash == rhs.invitationHash)
}

extension TalkService_getWapInvitation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (invitationHash.hashValue)
    return result
  }

}

extension TalkService_getWapInvitation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["invitationHash": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_getWapInvitation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getWapInvitation_args {
    _ = try proto.readStructBegin()
    var invitationHash: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           invitationHash = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(invitationHash, named: "invitationHash")

    return TalkService_getWapInvitation_args(invitationHash: invitationHash)
  }

}



fileprivate final class TalkService_getWapInvitation_result {

  fileprivate var success: WapInvitation?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: WapInvitation?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_getWapInvitation_result, rhs: TalkService_getWapInvitation_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_getWapInvitation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_getWapInvitation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_getWapInvitation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_getWapInvitation_result {
    _ = try proto.readStructBegin()
    var success: WapInvitation?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try WapInvitation.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_getWapInvitation_result(success: success, e: e)
  }

}



fileprivate final class TalkService_invalidateUserTicket_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_invalidateUserTicket_args, rhs: TalkService_invalidateUserTicket_args) -> Bool {
  return true
}

extension TalkService_invalidateUserTicket_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_invalidateUserTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_invalidateUserTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_invalidateUserTicket_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_invalidateUserTicket_args()
  }

}



fileprivate final class TalkService_invalidateUserTicket_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_invalidateUserTicket_result, rhs: TalkService_invalidateUserTicket_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_invalidateUserTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_invalidateUserTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_invalidateUserTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_invalidateUserTicket_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_invalidateUserTicket_result(e: e)
  }

}



fileprivate final class TalkService_inviteFriendsBySms_args {

  fileprivate var phoneNumberList: TList<String>


  fileprivate init(phoneNumberList: TList<String>) {
    self.phoneNumberList = phoneNumberList
  }

}

fileprivate func ==(lhs: TalkService_inviteFriendsBySms_args, rhs: TalkService_inviteFriendsBySms_args) -> Bool {
  return
    (lhs.phoneNumberList == rhs.phoneNumberList)
}

extension TalkService_inviteFriendsBySms_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (phoneNumberList.hashValue)
    return result
  }

}

extension TalkService_inviteFriendsBySms_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["phoneNumberList": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteFriendsBySms_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteFriendsBySms_args {
    _ = try proto.readStructBegin()
    var phoneNumberList: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .list):            phoneNumberList = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(phoneNumberList, named: "phoneNumberList")

    return TalkService_inviteFriendsBySms_args(phoneNumberList: phoneNumberList)
  }

}



fileprivate final class TalkService_inviteFriendsBySms_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_inviteFriendsBySms_result, rhs: TalkService_inviteFriendsBySms_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_inviteFriendsBySms_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_inviteFriendsBySms_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteFriendsBySms_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteFriendsBySms_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_inviteFriendsBySms_result(e: e)
  }

}



fileprivate final class TalkService_inviteIntoGroup_args {

  fileprivate var reqSeq: Int32

  fileprivate var groupId: String

  fileprivate var contactIds: TList<String>


  fileprivate init(reqSeq: Int32, groupId: String, contactIds: TList<String>) {
    self.reqSeq = reqSeq
    self.groupId = groupId
    self.contactIds = contactIds
  }

}

fileprivate func ==(lhs: TalkService_inviteIntoGroup_args, rhs: TalkService_inviteIntoGroup_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.groupId == rhs.groupId) &&
    (lhs.contactIds == rhs.contactIds)
}

extension TalkService_inviteIntoGroup_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (groupId.hashValue)
    result = prime &* result &+ (contactIds.hashValue)
    return result
  }

}

extension TalkService_inviteIntoGroup_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "groupId": 2, "contactIds": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteIntoGroup_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteIntoGroup_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var groupId: String!
    var contactIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           groupId = try String.read(from: proto)
        case (3, .list):            contactIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(groupId, named: "groupId")
    try proto.validateValue(contactIds, named: "contactIds")

    return TalkService_inviteIntoGroup_args(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
  }

}



fileprivate final class TalkService_inviteIntoGroup_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_inviteIntoGroup_result, rhs: TalkService_inviteIntoGroup_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_inviteIntoGroup_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_inviteIntoGroup_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteIntoGroup_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteIntoGroup_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_inviteIntoGroup_result(e: e)
  }

}



fileprivate final class TalkService_inviteIntoRoom_args {

  fileprivate var reqSeq: Int32

  fileprivate var roomId: String

  fileprivate var contactIds: TList<String>


  fileprivate init(reqSeq: Int32, roomId: String, contactIds: TList<String>) {
    self.reqSeq = reqSeq
    self.roomId = roomId
    self.contactIds = contactIds
  }

}

fileprivate func ==(lhs: TalkService_inviteIntoRoom_args, rhs: TalkService_inviteIntoRoom_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.roomId == rhs.roomId) &&
    (lhs.contactIds == rhs.contactIds)
}

extension TalkService_inviteIntoRoom_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (roomId.hashValue)
    result = prime &* result &+ (contactIds.hashValue)
    return result
  }

}

extension TalkService_inviteIntoRoom_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "roomId": 2, "contactIds": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteIntoRoom_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteIntoRoom_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var roomId: String!
    var contactIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           roomId = try String.read(from: proto)
        case (3, .list):            contactIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(roomId, named: "roomId")
    try proto.validateValue(contactIds, named: "contactIds")

    return TalkService_inviteIntoRoom_args(reqSeq: reqSeq, roomId: roomId, contactIds: contactIds)
  }

}



fileprivate final class TalkService_inviteIntoRoom_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_inviteIntoRoom_result, rhs: TalkService_inviteIntoRoom_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_inviteIntoRoom_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_inviteIntoRoom_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteIntoRoom_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteIntoRoom_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_inviteIntoRoom_result(e: e)
  }

}



fileprivate final class TalkService_inviteViaEmail_args {

  fileprivate var reqSeq: Int32

  fileprivate var email: String

  fileprivate var name: String


  fileprivate init(reqSeq: Int32, email: String, name: String) {
    self.reqSeq = reqSeq
    self.email = email
    self.name = name
  }

}

fileprivate func ==(lhs: TalkService_inviteViaEmail_args, rhs: TalkService_inviteViaEmail_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.email == rhs.email) &&
    (lhs.name == rhs.name)
}

extension TalkService_inviteViaEmail_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (email.hashValue)
    result = prime &* result &+ (name.hashValue)
    return result
  }

}

extension TalkService_inviteViaEmail_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "email": 2, "name": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteViaEmail_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteViaEmail_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var email: String!
    var name: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           email = try String.read(from: proto)
        case (3, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(email, named: "email")
    try proto.validateValue(name, named: "name")

    return TalkService_inviteViaEmail_args(reqSeq: reqSeq, email: email, name: name)
  }

}



fileprivate final class TalkService_inviteViaEmail_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_inviteViaEmail_result, rhs: TalkService_inviteViaEmail_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_inviteViaEmail_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_inviteViaEmail_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_inviteViaEmail_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_inviteViaEmail_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_inviteViaEmail_result(e: e)
  }

}



fileprivate final class TalkService_isIdentityIdentifierAvailable_args {

  fileprivate var identifier: String

  fileprivate var provider: IdentityProvider


  fileprivate init(provider: IdentityProvider, identifier: String) {
    self.provider = provider
    self.identifier = identifier
  }

}

fileprivate func ==(lhs: TalkService_isIdentityIdentifierAvailable_args, rhs: TalkService_isIdentityIdentifierAvailable_args) -> Bool {
  return
    (lhs.provider == rhs.provider) &&
    (lhs.identifier == rhs.identifier)
}

extension TalkService_isIdentityIdentifierAvailable_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    return result
  }

}

extension TalkService_isIdentityIdentifierAvailable_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["provider": 3, "identifier": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_isIdentityIdentifierAvailable_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_isIdentityIdentifierAvailable_args {
    _ = try proto.readStructBegin()
    var provider: IdentityProvider!
    var identifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .i32):             provider = try IdentityProvider.read(from: proto)
        case (2, .string):           identifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(identifier, named: "identifier")

    return TalkService_isIdentityIdentifierAvailable_args(provider: provider, identifier: identifier)
  }

}



fileprivate final class TalkService_isIdentityIdentifierAvailable_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_isIdentityIdentifierAvailable_result, rhs: TalkService_isIdentityIdentifierAvailable_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_isIdentityIdentifierAvailable_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_isIdentityIdentifierAvailable_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_isIdentityIdentifierAvailable_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_isIdentityIdentifierAvailable_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_isIdentityIdentifierAvailable_result(success: success, e: e)
  }

}



fileprivate final class TalkService_isUseridAvailable_args {

  fileprivate var userid: String


  fileprivate init(userid: String) {
    self.userid = userid
  }

}

fileprivate func ==(lhs: TalkService_isUseridAvailable_args, rhs: TalkService_isUseridAvailable_args) -> Bool {
  return
    (lhs.userid == rhs.userid)
}

extension TalkService_isUseridAvailable_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (userid.hashValue)
    return result
  }

}

extension TalkService_isUseridAvailable_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["userid": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_isUseridAvailable_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_isUseridAvailable_args {
    _ = try proto.readStructBegin()
    var userid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           userid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(userid, named: "userid")

    return TalkService_isUseridAvailable_args(userid: userid)
  }

}



fileprivate final class TalkService_isUseridAvailable_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_isUseridAvailable_result, rhs: TalkService_isUseridAvailable_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_isUseridAvailable_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_isUseridAvailable_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_isUseridAvailable_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_isUseridAvailable_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_isUseridAvailable_result(success: success, e: e)
  }

}



fileprivate final class TalkService_kickoutFromGroup_args {

  fileprivate var reqSeq: Int32

  fileprivate var groupId: String

  fileprivate var contactIds: TList<String>


  fileprivate init(reqSeq: Int32, groupId: String, contactIds: TList<String>) {
    self.reqSeq = reqSeq
    self.groupId = groupId
    self.contactIds = contactIds
  }

}

fileprivate func ==(lhs: TalkService_kickoutFromGroup_args, rhs: TalkService_kickoutFromGroup_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.groupId == rhs.groupId) &&
    (lhs.contactIds == rhs.contactIds)
}

extension TalkService_kickoutFromGroup_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (groupId.hashValue)
    result = prime &* result &+ (contactIds.hashValue)
    return result
  }

}

extension TalkService_kickoutFromGroup_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "groupId": 2, "contactIds": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_kickoutFromGroup_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_kickoutFromGroup_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var groupId: String!
    var contactIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           groupId = try String.read(from: proto)
        case (3, .list):            contactIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(groupId, named: "groupId")
    try proto.validateValue(contactIds, named: "contactIds")

    return TalkService_kickoutFromGroup_args(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
  }

}



fileprivate final class TalkService_kickoutFromGroup_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_kickoutFromGroup_result, rhs: TalkService_kickoutFromGroup_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_kickoutFromGroup_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_kickoutFromGroup_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_kickoutFromGroup_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_kickoutFromGroup_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_kickoutFromGroup_result(e: e)
  }

}



fileprivate final class TalkService_leaveGroup_args {

  fileprivate var reqSeq: Int32

  fileprivate var groupId: String


  fileprivate init(reqSeq: Int32, groupId: String) {
    self.reqSeq = reqSeq
    self.groupId = groupId
  }

}

fileprivate func ==(lhs: TalkService_leaveGroup_args, rhs: TalkService_leaveGroup_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.groupId == rhs.groupId)
}

extension TalkService_leaveGroup_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (groupId.hashValue)
    return result
  }

}

extension TalkService_leaveGroup_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "groupId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_leaveGroup_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_leaveGroup_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var groupId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           groupId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(groupId, named: "groupId")

    return TalkService_leaveGroup_args(reqSeq: reqSeq, groupId: groupId)
  }

}



fileprivate final class TalkService_leaveGroup_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_leaveGroup_result, rhs: TalkService_leaveGroup_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_leaveGroup_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_leaveGroup_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_leaveGroup_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_leaveGroup_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_leaveGroup_result(e: e)
  }

}



fileprivate final class TalkService_leaveRoom_args {

  fileprivate var reqSeq: Int32

  fileprivate var roomId: String


  fileprivate init(reqSeq: Int32, roomId: String) {
    self.reqSeq = reqSeq
    self.roomId = roomId
  }

}

fileprivate func ==(lhs: TalkService_leaveRoom_args, rhs: TalkService_leaveRoom_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.roomId == rhs.roomId)
}

extension TalkService_leaveRoom_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (roomId.hashValue)
    return result
  }

}

extension TalkService_leaveRoom_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "roomId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_leaveRoom_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_leaveRoom_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var roomId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           roomId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(roomId, named: "roomId")

    return TalkService_leaveRoom_args(reqSeq: reqSeq, roomId: roomId)
  }

}



fileprivate final class TalkService_leaveRoom_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_leaveRoom_result, rhs: TalkService_leaveRoom_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_leaveRoom_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_leaveRoom_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_leaveRoom_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_leaveRoom_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_leaveRoom_result(e: e)
  }

}



fileprivate final class TalkService_loginWithIdentityCredential_args {

  fileprivate var identifier: String

  fileprivate var password: String

  fileprivate var keepLoggedIn: Bool

  fileprivate var accessLocation: String

  fileprivate var systemName: String

  fileprivate var identityProvider: IdentityProvider

  fileprivate var certificate: String


  fileprivate init(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) {
    self.identityProvider = identityProvider
    self.identifier = identifier
    self.password = password
    self.keepLoggedIn = keepLoggedIn
    self.accessLocation = accessLocation
    self.systemName = systemName
    self.certificate = certificate
  }

}

fileprivate func ==(lhs: TalkService_loginWithIdentityCredential_args, rhs: TalkService_loginWithIdentityCredential_args) -> Bool {
  return
    (lhs.identityProvider == rhs.identityProvider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.password == rhs.password) &&
    (lhs.keepLoggedIn == rhs.keepLoggedIn) &&
    (lhs.accessLocation == rhs.accessLocation) &&
    (lhs.systemName == rhs.systemName) &&
    (lhs.certificate == rhs.certificate)
}

extension TalkService_loginWithIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (identityProvider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (password.hashValue)
    result = prime &* result &+ (keepLoggedIn.hashValue)
    result = prime &* result &+ (accessLocation.hashValue)
    result = prime &* result &+ (systemName.hashValue)
    result = prime &* result &+ (certificate.hashValue)
    return result
  }

}

extension TalkService_loginWithIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["identityProvider": 8, "identifier": 3, "password": 4, "keepLoggedIn": 5, "accessLocation": 6, "systemName": 7, "certificate": 9, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithIdentityCredential_args {
    _ = try proto.readStructBegin()
    var identityProvider: IdentityProvider!
    var identifier: String!
    var password: String!
    var keepLoggedIn: Bool!
    var accessLocation: String!
    var systemName: String!
    var certificate: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (8, .i32):             identityProvider = try IdentityProvider.read(from: proto)
        case (3, .string):           identifier = try String.read(from: proto)
        case (4, .string):           password = try String.read(from: proto)
        case (5, .bool):            keepLoggedIn = try Bool.read(from: proto)
        case (6, .string):           accessLocation = try String.read(from: proto)
        case (7, .string):           systemName = try String.read(from: proto)
        case (9, .string):           certificate = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(identityProvider, named: "identityProvider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(password, named: "password")
    try proto.validateValue(keepLoggedIn, named: "keepLoggedIn")
    try proto.validateValue(accessLocation, named: "accessLocation")
    try proto.validateValue(systemName, named: "systemName")
    try proto.validateValue(certificate, named: "certificate")

    return TalkService_loginWithIdentityCredential_args(identityProvider: identityProvider, identifier: identifier, password: password, keepLoggedIn: keepLoggedIn, accessLocation: accessLocation, systemName: systemName, certificate: certificate)
  }

}



fileprivate final class TalkService_loginWithIdentityCredential_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_loginWithIdentityCredential_result, rhs: TalkService_loginWithIdentityCredential_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_loginWithIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_loginWithIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithIdentityCredential_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_loginWithIdentityCredential_result(success: success, e: e)
  }

}



fileprivate final class TalkService_loginWithIdentityCredentialForCertificate_args {

  fileprivate var identifier: String

  fileprivate var password: String

  fileprivate var keepLoggedIn: Bool

  fileprivate var accessLocation: String

  fileprivate var systemName: String

  fileprivate var identityProvider: IdentityProvider

  fileprivate var certificate: String


  fileprivate init(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) {
    self.identityProvider = identityProvider
    self.identifier = identifier
    self.password = password
    self.keepLoggedIn = keepLoggedIn
    self.accessLocation = accessLocation
    self.systemName = systemName
    self.certificate = certificate
  }

}

fileprivate func ==(lhs: TalkService_loginWithIdentityCredentialForCertificate_args, rhs: TalkService_loginWithIdentityCredentialForCertificate_args) -> Bool {
  return
    (lhs.identityProvider == rhs.identityProvider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.password == rhs.password) &&
    (lhs.keepLoggedIn == rhs.keepLoggedIn) &&
    (lhs.accessLocation == rhs.accessLocation) &&
    (lhs.systemName == rhs.systemName) &&
    (lhs.certificate == rhs.certificate)
}

extension TalkService_loginWithIdentityCredentialForCertificate_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (identityProvider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (password.hashValue)
    result = prime &* result &+ (keepLoggedIn.hashValue)
    result = prime &* result &+ (accessLocation.hashValue)
    result = prime &* result &+ (systemName.hashValue)
    result = prime &* result &+ (certificate.hashValue)
    return result
  }

}

extension TalkService_loginWithIdentityCredentialForCertificate_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["identityProvider": 8, "identifier": 3, "password": 4, "keepLoggedIn": 5, "accessLocation": 6, "systemName": 7, "certificate": 9, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithIdentityCredentialForCertificate_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithIdentityCredentialForCertificate_args {
    _ = try proto.readStructBegin()
    var identityProvider: IdentityProvider!
    var identifier: String!
    var password: String!
    var keepLoggedIn: Bool!
    var accessLocation: String!
    var systemName: String!
    var certificate: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (8, .i32):             identityProvider = try IdentityProvider.read(from: proto)
        case (3, .string):           identifier = try String.read(from: proto)
        case (4, .string):           password = try String.read(from: proto)
        case (5, .bool):            keepLoggedIn = try Bool.read(from: proto)
        case (6, .string):           accessLocation = try String.read(from: proto)
        case (7, .string):           systemName = try String.read(from: proto)
        case (9, .string):           certificate = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(identityProvider, named: "identityProvider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(password, named: "password")
    try proto.validateValue(keepLoggedIn, named: "keepLoggedIn")
    try proto.validateValue(accessLocation, named: "accessLocation")
    try proto.validateValue(systemName, named: "systemName")
    try proto.validateValue(certificate, named: "certificate")

    return TalkService_loginWithIdentityCredentialForCertificate_args(identityProvider: identityProvider, identifier: identifier, password: password, keepLoggedIn: keepLoggedIn, accessLocation: accessLocation, systemName: systemName, certificate: certificate)
  }

}



fileprivate final class TalkService_loginWithIdentityCredentialForCertificate_result {

  fileprivate var success: LoginResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: LoginResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_loginWithIdentityCredentialForCertificate_result, rhs: TalkService_loginWithIdentityCredentialForCertificate_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_loginWithIdentityCredentialForCertificate_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_loginWithIdentityCredentialForCertificate_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithIdentityCredentialForCertificate_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithIdentityCredentialForCertificate_result {
    _ = try proto.readStructBegin()
    var success: LoginResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LoginResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_loginWithIdentityCredentialForCertificate_result(success: success, e: e)
  }

}



fileprivate final class TalkService_loginWithVerifier_args {

  fileprivate var verifier: String


  fileprivate init(verifier: String) {
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: TalkService_loginWithVerifier_args, rhs: TalkService_loginWithVerifier_args) -> Bool {
  return
    (lhs.verifier == rhs.verifier)
}

extension TalkService_loginWithVerifier_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension TalkService_loginWithVerifier_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["verifier": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithVerifier_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithVerifier_args {
    _ = try proto.readStructBegin()
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(verifier, named: "verifier")

    return TalkService_loginWithVerifier_args(verifier: verifier)
  }

}



fileprivate final class TalkService_loginWithVerifier_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_loginWithVerifier_result, rhs: TalkService_loginWithVerifier_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_loginWithVerifier_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_loginWithVerifier_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithVerifier_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithVerifier_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_loginWithVerifier_result(success: success, e: e)
  }

}



fileprivate final class TalkService_loginWithVerifierForCerificate_args {

  fileprivate var verifier: String


  fileprivate init(verifier: String) {
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: TalkService_loginWithVerifierForCerificate_args, rhs: TalkService_loginWithVerifierForCerificate_args) -> Bool {
  return
    (lhs.verifier == rhs.verifier)
}

extension TalkService_loginWithVerifierForCerificate_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension TalkService_loginWithVerifierForCerificate_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["verifier": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithVerifierForCerificate_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithVerifierForCerificate_args {
    _ = try proto.readStructBegin()
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(verifier, named: "verifier")

    return TalkService_loginWithVerifierForCerificate_args(verifier: verifier)
  }

}



fileprivate final class TalkService_loginWithVerifierForCerificate_result {

  fileprivate var success: LoginResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: LoginResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_loginWithVerifierForCerificate_result, rhs: TalkService_loginWithVerifierForCerificate_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_loginWithVerifierForCerificate_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_loginWithVerifierForCerificate_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithVerifierForCerificate_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithVerifierForCerificate_result {
    _ = try proto.readStructBegin()
    var success: LoginResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LoginResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_loginWithVerifierForCerificate_result(success: success, e: e)
  }

}



fileprivate final class TalkService_loginWithVerifierForCertificate_args {

  fileprivate var verifier: String


  fileprivate init(verifier: String) {
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: TalkService_loginWithVerifierForCertificate_args, rhs: TalkService_loginWithVerifierForCertificate_args) -> Bool {
  return
    (lhs.verifier == rhs.verifier)
}

extension TalkService_loginWithVerifierForCertificate_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension TalkService_loginWithVerifierForCertificate_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["verifier": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithVerifierForCertificate_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithVerifierForCertificate_args {
    _ = try proto.readStructBegin()
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(verifier, named: "verifier")

    return TalkService_loginWithVerifierForCertificate_args(verifier: verifier)
  }

}



fileprivate final class TalkService_loginWithVerifierForCertificate_result {

  fileprivate var success: LoginResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: LoginResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_loginWithVerifierForCertificate_result, rhs: TalkService_loginWithVerifierForCertificate_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_loginWithVerifierForCertificate_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_loginWithVerifierForCertificate_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_loginWithVerifierForCertificate_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_loginWithVerifierForCertificate_result {
    _ = try proto.readStructBegin()
    var success: LoginResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LoginResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_loginWithVerifierForCertificate_result(success: success, e: e)
  }

}



fileprivate final class TalkService_logout_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_logout_args, rhs: TalkService_logout_args) -> Bool {
  return true
}

extension TalkService_logout_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_logout_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_logout_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_logout_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_logout_args()
  }

}



fileprivate final class TalkService_logout_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_logout_result, rhs: TalkService_logout_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_logout_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_logout_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_logout_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_logout_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_logout_result(e: e)
  }

}



fileprivate final class TalkService_logoutSession_args {

  fileprivate var tokenKey: String


  fileprivate init(tokenKey: String) {
    self.tokenKey = tokenKey
  }

}

fileprivate func ==(lhs: TalkService_logoutSession_args, rhs: TalkService_logoutSession_args) -> Bool {
  return
    (lhs.tokenKey == rhs.tokenKey)
}

extension TalkService_logoutSession_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (tokenKey.hashValue)
    return result
  }

}

extension TalkService_logoutSession_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["tokenKey": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_logoutSession_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_logoutSession_args {
    _ = try proto.readStructBegin()
    var tokenKey: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           tokenKey = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(tokenKey, named: "tokenKey")

    return TalkService_logoutSession_args(tokenKey: tokenKey)
  }

}



fileprivate final class TalkService_logoutSession_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_logoutSession_result, rhs: TalkService_logoutSession_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_logoutSession_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_logoutSession_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_logoutSession_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_logoutSession_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_logoutSession_result(e: e)
  }

}



fileprivate final class TalkService_noop_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_noop_args, rhs: TalkService_noop_args) -> Bool {
  return true
}

extension TalkService_noop_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_noop_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_noop_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_noop_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_noop_args()
  }

}



fileprivate final class TalkService_noop_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_noop_result, rhs: TalkService_noop_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_noop_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_noop_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_noop_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_noop_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_noop_result(e: e)
  }

}



fileprivate final class TalkService_notifiedRedirect_args {

  fileprivate var paramMap: TMap<String, String>


  fileprivate init(paramMap: TMap<String, String>) {
    self.paramMap = paramMap
  }

}

fileprivate func ==(lhs: TalkService_notifiedRedirect_args, rhs: TalkService_notifiedRedirect_args) -> Bool {
  return
    (lhs.paramMap == rhs.paramMap)
}

extension TalkService_notifiedRedirect_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (paramMap.hashValue)
    return result
  }

}

extension TalkService_notifiedRedirect_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["paramMap": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_notifiedRedirect_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifiedRedirect_args {
    _ = try proto.readStructBegin()
    var paramMap: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .map):             paramMap = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(paramMap, named: "paramMap")

    return TalkService_notifiedRedirect_args(paramMap: paramMap)
  }

}



fileprivate final class TalkService_notifiedRedirect_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_notifiedRedirect_result, rhs: TalkService_notifiedRedirect_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_notifiedRedirect_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_notifiedRedirect_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_notifiedRedirect_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifiedRedirect_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_notifiedRedirect_result(e: e)
  }

}



fileprivate final class TalkService_notifyBuddyOnAir_args {

  fileprivate var seq: Int32

  fileprivate var receiverMids: TList<String>


  fileprivate init(seq: Int32, receiverMids: TList<String>) {
    self.seq = seq
    self.receiverMids = receiverMids
  }

}

fileprivate func ==(lhs: TalkService_notifyBuddyOnAir_args, rhs: TalkService_notifyBuddyOnAir_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.receiverMids == rhs.receiverMids)
}

extension TalkService_notifyBuddyOnAir_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (receiverMids.hashValue)
    return result
  }

}

extension TalkService_notifyBuddyOnAir_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "receiverMids": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyBuddyOnAir_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyBuddyOnAir_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var receiverMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .list):            receiverMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(receiverMids, named: "receiverMids")

    return TalkService_notifyBuddyOnAir_args(seq: seq, receiverMids: receiverMids)
  }

}



fileprivate final class TalkService_notifyBuddyOnAir_result {

  fileprivate var success: TMap<String, String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_notifyBuddyOnAir_result, rhs: TalkService_notifyBuddyOnAir_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_notifyBuddyOnAir_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_notifyBuddyOnAir_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyBuddyOnAir_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyBuddyOnAir_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_notifyBuddyOnAir_result(success: success, e: e)
  }

}



fileprivate final class TalkService_notifyIndividualEvent_args {

  fileprivate var notificationStatus: NotificationStatus

  fileprivate var receiverMids: TList<String>


  fileprivate init(notificationStatus: NotificationStatus, receiverMids: TList<String>) {
    self.notificationStatus = notificationStatus
    self.receiverMids = receiverMids
  }

}

fileprivate func ==(lhs: TalkService_notifyIndividualEvent_args, rhs: TalkService_notifyIndividualEvent_args) -> Bool {
  return
    (lhs.notificationStatus == rhs.notificationStatus) &&
    (lhs.receiverMids == rhs.receiverMids)
}

extension TalkService_notifyIndividualEvent_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (notificationStatus.hashValue)
    result = prime &* result &+ (receiverMids.hashValue)
    return result
  }

}

extension TalkService_notifyIndividualEvent_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["notificationStatus": 2, "receiverMids": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyIndividualEvent_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyIndividualEvent_args {
    _ = try proto.readStructBegin()
    var notificationStatus: NotificationStatus!
    var receiverMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             notificationStatus = try NotificationStatus.read(from: proto)
        case (3, .list):            receiverMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(notificationStatus, named: "notificationStatus")
    try proto.validateValue(receiverMids, named: "receiverMids")

    return TalkService_notifyIndividualEvent_args(notificationStatus: notificationStatus, receiverMids: receiverMids)
  }

}



fileprivate final class TalkService_notifyIndividualEvent_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_notifyIndividualEvent_result, rhs: TalkService_notifyIndividualEvent_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_notifyIndividualEvent_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_notifyIndividualEvent_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyIndividualEvent_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyIndividualEvent_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_notifyIndividualEvent_result(e: e)
  }

}



fileprivate final class TalkService_notifyInstalled_args {

  fileprivate var udidHash: String

  fileprivate var applicationTypeWithExtensions: String


  fileprivate init(udidHash: String, applicationTypeWithExtensions: String) {
    self.udidHash = udidHash
    self.applicationTypeWithExtensions = applicationTypeWithExtensions
  }

}

fileprivate func ==(lhs: TalkService_notifyInstalled_args, rhs: TalkService_notifyInstalled_args) -> Bool {
  return
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.applicationTypeWithExtensions == rhs.applicationTypeWithExtensions)
}

extension TalkService_notifyInstalled_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (applicationTypeWithExtensions.hashValue)
    return result
  }

}

extension TalkService_notifyInstalled_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["udidHash": 2, "applicationTypeWithExtensions": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyInstalled_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyInstalled_args {
    _ = try proto.readStructBegin()
    var udidHash: String!
    var applicationTypeWithExtensions: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           udidHash = try String.read(from: proto)
        case (3, .string):           applicationTypeWithExtensions = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(applicationTypeWithExtensions, named: "applicationTypeWithExtensions")

    return TalkService_notifyInstalled_args(udidHash: udidHash, applicationTypeWithExtensions: applicationTypeWithExtensions)
  }

}



fileprivate final class TalkService_notifyInstalled_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_notifyInstalled_result, rhs: TalkService_notifyInstalled_result) -> Bool {
  return true
}

extension TalkService_notifyInstalled_result : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_notifyInstalled_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_notifyInstalled_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyInstalled_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_notifyInstalled_result()
  }

}



fileprivate final class TalkService_notifyRegistrationComplete_args {

  fileprivate var udidHash: String

  fileprivate var applicationTypeWithExtensions: String


  fileprivate init(udidHash: String, applicationTypeWithExtensions: String) {
    self.udidHash = udidHash
    self.applicationTypeWithExtensions = applicationTypeWithExtensions
  }

}

fileprivate func ==(lhs: TalkService_notifyRegistrationComplete_args, rhs: TalkService_notifyRegistrationComplete_args) -> Bool {
  return
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.applicationTypeWithExtensions == rhs.applicationTypeWithExtensions)
}

extension TalkService_notifyRegistrationComplete_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (applicationTypeWithExtensions.hashValue)
    return result
  }

}

extension TalkService_notifyRegistrationComplete_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["udidHash": 2, "applicationTypeWithExtensions": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyRegistrationComplete_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyRegistrationComplete_args {
    _ = try proto.readStructBegin()
    var udidHash: String!
    var applicationTypeWithExtensions: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           udidHash = try String.read(from: proto)
        case (3, .string):           applicationTypeWithExtensions = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(applicationTypeWithExtensions, named: "applicationTypeWithExtensions")

    return TalkService_notifyRegistrationComplete_args(udidHash: udidHash, applicationTypeWithExtensions: applicationTypeWithExtensions)
  }

}



fileprivate final class TalkService_notifyRegistrationComplete_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_notifyRegistrationComplete_result, rhs: TalkService_notifyRegistrationComplete_result) -> Bool {
  return true
}

extension TalkService_notifyRegistrationComplete_result : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_notifyRegistrationComplete_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_notifyRegistrationComplete_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyRegistrationComplete_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_notifyRegistrationComplete_result()
  }

}



fileprivate final class TalkService_notifySleep_args {

  fileprivate var lastRev: Int64

  fileprivate var badge: Int32


  fileprivate init(lastRev: Int64, badge: Int32) {
    self.lastRev = lastRev
    self.badge = badge
  }

}

fileprivate func ==(lhs: TalkService_notifySleep_args, rhs: TalkService_notifySleep_args) -> Bool {
  return
    (lhs.lastRev == rhs.lastRev) &&
    (lhs.badge == rhs.badge)
}

extension TalkService_notifySleep_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastRev.hashValue)
    result = prime &* result &+ (badge.hashValue)
    return result
  }

}

extension TalkService_notifySleep_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastRev": 2, "badge": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_notifySleep_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifySleep_args {
    _ = try proto.readStructBegin()
    var lastRev: Int64!
    var badge: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             lastRev = try Int64.read(from: proto)
        case (3, .i32):             badge = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastRev, named: "lastRev")
    try proto.validateValue(badge, named: "badge")

    return TalkService_notifySleep_args(lastRev: lastRev, badge: badge)
  }

}



fileprivate final class TalkService_notifySleep_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_notifySleep_result, rhs: TalkService_notifySleep_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_notifySleep_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_notifySleep_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_notifySleep_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifySleep_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_notifySleep_result(e: e)
  }

}



fileprivate final class TalkService_notifyUpdated_args {

  fileprivate var lastRev: Int64

  fileprivate var deviceInfo: DeviceInfo


  fileprivate init(lastRev: Int64, deviceInfo: DeviceInfo) {
    self.lastRev = lastRev
    self.deviceInfo = deviceInfo
  }

}

fileprivate func ==(lhs: TalkService_notifyUpdated_args, rhs: TalkService_notifyUpdated_args) -> Bool {
  return
    (lhs.lastRev == rhs.lastRev) &&
    (lhs.deviceInfo == rhs.deviceInfo)
}

extension TalkService_notifyUpdated_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (lastRev.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    return result
  }

}

extension TalkService_notifyUpdated_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["lastRev": 2, "deviceInfo": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyUpdated_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyUpdated_args {
    _ = try proto.readStructBegin()
    var lastRev: Int64!
    var deviceInfo: DeviceInfo!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             lastRev = try Int64.read(from: proto)
        case (3, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(lastRev, named: "lastRev")
    try proto.validateValue(deviceInfo, named: "deviceInfo")

    return TalkService_notifyUpdated_args(lastRev: lastRev, deviceInfo: deviceInfo)
  }

}



fileprivate final class TalkService_notifyUpdated_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_notifyUpdated_result, rhs: TalkService_notifyUpdated_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_notifyUpdated_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_notifyUpdated_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_notifyUpdated_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_notifyUpdated_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_notifyUpdated_result(e: e)
  }

}



fileprivate final class TalkService_openProximityMatch_args {

  fileprivate var location: Location


  fileprivate init(location: Location) {
    self.location = location
  }

}

fileprivate func ==(lhs: TalkService_openProximityMatch_args, rhs: TalkService_openProximityMatch_args) -> Bool {
  return
    (lhs.location == rhs.location)
}

extension TalkService_openProximityMatch_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (location.hashValue)
    return result
  }

}

extension TalkService_openProximityMatch_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["location": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_openProximityMatch_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_openProximityMatch_args {
    _ = try proto.readStructBegin()
    var location: Location!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           location = try Location.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(location, named: "location")

    return TalkService_openProximityMatch_args(location: location)
  }

}



fileprivate final class TalkService_openProximityMatch_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_openProximityMatch_result, rhs: TalkService_openProximityMatch_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_openProximityMatch_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_openProximityMatch_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_openProximityMatch_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_openProximityMatch_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_openProximityMatch_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerBuddyUser_args {

  fileprivate var buddyId: String

  fileprivate var registrarPassword: String


  fileprivate init(buddyId: String, registrarPassword: String) {
    self.buddyId = buddyId
    self.registrarPassword = registrarPassword
  }

}

fileprivate func ==(lhs: TalkService_registerBuddyUser_args, rhs: TalkService_registerBuddyUser_args) -> Bool {
  return
    (lhs.buddyId == rhs.buddyId) &&
    (lhs.registrarPassword == rhs.registrarPassword)
}

extension TalkService_registerBuddyUser_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (buddyId.hashValue)
    result = prime &* result &+ (registrarPassword.hashValue)
    return result
  }

}

extension TalkService_registerBuddyUser_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["buddyId": 2, "registrarPassword": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_registerBuddyUser_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerBuddyUser_args {
    _ = try proto.readStructBegin()
    var buddyId: String!
    var registrarPassword: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           buddyId = try String.read(from: proto)
        case (3, .string):           registrarPassword = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(buddyId, named: "buddyId")
    try proto.validateValue(registrarPassword, named: "registrarPassword")

    return TalkService_registerBuddyUser_args(buddyId: buddyId, registrarPassword: registrarPassword)
  }

}



fileprivate final class TalkService_registerBuddyUser_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerBuddyUser_result, rhs: TalkService_registerBuddyUser_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerBuddyUser_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerBuddyUser_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerBuddyUser_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerBuddyUser_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerBuddyUser_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerBuddyUserid_args {

  fileprivate var seq: Int32

  fileprivate var userid: String


  fileprivate init(seq: Int32, userid: String) {
    self.seq = seq
    self.userid = userid
  }

}

fileprivate func ==(lhs: TalkService_registerBuddyUserid_args, rhs: TalkService_registerBuddyUserid_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.userid == rhs.userid)
}

extension TalkService_registerBuddyUserid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (userid.hashValue)
    return result
  }

}

extension TalkService_registerBuddyUserid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 2, "userid": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_registerBuddyUserid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerBuddyUserid_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var userid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             seq = try Int32.read(from: proto)
        case (3, .string):           userid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(userid, named: "userid")

    return TalkService_registerBuddyUserid_args(seq: seq, userid: userid)
  }

}



fileprivate final class TalkService_registerBuddyUserid_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerBuddyUserid_result, rhs: TalkService_registerBuddyUserid_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_registerBuddyUserid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerBuddyUserid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerBuddyUserid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerBuddyUserid_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerBuddyUserid_result(e: e)
  }

}



fileprivate final class TalkService_registerDevice_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_registerDevice_args, rhs: TalkService_registerDevice_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_registerDevice_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_registerDevice_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDevice_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDevice_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_registerDevice_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_registerDevice_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerDevice_result, rhs: TalkService_registerDevice_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerDevice_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerDevice_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDevice_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDevice_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerDevice_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerDeviceWithIdentityCredential_args {

  fileprivate var sessionId: String

  fileprivate var identifier: String

  fileprivate var verifier: String

  fileprivate var provider: IdentityProvider


  fileprivate init(sessionId: String, provider: IdentityProvider, identifier: String, verifier: String) {
    self.sessionId = sessionId
    self.provider = provider
    self.identifier = identifier
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: TalkService_registerDeviceWithIdentityCredential_args, rhs: TalkService_registerDeviceWithIdentityCredential_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId) &&
    (lhs.provider == rhs.provider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.verifier == rhs.verifier)
}

extension TalkService_registerDeviceWithIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension TalkService_registerDeviceWithIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, "provider": 5, "identifier": 3, "verifier": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDeviceWithIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDeviceWithIdentityCredential_args {
    _ = try proto.readStructBegin()
    var sessionId: String!
    var provider: IdentityProvider!
    var identifier: String!
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case (5, .i32):             provider = try IdentityProvider.read(from: proto)
        case (3, .string):           identifier = try String.read(from: proto)
        case (4, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(verifier, named: "verifier")

    return TalkService_registerDeviceWithIdentityCredential_args(sessionId: sessionId, provider: provider, identifier: identifier, verifier: verifier)
  }

}



fileprivate final class TalkService_registerDeviceWithIdentityCredential_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerDeviceWithIdentityCredential_result, rhs: TalkService_registerDeviceWithIdentityCredential_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerDeviceWithIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerDeviceWithIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDeviceWithIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDeviceWithIdentityCredential_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerDeviceWithIdentityCredential_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerDeviceWithoutPhoneNumber_args {

  fileprivate var region: String

  fileprivate var udidHash: String

  fileprivate var deviceInfo: DeviceInfo


  fileprivate init(region: String, udidHash: String, deviceInfo: DeviceInfo) {
    self.region = region
    self.udidHash = udidHash
    self.deviceInfo = deviceInfo
  }

}

fileprivate func ==(lhs: TalkService_registerDeviceWithoutPhoneNumber_args, rhs: TalkService_registerDeviceWithoutPhoneNumber_args) -> Bool {
  return
    (lhs.region == rhs.region) &&
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.deviceInfo == rhs.deviceInfo)
}

extension TalkService_registerDeviceWithoutPhoneNumber_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (region.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    return result
  }

}

extension TalkService_registerDeviceWithoutPhoneNumber_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["region": 2, "udidHash": 3, "deviceInfo": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDeviceWithoutPhoneNumber_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDeviceWithoutPhoneNumber_args {
    _ = try proto.readStructBegin()
    var region: String!
    var udidHash: String!
    var deviceInfo: DeviceInfo!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           region = try String.read(from: proto)
        case (3, .string):           udidHash = try String.read(from: proto)
        case (4, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(region, named: "region")
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(deviceInfo, named: "deviceInfo")

    return TalkService_registerDeviceWithoutPhoneNumber_args(region: region, udidHash: udidHash, deviceInfo: deviceInfo)
  }

}



fileprivate final class TalkService_registerDeviceWithoutPhoneNumber_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerDeviceWithoutPhoneNumber_result, rhs: TalkService_registerDeviceWithoutPhoneNumber_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerDeviceWithoutPhoneNumber_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerDeviceWithoutPhoneNumber_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDeviceWithoutPhoneNumber_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDeviceWithoutPhoneNumber_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerDeviceWithoutPhoneNumber_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args {

  fileprivate var region: String

  fileprivate var udidHash: String

  fileprivate var deviceInfo: DeviceInfo

  fileprivate var provider: IdentityProvider

  fileprivate var identifier: String

  fileprivate var verifier: String

  fileprivate var mid: String


  fileprivate init(region: String, udidHash: String, deviceInfo: DeviceInfo, provider: IdentityProvider, identifier: String, verifier: String, mid: String) {
    self.region = region
    self.udidHash = udidHash
    self.deviceInfo = deviceInfo
    self.provider = provider
    self.identifier = identifier
    self.verifier = verifier
    self.mid = mid
  }

}

fileprivate func ==(lhs: TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args, rhs: TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args) -> Bool {
  return
    (lhs.region == rhs.region) &&
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.deviceInfo == rhs.deviceInfo) &&
    (lhs.provider == rhs.provider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.verifier == rhs.verifier) &&
    (lhs.mid == rhs.mid)
}

extension TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (region.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["region": 2, "udidHash": 3, "deviceInfo": 4, "provider": 5, "identifier": 6, "verifier": 7, "mid": 8, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args {
    _ = try proto.readStructBegin()
    var region: String!
    var udidHash: String!
    var deviceInfo: DeviceInfo!
    var provider: IdentityProvider!
    var identifier: String!
    var verifier: String!
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           region = try String.read(from: proto)
        case (3, .string):           udidHash = try String.read(from: proto)
        case (4, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case (5, .i32):             provider = try IdentityProvider.read(from: proto)
        case (6, .string):           identifier = try String.read(from: proto)
        case (7, .string):           verifier = try String.read(from: proto)
        case (8, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(region, named: "region")
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(deviceInfo, named: "deviceInfo")
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(verifier, named: "verifier")
    try proto.validateValue(mid, named: "mid")

    return TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args(region: region, udidHash: udidHash, deviceInfo: deviceInfo, provider: provider, identifier: identifier, verifier: verifier, mid: mid)
  }

}



fileprivate final class TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result, rhs: TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerUserid_args {

  fileprivate var reqSeq: Int32

  fileprivate var userid: String


  fileprivate init(reqSeq: Int32, userid: String) {
    self.reqSeq = reqSeq
    self.userid = userid
  }

}

fileprivate func ==(lhs: TalkService_registerUserid_args, rhs: TalkService_registerUserid_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.userid == rhs.userid)
}

extension TalkService_registerUserid_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (userid.hashValue)
    return result
  }

}

extension TalkService_registerUserid_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "userid": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_registerUserid_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerUserid_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var userid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           userid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(userid, named: "userid")

    return TalkService_registerUserid_args(reqSeq: reqSeq, userid: userid)
  }

}



fileprivate final class TalkService_registerUserid_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerUserid_result, rhs: TalkService_registerUserid_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerUserid_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerUserid_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerUserid_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerUserid_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerUserid_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerWapDevice_args {

  fileprivate var invitationHash: String

  fileprivate var guidHash: String

  fileprivate var email: String

  fileprivate var deviceInfo: DeviceInfo


  fileprivate init(invitationHash: String, guidHash: String, email: String, deviceInfo: DeviceInfo) {
    self.invitationHash = invitationHash
    self.guidHash = guidHash
    self.email = email
    self.deviceInfo = deviceInfo
  }

}

fileprivate func ==(lhs: TalkService_registerWapDevice_args, rhs: TalkService_registerWapDevice_args) -> Bool {
  return
    (lhs.invitationHash == rhs.invitationHash) &&
    (lhs.guidHash == rhs.guidHash) &&
    (lhs.email == rhs.email) &&
    (lhs.deviceInfo == rhs.deviceInfo)
}

extension TalkService_registerWapDevice_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (invitationHash.hashValue)
    result = prime &* result &+ (guidHash.hashValue)
    result = prime &* result &+ (email.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    return result
  }

}

extension TalkService_registerWapDevice_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["invitationHash": 2, "guidHash": 3, "email": 4, "deviceInfo": 5, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWapDevice_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWapDevice_args {
    _ = try proto.readStructBegin()
    var invitationHash: String!
    var guidHash: String!
    var email: String!
    var deviceInfo: DeviceInfo!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           invitationHash = try String.read(from: proto)
        case (3, .string):           guidHash = try String.read(from: proto)
        case (4, .string):           email = try String.read(from: proto)
        case (5, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(invitationHash, named: "invitationHash")
    try proto.validateValue(guidHash, named: "guidHash")
    try proto.validateValue(email, named: "email")
    try proto.validateValue(deviceInfo, named: "deviceInfo")

    return TalkService_registerWapDevice_args(invitationHash: invitationHash, guidHash: guidHash, email: email, deviceInfo: deviceInfo)
  }

}



fileprivate final class TalkService_registerWapDevice_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerWapDevice_result, rhs: TalkService_registerWapDevice_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerWapDevice_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerWapDevice_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWapDevice_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWapDevice_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerWapDevice_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerWithExistingSnsIdAndIdentityCredential_args {

  fileprivate var identityCredential: IdentityCredential

  fileprivate var region: String

  fileprivate var udidHash: String

  fileprivate var deviceInfo: DeviceInfo


  fileprivate init(identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) {
    self.identityCredential = identityCredential
    self.region = region
    self.udidHash = udidHash
    self.deviceInfo = deviceInfo
  }

}

fileprivate func ==(lhs: TalkService_registerWithExistingSnsIdAndIdentityCredential_args, rhs: TalkService_registerWithExistingSnsIdAndIdentityCredential_args) -> Bool {
  return
    (lhs.identityCredential == rhs.identityCredential) &&
    (lhs.region == rhs.region) &&
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.deviceInfo == rhs.deviceInfo)
}

extension TalkService_registerWithExistingSnsIdAndIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (identityCredential.hashValue)
    result = prime &* result &+ (region.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    return result
  }

}

extension TalkService_registerWithExistingSnsIdAndIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["identityCredential": 2, "region": 3, "udidHash": 4, "deviceInfo": 5, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWithExistingSnsIdAndIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWithExistingSnsIdAndIdentityCredential_args {
    _ = try proto.readStructBegin()
    var identityCredential: IdentityCredential!
    var region: String!
    var udidHash: String!
    var deviceInfo: DeviceInfo!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           identityCredential = try IdentityCredential.read(from: proto)
        case (3, .string):           region = try String.read(from: proto)
        case (4, .string):           udidHash = try String.read(from: proto)
        case (5, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(identityCredential, named: "identityCredential")
    try proto.validateValue(region, named: "region")
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(deviceInfo, named: "deviceInfo")

    return TalkService_registerWithExistingSnsIdAndIdentityCredential_args(identityCredential: identityCredential, region: region, udidHash: udidHash, deviceInfo: deviceInfo)
  }

}



fileprivate final class TalkService_registerWithExistingSnsIdAndIdentityCredential_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerWithExistingSnsIdAndIdentityCredential_result, rhs: TalkService_registerWithExistingSnsIdAndIdentityCredential_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerWithExistingSnsIdAndIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerWithExistingSnsIdAndIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWithExistingSnsIdAndIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWithExistingSnsIdAndIdentityCredential_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerWithExistingSnsIdAndIdentityCredential_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerWithSnsId_args {

  fileprivate var snsIdType: SnsIdType

  fileprivate var snsAccessToken: String

  fileprivate var region: String

  fileprivate var udidHash: String

  fileprivate var deviceInfo: DeviceInfo

  fileprivate var mid: String


  fileprivate init(snsIdType: SnsIdType, snsAccessToken: String, region: String, udidHash: String, deviceInfo: DeviceInfo, mid: String) {
    self.snsIdType = snsIdType
    self.snsAccessToken = snsAccessToken
    self.region = region
    self.udidHash = udidHash
    self.deviceInfo = deviceInfo
    self.mid = mid
  }

}

fileprivate func ==(lhs: TalkService_registerWithSnsId_args, rhs: TalkService_registerWithSnsId_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsAccessToken == rhs.snsAccessToken) &&
    (lhs.region == rhs.region) &&
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.deviceInfo == rhs.deviceInfo) &&
    (lhs.mid == rhs.mid)
}

extension TalkService_registerWithSnsId_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsAccessToken.hashValue)
    result = prime &* result &+ (region.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    result = prime &* result &+ (mid.hashValue)
    return result
  }

}

extension TalkService_registerWithSnsId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, "snsAccessToken": 3, "region": 4, "udidHash": 5, "deviceInfo": 6, "mid": 7, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWithSnsId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWithSnsId_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!
    var snsAccessToken: String!
    var region: String!
    var udidHash: String!
    var deviceInfo: DeviceInfo!
    var mid: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsAccessToken = try String.read(from: proto)
        case (4, .string):           region = try String.read(from: proto)
        case (5, .string):           udidHash = try String.read(from: proto)
        case (6, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case (7, .string):           mid = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsAccessToken, named: "snsAccessToken")
    try proto.validateValue(region, named: "region")
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(deviceInfo, named: "deviceInfo")
    try proto.validateValue(mid, named: "mid")

    return TalkService_registerWithSnsId_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, region: region, udidHash: udidHash, deviceInfo: deviceInfo, mid: mid)
  }

}



fileprivate final class TalkService_registerWithSnsId_result {

  fileprivate var success: RegisterWithSnsIdResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: RegisterWithSnsIdResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerWithSnsId_result, rhs: TalkService_registerWithSnsId_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerWithSnsId_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerWithSnsId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWithSnsId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWithSnsId_result {
    _ = try proto.readStructBegin()
    var success: RegisterWithSnsIdResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try RegisterWithSnsIdResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerWithSnsId_result(success: success, e: e)
  }

}



fileprivate final class TalkService_registerWithSnsIdAndIdentityCredential_args {

  fileprivate var snsIdType: SnsIdType

  fileprivate var snsAccessToken: String

  fileprivate var identityCredential: IdentityCredential

  fileprivate var region: String

  fileprivate var udidHash: String

  fileprivate var deviceInfo: DeviceInfo


  fileprivate init(snsIdType: SnsIdType, snsAccessToken: String, identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) {
    self.snsIdType = snsIdType
    self.snsAccessToken = snsAccessToken
    self.identityCredential = identityCredential
    self.region = region
    self.udidHash = udidHash
    self.deviceInfo = deviceInfo
  }

}

fileprivate func ==(lhs: TalkService_registerWithSnsIdAndIdentityCredential_args, rhs: TalkService_registerWithSnsIdAndIdentityCredential_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType) &&
    (lhs.snsAccessToken == rhs.snsAccessToken) &&
    (lhs.identityCredential == rhs.identityCredential) &&
    (lhs.region == rhs.region) &&
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.deviceInfo == rhs.deviceInfo)
}

extension TalkService_registerWithSnsIdAndIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    result = prime &* result &+ (snsAccessToken.hashValue)
    result = prime &* result &+ (identityCredential.hashValue)
    result = prime &* result &+ (region.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    return result
  }

}

extension TalkService_registerWithSnsIdAndIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, "snsAccessToken": 3, "identityCredential": 4, "region": 5, "udidHash": 6, "deviceInfo": 7, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWithSnsIdAndIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWithSnsIdAndIdentityCredential_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!
    var snsAccessToken: String!
    var identityCredential: IdentityCredential!
    var region: String!
    var udidHash: String!
    var deviceInfo: DeviceInfo!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case (3, .string):           snsAccessToken = try String.read(from: proto)
        case (4, .struct):           identityCredential = try IdentityCredential.read(from: proto)
        case (5, .string):           region = try String.read(from: proto)
        case (6, .string):           udidHash = try String.read(from: proto)
        case (7, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")
    try proto.validateValue(snsAccessToken, named: "snsAccessToken")
    try proto.validateValue(identityCredential, named: "identityCredential")
    try proto.validateValue(region, named: "region")
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(deviceInfo, named: "deviceInfo")

    return TalkService_registerWithSnsIdAndIdentityCredential_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, identityCredential: identityCredential, region: region, udidHash: udidHash, deviceInfo: deviceInfo)
  }

}



fileprivate final class TalkService_registerWithSnsIdAndIdentityCredential_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_registerWithSnsIdAndIdentityCredential_result, rhs: TalkService_registerWithSnsIdAndIdentityCredential_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_registerWithSnsIdAndIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_registerWithSnsIdAndIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_registerWithSnsIdAndIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_registerWithSnsIdAndIdentityCredential_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_registerWithSnsIdAndIdentityCredential_result(success: success, e: e)
  }

}



fileprivate final class TalkService_reissueDeviceCredential_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_reissueDeviceCredential_args, rhs: TalkService_reissueDeviceCredential_args) -> Bool {
  return true
}

extension TalkService_reissueDeviceCredential_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_reissueDeviceCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_reissueDeviceCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reissueDeviceCredential_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reissueDeviceCredential_args()
  }

}



fileprivate final class TalkService_reissueDeviceCredential_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reissueDeviceCredential_result, rhs: TalkService_reissueDeviceCredential_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_reissueDeviceCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reissueDeviceCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reissueDeviceCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reissueDeviceCredential_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reissueDeviceCredential_result(success: success, e: e)
  }

}



fileprivate final class TalkService_reissueUserTicket_args {

  fileprivate var expirationTime: Int64

  fileprivate var maxUseCount: Int32


  fileprivate init(expirationTime: Int64, maxUseCount: Int32) {
    self.expirationTime = expirationTime
    self.maxUseCount = maxUseCount
  }

}

fileprivate func ==(lhs: TalkService_reissueUserTicket_args, rhs: TalkService_reissueUserTicket_args) -> Bool {
  return
    (lhs.expirationTime == rhs.expirationTime) &&
    (lhs.maxUseCount == rhs.maxUseCount)
}

extension TalkService_reissueUserTicket_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (expirationTime.hashValue)
    result = prime &* result &+ (maxUseCount.hashValue)
    return result
  }

}

extension TalkService_reissueUserTicket_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["expirationTime": 3, "maxUseCount": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_reissueUserTicket_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reissueUserTicket_args {
    _ = try proto.readStructBegin()
    var expirationTime: Int64!
    var maxUseCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .i64):             expirationTime = try Int64.read(from: proto)
        case (4, .i32):             maxUseCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(expirationTime, named: "expirationTime")
    try proto.validateValue(maxUseCount, named: "maxUseCount")

    return TalkService_reissueUserTicket_args(expirationTime: expirationTime, maxUseCount: maxUseCount)
  }

}



fileprivate final class TalkService_reissueUserTicket_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reissueUserTicket_result, rhs: TalkService_reissueUserTicket_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_reissueUserTicket_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reissueUserTicket_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reissueUserTicket_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reissueUserTicket_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reissueUserTicket_result(success: success, e: e)
  }

}



fileprivate final class TalkService_rejectGroupInvitation_args {

  fileprivate var reqSeq: Int32

  fileprivate var groupId: String


  fileprivate init(reqSeq: Int32, groupId: String) {
    self.reqSeq = reqSeq
    self.groupId = groupId
  }

}

fileprivate func ==(lhs: TalkService_rejectGroupInvitation_args, rhs: TalkService_rejectGroupInvitation_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.groupId == rhs.groupId)
}

extension TalkService_rejectGroupInvitation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (groupId.hashValue)
    return result
  }

}

extension TalkService_rejectGroupInvitation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "groupId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_rejectGroupInvitation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_rejectGroupInvitation_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var groupId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           groupId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(groupId, named: "groupId")

    return TalkService_rejectGroupInvitation_args(reqSeq: reqSeq, groupId: groupId)
  }

}



fileprivate final class TalkService_rejectGroupInvitation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_rejectGroupInvitation_result, rhs: TalkService_rejectGroupInvitation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_rejectGroupInvitation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_rejectGroupInvitation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_rejectGroupInvitation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_rejectGroupInvitation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_rejectGroupInvitation_result(e: e)
  }

}



fileprivate final class TalkService_releaseSession_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_releaseSession_args, rhs: TalkService_releaseSession_args) -> Bool {
  return true
}

extension TalkService_releaseSession_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_releaseSession_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_releaseSession_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_releaseSession_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_releaseSession_args()
  }

}



fileprivate final class TalkService_releaseSession_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_releaseSession_result, rhs: TalkService_releaseSession_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_releaseSession_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_releaseSession_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_releaseSession_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_releaseSession_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_releaseSession_result(e: e)
  }

}



fileprivate final class TalkService_removeAllMessages_args {

  fileprivate var seq: Int32

  fileprivate var lastMessageId: String


  fileprivate init(seq: Int32, lastMessageId: String) {
    self.seq = seq
    self.lastMessageId = lastMessageId
  }

}

fileprivate func ==(lhs: TalkService_removeAllMessages_args, rhs: TalkService_removeAllMessages_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.lastMessageId == rhs.lastMessageId)
}

extension TalkService_removeAllMessages_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (lastMessageId.hashValue)
    return result
  }

}

extension TalkService_removeAllMessages_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "lastMessageId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_removeAllMessages_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeAllMessages_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var lastMessageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           lastMessageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(lastMessageId, named: "lastMessageId")

    return TalkService_removeAllMessages_args(seq: seq, lastMessageId: lastMessageId)
  }

}



fileprivate final class TalkService_removeAllMessages_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_removeAllMessages_result, rhs: TalkService_removeAllMessages_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_removeAllMessages_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_removeAllMessages_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_removeAllMessages_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeAllMessages_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_removeAllMessages_result(e: e)
  }

}



fileprivate final class TalkService_removeBuddyLocation_args {

  fileprivate var mid: String

  fileprivate var index: Int32


  fileprivate init(mid: String, index: Int32) {
    self.mid = mid
    self.index = index
  }

}

fileprivate func ==(lhs: TalkService_removeBuddyLocation_args, rhs: TalkService_removeBuddyLocation_args) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.index == rhs.index)
}

extension TalkService_removeBuddyLocation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (index.hashValue)
    return result
  }

}

extension TalkService_removeBuddyLocation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["mid": 2, "index": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_removeBuddyLocation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeBuddyLocation_args {
    _ = try proto.readStructBegin()
    var mid: String!
    var index: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           mid = try String.read(from: proto)
        case (3, .i32):             index = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(index, named: "index")

    return TalkService_removeBuddyLocation_args(mid: mid, index: index)
  }

}



fileprivate final class TalkService_removeBuddyLocation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_removeBuddyLocation_result, rhs: TalkService_removeBuddyLocation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_removeBuddyLocation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_removeBuddyLocation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_removeBuddyLocation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeBuddyLocation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_removeBuddyLocation_result(e: e)
  }

}



fileprivate final class TalkService_removeMessage_args {

  fileprivate var messageId: String


  fileprivate init(messageId: String) {
    self.messageId = messageId
  }

}

fileprivate func ==(lhs: TalkService_removeMessage_args, rhs: TalkService_removeMessage_args) -> Bool {
  return
    (lhs.messageId == rhs.messageId)
}

extension TalkService_removeMessage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (messageId.hashValue)
    return result
  }

}

extension TalkService_removeMessage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["messageId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_removeMessage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeMessage_args {
    _ = try proto.readStructBegin()
    var messageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           messageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(messageId, named: "messageId")

    return TalkService_removeMessage_args(messageId: messageId)
  }

}



fileprivate final class TalkService_removeMessage_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_removeMessage_result, rhs: TalkService_removeMessage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_removeMessage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_removeMessage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_removeMessage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeMessage_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_removeMessage_result(success: success, e: e)
  }

}



fileprivate final class TalkService_removeMessageFromMyHome_args {

  fileprivate var messageId: String


  fileprivate init(messageId: String) {
    self.messageId = messageId
  }

}

fileprivate func ==(lhs: TalkService_removeMessageFromMyHome_args, rhs: TalkService_removeMessageFromMyHome_args) -> Bool {
  return
    (lhs.messageId == rhs.messageId)
}

extension TalkService_removeMessageFromMyHome_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (messageId.hashValue)
    return result
  }

}

extension TalkService_removeMessageFromMyHome_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["messageId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_removeMessageFromMyHome_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeMessageFromMyHome_args {
    _ = try proto.readStructBegin()
    var messageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           messageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(messageId, named: "messageId")

    return TalkService_removeMessageFromMyHome_args(messageId: messageId)
  }

}



fileprivate final class TalkService_removeMessageFromMyHome_result {

  fileprivate var success: Bool?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Bool?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_removeMessageFromMyHome_result, rhs: TalkService_removeMessageFromMyHome_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_removeMessageFromMyHome_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_removeMessageFromMyHome_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_removeMessageFromMyHome_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeMessageFromMyHome_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_removeMessageFromMyHome_result(success: success, e: e)
  }

}



fileprivate final class TalkService_removeSnsId_args {

  fileprivate var snsIdType: SnsIdType


  fileprivate init(snsIdType: SnsIdType) {
    self.snsIdType = snsIdType
  }

}

fileprivate func ==(lhs: TalkService_removeSnsId_args, rhs: TalkService_removeSnsId_args) -> Bool {
  return
    (lhs.snsIdType == rhs.snsIdType)
}

extension TalkService_removeSnsId_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (snsIdType.hashValue)
    return result
  }

}

extension TalkService_removeSnsId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["snsIdType": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_removeSnsId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeSnsId_args {
    _ = try proto.readStructBegin()
    var snsIdType: SnsIdType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             snsIdType = try SnsIdType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(snsIdType, named: "snsIdType")

    return TalkService_removeSnsId_args(snsIdType: snsIdType)
  }

}



fileprivate final class TalkService_removeSnsId_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_removeSnsId_result, rhs: TalkService_removeSnsId_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_removeSnsId_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_removeSnsId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_removeSnsId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_removeSnsId_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_removeSnsId_result(success: success, e: e)
  }

}



fileprivate final class TalkService_report_args {

  fileprivate var syncOpRevision: Int64

  fileprivate var category: SyncCategory

  fileprivate var report: String


  fileprivate init(syncOpRevision: Int64, category: SyncCategory, report: String) {
    self.syncOpRevision = syncOpRevision
    self.category = category
    self.report = report
  }

}

fileprivate func ==(lhs: TalkService_report_args, rhs: TalkService_report_args) -> Bool {
  return
    (lhs.syncOpRevision == rhs.syncOpRevision) &&
    (lhs.category == rhs.category) &&
    (lhs.report == rhs.report)
}

extension TalkService_report_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (syncOpRevision.hashValue)
    result = prime &* result &+ (category.hashValue)
    result = prime &* result &+ (report.hashValue)
    return result
  }

}

extension TalkService_report_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["syncOpRevision": 2, "category": 3, "report": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_report_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_report_args {
    _ = try proto.readStructBegin()
    var syncOpRevision: Int64!
    var category: SyncCategory!
    var report: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             syncOpRevision = try Int64.read(from: proto)
        case (3, .i32):             category = try SyncCategory.read(from: proto)
        case (4, .string):           report = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(syncOpRevision, named: "syncOpRevision")
    try proto.validateValue(category, named: "category")
    try proto.validateValue(report, named: "report")

    return TalkService_report_args(syncOpRevision: syncOpRevision, category: category, report: report)
  }

}



fileprivate final class TalkService_report_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_report_result, rhs: TalkService_report_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_report_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_report_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_report_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_report_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_report_result(e: e)
  }

}



fileprivate final class TalkService_reportContacts_args {

  fileprivate var syncOpRevision: Int64

  fileprivate var category: SyncCategory

  fileprivate var contactReports: TList<ContactReport>

  fileprivate var actionType: SyncActionType


  fileprivate init(syncOpRevision: Int64, category: SyncCategory, contactReports: TList<ContactReport>, actionType: SyncActionType) {
    self.syncOpRevision = syncOpRevision
    self.category = category
    self.contactReports = contactReports
    self.actionType = actionType
  }

}

fileprivate func ==(lhs: TalkService_reportContacts_args, rhs: TalkService_reportContacts_args) -> Bool {
  return
    (lhs.syncOpRevision == rhs.syncOpRevision) &&
    (lhs.category == rhs.category) &&
    (lhs.contactReports == rhs.contactReports) &&
    (lhs.actionType == rhs.actionType)
}

extension TalkService_reportContacts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (syncOpRevision.hashValue)
    result = prime &* result &+ (category.hashValue)
    result = prime &* result &+ (contactReports.hashValue)
    result = prime &* result &+ (actionType.hashValue)
    return result
  }

}

extension TalkService_reportContacts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["syncOpRevision": 2, "category": 3, "contactReports": 4, "actionType": 5, ]
  }

  fileprivate static var structName: String { return "TalkService_reportContacts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportContacts_args {
    _ = try proto.readStructBegin()
    var syncOpRevision: Int64!
    var category: SyncCategory!
    var contactReports: TList<ContactReport>!
    var actionType: SyncActionType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             syncOpRevision = try Int64.read(from: proto)
        case (3, .i32):             category = try SyncCategory.read(from: proto)
        case (4, .list):            contactReports = try TList<ContactReport>.read(from: proto)
        case (5, .i32):             actionType = try SyncActionType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(syncOpRevision, named: "syncOpRevision")
    try proto.validateValue(category, named: "category")
    try proto.validateValue(contactReports, named: "contactReports")
    try proto.validateValue(actionType, named: "actionType")

    return TalkService_reportContacts_args(syncOpRevision: syncOpRevision, category: category, contactReports: contactReports, actionType: actionType)
  }

}



fileprivate final class TalkService_reportContacts_result {

  fileprivate var success: TList<ContactReportResult>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<ContactReportResult>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reportContacts_result, rhs: TalkService_reportContacts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_reportContacts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reportContacts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reportContacts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportContacts_result {
    _ = try proto.readStructBegin()
    var success: TList<ContactReportResult>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<ContactReportResult>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reportContacts_result(success: success, e: e)
  }

}



fileprivate final class TalkService_reportGroups_args {

  fileprivate var syncOpRevision: Int64

  fileprivate var groups: TList<Group>


  fileprivate init(syncOpRevision: Int64, groups: TList<Group>) {
    self.syncOpRevision = syncOpRevision
    self.groups = groups
  }

}

fileprivate func ==(lhs: TalkService_reportGroups_args, rhs: TalkService_reportGroups_args) -> Bool {
  return
    (lhs.syncOpRevision == rhs.syncOpRevision) &&
    (lhs.groups == rhs.groups)
}

extension TalkService_reportGroups_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (syncOpRevision.hashValue)
    result = prime &* result &+ (groups.hashValue)
    return result
  }

}

extension TalkService_reportGroups_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["syncOpRevision": 2, "groups": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_reportGroups_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportGroups_args {
    _ = try proto.readStructBegin()
    var syncOpRevision: Int64!
    var groups: TList<Group>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             syncOpRevision = try Int64.read(from: proto)
        case (3, .list):            groups = try TList<Group>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(syncOpRevision, named: "syncOpRevision")
    try proto.validateValue(groups, named: "groups")

    return TalkService_reportGroups_args(syncOpRevision: syncOpRevision, groups: groups)
  }

}



fileprivate final class TalkService_reportGroups_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reportGroups_result, rhs: TalkService_reportGroups_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_reportGroups_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reportGroups_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reportGroups_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportGroups_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reportGroups_result(e: e)
  }

}



fileprivate final class TalkService_reportProfile_args {

  fileprivate var syncOpRevision: Int64

  fileprivate var profile: Profile


  fileprivate init(syncOpRevision: Int64, profile: Profile) {
    self.syncOpRevision = syncOpRevision
    self.profile = profile
  }

}

fileprivate func ==(lhs: TalkService_reportProfile_args, rhs: TalkService_reportProfile_args) -> Bool {
  return
    (lhs.syncOpRevision == rhs.syncOpRevision) &&
    (lhs.profile == rhs.profile)
}

extension TalkService_reportProfile_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (syncOpRevision.hashValue)
    result = prime &* result &+ (profile.hashValue)
    return result
  }

}

extension TalkService_reportProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["syncOpRevision": 2, "profile": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_reportProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportProfile_args {
    _ = try proto.readStructBegin()
    var syncOpRevision: Int64!
    var profile: Profile!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             syncOpRevision = try Int64.read(from: proto)
        case (3, .struct):           profile = try Profile.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(syncOpRevision, named: "syncOpRevision")
    try proto.validateValue(profile, named: "profile")

    return TalkService_reportProfile_args(syncOpRevision: syncOpRevision, profile: profile)
  }

}



fileprivate final class TalkService_reportProfile_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reportProfile_result, rhs: TalkService_reportProfile_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_reportProfile_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reportProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reportProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportProfile_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reportProfile_result(e: e)
  }

}



fileprivate final class TalkService_reportRooms_args {

  fileprivate var syncOpRevision: Int64

  fileprivate var rooms: TList<Room>


  fileprivate init(syncOpRevision: Int64, rooms: TList<Room>) {
    self.syncOpRevision = syncOpRevision
    self.rooms = rooms
  }

}

fileprivate func ==(lhs: TalkService_reportRooms_args, rhs: TalkService_reportRooms_args) -> Bool {
  return
    (lhs.syncOpRevision == rhs.syncOpRevision) &&
    (lhs.rooms == rhs.rooms)
}

extension TalkService_reportRooms_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (syncOpRevision.hashValue)
    result = prime &* result &+ (rooms.hashValue)
    return result
  }

}

extension TalkService_reportRooms_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["syncOpRevision": 2, "rooms": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_reportRooms_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportRooms_args {
    _ = try proto.readStructBegin()
    var syncOpRevision: Int64!
    var rooms: TList<Room>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             syncOpRevision = try Int64.read(from: proto)
        case (3, .list):            rooms = try TList<Room>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(syncOpRevision, named: "syncOpRevision")
    try proto.validateValue(rooms, named: "rooms")

    return TalkService_reportRooms_args(syncOpRevision: syncOpRevision, rooms: rooms)
  }

}



fileprivate final class TalkService_reportRooms_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reportRooms_result, rhs: TalkService_reportRooms_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_reportRooms_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reportRooms_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reportRooms_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportRooms_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reportRooms_result(e: e)
  }

}



fileprivate final class TalkService_reportSettings_args {

  fileprivate var syncOpRevision: Int64

  fileprivate var settings: Settings


  fileprivate init(syncOpRevision: Int64, settings: Settings) {
    self.syncOpRevision = syncOpRevision
    self.settings = settings
  }

}

fileprivate func ==(lhs: TalkService_reportSettings_args, rhs: TalkService_reportSettings_args) -> Bool {
  return
    (lhs.syncOpRevision == rhs.syncOpRevision) &&
    (lhs.settings == rhs.settings)
}

extension TalkService_reportSettings_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (syncOpRevision.hashValue)
    result = prime &* result &+ (settings.hashValue)
    return result
  }

}

extension TalkService_reportSettings_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["syncOpRevision": 2, "settings": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_reportSettings_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportSettings_args {
    _ = try proto.readStructBegin()
    var syncOpRevision: Int64!
    var settings: Settings!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i64):             syncOpRevision = try Int64.read(from: proto)
        case (3, .struct):           settings = try Settings.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(syncOpRevision, named: "syncOpRevision")
    try proto.validateValue(settings, named: "settings")

    return TalkService_reportSettings_args(syncOpRevision: syncOpRevision, settings: settings)
  }

}



fileprivate final class TalkService_reportSettings_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reportSettings_result, rhs: TalkService_reportSettings_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_reportSettings_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reportSettings_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reportSettings_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportSettings_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reportSettings_result(e: e)
  }

}



fileprivate final class TalkService_reportSpammer_args {

  fileprivate var spammerMid: String

  fileprivate var spammerReasons: TList<SpammerReason>

  fileprivate var spamMessageIds: TList<String>


  fileprivate init(spammerMid: String, spammerReasons: TList<SpammerReason>, spamMessageIds: TList<String>) {
    self.spammerMid = spammerMid
    self.spammerReasons = spammerReasons
    self.spamMessageIds = spamMessageIds
  }

}

fileprivate func ==(lhs: TalkService_reportSpammer_args, rhs: TalkService_reportSpammer_args) -> Bool {
  return
    (lhs.spammerMid == rhs.spammerMid) &&
    (lhs.spammerReasons == rhs.spammerReasons) &&
    (lhs.spamMessageIds == rhs.spamMessageIds)
}

extension TalkService_reportSpammer_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (spammerMid.hashValue)
    result = prime &* result &+ (spammerReasons.hashValue)
    result = prime &* result &+ (spamMessageIds.hashValue)
    return result
  }

}

extension TalkService_reportSpammer_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["spammerMid": 2, "spammerReasons": 3, "spamMessageIds": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_reportSpammer_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportSpammer_args {
    _ = try proto.readStructBegin()
    var spammerMid: String!
    var spammerReasons: TList<SpammerReason>!
    var spamMessageIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           spammerMid = try String.read(from: proto)
        case (3, .list):            spammerReasons = try TList<SpammerReason>.read(from: proto)
        case (4, .list):            spamMessageIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(spammerMid, named: "spammerMid")
    try proto.validateValue(spammerReasons, named: "spammerReasons")
    try proto.validateValue(spamMessageIds, named: "spamMessageIds")

    return TalkService_reportSpammer_args(spammerMid: spammerMid, spammerReasons: spammerReasons, spamMessageIds: spamMessageIds)
  }

}



fileprivate final class TalkService_reportSpammer_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_reportSpammer_result, rhs: TalkService_reportSpammer_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_reportSpammer_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_reportSpammer_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_reportSpammer_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_reportSpammer_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_reportSpammer_result(e: e)
  }

}



fileprivate final class TalkService_requestAccountPasswordReset_args {

  fileprivate var identifier: String

  fileprivate var provider: IdentityProvider

  fileprivate var locale: String


  fileprivate init(provider: IdentityProvider, identifier: String, locale: String) {
    self.provider = provider
    self.identifier = identifier
    self.locale = locale
  }

}

fileprivate func ==(lhs: TalkService_requestAccountPasswordReset_args, rhs: TalkService_requestAccountPasswordReset_args) -> Bool {
  return
    (lhs.provider == rhs.provider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.locale == rhs.locale)
}

extension TalkService_requestAccountPasswordReset_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension TalkService_requestAccountPasswordReset_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["provider": 4, "identifier": 2, "locale": 5, ]
  }

  fileprivate static var structName: String { return "TalkService_requestAccountPasswordReset_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_requestAccountPasswordReset_args {
    _ = try proto.readStructBegin()
    var provider: IdentityProvider!
    var identifier: String!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (4, .i32):             provider = try IdentityProvider.read(from: proto)
        case (2, .string):           identifier = try String.read(from: proto)
        case (5, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(locale, named: "locale")

    return TalkService_requestAccountPasswordReset_args(provider: provider, identifier: identifier, locale: locale)
  }

}



fileprivate final class TalkService_requestAccountPasswordReset_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_requestAccountPasswordReset_result, rhs: TalkService_requestAccountPasswordReset_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_requestAccountPasswordReset_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_requestAccountPasswordReset_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_requestAccountPasswordReset_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_requestAccountPasswordReset_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_requestAccountPasswordReset_result(e: e)
  }

}



fileprivate final class TalkService_requestEmailConfirmation_args {

  fileprivate var emailConfirmation: EmailConfirmation


  fileprivate init(emailConfirmation: EmailConfirmation) {
    self.emailConfirmation = emailConfirmation
  }

}

fileprivate func ==(lhs: TalkService_requestEmailConfirmation_args, rhs: TalkService_requestEmailConfirmation_args) -> Bool {
  return
    (lhs.emailConfirmation == rhs.emailConfirmation)
}

extension TalkService_requestEmailConfirmation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (emailConfirmation.hashValue)
    return result
  }

}

extension TalkService_requestEmailConfirmation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["emailConfirmation": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_requestEmailConfirmation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_requestEmailConfirmation_args {
    _ = try proto.readStructBegin()
    var emailConfirmation: EmailConfirmation!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           emailConfirmation = try EmailConfirmation.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(emailConfirmation, named: "emailConfirmation")

    return TalkService_requestEmailConfirmation_args(emailConfirmation: emailConfirmation)
  }

}



fileprivate final class TalkService_requestEmailConfirmation_result {

  fileprivate var success: EmailConfirmationSession?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: EmailConfirmationSession?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_requestEmailConfirmation_result, rhs: TalkService_requestEmailConfirmation_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_requestEmailConfirmation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_requestEmailConfirmation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_requestEmailConfirmation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_requestEmailConfirmation_result {
    _ = try proto.readStructBegin()
    var success: EmailConfirmationSession?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try EmailConfirmationSession.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_requestEmailConfirmation_result(success: success, e: e)
  }

}



fileprivate final class TalkService_requestIdentityUnbind_args {

  fileprivate var identifier: String

  fileprivate var provider: IdentityProvider


  fileprivate init(provider: IdentityProvider, identifier: String) {
    self.provider = provider
    self.identifier = identifier
  }

}

fileprivate func ==(lhs: TalkService_requestIdentityUnbind_args, rhs: TalkService_requestIdentityUnbind_args) -> Bool {
  return
    (lhs.provider == rhs.provider) &&
    (lhs.identifier == rhs.identifier)
}

extension TalkService_requestIdentityUnbind_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    return result
  }

}

extension TalkService_requestIdentityUnbind_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["provider": 4, "identifier": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_requestIdentityUnbind_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_requestIdentityUnbind_args {
    _ = try proto.readStructBegin()
    var provider: IdentityProvider!
    var identifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (4, .i32):             provider = try IdentityProvider.read(from: proto)
        case (2, .string):           identifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(identifier, named: "identifier")

    return TalkService_requestIdentityUnbind_args(provider: provider, identifier: identifier)
  }

}



fileprivate final class TalkService_requestIdentityUnbind_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_requestIdentityUnbind_result, rhs: TalkService_requestIdentityUnbind_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_requestIdentityUnbind_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_requestIdentityUnbind_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_requestIdentityUnbind_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_requestIdentityUnbind_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_requestIdentityUnbind_result(e: e)
  }

}



fileprivate final class TalkService_resendEmailConfirmation_args {

  fileprivate var verifier: String


  fileprivate init(verifier: String) {
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: TalkService_resendEmailConfirmation_args, rhs: TalkService_resendEmailConfirmation_args) -> Bool {
  return
    (lhs.verifier == rhs.verifier)
}

extension TalkService_resendEmailConfirmation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension TalkService_resendEmailConfirmation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["verifier": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_resendEmailConfirmation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_resendEmailConfirmation_args {
    _ = try proto.readStructBegin()
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(verifier, named: "verifier")

    return TalkService_resendEmailConfirmation_args(verifier: verifier)
  }

}



fileprivate final class TalkService_resendEmailConfirmation_result {

  fileprivate var success: EmailConfirmationSession?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: EmailConfirmationSession?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_resendEmailConfirmation_result, rhs: TalkService_resendEmailConfirmation_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_resendEmailConfirmation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_resendEmailConfirmation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_resendEmailConfirmation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_resendEmailConfirmation_result {
    _ = try proto.readStructBegin()
    var success: EmailConfirmationSession?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try EmailConfirmationSession.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_resendEmailConfirmation_result(success: success, e: e)
  }

}



fileprivate final class TalkService_resendPinCode_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_resendPinCode_args, rhs: TalkService_resendPinCode_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_resendPinCode_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_resendPinCode_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_resendPinCode_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_resendPinCode_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_resendPinCode_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_resendPinCode_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_resendPinCode_result, rhs: TalkService_resendPinCode_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_resendPinCode_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_resendPinCode_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_resendPinCode_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_resendPinCode_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_resendPinCode_result(e: e)
  }

}



fileprivate final class TalkService_resendPinCodeBySMS_args {

  fileprivate var sessionId: String


  fileprivate init(sessionId: String) {
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: TalkService_resendPinCodeBySMS_args, rhs: TalkService_resendPinCodeBySMS_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId)
}

extension TalkService_resendPinCodeBySMS_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension TalkService_resendPinCodeBySMS_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_resendPinCodeBySMS_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_resendPinCodeBySMS_args {
    _ = try proto.readStructBegin()
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")

    return TalkService_resendPinCodeBySMS_args(sessionId: sessionId)
  }

}



fileprivate final class TalkService_resendPinCodeBySMS_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_resendPinCodeBySMS_result, rhs: TalkService_resendPinCodeBySMS_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_resendPinCodeBySMS_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_resendPinCodeBySMS_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_resendPinCodeBySMS_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_resendPinCodeBySMS_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_resendPinCodeBySMS_result(e: e)
  }

}



fileprivate final class TalkService_sendChatChecked_args {

  fileprivate var seq: Int32

  fileprivate var consumer: String

  fileprivate var lastMessageId: String


  fileprivate init(seq: Int32, consumer: String, lastMessageId: String) {
    self.seq = seq
    self.consumer = consumer
    self.lastMessageId = lastMessageId
  }

}

fileprivate func ==(lhs: TalkService_sendChatChecked_args, rhs: TalkService_sendChatChecked_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.consumer == rhs.consumer) &&
    (lhs.lastMessageId == rhs.lastMessageId)
}

extension TalkService_sendChatChecked_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (consumer.hashValue)
    result = prime &* result &+ (lastMessageId.hashValue)
    return result
  }

}

extension TalkService_sendChatChecked_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "consumer": 2, "lastMessageId": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_sendChatChecked_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendChatChecked_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var consumer: String!
    var lastMessageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           consumer = try String.read(from: proto)
        case (3, .string):           lastMessageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(consumer, named: "consumer")
    try proto.validateValue(lastMessageId, named: "lastMessageId")

    return TalkService_sendChatChecked_args(seq: seq, consumer: consumer, lastMessageId: lastMessageId)
  }

}



fileprivate final class TalkService_sendChatChecked_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendChatChecked_result, rhs: TalkService_sendChatChecked_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_sendChatChecked_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendChatChecked_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendChatChecked_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendChatChecked_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendChatChecked_result(e: e)
  }

}



fileprivate final class TalkService_sendChatRemoved_args {

  fileprivate var seq: Int32

  fileprivate var consumer: String

  fileprivate var lastMessageId: String


  fileprivate init(seq: Int32, consumer: String, lastMessageId: String) {
    self.seq = seq
    self.consumer = consumer
    self.lastMessageId = lastMessageId
  }

}

fileprivate func ==(lhs: TalkService_sendChatRemoved_args, rhs: TalkService_sendChatRemoved_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.consumer == rhs.consumer) &&
    (lhs.lastMessageId == rhs.lastMessageId)
}

extension TalkService_sendChatRemoved_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (consumer.hashValue)
    result = prime &* result &+ (lastMessageId.hashValue)
    return result
  }

}

extension TalkService_sendChatRemoved_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "consumer": 2, "lastMessageId": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_sendChatRemoved_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendChatRemoved_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var consumer: String!
    var lastMessageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           consumer = try String.read(from: proto)
        case (3, .string):           lastMessageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(consumer, named: "consumer")
    try proto.validateValue(lastMessageId, named: "lastMessageId")

    return TalkService_sendChatRemoved_args(seq: seq, consumer: consumer, lastMessageId: lastMessageId)
  }

}



fileprivate final class TalkService_sendChatRemoved_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendChatRemoved_result, rhs: TalkService_sendChatRemoved_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_sendChatRemoved_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendChatRemoved_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendChatRemoved_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendChatRemoved_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendChatRemoved_result(e: e)
  }

}



fileprivate final class TalkService_sendContentPreviewUpdated_args {

  fileprivate var esq: Int32

  fileprivate var messageId: String

  fileprivate var receiverMids: TList<String>


  fileprivate init(esq: Int32, messageId: String, receiverMids: TList<String>) {
    self.esq = esq
    self.messageId = messageId
    self.receiverMids = receiverMids
  }

}

fileprivate func ==(lhs: TalkService_sendContentPreviewUpdated_args, rhs: TalkService_sendContentPreviewUpdated_args) -> Bool {
  return
    (lhs.esq == rhs.esq) &&
    (lhs.messageId == rhs.messageId) &&
    (lhs.receiverMids == rhs.receiverMids)
}

extension TalkService_sendContentPreviewUpdated_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (esq.hashValue)
    result = prime &* result &+ (messageId.hashValue)
    result = prime &* result &+ (receiverMids.hashValue)
    return result
  }

}

extension TalkService_sendContentPreviewUpdated_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["esq": 1, "messageId": 2, "receiverMids": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_sendContentPreviewUpdated_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendContentPreviewUpdated_args {
    _ = try proto.readStructBegin()
    var esq: Int32!
    var messageId: String!
    var receiverMids: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             esq = try Int32.read(from: proto)
        case (2, .string):           messageId = try String.read(from: proto)
        case (3, .list):            receiverMids = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(esq, named: "esq")
    try proto.validateValue(messageId, named: "messageId")
    try proto.validateValue(receiverMids, named: "receiverMids")

    return TalkService_sendContentPreviewUpdated_args(esq: esq, messageId: messageId, receiverMids: receiverMids)
  }

}



fileprivate final class TalkService_sendContentPreviewUpdated_result {

  fileprivate var success: TMap<String, String>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, String>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendContentPreviewUpdated_result, rhs: TalkService_sendContentPreviewUpdated_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_sendContentPreviewUpdated_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendContentPreviewUpdated_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendContentPreviewUpdated_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendContentPreviewUpdated_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, String>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, String>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendContentPreviewUpdated_result(success: success, e: e)
  }

}



fileprivate final class TalkService_sendContentReceipt_args {

  fileprivate var seq: Int32

  fileprivate var consumer: String

  fileprivate var messageId: String


  fileprivate init(seq: Int32, consumer: String, messageId: String) {
    self.seq = seq
    self.consumer = consumer
    self.messageId = messageId
  }

}

fileprivate func ==(lhs: TalkService_sendContentReceipt_args, rhs: TalkService_sendContentReceipt_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.consumer == rhs.consumer) &&
    (lhs.messageId == rhs.messageId)
}

extension TalkService_sendContentReceipt_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (consumer.hashValue)
    result = prime &* result &+ (messageId.hashValue)
    return result
  }

}

extension TalkService_sendContentReceipt_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "consumer": 2, "messageId": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_sendContentReceipt_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendContentReceipt_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var consumer: String!
    var messageId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           consumer = try String.read(from: proto)
        case (3, .string):           messageId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(consumer, named: "consumer")
    try proto.validateValue(messageId, named: "messageId")

    return TalkService_sendContentReceipt_args(seq: seq, consumer: consumer, messageId: messageId)
  }

}



fileprivate final class TalkService_sendContentReceipt_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendContentReceipt_result, rhs: TalkService_sendContentReceipt_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_sendContentReceipt_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendContentReceipt_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendContentReceipt_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendContentReceipt_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendContentReceipt_result(e: e)
  }

}



fileprivate final class TalkService_sendDummyPush_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_sendDummyPush_args, rhs: TalkService_sendDummyPush_args) -> Bool {
  return true
}

extension TalkService_sendDummyPush_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_sendDummyPush_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_sendDummyPush_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendDummyPush_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendDummyPush_args()
  }

}



fileprivate final class TalkService_sendDummyPush_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendDummyPush_result, rhs: TalkService_sendDummyPush_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_sendDummyPush_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendDummyPush_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendDummyPush_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendDummyPush_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendDummyPush_result(e: e)
  }

}



fileprivate final class TalkService_sendEvent_args {

  fileprivate var seq: Int32

  fileprivate var message: Message


  fileprivate init(seq: Int32, message: Message) {
    self.seq = seq
    self.message = message
  }

}

fileprivate func ==(lhs: TalkService_sendEvent_args, rhs: TalkService_sendEvent_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.message == rhs.message)
}

extension TalkService_sendEvent_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension TalkService_sendEvent_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "message": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_sendEvent_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendEvent_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var message: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .struct):           message = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(message, named: "message")

    return TalkService_sendEvent_args(seq: seq, message: message)
  }

}



fileprivate final class TalkService_sendEvent_result {

  fileprivate var success: Message?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Message?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendEvent_result, rhs: TalkService_sendEvent_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_sendEvent_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendEvent_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendEvent_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendEvent_result {
    _ = try proto.readStructBegin()
    var success: Message?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Message.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendEvent_result(success: success, e: e)
  }

}



fileprivate final class TalkService_sendMessage_args {

  fileprivate var seq: Int32

  fileprivate var message: Message


  fileprivate init(seq: Int32, message: Message) {
    self.seq = seq
    self.message = message
  }

}

fileprivate func ==(lhs: TalkService_sendMessage_args, rhs: TalkService_sendMessage_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.message == rhs.message)
}

extension TalkService_sendMessage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension TalkService_sendMessage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "message": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessage_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var message: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .struct):           message = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(message, named: "message")

    return TalkService_sendMessage_args(seq: seq, message: message)
  }

}



fileprivate final class TalkService_sendMessage_result {

  fileprivate var success: Message?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Message?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendMessage_result, rhs: TalkService_sendMessage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_sendMessage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendMessage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessage_result {
    _ = try proto.readStructBegin()
    var success: Message?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Message.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendMessage_result(success: success, e: e)
  }

}



fileprivate final class TalkService_sendMessageIgnored_args {

  fileprivate var seq: Int32

  fileprivate var consumer: String

  fileprivate var messageIds: TList<String>


  fileprivate init(seq: Int32, consumer: String, messageIds: TList<String>) {
    self.seq = seq
    self.consumer = consumer
    self.messageIds = messageIds
  }

}

fileprivate func ==(lhs: TalkService_sendMessageIgnored_args, rhs: TalkService_sendMessageIgnored_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.consumer == rhs.consumer) &&
    (lhs.messageIds == rhs.messageIds)
}

extension TalkService_sendMessageIgnored_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (consumer.hashValue)
    result = prime &* result &+ (messageIds.hashValue)
    return result
  }

}

extension TalkService_sendMessageIgnored_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "consumer": 2, "messageIds": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessageIgnored_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessageIgnored_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var consumer: String!
    var messageIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           consumer = try String.read(from: proto)
        case (3, .list):            messageIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(consumer, named: "consumer")
    try proto.validateValue(messageIds, named: "messageIds")

    return TalkService_sendMessageIgnored_args(seq: seq, consumer: consumer, messageIds: messageIds)
  }

}



fileprivate final class TalkService_sendMessageIgnored_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendMessageIgnored_result, rhs: TalkService_sendMessageIgnored_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_sendMessageIgnored_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendMessageIgnored_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessageIgnored_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessageIgnored_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendMessageIgnored_result(e: e)
  }

}



fileprivate final class TalkService_sendMessageReceipt_args {

  fileprivate var seq: Int32

  fileprivate var consumer: String

  fileprivate var messageIds: TList<String>


  fileprivate init(seq: Int32, consumer: String, messageIds: TList<String>) {
    self.seq = seq
    self.consumer = consumer
    self.messageIds = messageIds
  }

}

fileprivate func ==(lhs: TalkService_sendMessageReceipt_args, rhs: TalkService_sendMessageReceipt_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.consumer == rhs.consumer) &&
    (lhs.messageIds == rhs.messageIds)
}

extension TalkService_sendMessageReceipt_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (consumer.hashValue)
    result = prime &* result &+ (messageIds.hashValue)
    return result
  }

}

extension TalkService_sendMessageReceipt_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "consumer": 2, "messageIds": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessageReceipt_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessageReceipt_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var consumer: String!
    var messageIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .string):           consumer = try String.read(from: proto)
        case (3, .list):            messageIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(consumer, named: "consumer")
    try proto.validateValue(messageIds, named: "messageIds")

    return TalkService_sendMessageReceipt_args(seq: seq, consumer: consumer, messageIds: messageIds)
  }

}



fileprivate final class TalkService_sendMessageReceipt_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendMessageReceipt_result, rhs: TalkService_sendMessageReceipt_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_sendMessageReceipt_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendMessageReceipt_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessageReceipt_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessageReceipt_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendMessageReceipt_result(e: e)
  }

}



fileprivate final class TalkService_sendMessageToMyHome_args {

  fileprivate var seq: Int32

  fileprivate var message: Message


  fileprivate init(seq: Int32, message: Message) {
    self.seq = seq
    self.message = message
  }

}

fileprivate func ==(lhs: TalkService_sendMessageToMyHome_args, rhs: TalkService_sendMessageToMyHome_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.message == rhs.message)
}

extension TalkService_sendMessageToMyHome_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension TalkService_sendMessageToMyHome_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "message": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessageToMyHome_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessageToMyHome_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var message: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .struct):           message = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(message, named: "message")

    return TalkService_sendMessageToMyHome_args(seq: seq, message: message)
  }

}



fileprivate final class TalkService_sendMessageToMyHome_result {

  fileprivate var success: Message?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Message?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_sendMessageToMyHome_result, rhs: TalkService_sendMessageToMyHome_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_sendMessageToMyHome_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_sendMessageToMyHome_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_sendMessageToMyHome_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_sendMessageToMyHome_result {
    _ = try proto.readStructBegin()
    var success: Message?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Message.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_sendMessageToMyHome_result(success: success, e: e)
  }

}



fileprivate final class TalkService_setBuddyLocation_args {

  fileprivate var mid: String

  fileprivate var index: Int32

  fileprivate var location: Geolocation


  fileprivate init(mid: String, index: Int32, location: Geolocation) {
    self.mid = mid
    self.index = index
    self.location = location
  }

}

fileprivate func ==(lhs: TalkService_setBuddyLocation_args, rhs: TalkService_setBuddyLocation_args) -> Bool {
  return
    (lhs.mid == rhs.mid) &&
    (lhs.index == rhs.index) &&
    (lhs.location == rhs.location)
}

extension TalkService_setBuddyLocation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (index.hashValue)
    result = prime &* result &+ (location.hashValue)
    return result
  }

}

extension TalkService_setBuddyLocation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["mid": 2, "index": 3, "location": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_setBuddyLocation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_setBuddyLocation_args {
    _ = try proto.readStructBegin()
    var mid: String!
    var index: Int32!
    var location: Geolocation!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           mid = try String.read(from: proto)
        case (3, .i32):             index = try Int32.read(from: proto)
        case (4, .struct):           location = try Geolocation.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(index, named: "index")
    try proto.validateValue(location, named: "location")

    return TalkService_setBuddyLocation_args(mid: mid, index: index, location: location)
  }

}



fileprivate final class TalkService_setBuddyLocation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_setBuddyLocation_result, rhs: TalkService_setBuddyLocation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_setBuddyLocation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_setBuddyLocation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_setBuddyLocation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_setBuddyLocation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_setBuddyLocation_result(e: e)
  }

}



fileprivate final class TalkService_setIdentityCredential_args {

  fileprivate var identifier: String

  fileprivate var verifier: String

  fileprivate var provider: IdentityProvider


  fileprivate init(provider: IdentityProvider, identifier: String, verifier: String) {
    self.provider = provider
    self.identifier = identifier
    self.verifier = verifier
  }

}

fileprivate func ==(lhs: TalkService_setIdentityCredential_args, rhs: TalkService_setIdentityCredential_args) -> Bool {
  return
    (lhs.provider == rhs.provider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.verifier == rhs.verifier)
}

extension TalkService_setIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (provider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (verifier.hashValue)
    return result
  }

}

extension TalkService_setIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["provider": 4, "identifier": 2, "verifier": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_setIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_setIdentityCredential_args {
    _ = try proto.readStructBegin()
    var provider: IdentityProvider!
    var identifier: String!
    var verifier: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (4, .i32):             provider = try IdentityProvider.read(from: proto)
        case (2, .string):           identifier = try String.read(from: proto)
        case (3, .string):           verifier = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(provider, named: "provider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(verifier, named: "verifier")

    return TalkService_setIdentityCredential_args(provider: provider, identifier: identifier, verifier: verifier)
  }

}



fileprivate final class TalkService_setIdentityCredential_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_setIdentityCredential_result, rhs: TalkService_setIdentityCredential_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_setIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_setIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_setIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_setIdentityCredential_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_setIdentityCredential_result(e: e)
  }

}



fileprivate final class TalkService_setNotificationsEnabled_args {

  fileprivate var reqSeq: Int32

  fileprivate var type: MIDType

  fileprivate var target: String

  fileprivate var enablement: Bool


  fileprivate init(reqSeq: Int32, type: MIDType, target: String, enablement: Bool) {
    self.reqSeq = reqSeq
    self.type = type
    self.target = target
    self.enablement = enablement
  }

}

fileprivate func ==(lhs: TalkService_setNotificationsEnabled_args, rhs: TalkService_setNotificationsEnabled_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.type == rhs.type) &&
    (lhs.target == rhs.target) &&
    (lhs.enablement == rhs.enablement)
}

extension TalkService_setNotificationsEnabled_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (target.hashValue)
    result = prime &* result &+ (enablement.hashValue)
    return result
  }

}

extension TalkService_setNotificationsEnabled_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "type": 2, "target": 3, "enablement": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_setNotificationsEnabled_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_setNotificationsEnabled_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var type: MIDType!
    var target: String!
    var enablement: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .i32):             type = try MIDType.read(from: proto)
        case (3, .string):           target = try String.read(from: proto)
        case (4, .bool):            enablement = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(type, named: "type")
    try proto.validateValue(target, named: "target")
    try proto.validateValue(enablement, named: "enablement")

    return TalkService_setNotificationsEnabled_args(reqSeq: reqSeq, type: type, target: target, enablement: enablement)
  }

}



fileprivate final class TalkService_setNotificationsEnabled_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_setNotificationsEnabled_result, rhs: TalkService_setNotificationsEnabled_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_setNotificationsEnabled_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_setNotificationsEnabled_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_setNotificationsEnabled_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_setNotificationsEnabled_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_setNotificationsEnabled_result(e: e)
  }

}



fileprivate final class TalkService_startUpdateVerification_args {

  fileprivate var region: String

  fileprivate var carrier: CarrierCode

  fileprivate var phone: String

  fileprivate var udidHash: String

  fileprivate var deviceInfo: DeviceInfo

  fileprivate var networkCode: String

  fileprivate var locale: String


  fileprivate init(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, locale: String) {
    self.region = region
    self.carrier = carrier
    self.phone = phone
    self.udidHash = udidHash
    self.deviceInfo = deviceInfo
    self.networkCode = networkCode
    self.locale = locale
  }

}

fileprivate func ==(lhs: TalkService_startUpdateVerification_args, rhs: TalkService_startUpdateVerification_args) -> Bool {
  return
    (lhs.region == rhs.region) &&
    (lhs.carrier == rhs.carrier) &&
    (lhs.phone == rhs.phone) &&
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.deviceInfo == rhs.deviceInfo) &&
    (lhs.networkCode == rhs.networkCode) &&
    (lhs.locale == rhs.locale)
}

extension TalkService_startUpdateVerification_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (region.hashValue)
    result = prime &* result &+ (carrier.hashValue)
    result = prime &* result &+ (phone.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    result = prime &* result &+ (networkCode.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension TalkService_startUpdateVerification_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["region": 2, "carrier": 3, "phone": 4, "udidHash": 5, "deviceInfo": 6, "networkCode": 7, "locale": 8, ]
  }

  fileprivate static var structName: String { return "TalkService_startUpdateVerification_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_startUpdateVerification_args {
    _ = try proto.readStructBegin()
    var region: String!
    var carrier: CarrierCode!
    var phone: String!
    var udidHash: String!
    var deviceInfo: DeviceInfo!
    var networkCode: String!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           region = try String.read(from: proto)
        case (3, .i32):             carrier = try CarrierCode.read(from: proto)
        case (4, .string):           phone = try String.read(from: proto)
        case (5, .string):           udidHash = try String.read(from: proto)
        case (6, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case (7, .string):           networkCode = try String.read(from: proto)
        case (8, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(region, named: "region")
    try proto.validateValue(carrier, named: "carrier")
    try proto.validateValue(phone, named: "phone")
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(deviceInfo, named: "deviceInfo")
    try proto.validateValue(networkCode, named: "networkCode")
    try proto.validateValue(locale, named: "locale")

    return TalkService_startUpdateVerification_args(region: region, carrier: carrier, phone: phone, udidHash: udidHash, deviceInfo: deviceInfo, networkCode: networkCode, locale: locale)
  }

}



fileprivate final class TalkService_startUpdateVerification_result {

  fileprivate var success: VerificationSessionData?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: VerificationSessionData?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_startUpdateVerification_result, rhs: TalkService_startUpdateVerification_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_startUpdateVerification_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_startUpdateVerification_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_startUpdateVerification_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_startUpdateVerification_result {
    _ = try proto.readStructBegin()
    var success: VerificationSessionData?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try VerificationSessionData.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_startUpdateVerification_result(success: success, e: e)
  }

}



fileprivate final class TalkService_startVerification_args {

  fileprivate var region: String

  fileprivate var carrier: CarrierCode

  fileprivate var phone: String

  fileprivate var udidHash: String

  fileprivate var deviceInfo: DeviceInfo

  fileprivate var networkCode: String

  fileprivate var mid: String

  fileprivate var locale: String


  fileprivate init(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, mid: String, locale: String) {
    self.region = region
    self.carrier = carrier
    self.phone = phone
    self.udidHash = udidHash
    self.deviceInfo = deviceInfo
    self.networkCode = networkCode
    self.mid = mid
    self.locale = locale
  }

}

fileprivate func ==(lhs: TalkService_startVerification_args, rhs: TalkService_startVerification_args) -> Bool {
  return
    (lhs.region == rhs.region) &&
    (lhs.carrier == rhs.carrier) &&
    (lhs.phone == rhs.phone) &&
    (lhs.udidHash == rhs.udidHash) &&
    (lhs.deviceInfo == rhs.deviceInfo) &&
    (lhs.networkCode == rhs.networkCode) &&
    (lhs.mid == rhs.mid) &&
    (lhs.locale == rhs.locale)
}

extension TalkService_startVerification_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (region.hashValue)
    result = prime &* result &+ (carrier.hashValue)
    result = prime &* result &+ (phone.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    result = prime &* result &+ (networkCode.hashValue)
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (locale.hashValue)
    return result
  }

}

extension TalkService_startVerification_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["region": 2, "carrier": 3, "phone": 4, "udidHash": 5, "deviceInfo": 6, "networkCode": 7, "mid": 8, "locale": 9, ]
  }

  fileprivate static var structName: String { return "TalkService_startVerification_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_startVerification_args {
    _ = try proto.readStructBegin()
    var region: String!
    var carrier: CarrierCode!
    var phone: String!
    var udidHash: String!
    var deviceInfo: DeviceInfo!
    var networkCode: String!
    var mid: String!
    var locale: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           region = try String.read(from: proto)
        case (3, .i32):             carrier = try CarrierCode.read(from: proto)
        case (4, .string):           phone = try String.read(from: proto)
        case (5, .string):           udidHash = try String.read(from: proto)
        case (6, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case (7, .string):           networkCode = try String.read(from: proto)
        case (8, .string):           mid = try String.read(from: proto)
        case (9, .string):           locale = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(region, named: "region")
    try proto.validateValue(carrier, named: "carrier")
    try proto.validateValue(phone, named: "phone")
    try proto.validateValue(udidHash, named: "udidHash")
    try proto.validateValue(deviceInfo, named: "deviceInfo")
    try proto.validateValue(networkCode, named: "networkCode")
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(locale, named: "locale")

    return TalkService_startVerification_args(region: region, carrier: carrier, phone: phone, udidHash: udidHash, deviceInfo: deviceInfo, networkCode: networkCode, mid: mid, locale: locale)
  }

}



fileprivate final class TalkService_startVerification_result {

  fileprivate var success: VerificationSessionData?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: VerificationSessionData?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_startVerification_result, rhs: TalkService_startVerification_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_startVerification_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_startVerification_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_startVerification_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_startVerification_result {
    _ = try proto.readStructBegin()
    var success: VerificationSessionData?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try VerificationSessionData.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_startVerification_result(success: success, e: e)
  }

}



fileprivate final class TalkService_storeUpdateProfileAttribute_args {

  fileprivate var seq: Int32

  fileprivate var profileAttribute: ProfileAttribute

  fileprivate var value: String


  fileprivate init(seq: Int32, profileAttribute: ProfileAttribute, value: String) {
    self.seq = seq
    self.profileAttribute = profileAttribute
    self.value = value
  }

}

fileprivate func ==(lhs: TalkService_storeUpdateProfileAttribute_args, rhs: TalkService_storeUpdateProfileAttribute_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.profileAttribute == rhs.profileAttribute) &&
    (lhs.value == rhs.value)
}

extension TalkService_storeUpdateProfileAttribute_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (profileAttribute.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension TalkService_storeUpdateProfileAttribute_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "profileAttribute": 2, "value": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_storeUpdateProfileAttribute_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_storeUpdateProfileAttribute_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var profileAttribute: ProfileAttribute!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .i32):             profileAttribute = try ProfileAttribute.read(from: proto)
        case (3, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(profileAttribute, named: "profileAttribute")
    try proto.validateValue(value, named: "value")

    return TalkService_storeUpdateProfileAttribute_args(seq: seq, profileAttribute: profileAttribute, value: value)
  }

}



fileprivate final class TalkService_storeUpdateProfileAttribute_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_storeUpdateProfileAttribute_result, rhs: TalkService_storeUpdateProfileAttribute_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_storeUpdateProfileAttribute_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_storeUpdateProfileAttribute_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_storeUpdateProfileAttribute_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_storeUpdateProfileAttribute_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_storeUpdateProfileAttribute_result(e: e)
  }

}



fileprivate final class TalkService_syncContactBySnsIds_args {

  fileprivate var reqSeq: Int32

  fileprivate var modifications: TList<SnsFriendModification>


  fileprivate init(reqSeq: Int32, modifications: TList<SnsFriendModification>) {
    self.reqSeq = reqSeq
    self.modifications = modifications
  }

}

fileprivate func ==(lhs: TalkService_syncContactBySnsIds_args, rhs: TalkService_syncContactBySnsIds_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.modifications == rhs.modifications)
}

extension TalkService_syncContactBySnsIds_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (modifications.hashValue)
    return result
  }

}

extension TalkService_syncContactBySnsIds_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "modifications": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_syncContactBySnsIds_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_syncContactBySnsIds_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var modifications: TList<SnsFriendModification>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .list):            modifications = try TList<SnsFriendModification>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(modifications, named: "modifications")

    return TalkService_syncContactBySnsIds_args(reqSeq: reqSeq, modifications: modifications)
  }

}



fileprivate final class TalkService_syncContactBySnsIds_result {

  fileprivate var success: TList<SnsFriendContactRegistration>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TList<SnsFriendContactRegistration>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_syncContactBySnsIds_result, rhs: TalkService_syncContactBySnsIds_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_syncContactBySnsIds_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_syncContactBySnsIds_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_syncContactBySnsIds_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_syncContactBySnsIds_result {
    _ = try proto.readStructBegin()
    var success: TList<SnsFriendContactRegistration>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<SnsFriendContactRegistration>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_syncContactBySnsIds_result(success: success, e: e)
  }

}



fileprivate final class TalkService_syncContacts_args {

  fileprivate var reqSeq: Int32

  fileprivate var localContacts: TList<ContactModification>


  fileprivate init(reqSeq: Int32, localContacts: TList<ContactModification>) {
    self.reqSeq = reqSeq
    self.localContacts = localContacts
  }

}

fileprivate func ==(lhs: TalkService_syncContacts_args, rhs: TalkService_syncContacts_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.localContacts == rhs.localContacts)
}

extension TalkService_syncContacts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (localContacts.hashValue)
    return result
  }

}

extension TalkService_syncContacts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "localContacts": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_syncContacts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_syncContacts_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var localContacts: TList<ContactModification>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .list):            localContacts = try TList<ContactModification>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(localContacts, named: "localContacts")

    return TalkService_syncContacts_args(reqSeq: reqSeq, localContacts: localContacts)
  }

}



fileprivate final class TalkService_syncContacts_result {

  fileprivate var success: TMap<String, ContactRegistration>?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: TMap<String, ContactRegistration>?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_syncContacts_result, rhs: TalkService_syncContacts_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_syncContacts_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_syncContacts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_syncContacts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_syncContacts_result {
    _ = try proto.readStructBegin()
    var success: TMap<String, ContactRegistration>?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .map):             success = try TMap<String, ContactRegistration>.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_syncContacts_result(success: success, e: e)
  }

}



fileprivate final class TalkService_trySendMessage_args {

  fileprivate var seq: Int32

  fileprivate var message: Message


  fileprivate init(seq: Int32, message: Message) {
    self.seq = seq
    self.message = message
  }

}

fileprivate func ==(lhs: TalkService_trySendMessage_args, rhs: TalkService_trySendMessage_args) -> Bool {
  return
    (lhs.seq == rhs.seq) &&
    (lhs.message == rhs.message)
}

extension TalkService_trySendMessage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (seq.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension TalkService_trySendMessage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["seq": 1, "message": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_trySendMessage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_trySendMessage_args {
    _ = try proto.readStructBegin()
    var seq: Int32!
    var message: Message!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             seq = try Int32.read(from: proto)
        case (2, .struct):           message = try Message.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(seq, named: "seq")
    try proto.validateValue(message, named: "message")

    return TalkService_trySendMessage_args(seq: seq, message: message)
  }

}



fileprivate final class TalkService_trySendMessage_result {

  fileprivate var success: Message?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Message?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_trySendMessage_result, rhs: TalkService_trySendMessage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_trySendMessage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_trySendMessage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_trySendMessage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_trySendMessage_result {
    _ = try proto.readStructBegin()
    var success: Message?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Message.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_trySendMessage_result(success: success, e: e)
  }

}



fileprivate final class TalkService_unblockContact_args {

  fileprivate var reqSeq: Int32

  fileprivate var id: String


  fileprivate init(reqSeq: Int32, id: String) {
    self.reqSeq = reqSeq
    self.id = id
  }

}

fileprivate func ==(lhs: TalkService_unblockContact_args, rhs: TalkService_unblockContact_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.id == rhs.id)
}

extension TalkService_unblockContact_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (id.hashValue)
    return result
  }

}

extension TalkService_unblockContact_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "id": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_unblockContact_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_unblockContact_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var id: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           id = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(id, named: "id")

    return TalkService_unblockContact_args(reqSeq: reqSeq, id: id)
  }

}



fileprivate final class TalkService_unblockContact_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_unblockContact_result, rhs: TalkService_unblockContact_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_unblockContact_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_unblockContact_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_unblockContact_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_unblockContact_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_unblockContact_result(e: e)
  }

}



fileprivate final class TalkService_unblockRecommendation_args {

  fileprivate var reqSeq: Int32

  fileprivate var id: String


  fileprivate init(reqSeq: Int32, id: String) {
    self.reqSeq = reqSeq
    self.id = id
  }

}

fileprivate func ==(lhs: TalkService_unblockRecommendation_args, rhs: TalkService_unblockRecommendation_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.id == rhs.id)
}

extension TalkService_unblockRecommendation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (id.hashValue)
    return result
  }

}

extension TalkService_unblockRecommendation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "id": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_unblockRecommendation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_unblockRecommendation_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var id: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           id = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(id, named: "id")

    return TalkService_unblockRecommendation_args(reqSeq: reqSeq, id: id)
  }

}



fileprivate final class TalkService_unblockRecommendation_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_unblockRecommendation_result, rhs: TalkService_unblockRecommendation_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_unblockRecommendation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_unblockRecommendation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_unblockRecommendation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_unblockRecommendation_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_unblockRecommendation_result(e: e)
  }

}



fileprivate final class TalkService_unregisterUserAndDevice_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TalkService_unregisterUserAndDevice_args, rhs: TalkService_unregisterUserAndDevice_args) -> Bool {
  return true
}

extension TalkService_unregisterUserAndDevice_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension TalkService_unregisterUserAndDevice_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TalkService_unregisterUserAndDevice_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_unregisterUserAndDevice_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_unregisterUserAndDevice_args()
  }

}



fileprivate final class TalkService_unregisterUserAndDevice_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_unregisterUserAndDevice_result, rhs: TalkService_unregisterUserAndDevice_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_unregisterUserAndDevice_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_unregisterUserAndDevice_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_unregisterUserAndDevice_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_unregisterUserAndDevice_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_unregisterUserAndDevice_result(success: success, e: e)
  }

}



fileprivate final class TalkService_updateApnsDeviceToken_args {

  fileprivate var apnsDeviceToken: Data


  fileprivate init(apnsDeviceToken: Data) {
    self.apnsDeviceToken = apnsDeviceToken
  }

}

fileprivate func ==(lhs: TalkService_updateApnsDeviceToken_args, rhs: TalkService_updateApnsDeviceToken_args) -> Bool {
  return
    (lhs.apnsDeviceToken == rhs.apnsDeviceToken)
}

extension TalkService_updateApnsDeviceToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (apnsDeviceToken.hashValue)
    return result
  }

}

extension TalkService_updateApnsDeviceToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["apnsDeviceToken": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateApnsDeviceToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateApnsDeviceToken_args {
    _ = try proto.readStructBegin()
    var apnsDeviceToken: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           apnsDeviceToken = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(apnsDeviceToken, named: "apnsDeviceToken")

    return TalkService_updateApnsDeviceToken_args(apnsDeviceToken: apnsDeviceToken)
  }

}



fileprivate final class TalkService_updateApnsDeviceToken_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateApnsDeviceToken_result, rhs: TalkService_updateApnsDeviceToken_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateApnsDeviceToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateApnsDeviceToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateApnsDeviceToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateApnsDeviceToken_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateApnsDeviceToken_result(e: e)
  }

}



fileprivate final class TalkService_updateBuddySetting_args {

  fileprivate var key: String

  fileprivate var value: String


  fileprivate init(key: String, value: String) {
    self.key = key
    self.value = value
  }

}

fileprivate func ==(lhs: TalkService_updateBuddySetting_args, rhs: TalkService_updateBuddySetting_args) -> Bool {
  return
    (lhs.key == rhs.key) &&
    (lhs.value == rhs.value)
}

extension TalkService_updateBuddySetting_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (key.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension TalkService_updateBuddySetting_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["key": 2, "value": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_updateBuddySetting_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateBuddySetting_args {
    _ = try proto.readStructBegin()
    var key: String!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           key = try String.read(from: proto)
        case (3, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(key, named: "key")
    try proto.validateValue(value, named: "value")

    return TalkService_updateBuddySetting_args(key: key, value: value)
  }

}



fileprivate final class TalkService_updateBuddySetting_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateBuddySetting_result, rhs: TalkService_updateBuddySetting_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateBuddySetting_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateBuddySetting_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateBuddySetting_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateBuddySetting_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateBuddySetting_result(e: e)
  }

}



fileprivate final class TalkService_updateC2DMRegistrationId_args {

  fileprivate var registrationId: String


  fileprivate init(registrationId: String) {
    self.registrationId = registrationId
  }

}

fileprivate func ==(lhs: TalkService_updateC2DMRegistrationId_args, rhs: TalkService_updateC2DMRegistrationId_args) -> Bool {
  return
    (lhs.registrationId == rhs.registrationId)
}

extension TalkService_updateC2DMRegistrationId_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (registrationId.hashValue)
    return result
  }

}

extension TalkService_updateC2DMRegistrationId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["registrationId": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateC2DMRegistrationId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateC2DMRegistrationId_args {
    _ = try proto.readStructBegin()
    var registrationId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           registrationId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(registrationId, named: "registrationId")

    return TalkService_updateC2DMRegistrationId_args(registrationId: registrationId)
  }

}



fileprivate final class TalkService_updateC2DMRegistrationId_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateC2DMRegistrationId_result, rhs: TalkService_updateC2DMRegistrationId_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateC2DMRegistrationId_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateC2DMRegistrationId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateC2DMRegistrationId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateC2DMRegistrationId_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateC2DMRegistrationId_result(e: e)
  }

}



fileprivate final class TalkService_updateContactSetting_args {

  fileprivate var reqSeq: Int32

  fileprivate var mid: String

  fileprivate var flag: ContactSetting

  fileprivate var value: String


  fileprivate init(reqSeq: Int32, mid: String, flag: ContactSetting, value: String) {
    self.reqSeq = reqSeq
    self.mid = mid
    self.flag = flag
    self.value = value
  }

}

fileprivate func ==(lhs: TalkService_updateContactSetting_args, rhs: TalkService_updateContactSetting_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.mid == rhs.mid) &&
    (lhs.flag == rhs.flag) &&
    (lhs.value == rhs.value)
}

extension TalkService_updateContactSetting_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (mid.hashValue)
    result = prime &* result &+ (flag.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension TalkService_updateContactSetting_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "mid": 2, "flag": 3, "value": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_updateContactSetting_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateContactSetting_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var mid: String!
    var flag: ContactSetting!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .string):           mid = try String.read(from: proto)
        case (3, .i32):             flag = try ContactSetting.read(from: proto)
        case (4, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(mid, named: "mid")
    try proto.validateValue(flag, named: "flag")
    try proto.validateValue(value, named: "value")

    return TalkService_updateContactSetting_args(reqSeq: reqSeq, mid: mid, flag: flag, value: value)
  }

}



fileprivate final class TalkService_updateContactSetting_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateContactSetting_result, rhs: TalkService_updateContactSetting_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateContactSetting_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateContactSetting_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateContactSetting_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateContactSetting_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateContactSetting_result(e: e)
  }

}



fileprivate final class TalkService_updateCustomModeSettings_args {

  fileprivate var customMode: CustomMode

  fileprivate var paramMap: TMap<String, String>


  fileprivate init(customMode: CustomMode, paramMap: TMap<String, String>) {
    self.customMode = customMode
    self.paramMap = paramMap
  }

}

fileprivate func ==(lhs: TalkService_updateCustomModeSettings_args, rhs: TalkService_updateCustomModeSettings_args) -> Bool {
  return
    (lhs.customMode == rhs.customMode) &&
    (lhs.paramMap == rhs.paramMap)
}

extension TalkService_updateCustomModeSettings_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (customMode.hashValue)
    result = prime &* result &+ (paramMap.hashValue)
    return result
  }

}

extension TalkService_updateCustomModeSettings_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["customMode": 2, "paramMap": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_updateCustomModeSettings_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateCustomModeSettings_args {
    _ = try proto.readStructBegin()
    var customMode: CustomMode!
    var paramMap: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .i32):             customMode = try CustomMode.read(from: proto)
        case (3, .map):             paramMap = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(customMode, named: "customMode")
    try proto.validateValue(paramMap, named: "paramMap")

    return TalkService_updateCustomModeSettings_args(customMode: customMode, paramMap: paramMap)
  }

}



fileprivate final class TalkService_updateCustomModeSettings_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateCustomModeSettings_result, rhs: TalkService_updateCustomModeSettings_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateCustomModeSettings_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateCustomModeSettings_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateCustomModeSettings_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateCustomModeSettings_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateCustomModeSettings_result(e: e)
  }

}



fileprivate final class TalkService_updateDeviceInfo_args {

  fileprivate var deviceUid: String

  fileprivate var deviceInfo: DeviceInfo


  fileprivate init(deviceUid: String, deviceInfo: DeviceInfo) {
    self.deviceUid = deviceUid
    self.deviceInfo = deviceInfo
  }

}

fileprivate func ==(lhs: TalkService_updateDeviceInfo_args, rhs: TalkService_updateDeviceInfo_args) -> Bool {
  return
    (lhs.deviceUid == rhs.deviceUid) &&
    (lhs.deviceInfo == rhs.deviceInfo)
}

extension TalkService_updateDeviceInfo_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (deviceUid.hashValue)
    result = prime &* result &+ (deviceInfo.hashValue)
    return result
  }

}

extension TalkService_updateDeviceInfo_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["deviceUid": 2, "deviceInfo": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_updateDeviceInfo_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateDeviceInfo_args {
    _ = try proto.readStructBegin()
    var deviceUid: String!
    var deviceInfo: DeviceInfo!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           deviceUid = try String.read(from: proto)
        case (3, .struct):           deviceInfo = try DeviceInfo.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(deviceUid, named: "deviceUid")
    try proto.validateValue(deviceInfo, named: "deviceInfo")

    return TalkService_updateDeviceInfo_args(deviceUid: deviceUid, deviceInfo: deviceInfo)
  }

}



fileprivate final class TalkService_updateDeviceInfo_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateDeviceInfo_result, rhs: TalkService_updateDeviceInfo_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateDeviceInfo_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateDeviceInfo_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateDeviceInfo_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateDeviceInfo_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateDeviceInfo_result(e: e)
  }

}



fileprivate final class TalkService_updateGroup_args {

  fileprivate var reqSeq: Int32

  fileprivate var group: Group


  fileprivate init(reqSeq: Int32, group: Group) {
    self.reqSeq = reqSeq
    self.group = group
  }

}

fileprivate func ==(lhs: TalkService_updateGroup_args, rhs: TalkService_updateGroup_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.group == rhs.group)
}

extension TalkService_updateGroup_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (group.hashValue)
    return result
  }

}

extension TalkService_updateGroup_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "group": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateGroup_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateGroup_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var group: Group!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .struct):           group = try Group.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(group, named: "group")

    return TalkService_updateGroup_args(reqSeq: reqSeq, group: group)
  }

}



fileprivate final class TalkService_updateGroup_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateGroup_result, rhs: TalkService_updateGroup_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateGroup_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateGroup_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateGroup_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateGroup_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateGroup_result(e: e)
  }

}



fileprivate final class TalkService_updateNotificationToken_args {

  fileprivate var token: String

  fileprivate var type: NotificationType


  fileprivate init(type: NotificationType, token: String) {
    self.type = type
    self.token = token
  }

}

fileprivate func ==(lhs: TalkService_updateNotificationToken_args, rhs: TalkService_updateNotificationToken_args) -> Bool {
  return
    (lhs.type == rhs.type) &&
    (lhs.token == rhs.token)
}

extension TalkService_updateNotificationToken_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (token.hashValue)
    return result
  }

}

extension TalkService_updateNotificationToken_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["type": 3, "token": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateNotificationToken_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateNotificationToken_args {
    _ = try proto.readStructBegin()
    var type: NotificationType!
    var token: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .i32):             type = try NotificationType.read(from: proto)
        case (2, .string):           token = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")
    try proto.validateValue(token, named: "token")

    return TalkService_updateNotificationToken_args(type: type, token: token)
  }

}



fileprivate final class TalkService_updateNotificationToken_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateNotificationToken_result, rhs: TalkService_updateNotificationToken_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateNotificationToken_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateNotificationToken_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateNotificationToken_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateNotificationToken_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateNotificationToken_result(e: e)
  }

}



fileprivate final class TalkService_updateNotificationTokenWithBytes_args {

  fileprivate var token: Data

  fileprivate var type: NotificationType


  fileprivate init(type: NotificationType, token: Data) {
    self.type = type
    self.token = token
  }

}

fileprivate func ==(lhs: TalkService_updateNotificationTokenWithBytes_args, rhs: TalkService_updateNotificationTokenWithBytes_args) -> Bool {
  return
    (lhs.type == rhs.type) &&
    (lhs.token == rhs.token)
}

extension TalkService_updateNotificationTokenWithBytes_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (type.hashValue)
    result = prime &* result &+ (token.hashValue)
    return result
  }

}

extension TalkService_updateNotificationTokenWithBytes_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["type": 3, "token": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateNotificationTokenWithBytes_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateNotificationTokenWithBytes_args {
    _ = try proto.readStructBegin()
    var type: NotificationType!
    var token: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (3, .i32):             type = try NotificationType.read(from: proto)
        case (2, .string):           token = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")
    try proto.validateValue(token, named: "token")

    return TalkService_updateNotificationTokenWithBytes_args(type: type, token: token)
  }

}



fileprivate final class TalkService_updateNotificationTokenWithBytes_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateNotificationTokenWithBytes_result, rhs: TalkService_updateNotificationTokenWithBytes_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateNotificationTokenWithBytes_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateNotificationTokenWithBytes_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateNotificationTokenWithBytes_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateNotificationTokenWithBytes_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateNotificationTokenWithBytes_result(e: e)
  }

}



fileprivate final class TalkService_updateProfile_args {

  fileprivate var reqSeq: Int32

  fileprivate var profile: Profile


  fileprivate init(reqSeq: Int32, profile: Profile) {
    self.reqSeq = reqSeq
    self.profile = profile
  }

}

fileprivate func ==(lhs: TalkService_updateProfile_args, rhs: TalkService_updateProfile_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.profile == rhs.profile)
}

extension TalkService_updateProfile_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (profile.hashValue)
    return result
  }

}

extension TalkService_updateProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "profile": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateProfile_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var profile: Profile!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .struct):           profile = try Profile.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(profile, named: "profile")

    return TalkService_updateProfile_args(reqSeq: reqSeq, profile: profile)
  }

}



fileprivate final class TalkService_updateProfile_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateProfile_result, rhs: TalkService_updateProfile_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateProfile_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateProfile_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateProfile_result(e: e)
  }

}



fileprivate final class TalkService_updateProfileAttribute_args {

  fileprivate var reqSeq: Int32

  fileprivate var attr: ProfileAttribute

  fileprivate var value: String


  fileprivate init(reqSeq: Int32, attr: ProfileAttribute, value: String) {
    self.reqSeq = reqSeq
    self.attr = attr
    self.value = value
  }

}

fileprivate func ==(lhs: TalkService_updateProfileAttribute_args, rhs: TalkService_updateProfileAttribute_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.attr == rhs.attr) &&
    (lhs.value == rhs.value)
}

extension TalkService_updateProfileAttribute_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (attr.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension TalkService_updateProfileAttribute_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "attr": 2, "value": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_updateProfileAttribute_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateProfileAttribute_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var attr: ProfileAttribute!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .i32):             attr = try ProfileAttribute.read(from: proto)
        case (3, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(attr, named: "attr")
    try proto.validateValue(value, named: "value")

    return TalkService_updateProfileAttribute_args(reqSeq: reqSeq, attr: attr, value: value)
  }

}



fileprivate final class TalkService_updateProfileAttribute_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateProfileAttribute_result, rhs: TalkService_updateProfileAttribute_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateProfileAttribute_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateProfileAttribute_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateProfileAttribute_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateProfileAttribute_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateProfileAttribute_result(e: e)
  }

}



fileprivate final class TalkService_updateRegion_args {

  fileprivate var region: String


  fileprivate init(region: String) {
    self.region = region
  }

}

fileprivate func ==(lhs: TalkService_updateRegion_args, rhs: TalkService_updateRegion_args) -> Bool {
  return
    (lhs.region == rhs.region)
}

extension TalkService_updateRegion_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (region.hashValue)
    return result
  }

}

extension TalkService_updateRegion_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["region": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateRegion_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateRegion_args {
    _ = try proto.readStructBegin()
    var region: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           region = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(region, named: "region")

    return TalkService_updateRegion_args(region: region)
  }

}



fileprivate final class TalkService_updateRegion_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateRegion_result, rhs: TalkService_updateRegion_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateRegion_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateRegion_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateRegion_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateRegion_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateRegion_result(e: e)
  }

}



fileprivate final class TalkService_updateSettings_args {

  fileprivate var reqSeq: Int32

  fileprivate var settings: Settings


  fileprivate init(reqSeq: Int32, settings: Settings) {
    self.reqSeq = reqSeq
    self.settings = settings
  }

}

fileprivate func ==(lhs: TalkService_updateSettings_args, rhs: TalkService_updateSettings_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.settings == rhs.settings)
}

extension TalkService_updateSettings_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (settings.hashValue)
    return result
  }

}

extension TalkService_updateSettings_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "settings": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettings_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettings_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var settings: Settings!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .struct):           settings = try Settings.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(settings, named: "settings")

    return TalkService_updateSettings_args(reqSeq: reqSeq, settings: settings)
  }

}



fileprivate final class TalkService_updateSettings_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateSettings_result, rhs: TalkService_updateSettings_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateSettings_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateSettings_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettings_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettings_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateSettings_result(e: e)
  }

}



fileprivate final class TalkService_updateSettings2_args {

  fileprivate var reqSeq: Int32

  fileprivate var settings: Settings


  fileprivate init(reqSeq: Int32, settings: Settings) {
    self.reqSeq = reqSeq
    self.settings = settings
  }

}

fileprivate func ==(lhs: TalkService_updateSettings2_args, rhs: TalkService_updateSettings2_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.settings == rhs.settings)
}

extension TalkService_updateSettings2_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (settings.hashValue)
    return result
  }

}

extension TalkService_updateSettings2_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "settings": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettings2_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettings2_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var settings: Settings!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .struct):           settings = try Settings.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(settings, named: "settings")

    return TalkService_updateSettings2_args(reqSeq: reqSeq, settings: settings)
  }

}



fileprivate final class TalkService_updateSettings2_result {

  fileprivate var success: Int32?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int32?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateSettings2_result, rhs: TalkService_updateSettings2_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_updateSettings2_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateSettings2_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettings2_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettings2_result {
    _ = try proto.readStructBegin()
    var success: Int32?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateSettings2_result(success: success, e: e)
  }

}



fileprivate final class TalkService_updateSettingsAttribute_args {

  fileprivate var reqSeq: Int32

  fileprivate var attr: SettingsAttribute

  fileprivate var value: String


  fileprivate init(reqSeq: Int32, attr: SettingsAttribute, value: String) {
    self.reqSeq = reqSeq
    self.attr = attr
    self.value = value
  }

}

fileprivate func ==(lhs: TalkService_updateSettingsAttribute_args, rhs: TalkService_updateSettingsAttribute_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.attr == rhs.attr) &&
    (lhs.value == rhs.value)
}

extension TalkService_updateSettingsAttribute_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (attr.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension TalkService_updateSettingsAttribute_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "attr": 2, "value": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettingsAttribute_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettingsAttribute_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var attr: SettingsAttribute!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .i32):             attr = try SettingsAttribute.read(from: proto)
        case (3, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(attr, named: "attr")
    try proto.validateValue(value, named: "value")

    return TalkService_updateSettingsAttribute_args(reqSeq: reqSeq, attr: attr, value: value)
  }

}



fileprivate final class TalkService_updateSettingsAttribute_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateSettingsAttribute_result, rhs: TalkService_updateSettingsAttribute_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_updateSettingsAttribute_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateSettingsAttribute_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettingsAttribute_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettingsAttribute_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateSettingsAttribute_result(e: e)
  }

}



fileprivate final class TalkService_updateSettingsAttributes_args {

  fileprivate var reqSeq: Int32

  fileprivate var attrBitset: Int32

  fileprivate var settings: Settings


  fileprivate init(reqSeq: Int32, attrBitset: Int32, settings: Settings) {
    self.reqSeq = reqSeq
    self.attrBitset = attrBitset
    self.settings = settings
  }

}

fileprivate func ==(lhs: TalkService_updateSettingsAttributes_args, rhs: TalkService_updateSettingsAttributes_args) -> Bool {
  return
    (lhs.reqSeq == rhs.reqSeq) &&
    (lhs.attrBitset == rhs.attrBitset) &&
    (lhs.settings == rhs.settings)
}

extension TalkService_updateSettingsAttributes_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reqSeq.hashValue)
    result = prime &* result &+ (attrBitset.hashValue)
    result = prime &* result &+ (settings.hashValue)
    return result
  }

}

extension TalkService_updateSettingsAttributes_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reqSeq": 1, "attrBitset": 2, "settings": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettingsAttributes_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettingsAttributes_args {
    _ = try proto.readStructBegin()
    var reqSeq: Int32!
    var attrBitset: Int32!
    var settings: Settings!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reqSeq = try Int32.read(from: proto)
        case (2, .i32):             attrBitset = try Int32.read(from: proto)
        case (3, .struct):           settings = try Settings.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reqSeq, named: "reqSeq")
    try proto.validateValue(attrBitset, named: "attrBitset")
    try proto.validateValue(settings, named: "settings")

    return TalkService_updateSettingsAttributes_args(reqSeq: reqSeq, attrBitset: attrBitset, settings: settings)
  }

}



fileprivate final class TalkService_updateSettingsAttributes_result {

  fileprivate var success: Int32?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: Int32?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_updateSettingsAttributes_result, rhs: TalkService_updateSettingsAttributes_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_updateSettingsAttributes_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_updateSettingsAttributes_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_updateSettingsAttributes_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_updateSettingsAttributes_result {
    _ = try proto.readStructBegin()
    var success: Int32?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_updateSettingsAttributes_result(success: success, e: e)
  }

}



fileprivate final class TalkService_verifyIdentityCredential_args {

  fileprivate var identifier: String

  fileprivate var password: String

  fileprivate var identityProvider: IdentityProvider


  fileprivate init(identityProvider: IdentityProvider, identifier: String, password: String) {
    self.identityProvider = identityProvider
    self.identifier = identifier
    self.password = password
  }

}

fileprivate func ==(lhs: TalkService_verifyIdentityCredential_args, rhs: TalkService_verifyIdentityCredential_args) -> Bool {
  return
    (lhs.identityProvider == rhs.identityProvider) &&
    (lhs.identifier == rhs.identifier) &&
    (lhs.password == rhs.password)
}

extension TalkService_verifyIdentityCredential_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (identityProvider.hashValue)
    result = prime &* result &+ (identifier.hashValue)
    result = prime &* result &+ (password.hashValue)
    return result
  }

}

extension TalkService_verifyIdentityCredential_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["identityProvider": 8, "identifier": 3, "password": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyIdentityCredential_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyIdentityCredential_args {
    _ = try proto.readStructBegin()
    var identityProvider: IdentityProvider!
    var identifier: String!
    var password: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (8, .i32):             identityProvider = try IdentityProvider.read(from: proto)
        case (3, .string):           identifier = try String.read(from: proto)
        case (4, .string):           password = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(identityProvider, named: "identityProvider")
    try proto.validateValue(identifier, named: "identifier")
    try proto.validateValue(password, named: "password")

    return TalkService_verifyIdentityCredential_args(identityProvider: identityProvider, identifier: identifier, password: password)
  }

}



fileprivate final class TalkService_verifyIdentityCredential_result {

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(e: TalkException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_verifyIdentityCredential_result, rhs: TalkService_verifyIdentityCredential_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension TalkService_verifyIdentityCredential_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_verifyIdentityCredential_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyIdentityCredential_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyIdentityCredential_result {
    _ = try proto.readStructBegin()
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_verifyIdentityCredential_result(e: e)
  }

}



fileprivate final class TalkService_verifyIdentityCredentialWithResult_args {

  fileprivate var identityCredential: IdentityCredential


  fileprivate init(identityCredential: IdentityCredential) {
    self.identityCredential = identityCredential
  }

}

fileprivate func ==(lhs: TalkService_verifyIdentityCredentialWithResult_args, rhs: TalkService_verifyIdentityCredentialWithResult_args) -> Bool {
  return
    (lhs.identityCredential == rhs.identityCredential)
}

extension TalkService_verifyIdentityCredentialWithResult_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (identityCredential.hashValue)
    return result
  }

}

extension TalkService_verifyIdentityCredentialWithResult_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["identityCredential": 2, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyIdentityCredentialWithResult_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyIdentityCredentialWithResult_args {
    _ = try proto.readStructBegin()
    var identityCredential: IdentityCredential!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           identityCredential = try IdentityCredential.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(identityCredential, named: "identityCredential")

    return TalkService_verifyIdentityCredentialWithResult_args(identityCredential: identityCredential)
  }

}



fileprivate final class TalkService_verifyIdentityCredentialWithResult_result {

  fileprivate var success: UserAuthStatus?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: UserAuthStatus?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_verifyIdentityCredentialWithResult_result, rhs: TalkService_verifyIdentityCredentialWithResult_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_verifyIdentityCredentialWithResult_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_verifyIdentityCredentialWithResult_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyIdentityCredentialWithResult_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyIdentityCredentialWithResult_result {
    _ = try proto.readStructBegin()
    var success: UserAuthStatus?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try UserAuthStatus.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_verifyIdentityCredentialWithResult_result(success: success, e: e)
  }

}



fileprivate final class TalkService_verifyPhone_args {

  fileprivate var sessionId: String

  fileprivate var pinCode: String

  fileprivate var udidHash: String


  fileprivate init(sessionId: String, pinCode: String, udidHash: String) {
    self.sessionId = sessionId
    self.pinCode = pinCode
    self.udidHash = udidHash
  }

}

fileprivate func ==(lhs: TalkService_verifyPhone_args, rhs: TalkService_verifyPhone_args) -> Bool {
  return
    (lhs.sessionId == rhs.sessionId) &&
    (lhs.pinCode == rhs.pinCode) &&
    (lhs.udidHash == rhs.udidHash)
}

extension TalkService_verifyPhone_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sessionId.hashValue)
    result = prime &* result &+ (pinCode.hashValue)
    result = prime &* result &+ (udidHash.hashValue)
    return result
  }

}

extension TalkService_verifyPhone_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sessionId": 2, "pinCode": 3, "udidHash": 4, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyPhone_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyPhone_args {
    _ = try proto.readStructBegin()
    var sessionId: String!
    var pinCode: String!
    var udidHash: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           sessionId = try String.read(from: proto)
        case (3, .string):           pinCode = try String.read(from: proto)
        case (4, .string):           udidHash = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sessionId, named: "sessionId")
    try proto.validateValue(pinCode, named: "pinCode")
    try proto.validateValue(udidHash, named: "udidHash")

    return TalkService_verifyPhone_args(sessionId: sessionId, pinCode: pinCode, udidHash: udidHash)
  }

}



fileprivate final class TalkService_verifyPhone_result {

  fileprivate var success: VerificationResult?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: VerificationResult?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_verifyPhone_result, rhs: TalkService_verifyPhone_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_verifyPhone_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_verifyPhone_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyPhone_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyPhone_result {
    _ = try proto.readStructBegin()
    var success: VerificationResult?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try VerificationResult.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_verifyPhone_result(success: success, e: e)
  }

}



fileprivate final class TalkService_verifyQrcode_args {

  fileprivate var verifier: String

  fileprivate var pinCode: String


  fileprivate init(verifier: String, pinCode: String) {
    self.verifier = verifier
    self.pinCode = pinCode
  }

}

fileprivate func ==(lhs: TalkService_verifyQrcode_args, rhs: TalkService_verifyQrcode_args) -> Bool {
  return
    (lhs.verifier == rhs.verifier) &&
    (lhs.pinCode == rhs.pinCode)
}

extension TalkService_verifyQrcode_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (verifier.hashValue)
    result = prime &* result &+ (pinCode.hashValue)
    return result
  }

}

extension TalkService_verifyQrcode_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["verifier": 2, "pinCode": 3, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyQrcode_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyQrcode_args {
    _ = try proto.readStructBegin()
    var verifier: String!
    var pinCode: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .string):           verifier = try String.read(from: proto)
        case (3, .string):           pinCode = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(verifier, named: "verifier")
    try proto.validateValue(pinCode, named: "pinCode")

    return TalkService_verifyQrcode_args(verifier: verifier, pinCode: pinCode)
  }

}



fileprivate final class TalkService_verifyQrcode_result {

  fileprivate var success: String?

  fileprivate var e: TalkException?


  fileprivate init() { }
  fileprivate init(success: String?, e: TalkException?) {
    self.success = success
    self.e = e
  }

}

fileprivate func ==(lhs: TalkService_verifyQrcode_result, rhs: TalkService_verifyQrcode_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.e == rhs.e)
}

extension TalkService_verifyQrcode_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension TalkService_verifyQrcode_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "e": 1, ]
  }

  fileprivate static var structName: String { return "TalkService_verifyQrcode_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TalkService_verifyQrcode_result {
    _ = try proto.readStructBegin()
    var success: String?
    var e: TalkException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case (1, .struct):           e = try TalkException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TalkService_verifyQrcode_result(success: success, e: e)
  }

}



extension TalkServiceClient : TalkService {

  private func send_acceptGroupInvitation(reqSeq: Int32, groupId: String) throws {
    try outProtocol.writeMessageBegin(name: "acceptGroupInvitation", type: .call, sequenceID: 0)
    let args = TalkService_acceptGroupInvitation_args(reqSeq: reqSeq, groupId: groupId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_acceptGroupInvitation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_acceptGroupInvitation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func acceptGroupInvitation(reqSeq: Int32, groupId: String) throws {
    try send_acceptGroupInvitation(reqSeq: reqSeq, groupId: groupId)
    try outProtocol.transport.flush()
    try recv_acceptGroupInvitation()
  }

  private func send_acceptProximityMatches(sessionId: String, ids: TSet<String>) throws {
    try outProtocol.writeMessageBegin(name: "acceptProximityMatches", type: .call, sequenceID: 0)
    let args = TalkService_acceptProximityMatches_args(sessionId: sessionId, ids: ids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_acceptProximityMatches() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_acceptProximityMatches_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func acceptProximityMatches(sessionId: String, ids: TSet<String>) throws {
    try send_acceptProximityMatches(sessionId: sessionId, ids: ids)
    try outProtocol.transport.flush()
    try recv_acceptProximityMatches()
  }

  private func send_acquireCallRoute(to: String) throws {
    try outProtocol.writeMessageBegin(name: "acquireCallRoute", type: .call, sequenceID: 0)
    let args = TalkService_acquireCallRoute_args(to: to)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_acquireCallRoute() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_acquireCallRoute_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "acquireCallRoute"))
  }

  public func acquireCallRoute(to: String) throws -> TList<String> {
    try send_acquireCallRoute(to: to)
    try outProtocol.transport.flush()
    return try recv_acquireCallRoute()
  }

  private func send_acquireCallTicket(to: String) throws {
    try outProtocol.writeMessageBegin(name: "acquireCallTicket", type: .call, sequenceID: 0)
    let args = TalkService_acquireCallTicket_args(to: to)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_acquireCallTicket() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_acquireCallTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "acquireCallTicket"))
  }

  public func acquireCallTicket(to: String) throws -> String {
    try send_acquireCallTicket(to: to)
    try outProtocol.transport.flush()
    return try recv_acquireCallTicket()
  }

  private func send_acquireEncryptedAccessToken(featureType: FeatureType) throws {
    try outProtocol.writeMessageBegin(name: "acquireEncryptedAccessToken", type: .call, sequenceID: 0)
    let args = TalkService_acquireEncryptedAccessToken_args(featureType: featureType)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_acquireEncryptedAccessToken() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_acquireEncryptedAccessToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "acquireEncryptedAccessToken"))
  }

  public func acquireEncryptedAccessToken(featureType: FeatureType) throws -> String {
    try send_acquireEncryptedAccessToken(featureType: featureType)
    try outProtocol.transport.flush()
    return try recv_acquireEncryptedAccessToken()
  }

  private func send_addSnsId(snsIdType: SnsIdType, snsAccessToken: String) throws {
    try outProtocol.writeMessageBegin(name: "addSnsId", type: .call, sequenceID: 0)
    let args = TalkService_addSnsId_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_addSnsId() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_addSnsId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "addSnsId"))
  }

  public func addSnsId(snsIdType: SnsIdType, snsAccessToken: String) throws -> String {
    try send_addSnsId(snsIdType: snsIdType, snsAccessToken: snsAccessToken)
    try outProtocol.transport.flush()
    return try recv_addSnsId()
  }

  private func send_blockContact(reqSeq: Int32, id: String) throws {
    try outProtocol.writeMessageBegin(name: "blockContact", type: .call, sequenceID: 0)
    let args = TalkService_blockContact_args(reqSeq: reqSeq, id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_blockContact() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_blockContact_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func blockContact(reqSeq: Int32, id: String) throws {
    try send_blockContact(reqSeq: reqSeq, id: id)
    try outProtocol.transport.flush()
    try recv_blockContact()
  }

  private func send_blockRecommendation(reqSeq: Int32, id: String) throws {
    try outProtocol.writeMessageBegin(name: "blockRecommendation", type: .call, sequenceID: 0)
    let args = TalkService_blockRecommendation_args(reqSeq: reqSeq, id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_blockRecommendation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_blockRecommendation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func blockRecommendation(reqSeq: Int32, id: String) throws {
    try send_blockRecommendation(reqSeq: reqSeq, id: id)
    try outProtocol.transport.flush()
    try recv_blockRecommendation()
  }

  private func send_cancelGroupInvitation(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "cancelGroupInvitation", type: .call, sequenceID: 0)
    let args = TalkService_cancelGroupInvitation_args(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_cancelGroupInvitation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_cancelGroupInvitation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func cancelGroupInvitation(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws {
    try send_cancelGroupInvitation(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
    try outProtocol.transport.flush()
    try recv_cancelGroupInvitation()
  }

  private func send_changeVerificationMethod(sessionId: String, method: VerificationMethod) throws {
    try outProtocol.writeMessageBegin(name: "changeVerificationMethod", type: .call, sequenceID: 0)
    let args = TalkService_changeVerificationMethod_args(sessionId: sessionId, method: method)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_changeVerificationMethod() throws -> VerificationSessionData {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_changeVerificationMethod_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "changeVerificationMethod"))
  }

  public func changeVerificationMethod(sessionId: String, method: VerificationMethod) throws -> VerificationSessionData {
    try send_changeVerificationMethod(sessionId: sessionId, method: method)
    try outProtocol.transport.flush()
    return try recv_changeVerificationMethod()
  }

  private func send_clearIdentityCredential() throws {
    try outProtocol.writeMessageBegin(name: "clearIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_clearIdentityCredential_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_clearIdentityCredential() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_clearIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func clearIdentityCredential() throws {
    try send_clearIdentityCredential()
    try outProtocol.transport.flush()
    try recv_clearIdentityCredential()
  }

  private func send_clearMessageBox(channelId: String, messageBoxId: String) throws {
    try outProtocol.writeMessageBegin(name: "clearMessageBox", type: .call, sequenceID: 0)
    let args = TalkService_clearMessageBox_args(channelId: channelId, messageBoxId: messageBoxId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_clearMessageBox() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_clearMessageBox_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func clearMessageBox(channelId: String, messageBoxId: String) throws {
    try send_clearMessageBox(channelId: channelId, messageBoxId: messageBoxId)
    try outProtocol.transport.flush()
    try recv_clearMessageBox()
  }

  private func send_closeProximityMatch(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "closeProximityMatch", type: .call, sequenceID: 0)
    let args = TalkService_closeProximityMatch_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_closeProximityMatch() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_closeProximityMatch_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func closeProximityMatch(sessionId: String) throws {
    try send_closeProximityMatch(sessionId: sessionId)
    try outProtocol.transport.flush()
    try recv_closeProximityMatch()
  }

  private func send_commitSendMessage(seq: Int32, messageId: String, receiverMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "commitSendMessage", type: .call, sequenceID: 0)
    let args = TalkService_commitSendMessage_args(seq: seq, messageId: messageId, receiverMids: receiverMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_commitSendMessage() throws -> TMap<String, String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_commitSendMessage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "commitSendMessage"))
  }

  public func commitSendMessage(seq: Int32, messageId: String, receiverMids: TList<String>) throws -> TMap<String, String> {
    try send_commitSendMessage(seq: seq, messageId: messageId, receiverMids: receiverMids)
    try outProtocol.transport.flush()
    return try recv_commitSendMessage()
  }

  private func send_commitSendMessages(seq: Int32, messageIds: TList<String>, receiverMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "commitSendMessages", type: .call, sequenceID: 0)
    let args = TalkService_commitSendMessages_args(seq: seq, messageIds: messageIds, receiverMids: receiverMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_commitSendMessages() throws -> TMap<String, String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_commitSendMessages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "commitSendMessages"))
  }

  public func commitSendMessages(seq: Int32, messageIds: TList<String>, receiverMids: TList<String>) throws -> TMap<String, String> {
    try send_commitSendMessages(seq: seq, messageIds: messageIds, receiverMids: receiverMids)
    try outProtocol.transport.flush()
    return try recv_commitSendMessages()
  }

  private func send_commitUpdateProfile(seq: Int32, attrs: TList<ProfileAttribute>, receiverMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "commitUpdateProfile", type: .call, sequenceID: 0)
    let args = TalkService_commitUpdateProfile_args(seq: seq, attrs: attrs, receiverMids: receiverMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_commitUpdateProfile() throws -> TMap<String, String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_commitUpdateProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "commitUpdateProfile"))
  }

  public func commitUpdateProfile(seq: Int32, attrs: TList<ProfileAttribute>, receiverMids: TList<String>) throws -> TMap<String, String> {
    try send_commitUpdateProfile(seq: seq, attrs: attrs, receiverMids: receiverMids)
    try outProtocol.transport.flush()
    return try recv_commitUpdateProfile()
  }

  private func send_confirmEmail(verifier: String, pinCode: String) throws {
    try outProtocol.writeMessageBegin(name: "confirmEmail", type: .call, sequenceID: 0)
    let args = TalkService_confirmEmail_args(verifier: verifier, pinCode: pinCode)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_confirmEmail() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_confirmEmail_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func confirmEmail(verifier: String, pinCode: String) throws {
    try send_confirmEmail(verifier: verifier, pinCode: pinCode)
    try outProtocol.transport.flush()
    try recv_confirmEmail()
  }

  private func send_createGroup(seq: Int32, name: String, contactIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "createGroup", type: .call, sequenceID: 0)
    let args = TalkService_createGroup_args(seq: seq, name: name, contactIds: contactIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_createGroup() throws -> Group {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_createGroup_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "createGroup"))
  }

  public func createGroup(seq: Int32, name: String, contactIds: TList<String>) throws -> Group {
    try send_createGroup(seq: seq, name: name, contactIds: contactIds)
    try outProtocol.transport.flush()
    return try recv_createGroup()
  }

  private func send_createQrcodeBase64Image(url: String, characterSet: String, imageSize: Int32, x: Int32, y: Int32, width: Int32, height: Int32) throws {
    try outProtocol.writeMessageBegin(name: "createQrcodeBase64Image", type: .call, sequenceID: 0)
    let args = TalkService_createQrcodeBase64Image_args(url: url, characterSet: characterSet, imageSize: imageSize, x: x, y: y, width: width, height: height)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_createQrcodeBase64Image() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_createQrcodeBase64Image_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "createQrcodeBase64Image"))
  }

  public func createQrcodeBase64Image(url: String, characterSet: String, imageSize: Int32, x: Int32, y: Int32, width: Int32, height: Int32) throws -> String {
    try send_createQrcodeBase64Image(url: url, characterSet: characterSet, imageSize: imageSize, x: x, y: y, width: width, height: height)
    try outProtocol.transport.flush()
    return try recv_createQrcodeBase64Image()
  }

  private func send_createRoom(reqSeq: Int32, contactIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "createRoom", type: .call, sequenceID: 0)
    let args = TalkService_createRoom_args(reqSeq: reqSeq, contactIds: contactIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_createRoom() throws -> Room {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_createRoom_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "createRoom"))
  }

  public func createRoom(reqSeq: Int32, contactIds: TList<String>) throws -> Room {
    try send_createRoom(reqSeq: reqSeq, contactIds: contactIds)
    try outProtocol.transport.flush()
    return try recv_createRoom()
  }

  private func send_createSession() throws {
    try outProtocol.writeMessageBegin(name: "createSession", type: .call, sequenceID: 0)
    let args = TalkService_createSession_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_createSession() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_createSession_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "createSession"))
  }

  public func createSession() throws -> String {
    try send_createSession()
    try outProtocol.transport.flush()
    return try recv_createSession()
  }

  private func send_fetchAnnouncements(lastFetchedIndex: Int32) throws {
    try outProtocol.writeMessageBegin(name: "fetchAnnouncements", type: .call, sequenceID: 0)
    let args = TalkService_fetchAnnouncements_args(lastFetchedIndex: lastFetchedIndex)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_fetchAnnouncements() throws -> TList<Announcement> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_fetchAnnouncements_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "fetchAnnouncements"))
  }

  public func fetchAnnouncements(lastFetchedIndex: Int32) throws -> TList<Announcement> {
    try send_fetchAnnouncements(lastFetchedIndex: lastFetchedIndex)
    try outProtocol.transport.flush()
    return try recv_fetchAnnouncements()
  }

  private func send_fetchMessages(localTs: Int64, count: Int32) throws {
    try outProtocol.writeMessageBegin(name: "fetchMessages", type: .call, sequenceID: 0)
    let args = TalkService_fetchMessages_args(localTs: localTs, count: count)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_fetchMessages() throws -> TList<Message> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_fetchMessages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "fetchMessages"))
  }

  public func fetchMessages(localTs: Int64, count: Int32) throws -> TList<Message> {
    try send_fetchMessages(localTs: localTs, count: count)
    try outProtocol.transport.flush()
    return try recv_fetchMessages()
  }

  private func send_fetchOperations(localRev: Int64, count: Int32) throws {
    try outProtocol.writeMessageBegin(name: "fetchOperations", type: .call, sequenceID: 0)
    let args = TalkService_fetchOperations_args(localRev: localRev, count: count)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_fetchOperations() throws -> TList<Operation> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_fetchOperations_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "fetchOperations"))
  }

  public func fetchOperations(localRev: Int64, count: Int32) throws -> TList<Operation> {
    try send_fetchOperations(localRev: localRev, count: count)
    try outProtocol.transport.flush()
    return try recv_fetchOperations()
  }

  private func send_fetchOps(localRev: Int64, count: Int32, globalRev: Int64, individualRev: Int64) throws {
    try outProtocol.writeMessageBegin(name: "fetchOps", type: .call, sequenceID: 0)
    let args = TalkService_fetchOps_args(localRev: localRev, count: count, globalRev: globalRev, individualRev: individualRev)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_fetchOps() throws -> TList<Operation> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_fetchOps_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "fetchOps"))
  }

  public func fetchOps(localRev: Int64, count: Int32, globalRev: Int64, individualRev: Int64) throws -> TList<Operation> {
    try send_fetchOps(localRev: localRev, count: count, globalRev: globalRev, individualRev: individualRev)
    try outProtocol.transport.flush()
    return try recv_fetchOps()
  }

  private func send_findAndAddContactsByEmail(reqSeq: Int32, emails: TSet<String>) throws {
    try outProtocol.writeMessageBegin(name: "findAndAddContactsByEmail", type: .call, sequenceID: 0)
    let args = TalkService_findAndAddContactsByEmail_args(reqSeq: reqSeq, emails: emails)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findAndAddContactsByEmail() throws -> TMap<String, Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findAndAddContactsByEmail_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findAndAddContactsByEmail"))
  }

  public func findAndAddContactsByEmail(reqSeq: Int32, emails: TSet<String>) throws -> TMap<String, Contact> {
    try send_findAndAddContactsByEmail(reqSeq: reqSeq, emails: emails)
    try outProtocol.transport.flush()
    return try recv_findAndAddContactsByEmail()
  }

  private func send_findAndAddContactsByMid(reqSeq: Int32, mid: String) throws {
    try outProtocol.writeMessageBegin(name: "findAndAddContactsByMid", type: .call, sequenceID: 0)
    let args = TalkService_findAndAddContactsByMid_args(reqSeq: reqSeq, mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findAndAddContactsByMid() throws -> TMap<String, Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findAndAddContactsByMid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findAndAddContactsByMid"))
  }

  public func findAndAddContactsByMid(reqSeq: Int32, mid: String) throws -> TMap<String, Contact> {
    try send_findAndAddContactsByMid(reqSeq: reqSeq, mid: mid)
    try outProtocol.transport.flush()
    return try recv_findAndAddContactsByMid()
  }

  private func send_findAndAddContactsByPhone(reqSeq: Int32, phones: TSet<String>) throws {
    try outProtocol.writeMessageBegin(name: "findAndAddContactsByPhone", type: .call, sequenceID: 0)
    let args = TalkService_findAndAddContactsByPhone_args(reqSeq: reqSeq, phones: phones)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findAndAddContactsByPhone() throws -> TMap<String, Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findAndAddContactsByPhone_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findAndAddContactsByPhone"))
  }

  public func findAndAddContactsByPhone(reqSeq: Int32, phones: TSet<String>) throws -> TMap<String, Contact> {
    try send_findAndAddContactsByPhone(reqSeq: reqSeq, phones: phones)
    try outProtocol.transport.flush()
    return try recv_findAndAddContactsByPhone()
  }

  private func send_findAndAddContactsByUserid(reqSeq: Int32, userid: String) throws {
    try outProtocol.writeMessageBegin(name: "findAndAddContactsByUserid", type: .call, sequenceID: 0)
    let args = TalkService_findAndAddContactsByUserid_args(reqSeq: reqSeq, userid: userid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findAndAddContactsByUserid() throws -> TMap<String, Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findAndAddContactsByUserid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findAndAddContactsByUserid"))
  }

  public func findAndAddContactsByUserid(reqSeq: Int32, userid: String) throws -> TMap<String, Contact> {
    try send_findAndAddContactsByUserid(reqSeq: reqSeq, userid: userid)
    try outProtocol.transport.flush()
    return try recv_findAndAddContactsByUserid()
  }

  private func send_findContactByUserid(userid: String) throws {
    try outProtocol.writeMessageBegin(name: "findContactByUserid", type: .call, sequenceID: 0)
    let args = TalkService_findContactByUserid_args(userid: userid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findContactByUserid() throws -> Contact {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findContactByUserid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findContactByUserid"))
  }

  public func findContactByUserid(userid: String) throws -> Contact {
    try send_findContactByUserid(userid: userid)
    try outProtocol.transport.flush()
    return try recv_findContactByUserid()
  }

  private func send_findContactByUserTicket(ticketId: String) throws {
    try outProtocol.writeMessageBegin(name: "findContactByUserTicket", type: .call, sequenceID: 0)
    let args = TalkService_findContactByUserTicket_args(ticketId: ticketId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findContactByUserTicket() throws -> Contact {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findContactByUserTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findContactByUserTicket"))
  }

  public func findContactByUserTicket(ticketId: String) throws -> Contact {
    try send_findContactByUserTicket(ticketId: ticketId)
    try outProtocol.transport.flush()
    return try recv_findContactByUserTicket()
  }

  private func send_findContactsByEmail(emails: TSet<String>) throws {
    try outProtocol.writeMessageBegin(name: "findContactsByEmail", type: .call, sequenceID: 0)
    let args = TalkService_findContactsByEmail_args(emails: emails)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findContactsByEmail() throws -> TMap<String, Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findContactsByEmail_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findContactsByEmail"))
  }

  public func findContactsByEmail(emails: TSet<String>) throws -> TMap<String, Contact> {
    try send_findContactsByEmail(emails: emails)
    try outProtocol.transport.flush()
    return try recv_findContactsByEmail()
  }

  private func send_findContactsByPhone(phones: TSet<String>) throws {
    try outProtocol.writeMessageBegin(name: "findContactsByPhone", type: .call, sequenceID: 0)
    let args = TalkService_findContactsByPhone_args(phones: phones)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findContactsByPhone() throws -> TMap<String, Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findContactsByPhone_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findContactsByPhone"))
  }

  public func findContactsByPhone(phones: TSet<String>) throws -> TMap<String, Contact> {
    try send_findContactsByPhone(phones: phones)
    try outProtocol.transport.flush()
    return try recv_findContactsByPhone()
  }

  private func send_findSnsIdUserStatus(snsIdType: SnsIdType, snsAccessToken: String, udidHash: String) throws {
    try outProtocol.writeMessageBegin(name: "findSnsIdUserStatus", type: .call, sequenceID: 0)
    let args = TalkService_findSnsIdUserStatus_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, udidHash: udidHash)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_findSnsIdUserStatus() throws -> SnsIdUserStatus {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_findSnsIdUserStatus_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "findSnsIdUserStatus"))
  }

  public func findSnsIdUserStatus(snsIdType: SnsIdType, snsAccessToken: String, udidHash: String) throws -> SnsIdUserStatus {
    try send_findSnsIdUserStatus(snsIdType: snsIdType, snsAccessToken: snsAccessToken, udidHash: udidHash)
    try outProtocol.transport.flush()
    return try recv_findSnsIdUserStatus()
  }

  private func send_finishUpdateVerification(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "finishUpdateVerification", type: .call, sequenceID: 0)
    let args = TalkService_finishUpdateVerification_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_finishUpdateVerification() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_finishUpdateVerification_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func finishUpdateVerification(sessionId: String) throws {
    try send_finishUpdateVerification(sessionId: sessionId)
    try outProtocol.transport.flush()
    try recv_finishUpdateVerification()
  }

  private func send_generateUserTicket(expirationTime: Int64, maxUseCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "generateUserTicket", type: .call, sequenceID: 0)
    let args = TalkService_generateUserTicket_args(expirationTime: expirationTime, maxUseCount: maxUseCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_generateUserTicket() throws -> Ticket {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_generateUserTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "generateUserTicket"))
  }

  public func generateUserTicket(expirationTime: Int64, maxUseCount: Int32) throws -> Ticket {
    try send_generateUserTicket(expirationTime: expirationTime, maxUseCount: maxUseCount)
    try outProtocol.transport.flush()
    return try recv_generateUserTicket()
  }

  private func send_getAcceptedProximityMatches(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "getAcceptedProximityMatches", type: .call, sequenceID: 0)
    let args = TalkService_getAcceptedProximityMatches_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getAcceptedProximityMatches() throws -> TSet<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getAcceptedProximityMatches_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getAcceptedProximityMatches"))
  }

  public func getAcceptedProximityMatches(sessionId: String) throws -> TSet<String> {
    try send_getAcceptedProximityMatches(sessionId: sessionId)
    try outProtocol.transport.flush()
    return try recv_getAcceptedProximityMatches()
  }

  private func send_getActiveBuddySubscriberIds() throws {
    try outProtocol.writeMessageBegin(name: "getActiveBuddySubscriberIds", type: .call, sequenceID: 0)
    let args = TalkService_getActiveBuddySubscriberIds_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getActiveBuddySubscriberIds() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getActiveBuddySubscriberIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getActiveBuddySubscriberIds"))
  }

  public func getActiveBuddySubscriberIds() throws -> TList<String> {
    try send_getActiveBuddySubscriberIds()
    try outProtocol.transport.flush()
    return try recv_getActiveBuddySubscriberIds()
  }

  private func send_getAllContactIds() throws {
    try outProtocol.writeMessageBegin(name: "getAllContactIds", type: .call, sequenceID: 0)
    let args = TalkService_getAllContactIds_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getAllContactIds() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getAllContactIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getAllContactIds"))
  }

  public func getAllContactIds() throws -> TList<String> {
    try send_getAllContactIds()
    try outProtocol.transport.flush()
    return try recv_getAllContactIds()
  }

  private func send_getAuthQrcode(keepLoggedIn: Bool, systemName: String) throws {
    try outProtocol.writeMessageBegin(name: "getAuthQrcode", type: .call, sequenceID: 0)
    let args = TalkService_getAuthQrcode_args(keepLoggedIn: keepLoggedIn, systemName: systemName)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getAuthQrcode() throws -> AuthQrcode {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getAuthQrcode_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getAuthQrcode"))
  }

  public func getAuthQrcode(keepLoggedIn: Bool, systemName: String) throws -> AuthQrcode {
    try send_getAuthQrcode(keepLoggedIn: keepLoggedIn, systemName: systemName)
    try outProtocol.transport.flush()
    return try recv_getAuthQrcode()
  }

  private func send_getBlockedContactIds() throws {
    try outProtocol.writeMessageBegin(name: "getBlockedContactIds", type: .call, sequenceID: 0)
    let args = TalkService_getBlockedContactIds_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBlockedContactIds() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getBlockedContactIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBlockedContactIds"))
  }

  public func getBlockedContactIds() throws -> TList<String> {
    try send_getBlockedContactIds()
    try outProtocol.transport.flush()
    return try recv_getBlockedContactIds()
  }

  private func send_getBlockedContactIdsByRange(start: Int32, count: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getBlockedContactIdsByRange", type: .call, sequenceID: 0)
    let args = TalkService_getBlockedContactIdsByRange_args(start: start, count: count)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBlockedContactIdsByRange() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getBlockedContactIdsByRange_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBlockedContactIdsByRange"))
  }

  public func getBlockedContactIdsByRange(start: Int32, count: Int32) throws -> TList<String> {
    try send_getBlockedContactIdsByRange(start: start, count: count)
    try outProtocol.transport.flush()
    return try recv_getBlockedContactIdsByRange()
  }

  private func send_getBlockedRecommendationIds() throws {
    try outProtocol.writeMessageBegin(name: "getBlockedRecommendationIds", type: .call, sequenceID: 0)
    let args = TalkService_getBlockedRecommendationIds_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBlockedRecommendationIds() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getBlockedRecommendationIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBlockedRecommendationIds"))
  }

  public func getBlockedRecommendationIds() throws -> TList<String> {
    try send_getBlockedRecommendationIds()
    try outProtocol.transport.flush()
    return try recv_getBlockedRecommendationIds()
  }

  private func send_getBuddyBlockerIds() throws {
    try outProtocol.writeMessageBegin(name: "getBuddyBlockerIds", type: .call, sequenceID: 0)
    let args = TalkService_getBuddyBlockerIds_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBuddyBlockerIds() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getBuddyBlockerIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBuddyBlockerIds"))
  }

  public func getBuddyBlockerIds() throws -> TList<String> {
    try send_getBuddyBlockerIds()
    try outProtocol.transport.flush()
    return try recv_getBuddyBlockerIds()
  }

  private func send_getBuddyLocation(mid: String, index: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getBuddyLocation", type: .call, sequenceID: 0)
    let args = TalkService_getBuddyLocation_args(mid: mid, index: index)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getBuddyLocation() throws -> Geolocation {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getBuddyLocation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getBuddyLocation"))
  }

  public func getBuddyLocation(mid: String, index: Int32) throws -> Geolocation {
    try send_getBuddyLocation(mid: mid, index: index)
    try outProtocol.transport.flush()
    return try recv_getBuddyLocation()
  }

  private func send_getCompactContactsModifiedSince(timestamp: Int64) throws {
    try outProtocol.writeMessageBegin(name: "getCompactContactsModifiedSince", type: .call, sequenceID: 0)
    let args = TalkService_getCompactContactsModifiedSince_args(timestamp: timestamp)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCompactContactsModifiedSince() throws -> TList<CompactContact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getCompactContactsModifiedSince_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCompactContactsModifiedSince"))
  }

  public func getCompactContactsModifiedSince(timestamp: Int64) throws -> TList<CompactContact> {
    try send_getCompactContactsModifiedSince(timestamp: timestamp)
    try outProtocol.transport.flush()
    return try recv_getCompactContactsModifiedSince()
  }

  private func send_getCompactGroup(groupId: String) throws {
    try outProtocol.writeMessageBegin(name: "getCompactGroup", type: .call, sequenceID: 0)
    let args = TalkService_getCompactGroup_args(groupId: groupId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCompactGroup() throws -> Group {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getCompactGroup_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCompactGroup"))
  }

  public func getCompactGroup(groupId: String) throws -> Group {
    try send_getCompactGroup(groupId: groupId)
    try outProtocol.transport.flush()
    return try recv_getCompactGroup()
  }

  private func send_getCompactRoom(roomId: String) throws {
    try outProtocol.writeMessageBegin(name: "getCompactRoom", type: .call, sequenceID: 0)
    let args = TalkService_getCompactRoom_args(roomId: roomId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCompactRoom() throws -> Room {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getCompactRoom_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCompactRoom"))
  }

  public func getCompactRoom(roomId: String) throws -> Room {
    try send_getCompactRoom(roomId: roomId)
    try outProtocol.transport.flush()
    return try recv_getCompactRoom()
  }

  private func send_getContact(id: String) throws {
    try outProtocol.writeMessageBegin(name: "getContact", type: .call, sequenceID: 0)
    let args = TalkService_getContact_args(id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getContact() throws -> Contact {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getContact_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getContact"))
  }

  public func getContact(id: String) throws -> Contact {
    try send_getContact(id: id)
    try outProtocol.transport.flush()
    return try recv_getContact()
  }

  private func send_getContacts(ids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "getContacts", type: .call, sequenceID: 0)
    let args = TalkService_getContacts_args(ids: ids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getContacts() throws -> TList<Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getContacts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getContacts"))
  }

  public func getContacts(ids: TList<String>) throws -> TList<Contact> {
    try send_getContacts(ids: ids)
    try outProtocol.transport.flush()
    return try recv_getContacts()
  }

  private func send_getCountryWithRequestIp() throws {
    try outProtocol.writeMessageBegin(name: "getCountryWithRequestIp", type: .call, sequenceID: 0)
    let args = TalkService_getCountryWithRequestIp_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCountryWithRequestIp() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getCountryWithRequestIp_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getCountryWithRequestIp"))
  }

  public func getCountryWithRequestIp() throws -> String {
    try send_getCountryWithRequestIp()
    try outProtocol.transport.flush()
    return try recv_getCountryWithRequestIp()
  }

  private func send_getFavoriteMids() throws {
    try outProtocol.writeMessageBegin(name: "getFavoriteMids", type: .call, sequenceID: 0)
    let args = TalkService_getFavoriteMids_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getFavoriteMids() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getFavoriteMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getFavoriteMids"))
  }

  public func getFavoriteMids() throws -> TList<String> {
    try send_getFavoriteMids()
    try outProtocol.transport.flush()
    return try recv_getFavoriteMids()
  }

  private func send_getGroup(groupId: String) throws {
    try outProtocol.writeMessageBegin(name: "getGroup", type: .call, sequenceID: 0)
    let args = TalkService_getGroup_args(groupId: groupId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getGroup() throws -> Group {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getGroup_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getGroup"))
  }

  public func getGroup(groupId: String) throws -> Group {
    try send_getGroup(groupId: groupId)
    try outProtocol.transport.flush()
    return try recv_getGroup()
  }

  private func send_getGroupIdsInvited() throws {
    try outProtocol.writeMessageBegin(name: "getGroupIdsInvited", type: .call, sequenceID: 0)
    let args = TalkService_getGroupIdsInvited_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getGroupIdsInvited() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getGroupIdsInvited_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getGroupIdsInvited"))
  }

  public func getGroupIdsInvited() throws -> TList<String> {
    try send_getGroupIdsInvited()
    try outProtocol.transport.flush()
    return try recv_getGroupIdsInvited()
  }

  private func send_getGroupIdsJoined() throws {
    try outProtocol.writeMessageBegin(name: "getGroupIdsJoined", type: .call, sequenceID: 0)
    let args = TalkService_getGroupIdsJoined_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getGroupIdsJoined() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getGroupIdsJoined_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getGroupIdsJoined"))
  }

  public func getGroupIdsJoined() throws -> TList<String> {
    try send_getGroupIdsJoined()
    try outProtocol.transport.flush()
    return try recv_getGroupIdsJoined()
  }

  private func send_getGroups(groupIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "getGroups", type: .call, sequenceID: 0)
    let args = TalkService_getGroups_args(groupIds: groupIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getGroups() throws -> TList<Group> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getGroups_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getGroups"))
  }

  public func getGroups(groupIds: TList<String>) throws -> TList<Group> {
    try send_getGroups(groupIds: groupIds)
    try outProtocol.transport.flush()
    return try recv_getGroups()
  }

  private func send_getHiddenContactMids() throws {
    try outProtocol.writeMessageBegin(name: "getHiddenContactMids", type: .call, sequenceID: 0)
    let args = TalkService_getHiddenContactMids_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getHiddenContactMids() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getHiddenContactMids_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getHiddenContactMids"))
  }

  public func getHiddenContactMids() throws -> TList<String> {
    try send_getHiddenContactMids()
    try outProtocol.transport.flush()
    return try recv_getHiddenContactMids()
  }

  private func send_getIdentityIdentifier() throws {
    try outProtocol.writeMessageBegin(name: "getIdentityIdentifier", type: .call, sequenceID: 0)
    let args = TalkService_getIdentityIdentifier_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getIdentityIdentifier() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getIdentityIdentifier_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getIdentityIdentifier"))
  }

  public func getIdentityIdentifier() throws -> String {
    try send_getIdentityIdentifier()
    try outProtocol.transport.flush()
    return try recv_getIdentityIdentifier()
  }

  private func send_getLastAnnouncementIndex() throws {
    try outProtocol.writeMessageBegin(name: "getLastAnnouncementIndex", type: .call, sequenceID: 0)
    let args = TalkService_getLastAnnouncementIndex_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getLastAnnouncementIndex() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getLastAnnouncementIndex_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getLastAnnouncementIndex"))
  }

  public func getLastAnnouncementIndex() throws -> Int32 {
    try send_getLastAnnouncementIndex()
    try outProtocol.transport.flush()
    return try recv_getLastAnnouncementIndex()
  }

  private func send_getLastOpRevision() throws {
    try outProtocol.writeMessageBegin(name: "getLastOpRevision", type: .call, sequenceID: 0)
    let args = TalkService_getLastOpRevision_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getLastOpRevision() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getLastOpRevision_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getLastOpRevision"))
  }

  public func getLastOpRevision() throws -> Int64 {
    try send_getLastOpRevision()
    try outProtocol.transport.flush()
    return try recv_getLastOpRevision()
  }

  private func send_getMessageBox(channelId: String, messageBoxId: String, lastMessagesCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getMessageBox", type: .call, sequenceID: 0)
    let args = TalkService_getMessageBox_args(channelId: channelId, messageBoxId: messageBoxId, lastMessagesCount: lastMessagesCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessageBox() throws -> TMessageBox {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessageBox_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessageBox"))
  }

  public func getMessageBox(channelId: String, messageBoxId: String, lastMessagesCount: Int32) throws -> TMessageBox {
    try send_getMessageBox(channelId: channelId, messageBoxId: messageBoxId, lastMessagesCount: lastMessagesCount)
    try outProtocol.transport.flush()
    return try recv_getMessageBox()
  }

  private func send_getMessageBoxCompactWrapUp(mid: String) throws {
    try outProtocol.writeMessageBegin(name: "getMessageBoxCompactWrapUp", type: .call, sequenceID: 0)
    let args = TalkService_getMessageBoxCompactWrapUp_args(mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessageBoxCompactWrapUp() throws -> TMessageBoxWrapUp {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessageBoxCompactWrapUp_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessageBoxCompactWrapUp"))
  }

  public func getMessageBoxCompactWrapUp(mid: String) throws -> TMessageBoxWrapUp {
    try send_getMessageBoxCompactWrapUp(mid: mid)
    try outProtocol.transport.flush()
    return try recv_getMessageBoxCompactWrapUp()
  }

  private func send_getMessageBoxCompactWrapUpList(start: Int32, messageBoxCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getMessageBoxCompactWrapUpList", type: .call, sequenceID: 0)
    let args = TalkService_getMessageBoxCompactWrapUpList_args(start: start, messageBoxCount: messageBoxCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessageBoxCompactWrapUpList() throws -> TMessageBoxWrapUpResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessageBoxCompactWrapUpList_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessageBoxCompactWrapUpList"))
  }

  public func getMessageBoxCompactWrapUpList(start: Int32, messageBoxCount: Int32) throws -> TMessageBoxWrapUpResponse {
    try send_getMessageBoxCompactWrapUpList(start: start, messageBoxCount: messageBoxCount)
    try outProtocol.transport.flush()
    return try recv_getMessageBoxCompactWrapUpList()
  }

  private func send_getMessageBoxList(channelId: String, lastMessagesCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getMessageBoxList", type: .call, sequenceID: 0)
    let args = TalkService_getMessageBoxList_args(channelId: channelId, lastMessagesCount: lastMessagesCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessageBoxList() throws -> TList<TMessageBox> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessageBoxList_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessageBoxList"))
  }

  public func getMessageBoxList(channelId: String, lastMessagesCount: Int32) throws -> TList<TMessageBox> {
    try send_getMessageBoxList(channelId: channelId, lastMessagesCount: lastMessagesCount)
    try outProtocol.transport.flush()
    return try recv_getMessageBoxList()
  }

  private func send_getMessageBoxListByStatus(channelId: String, lastMessagesCount: Int32, status: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getMessageBoxListByStatus", type: .call, sequenceID: 0)
    let args = TalkService_getMessageBoxListByStatus_args(channelId: channelId, lastMessagesCount: lastMessagesCount, status: status)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessageBoxListByStatus() throws -> TList<TMessageBox> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessageBoxListByStatus_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessageBoxListByStatus"))
  }

  public func getMessageBoxListByStatus(channelId: String, lastMessagesCount: Int32, status: Int32) throws -> TList<TMessageBox> {
    try send_getMessageBoxListByStatus(channelId: channelId, lastMessagesCount: lastMessagesCount, status: status)
    try outProtocol.transport.flush()
    return try recv_getMessageBoxListByStatus()
  }

  private func send_getMessageBoxWrapUp(mid: String) throws {
    try outProtocol.writeMessageBegin(name: "getMessageBoxWrapUp", type: .call, sequenceID: 0)
    let args = TalkService_getMessageBoxWrapUp_args(mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessageBoxWrapUp() throws -> TMessageBoxWrapUp {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessageBoxWrapUp_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessageBoxWrapUp"))
  }

  public func getMessageBoxWrapUp(mid: String) throws -> TMessageBoxWrapUp {
    try send_getMessageBoxWrapUp(mid: mid)
    try outProtocol.transport.flush()
    return try recv_getMessageBoxWrapUp()
  }

  private func send_getMessageBoxWrapUpList(start: Int32, messageBoxCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getMessageBoxWrapUpList", type: .call, sequenceID: 0)
    let args = TalkService_getMessageBoxWrapUpList_args(start: start, messageBoxCount: messageBoxCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessageBoxWrapUpList() throws -> TMessageBoxWrapUpResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessageBoxWrapUpList_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessageBoxWrapUpList"))
  }

  public func getMessageBoxWrapUpList(start: Int32, messageBoxCount: Int32) throws -> TMessageBoxWrapUpResponse {
    try send_getMessageBoxWrapUpList(start: start, messageBoxCount: messageBoxCount)
    try outProtocol.transport.flush()
    return try recv_getMessageBoxWrapUpList()
  }

  private func send_getMessagesBySequenceNumber(channelId: String, messageBoxId: String, startSeq: Int64, endSeq: Int64) throws {
    try outProtocol.writeMessageBegin(name: "getMessagesBySequenceNumber", type: .call, sequenceID: 0)
    let args = TalkService_getMessagesBySequenceNumber_args(channelId: channelId, messageBoxId: messageBoxId, startSeq: startSeq, endSeq: endSeq)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getMessagesBySequenceNumber() throws -> TList<Message> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getMessagesBySequenceNumber_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getMessagesBySequenceNumber"))
  }

  public func getMessagesBySequenceNumber(channelId: String, messageBoxId: String, startSeq: Int64, endSeq: Int64) throws -> TList<Message> {
    try send_getMessagesBySequenceNumber(channelId: channelId, messageBoxId: messageBoxId, startSeq: startSeq, endSeq: endSeq)
    try outProtocol.transport.flush()
    return try recv_getMessagesBySequenceNumber()
  }

  private func send_getNextMessages(messageBoxId: String, startSeq: Int64, messagesCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getNextMessages", type: .call, sequenceID: 0)
    let args = TalkService_getNextMessages_args(messageBoxId: messageBoxId, startSeq: startSeq, messagesCount: messagesCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getNextMessages() throws -> TList<Message> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getNextMessages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getNextMessages"))
  }

  public func getNextMessages(messageBoxId: String, startSeq: Int64, messagesCount: Int32) throws -> TList<Message> {
    try send_getNextMessages(messageBoxId: messageBoxId, startSeq: startSeq, messagesCount: messagesCount)
    try outProtocol.transport.flush()
    return try recv_getNextMessages()
  }

  private func send_getNotificationPolicy(carrier: CarrierCode) throws {
    try outProtocol.writeMessageBegin(name: "getNotificationPolicy", type: .call, sequenceID: 0)
    let args = TalkService_getNotificationPolicy_args(carrier: carrier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getNotificationPolicy() throws -> TList<NotificationType> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getNotificationPolicy_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getNotificationPolicy"))
  }

  public func getNotificationPolicy(carrier: CarrierCode) throws -> TList<NotificationType> {
    try send_getNotificationPolicy(carrier: carrier)
    try outProtocol.transport.flush()
    return try recv_getNotificationPolicy()
  }

  private func send_getPreviousMessages(messageBoxId: String, endSeq: Int64, messagesCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getPreviousMessages", type: .call, sequenceID: 0)
    let args = TalkService_getPreviousMessages_args(messageBoxId: messageBoxId, endSeq: endSeq, messagesCount: messagesCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getPreviousMessages() throws -> TList<Message> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getPreviousMessages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getPreviousMessages"))
  }

  public func getPreviousMessages(messageBoxId: String, endSeq: Int64, messagesCount: Int32) throws -> TList<Message> {
    try send_getPreviousMessages(messageBoxId: messageBoxId, endSeq: endSeq, messagesCount: messagesCount)
    try outProtocol.transport.flush()
    return try recv_getPreviousMessages()
  }

  private func send_getProfile() throws {
    try outProtocol.writeMessageBegin(name: "getProfile", type: .call, sequenceID: 0)
    let args = TalkService_getProfile_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProfile() throws -> Profile {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProfile"))
  }

  public func getProfile() throws -> Profile {
    try send_getProfile()
    try outProtocol.transport.flush()
    return try recv_getProfile()
  }

  private func send_getProximityMatchCandidateList(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "getProximityMatchCandidateList", type: .call, sequenceID: 0)
    let args = TalkService_getProximityMatchCandidateList_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProximityMatchCandidateList() throws -> ProximityMatchCandidateResult {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getProximityMatchCandidateList_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProximityMatchCandidateList"))
  }

  public func getProximityMatchCandidateList(sessionId: String) throws -> ProximityMatchCandidateResult {
    try send_getProximityMatchCandidateList(sessionId: sessionId)
    try outProtocol.transport.flush()
    return try recv_getProximityMatchCandidateList()
  }

  private func send_getProximityMatchCandidates(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "getProximityMatchCandidates", type: .call, sequenceID: 0)
    let args = TalkService_getProximityMatchCandidates_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getProximityMatchCandidates() throws -> TSet<Contact> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getProximityMatchCandidates_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getProximityMatchCandidates"))
  }

  public func getProximityMatchCandidates(sessionId: String) throws -> TSet<Contact> {
    try send_getProximityMatchCandidates(sessionId: sessionId)
    try outProtocol.transport.flush()
    return try recv_getProximityMatchCandidates()
  }

  private func send_getRecentMessages(messageBoxId: String, messagesCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getRecentMessages", type: .call, sequenceID: 0)
    let args = TalkService_getRecentMessages_args(messageBoxId: messageBoxId, messagesCount: messagesCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getRecentMessages() throws -> TList<Message> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getRecentMessages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getRecentMessages"))
  }

  public func getRecentMessages(messageBoxId: String, messagesCount: Int32) throws -> TList<Message> {
    try send_getRecentMessages(messageBoxId: messageBoxId, messagesCount: messagesCount)
    try outProtocol.transport.flush()
    return try recv_getRecentMessages()
  }

  private func send_getRecommendationIds() throws {
    try outProtocol.writeMessageBegin(name: "getRecommendationIds", type: .call, sequenceID: 0)
    let args = TalkService_getRecommendationIds_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getRecommendationIds() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getRecommendationIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getRecommendationIds"))
  }

  public func getRecommendationIds() throws -> TList<String> {
    try send_getRecommendationIds()
    try outProtocol.transport.flush()
    return try recv_getRecommendationIds()
  }

  private func send_getRoom(roomId: String) throws {
    try outProtocol.writeMessageBegin(name: "getRoom", type: .call, sequenceID: 0)
    let args = TalkService_getRoom_args(roomId: roomId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getRoom() throws -> Room {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getRoom_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getRoom"))
  }

  public func getRoom(roomId: String) throws -> Room {
    try send_getRoom(roomId: roomId)
    try outProtocol.transport.flush()
    return try recv_getRoom()
  }

  private func send_getRSAKeyInfo(provider: IdentityProvider) throws {
    try outProtocol.writeMessageBegin(name: "getRSAKeyInfo", type: .call, sequenceID: 0)
    let args = TalkService_getRSAKeyInfo_args(provider: provider)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getRSAKeyInfo() throws -> RSAKey {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getRSAKeyInfo_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getRSAKeyInfo"))
  }

  public func getRSAKeyInfo(provider: IdentityProvider) throws -> RSAKey {
    try send_getRSAKeyInfo(provider: provider)
    try outProtocol.transport.flush()
    return try recv_getRSAKeyInfo()
  }

  private func send_getServerTime() throws {
    try outProtocol.writeMessageBegin(name: "getServerTime", type: .call, sequenceID: 0)
    let args = TalkService_getServerTime_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getServerTime() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getServerTime_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getServerTime"))
  }

  public func getServerTime() throws -> Int64 {
    try send_getServerTime()
    try outProtocol.transport.flush()
    return try recv_getServerTime()
  }

  private func send_getSessions() throws {
    try outProtocol.writeMessageBegin(name: "getSessions", type: .call, sequenceID: 0)
    let args = TalkService_getSessions_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSessions() throws -> TList<LoginSession> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getSessions_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSessions"))
  }

  public func getSessions() throws -> TList<LoginSession> {
    try send_getSessions()
    try outProtocol.transport.flush()
    return try recv_getSessions()
  }

  private func send_getSettings() throws {
    try outProtocol.writeMessageBegin(name: "getSettings", type: .call, sequenceID: 0)
    let args = TalkService_getSettings_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSettings() throws -> Settings {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getSettings_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSettings"))
  }

  public func getSettings() throws -> Settings {
    try send_getSettings()
    try outProtocol.transport.flush()
    return try recv_getSettings()
  }

  private func send_getSettingsAttributes(attrBitset: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getSettingsAttributes", type: .call, sequenceID: 0)
    let args = TalkService_getSettingsAttributes_args(attrBitset: attrBitset)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSettingsAttributes() throws -> Settings {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getSettingsAttributes_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSettingsAttributes"))
  }

  public func getSettingsAttributes(attrBitset: Int32) throws -> Settings {
    try send_getSettingsAttributes(attrBitset: attrBitset)
    try outProtocol.transport.flush()
    return try recv_getSettingsAttributes()
  }

  private func send_getSystemConfiguration() throws {
    try outProtocol.writeMessageBegin(name: "getSystemConfiguration", type: .call, sequenceID: 0)
    let args = TalkService_getSystemConfiguration_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getSystemConfiguration() throws -> SystemConfiguration {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getSystemConfiguration_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getSystemConfiguration"))
  }

  public func getSystemConfiguration() throws -> SystemConfiguration {
    try send_getSystemConfiguration()
    try outProtocol.transport.flush()
    return try recv_getSystemConfiguration()
  }

  private func send_getUserTicket() throws {
    try outProtocol.writeMessageBegin(name: "getUserTicket", type: .call, sequenceID: 0)
    let args = TalkService_getUserTicket_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUserTicket() throws -> Ticket {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getUserTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getUserTicket"))
  }

  public func getUserTicket() throws -> Ticket {
    try send_getUserTicket()
    try outProtocol.transport.flush()
    return try recv_getUserTicket()
  }

  private func send_getWapInvitation(invitationHash: String) throws {
    try outProtocol.writeMessageBegin(name: "getWapInvitation", type: .call, sequenceID: 0)
    let args = TalkService_getWapInvitation_args(invitationHash: invitationHash)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getWapInvitation() throws -> WapInvitation {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_getWapInvitation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "getWapInvitation"))
  }

  public func getWapInvitation(invitationHash: String) throws -> WapInvitation {
    try send_getWapInvitation(invitationHash: invitationHash)
    try outProtocol.transport.flush()
    return try recv_getWapInvitation()
  }

  private func send_invalidateUserTicket() throws {
    try outProtocol.writeMessageBegin(name: "invalidateUserTicket", type: .call, sequenceID: 0)
    let args = TalkService_invalidateUserTicket_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_invalidateUserTicket() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_invalidateUserTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func invalidateUserTicket() throws {
    try send_invalidateUserTicket()
    try outProtocol.transport.flush()
    try recv_invalidateUserTicket()
  }

  private func send_inviteFriendsBySms(phoneNumberList: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "inviteFriendsBySms", type: .call, sequenceID: 0)
    let args = TalkService_inviteFriendsBySms_args(phoneNumberList: phoneNumberList)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_inviteFriendsBySms() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_inviteFriendsBySms_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func inviteFriendsBySms(phoneNumberList: TList<String>) throws {
    try send_inviteFriendsBySms(phoneNumberList: phoneNumberList)
    try outProtocol.transport.flush()
    try recv_inviteFriendsBySms()
  }

  private func send_inviteIntoGroup(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "inviteIntoGroup", type: .call, sequenceID: 0)
    let args = TalkService_inviteIntoGroup_args(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_inviteIntoGroup() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_inviteIntoGroup_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func inviteIntoGroup(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws {
    try send_inviteIntoGroup(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
    try outProtocol.transport.flush()
    try recv_inviteIntoGroup()
  }

  private func send_inviteIntoRoom(reqSeq: Int32, roomId: String, contactIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "inviteIntoRoom", type: .call, sequenceID: 0)
    let args = TalkService_inviteIntoRoom_args(reqSeq: reqSeq, roomId: roomId, contactIds: contactIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_inviteIntoRoom() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_inviteIntoRoom_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func inviteIntoRoom(reqSeq: Int32, roomId: String, contactIds: TList<String>) throws {
    try send_inviteIntoRoom(reqSeq: reqSeq, roomId: roomId, contactIds: contactIds)
    try outProtocol.transport.flush()
    try recv_inviteIntoRoom()
  }

  private func send_inviteViaEmail(reqSeq: Int32, email: String, name: String) throws {
    try outProtocol.writeMessageBegin(name: "inviteViaEmail", type: .call, sequenceID: 0)
    let args = TalkService_inviteViaEmail_args(reqSeq: reqSeq, email: email, name: name)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_inviteViaEmail() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_inviteViaEmail_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func inviteViaEmail(reqSeq: Int32, email: String, name: String) throws {
    try send_inviteViaEmail(reqSeq: reqSeq, email: email, name: name)
    try outProtocol.transport.flush()
    try recv_inviteViaEmail()
  }

  private func send_isIdentityIdentifierAvailable(provider: IdentityProvider, identifier: String) throws {
    try outProtocol.writeMessageBegin(name: "isIdentityIdentifierAvailable", type: .call, sequenceID: 0)
    let args = TalkService_isIdentityIdentifierAvailable_args(provider: provider, identifier: identifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isIdentityIdentifierAvailable() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_isIdentityIdentifierAvailable_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "isIdentityIdentifierAvailable"))
  }

  public func isIdentityIdentifierAvailable(provider: IdentityProvider, identifier: String) throws -> Bool {
    try send_isIdentityIdentifierAvailable(provider: provider, identifier: identifier)
    try outProtocol.transport.flush()
    return try recv_isIdentityIdentifierAvailable()
  }

  private func send_isUseridAvailable(userid: String) throws {
    try outProtocol.writeMessageBegin(name: "isUseridAvailable", type: .call, sequenceID: 0)
    let args = TalkService_isUseridAvailable_args(userid: userid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isUseridAvailable() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_isUseridAvailable_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "isUseridAvailable"))
  }

  public func isUseridAvailable(userid: String) throws -> Bool {
    try send_isUseridAvailable(userid: userid)
    try outProtocol.transport.flush()
    return try recv_isUseridAvailable()
  }

  private func send_kickoutFromGroup(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "kickoutFromGroup", type: .call, sequenceID: 0)
    let args = TalkService_kickoutFromGroup_args(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_kickoutFromGroup() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_kickoutFromGroup_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func kickoutFromGroup(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws {
    try send_kickoutFromGroup(reqSeq: reqSeq, groupId: groupId, contactIds: contactIds)
    try outProtocol.transport.flush()
    try recv_kickoutFromGroup()
  }

  private func send_leaveGroup(reqSeq: Int32, groupId: String) throws {
    try outProtocol.writeMessageBegin(name: "leaveGroup", type: .call, sequenceID: 0)
    let args = TalkService_leaveGroup_args(reqSeq: reqSeq, groupId: groupId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_leaveGroup() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_leaveGroup_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func leaveGroup(reqSeq: Int32, groupId: String) throws {
    try send_leaveGroup(reqSeq: reqSeq, groupId: groupId)
    try outProtocol.transport.flush()
    try recv_leaveGroup()
  }

  private func send_leaveRoom(reqSeq: Int32, roomId: String) throws {
    try outProtocol.writeMessageBegin(name: "leaveRoom", type: .call, sequenceID: 0)
    let args = TalkService_leaveRoom_args(reqSeq: reqSeq, roomId: roomId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_leaveRoom() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_leaveRoom_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func leaveRoom(reqSeq: Int32, roomId: String) throws {
    try send_leaveRoom(reqSeq: reqSeq, roomId: roomId)
    try outProtocol.transport.flush()
    try recv_leaveRoom()
  }

  private func send_loginWithIdentityCredential(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) throws {
    try outProtocol.writeMessageBegin(name: "loginWithIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_loginWithIdentityCredential_args(identityProvider: identityProvider, identifier: identifier, password: password, keepLoggedIn: keepLoggedIn, accessLocation: accessLocation, systemName: systemName, certificate: certificate)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_loginWithIdentityCredential() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_loginWithIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "loginWithIdentityCredential"))
  }

  public func loginWithIdentityCredential(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) throws -> String {
    try send_loginWithIdentityCredential(identityProvider: identityProvider, identifier: identifier, password: password, keepLoggedIn: keepLoggedIn, accessLocation: accessLocation, systemName: systemName, certificate: certificate)
    try outProtocol.transport.flush()
    return try recv_loginWithIdentityCredential()
  }

  private func send_loginWithIdentityCredentialForCertificate(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) throws {
    try outProtocol.writeMessageBegin(name: "loginWithIdentityCredentialForCertificate", type: .call, sequenceID: 0)
    let args = TalkService_loginWithIdentityCredentialForCertificate_args(identityProvider: identityProvider, identifier: identifier, password: password, keepLoggedIn: keepLoggedIn, accessLocation: accessLocation, systemName: systemName, certificate: certificate)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_loginWithIdentityCredentialForCertificate() throws -> LoginResult {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_loginWithIdentityCredentialForCertificate_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "loginWithIdentityCredentialForCertificate"))
  }

  public func loginWithIdentityCredentialForCertificate(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) throws -> LoginResult {
    try send_loginWithIdentityCredentialForCertificate(identityProvider: identityProvider, identifier: identifier, password: password, keepLoggedIn: keepLoggedIn, accessLocation: accessLocation, systemName: systemName, certificate: certificate)
    try outProtocol.transport.flush()
    return try recv_loginWithIdentityCredentialForCertificate()
  }

  private func send_loginWithVerifier(verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "loginWithVerifier", type: .call, sequenceID: 0)
    let args = TalkService_loginWithVerifier_args(verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_loginWithVerifier() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_loginWithVerifier_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "loginWithVerifier"))
  }

  public func loginWithVerifier(verifier: String) throws -> String {
    try send_loginWithVerifier(verifier: verifier)
    try outProtocol.transport.flush()
    return try recv_loginWithVerifier()
  }

  private func send_loginWithVerifierForCerificate(verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "loginWithVerifierForCerificate", type: .call, sequenceID: 0)
    let args = TalkService_loginWithVerifierForCerificate_args(verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_loginWithVerifierForCerificate() throws -> LoginResult {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_loginWithVerifierForCerificate_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "loginWithVerifierForCerificate"))
  }

  public func loginWithVerifierForCerificate(verifier: String) throws -> LoginResult {
    try send_loginWithVerifierForCerificate(verifier: verifier)
    try outProtocol.transport.flush()
    return try recv_loginWithVerifierForCerificate()
  }

  private func send_loginWithVerifierForCertificate(verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "loginWithVerifierForCertificate", type: .call, sequenceID: 0)
    let args = TalkService_loginWithVerifierForCertificate_args(verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_loginWithVerifierForCertificate() throws -> LoginResult {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_loginWithVerifierForCertificate_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "loginWithVerifierForCertificate"))
  }

  public func loginWithVerifierForCertificate(verifier: String) throws -> LoginResult {
    try send_loginWithVerifierForCertificate(verifier: verifier)
    try outProtocol.transport.flush()
    return try recv_loginWithVerifierForCertificate()
  }

  private func send_logout() throws {
    try outProtocol.writeMessageBegin(name: "logout", type: .call, sequenceID: 0)
    let args = TalkService_logout_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_logout() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_logout_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func logout() throws {
    try send_logout()
    try outProtocol.transport.flush()
    try recv_logout()
  }

  private func send_logoutSession(tokenKey: String) throws {
    try outProtocol.writeMessageBegin(name: "logoutSession", type: .call, sequenceID: 0)
    let args = TalkService_logoutSession_args(tokenKey: tokenKey)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_logoutSession() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_logoutSession_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func logoutSession(tokenKey: String) throws {
    try send_logoutSession(tokenKey: tokenKey)
    try outProtocol.transport.flush()
    try recv_logoutSession()
  }

  private func send_noop() throws {
    try outProtocol.writeMessageBegin(name: "noop", type: .call, sequenceID: 0)
    let args = TalkService_noop_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_noop() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_noop_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func noop() throws {
    try send_noop()
    try outProtocol.transport.flush()
    try recv_noop()
  }

  private func send_notifiedRedirect(paramMap: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "notifiedRedirect", type: .call, sequenceID: 0)
    let args = TalkService_notifiedRedirect_args(paramMap: paramMap)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifiedRedirect() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_notifiedRedirect_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notifiedRedirect(paramMap: TMap<String, String>) throws {
    try send_notifiedRedirect(paramMap: paramMap)
    try outProtocol.transport.flush()
    try recv_notifiedRedirect()
  }

  private func send_notifyBuddyOnAir(seq: Int32, receiverMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "notifyBuddyOnAir", type: .call, sequenceID: 0)
    let args = TalkService_notifyBuddyOnAir_args(seq: seq, receiverMids: receiverMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyBuddyOnAir() throws -> TMap<String, String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_notifyBuddyOnAir_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "notifyBuddyOnAir"))
  }

  public func notifyBuddyOnAir(seq: Int32, receiverMids: TList<String>) throws -> TMap<String, String> {
    try send_notifyBuddyOnAir(seq: seq, receiverMids: receiverMids)
    try outProtocol.transport.flush()
    return try recv_notifyBuddyOnAir()
  }

  private func send_notifyIndividualEvent(notificationStatus: NotificationStatus, receiverMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "notifyIndividualEvent", type: .call, sequenceID: 0)
    let args = TalkService_notifyIndividualEvent_args(notificationStatus: notificationStatus, receiverMids: receiverMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyIndividualEvent() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_notifyIndividualEvent_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notifyIndividualEvent(notificationStatus: NotificationStatus, receiverMids: TList<String>) throws {
    try send_notifyIndividualEvent(notificationStatus: notificationStatus, receiverMids: receiverMids)
    try outProtocol.transport.flush()
    try recv_notifyIndividualEvent()
  }

  private func send_notifyInstalled(udidHash: String, applicationTypeWithExtensions: String) throws {
    try outProtocol.writeMessageBegin(name: "notifyInstalled", type: .call, sequenceID: 0)
    let args = TalkService_notifyInstalled_args(udidHash: udidHash, applicationTypeWithExtensions: applicationTypeWithExtensions)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyInstalled() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try TalkService_notifyInstalled_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func notifyInstalled(udidHash: String, applicationTypeWithExtensions: String) throws {
    try send_notifyInstalled(udidHash: udidHash, applicationTypeWithExtensions: applicationTypeWithExtensions)
    try outProtocol.transport.flush()
    try recv_notifyInstalled()
  }

  private func send_notifyRegistrationComplete(udidHash: String, applicationTypeWithExtensions: String) throws {
    try outProtocol.writeMessageBegin(name: "notifyRegistrationComplete", type: .call, sequenceID: 0)
    let args = TalkService_notifyRegistrationComplete_args(udidHash: udidHash, applicationTypeWithExtensions: applicationTypeWithExtensions)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyRegistrationComplete() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try TalkService_notifyRegistrationComplete_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func notifyRegistrationComplete(udidHash: String, applicationTypeWithExtensions: String) throws {
    try send_notifyRegistrationComplete(udidHash: udidHash, applicationTypeWithExtensions: applicationTypeWithExtensions)
    try outProtocol.transport.flush()
    try recv_notifyRegistrationComplete()
  }

  private func send_notifySleep(lastRev: Int64, badge: Int32) throws {
    try outProtocol.writeMessageBegin(name: "notifySleep", type: .call, sequenceID: 0)
    let args = TalkService_notifySleep_args(lastRev: lastRev, badge: badge)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifySleep() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_notifySleep_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notifySleep(lastRev: Int64, badge: Int32) throws {
    try send_notifySleep(lastRev: lastRev, badge: badge)
    try outProtocol.transport.flush()
    try recv_notifySleep()
  }

  private func send_notifyUpdated(lastRev: Int64, deviceInfo: DeviceInfo) throws {
    try outProtocol.writeMessageBegin(name: "notifyUpdated", type: .call, sequenceID: 0)
    let args = TalkService_notifyUpdated_args(lastRev: lastRev, deviceInfo: deviceInfo)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notifyUpdated() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_notifyUpdated_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notifyUpdated(lastRev: Int64, deviceInfo: DeviceInfo) throws {
    try send_notifyUpdated(lastRev: lastRev, deviceInfo: deviceInfo)
    try outProtocol.transport.flush()
    try recv_notifyUpdated()
  }

  private func send_openProximityMatch(location: Location) throws {
    try outProtocol.writeMessageBegin(name: "openProximityMatch", type: .call, sequenceID: 0)
    let args = TalkService_openProximityMatch_args(location: location)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_openProximityMatch() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_openProximityMatch_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "openProximityMatch"))
  }

  public func openProximityMatch(location: Location) throws -> String {
    try send_openProximityMatch(location: location)
    try outProtocol.transport.flush()
    return try recv_openProximityMatch()
  }

  private func send_registerBuddyUser(buddyId: String, registrarPassword: String) throws {
    try outProtocol.writeMessageBegin(name: "registerBuddyUser", type: .call, sequenceID: 0)
    let args = TalkService_registerBuddyUser_args(buddyId: buddyId, registrarPassword: registrarPassword)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerBuddyUser() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerBuddyUser_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerBuddyUser"))
  }

  public func registerBuddyUser(buddyId: String, registrarPassword: String) throws -> String {
    try send_registerBuddyUser(buddyId: buddyId, registrarPassword: registrarPassword)
    try outProtocol.transport.flush()
    return try recv_registerBuddyUser()
  }

  private func send_registerBuddyUserid(seq: Int32, userid: String) throws {
    try outProtocol.writeMessageBegin(name: "registerBuddyUserid", type: .call, sequenceID: 0)
    let args = TalkService_registerBuddyUserid_args(seq: seq, userid: userid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerBuddyUserid() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerBuddyUserid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func registerBuddyUserid(seq: Int32, userid: String) throws {
    try send_registerBuddyUserid(seq: seq, userid: userid)
    try outProtocol.transport.flush()
    try recv_registerBuddyUserid()
  }

  private func send_registerDevice(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "registerDevice", type: .call, sequenceID: 0)
    let args = TalkService_registerDevice_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerDevice() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerDevice_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerDevice"))
  }

  public func registerDevice(sessionId: String) throws -> String {
    try send_registerDevice(sessionId: sessionId)
    try outProtocol.transport.flush()
    return try recv_registerDevice()
  }

  private func send_registerDeviceWithIdentityCredential(sessionId: String, provider: IdentityProvider, identifier: String, verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "registerDeviceWithIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_registerDeviceWithIdentityCredential_args(sessionId: sessionId, provider: provider, identifier: identifier, verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerDeviceWithIdentityCredential() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerDeviceWithIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerDeviceWithIdentityCredential"))
  }

  public func registerDeviceWithIdentityCredential(sessionId: String, provider: IdentityProvider, identifier: String, verifier: String) throws -> String {
    try send_registerDeviceWithIdentityCredential(sessionId: sessionId, provider: provider, identifier: identifier, verifier: verifier)
    try outProtocol.transport.flush()
    return try recv_registerDeviceWithIdentityCredential()
  }

  private func send_registerDeviceWithoutPhoneNumber(region: String, udidHash: String, deviceInfo: DeviceInfo) throws {
    try outProtocol.writeMessageBegin(name: "registerDeviceWithoutPhoneNumber", type: .call, sequenceID: 0)
    let args = TalkService_registerDeviceWithoutPhoneNumber_args(region: region, udidHash: udidHash, deviceInfo: deviceInfo)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerDeviceWithoutPhoneNumber() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerDeviceWithoutPhoneNumber_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerDeviceWithoutPhoneNumber"))
  }

  public func registerDeviceWithoutPhoneNumber(region: String, udidHash: String, deviceInfo: DeviceInfo) throws -> String {
    try send_registerDeviceWithoutPhoneNumber(region: region, udidHash: udidHash, deviceInfo: deviceInfo)
    try outProtocol.transport.flush()
    return try recv_registerDeviceWithoutPhoneNumber()
  }

  private func send_registerDeviceWithoutPhoneNumberWithIdentityCredential(region: String, udidHash: String, deviceInfo: DeviceInfo, provider: IdentityProvider, identifier: String, verifier: String, mid: String) throws {
    try outProtocol.writeMessageBegin(name: "registerDeviceWithoutPhoneNumberWithIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args(region: region, udidHash: udidHash, deviceInfo: deviceInfo, provider: provider, identifier: identifier, verifier: verifier, mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerDeviceWithoutPhoneNumberWithIdentityCredential() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerDeviceWithoutPhoneNumberWithIdentityCredential"))
  }

  public func registerDeviceWithoutPhoneNumberWithIdentityCredential(region: String, udidHash: String, deviceInfo: DeviceInfo, provider: IdentityProvider, identifier: String, verifier: String, mid: String) throws -> String {
    try send_registerDeviceWithoutPhoneNumberWithIdentityCredential(region: region, udidHash: udidHash, deviceInfo: deviceInfo, provider: provider, identifier: identifier, verifier: verifier, mid: mid)
    try outProtocol.transport.flush()
    return try recv_registerDeviceWithoutPhoneNumberWithIdentityCredential()
  }

  private func send_registerUserid(reqSeq: Int32, userid: String) throws {
    try outProtocol.writeMessageBegin(name: "registerUserid", type: .call, sequenceID: 0)
    let args = TalkService_registerUserid_args(reqSeq: reqSeq, userid: userid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerUserid() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerUserid_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerUserid"))
  }

  public func registerUserid(reqSeq: Int32, userid: String) throws -> Bool {
    try send_registerUserid(reqSeq: reqSeq, userid: userid)
    try outProtocol.transport.flush()
    return try recv_registerUserid()
  }

  private func send_registerWapDevice(invitationHash: String, guidHash: String, email: String, deviceInfo: DeviceInfo) throws {
    try outProtocol.writeMessageBegin(name: "registerWapDevice", type: .call, sequenceID: 0)
    let args = TalkService_registerWapDevice_args(invitationHash: invitationHash, guidHash: guidHash, email: email, deviceInfo: deviceInfo)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerWapDevice() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerWapDevice_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerWapDevice"))
  }

  public func registerWapDevice(invitationHash: String, guidHash: String, email: String, deviceInfo: DeviceInfo) throws -> String {
    try send_registerWapDevice(invitationHash: invitationHash, guidHash: guidHash, email: email, deviceInfo: deviceInfo)
    try outProtocol.transport.flush()
    return try recv_registerWapDevice()
  }

  private func send_registerWithExistingSnsIdAndIdentityCredential(identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) throws {
    try outProtocol.writeMessageBegin(name: "registerWithExistingSnsIdAndIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_registerWithExistingSnsIdAndIdentityCredential_args(identityCredential: identityCredential, region: region, udidHash: udidHash, deviceInfo: deviceInfo)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerWithExistingSnsIdAndIdentityCredential() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerWithExistingSnsIdAndIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerWithExistingSnsIdAndIdentityCredential"))
  }

  public func registerWithExistingSnsIdAndIdentityCredential(identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) throws -> String {
    try send_registerWithExistingSnsIdAndIdentityCredential(identityCredential: identityCredential, region: region, udidHash: udidHash, deviceInfo: deviceInfo)
    try outProtocol.transport.flush()
    return try recv_registerWithExistingSnsIdAndIdentityCredential()
  }

  private func send_registerWithSnsId(snsIdType: SnsIdType, snsAccessToken: String, region: String, udidHash: String, deviceInfo: DeviceInfo, mid: String) throws {
    try outProtocol.writeMessageBegin(name: "registerWithSnsId", type: .call, sequenceID: 0)
    let args = TalkService_registerWithSnsId_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, region: region, udidHash: udidHash, deviceInfo: deviceInfo, mid: mid)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerWithSnsId() throws -> RegisterWithSnsIdResult {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerWithSnsId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerWithSnsId"))
  }

  public func registerWithSnsId(snsIdType: SnsIdType, snsAccessToken: String, region: String, udidHash: String, deviceInfo: DeviceInfo, mid: String) throws -> RegisterWithSnsIdResult {
    try send_registerWithSnsId(snsIdType: snsIdType, snsAccessToken: snsAccessToken, region: region, udidHash: udidHash, deviceInfo: deviceInfo, mid: mid)
    try outProtocol.transport.flush()
    return try recv_registerWithSnsId()
  }

  private func send_registerWithSnsIdAndIdentityCredential(snsIdType: SnsIdType, snsAccessToken: String, identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) throws {
    try outProtocol.writeMessageBegin(name: "registerWithSnsIdAndIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_registerWithSnsIdAndIdentityCredential_args(snsIdType: snsIdType, snsAccessToken: snsAccessToken, identityCredential: identityCredential, region: region, udidHash: udidHash, deviceInfo: deviceInfo)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerWithSnsIdAndIdentityCredential() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_registerWithSnsIdAndIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "registerWithSnsIdAndIdentityCredential"))
  }

  public func registerWithSnsIdAndIdentityCredential(snsIdType: SnsIdType, snsAccessToken: String, identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) throws -> String {
    try send_registerWithSnsIdAndIdentityCredential(snsIdType: snsIdType, snsAccessToken: snsAccessToken, identityCredential: identityCredential, region: region, udidHash: udidHash, deviceInfo: deviceInfo)
    try outProtocol.transport.flush()
    return try recv_registerWithSnsIdAndIdentityCredential()
  }

  private func send_reissueDeviceCredential() throws {
    try outProtocol.writeMessageBegin(name: "reissueDeviceCredential", type: .call, sequenceID: 0)
    let args = TalkService_reissueDeviceCredential_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reissueDeviceCredential() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reissueDeviceCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "reissueDeviceCredential"))
  }

  public func reissueDeviceCredential() throws -> String {
    try send_reissueDeviceCredential()
    try outProtocol.transport.flush()
    return try recv_reissueDeviceCredential()
  }

  private func send_reissueUserTicket(expirationTime: Int64, maxUseCount: Int32) throws {
    try outProtocol.writeMessageBegin(name: "reissueUserTicket", type: .call, sequenceID: 0)
    let args = TalkService_reissueUserTicket_args(expirationTime: expirationTime, maxUseCount: maxUseCount)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reissueUserTicket() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reissueUserTicket_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "reissueUserTicket"))
  }

  public func reissueUserTicket(expirationTime: Int64, maxUseCount: Int32) throws -> String {
    try send_reissueUserTicket(expirationTime: expirationTime, maxUseCount: maxUseCount)
    try outProtocol.transport.flush()
    return try recv_reissueUserTicket()
  }

  private func send_rejectGroupInvitation(reqSeq: Int32, groupId: String) throws {
    try outProtocol.writeMessageBegin(name: "rejectGroupInvitation", type: .call, sequenceID: 0)
    let args = TalkService_rejectGroupInvitation_args(reqSeq: reqSeq, groupId: groupId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_rejectGroupInvitation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_rejectGroupInvitation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func rejectGroupInvitation(reqSeq: Int32, groupId: String) throws {
    try send_rejectGroupInvitation(reqSeq: reqSeq, groupId: groupId)
    try outProtocol.transport.flush()
    try recv_rejectGroupInvitation()
  }

  private func send_releaseSession() throws {
    try outProtocol.writeMessageBegin(name: "releaseSession", type: .call, sequenceID: 0)
    let args = TalkService_releaseSession_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_releaseSession() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_releaseSession_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func releaseSession() throws {
    try send_releaseSession()
    try outProtocol.transport.flush()
    try recv_releaseSession()
  }

  private func send_removeAllMessages(seq: Int32, lastMessageId: String) throws {
    try outProtocol.writeMessageBegin(name: "removeAllMessages", type: .call, sequenceID: 0)
    let args = TalkService_removeAllMessages_args(seq: seq, lastMessageId: lastMessageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeAllMessages() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_removeAllMessages_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func removeAllMessages(seq: Int32, lastMessageId: String) throws {
    try send_removeAllMessages(seq: seq, lastMessageId: lastMessageId)
    try outProtocol.transport.flush()
    try recv_removeAllMessages()
  }

  private func send_removeBuddyLocation(mid: String, index: Int32) throws {
    try outProtocol.writeMessageBegin(name: "removeBuddyLocation", type: .call, sequenceID: 0)
    let args = TalkService_removeBuddyLocation_args(mid: mid, index: index)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeBuddyLocation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_removeBuddyLocation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func removeBuddyLocation(mid: String, index: Int32) throws {
    try send_removeBuddyLocation(mid: mid, index: index)
    try outProtocol.transport.flush()
    try recv_removeBuddyLocation()
  }

  private func send_removeMessage(messageId: String) throws {
    try outProtocol.writeMessageBegin(name: "removeMessage", type: .call, sequenceID: 0)
    let args = TalkService_removeMessage_args(messageId: messageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeMessage() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_removeMessage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "removeMessage"))
  }

  public func removeMessage(messageId: String) throws -> Bool {
    try send_removeMessage(messageId: messageId)
    try outProtocol.transport.flush()
    return try recv_removeMessage()
  }

  private func send_removeMessageFromMyHome(messageId: String) throws {
    try outProtocol.writeMessageBegin(name: "removeMessageFromMyHome", type: .call, sequenceID: 0)
    let args = TalkService_removeMessageFromMyHome_args(messageId: messageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeMessageFromMyHome() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_removeMessageFromMyHome_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "removeMessageFromMyHome"))
  }

  public func removeMessageFromMyHome(messageId: String) throws -> Bool {
    try send_removeMessageFromMyHome(messageId: messageId)
    try outProtocol.transport.flush()
    return try recv_removeMessageFromMyHome()
  }

  private func send_removeSnsId(snsIdType: SnsIdType) throws {
    try outProtocol.writeMessageBegin(name: "removeSnsId", type: .call, sequenceID: 0)
    let args = TalkService_removeSnsId_args(snsIdType: snsIdType)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_removeSnsId() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_removeSnsId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "removeSnsId"))
  }

  public func removeSnsId(snsIdType: SnsIdType) throws -> String {
    try send_removeSnsId(snsIdType: snsIdType)
    try outProtocol.transport.flush()
    return try recv_removeSnsId()
  }

  private func send_report(syncOpRevision: Int64, category: SyncCategory, report: String) throws {
    try outProtocol.writeMessageBegin(name: "report", type: .call, sequenceID: 0)
    let args = TalkService_report_args(syncOpRevision: syncOpRevision, category: category, report: report)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_report() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_report_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func report(syncOpRevision: Int64, category: SyncCategory, report: String) throws {
    try send_report(syncOpRevision: syncOpRevision, category: category, report: report)
    try outProtocol.transport.flush()
    try recv_report()
  }

  private func send_reportContacts(syncOpRevision: Int64, category: SyncCategory, contactReports: TList<ContactReport>, actionType: SyncActionType) throws {
    try outProtocol.writeMessageBegin(name: "reportContacts", type: .call, sequenceID: 0)
    let args = TalkService_reportContacts_args(syncOpRevision: syncOpRevision, category: category, contactReports: contactReports, actionType: actionType)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reportContacts() throws -> TList<ContactReportResult> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reportContacts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "reportContacts"))
  }

  public func reportContacts(syncOpRevision: Int64, category: SyncCategory, contactReports: TList<ContactReport>, actionType: SyncActionType) throws -> TList<ContactReportResult> {
    try send_reportContacts(syncOpRevision: syncOpRevision, category: category, contactReports: contactReports, actionType: actionType)
    try outProtocol.transport.flush()
    return try recv_reportContacts()
  }

  private func send_reportGroups(syncOpRevision: Int64, groups: TList<Group>) throws {
    try outProtocol.writeMessageBegin(name: "reportGroups", type: .call, sequenceID: 0)
    let args = TalkService_reportGroups_args(syncOpRevision: syncOpRevision, groups: groups)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reportGroups() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reportGroups_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func reportGroups(syncOpRevision: Int64, groups: TList<Group>) throws {
    try send_reportGroups(syncOpRevision: syncOpRevision, groups: groups)
    try outProtocol.transport.flush()
    try recv_reportGroups()
  }

  private func send_reportProfile(syncOpRevision: Int64, profile: Profile) throws {
    try outProtocol.writeMessageBegin(name: "reportProfile", type: .call, sequenceID: 0)
    let args = TalkService_reportProfile_args(syncOpRevision: syncOpRevision, profile: profile)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reportProfile() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reportProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func reportProfile(syncOpRevision: Int64, profile: Profile) throws {
    try send_reportProfile(syncOpRevision: syncOpRevision, profile: profile)
    try outProtocol.transport.flush()
    try recv_reportProfile()
  }

  private func send_reportRooms(syncOpRevision: Int64, rooms: TList<Room>) throws {
    try outProtocol.writeMessageBegin(name: "reportRooms", type: .call, sequenceID: 0)
    let args = TalkService_reportRooms_args(syncOpRevision: syncOpRevision, rooms: rooms)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reportRooms() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reportRooms_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func reportRooms(syncOpRevision: Int64, rooms: TList<Room>) throws {
    try send_reportRooms(syncOpRevision: syncOpRevision, rooms: rooms)
    try outProtocol.transport.flush()
    try recv_reportRooms()
  }

  private func send_reportSettings(syncOpRevision: Int64, settings: Settings) throws {
    try outProtocol.writeMessageBegin(name: "reportSettings", type: .call, sequenceID: 0)
    let args = TalkService_reportSettings_args(syncOpRevision: syncOpRevision, settings: settings)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reportSettings() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reportSettings_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func reportSettings(syncOpRevision: Int64, settings: Settings) throws {
    try send_reportSettings(syncOpRevision: syncOpRevision, settings: settings)
    try outProtocol.transport.flush()
    try recv_reportSettings()
  }

  private func send_reportSpammer(spammerMid: String, spammerReasons: TList<SpammerReason>, spamMessageIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "reportSpammer", type: .call, sequenceID: 0)
    let args = TalkService_reportSpammer_args(spammerMid: spammerMid, spammerReasons: spammerReasons, spamMessageIds: spamMessageIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reportSpammer() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_reportSpammer_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func reportSpammer(spammerMid: String, spammerReasons: TList<SpammerReason>, spamMessageIds: TList<String>) throws {
    try send_reportSpammer(spammerMid: spammerMid, spammerReasons: spammerReasons, spamMessageIds: spamMessageIds)
    try outProtocol.transport.flush()
    try recv_reportSpammer()
  }

  private func send_requestAccountPasswordReset(provider: IdentityProvider, identifier: String, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "requestAccountPasswordReset", type: .call, sequenceID: 0)
    let args = TalkService_requestAccountPasswordReset_args(provider: provider, identifier: identifier, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_requestAccountPasswordReset() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_requestAccountPasswordReset_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func requestAccountPasswordReset(provider: IdentityProvider, identifier: String, locale: String) throws {
    try send_requestAccountPasswordReset(provider: provider, identifier: identifier, locale: locale)
    try outProtocol.transport.flush()
    try recv_requestAccountPasswordReset()
  }

  private func send_requestEmailConfirmation(emailConfirmation: EmailConfirmation) throws {
    try outProtocol.writeMessageBegin(name: "requestEmailConfirmation", type: .call, sequenceID: 0)
    let args = TalkService_requestEmailConfirmation_args(emailConfirmation: emailConfirmation)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_requestEmailConfirmation() throws -> EmailConfirmationSession {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_requestEmailConfirmation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "requestEmailConfirmation"))
  }

  public func requestEmailConfirmation(emailConfirmation: EmailConfirmation) throws -> EmailConfirmationSession {
    try send_requestEmailConfirmation(emailConfirmation: emailConfirmation)
    try outProtocol.transport.flush()
    return try recv_requestEmailConfirmation()
  }

  private func send_requestIdentityUnbind(provider: IdentityProvider, identifier: String) throws {
    try outProtocol.writeMessageBegin(name: "requestIdentityUnbind", type: .call, sequenceID: 0)
    let args = TalkService_requestIdentityUnbind_args(provider: provider, identifier: identifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_requestIdentityUnbind() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_requestIdentityUnbind_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func requestIdentityUnbind(provider: IdentityProvider, identifier: String) throws {
    try send_requestIdentityUnbind(provider: provider, identifier: identifier)
    try outProtocol.transport.flush()
    try recv_requestIdentityUnbind()
  }

  private func send_resendEmailConfirmation(verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "resendEmailConfirmation", type: .call, sequenceID: 0)
    let args = TalkService_resendEmailConfirmation_args(verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_resendEmailConfirmation() throws -> EmailConfirmationSession {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_resendEmailConfirmation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "resendEmailConfirmation"))
  }

  public func resendEmailConfirmation(verifier: String) throws -> EmailConfirmationSession {
    try send_resendEmailConfirmation(verifier: verifier)
    try outProtocol.transport.flush()
    return try recv_resendEmailConfirmation()
  }

  private func send_resendPinCode(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "resendPinCode", type: .call, sequenceID: 0)
    let args = TalkService_resendPinCode_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_resendPinCode() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_resendPinCode_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func resendPinCode(sessionId: String) throws {
    try send_resendPinCode(sessionId: sessionId)
    try outProtocol.transport.flush()
    try recv_resendPinCode()
  }

  private func send_resendPinCodeBySMS(sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "resendPinCodeBySMS", type: .call, sequenceID: 0)
    let args = TalkService_resendPinCodeBySMS_args(sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_resendPinCodeBySMS() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_resendPinCodeBySMS_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func resendPinCodeBySMS(sessionId: String) throws {
    try send_resendPinCodeBySMS(sessionId: sessionId)
    try outProtocol.transport.flush()
    try recv_resendPinCodeBySMS()
  }

  private func send_sendChatChecked(seq: Int32, consumer: String, lastMessageId: String) throws {
    try outProtocol.writeMessageBegin(name: "sendChatChecked", type: .call, sequenceID: 0)
    let args = TalkService_sendChatChecked_args(seq: seq, consumer: consumer, lastMessageId: lastMessageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendChatChecked() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendChatChecked_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendChatChecked(seq: Int32, consumer: String, lastMessageId: String) throws {
    try send_sendChatChecked(seq: seq, consumer: consumer, lastMessageId: lastMessageId)
    try outProtocol.transport.flush()
    try recv_sendChatChecked()
  }

  private func send_sendChatRemoved(seq: Int32, consumer: String, lastMessageId: String) throws {
    try outProtocol.writeMessageBegin(name: "sendChatRemoved", type: .call, sequenceID: 0)
    let args = TalkService_sendChatRemoved_args(seq: seq, consumer: consumer, lastMessageId: lastMessageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendChatRemoved() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendChatRemoved_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendChatRemoved(seq: Int32, consumer: String, lastMessageId: String) throws {
    try send_sendChatRemoved(seq: seq, consumer: consumer, lastMessageId: lastMessageId)
    try outProtocol.transport.flush()
    try recv_sendChatRemoved()
  }

  private func send_sendContentPreviewUpdated(esq: Int32, messageId: String, receiverMids: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "sendContentPreviewUpdated", type: .call, sequenceID: 0)
    let args = TalkService_sendContentPreviewUpdated_args(esq: esq, messageId: messageId, receiverMids: receiverMids)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendContentPreviewUpdated() throws -> TMap<String, String> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendContentPreviewUpdated_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendContentPreviewUpdated"))
  }

  public func sendContentPreviewUpdated(esq: Int32, messageId: String, receiverMids: TList<String>) throws -> TMap<String, String> {
    try send_sendContentPreviewUpdated(esq: esq, messageId: messageId, receiverMids: receiverMids)
    try outProtocol.transport.flush()
    return try recv_sendContentPreviewUpdated()
  }

  private func send_sendContentReceipt(seq: Int32, consumer: String, messageId: String) throws {
    try outProtocol.writeMessageBegin(name: "sendContentReceipt", type: .call, sequenceID: 0)
    let args = TalkService_sendContentReceipt_args(seq: seq, consumer: consumer, messageId: messageId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendContentReceipt() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendContentReceipt_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendContentReceipt(seq: Int32, consumer: String, messageId: String) throws {
    try send_sendContentReceipt(seq: seq, consumer: consumer, messageId: messageId)
    try outProtocol.transport.flush()
    try recv_sendContentReceipt()
  }

  private func send_sendDummyPush() throws {
    try outProtocol.writeMessageBegin(name: "sendDummyPush", type: .call, sequenceID: 0)
    let args = TalkService_sendDummyPush_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendDummyPush() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendDummyPush_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendDummyPush() throws {
    try send_sendDummyPush()
    try outProtocol.transport.flush()
    try recv_sendDummyPush()
  }

  private func send_sendEvent(seq: Int32, message: Message) throws {
    try outProtocol.writeMessageBegin(name: "sendEvent", type: .call, sequenceID: 0)
    let args = TalkService_sendEvent_args(seq: seq, message: message)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendEvent() throws -> Message {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendEvent_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendEvent"))
  }

  public func sendEvent(seq: Int32, message: Message) throws -> Message {
    try send_sendEvent(seq: seq, message: message)
    try outProtocol.transport.flush()
    return try recv_sendEvent()
  }

  private func send_sendMessage(seq: Int32, message: Message) throws {
    try outProtocol.writeMessageBegin(name: "sendMessage", type: .call, sequenceID: 0)
    let args = TalkService_sendMessage_args(seq: seq, message: message)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMessage() throws -> Message {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendMessage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendMessage"))
  }

  public func sendMessage(seq: Int32, message: Message) throws -> Message {
    try send_sendMessage(seq: seq, message: message)
    try outProtocol.transport.flush()
    return try recv_sendMessage()
  }

  private func send_sendMessageIgnored(seq: Int32, consumer: String, messageIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "sendMessageIgnored", type: .call, sequenceID: 0)
    let args = TalkService_sendMessageIgnored_args(seq: seq, consumer: consumer, messageIds: messageIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMessageIgnored() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendMessageIgnored_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendMessageIgnored(seq: Int32, consumer: String, messageIds: TList<String>) throws {
    try send_sendMessageIgnored(seq: seq, consumer: consumer, messageIds: messageIds)
    try outProtocol.transport.flush()
    try recv_sendMessageIgnored()
  }

  private func send_sendMessageReceipt(seq: Int32, consumer: String, messageIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "sendMessageReceipt", type: .call, sequenceID: 0)
    let args = TalkService_sendMessageReceipt_args(seq: seq, consumer: consumer, messageIds: messageIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMessageReceipt() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendMessageReceipt_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func sendMessageReceipt(seq: Int32, consumer: String, messageIds: TList<String>) throws {
    try send_sendMessageReceipt(seq: seq, consumer: consumer, messageIds: messageIds)
    try outProtocol.transport.flush()
    try recv_sendMessageReceipt()
  }

  private func send_sendMessageToMyHome(seq: Int32, message: Message) throws {
    try outProtocol.writeMessageBegin(name: "sendMessageToMyHome", type: .call, sequenceID: 0)
    let args = TalkService_sendMessageToMyHome_args(seq: seq, message: message)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMessageToMyHome() throws -> Message {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_sendMessageToMyHome_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "sendMessageToMyHome"))
  }

  public func sendMessageToMyHome(seq: Int32, message: Message) throws -> Message {
    try send_sendMessageToMyHome(seq: seq, message: message)
    try outProtocol.transport.flush()
    return try recv_sendMessageToMyHome()
  }

  private func send_setBuddyLocation(mid: String, index: Int32, location: Geolocation) throws {
    try outProtocol.writeMessageBegin(name: "setBuddyLocation", type: .call, sequenceID: 0)
    let args = TalkService_setBuddyLocation_args(mid: mid, index: index, location: location)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_setBuddyLocation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_setBuddyLocation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func setBuddyLocation(mid: String, index: Int32, location: Geolocation) throws {
    try send_setBuddyLocation(mid: mid, index: index, location: location)
    try outProtocol.transport.flush()
    try recv_setBuddyLocation()
  }

  private func send_setIdentityCredential(provider: IdentityProvider, identifier: String, verifier: String) throws {
    try outProtocol.writeMessageBegin(name: "setIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_setIdentityCredential_args(provider: provider, identifier: identifier, verifier: verifier)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_setIdentityCredential() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_setIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func setIdentityCredential(provider: IdentityProvider, identifier: String, verifier: String) throws {
    try send_setIdentityCredential(provider: provider, identifier: identifier, verifier: verifier)
    try outProtocol.transport.flush()
    try recv_setIdentityCredential()
  }

  private func send_setNotificationsEnabled(reqSeq: Int32, type: MIDType, target: String, enablement: Bool) throws {
    try outProtocol.writeMessageBegin(name: "setNotificationsEnabled", type: .call, sequenceID: 0)
    let args = TalkService_setNotificationsEnabled_args(reqSeq: reqSeq, type: type, target: target, enablement: enablement)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_setNotificationsEnabled() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_setNotificationsEnabled_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func setNotificationsEnabled(reqSeq: Int32, type: MIDType, target: String, enablement: Bool) throws {
    try send_setNotificationsEnabled(reqSeq: reqSeq, type: type, target: target, enablement: enablement)
    try outProtocol.transport.flush()
    try recv_setNotificationsEnabled()
  }

  private func send_startUpdateVerification(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "startUpdateVerification", type: .call, sequenceID: 0)
    let args = TalkService_startUpdateVerification_args(region: region, carrier: carrier, phone: phone, udidHash: udidHash, deviceInfo: deviceInfo, networkCode: networkCode, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_startUpdateVerification() throws -> VerificationSessionData {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_startUpdateVerification_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "startUpdateVerification"))
  }

  public func startUpdateVerification(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, locale: String) throws -> VerificationSessionData {
    try send_startUpdateVerification(region: region, carrier: carrier, phone: phone, udidHash: udidHash, deviceInfo: deviceInfo, networkCode: networkCode, locale: locale)
    try outProtocol.transport.flush()
    return try recv_startUpdateVerification()
  }

  private func send_startVerification(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, mid: String, locale: String) throws {
    try outProtocol.writeMessageBegin(name: "startVerification", type: .call, sequenceID: 0)
    let args = TalkService_startVerification_args(region: region, carrier: carrier, phone: phone, udidHash: udidHash, deviceInfo: deviceInfo, networkCode: networkCode, mid: mid, locale: locale)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_startVerification() throws -> VerificationSessionData {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_startVerification_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "startVerification"))
  }

  public func startVerification(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, mid: String, locale: String) throws -> VerificationSessionData {
    try send_startVerification(region: region, carrier: carrier, phone: phone, udidHash: udidHash, deviceInfo: deviceInfo, networkCode: networkCode, mid: mid, locale: locale)
    try outProtocol.transport.flush()
    return try recv_startVerification()
  }

  private func send_storeUpdateProfileAttribute(seq: Int32, profileAttribute: ProfileAttribute, value: String) throws {
    try outProtocol.writeMessageBegin(name: "storeUpdateProfileAttribute", type: .call, sequenceID: 0)
    let args = TalkService_storeUpdateProfileAttribute_args(seq: seq, profileAttribute: profileAttribute, value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_storeUpdateProfileAttribute() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_storeUpdateProfileAttribute_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func storeUpdateProfileAttribute(seq: Int32, profileAttribute: ProfileAttribute, value: String) throws {
    try send_storeUpdateProfileAttribute(seq: seq, profileAttribute: profileAttribute, value: value)
    try outProtocol.transport.flush()
    try recv_storeUpdateProfileAttribute()
  }

  private func send_syncContactBySnsIds(reqSeq: Int32, modifications: TList<SnsFriendModification>) throws {
    try outProtocol.writeMessageBegin(name: "syncContactBySnsIds", type: .call, sequenceID: 0)
    let args = TalkService_syncContactBySnsIds_args(reqSeq: reqSeq, modifications: modifications)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_syncContactBySnsIds() throws -> TList<SnsFriendContactRegistration> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_syncContactBySnsIds_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "syncContactBySnsIds"))
  }

  public func syncContactBySnsIds(reqSeq: Int32, modifications: TList<SnsFriendModification>) throws -> TList<SnsFriendContactRegistration> {
    try send_syncContactBySnsIds(reqSeq: reqSeq, modifications: modifications)
    try outProtocol.transport.flush()
    return try recv_syncContactBySnsIds()
  }

  private func send_syncContacts(reqSeq: Int32, localContacts: TList<ContactModification>) throws {
    try outProtocol.writeMessageBegin(name: "syncContacts", type: .call, sequenceID: 0)
    let args = TalkService_syncContacts_args(reqSeq: reqSeq, localContacts: localContacts)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_syncContacts() throws -> TMap<String, ContactRegistration> {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_syncContacts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "syncContacts"))
  }

  public func syncContacts(reqSeq: Int32, localContacts: TList<ContactModification>) throws -> TMap<String, ContactRegistration> {
    try send_syncContacts(reqSeq: reqSeq, localContacts: localContacts)
    try outProtocol.transport.flush()
    return try recv_syncContacts()
  }

  private func send_trySendMessage(seq: Int32, message: Message) throws {
    try outProtocol.writeMessageBegin(name: "trySendMessage", type: .call, sequenceID: 0)
    let args = TalkService_trySendMessage_args(seq: seq, message: message)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_trySendMessage() throws -> Message {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_trySendMessage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "trySendMessage"))
  }

  public func trySendMessage(seq: Int32, message: Message) throws -> Message {
    try send_trySendMessage(seq: seq, message: message)
    try outProtocol.transport.flush()
    return try recv_trySendMessage()
  }

  private func send_unblockContact(reqSeq: Int32, id: String) throws {
    try outProtocol.writeMessageBegin(name: "unblockContact", type: .call, sequenceID: 0)
    let args = TalkService_unblockContact_args(reqSeq: reqSeq, id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unblockContact() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_unblockContact_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func unblockContact(reqSeq: Int32, id: String) throws {
    try send_unblockContact(reqSeq: reqSeq, id: id)
    try outProtocol.transport.flush()
    try recv_unblockContact()
  }

  private func send_unblockRecommendation(reqSeq: Int32, id: String) throws {
    try outProtocol.writeMessageBegin(name: "unblockRecommendation", type: .call, sequenceID: 0)
    let args = TalkService_unblockRecommendation_args(reqSeq: reqSeq, id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unblockRecommendation() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_unblockRecommendation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func unblockRecommendation(reqSeq: Int32, id: String) throws {
    try send_unblockRecommendation(reqSeq: reqSeq, id: id)
    try outProtocol.transport.flush()
    try recv_unblockRecommendation()
  }

  private func send_unregisterUserAndDevice() throws {
    try outProtocol.writeMessageBegin(name: "unregisterUserAndDevice", type: .call, sequenceID: 0)
    let args = TalkService_unregisterUserAndDevice_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unregisterUserAndDevice() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_unregisterUserAndDevice_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "unregisterUserAndDevice"))
  }

  public func unregisterUserAndDevice() throws -> String {
    try send_unregisterUserAndDevice()
    try outProtocol.transport.flush()
    return try recv_unregisterUserAndDevice()
  }

  private func send_updateApnsDeviceToken(apnsDeviceToken: Data) throws {
    try outProtocol.writeMessageBegin(name: "updateApnsDeviceToken", type: .call, sequenceID: 0)
    let args = TalkService_updateApnsDeviceToken_args(apnsDeviceToken: apnsDeviceToken)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateApnsDeviceToken() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateApnsDeviceToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateApnsDeviceToken(apnsDeviceToken: Data) throws {
    try send_updateApnsDeviceToken(apnsDeviceToken: apnsDeviceToken)
    try outProtocol.transport.flush()
    try recv_updateApnsDeviceToken()
  }

  private func send_updateBuddySetting(key: String, value: String) throws {
    try outProtocol.writeMessageBegin(name: "updateBuddySetting", type: .call, sequenceID: 0)
    let args = TalkService_updateBuddySetting_args(key: key, value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateBuddySetting() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateBuddySetting_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateBuddySetting(key: String, value: String) throws {
    try send_updateBuddySetting(key: key, value: value)
    try outProtocol.transport.flush()
    try recv_updateBuddySetting()
  }

  private func send_updateC2DMRegistrationId(registrationId: String) throws {
    try outProtocol.writeMessageBegin(name: "updateC2DMRegistrationId", type: .call, sequenceID: 0)
    let args = TalkService_updateC2DMRegistrationId_args(registrationId: registrationId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateC2DMRegistrationId() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateC2DMRegistrationId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateC2DMRegistrationId(registrationId: String) throws {
    try send_updateC2DMRegistrationId(registrationId: registrationId)
    try outProtocol.transport.flush()
    try recv_updateC2DMRegistrationId()
  }

  private func send_updateContactSetting(reqSeq: Int32, mid: String, flag: ContactSetting, value: String) throws {
    try outProtocol.writeMessageBegin(name: "updateContactSetting", type: .call, sequenceID: 0)
    let args = TalkService_updateContactSetting_args(reqSeq: reqSeq, mid: mid, flag: flag, value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateContactSetting() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateContactSetting_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateContactSetting(reqSeq: Int32, mid: String, flag: ContactSetting, value: String) throws {
    try send_updateContactSetting(reqSeq: reqSeq, mid: mid, flag: flag, value: value)
    try outProtocol.transport.flush()
    try recv_updateContactSetting()
  }

  private func send_updateCustomModeSettings(customMode: CustomMode, paramMap: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "updateCustomModeSettings", type: .call, sequenceID: 0)
    let args = TalkService_updateCustomModeSettings_args(customMode: customMode, paramMap: paramMap)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateCustomModeSettings() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateCustomModeSettings_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateCustomModeSettings(customMode: CustomMode, paramMap: TMap<String, String>) throws {
    try send_updateCustomModeSettings(customMode: customMode, paramMap: paramMap)
    try outProtocol.transport.flush()
    try recv_updateCustomModeSettings()
  }

  private func send_updateDeviceInfo(deviceUid: String, deviceInfo: DeviceInfo) throws {
    try outProtocol.writeMessageBegin(name: "updateDeviceInfo", type: .call, sequenceID: 0)
    let args = TalkService_updateDeviceInfo_args(deviceUid: deviceUid, deviceInfo: deviceInfo)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateDeviceInfo() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateDeviceInfo_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateDeviceInfo(deviceUid: String, deviceInfo: DeviceInfo) throws {
    try send_updateDeviceInfo(deviceUid: deviceUid, deviceInfo: deviceInfo)
    try outProtocol.transport.flush()
    try recv_updateDeviceInfo()
  }

  private func send_updateGroup(reqSeq: Int32, group: Group) throws {
    try outProtocol.writeMessageBegin(name: "updateGroup", type: .call, sequenceID: 0)
    let args = TalkService_updateGroup_args(reqSeq: reqSeq, group: group)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateGroup() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateGroup_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateGroup(reqSeq: Int32, group: Group) throws {
    try send_updateGroup(reqSeq: reqSeq, group: group)
    try outProtocol.transport.flush()
    try recv_updateGroup()
  }

  private func send_updateNotificationToken(type: NotificationType, token: String) throws {
    try outProtocol.writeMessageBegin(name: "updateNotificationToken", type: .call, sequenceID: 0)
    let args = TalkService_updateNotificationToken_args(type: type, token: token)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateNotificationToken() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateNotificationToken_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateNotificationToken(type: NotificationType, token: String) throws {
    try send_updateNotificationToken(type: type, token: token)
    try outProtocol.transport.flush()
    try recv_updateNotificationToken()
  }

  private func send_updateNotificationTokenWithBytes(type: NotificationType, token: Data) throws {
    try outProtocol.writeMessageBegin(name: "updateNotificationTokenWithBytes", type: .call, sequenceID: 0)
    let args = TalkService_updateNotificationTokenWithBytes_args(type: type, token: token)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateNotificationTokenWithBytes() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateNotificationTokenWithBytes_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateNotificationTokenWithBytes(type: NotificationType, token: Data) throws {
    try send_updateNotificationTokenWithBytes(type: type, token: token)
    try outProtocol.transport.flush()
    try recv_updateNotificationTokenWithBytes()
  }

  private func send_updateProfile(reqSeq: Int32, profile: Profile) throws {
    try outProtocol.writeMessageBegin(name: "updateProfile", type: .call, sequenceID: 0)
    let args = TalkService_updateProfile_args(reqSeq: reqSeq, profile: profile)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateProfile() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateProfile(reqSeq: Int32, profile: Profile) throws {
    try send_updateProfile(reqSeq: reqSeq, profile: profile)
    try outProtocol.transport.flush()
    try recv_updateProfile()
  }

  private func send_updateProfileAttribute(reqSeq: Int32, attr: ProfileAttribute, value: String) throws {
    try outProtocol.writeMessageBegin(name: "updateProfileAttribute", type: .call, sequenceID: 0)
    let args = TalkService_updateProfileAttribute_args(reqSeq: reqSeq, attr: attr, value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateProfileAttribute() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateProfileAttribute_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateProfileAttribute(reqSeq: Int32, attr: ProfileAttribute, value: String) throws {
    try send_updateProfileAttribute(reqSeq: reqSeq, attr: attr, value: value)
    try outProtocol.transport.flush()
    try recv_updateProfileAttribute()
  }

  private func send_updateRegion(region: String) throws {
    try outProtocol.writeMessageBegin(name: "updateRegion", type: .call, sequenceID: 0)
    let args = TalkService_updateRegion_args(region: region)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateRegion() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateRegion_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateRegion(region: String) throws {
    try send_updateRegion(region: region)
    try outProtocol.transport.flush()
    try recv_updateRegion()
  }

  private func send_updateSettings(reqSeq: Int32, settings: Settings) throws {
    try outProtocol.writeMessageBegin(name: "updateSettings", type: .call, sequenceID: 0)
    let args = TalkService_updateSettings_args(reqSeq: reqSeq, settings: settings)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateSettings() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateSettings_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateSettings(reqSeq: Int32, settings: Settings) throws {
    try send_updateSettings(reqSeq: reqSeq, settings: settings)
    try outProtocol.transport.flush()
    try recv_updateSettings()
  }

  private func send_updateSettings2(reqSeq: Int32, settings: Settings) throws {
    try outProtocol.writeMessageBegin(name: "updateSettings2", type: .call, sequenceID: 0)
    let args = TalkService_updateSettings2_args(reqSeq: reqSeq, settings: settings)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateSettings2() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateSettings2_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "updateSettings2"))
  }

  public func updateSettings2(reqSeq: Int32, settings: Settings) throws -> Int32 {
    try send_updateSettings2(reqSeq: reqSeq, settings: settings)
    try outProtocol.transport.flush()
    return try recv_updateSettings2()
  }

  private func send_updateSettingsAttribute(reqSeq: Int32, attr: SettingsAttribute, value: String) throws {
    try outProtocol.writeMessageBegin(name: "updateSettingsAttribute", type: .call, sequenceID: 0)
    let args = TalkService_updateSettingsAttribute_args(reqSeq: reqSeq, attr: attr, value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateSettingsAttribute() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateSettingsAttribute_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func updateSettingsAttribute(reqSeq: Int32, attr: SettingsAttribute, value: String) throws {
    try send_updateSettingsAttribute(reqSeq: reqSeq, attr: attr, value: value)
    try outProtocol.transport.flush()
    try recv_updateSettingsAttribute()
  }

  private func send_updateSettingsAttributes(reqSeq: Int32, attrBitset: Int32, settings: Settings) throws {
    try outProtocol.writeMessageBegin(name: "updateSettingsAttributes", type: .call, sequenceID: 0)
    let args = TalkService_updateSettingsAttributes_args(reqSeq: reqSeq, attrBitset: attrBitset, settings: settings)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateSettingsAttributes() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_updateSettingsAttributes_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "updateSettingsAttributes"))
  }

  public func updateSettingsAttributes(reqSeq: Int32, attrBitset: Int32, settings: Settings) throws -> Int32 {
    try send_updateSettingsAttributes(reqSeq: reqSeq, attrBitset: attrBitset, settings: settings)
    try outProtocol.transport.flush()
    return try recv_updateSettingsAttributes()
  }

  private func send_verifyIdentityCredential(identityProvider: IdentityProvider, identifier: String, password: String) throws {
    try outProtocol.writeMessageBegin(name: "verifyIdentityCredential", type: .call, sequenceID: 0)
    let args = TalkService_verifyIdentityCredential_args(identityProvider: identityProvider, identifier: identifier, password: password)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_verifyIdentityCredential() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_verifyIdentityCredential_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func verifyIdentityCredential(identityProvider: IdentityProvider, identifier: String, password: String) throws {
    try send_verifyIdentityCredential(identityProvider: identityProvider, identifier: identifier, password: password)
    try outProtocol.transport.flush()
    try recv_verifyIdentityCredential()
  }

  private func send_verifyIdentityCredentialWithResult(identityCredential: IdentityCredential) throws {
    try outProtocol.writeMessageBegin(name: "verifyIdentityCredentialWithResult", type: .call, sequenceID: 0)
    let args = TalkService_verifyIdentityCredentialWithResult_args(identityCredential: identityCredential)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_verifyIdentityCredentialWithResult() throws -> UserAuthStatus {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_verifyIdentityCredentialWithResult_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "verifyIdentityCredentialWithResult"))
  }

  public func verifyIdentityCredentialWithResult(identityCredential: IdentityCredential) throws -> UserAuthStatus {
    try send_verifyIdentityCredentialWithResult(identityCredential: identityCredential)
    try outProtocol.transport.flush()
    return try recv_verifyIdentityCredentialWithResult()
  }

  private func send_verifyPhone(sessionId: String, pinCode: String, udidHash: String) throws {
    try outProtocol.writeMessageBegin(name: "verifyPhone", type: .call, sequenceID: 0)
    let args = TalkService_verifyPhone_args(sessionId: sessionId, pinCode: pinCode, udidHash: udidHash)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_verifyPhone() throws -> VerificationResult {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_verifyPhone_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "verifyPhone"))
  }

  public func verifyPhone(sessionId: String, pinCode: String, udidHash: String) throws -> VerificationResult {
    try send_verifyPhone(sessionId: sessionId, pinCode: pinCode, udidHash: udidHash)
    try outProtocol.transport.flush()
    return try recv_verifyPhone()
  }

  private func send_verifyQrcode(verifier: String, pinCode: String) throws {
    try outProtocol.writeMessageBegin(name: "verifyQrcode", type: .call, sequenceID: 0)
    let args = TalkService_verifyQrcode_args(verifier: verifier, pinCode: pinCode)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_verifyQrcode() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TalkService_verifyQrcode_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let e = result.e {
      throw e
    }
    throw TApplicationError(error: .missingResult(methodName: "verifyQrcode"))
  }

  public func verifyQrcode(verifier: String, pinCode: String) throws -> String {
    try send_verifyQrcode(verifier: verifier, pinCode: pinCode)
    try outProtocol.transport.flush()
    return try recv_verifyQrcode()
  }

}

extension TalkServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["acceptGroupInvitation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_acceptGroupInvitation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_acceptGroupInvitation_result()
      do {
        try handler.acceptGroupInvitation(reqSeq: args.reqSeq, groupId: args.groupId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "acceptGroupInvitation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["acceptProximityMatches"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_acceptProximityMatches_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_acceptProximityMatches_result()
      do {
        try handler.acceptProximityMatches(sessionId: args.sessionId, ids: args.ids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "acceptProximityMatches", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["acquireCallRoute"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_acquireCallRoute_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_acquireCallRoute_result()
      do {
        result.success = try handler.acquireCallRoute(to: args.to)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "acquireCallRoute", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["acquireCallTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_acquireCallTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_acquireCallTicket_result()
      do {
        result.success = try handler.acquireCallTicket(to: args.to)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "acquireCallTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["acquireEncryptedAccessToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_acquireEncryptedAccessToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_acquireEncryptedAccessToken_result()
      do {
        result.success = try handler.acquireEncryptedAccessToken(featureType: args.featureType)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "acquireEncryptedAccessToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["addSnsId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_addSnsId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_addSnsId_result()
      do {
        result.success = try handler.addSnsId(snsIdType: args.snsIdType, snsAccessToken: args.snsAccessToken)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "addSnsId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["blockContact"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_blockContact_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_blockContact_result()
      do {
        try handler.blockContact(reqSeq: args.reqSeq, id: args.id)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "blockContact", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["blockRecommendation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_blockRecommendation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_blockRecommendation_result()
      do {
        try handler.blockRecommendation(reqSeq: args.reqSeq, id: args.id)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "blockRecommendation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["cancelGroupInvitation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_cancelGroupInvitation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_cancelGroupInvitation_result()
      do {
        try handler.cancelGroupInvitation(reqSeq: args.reqSeq, groupId: args.groupId, contactIds: args.contactIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "cancelGroupInvitation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["changeVerificationMethod"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_changeVerificationMethod_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_changeVerificationMethod_result()
      do {
        result.success = try handler.changeVerificationMethod(sessionId: args.sessionId, method: args.method)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "changeVerificationMethod", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["clearIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_clearIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_clearIdentityCredential_result()
      do {
        try handler.clearIdentityCredential()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "clearIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["clearMessageBox"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_clearMessageBox_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_clearMessageBox_result()
      do {
        try handler.clearMessageBox(channelId: args.channelId, messageBoxId: args.messageBoxId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "clearMessageBox", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["closeProximityMatch"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_closeProximityMatch_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_closeProximityMatch_result()
      do {
        try handler.closeProximityMatch(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "closeProximityMatch", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["commitSendMessage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_commitSendMessage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_commitSendMessage_result()
      do {
        result.success = try handler.commitSendMessage(seq: args.seq, messageId: args.messageId, receiverMids: args.receiverMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "commitSendMessage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["commitSendMessages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_commitSendMessages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_commitSendMessages_result()
      do {
        result.success = try handler.commitSendMessages(seq: args.seq, messageIds: args.messageIds, receiverMids: args.receiverMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "commitSendMessages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["commitUpdateProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_commitUpdateProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_commitUpdateProfile_result()
      do {
        result.success = try handler.commitUpdateProfile(seq: args.seq, attrs: args.attrs, receiverMids: args.receiverMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "commitUpdateProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["confirmEmail"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_confirmEmail_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_confirmEmail_result()
      do {
        try handler.confirmEmail(verifier: args.verifier, pinCode: args.pinCode)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "confirmEmail", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["createGroup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_createGroup_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_createGroup_result()
      do {
        result.success = try handler.createGroup(seq: args.seq, name: args.name, contactIds: args.contactIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "createGroup", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["createQrcodeBase64Image"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_createQrcodeBase64Image_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_createQrcodeBase64Image_result()
      do {
        result.success = try handler.createQrcodeBase64Image(url: args.url, characterSet: args.characterSet, imageSize: args.imageSize, x: args.x, y: args.y, width: args.width, height: args.height)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "createQrcodeBase64Image", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["createRoom"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_createRoom_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_createRoom_result()
      do {
        result.success = try handler.createRoom(reqSeq: args.reqSeq, contactIds: args.contactIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "createRoom", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["createSession"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_createSession_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_createSession_result()
      do {
        result.success = try handler.createSession()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "createSession", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["fetchAnnouncements"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_fetchAnnouncements_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_fetchAnnouncements_result()
      do {
        result.success = try handler.fetchAnnouncements(lastFetchedIndex: args.lastFetchedIndex)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "fetchAnnouncements", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["fetchMessages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_fetchMessages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_fetchMessages_result()
      do {
        result.success = try handler.fetchMessages(localTs: args.localTs, count: args.count)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "fetchMessages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["fetchOperations"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_fetchOperations_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_fetchOperations_result()
      do {
        result.success = try handler.fetchOperations(localRev: args.localRev, count: args.count)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "fetchOperations", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["fetchOps"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_fetchOps_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_fetchOps_result()
      do {
        result.success = try handler.fetchOps(localRev: args.localRev, count: args.count, globalRev: args.globalRev, individualRev: args.individualRev)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "fetchOps", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findAndAddContactsByEmail"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findAndAddContactsByEmail_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findAndAddContactsByEmail_result()
      do {
        result.success = try handler.findAndAddContactsByEmail(reqSeq: args.reqSeq, emails: args.emails)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findAndAddContactsByEmail", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findAndAddContactsByMid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findAndAddContactsByMid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findAndAddContactsByMid_result()
      do {
        result.success = try handler.findAndAddContactsByMid(reqSeq: args.reqSeq, mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findAndAddContactsByMid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findAndAddContactsByPhone"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findAndAddContactsByPhone_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findAndAddContactsByPhone_result()
      do {
        result.success = try handler.findAndAddContactsByPhone(reqSeq: args.reqSeq, phones: args.phones)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findAndAddContactsByPhone", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findAndAddContactsByUserid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findAndAddContactsByUserid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findAndAddContactsByUserid_result()
      do {
        result.success = try handler.findAndAddContactsByUserid(reqSeq: args.reqSeq, userid: args.userid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findAndAddContactsByUserid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findContactByUserid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findContactByUserid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findContactByUserid_result()
      do {
        result.success = try handler.findContactByUserid(userid: args.userid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findContactByUserid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findContactByUserTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findContactByUserTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findContactByUserTicket_result()
      do {
        result.success = try handler.findContactByUserTicket(ticketId: args.ticketId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findContactByUserTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findContactsByEmail"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findContactsByEmail_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findContactsByEmail_result()
      do {
        result.success = try handler.findContactsByEmail(emails: args.emails)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findContactsByEmail", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findContactsByPhone"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findContactsByPhone_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findContactsByPhone_result()
      do {
        result.success = try handler.findContactsByPhone(phones: args.phones)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findContactsByPhone", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["findSnsIdUserStatus"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_findSnsIdUserStatus_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_findSnsIdUserStatus_result()
      do {
        result.success = try handler.findSnsIdUserStatus(snsIdType: args.snsIdType, snsAccessToken: args.snsAccessToken, udidHash: args.udidHash)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "findSnsIdUserStatus", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["finishUpdateVerification"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_finishUpdateVerification_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_finishUpdateVerification_result()
      do {
        try handler.finishUpdateVerification(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "finishUpdateVerification", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["generateUserTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_generateUserTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_generateUserTicket_result()
      do {
        result.success = try handler.generateUserTicket(expirationTime: args.expirationTime, maxUseCount: args.maxUseCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "generateUserTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getAcceptedProximityMatches"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getAcceptedProximityMatches_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getAcceptedProximityMatches_result()
      do {
        result.success = try handler.getAcceptedProximityMatches(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getAcceptedProximityMatches", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getActiveBuddySubscriberIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getActiveBuddySubscriberIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getActiveBuddySubscriberIds_result()
      do {
        result.success = try handler.getActiveBuddySubscriberIds()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getActiveBuddySubscriberIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getAllContactIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getAllContactIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getAllContactIds_result()
      do {
        result.success = try handler.getAllContactIds()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getAllContactIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getAuthQrcode"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getAuthQrcode_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getAuthQrcode_result()
      do {
        result.success = try handler.getAuthQrcode(keepLoggedIn: args.keepLoggedIn, systemName: args.systemName)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getAuthQrcode", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBlockedContactIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getBlockedContactIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getBlockedContactIds_result()
      do {
        result.success = try handler.getBlockedContactIds()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBlockedContactIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBlockedContactIdsByRange"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getBlockedContactIdsByRange_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getBlockedContactIdsByRange_result()
      do {
        result.success = try handler.getBlockedContactIdsByRange(start: args.start, count: args.count)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBlockedContactIdsByRange", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBlockedRecommendationIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getBlockedRecommendationIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getBlockedRecommendationIds_result()
      do {
        result.success = try handler.getBlockedRecommendationIds()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBlockedRecommendationIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBuddyBlockerIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getBuddyBlockerIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getBuddyBlockerIds_result()
      do {
        result.success = try handler.getBuddyBlockerIds()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBuddyBlockerIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getBuddyLocation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getBuddyLocation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getBuddyLocation_result()
      do {
        result.success = try handler.getBuddyLocation(mid: args.mid, index: args.index)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getBuddyLocation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCompactContactsModifiedSince"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getCompactContactsModifiedSince_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getCompactContactsModifiedSince_result()
      do {
        result.success = try handler.getCompactContactsModifiedSince(timestamp: args.timestamp)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCompactContactsModifiedSince", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCompactGroup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getCompactGroup_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getCompactGroup_result()
      do {
        result.success = try handler.getCompactGroup(groupId: args.groupId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCompactGroup", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCompactRoom"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getCompactRoom_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getCompactRoom_result()
      do {
        result.success = try handler.getCompactRoom(roomId: args.roomId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCompactRoom", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getContact"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getContact_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getContact_result()
      do {
        result.success = try handler.getContact(id: args.id)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getContact", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getContacts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getContacts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getContacts_result()
      do {
        result.success = try handler.getContacts(ids: args.ids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getContacts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCountryWithRequestIp"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getCountryWithRequestIp_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getCountryWithRequestIp_result()
      do {
        result.success = try handler.getCountryWithRequestIp()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCountryWithRequestIp", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getFavoriteMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getFavoriteMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getFavoriteMids_result()
      do {
        result.success = try handler.getFavoriteMids()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getFavoriteMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getGroup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getGroup_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getGroup_result()
      do {
        result.success = try handler.getGroup(groupId: args.groupId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getGroup", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getGroupIdsInvited"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getGroupIdsInvited_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getGroupIdsInvited_result()
      do {
        result.success = try handler.getGroupIdsInvited()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getGroupIdsInvited", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getGroupIdsJoined"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getGroupIdsJoined_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getGroupIdsJoined_result()
      do {
        result.success = try handler.getGroupIdsJoined()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getGroupIdsJoined", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getGroups"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getGroups_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getGroups_result()
      do {
        result.success = try handler.getGroups(groupIds: args.groupIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getGroups", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getHiddenContactMids"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getHiddenContactMids_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getHiddenContactMids_result()
      do {
        result.success = try handler.getHiddenContactMids()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getHiddenContactMids", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getIdentityIdentifier"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getIdentityIdentifier_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getIdentityIdentifier_result()
      do {
        result.success = try handler.getIdentityIdentifier()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getIdentityIdentifier", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getLastAnnouncementIndex"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getLastAnnouncementIndex_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getLastAnnouncementIndex_result()
      do {
        result.success = try handler.getLastAnnouncementIndex()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getLastAnnouncementIndex", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getLastOpRevision"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getLastOpRevision_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getLastOpRevision_result()
      do {
        result.success = try handler.getLastOpRevision()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getLastOpRevision", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessageBox"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessageBox_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessageBox_result()
      do {
        result.success = try handler.getMessageBox(channelId: args.channelId, messageBoxId: args.messageBoxId, lastMessagesCount: args.lastMessagesCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessageBox", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessageBoxCompactWrapUp"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessageBoxCompactWrapUp_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessageBoxCompactWrapUp_result()
      do {
        result.success = try handler.getMessageBoxCompactWrapUp(mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessageBoxCompactWrapUp", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessageBoxCompactWrapUpList"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessageBoxCompactWrapUpList_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessageBoxCompactWrapUpList_result()
      do {
        result.success = try handler.getMessageBoxCompactWrapUpList(start: args.start, messageBoxCount: args.messageBoxCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessageBoxCompactWrapUpList", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessageBoxList"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessageBoxList_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessageBoxList_result()
      do {
        result.success = try handler.getMessageBoxList(channelId: args.channelId, lastMessagesCount: args.lastMessagesCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessageBoxList", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessageBoxListByStatus"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessageBoxListByStatus_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessageBoxListByStatus_result()
      do {
        result.success = try handler.getMessageBoxListByStatus(channelId: args.channelId, lastMessagesCount: args.lastMessagesCount, status: args.status)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessageBoxListByStatus", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessageBoxWrapUp"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessageBoxWrapUp_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessageBoxWrapUp_result()
      do {
        result.success = try handler.getMessageBoxWrapUp(mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessageBoxWrapUp", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessageBoxWrapUpList"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessageBoxWrapUpList_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessageBoxWrapUpList_result()
      do {
        result.success = try handler.getMessageBoxWrapUpList(start: args.start, messageBoxCount: args.messageBoxCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessageBoxWrapUpList", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getMessagesBySequenceNumber"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getMessagesBySequenceNumber_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getMessagesBySequenceNumber_result()
      do {
        result.success = try handler.getMessagesBySequenceNumber(channelId: args.channelId, messageBoxId: args.messageBoxId, startSeq: args.startSeq, endSeq: args.endSeq)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getMessagesBySequenceNumber", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getNextMessages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getNextMessages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getNextMessages_result()
      do {
        result.success = try handler.getNextMessages(messageBoxId: args.messageBoxId, startSeq: args.startSeq, messagesCount: args.messagesCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getNextMessages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getNotificationPolicy"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getNotificationPolicy_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getNotificationPolicy_result()
      do {
        result.success = try handler.getNotificationPolicy(carrier: args.carrier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getNotificationPolicy", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPreviousMessages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getPreviousMessages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getPreviousMessages_result()
      do {
        result.success = try handler.getPreviousMessages(messageBoxId: args.messageBoxId, endSeq: args.endSeq, messagesCount: args.messagesCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getPreviousMessages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getProfile_result()
      do {
        result.success = try handler.getProfile()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProximityMatchCandidateList"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getProximityMatchCandidateList_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getProximityMatchCandidateList_result()
      do {
        result.success = try handler.getProximityMatchCandidateList(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProximityMatchCandidateList", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getProximityMatchCandidates"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getProximityMatchCandidates_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getProximityMatchCandidates_result()
      do {
        result.success = try handler.getProximityMatchCandidates(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getProximityMatchCandidates", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getRecentMessages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getRecentMessages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getRecentMessages_result()
      do {
        result.success = try handler.getRecentMessages(messageBoxId: args.messageBoxId, messagesCount: args.messagesCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getRecentMessages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getRecommendationIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getRecommendationIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getRecommendationIds_result()
      do {
        result.success = try handler.getRecommendationIds()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getRecommendationIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getRoom"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getRoom_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getRoom_result()
      do {
        result.success = try handler.getRoom(roomId: args.roomId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getRoom", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getRSAKeyInfo"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getRSAKeyInfo_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getRSAKeyInfo_result()
      do {
        result.success = try handler.getRSAKeyInfo(provider: args.provider)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getRSAKeyInfo", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getServerTime"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getServerTime_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getServerTime_result()
      do {
        result.success = try handler.getServerTime()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getServerTime", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSessions"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getSessions_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getSessions_result()
      do {
        result.success = try handler.getSessions()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSessions", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getSettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getSettings_result()
      do {
        result.success = try handler.getSettings()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSettings", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSettingsAttributes"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getSettingsAttributes_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getSettingsAttributes_result()
      do {
        result.success = try handler.getSettingsAttributes(attrBitset: args.attrBitset)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSettingsAttributes", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getSystemConfiguration"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getSystemConfiguration_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getSystemConfiguration_result()
      do {
        result.success = try handler.getSystemConfiguration()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getSystemConfiguration", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getUserTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getUserTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getUserTicket_result()
      do {
        result.success = try handler.getUserTicket()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUserTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getWapInvitation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_getWapInvitation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_getWapInvitation_result()
      do {
        result.success = try handler.getWapInvitation(invitationHash: args.invitationHash)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getWapInvitation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["invalidateUserTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_invalidateUserTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_invalidateUserTicket_result()
      do {
        try handler.invalidateUserTicket()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "invalidateUserTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["inviteFriendsBySms"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_inviteFriendsBySms_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_inviteFriendsBySms_result()
      do {
        try handler.inviteFriendsBySms(phoneNumberList: args.phoneNumberList)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "inviteFriendsBySms", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["inviteIntoGroup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_inviteIntoGroup_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_inviteIntoGroup_result()
      do {
        try handler.inviteIntoGroup(reqSeq: args.reqSeq, groupId: args.groupId, contactIds: args.contactIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "inviteIntoGroup", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["inviteIntoRoom"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_inviteIntoRoom_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_inviteIntoRoom_result()
      do {
        try handler.inviteIntoRoom(reqSeq: args.reqSeq, roomId: args.roomId, contactIds: args.contactIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "inviteIntoRoom", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["inviteViaEmail"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_inviteViaEmail_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_inviteViaEmail_result()
      do {
        try handler.inviteViaEmail(reqSeq: args.reqSeq, email: args.email, name: args.name)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "inviteViaEmail", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["isIdentityIdentifierAvailable"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_isIdentityIdentifierAvailable_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_isIdentityIdentifierAvailable_result()
      do {
        result.success = try handler.isIdentityIdentifierAvailable(provider: args.provider, identifier: args.identifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isIdentityIdentifierAvailable", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["isUseridAvailable"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_isUseridAvailable_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_isUseridAvailable_result()
      do {
        result.success = try handler.isUseridAvailable(userid: args.userid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isUseridAvailable", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["kickoutFromGroup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_kickoutFromGroup_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_kickoutFromGroup_result()
      do {
        try handler.kickoutFromGroup(reqSeq: args.reqSeq, groupId: args.groupId, contactIds: args.contactIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "kickoutFromGroup", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["leaveGroup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_leaveGroup_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_leaveGroup_result()
      do {
        try handler.leaveGroup(reqSeq: args.reqSeq, groupId: args.groupId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "leaveGroup", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["leaveRoom"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_leaveRoom_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_leaveRoom_result()
      do {
        try handler.leaveRoom(reqSeq: args.reqSeq, roomId: args.roomId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "leaveRoom", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["loginWithIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_loginWithIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_loginWithIdentityCredential_result()
      do {
        result.success = try handler.loginWithIdentityCredential(identityProvider: args.identityProvider, identifier: args.identifier, password: args.password, keepLoggedIn: args.keepLoggedIn, accessLocation: args.accessLocation, systemName: args.systemName, certificate: args.certificate)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "loginWithIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["loginWithIdentityCredentialForCertificate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_loginWithIdentityCredentialForCertificate_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_loginWithIdentityCredentialForCertificate_result()
      do {
        result.success = try handler.loginWithIdentityCredentialForCertificate(identityProvider: args.identityProvider, identifier: args.identifier, password: args.password, keepLoggedIn: args.keepLoggedIn, accessLocation: args.accessLocation, systemName: args.systemName, certificate: args.certificate)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "loginWithIdentityCredentialForCertificate", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["loginWithVerifier"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_loginWithVerifier_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_loginWithVerifier_result()
      do {
        result.success = try handler.loginWithVerifier(verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "loginWithVerifier", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["loginWithVerifierForCerificate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_loginWithVerifierForCerificate_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_loginWithVerifierForCerificate_result()
      do {
        result.success = try handler.loginWithVerifierForCerificate(verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "loginWithVerifierForCerificate", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["loginWithVerifierForCertificate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_loginWithVerifierForCertificate_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_loginWithVerifierForCertificate_result()
      do {
        result.success = try handler.loginWithVerifierForCertificate(verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "loginWithVerifierForCertificate", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["logout"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_logout_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_logout_result()
      do {
        try handler.logout()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "logout", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["logoutSession"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_logoutSession_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_logoutSession_result()
      do {
        try handler.logoutSession(tokenKey: args.tokenKey)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "logoutSession", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["noop"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_noop_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_noop_result()
      do {
        try handler.noop()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "noop", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifiedRedirect"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_notifiedRedirect_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_notifiedRedirect_result()
      do {
        try handler.notifiedRedirect(paramMap: args.paramMap)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifiedRedirect", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyBuddyOnAir"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_notifyBuddyOnAir_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_notifyBuddyOnAir_result()
      do {
        result.success = try handler.notifyBuddyOnAir(seq: args.seq, receiverMids: args.receiverMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyBuddyOnAir", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyIndividualEvent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_notifyIndividualEvent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_notifyIndividualEvent_result()
      do {
        try handler.notifyIndividualEvent(notificationStatus: args.notificationStatus, receiverMids: args.receiverMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyIndividualEvent", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyInstalled"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_notifyInstalled_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_notifyInstalled_result()
      do {
        try handler.notifyInstalled(udidHash: args.udidHash, applicationTypeWithExtensions: args.applicationTypeWithExtensions)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyInstalled", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyRegistrationComplete"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_notifyRegistrationComplete_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_notifyRegistrationComplete_result()
      do {
        try handler.notifyRegistrationComplete(udidHash: args.udidHash, applicationTypeWithExtensions: args.applicationTypeWithExtensions)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyRegistrationComplete", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifySleep"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_notifySleep_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_notifySleep_result()
      do {
        try handler.notifySleep(lastRev: args.lastRev, badge: args.badge)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifySleep", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["notifyUpdated"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_notifyUpdated_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_notifyUpdated_result()
      do {
        try handler.notifyUpdated(lastRev: args.lastRev, deviceInfo: args.deviceInfo)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notifyUpdated", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["openProximityMatch"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_openProximityMatch_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_openProximityMatch_result()
      do {
        result.success = try handler.openProximityMatch(location: args.location)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "openProximityMatch", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerBuddyUser"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerBuddyUser_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerBuddyUser_result()
      do {
        result.success = try handler.registerBuddyUser(buddyId: args.buddyId, registrarPassword: args.registrarPassword)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerBuddyUser", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerBuddyUserid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerBuddyUserid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerBuddyUserid_result()
      do {
        try handler.registerBuddyUserid(seq: args.seq, userid: args.userid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerBuddyUserid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerDevice"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerDevice_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerDevice_result()
      do {
        result.success = try handler.registerDevice(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerDevice", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerDeviceWithIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerDeviceWithIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerDeviceWithIdentityCredential_result()
      do {
        result.success = try handler.registerDeviceWithIdentityCredential(sessionId: args.sessionId, provider: args.provider, identifier: args.identifier, verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerDeviceWithIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerDeviceWithoutPhoneNumber"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerDeviceWithoutPhoneNumber_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerDeviceWithoutPhoneNumber_result()
      do {
        result.success = try handler.registerDeviceWithoutPhoneNumber(region: args.region, udidHash: args.udidHash, deviceInfo: args.deviceInfo)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerDeviceWithoutPhoneNumber", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerDeviceWithoutPhoneNumberWithIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result()
      do {
        result.success = try handler.registerDeviceWithoutPhoneNumberWithIdentityCredential(region: args.region, udidHash: args.udidHash, deviceInfo: args.deviceInfo, provider: args.provider, identifier: args.identifier, verifier: args.verifier, mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerDeviceWithoutPhoneNumberWithIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerUserid"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerUserid_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerUserid_result()
      do {
        result.success = try handler.registerUserid(reqSeq: args.reqSeq, userid: args.userid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerUserid", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerWapDevice"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerWapDevice_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerWapDevice_result()
      do {
        result.success = try handler.registerWapDevice(invitationHash: args.invitationHash, guidHash: args.guidHash, email: args.email, deviceInfo: args.deviceInfo)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerWapDevice", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerWithExistingSnsIdAndIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerWithExistingSnsIdAndIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerWithExistingSnsIdAndIdentityCredential_result()
      do {
        result.success = try handler.registerWithExistingSnsIdAndIdentityCredential(identityCredential: args.identityCredential, region: args.region, udidHash: args.udidHash, deviceInfo: args.deviceInfo)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerWithExistingSnsIdAndIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerWithSnsId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerWithSnsId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerWithSnsId_result()
      do {
        result.success = try handler.registerWithSnsId(snsIdType: args.snsIdType, snsAccessToken: args.snsAccessToken, region: args.region, udidHash: args.udidHash, deviceInfo: args.deviceInfo, mid: args.mid)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerWithSnsId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerWithSnsIdAndIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_registerWithSnsIdAndIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_registerWithSnsIdAndIdentityCredential_result()
      do {
        result.success = try handler.registerWithSnsIdAndIdentityCredential(snsIdType: args.snsIdType, snsAccessToken: args.snsAccessToken, identityCredential: args.identityCredential, region: args.region, udidHash: args.udidHash, deviceInfo: args.deviceInfo)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerWithSnsIdAndIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reissueDeviceCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reissueDeviceCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reissueDeviceCredential_result()
      do {
        result.success = try handler.reissueDeviceCredential()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reissueDeviceCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reissueUserTicket"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reissueUserTicket_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reissueUserTicket_result()
      do {
        result.success = try handler.reissueUserTicket(expirationTime: args.expirationTime, maxUseCount: args.maxUseCount)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reissueUserTicket", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["rejectGroupInvitation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_rejectGroupInvitation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_rejectGroupInvitation_result()
      do {
        try handler.rejectGroupInvitation(reqSeq: args.reqSeq, groupId: args.groupId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "rejectGroupInvitation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["releaseSession"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_releaseSession_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_releaseSession_result()
      do {
        try handler.releaseSession()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "releaseSession", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeAllMessages"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_removeAllMessages_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_removeAllMessages_result()
      do {
        try handler.removeAllMessages(seq: args.seq, lastMessageId: args.lastMessageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeAllMessages", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeBuddyLocation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_removeBuddyLocation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_removeBuddyLocation_result()
      do {
        try handler.removeBuddyLocation(mid: args.mid, index: args.index)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeBuddyLocation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeMessage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_removeMessage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_removeMessage_result()
      do {
        result.success = try handler.removeMessage(messageId: args.messageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeMessage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeMessageFromMyHome"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_removeMessageFromMyHome_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_removeMessageFromMyHome_result()
      do {
        result.success = try handler.removeMessageFromMyHome(messageId: args.messageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeMessageFromMyHome", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["removeSnsId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_removeSnsId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_removeSnsId_result()
      do {
        result.success = try handler.removeSnsId(snsIdType: args.snsIdType)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "removeSnsId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["report"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_report_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_report_result()
      do {
        try handler.report(syncOpRevision: args.syncOpRevision, category: args.category, report: args.report)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "report", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reportContacts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reportContacts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reportContacts_result()
      do {
        result.success = try handler.reportContacts(syncOpRevision: args.syncOpRevision, category: args.category, contactReports: args.contactReports, actionType: args.actionType)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reportContacts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reportGroups"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reportGroups_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reportGroups_result()
      do {
        try handler.reportGroups(syncOpRevision: args.syncOpRevision, groups: args.groups)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reportGroups", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reportProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reportProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reportProfile_result()
      do {
        try handler.reportProfile(syncOpRevision: args.syncOpRevision, profile: args.profile)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reportProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reportRooms"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reportRooms_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reportRooms_result()
      do {
        try handler.reportRooms(syncOpRevision: args.syncOpRevision, rooms: args.rooms)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reportRooms", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reportSettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reportSettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reportSettings_result()
      do {
        try handler.reportSettings(syncOpRevision: args.syncOpRevision, settings: args.settings)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reportSettings", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["reportSpammer"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_reportSpammer_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_reportSpammer_result()
      do {
        try handler.reportSpammer(spammerMid: args.spammerMid, spammerReasons: args.spammerReasons, spamMessageIds: args.spamMessageIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reportSpammer", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["requestAccountPasswordReset"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_requestAccountPasswordReset_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_requestAccountPasswordReset_result()
      do {
        try handler.requestAccountPasswordReset(provider: args.provider, identifier: args.identifier, locale: args.locale)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "requestAccountPasswordReset", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["requestEmailConfirmation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_requestEmailConfirmation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_requestEmailConfirmation_result()
      do {
        result.success = try handler.requestEmailConfirmation(emailConfirmation: args.emailConfirmation)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "requestEmailConfirmation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["requestIdentityUnbind"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_requestIdentityUnbind_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_requestIdentityUnbind_result()
      do {
        try handler.requestIdentityUnbind(provider: args.provider, identifier: args.identifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "requestIdentityUnbind", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["resendEmailConfirmation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_resendEmailConfirmation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_resendEmailConfirmation_result()
      do {
        result.success = try handler.resendEmailConfirmation(verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "resendEmailConfirmation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["resendPinCode"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_resendPinCode_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_resendPinCode_result()
      do {
        try handler.resendPinCode(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "resendPinCode", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["resendPinCodeBySMS"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_resendPinCodeBySMS_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_resendPinCodeBySMS_result()
      do {
        try handler.resendPinCodeBySMS(sessionId: args.sessionId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "resendPinCodeBySMS", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendChatChecked"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendChatChecked_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendChatChecked_result()
      do {
        try handler.sendChatChecked(seq: args.seq, consumer: args.consumer, lastMessageId: args.lastMessageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendChatChecked", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendChatRemoved"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendChatRemoved_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendChatRemoved_result()
      do {
        try handler.sendChatRemoved(seq: args.seq, consumer: args.consumer, lastMessageId: args.lastMessageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendChatRemoved", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendContentPreviewUpdated"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendContentPreviewUpdated_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendContentPreviewUpdated_result()
      do {
        result.success = try handler.sendContentPreviewUpdated(esq: args.esq, messageId: args.messageId, receiverMids: args.receiverMids)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendContentPreviewUpdated", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendContentReceipt"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendContentReceipt_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendContentReceipt_result()
      do {
        try handler.sendContentReceipt(seq: args.seq, consumer: args.consumer, messageId: args.messageId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendContentReceipt", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendDummyPush"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendDummyPush_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendDummyPush_result()
      do {
        try handler.sendDummyPush()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendDummyPush", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendEvent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendEvent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendEvent_result()
      do {
        result.success = try handler.sendEvent(seq: args.seq, message: args.message)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendEvent", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendMessage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendMessage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendMessage_result()
      do {
        result.success = try handler.sendMessage(seq: args.seq, message: args.message)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMessage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendMessageIgnored"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendMessageIgnored_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendMessageIgnored_result()
      do {
        try handler.sendMessageIgnored(seq: args.seq, consumer: args.consumer, messageIds: args.messageIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMessageIgnored", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendMessageReceipt"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendMessageReceipt_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendMessageReceipt_result()
      do {
        try handler.sendMessageReceipt(seq: args.seq, consumer: args.consumer, messageIds: args.messageIds)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMessageReceipt", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendMessageToMyHome"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_sendMessageToMyHome_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_sendMessageToMyHome_result()
      do {
        result.success = try handler.sendMessageToMyHome(seq: args.seq, message: args.message)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMessageToMyHome", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["setBuddyLocation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_setBuddyLocation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_setBuddyLocation_result()
      do {
        try handler.setBuddyLocation(mid: args.mid, index: args.index, location: args.location)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "setBuddyLocation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["setIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_setIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_setIdentityCredential_result()
      do {
        try handler.setIdentityCredential(provider: args.provider, identifier: args.identifier, verifier: args.verifier)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "setIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["setNotificationsEnabled"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_setNotificationsEnabled_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_setNotificationsEnabled_result()
      do {
        try handler.setNotificationsEnabled(reqSeq: args.reqSeq, type: args.type, target: args.target, enablement: args.enablement)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "setNotificationsEnabled", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["startUpdateVerification"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_startUpdateVerification_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_startUpdateVerification_result()
      do {
        result.success = try handler.startUpdateVerification(region: args.region, carrier: args.carrier, phone: args.phone, udidHash: args.udidHash, deviceInfo: args.deviceInfo, networkCode: args.networkCode, locale: args.locale)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "startUpdateVerification", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["startVerification"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_startVerification_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_startVerification_result()
      do {
        result.success = try handler.startVerification(region: args.region, carrier: args.carrier, phone: args.phone, udidHash: args.udidHash, deviceInfo: args.deviceInfo, networkCode: args.networkCode, mid: args.mid, locale: args.locale)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "startVerification", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["storeUpdateProfileAttribute"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_storeUpdateProfileAttribute_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_storeUpdateProfileAttribute_result()
      do {
        try handler.storeUpdateProfileAttribute(seq: args.seq, profileAttribute: args.profileAttribute, value: args.value)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "storeUpdateProfileAttribute", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["syncContactBySnsIds"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_syncContactBySnsIds_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_syncContactBySnsIds_result()
      do {
        result.success = try handler.syncContactBySnsIds(reqSeq: args.reqSeq, modifications: args.modifications)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "syncContactBySnsIds", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["syncContacts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_syncContacts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_syncContacts_result()
      do {
        result.success = try handler.syncContacts(reqSeq: args.reqSeq, localContacts: args.localContacts)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "syncContacts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["trySendMessage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_trySendMessage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_trySendMessage_result()
      do {
        result.success = try handler.trySendMessage(seq: args.seq, message: args.message)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "trySendMessage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unblockContact"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_unblockContact_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_unblockContact_result()
      do {
        try handler.unblockContact(reqSeq: args.reqSeq, id: args.id)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unblockContact", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unblockRecommendation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_unblockRecommendation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_unblockRecommendation_result()
      do {
        try handler.unblockRecommendation(reqSeq: args.reqSeq, id: args.id)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unblockRecommendation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unregisterUserAndDevice"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_unregisterUserAndDevice_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_unregisterUserAndDevice_result()
      do {
        result.success = try handler.unregisterUserAndDevice()
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unregisterUserAndDevice", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateApnsDeviceToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateApnsDeviceToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateApnsDeviceToken_result()
      do {
        try handler.updateApnsDeviceToken(apnsDeviceToken: args.apnsDeviceToken)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateApnsDeviceToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateBuddySetting"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateBuddySetting_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateBuddySetting_result()
      do {
        try handler.updateBuddySetting(key: args.key, value: args.value)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateBuddySetting", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateC2DMRegistrationId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateC2DMRegistrationId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateC2DMRegistrationId_result()
      do {
        try handler.updateC2DMRegistrationId(registrationId: args.registrationId)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateC2DMRegistrationId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateContactSetting"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateContactSetting_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateContactSetting_result()
      do {
        try handler.updateContactSetting(reqSeq: args.reqSeq, mid: args.mid, flag: args.flag, value: args.value)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateContactSetting", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateCustomModeSettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateCustomModeSettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateCustomModeSettings_result()
      do {
        try handler.updateCustomModeSettings(customMode: args.customMode, paramMap: args.paramMap)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateCustomModeSettings", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateDeviceInfo"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateDeviceInfo_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateDeviceInfo_result()
      do {
        try handler.updateDeviceInfo(deviceUid: args.deviceUid, deviceInfo: args.deviceInfo)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateDeviceInfo", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateGroup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateGroup_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateGroup_result()
      do {
        try handler.updateGroup(reqSeq: args.reqSeq, group: args.group)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateGroup", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateNotificationToken"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateNotificationToken_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateNotificationToken_result()
      do {
        try handler.updateNotificationToken(type: args.type, token: args.token)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateNotificationToken", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateNotificationTokenWithBytes"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateNotificationTokenWithBytes_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateNotificationTokenWithBytes_result()
      do {
        try handler.updateNotificationTokenWithBytes(type: args.type, token: args.token)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateNotificationTokenWithBytes", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateProfile_result()
      do {
        try handler.updateProfile(reqSeq: args.reqSeq, profile: args.profile)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateProfileAttribute"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateProfileAttribute_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateProfileAttribute_result()
      do {
        try handler.updateProfileAttribute(reqSeq: args.reqSeq, attr: args.attr, value: args.value)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateProfileAttribute", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateRegion"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateRegion_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateRegion_result()
      do {
        try handler.updateRegion(region: args.region)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateRegion", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateSettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateSettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateSettings_result()
      do {
        try handler.updateSettings(reqSeq: args.reqSeq, settings: args.settings)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateSettings", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateSettings2"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateSettings2_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateSettings2_result()
      do {
        result.success = try handler.updateSettings2(reqSeq: args.reqSeq, settings: args.settings)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateSettings2", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateSettingsAttribute"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateSettingsAttribute_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateSettingsAttribute_result()
      do {
        try handler.updateSettingsAttribute(reqSeq: args.reqSeq, attr: args.attr, value: args.value)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateSettingsAttribute", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateSettingsAttributes"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_updateSettingsAttributes_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_updateSettingsAttributes_result()
      do {
        result.success = try handler.updateSettingsAttributes(reqSeq: args.reqSeq, attrBitset: args.attrBitset, settings: args.settings)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateSettingsAttributes", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["verifyIdentityCredential"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_verifyIdentityCredential_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_verifyIdentityCredential_result()
      do {
        try handler.verifyIdentityCredential(identityProvider: args.identityProvider, identifier: args.identifier, password: args.password)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "verifyIdentityCredential", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["verifyIdentityCredentialWithResult"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_verifyIdentityCredentialWithResult_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_verifyIdentityCredentialWithResult_result()
      do {
        result.success = try handler.verifyIdentityCredentialWithResult(identityCredential: args.identityCredential)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "verifyIdentityCredentialWithResult", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["verifyPhone"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_verifyPhone_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_verifyPhone_result()
      do {
        result.success = try handler.verifyPhone(sessionId: args.sessionId, pinCode: args.pinCode, udidHash: args.udidHash)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "verifyPhone", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["verifyQrcode"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TalkService_verifyQrcode_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TalkService_verifyQrcode_result()
      do {
        result.success = try handler.verifyQrcode(verifier: args.verifier, pinCode: args.pinCode)
      }
      catch let error as TalkException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "verifyQrcode", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = TalkServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class UniversalNotificationService_notify_args {

  fileprivate var event: GlobalEvent


  fileprivate init(event: GlobalEvent) {
    self.event = event
  }

}

fileprivate func ==(lhs: UniversalNotificationService_notify_args, rhs: UniversalNotificationService_notify_args) -> Bool {
  return
    (lhs.event == rhs.event)
}

extension UniversalNotificationService_notify_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (event.hashValue)
    return result
  }

}

extension UniversalNotificationService_notify_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["event": 2, ]
  }

  fileprivate static var structName: String { return "UniversalNotificationService_notify_args" }

  fileprivate static func read(from proto: TProtocol) throws -> UniversalNotificationService_notify_args {
    _ = try proto.readStructBegin()
    var event: GlobalEvent!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (2, .struct):           event = try GlobalEvent.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(event, named: "event")

    return UniversalNotificationService_notify_args(event: event)
  }

}



fileprivate final class UniversalNotificationService_notify_result {

  fileprivate var e: UniversalNotificationServiceException?


  fileprivate init() { }
  fileprivate init(e: UniversalNotificationServiceException?) {
    self.e = e
  }

}

fileprivate func ==(lhs: UniversalNotificationService_notify_result, rhs: UniversalNotificationService_notify_result) -> Bool {
  return
    (lhs.e == rhs.e)
}

extension UniversalNotificationService_notify_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (e?.hashValue ?? 0)
    return result
  }

}

extension UniversalNotificationService_notify_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["e": 1, ]
  }

  fileprivate static var structName: String { return "UniversalNotificationService_notify_result" }

  fileprivate static func read(from proto: TProtocol) throws -> UniversalNotificationService_notify_result {
    _ = try proto.readStructBegin()
    var e: UniversalNotificationServiceException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           e = try UniversalNotificationServiceException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return UniversalNotificationService_notify_result(e: e)
  }

}



extension UniversalNotificationServiceClient : UniversalNotificationService {

  private func send_notify(event: GlobalEvent) throws {
    try outProtocol.writeMessageBegin(name: "notify", type: .call, sequenceID: 0)
    let args = UniversalNotificationService_notify_args(event: event)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_notify() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try UniversalNotificationService_notify_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let e = result.e {
      throw e
    }
  }

  public func notify(event: GlobalEvent) throws {
    try send_notify(event: event)
    try outProtocol.transport.flush()
    try recv_notify()
  }

}

extension UniversalNotificationServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["notify"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try UniversalNotificationService_notify_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = UniversalNotificationService_notify_result()
      do {
        try handler.notify(event: args.event)
      }
      catch let error as UniversalNotificationServiceException { result.e = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "notify", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = UniversalNotificationServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

