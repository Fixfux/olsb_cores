/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public enum ApplicationType : TEnum {
  case ios
  case ios_rc
  case ios_beta
  case ios_alpha
  case android
  case android_rc
  case android_beta
  case android_alpha
  case wap
  case wap_rc
  case wap_beta
  case wap_alpha
  case bot
  case bot_rc
  case bot_beta
  case bot_alpha
  case web
  case web_rc
  case web_beta
  case web_alpha
  case desktopwin
  case desktopwin_rc
  case desktopwin_beta
  case desktopwin_alpha
  case desktopmac
  case desktopmac_rc
  case desktopmac_beta
  case desktopmac_alpha
  case channelgw
  case channelgw_rc
  case channelgw_beta
  case channelgw_alpha
  case channelcp
  case channelcp_rc
  case channelcp_beta
  case channelcp_alpha
  case winphone
  case winphone_rc
  case winphone_beta
  case winphone_alpha
  case blackberry
  case blackberry_rc
  case blackberry_beta
  case blackberry_alpha
  case winmetro
  case winmetro_rc
  case winmetro_beta
  case winmetro_alpha
  case s40
  case s40_rc
  case s40_beta
  case s40_alpha
  case chrono
  case chrono_rc
  case chrono_beta
  case chrono_alpha
  case tizen
  case tizen_rc
  case tizen_beta
  case tizen_alpha
  case virtual

  public static func read(from proto: TProtocol) throws -> ApplicationType {
    let raw: Int32 = try proto.read()
    let new = ApplicationType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ApplicationType.self)")
    }
  }

  public init() {
    self = .ios
  }

  public var rawValue: Int32 {
    switch self {
    case .ios: return 16
    case .ios_rc: return 17
    case .ios_beta: return 18
    case .ios_alpha: return 19
    case .android: return 32
    case .android_rc: return 33
    case .android_beta: return 34
    case .android_alpha: return 35
    case .wap: return 48
    case .wap_rc: return 49
    case .wap_beta: return 50
    case .wap_alpha: return 51
    case .bot: return 64
    case .bot_rc: return 65
    case .bot_beta: return 66
    case .bot_alpha: return 67
    case .web: return 80
    case .web_rc: return 81
    case .web_beta: return 82
    case .web_alpha: return 83
    case .desktopwin: return 96
    case .desktopwin_rc: return 97
    case .desktopwin_beta: return 98
    case .desktopwin_alpha: return 99
    case .desktopmac: return 112
    case .desktopmac_rc: return 113
    case .desktopmac_beta: return 114
    case .desktopmac_alpha: return 115
    case .channelgw: return 128
    case .channelgw_rc: return 129
    case .channelgw_beta: return 130
    case .channelgw_alpha: return 131
    case .channelcp: return 144
    case .channelcp_rc: return 145
    case .channelcp_beta: return 146
    case .channelcp_alpha: return 147
    case .winphone: return 160
    case .winphone_rc: return 161
    case .winphone_beta: return 162
    case .winphone_alpha: return 163
    case .blackberry: return 176
    case .blackberry_rc: return 177
    case .blackberry_beta: return 178
    case .blackberry_alpha: return 179
    case .winmetro: return 192
    case .winmetro_rc: return 193
    case .winmetro_beta: return 194
    case .winmetro_alpha: return 195
    case .s40: return 208
    case .s40_rc: return 209
    case .s40_beta: return 210
    case .s40_alpha: return 211
    case .chrono: return 224
    case .chrono_rc: return 225
    case .chrono_beta: return 226
    case .chrono_alpha: return 227
    case .tizen: return 256
    case .tizen_rc: return 257
    case .tizen_beta: return 258
    case .tizen_alpha: return 259
    case .virtual: return 272
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 16: self = .ios
    case 17: self = .ios_rc
    case 18: self = .ios_beta
    case 19: self = .ios_alpha
    case 32: self = .android
    case 33: self = .android_rc
    case 34: self = .android_beta
    case 35: self = .android_alpha
    case 48: self = .wap
    case 49: self = .wap_rc
    case 50: self = .wap_beta
    case 51: self = .wap_alpha
    case 64: self = .bot
    case 65: self = .bot_rc
    case 66: self = .bot_beta
    case 67: self = .bot_alpha
    case 80: self = .web
    case 81: self = .web_rc
    case 82: self = .web_beta
    case 83: self = .web_alpha
    case 96: self = .desktopwin
    case 97: self = .desktopwin_rc
    case 98: self = .desktopwin_beta
    case 99: self = .desktopwin_alpha
    case 112: self = .desktopmac
    case 113: self = .desktopmac_rc
    case 114: self = .desktopmac_beta
    case 115: self = .desktopmac_alpha
    case 128: self = .channelgw
    case 129: self = .channelgw_rc
    case 130: self = .channelgw_beta
    case 131: self = .channelgw_alpha
    case 144: self = .channelcp
    case 145: self = .channelcp_rc
    case 146: self = .channelcp_beta
    case 147: self = .channelcp_alpha
    case 160: self = .winphone
    case 161: self = .winphone_rc
    case 162: self = .winphone_beta
    case 163: self = .winphone_alpha
    case 176: self = .blackberry
    case 177: self = .blackberry_rc
    case 178: self = .blackberry_beta
    case 179: self = .blackberry_alpha
    case 192: self = .winmetro
    case 193: self = .winmetro_rc
    case 194: self = .winmetro_beta
    case 195: self = .winmetro_alpha
    case 208: self = .s40
    case 209: self = .s40_rc
    case 210: self = .s40_beta
    case 211: self = .s40_alpha
    case 224: self = .chrono
    case 225: self = .chrono_rc
    case 226: self = .chrono_beta
    case 227: self = .chrono_alpha
    case 256: self = .tizen
    case 257: self = .tizen_rc
    case 258: self = .tizen_beta
    case 259: self = .tizen_alpha
    case 272: self = .virtual
    default: return nil
    }
  }
}

public enum BuddyBannerLinkType : TEnum {
  case buddy_banner_link_hidden
  case buddy_banner_link_mid
  case buddy_banner_link_url

  public static func read(from proto: TProtocol) throws -> BuddyBannerLinkType {
    let raw: Int32 = try proto.read()
    let new = BuddyBannerLinkType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(BuddyBannerLinkType.self)")
    }
  }

  public init() {
    self = .buddy_banner_link_hidden
  }

  public var rawValue: Int32 {
    switch self {
    case .buddy_banner_link_hidden: return 0
    case .buddy_banner_link_mid: return 1
    case .buddy_banner_link_url: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .buddy_banner_link_hidden
    case 1: self = .buddy_banner_link_mid
    case 2: self = .buddy_banner_link_url
    default: return nil
    }
  }
}

public enum BuddyOnAirType : TEnum {
  case normal
  case live
  case voip

  public static func read(from proto: TProtocol) throws -> BuddyOnAirType {
    let raw: Int32 = try proto.read()
    let new = BuddyOnAirType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(BuddyOnAirType.self)")
    }
  }

  public init() {
    self = .normal
  }

  public var rawValue: Int32 {
    switch self {
    case .normal: return 0
    case .live: return 1
    case .voip: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .live
    case 2: self = .voip
    default: return nil
    }
  }
}

public enum BuddyResultState : TEnum {
  case accepted
  case succeeded
  case failed
  case cancelled
  case notify_failed
  case storing
  case uploading
  case notifying

  public static func read(from proto: TProtocol) throws -> BuddyResultState {
    let raw: Int32 = try proto.read()
    let new = BuddyResultState(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(BuddyResultState.self)")
    }
  }

  public init() {
    self = .accepted
  }

  public var rawValue: Int32 {
    switch self {
    case .accepted: return 1
    case .succeeded: return 2
    case .failed: return 3
    case .cancelled: return 4
    case .notify_failed: return 5
    case .storing: return 11
    case .uploading: return 21
    case .notifying: return 31
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .accepted
    case 2: self = .succeeded
    case 3: self = .failed
    case 4: self = .cancelled
    case 5: self = .notify_failed
    case 11: self = .storing
    case 21: self = .uploading
    case 31: self = .notifying
    default: return nil
    }
  }
}

public enum BuddySearchRequestSource : TEnum {
  case na
  case friend_view
  case official_account_view

  public static func read(from proto: TProtocol) throws -> BuddySearchRequestSource {
    let raw: Int32 = try proto.read()
    let new = BuddySearchRequestSource(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(BuddySearchRequestSource.self)")
    }
  }

  public init() {
    self = .na
  }

  public var rawValue: Int32 {
    switch self {
    case .na: return 0
    case .friend_view: return 1
    case .official_account_view: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .na
    case 1: self = .friend_view
    case 2: self = .official_account_view
    default: return nil
    }
  }
}

public enum CarrierCode : TEnum {
  case not_specified
  case jp_docomo
  case jp_au
  case jp_softbank
  case kr_skt
  case kr_kt
  case kr_lgt

  public static func read(from proto: TProtocol) throws -> CarrierCode {
    let raw: Int32 = try proto.read()
    let new = CarrierCode(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(CarrierCode.self)")
    }
  }

  public init() {
    self = .not_specified
  }

  public var rawValue: Int32 {
    switch self {
    case .not_specified: return 0
    case .jp_docomo: return 1
    case .jp_au: return 2
    case .jp_softbank: return 3
    case .kr_skt: return 17
    case .kr_kt: return 18
    case .kr_lgt: return 19
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .not_specified
    case 1: self = .jp_docomo
    case 2: self = .jp_au
    case 3: self = .jp_softbank
    case 17: self = .kr_skt
    case 18: self = .kr_kt
    case 19: self = .kr_lgt
    default: return nil
    }
  }
}

public enum ChannelConfiguration : TEnum {
  case message
  case message_notification
  case notification_center

  public static func read(from proto: TProtocol) throws -> ChannelConfiguration {
    let raw: Int32 = try proto.read()
    let new = ChannelConfiguration(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ChannelConfiguration.self)")
    }
  }

  public init() {
    self = .message
  }

  public var rawValue: Int32 {
    switch self {
    case .message: return 0
    case .message_notification: return 1
    case .notification_center: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .message
    case 1: self = .message_notification
    case 2: self = .notification_center
    default: return nil
    }
  }
}

public enum ChannelErrorCode : TEnum {
  case illegal_argument
  case internal_error
  case connection_error
  case authenticationi_failed
  case need_permission_approval
  case coin_not_usable

  public static func read(from proto: TProtocol) throws -> ChannelErrorCode {
    let raw: Int32 = try proto.read()
    let new = ChannelErrorCode(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ChannelErrorCode.self)")
    }
  }

  public init() {
    self = .illegal_argument
  }

  public var rawValue: Int32 {
    switch self {
    case .illegal_argument: return 0
    case .internal_error: return 1
    case .connection_error: return 2
    case .authenticationi_failed: return 3
    case .need_permission_approval: return 4
    case .coin_not_usable: return 5
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .illegal_argument
    case 1: self = .internal_error
    case 2: self = .connection_error
    case 3: self = .authenticationi_failed
    case 4: self = .need_permission_approval
    case 5: self = .coin_not_usable
    default: return nil
    }
  }
}

public enum ChannelSyncType : TEnum {
  case sync
  case remove

  public static func read(from proto: TProtocol) throws -> ChannelSyncType {
    let raw: Int32 = try proto.read()
    let new = ChannelSyncType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ChannelSyncType.self)")
    }
  }

  public init() {
    self = .sync
  }

  public var rawValue: Int32 {
    switch self {
    case .sync: return 0
    case .remove: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .sync
    case 1: self = .remove
    default: return nil
    }
  }
}

public enum ContactAttribute : TEnum {
  case contact_attribute_capable_voice_call
  case contact_attribute_capable_video_call
  case contact_attribute_capable_my_home
  case contact_attribute_capable_buddy

  public static func read(from proto: TProtocol) throws -> ContactAttribute {
    let raw: Int32 = try proto.read()
    let new = ContactAttribute(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ContactAttribute.self)")
    }
  }

  public init() {
    self = .contact_attribute_capable_voice_call
  }

  public var rawValue: Int32 {
    switch self {
    case .contact_attribute_capable_voice_call: return 1
    case .contact_attribute_capable_video_call: return 2
    case .contact_attribute_capable_my_home: return 16
    case .contact_attribute_capable_buddy: return 32
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .contact_attribute_capable_voice_call
    case 2: self = .contact_attribute_capable_video_call
    case 16: self = .contact_attribute_capable_my_home
    case 32: self = .contact_attribute_capable_buddy
    default: return nil
    }
  }
}

public enum ContactCategory : TEnum {
  case normal
  case recommend

  public static func read(from proto: TProtocol) throws -> ContactCategory {
    let raw: Int32 = try proto.read()
    let new = ContactCategory(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ContactCategory.self)")
    }
  }

  public init() {
    self = .normal
  }

  public var rawValue: Int32 {
    switch self {
    case .normal: return 0
    case .recommend: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .recommend
    default: return nil
    }
  }
}

public enum ContactRelation : TEnum {
  case oneway
  case both
  case not_registered

  public static func read(from proto: TProtocol) throws -> ContactRelation {
    let raw: Int32 = try proto.read()
    let new = ContactRelation(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ContactRelation.self)")
    }
  }

  public init() {
    self = .oneway
  }

  public var rawValue: Int32 {
    switch self {
    case .oneway: return 0
    case .both: return 1
    case .not_registered: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .oneway
    case 1: self = .both
    case 2: self = .not_registered
    default: return nil
    }
  }
}

public enum ContactSetting : TEnum {
  case contact_setting_notification_disable
  case contact_setting_display_name_override
  case contact_setting_contact_hide
  case contact_setting_favorite
  case contact_setting_delete

  public static func read(from proto: TProtocol) throws -> ContactSetting {
    let raw: Int32 = try proto.read()
    let new = ContactSetting(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ContactSetting.self)")
    }
  }

  public init() {
    self = .contact_setting_notification_disable
  }

  public var rawValue: Int32 {
    switch self {
    case .contact_setting_notification_disable: return 1
    case .contact_setting_display_name_override: return 2
    case .contact_setting_contact_hide: return 4
    case .contact_setting_favorite: return 8
    case .contact_setting_delete: return 16
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .contact_setting_notification_disable
    case 2: self = .contact_setting_display_name_override
    case 4: self = .contact_setting_contact_hide
    case 8: self = .contact_setting_favorite
    case 16: self = .contact_setting_delete
    default: return nil
    }
  }
}

public enum ContactStatus : TEnum {
  case unspecified
  case friend
  case friend_blocked
  case recommend
  case recommend_blocked
  case deleted
  case deleted_blocked

  public static func read(from proto: TProtocol) throws -> ContactStatus {
    let raw: Int32 = try proto.read()
    let new = ContactStatus(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ContactStatus.self)")
    }
  }

  public init() {
    self = .unspecified
  }

  public var rawValue: Int32 {
    switch self {
    case .unspecified: return 0
    case .friend: return 1
    case .friend_blocked: return 2
    case .recommend: return 3
    case .recommend_blocked: return 4
    case .deleted: return 5
    case .deleted_blocked: return 6
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .friend
    case 2: self = .friend_blocked
    case 3: self = .recommend
    case 4: self = .recommend_blocked
    case 5: self = .deleted
    case 6: self = .deleted_blocked
    default: return nil
    }
  }
}

public enum ContactType : TEnum {
  case mid
  case phone
  case email
  case userid
  case proximity
  case group
  case user
  case qrcode
  case promotion_bot
  case repair
  case facebook
  case sina
  case renren
  case feixin

  public static func read(from proto: TProtocol) throws -> ContactType {
    let raw: Int32 = try proto.read()
    let new = ContactType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ContactType.self)")
    }
  }

  public init() {
    self = .mid
  }

  public var rawValue: Int32 {
    switch self {
    case .mid: return 0
    case .phone: return 1
    case .email: return 2
    case .userid: return 3
    case .proximity: return 4
    case .group: return 5
    case .user: return 6
    case .qrcode: return 7
    case .promotion_bot: return 8
    case .repair: return 128
    case .facebook: return 2305
    case .sina: return 2306
    case .renren: return 2307
    case .feixin: return 2308
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .mid
    case 1: self = .phone
    case 2: self = .email
    case 3: self = .userid
    case 4: self = .proximity
    case 5: self = .group
    case 6: self = .user
    case 7: self = .qrcode
    case 8: self = .promotion_bot
    case 128: self = .repair
    case 2305: self = .facebook
    case 2306: self = .sina
    case 2307: self = .renren
    case 2308: self = .feixin
    default: return nil
    }
  }
}

public enum ContentType : TEnum {
  case `none`
  case image
  case video
  case audio
  case html
  case pdf
  case call
  case sticker
  case presence
  case gift
  case groupboard
  case applink
  case link
  case contact
  case file
  case location
  case postnotification
  case rich
  case chatevent

  public static func read(from proto: TProtocol) throws -> ContentType {
    let raw: Int32 = try proto.read()
    let new = ContentType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ContentType.self)")
    }
  }

  public init() {
    self = .none
  }

  public var rawValue: Int32 {
    switch self {
    case .`none`: return 0
    case .image: return 1
    case .video: return 2
    case .audio: return 3
    case .html: return 4
    case .pdf: return 5
    case .call: return 6
    case .sticker: return 7
    case .presence: return 8
    case .gift: return 9
    case .groupboard: return 10
    case .applink: return 11
    case .link: return 12
    case .contact: return 13
    case .file: return 14
    case .location: return 15
    case .postnotification: return 16
    case .rich: return 17
    case .chatevent: return 18
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .`none`
    case 1: self = .image
    case 2: self = .video
    case 3: self = .audio
    case 4: self = .html
    case 5: self = .pdf
    case 6: self = .call
    case 7: self = .sticker
    case 8: self = .presence
    case 9: self = .gift
    case 10: self = .groupboard
    case 11: self = .applink
    case 12: self = .link
    case 13: self = .contact
    case 14: self = .file
    case 15: self = .location
    case 16: self = .postnotification
    case 17: self = .rich
    case 18: self = .chatevent
    default: return nil
    }
  }
}

public enum CustomMode : TEnum {
  case promotion_friends_invite
  case capability_server_side_sms
  case line_client_analytics_configuration

  public static func read(from proto: TProtocol) throws -> CustomMode {
    let raw: Int32 = try proto.read()
    let new = CustomMode(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(CustomMode.self)")
    }
  }

  public init() {
    self = .promotion_friends_invite
  }

  public var rawValue: Int32 {
    switch self {
    case .promotion_friends_invite: return 1
    case .capability_server_side_sms: return 2
    case .line_client_analytics_configuration: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .promotion_friends_invite
    case 2: self = .capability_server_side_sms
    case 3: self = .line_client_analytics_configuration
    default: return nil
    }
  }
}

public enum EmailConfirmationStatus : TEnum {
  case not_specified
  case not_yet
  case done

  public static func read(from proto: TProtocol) throws -> EmailConfirmationStatus {
    let raw: Int32 = try proto.read()
    let new = EmailConfirmationStatus(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(EmailConfirmationStatus.self)")
    }
  }

  public init() {
    self = .not_specified
  }

  public var rawValue: Int32 {
    switch self {
    case .not_specified: return 0
    case .not_yet: return 1
    case .done: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .not_specified
    case 1: self = .not_yet
    case 3: self = .done
    default: return nil
    }
  }
}

public enum EmailConfirmationType : TEnum {
  case server_side_email
  case client_side_email

  public static func read(from proto: TProtocol) throws -> EmailConfirmationType {
    let raw: Int32 = try proto.read()
    let new = EmailConfirmationType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(EmailConfirmationType.self)")
    }
  }

  public init() {
    self = .server_side_email
  }

  public var rawValue: Int32 {
    switch self {
    case .server_side_email: return 0
    case .client_side_email: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .server_side_email
    case 1: self = .client_side_email
    default: return nil
    }
  }
}

public enum ErrorCode : TEnum {
  case illegal_argument
  case authentication_failed
  case db_failed
  case invalid_state
  case excessive_access
  case not_found
  case invalid_length
  case not_available_user
  case not_authorized_device
  case invalid_mid
  case not_a_member
  case incompatible_app_version
  case not_ready
  case not_available_session
  case not_authorized_session
  case system_error
  case no_available_verification_method
  case not_authenticated
  case invalid_identity_credential
  case not_available_identity_identifier
  case internal_error
  case no_such_identity_idenfier
  case deactivated_account_bound_to_this_identity
  case illegal_identity_credential
  case unknown_channel
  case no_such_message_box
  case not_available_message_box
  case channel_does_not_match
  case not_your_message
  case message_defined_error
  case user_cannot_accept_presents
  case user_not_sticker_owner
  case maintenance_error
  case account_not_matched
  case abuse_block
  case not_friend
  case not_allowed_call
  case block_friend
  case incompatible_voip_version
  case invalid_sns_access_token
  case external_service_not_available
  case not_allowed_add_contact
  case not_certificated
  case not_allowed_secondary_device
  case invalid_pin_code
  case not_found_identity_credential
  case exceed_file_max_size
  case exceed_daily_quota
  case not_support_send_file
  case must_upgrade
  case not_available_pin_code_session

  public static func read(from proto: TProtocol) throws -> ErrorCode {
    let raw: Int32 = try proto.read()
    let new = ErrorCode(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ErrorCode.self)")
    }
  }

  public init() {
    self = .illegal_argument
  }

  public var rawValue: Int32 {
    switch self {
    case .illegal_argument: return 0
    case .authentication_failed: return 1
    case .db_failed: return 2
    case .invalid_state: return 3
    case .excessive_access: return 4
    case .not_found: return 5
    case .invalid_length: return 6
    case .not_available_user: return 7
    case .not_authorized_device: return 8
    case .invalid_mid: return 9
    case .not_a_member: return 10
    case .incompatible_app_version: return 11
    case .not_ready: return 12
    case .not_available_session: return 13
    case .not_authorized_session: return 14
    case .system_error: return 15
    case .no_available_verification_method: return 16
    case .not_authenticated: return 17
    case .invalid_identity_credential: return 18
    case .not_available_identity_identifier: return 19
    case .internal_error: return 20
    case .no_such_identity_idenfier: return 21
    case .deactivated_account_bound_to_this_identity: return 22
    case .illegal_identity_credential: return 23
    case .unknown_channel: return 24
    case .no_such_message_box: return 25
    case .not_available_message_box: return 26
    case .channel_does_not_match: return 27
    case .not_your_message: return 28
    case .message_defined_error: return 29
    case .user_cannot_accept_presents: return 30
    case .user_not_sticker_owner: return 32
    case .maintenance_error: return 33
    case .account_not_matched: return 34
    case .abuse_block: return 35
    case .not_friend: return 36
    case .not_allowed_call: return 37
    case .block_friend: return 38
    case .incompatible_voip_version: return 39
    case .invalid_sns_access_token: return 40
    case .external_service_not_available: return 41
    case .not_allowed_add_contact: return 42
    case .not_certificated: return 43
    case .not_allowed_secondary_device: return 44
    case .invalid_pin_code: return 45
    case .not_found_identity_credential: return 46
    case .exceed_file_max_size: return 47
    case .exceed_daily_quota: return 48
    case .not_support_send_file: return 49
    case .must_upgrade: return 50
    case .not_available_pin_code_session: return 51
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .illegal_argument
    case 1: self = .authentication_failed
    case 2: self = .db_failed
    case 3: self = .invalid_state
    case 4: self = .excessive_access
    case 5: self = .not_found
    case 6: self = .invalid_length
    case 7: self = .not_available_user
    case 8: self = .not_authorized_device
    case 9: self = .invalid_mid
    case 10: self = .not_a_member
    case 11: self = .incompatible_app_version
    case 12: self = .not_ready
    case 13: self = .not_available_session
    case 14: self = .not_authorized_session
    case 15: self = .system_error
    case 16: self = .no_available_verification_method
    case 17: self = .not_authenticated
    case 18: self = .invalid_identity_credential
    case 19: self = .not_available_identity_identifier
    case 20: self = .internal_error
    case 21: self = .no_such_identity_idenfier
    case 22: self = .deactivated_account_bound_to_this_identity
    case 23: self = .illegal_identity_credential
    case 24: self = .unknown_channel
    case 25: self = .no_such_message_box
    case 26: self = .not_available_message_box
    case 27: self = .channel_does_not_match
    case 28: self = .not_your_message
    case 29: self = .message_defined_error
    case 30: self = .user_cannot_accept_presents
    case 32: self = .user_not_sticker_owner
    case 33: self = .maintenance_error
    case 34: self = .account_not_matched
    case 35: self = .abuse_block
    case 36: self = .not_friend
    case 37: self = .not_allowed_call
    case 38: self = .block_friend
    case 39: self = .incompatible_voip_version
    case 40: self = .invalid_sns_access_token
    case 41: self = .external_service_not_available
    case 42: self = .not_allowed_add_contact
    case 43: self = .not_certificated
    case 44: self = .not_allowed_secondary_device
    case 45: self = .invalid_pin_code
    case 46: self = .not_found_identity_credential
    case 47: self = .exceed_file_max_size
    case 48: self = .exceed_daily_quota
    case 49: self = .not_support_send_file
    case 50: self = .must_upgrade
    case 51: self = .not_available_pin_code_session
    default: return nil
    }
  }
}

public enum FeatureType : TEnum {
  case object_storage

  public static func read(from proto: TProtocol) throws -> FeatureType {
    let raw: Int32 = try proto.read()
    let new = FeatureType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(FeatureType.self)")
    }
  }

  public init() {
    self = .object_storage
  }

  public var rawValue: Int32 {
    switch self {
    case .object_storage: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .object_storage
    default: return nil
    }
  }
}

public enum GroupAttribute : TEnum {
  case name
  case picture_status
  case all

  public static func read(from proto: TProtocol) throws -> GroupAttribute {
    let raw: Int32 = try proto.read()
    let new = GroupAttribute(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(GroupAttribute.self)")
    }
  }

  public init() {
    self = .name
  }

  public var rawValue: Int32 {
    switch self {
    case .name: return 1
    case .picture_status: return 2
    case .all: return 255
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .name
    case 2: self = .picture_status
    case 255: self = .all
    default: return nil
    }
  }
}

public enum IdentityProvider : TEnum {
  case unknown
  case line
  case naver_kr

  public static func read(from proto: TProtocol) throws -> IdentityProvider {
    let raw: Int32 = try proto.read()
    let new = IdentityProvider(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(IdentityProvider.self)")
    }
  }

  public init() {
    self = .unknown
  }

  public var rawValue: Int32 {
    switch self {
    case .unknown: return 0
    case .line: return 1
    case .naver_kr: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .line
    case 2: self = .naver_kr
    default: return nil
    }
  }
}

public enum LoginResultType : TEnum {
  case success
  case require_qrcode
  case require_device_confirm

  public static func read(from proto: TProtocol) throws -> LoginResultType {
    let raw: Int32 = try proto.read()
    let new = LoginResultType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(LoginResultType.self)")
    }
  }

  public init() {
    self = .success
  }

  public var rawValue: Int32 {
    switch self {
    case .success: return 1
    case .require_qrcode: return 2
    case .require_device_confirm: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .success
    case 2: self = .require_qrcode
    case 3: self = .require_device_confirm
    default: return nil
    }
  }
}

public enum MessageOperationType : TEnum {
  case send_message
  case receive_message
  case read_message
  case notified_read_message
  case notified_join_chat
  case failed_send_message
  case send_content
  case send_content_receipt
  case send_chat_removed
  case remove_all_messages

  public static func read(from proto: TProtocol) throws -> MessageOperationType {
    let raw: Int32 = try proto.read()
    let new = MessageOperationType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(MessageOperationType.self)")
    }
  }

  public init() {
    self = .send_message
  }

  public var rawValue: Int32 {
    switch self {
    case .send_message: return 1
    case .receive_message: return 2
    case .read_message: return 3
    case .notified_read_message: return 4
    case .notified_join_chat: return 5
    case .failed_send_message: return 6
    case .send_content: return 7
    case .send_content_receipt: return 8
    case .send_chat_removed: return 9
    case .remove_all_messages: return 10
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .send_message
    case 2: self = .receive_message
    case 3: self = .read_message
    case 4: self = .notified_read_message
    case 5: self = .notified_join_chat
    case 6: self = .failed_send_message
    case 7: self = .send_content
    case 8: self = .send_content_receipt
    case 9: self = .send_chat_removed
    case 10: self = .remove_all_messages
    default: return nil
    }
  }
}

public enum MIDType : TEnum {
  case user
  case room
  case group

  public static func read(from proto: TProtocol) throws -> MIDType {
    let raw: Int32 = try proto.read()
    let new = MIDType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(MIDType.self)")
    }
  }

  public init() {
    self = .user
  }

  public var rawValue: Int32 {
    switch self {
    case .user: return 0
    case .room: return 1
    case .group: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .user
    case 1: self = .room
    case 2: self = .group
    default: return nil
    }
  }
}

public enum ModificationType : TEnum {
  case add
  case remove
  case modify

  public static func read(from proto: TProtocol) throws -> ModificationType {
    let raw: Int32 = try proto.read()
    let new = ModificationType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ModificationType.self)")
    }
  }

  public init() {
    self = .add
  }

  public var rawValue: Int32 {
    switch self {
    case .add: return 0
    case .remove: return 1
    case .modify: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .add
    case 1: self = .remove
    case 2: self = .modify
    default: return nil
    }
  }
}

public enum NotificationItemFetchMode : TEnum {
  case all
  case append

  public static func read(from proto: TProtocol) throws -> NotificationItemFetchMode {
    let raw: Int32 = try proto.read()
    let new = NotificationItemFetchMode(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(NotificationItemFetchMode.self)")
    }
  }

  public init() {
    self = .all
  }

  public var rawValue: Int32 {
    switch self {
    case .all: return 0
    case .append: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .all
    case 1: self = .append
    default: return nil
    }
  }
}

public enum NotificationQueueType : TEnum {
  case global
  case message
  case primary

  public static func read(from proto: TProtocol) throws -> NotificationQueueType {
    let raw: Int32 = try proto.read()
    let new = NotificationQueueType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(NotificationQueueType.self)")
    }
  }

  public init() {
    self = .global
  }

  public var rawValue: Int32 {
    switch self {
    case .global: return 1
    case .message: return 2
    case .primary: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .global
    case 2: self = .message
    case 3: self = .primary
    default: return nil
    }
  }
}

public enum NotificationStatus : TEnum {
  case notification_item_exist
  case timeline_item_exist
  case note_group_new_item_exist
  case timeline_buddygroup_changed
  case note_one_to_one_new_item_exist
  case album_item_exist
  case timeline_item_deleted

  public static func read(from proto: TProtocol) throws -> NotificationStatus {
    let raw: Int32 = try proto.read()
    let new = NotificationStatus(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(NotificationStatus.self)")
    }
  }

  public init() {
    self = .notification_item_exist
  }

  public var rawValue: Int32 {
    switch self {
    case .notification_item_exist: return 1
    case .timeline_item_exist: return 2
    case .note_group_new_item_exist: return 4
    case .timeline_buddygroup_changed: return 8
    case .note_one_to_one_new_item_exist: return 16
    case .album_item_exist: return 32
    case .timeline_item_deleted: return 64
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .notification_item_exist
    case 2: self = .timeline_item_exist
    case 4: self = .note_group_new_item_exist
    case 8: self = .timeline_buddygroup_changed
    case 16: self = .note_one_to_one_new_item_exist
    case 32: self = .album_item_exist
    case 64: self = .timeline_item_deleted
    default: return nil
    }
  }
}

public enum NotificationType : TEnum {
  case apple_apns
  case google_c2dm
  case nhn_nni
  case skt_aom
  case ms_mpns
  case rim_bis
  case google_gcm
  case nokia_nnapi
  case tizen
  case line_bot
  case line_wap

  public static func read(from proto: TProtocol) throws -> NotificationType {
    let raw: Int32 = try proto.read()
    let new = NotificationType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(NotificationType.self)")
    }
  }

  public init() {
    self = .apple_apns
  }

  public var rawValue: Int32 {
    switch self {
    case .apple_apns: return 1
    case .google_c2dm: return 2
    case .nhn_nni: return 3
    case .skt_aom: return 4
    case .ms_mpns: return 5
    case .rim_bis: return 6
    case .google_gcm: return 7
    case .nokia_nnapi: return 8
    case .tizen: return 9
    case .line_bot: return 17
    case .line_wap: return 18
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .apple_apns
    case 2: self = .google_c2dm
    case 3: self = .nhn_nni
    case 4: self = .skt_aom
    case 5: self = .ms_mpns
    case 6: self = .rim_bis
    case 7: self = .google_gcm
    case 8: self = .nokia_nnapi
    case 9: self = .tizen
    case 17: self = .line_bot
    case 18: self = .line_wap
    default: return nil
    }
  }
}

public enum OpStatus : TEnum {
  case normal
  case alert_disabled

  public static func read(from proto: TProtocol) throws -> OpStatus {
    let raw: Int32 = try proto.read()
    let new = OpStatus(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(OpStatus.self)")
    }
  }

  public init() {
    self = .normal
  }

  public var rawValue: Int32 {
    switch self {
    case .normal: return 0
    case .alert_disabled: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .alert_disabled
    default: return nil
    }
  }
}

public enum OpType : TEnum {
  case end_of_operation
  case update_profile
  case notified_update_profile
  case register_userid
  case add_contact
  case notified_add_contact
  case block_contact
  case unblock_contact
  case notified_recommend_contact
  case create_group
  case update_group
  case notified_update_group
  case invite_into_group
  case notified_invite_into_group
  case leave_group
  case notified_leave_group
  case accept_group_invitation
  case notified_accept_group_invitation
  case kickout_from_group
  case notified_kickout_from_group
  case create_room
  case invite_into_room
  case notified_invite_into_room
  case leave_room
  case notified_leave_room
  case send_message
  case receive_message
  case send_message_receipt
  case receive_message_receipt
  case send_content_receipt
  case receive_announcement
  case cancel_invitation_group
  case notified_cancel_invitation_group
  case notified_unregister_user
  case reject_group_invitation
  case notified_reject_group_invitation
  case update_settings
  case notified_register_user
  case invite_via_email
  case notified_request_recovery
  case send_chat_checked
  case send_chat_removed
  case notified_force_sync
  case send_content
  case send_message_myhome
  case notified_update_content_preview
  case remove_all_messages
  case notified_update_purchases
  case dummy
  case update_contact
  case notified_received_call
  case cancel_call
  case notified_redirect
  case notified_channel_sync
  case failed_send_message
  case notified_read_message
  case failed_email_confirmation
  case notified_chat_content
  case notified_push_noticenter_item

  public static func read(from proto: TProtocol) throws -> OpType {
    let raw: Int32 = try proto.read()
    let new = OpType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(OpType.self)")
    }
  }

  public init() {
    self = .end_of_operation
  }

  public var rawValue: Int32 {
    switch self {
    case .end_of_operation: return 0
    case .update_profile: return 1
    case .notified_update_profile: return 2
    case .register_userid: return 3
    case .add_contact: return 4
    case .notified_add_contact: return 5
    case .block_contact: return 6
    case .unblock_contact: return 7
    case .notified_recommend_contact: return 8
    case .create_group: return 9
    case .update_group: return 10
    case .notified_update_group: return 11
    case .invite_into_group: return 12
    case .notified_invite_into_group: return 13
    case .leave_group: return 14
    case .notified_leave_group: return 15
    case .accept_group_invitation: return 16
    case .notified_accept_group_invitation: return 17
    case .kickout_from_group: return 18
    case .notified_kickout_from_group: return 19
    case .create_room: return 20
    case .invite_into_room: return 21
    case .notified_invite_into_room: return 22
    case .leave_room: return 23
    case .notified_leave_room: return 24
    case .send_message: return 25
    case .receive_message: return 26
    case .send_message_receipt: return 27
    case .receive_message_receipt: return 28
    case .send_content_receipt: return 29
    case .receive_announcement: return 30
    case .cancel_invitation_group: return 31
    case .notified_cancel_invitation_group: return 32
    case .notified_unregister_user: return 33
    case .reject_group_invitation: return 34
    case .notified_reject_group_invitation: return 35
    case .update_settings: return 36
    case .notified_register_user: return 37
    case .invite_via_email: return 38
    case .notified_request_recovery: return 39
    case .send_chat_checked: return 40
    case .send_chat_removed: return 41
    case .notified_force_sync: return 42
    case .send_content: return 43
    case .send_message_myhome: return 44
    case .notified_update_content_preview: return 45
    case .remove_all_messages: return 46
    case .notified_update_purchases: return 47
    case .dummy: return 48
    case .update_contact: return 49
    case .notified_received_call: return 50
    case .cancel_call: return 51
    case .notified_redirect: return 52
    case .notified_channel_sync: return 53
    case .failed_send_message: return 54
    case .notified_read_message: return 55
    case .failed_email_confirmation: return 56
    case .notified_chat_content: return 58
    case .notified_push_noticenter_item: return 59
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .end_of_operation
    case 1: self = .update_profile
    case 2: self = .notified_update_profile
    case 3: self = .register_userid
    case 4: self = .add_contact
    case 5: self = .notified_add_contact
    case 6: self = .block_contact
    case 7: self = .unblock_contact
    case 8: self = .notified_recommend_contact
    case 9: self = .create_group
    case 10: self = .update_group
    case 11: self = .notified_update_group
    case 12: self = .invite_into_group
    case 13: self = .notified_invite_into_group
    case 14: self = .leave_group
    case 15: self = .notified_leave_group
    case 16: self = .accept_group_invitation
    case 17: self = .notified_accept_group_invitation
    case 18: self = .kickout_from_group
    case 19: self = .notified_kickout_from_group
    case 20: self = .create_room
    case 21: self = .invite_into_room
    case 22: self = .notified_invite_into_room
    case 23: self = .leave_room
    case 24: self = .notified_leave_room
    case 25: self = .send_message
    case 26: self = .receive_message
    case 27: self = .send_message_receipt
    case 28: self = .receive_message_receipt
    case 29: self = .send_content_receipt
    case 30: self = .receive_announcement
    case 31: self = .cancel_invitation_group
    case 32: self = .notified_cancel_invitation_group
    case 33: self = .notified_unregister_user
    case 34: self = .reject_group_invitation
    case 35: self = .notified_reject_group_invitation
    case 36: self = .update_settings
    case 37: self = .notified_register_user
    case 38: self = .invite_via_email
    case 39: self = .notified_request_recovery
    case 40: self = .send_chat_checked
    case 41: self = .send_chat_removed
    case 42: self = .notified_force_sync
    case 43: self = .send_content
    case 44: self = .send_message_myhome
    case 45: self = .notified_update_content_preview
    case 46: self = .remove_all_messages
    case 47: self = .notified_update_purchases
    case 48: self = .dummy
    case 49: self = .update_contact
    case 50: self = .notified_received_call
    case 51: self = .cancel_call
    case 52: self = .notified_redirect
    case 53: self = .notified_channel_sync
    case 54: self = .failed_send_message
    case 55: self = .notified_read_message
    case 56: self = .failed_email_confirmation
    case 58: self = .notified_chat_content
    case 59: self = .notified_push_noticenter_item
    default: return nil
    }
  }
}

public enum PayloadType : TEnum {
  case payload_buy
  case payload_cs
  case payload_bonus
  case payload_event

  public static func read(from proto: TProtocol) throws -> PayloadType {
    let raw: Int32 = try proto.read()
    let new = PayloadType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(PayloadType.self)")
    }
  }

  public init() {
    self = .payload_buy
  }

  public var rawValue: Int32 {
    switch self {
    case .payload_buy: return 101
    case .payload_cs: return 111
    case .payload_bonus: return 121
    case .payload_event: return 131
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 101: self = .payload_buy
    case 111: self = .payload_cs
    case 121: self = .payload_bonus
    case 131: self = .payload_event
    default: return nil
    }
  }
}

public enum PaymentPgType : TEnum {
  case payment_pg_none
  case payment_pg_au
  case payment_pg_al

  public static func read(from proto: TProtocol) throws -> PaymentPgType {
    let raw: Int32 = try proto.read()
    let new = PaymentPgType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(PaymentPgType.self)")
    }
  }

  public init() {
    self = .payment_pg_none
  }

  public var rawValue: Int32 {
    switch self {
    case .payment_pg_none: return 0
    case .payment_pg_au: return 1
    case .payment_pg_al: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .payment_pg_none
    case 1: self = .payment_pg_au
    case 2: self = .payment_pg_al
    default: return nil
    }
  }
}

public enum PaymentType : TEnum {
  case payment_apple
  case payment_google

  public static func read(from proto: TProtocol) throws -> PaymentType {
    let raw: Int32 = try proto.read()
    let new = PaymentType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(PaymentType.self)")
    }
  }

  public init() {
    self = .payment_apple
  }

  public var rawValue: Int32 {
    switch self {
    case .payment_apple: return 1
    case .payment_google: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .payment_apple
    case 2: self = .payment_google
    default: return nil
    }
  }
}

public enum ProductBannerLinkType : TEnum {
  case banner_link_none
  case banner_link_item
  case banner_link_url
  case banner_link_category

  public static func read(from proto: TProtocol) throws -> ProductBannerLinkType {
    let raw: Int32 = try proto.read()
    let new = ProductBannerLinkType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ProductBannerLinkType.self)")
    }
  }

  public init() {
    self = .banner_link_none
  }

  public var rawValue: Int32 {
    switch self {
    case .banner_link_none: return 0
    case .banner_link_item: return 1
    case .banner_link_url: return 2
    case .banner_link_category: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .banner_link_none
    case 1: self = .banner_link_item
    case 2: self = .banner_link_url
    case 3: self = .banner_link_category
    default: return nil
    }
  }
}

public enum ProductEventType : TEnum {
  case no_event
  case carrier_any
  case buddy_any
  case install_ios
  case install_android
  case mission_any
  case mustbuy_any

  public static func read(from proto: TProtocol) throws -> ProductEventType {
    let raw: Int32 = try proto.read()
    let new = ProductEventType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ProductEventType.self)")
    }
  }

  public init() {
    self = .no_event
  }

  public var rawValue: Int32 {
    switch self {
    case .no_event: return 0
    case .carrier_any: return 65537
    case .buddy_any: return 131073
    case .install_ios: return 196609
    case .install_android: return 196610
    case .mission_any: return 262145
    case .mustbuy_any: return 327681
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .no_event
    case 65537: self = .carrier_any
    case 131073: self = .buddy_any
    case 196609: self = .install_ios
    case 196610: self = .install_android
    case 262145: self = .mission_any
    case 327681: self = .mustbuy_any
    default: return nil
    }
  }
}

public enum ProfileAttribute : TEnum {
  case email
  case display_name
  case phonetic_name
  case picture
  case status_message
  case allow_search_by_userid
  case allow_search_by_email
  case buddy_status
  case all

  public static func read(from proto: TProtocol) throws -> ProfileAttribute {
    let raw: Int32 = try proto.read()
    let new = ProfileAttribute(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ProfileAttribute.self)")
    }
  }

  public init() {
    self = .email
  }

  public var rawValue: Int32 {
    switch self {
    case .email: return 1
    case .display_name: return 2
    case .phonetic_name: return 4
    case .picture: return 8
    case .status_message: return 16
    case .allow_search_by_userid: return 32
    case .allow_search_by_email: return 64
    case .buddy_status: return 128
    case .all: return 255
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .email
    case 2: self = .display_name
    case 4: self = .phonetic_name
    case 8: self = .picture
    case 16: self = .status_message
    case 32: self = .allow_search_by_userid
    case 64: self = .allow_search_by_email
    case 128: self = .buddy_status
    case 255: self = .all
    default: return nil
    }
  }
}

public enum PublicType : TEnum {
  case hidden
  case `public`

  public static func read(from proto: TProtocol) throws -> PublicType {
    let raw: Int32 = try proto.read()
    let new = PublicType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(PublicType.self)")
    }
  }

  public init() {
    self = .hidden
  }

  public var rawValue: Int32 {
    switch self {
    case .hidden: return 0
    case .`public`: return 1000
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .hidden
    case 1000: self = .`public`
    default: return nil
    }
  }
}

public enum RedirectType : TEnum {
  case `none`
  case expire_second

  public static func read(from proto: TProtocol) throws -> RedirectType {
    let raw: Int32 = try proto.read()
    let new = RedirectType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(RedirectType.self)")
    }
  }

  public init() {
    self = .none
  }

  public var rawValue: Int32 {
    switch self {
    case .`none`: return 0
    case .expire_second: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .`none`
    case 1: self = .expire_second
    default: return nil
    }
  }
}

public enum RegistrationType : TEnum {
  case phone
  case email_wap
  case facebook
  case sina
  case renren
  case feixin

  public static func read(from proto: TProtocol) throws -> RegistrationType {
    let raw: Int32 = try proto.read()
    let new = RegistrationType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(RegistrationType.self)")
    }
  }

  public init() {
    self = .phone
  }

  public var rawValue: Int32 {
    switch self {
    case .phone: return 0
    case .email_wap: return 1
    case .facebook: return 2305
    case .sina: return 2306
    case .renren: return 2307
    case .feixin: return 2308
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .phone
    case 1: self = .email_wap
    case 2305: self = .facebook
    case 2306: self = .sina
    case 2307: self = .renren
    case 2308: self = .feixin
    default: return nil
    }
  }
}

public enum SettingsAttribute : TEnum {
  case notification_enable
  case notification_mute_expiration
  case notification_new_message
  case notification_group_invitation
  case notification_show_message
  case notification_incoming_call
  case privacy_sync_contacts
  case privacy_search_by_phone_number
  case notification_sound_message
  case notification_sound_group
  case contact_my_ticket
  case identity_provider
  case identity_identifier
  case privacy_search_by_userid
  case privacy_search_by_email
  case preference_locale
  case notification_disabled_with_sub
  case sns_account
  case phone_registration
  case privacy_allow_secondary_device_login
  case custom_mode
  case privacy_profile_image_post_to_myhome
  case email_confirmation_status
  case privacy_recv_messages_from_not_friend
  case all

  public static func read(from proto: TProtocol) throws -> SettingsAttribute {
    let raw: Int32 = try proto.read()
    let new = SettingsAttribute(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(SettingsAttribute.self)")
    }
  }

  public init() {
    self = .notification_enable
  }

  public var rawValue: Int32 {
    switch self {
    case .notification_enable: return 1
    case .notification_mute_expiration: return 2
    case .notification_new_message: return 4
    case .notification_group_invitation: return 8
    case .notification_show_message: return 16
    case .notification_incoming_call: return 32
    case .privacy_sync_contacts: return 64
    case .privacy_search_by_phone_number: return 128
    case .notification_sound_message: return 256
    case .notification_sound_group: return 512
    case .contact_my_ticket: return 1024
    case .identity_provider: return 2048
    case .identity_identifier: return 4096
    case .privacy_search_by_userid: return 8192
    case .privacy_search_by_email: return 16384
    case .preference_locale: return 32768
    case .notification_disabled_with_sub: return 65536
    case .sns_account: return 524288
    case .phone_registration: return 1048576
    case .privacy_allow_secondary_device_login: return 2097152
    case .custom_mode: return 4194304
    case .privacy_profile_image_post_to_myhome: return 8388608
    case .email_confirmation_status: return 16777216
    case .privacy_recv_messages_from_not_friend: return 33554432
    case .all: return 2147483647
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .notification_enable
    case 2: self = .notification_mute_expiration
    case 4: self = .notification_new_message
    case 8: self = .notification_group_invitation
    case 16: self = .notification_show_message
    case 32: self = .notification_incoming_call
    case 64: self = .privacy_sync_contacts
    case 128: self = .privacy_search_by_phone_number
    case 256: self = .notification_sound_message
    case 512: self = .notification_sound_group
    case 1024: self = .contact_my_ticket
    case 2048: self = .identity_provider
    case 4096: self = .identity_identifier
    case 8192: self = .privacy_search_by_userid
    case 16384: self = .privacy_search_by_email
    case 32768: self = .preference_locale
    case 65536: self = .notification_disabled_with_sub
    case 524288: self = .sns_account
    case 1048576: self = .phone_registration
    case 2097152: self = .privacy_allow_secondary_device_login
    case 4194304: self = .custom_mode
    case 8388608: self = .privacy_profile_image_post_to_myhome
    case 16777216: self = .email_confirmation_status
    case 33554432: self = .privacy_recv_messages_from_not_friend
    case 2147483647: self = .all
    default: return nil
    }
  }
}

public enum SnsIdType : TEnum {
  case facebook
  case sina
  case renren
  case feixin

  public static func read(from proto: TProtocol) throws -> SnsIdType {
    let raw: Int32 = try proto.read()
    let new = SnsIdType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(SnsIdType.self)")
    }
  }

  public init() {
    self = .facebook
  }

  public var rawValue: Int32 {
    switch self {
    case .facebook: return 1
    case .sina: return 2
    case .renren: return 3
    case .feixin: return 4
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .facebook
    case 2: self = .sina
    case 3: self = .renren
    case 4: self = .feixin
    default: return nil
    }
  }
}

public enum SpammerReason : TEnum {
  case other
  case advertising
  case gender_harassment
  case harassment

  public static func read(from proto: TProtocol) throws -> SpammerReason {
    let raw: Int32 = try proto.read()
    let new = SpammerReason(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(SpammerReason.self)")
    }
  }

  public init() {
    self = .other
  }

  public var rawValue: Int32 {
    switch self {
    case .other: return 0
    case .advertising: return 1
    case .gender_harassment: return 2
    case .harassment: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .other
    case 1: self = .advertising
    case 2: self = .gender_harassment
    case 3: self = .harassment
    default: return nil
    }
  }
}

public enum SyncActionType : TEnum {
  case sync
  case report

  public static func read(from proto: TProtocol) throws -> SyncActionType {
    let raw: Int32 = try proto.read()
    let new = SyncActionType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(SyncActionType.self)")
    }
  }

  public init() {
    self = .sync
  }

  public var rawValue: Int32 {
    switch self {
    case .sync: return 0
    case .report: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .sync
    case 1: self = .report
    default: return nil
    }
  }
}

public enum SyncCategory : TEnum {
  case profile
  case settings
  case ops
  case contact
  case recommend
  case block
  case group
  case room
  case notification

  public static func read(from proto: TProtocol) throws -> SyncCategory {
    let raw: Int32 = try proto.read()
    let new = SyncCategory(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(SyncCategory.self)")
    }
  }

  public init() {
    self = .profile
  }

  public var rawValue: Int32 {
    switch self {
    case .profile: return 0
    case .settings: return 1
    case .ops: return 2
    case .contact: return 3
    case .recommend: return 4
    case .block: return 5
    case .group: return 6
    case .room: return 7
    case .notification: return 8
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .profile
    case 1: self = .settings
    case 2: self = .ops
    case 3: self = .contact
    case 4: self = .recommend
    case 5: self = .block
    case 6: self = .group
    case 7: self = .room
    case 8: self = .notification
    default: return nil
    }
  }
}

public enum TMessageBoxStatus : TEnum {
  case activated
  case unread

  public static func read(from proto: TProtocol) throws -> TMessageBoxStatus {
    let raw: Int32 = try proto.read()
    let new = TMessageBoxStatus(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(TMessageBoxStatus.self)")
    }
  }

  public init() {
    self = .activated
  }

  public var rawValue: Int32 {
    switch self {
    case .activated: return 1
    case .unread: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .activated
    case 2: self = .unread
    default: return nil
    }
  }
}

public enum UniversalNotificationServiceErrorCode : TEnum {
  case internal_error
  case invalid_key
  case illegal_argument
  case too_many_request
  case authentication_failed
  case no_write_permission

  public static func read(from proto: TProtocol) throws -> UniversalNotificationServiceErrorCode {
    let raw: Int32 = try proto.read()
    let new = UniversalNotificationServiceErrorCode(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(UniversalNotificationServiceErrorCode.self)")
    }
  }

  public init() {
    self = .internal_error
  }

  public var rawValue: Int32 {
    switch self {
    case .internal_error: return 0
    case .invalid_key: return 1
    case .illegal_argument: return 2
    case .too_many_request: return 3
    case .authentication_failed: return 4
    case .no_write_permission: return 5
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .internal_error
    case 1: self = .invalid_key
    case 2: self = .illegal_argument
    case 3: self = .too_many_request
    case 4: self = .authentication_failed
    case 5: self = .no_write_permission
    default: return nil
    }
  }
}

public enum UnregistrationReason : TEnum {
  case unregistration_reason_unregister_user
  case unregistration_reason_unbind_device

  public static func read(from proto: TProtocol) throws -> UnregistrationReason {
    let raw: Int32 = try proto.read()
    let new = UnregistrationReason(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(UnregistrationReason.self)")
    }
  }

  public init() {
    self = .unregistration_reason_unregister_user
  }

  public var rawValue: Int32 {
    switch self {
    case .unregistration_reason_unregister_user: return 1
    case .unregistration_reason_unbind_device: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .unregistration_reason_unregister_user
    case 2: self = .unregistration_reason_unbind_device
    default: return nil
    }
  }
}

public enum UserAgeType : TEnum {
  case over
  case under
  case undefined

  public static func read(from proto: TProtocol) throws -> UserAgeType {
    let raw: Int32 = try proto.read()
    let new = UserAgeType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(UserAgeType.self)")
    }
  }

  public init() {
    self = .over
  }

  public var rawValue: Int32 {
    switch self {
    case .over: return 1
    case .under: return 2
    case .undefined: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .over
    case 2: self = .under
    case 3: self = .undefined
    default: return nil
    }
  }
}

public enum VerificationMethod : TEnum {
  case no_available
  case pin_via_sms
  case callerid_indigo
  case pin_via_tts
  case skip

  public static func read(from proto: TProtocol) throws -> VerificationMethod {
    let raw: Int32 = try proto.read()
    let new = VerificationMethod(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(VerificationMethod.self)")
    }
  }

  public init() {
    self = .no_available
  }

  public var rawValue: Int32 {
    switch self {
    case .no_available: return 0
    case .pin_via_sms: return 1
    case .callerid_indigo: return 2
    case .pin_via_tts: return 4
    case .skip: return 10
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .no_available
    case 1: self = .pin_via_sms
    case 2: self = .callerid_indigo
    case 4: self = .pin_via_tts
    case 10: self = .skip
    default: return nil
    }
  }
}

public enum VerificationResult : TEnum {
  case failed
  case ok_not_registered_yet
  case ok_registered_with_same_device
  case ok_registered_with_another_device

  public static func read(from proto: TProtocol) throws -> VerificationResult {
    let raw: Int32 = try proto.read()
    let new = VerificationResult(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(VerificationResult.self)")
    }
  }

  public init() {
    self = .failed
  }

  public var rawValue: Int32 {
    switch self {
    case .failed: return 0
    case .ok_not_registered_yet: return 1
    case .ok_registered_with_same_device: return 2
    case .ok_registered_with_another_device: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .failed
    case 1: self = .ok_not_registered_yet
    case 2: self = .ok_registered_with_same_device
    case 3: self = .ok_registered_with_another_device
    default: return nil
    }
  }
}

public enum WapInvitationType : TEnum {
  case registration
  case chat

  public static func read(from proto: TProtocol) throws -> WapInvitationType {
    let raw: Int32 = try proto.read()
    let new = WapInvitationType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(WapInvitationType.self)")
    }
  }

  public init() {
    self = .registration
  }

  public var rawValue: Int32 {
    switch self {
    case .registration: return 1
    case .chat: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .registration
    case 2: self = .chat
    default: return nil
    }
  }
}

public final class AgeCheckDocomoResult {

  public var authUrl: String

  public var userAgeType: UserAgeType


  public init(authUrl: String, userAgeType: UserAgeType) {
    self.authUrl = authUrl
    self.userAgeType = userAgeType
  }

}

public final class AgeCheckRequestResult {

  public var authUrl: String

  public var sessionId: String


  public init(authUrl: String, sessionId: String) {
    self.authUrl = authUrl
    self.sessionId = sessionId
  }

}

public final class Announcement {

  public var index: Int32

  public var forceUpdate: Bool

  public var title: String

  public var text: String

  public var createdTime: Int64

  public var pictureUrl: String

  public var thumbnailUrl: String


  public init(index: Int32, forceUpdate: Bool, title: String, text: String, createdTime: Int64, pictureUrl: String, thumbnailUrl: String) {
    self.index = index
    self.forceUpdate = forceUpdate
    self.title = title
    self.text = text
    self.createdTime = createdTime
    self.pictureUrl = pictureUrl
    self.thumbnailUrl = thumbnailUrl
  }

}

public final class ChannelProvider {

  public var name: String


  public init(name: String) {
    self.name = name
  }

}

public final class ChannelInfo {

  public var channelId: String

  public var name: String

  public var entryPageUrl: String

  public var descriptionText: String

  public var provider: ChannelProvider

  public var publicType: PublicType

  public var iconImage: String

  public var permissions: TList<String>

  public var iconThumbnailImage: String

  public var channelConfigurations: TList<ChannelConfiguration>


  public init(channelId: String, name: String, entryPageUrl: String, descriptionText: String, provider: ChannelProvider, publicType: PublicType, iconImage: String, permissions: TList<String>, iconThumbnailImage: String, channelConfigurations: TList<ChannelConfiguration>) {
    self.channelId = channelId
    self.name = name
    self.entryPageUrl = entryPageUrl
    self.descriptionText = descriptionText
    self.provider = provider
    self.publicType = publicType
    self.iconImage = iconImage
    self.permissions = permissions
    self.iconThumbnailImage = iconThumbnailImage
    self.channelConfigurations = channelConfigurations
  }

}

public final class ApprovedChannelInfo {

  public var channelInfo: ChannelInfo

  public var approvedAt: Int64


  public init(channelInfo: ChannelInfo, approvedAt: Int64) {
    self.channelInfo = channelInfo
    self.approvedAt = approvedAt
  }

}

public final class ApprovedChannelInfos {

  public var approvedChannelInfos: TList<ApprovedChannelInfo>

  public var revision: Int64


  public init(approvedChannelInfos: TList<ApprovedChannelInfo>, revision: Int64) {
    self.approvedChannelInfos = approvedChannelInfos
    self.revision = revision
  }

}

public final class AuthQrcode {

  public var qrcode: String

  public var verifier: String


  public init(qrcode: String, verifier: String) {
    self.qrcode = qrcode
    self.verifier = verifier
  }

}

public final class BuddyBanner {

  public var buddyBannerLinkType: BuddyBannerLinkType

  public var buddyBannerLink: String

  public var buddyBannerImageUrl: String


  public init(buddyBannerLinkType: BuddyBannerLinkType, buddyBannerLink: String, buddyBannerImageUrl: String) {
    self.buddyBannerLinkType = buddyBannerLinkType
    self.buddyBannerLink = buddyBannerLink
    self.buddyBannerImageUrl = buddyBannerImageUrl
  }

}

public final class BuddyDetail {

  public var mid: String

  public var memberCount: Int64

  public var onAir: Bool

  public var businessAccount: Bool

  public var addable: Bool

  public var acceptableContentTypes: TSet<ContentType>

  public var capableMyhome: Bool


  public init(mid: String, memberCount: Int64, onAir: Bool, businessAccount: Bool, addable: Bool, acceptableContentTypes: TSet<ContentType>, capableMyhome: Bool) {
    self.mid = mid
    self.memberCount = memberCount
    self.onAir = onAir
    self.businessAccount = businessAccount
    self.addable = addable
    self.acceptableContentTypes = acceptableContentTypes
    self.capableMyhome = capableMyhome
  }

}

public final class Contact {

  public var mid: String

  public var createdTime: Int64

  public var type: ContactType

  public var status: ContactStatus

  public var relation: ContactRelation

  public var displayName: String

  public var phoneticName: String

  public var pictureStatus: String

  public var thumbnailUrl: String

  public var statusMessage: String

  public var displayNameOverridden: String

  public var favoriteTime: Int64

  public var capableVoiceCall: Bool

  public var capableVideoCall: Bool

  public var capableMyhome: Bool

  public var capableBuddy: Bool

  public var attributes: Int32

  public var settings: Int64

  public var picturePath: String


  public init(mid: String, createdTime: Int64, type: ContactType, status: ContactStatus, relation: ContactRelation, displayName: String, phoneticName: String, pictureStatus: String, thumbnailUrl: String, statusMessage: String, displayNameOverridden: String, favoriteTime: Int64, capableVoiceCall: Bool, capableVideoCall: Bool, capableMyhome: Bool, capableBuddy: Bool, attributes: Int32, settings: Int64, picturePath: String) {
    self.mid = mid
    self.createdTime = createdTime
    self.type = type
    self.status = status
    self.relation = relation
    self.displayName = displayName
    self.phoneticName = phoneticName
    self.pictureStatus = pictureStatus
    self.thumbnailUrl = thumbnailUrl
    self.statusMessage = statusMessage
    self.displayNameOverridden = displayNameOverridden
    self.favoriteTime = favoriteTime
    self.capableVoiceCall = capableVoiceCall
    self.capableVideoCall = capableVideoCall
    self.capableMyhome = capableMyhome
    self.capableBuddy = capableBuddy
    self.attributes = attributes
    self.settings = settings
    self.picturePath = picturePath
  }

}

public final class BuddyList {

  public var classification: String

  public var displayName: String

  public var totalBuddyCount: Int32

  public var popularContacts: TList<Contact>


  public init(classification: String, displayName: String, totalBuddyCount: Int32, popularContacts: TList<Contact>) {
    self.classification = classification
    self.displayName = displayName
    self.totalBuddyCount = totalBuddyCount
    self.popularContacts = popularContacts
  }

}

public final class Location {

  public var title: String

  public var address: String

  public var latitude: Double

  public var longitude: Double

  public var phone: String


  public init(title: String, address: String, latitude: Double, longitude: Double, phone: String) {
    self.title = title
    self.address = address
    self.latitude = latitude
    self.longitude = longitude
    self.phone = phone
  }

}

public final class BuddyMessageRequest {

  public var contentType: ContentType

  public var text: String

  public var location: Location

  public var content: Data

  public var contentMetadata: TMap<String, String>


  public init(contentType: ContentType, text: String, location: Location, content: Data, contentMetadata: TMap<String, String>) {
    self.contentType = contentType
    self.text = text
    self.location = location
    self.content = content
    self.contentMetadata = contentMetadata
  }

}

public final class BuddyOnAirUrls {

  public var hls: TMap<String, String>

  public var smoothStreaming: TMap<String, String>


  public init(hls: TMap<String, String>, smoothStreaming: TMap<String, String>) {
    self.hls = hls
    self.smoothStreaming = smoothStreaming
  }

}

public final class BuddyOnAir {

  public var mid: String

  public var freshnessLifetime: Int64

  public var onAirId: String

  public var onAir: Bool

  public var text: String

  public var viewerCount: Int64

  public var targetCount: Int64

  public var onAirType: BuddyOnAirType

  public var onAirUrls: BuddyOnAirUrls


  public init(mid: String, freshnessLifetime: Int64, onAirId: String, onAir: Bool, text: String, viewerCount: Int64, targetCount: Int64, onAirType: BuddyOnAirType, onAirUrls: BuddyOnAirUrls) {
    self.mid = mid
    self.freshnessLifetime = freshnessLifetime
    self.onAirId = onAirId
    self.onAir = onAir
    self.text = text
    self.viewerCount = viewerCount
    self.targetCount = targetCount
    self.onAirType = onAirType
    self.onAirUrls = onAirUrls
  }

}

public final class BuddyProfile {

  public var buddyId: String

  public var mid: String

  public var searchId: String

  public var displayName: String

  public var statusMessage: String

  public var contactCount: Int64


  public init(buddyId: String, mid: String, searchId: String, displayName: String, statusMessage: String, contactCount: Int64) {
    self.buddyId = buddyId
    self.mid = mid
    self.searchId = searchId
    self.displayName = displayName
    self.statusMessage = statusMessage
    self.contactCount = contactCount
  }

}

public final class BuddySearchResult {

  public var mid: String

  public var displayName: String

  public var pictureStatus: String

  public var picturePath: String

  public var statusMessage: String

  public var businessAccount: Bool


  public init(mid: String, displayName: String, pictureStatus: String, picturePath: String, statusMessage: String, businessAccount: Bool) {
    self.mid = mid
    self.displayName = displayName
    self.pictureStatus = pictureStatus
    self.picturePath = picturePath
    self.statusMessage = statusMessage
    self.businessAccount = businessAccount
  }

}

public final class ChannelDomain {

  public var host: String

  public var removed: Bool


  public init(host: String, removed: Bool) {
    self.host = host
    self.removed = removed
  }

}

public final class ChannelDomains {

  public var channelDomains: TList<ChannelDomain>

  public var revision: Int64


  public init(channelDomains: TList<ChannelDomain>, revision: Int64) {
    self.channelDomains = channelDomains
    self.revision = revision
  }

}

public final class ChannelException : Swift.Error {

  public var code: ChannelErrorCode

  public var reason: String

  public var parameterMap: TMap<String, String>


  public init(code: ChannelErrorCode, reason: String, parameterMap: TMap<String, String>) {
    self.code = code
    self.reason = reason
    self.parameterMap = parameterMap
  }

}

public final class ChannelInfos {

  public var channelInfos: TList<ChannelInfo>

  public var revision: Int64


  public init(channelInfos: TList<ChannelInfo>, revision: Int64) {
    self.channelInfos = channelInfos
    self.revision = revision
  }

}

public final class ChannelNotificationSetting {

  public var channelId: String

  public var name: String

  public var notificationReceivable: Bool

  public var messageReceivable: Bool

  public var showDefault: Bool


  public init(channelId: String, name: String, notificationReceivable: Bool, messageReceivable: Bool, showDefault: Bool) {
    self.channelId = channelId
    self.name = name
    self.notificationReceivable = notificationReceivable
    self.messageReceivable = messageReceivable
    self.showDefault = showDefault
  }

}

public final class ChannelSyncDatas {

  public var channelInfos: TList<ChannelInfo>

  public var channelDomains: TList<ChannelDomain>

  public var revision: Int64

  public var expires: Int64


  public init(channelInfos: TList<ChannelInfo>, channelDomains: TList<ChannelDomain>, revision: Int64, expires: Int64) {
    self.channelInfos = channelInfos
    self.channelDomains = channelDomains
    self.revision = revision
    self.expires = expires
  }

}

public final class ChannelToken {

  public var token: String

  public var obsToken: String

  public var expiration: Int64

  public var refreshToken: String

  public var channelAccessToken: String


  public init(token: String, obsToken: String, expiration: Int64, refreshToken: String, channelAccessToken: String) {
    self.token = token
    self.obsToken = obsToken
    self.expiration = expiration
    self.refreshToken = refreshToken
    self.channelAccessToken = channelAccessToken
  }

}

public final class Coin {

  public var freeCoinBalance: Int32

  public var payedCoinBalance: Int32

  public var totalCoinBalance: Int32

  public var rewardCoinBalance: Int32


  public init(freeCoinBalance: Int32, payedCoinBalance: Int32, totalCoinBalance: Int32, rewardCoinBalance: Int32) {
    self.freeCoinBalance = freeCoinBalance
    self.payedCoinBalance = payedCoinBalance
    self.totalCoinBalance = totalCoinBalance
    self.rewardCoinBalance = rewardCoinBalance
  }

}

public final class CoinPayLoad {

  public var payCoin: Int32

  public var freeCoin: Int32

  public var type: PayloadType

  public var rewardCoin: Int32


  public init(payCoin: Int32, freeCoin: Int32, type: PayloadType, rewardCoin: Int32) {
    self.payCoin = payCoin
    self.freeCoin = freeCoin
    self.type = type
    self.rewardCoin = rewardCoin
  }

}

public final class CoinHistory {

  public var payDate: Int64

  public var coinBalance: Int32

  public var coin: Int32

  public var price: String

  public var title: String

  public var refund: Bool

  public var paySeq: String

  public var currency: String

  public var currencySign: String

  public var displayPrice: String

  public var payload: CoinPayLoad

  public var channelId: String


  public init(payDate: Int64, coinBalance: Int32, coin: Int32, price: String, title: String, refund: Bool, paySeq: String, currency: String, currencySign: String, displayPrice: String, payload: CoinPayLoad, channelId: String) {
    self.payDate = payDate
    self.coinBalance = coinBalance
    self.coin = coin
    self.price = price
    self.title = title
    self.refund = refund
    self.paySeq = paySeq
    self.currency = currency
    self.currencySign = currencySign
    self.displayPrice = displayPrice
    self.payload = payload
    self.channelId = channelId
  }

}

public final class CoinHistoryCondition {

  public var start: Int64

  public var size: Int32

  public var language: String

  public var eddt: String

  public var appStoreCode: PaymentType


  public init(start: Int64, size: Int32, language: String, eddt: String, appStoreCode: PaymentType) {
    self.start = start
    self.size = size
    self.language = language
    self.eddt = eddt
    self.appStoreCode = appStoreCode
  }

}

public final class CoinHistoryResult {

  public var historys: TList<CoinHistory>

  public var balance: Coin

  public var hasNext: Bool


  public init(historys: TList<CoinHistory>, balance: Coin, hasNext: Bool) {
    self.historys = historys
    self.balance = balance
    self.hasNext = hasNext
  }

}

public final class CoinProductItem {

  public var itemId: String

  public var coin: Int32

  public var freeCoin: Int32

  public var currency: String

  public var price: String

  public var displayPrice: String

  public var name: String

  public var desc: String


  public init(itemId: String, coin: Int32, freeCoin: Int32, currency: String, price: String, displayPrice: String, name: String, desc: String) {
    self.itemId = itemId
    self.coin = coin
    self.freeCoin = freeCoin
    self.currency = currency
    self.price = price
    self.displayPrice = displayPrice
    self.name = name
    self.desc = desc
  }

}

public final class CoinPurchaseConfirm {

  public var orderId: String

  public var appStoreCode: PaymentType

  public var receipt: String

  public var signature: String

  public var seller: String

  public var requestType: String

  public var ignoreReceipt: Bool


  public init(orderId: String, appStoreCode: PaymentType, receipt: String, signature: String, seller: String, requestType: String, ignoreReceipt: Bool) {
    self.orderId = orderId
    self.appStoreCode = appStoreCode
    self.receipt = receipt
    self.signature = signature
    self.seller = seller
    self.requestType = requestType
    self.ignoreReceipt = ignoreReceipt
  }

}

public final class CoinPurchaseReservation {

  public var productId: String

  public var country: String

  public var currency: String

  public var price: String

  public var appStoreCode: PaymentType

  public var language: String

  public var pgCode: PaymentPgType

  public var redirectUrl: String


  public init(productId: String, country: String, currency: String, price: String, appStoreCode: PaymentType, language: String, pgCode: PaymentPgType, redirectUrl: String) {
    self.productId = productId
    self.country = country
    self.currency = currency
    self.price = price
    self.appStoreCode = appStoreCode
    self.language = language
    self.pgCode = pgCode
    self.redirectUrl = redirectUrl
  }

}

public final class CoinUseReservationItem {

  public var itemId: String

  public var itemName: String

  public var amount: Int32


  public init(itemId: String, itemName: String, amount: Int32) {
    self.itemId = itemId
    self.itemName = itemName
    self.amount = amount
  }

}

public final class CoinUseReservation {

  public var channelId: String

  public var shopOrderId: String

  public var appStoreCode: PaymentType

  public var items: TList<CoinUseReservationItem>

  public var country: String


  public init(channelId: String, shopOrderId: String, appStoreCode: PaymentType, items: TList<CoinUseReservationItem>, country: String) {
    self.channelId = channelId
    self.shopOrderId = shopOrderId
    self.appStoreCode = appStoreCode
    self.items = items
    self.country = country
  }

}

public final class CompactContact {

  public var mid: String

  public var createdTime: Int64

  public var modifiedTime: Int64

  public var status: ContactStatus

  public var settings: Int64

  public var displayNameOverridden: String


  public init(mid: String, createdTime: Int64, modifiedTime: Int64, status: ContactStatus, settings: Int64, displayNameOverridden: String) {
    self.mid = mid
    self.createdTime = createdTime
    self.modifiedTime = modifiedTime
    self.status = status
    self.settings = settings
    self.displayNameOverridden = displayNameOverridden
  }

}

public final class ContactModification {

  public var type: ModificationType

  public var luid: String

  public var phones: TList<String>

  public var emails: TList<String>

  public var userids: TList<String>


  public init(type: ModificationType, luid: String, phones: TList<String>, emails: TList<String>, userids: TList<String>) {
    self.type = type
    self.luid = luid
    self.phones = phones
    self.emails = emails
    self.userids = userids
  }

}

public final class ContactRegistration {

  public var contact: Contact

  public var luid: String

  public var contactType: ContactType

  public var contactKey: String


  public init(contact: Contact, luid: String, contactType: ContactType, contactKey: String) {
    self.contact = contact
    self.luid = luid
    self.contactType = contactType
    self.contactKey = contactKey
  }

}

public final class ContactReport {

  public var mid: String

  public var exists: Bool

  public var contact: Contact


  public init(mid: String, exists: Bool, contact: Contact) {
    self.mid = mid
    self.exists = exists
    self.contact = contact
  }

}

public final class ContactReportResult {

  public var mid: String

  public var exists: Bool


  public init(mid: String, exists: Bool) {
    self.mid = mid
    self.exists = exists
  }

}

public final class DeviceInfo {

  public var deviceName: String

  public var systemName: String

  public var systemVersion: String

  public var model: String

  public var carrierCode: CarrierCode

  public var carrierName: String

  public var applicationType: ApplicationType


  public init(deviceName: String, systemName: String, systemVersion: String, model: String, carrierCode: CarrierCode, carrierName: String, applicationType: ApplicationType) {
    self.deviceName = deviceName
    self.systemName = systemName
    self.systemVersion = systemVersion
    self.model = model
    self.carrierCode = carrierCode
    self.carrierName = carrierName
    self.applicationType = applicationType
  }

}

public final class EmailConfirmation {

  public var usePasswordSet: Bool

  public var email: String

  public var password: String

  public var ignoreDuplication: Bool


  public init(usePasswordSet: Bool, email: String, password: String, ignoreDuplication: Bool) {
    self.usePasswordSet = usePasswordSet
    self.email = email
    self.password = password
    self.ignoreDuplication = ignoreDuplication
  }

}

public final class EmailConfirmationSession {

  public var emailConfirmationType: EmailConfirmationType

  public var verifier: String

  public var targetEmail: String


  public init(emailConfirmationType: EmailConfirmationType, verifier: String, targetEmail: String) {
    self.emailConfirmationType = emailConfirmationType
    self.verifier = verifier
    self.targetEmail = targetEmail
  }

}

public final class FriendChannelMatrix {

  public var channelId: String

  public var representMid: String

  public var count: Int32


  public init(channelId: String, representMid: String, count: Int32) {
    self.channelId = channelId
    self.representMid = representMid
    self.count = count
  }

}

public final class FriendChannelMatricesResponse {

  public var expires: Int64

  public var matrices: TList<FriendChannelMatrix>


  public init(expires: Int64, matrices: TList<FriendChannelMatrix>) {
    self.expires = expires
    self.matrices = matrices
  }

}

public final class Geolocation {

  public var longitude: Double

  public var latitude: Double


  public init(longitude: Double, latitude: Double) {
    self.longitude = longitude
    self.latitude = latitude
  }

}

public final class NotificationTarget {

  public var applicationType: String

  public var applicationVersion: String

  public var region: String


  public init(applicationType: String, applicationVersion: String, region: String) {
    self.applicationType = applicationType
    self.applicationVersion = applicationVersion
    self.region = region
  }

}

public final class GlobalEvent {

  public var key: String

  public var targets: TList<NotificationTarget>

  public var createdTime: Int64

  public var data: Int64

  public var maxDelay: Int32


  public init(key: String, targets: TList<NotificationTarget>, createdTime: Int64, data: Int64, maxDelay: Int32) {
    self.key = key
    self.targets = targets
    self.createdTime = createdTime
    self.data = data
    self.maxDelay = maxDelay
  }

}

public final class Group {

  public var id: String

  public var createdTime: Int64

  public var name: String

  public var pictureStatus: String

  public var members: TList<Contact>

  public var creator: Contact

  public var invitee: TList<Contact>

  public var notificationDisabled: Bool


  public init(id: String, createdTime: Int64, name: String, pictureStatus: String, members: TList<Contact>, creator: Contact, invitee: TList<Contact>, notificationDisabled: Bool) {
    self.id = id
    self.createdTime = createdTime
    self.name = name
    self.pictureStatus = pictureStatus
    self.members = members
    self.creator = creator
    self.invitee = invitee
    self.notificationDisabled = notificationDisabled
  }

}

public final class IdentityCredential {

  public var provider: IdentityProvider

  public var identifier: String

  public var password: String


  public init(provider: IdentityProvider, identifier: String, password: String) {
    self.provider = provider
    self.identifier = identifier
    self.password = password
  }

}

public final class LastReadMessageId {

  public var mid: String

  public var lastReadMessageId: String


  public init(mid: String, lastReadMessageId: String) {
    self.mid = mid
    self.lastReadMessageId = lastReadMessageId
  }

}

public final class LastReadMessageIds {

  public var chatId: String

  public var lastReadMessageIds: TList<LastReadMessageId>


  public init(chatId: String, lastReadMessageIds: TList<LastReadMessageId>) {
    self.chatId = chatId
    self.lastReadMessageIds = lastReadMessageIds
  }

}

public final class LoginResult {

  public var authToken: String

  public var certificate: String

  public var verifier: String

  public var pinCode: String

  public var type: LoginResultType


  public init(authToken: String, certificate: String, verifier: String, pinCode: String, type: LoginResultType) {
    self.authToken = authToken
    self.certificate = certificate
    self.verifier = verifier
    self.pinCode = pinCode
    self.type = type
  }

}

public final class LoginSession {

  public var tokenKey: String

  public var expirationTime: Int64

  public var applicationType: ApplicationType

  public var systemName: String

  public var accessLocation: String


  public init(tokenKey: String, expirationTime: Int64, applicationType: ApplicationType, systemName: String, accessLocation: String) {
    self.tokenKey = tokenKey
    self.expirationTime = expirationTime
    self.applicationType = applicationType
    self.systemName = systemName
    self.accessLocation = accessLocation
  }

}

public final class Message {

  public var from_: String

  public var to: String

  public var toType: MIDType

  public var id: String

  public var createdTime: Int64

  public var deliveredTime: Int64

  public var text: String

  public var location: Location

  public var hasContent: Bool

  public var contentType: ContentType

  public var contentPreview: Data

  public var contentMetadata: TMap<String, String>


  public init(from_: String, to: String, toType: MIDType, id: String, createdTime: Int64, deliveredTime: Int64, text: String, location: Location, hasContent: Bool, contentType: ContentType, contentPreview: Data, contentMetadata: TMap<String, String>) {
    self.from_ = from_
    self.to = to
    self.toType = toType
    self.id = id
    self.createdTime = createdTime
    self.deliveredTime = deliveredTime
    self.text = text
    self.location = location
    self.hasContent = hasContent
    self.contentType = contentType
    self.contentPreview = contentPreview
    self.contentMetadata = contentMetadata
  }

}

public final class MessageOperation {

  public var revision: Int64

  public var createdTime: Int64

  public var type: MessageOperationType

  public var reqSeq: Int32

  public var status: OpStatus

  public var param1: String

  public var param2: String

  public var param3: String

  public var message: Message


  public init(revision: Int64, createdTime: Int64, type: MessageOperationType, reqSeq: Int32, status: OpStatus, param1: String, param2: String, param3: String, message: Message) {
    self.revision = revision
    self.createdTime = createdTime
    self.type = type
    self.reqSeq = reqSeq
    self.status = status
    self.param1 = param1
    self.param2 = param2
    self.param3 = param3
    self.message = message
  }

}

public final class MessageOperations {

  public var operations: TList<MessageOperation>

  public var endFlag: Bool


  public init(operations: TList<MessageOperation>, endFlag: Bool) {
    self.operations = operations
    self.endFlag = endFlag
  }

}

public final class MetaProfile {

  public var createTime: Int64

  public var regionCode: String

  public var identities: TMap<RegistrationType, String>


  public init(createTime: Int64, regionCode: String, identities: TMap<RegistrationType, String>) {
    self.createTime = createTime
    self.regionCode = regionCode
    self.identities = identities
  }

}

public final class NotificationItem {

  public var id: String

  public var from_: String

  public var to: String

  public var fromChannel: String

  public var toChannel: String

  public var revision: Int64

  public var createdTime: Int64

  public var content: TMap<String, String>


  public init(id: String, from_: String, to: String, fromChannel: String, toChannel: String, revision: Int64, createdTime: Int64, content: TMap<String, String>) {
    self.id = id
    self.from_ = from_
    self.to = to
    self.fromChannel = fromChannel
    self.toChannel = toChannel
    self.revision = revision
    self.createdTime = createdTime
    self.content = content
  }

}

public final class NotificationFetchResult {

  public var fetchMode: NotificationItemFetchMode

  public var itemList: TList<NotificationItem>


  public init(fetchMode: NotificationItemFetchMode, itemList: TList<NotificationItem>) {
    self.fetchMode = fetchMode
    self.itemList = itemList
  }

}

public final class Operation {

  public var revision: Int64

  public var createdTime: Int64

  public var type: OpType

  public var reqSeq: Int32

  public var checksum: String

  public var status: OpStatus

  public var param1: String

  public var param2: String

  public var param3: String

  public var message: Message


  public init(revision: Int64, createdTime: Int64, type: OpType, reqSeq: Int32, checksum: String, status: OpStatus, param1: String, param2: String, param3: String, message: Message) {
    self.revision = revision
    self.createdTime = createdTime
    self.type = type
    self.reqSeq = reqSeq
    self.checksum = checksum
    self.status = status
    self.param1 = param1
    self.param2 = param2
    self.param3 = param3
    self.message = message
  }

}

public final class PaymentReservation {

  public var receiverMid: String

  public var productId: String

  public var language: String

  public var location: String

  public var currency: String

  public var price: String

  public var appStoreCode: PaymentType

  public var messageText: String

  public var messageTemplate: Int32

  public var packageId: Int64


  public init(receiverMid: String, productId: String, language: String, location: String, currency: String, price: String, appStoreCode: PaymentType, messageText: String, messageTemplate: Int32, packageId: Int64) {
    self.receiverMid = receiverMid
    self.productId = productId
    self.language = language
    self.location = location
    self.currency = currency
    self.price = price
    self.appStoreCode = appStoreCode
    self.messageText = messageText
    self.messageTemplate = messageTemplate
    self.packageId = packageId
  }

}

public final class PaymentReservationResult {

  public var orderId: String

  public var confirmUrl: String

  public var extras: TMap<String, String>


  public init(orderId: String, confirmUrl: String, extras: TMap<String, String>) {
    self.orderId = orderId
    self.confirmUrl = confirmUrl
    self.extras = extras
  }

}

public final class Product {

  public var productId: String

  public var packageId: Int64

  public var version: Int32

  public var authorName: String

  public var onSale: Bool

  public var validDays: Int32

  public var saleType: Int32

  public var copyright: String

  public var title: String

  public var descriptionText: String

  public var shopOrderId: Int64

  public var fromMid: String

  public var toMid: String

  public var validUntil: Int64

  public var priceTier: Int32

  public var price: String

  public var currency: String

  public var currencySymbol: String

  public var paymentType: PaymentType

  public var createDate: Int64

  public var ownFlag: Bool

  public var eventType: ProductEventType

  public var urlSchema: String

  public var downloadUrl: String

  public var buddyMid: String

  public var publishSince: Int64

  public var newFlag: Bool

  public var missionFlag: Bool


  public init(productId: String, packageId: Int64, version: Int32, authorName: String, onSale: Bool, validDays: Int32, saleType: Int32, copyright: String, title: String, descriptionText: String, shopOrderId: Int64, fromMid: String, toMid: String, validUntil: Int64, priceTier: Int32, price: String, currency: String, currencySymbol: String, paymentType: PaymentType, createDate: Int64, ownFlag: Bool, eventType: ProductEventType, urlSchema: String, downloadUrl: String, buddyMid: String, publishSince: Int64, newFlag: Bool, missionFlag: Bool) {
    self.productId = productId
    self.packageId = packageId
    self.version = version
    self.authorName = authorName
    self.onSale = onSale
    self.validDays = validDays
    self.saleType = saleType
    self.copyright = copyright
    self.title = title
    self.descriptionText = descriptionText
    self.shopOrderId = shopOrderId
    self.fromMid = fromMid
    self.toMid = toMid
    self.validUntil = validUntil
    self.priceTier = priceTier
    self.price = price
    self.currency = currency
    self.currencySymbol = currencySymbol
    self.paymentType = paymentType
    self.createDate = createDate
    self.ownFlag = ownFlag
    self.eventType = eventType
    self.urlSchema = urlSchema
    self.downloadUrl = downloadUrl
    self.buddyMid = buddyMid
    self.publishSince = publishSince
    self.newFlag = newFlag
    self.missionFlag = missionFlag
  }

}

public final class ProductList {

  public var hasNext: Bool

  public var bannerSequence: Int64

  public var bannerTargetType: ProductBannerLinkType

  public var bannerTargetPath: String

  public var productList: TList<Product>

  public var bannerLang: String


  public init(hasNext: Bool, bannerSequence: Int64, bannerTargetType: ProductBannerLinkType, bannerTargetPath: String, productList: TList<Product>, bannerLang: String) {
    self.hasNext = hasNext
    self.bannerSequence = bannerSequence
    self.bannerTargetType = bannerTargetType
    self.bannerTargetPath = bannerTargetPath
    self.productList = productList
    self.bannerLang = bannerLang
  }

}

public final class ProductSimple {

  public var productId: String

  public var packageId: Int64

  public var version: Int32

  public var onSale: Bool

  public var validUntil: Int64


  public init(productId: String, packageId: Int64, version: Int32, onSale: Bool, validUntil: Int64) {
    self.productId = productId
    self.packageId = packageId
    self.version = version
    self.onSale = onSale
    self.validUntil = validUntil
  }

}

public final class ProductSimpleList {

  public var hasNext: Bool

  public var reinvokeHour: Int32

  public var lastVersionSeq: Int64

  public var productList: TList<ProductSimple>

  public var recentNewReleaseDate: Int64

  public var recentEventReleaseDate: Int64


  public init(hasNext: Bool, reinvokeHour: Int32, lastVersionSeq: Int64, productList: TList<ProductSimple>, recentNewReleaseDate: Int64, recentEventReleaseDate: Int64) {
    self.hasNext = hasNext
    self.reinvokeHour = reinvokeHour
    self.lastVersionSeq = lastVersionSeq
    self.productList = productList
    self.recentNewReleaseDate = recentNewReleaseDate
    self.recentEventReleaseDate = recentEventReleaseDate
  }

}

public final class Profile {

  public var mid: String

  public var userid: String

  public var phone: String

  public var email: String

  public var regionCode: String

  public var displayName: String

  public var phoneticName: String

  public var pictureStatus: String

  public var thumbnailUrl: String

  public var statusMessage: String

  public var allowSearchByUserid: Bool

  public var allowSearchByEmail: Bool

  public var picturePath: String


  public init(mid: String, userid: String, phone: String, email: String, regionCode: String, displayName: String, phoneticName: String, pictureStatus: String, thumbnailUrl: String, statusMessage: String, allowSearchByUserid: Bool, allowSearchByEmail: Bool, picturePath: String) {
    self.mid = mid
    self.userid = userid
    self.phone = phone
    self.email = email
    self.regionCode = regionCode
    self.displayName = displayName
    self.phoneticName = phoneticName
    self.pictureStatus = pictureStatus
    self.thumbnailUrl = thumbnailUrl
    self.statusMessage = statusMessage
    self.allowSearchByUserid = allowSearchByUserid
    self.allowSearchByEmail = allowSearchByEmail
    self.picturePath = picturePath
  }

}

public final class ProximityMatchCandidateResult {

  public var users: TList<Contact>

  public var buddies: TList<Contact>


  public init(users: TList<Contact>, buddies: TList<Contact>) {
    self.users = users
    self.buddies = buddies
  }

}

public final class RegisterWithSnsIdResult {

  public var authToken: String

  public var userCreated: Bool


  public init(authToken: String, userCreated: Bool) {
    self.authToken = authToken
    self.userCreated = userCreated
  }

}

public final class RequestTokenResponse {

  public var requestToken: String

  public var returnUrl: String


  public init(requestToken: String, returnUrl: String) {
    self.requestToken = requestToken
    self.returnUrl = returnUrl
  }

}

public final class Room {

  public var mid: String

  public var createdTime: Int64

  public var contacts: TList<Contact>

  public var notificationDisabled: Bool


  public init(mid: String, createdTime: Int64, contacts: TList<Contact>, notificationDisabled: Bool) {
    self.mid = mid
    self.createdTime = createdTime
    self.contacts = contacts
    self.notificationDisabled = notificationDisabled
  }

}

public final class RSAKey {

  public var keynm: String

  public var nvalue: String

  public var evalue: String

  public var sessionKey: String


  public init(keynm: String, nvalue: String, evalue: String, sessionKey: String) {
    self.keynm = keynm
    self.nvalue = nvalue
    self.evalue = evalue
    self.sessionKey = sessionKey
  }

}

public final class SendBuddyMessageResult {

  public var requestId: String

  public var state: BuddyResultState

  public var messageId: String

  public var eventNo: Int32

  public var receiverCount: Int64

  public var successCount: Int64

  public var failCount: Int64

  public var cancelCount: Int64

  public var blockCount: Int64

  public var unregisterCount: Int64

  public var timestamp: Int64

  public var message: String


  public init(requestId: String, state: BuddyResultState, messageId: String, eventNo: Int32, receiverCount: Int64, successCount: Int64, failCount: Int64, cancelCount: Int64, blockCount: Int64, unregisterCount: Int64, timestamp: Int64, message: String) {
    self.requestId = requestId
    self.state = state
    self.messageId = messageId
    self.eventNo = eventNo
    self.receiverCount = receiverCount
    self.successCount = successCount
    self.failCount = failCount
    self.cancelCount = cancelCount
    self.blockCount = blockCount
    self.unregisterCount = unregisterCount
    self.timestamp = timestamp
    self.message = message
  }

}

public final class SetBuddyOnAirResult {

  public var requestId: String

  public var state: BuddyResultState

  public var eventNo: Int32

  public var receiverCount: Int64

  public var successCount: Int64

  public var failCount: Int64

  public var cancelCount: Int64

  public var unregisterCount: Int64

  public var timestamp: Int64

  public var message: String


  public init(requestId: String, state: BuddyResultState, eventNo: Int32, receiverCount: Int64, successCount: Int64, failCount: Int64, cancelCount: Int64, unregisterCount: Int64, timestamp: Int64, message: String) {
    self.requestId = requestId
    self.state = state
    self.eventNo = eventNo
    self.receiverCount = receiverCount
    self.successCount = successCount
    self.failCount = failCount
    self.cancelCount = cancelCount
    self.unregisterCount = unregisterCount
    self.timestamp = timestamp
    self.message = message
  }

}

public final class Settings {

  public var notificationEnable: Bool

  public var notificationMuteExpiration: Int64

  public var notificationNewMessage: Bool

  public var notificationGroupInvitation: Bool

  public var notificationShowMessage: Bool

  public var notificationIncomingCall: Bool

  public var notificationSoundMessage: String

  public var notificationSoundGroup: String

  public var notificationDisabledWithSub: Bool

  public var privacySyncContacts: Bool

  public var privacySearchByPhoneNumber: Bool

  public var privacySearchByUserid: Bool

  public var privacySearchByEmail: Bool

  public var privacyAllowSecondaryDeviceLogin: Bool

  public var privacyProfileImagePostToMyhome: Bool

  public var privacyReceiveMessagesFromNotFriend: Bool

  public var contactMyTicket: String

  public var identityProvider: IdentityProvider

  public var identityIdentifier: String

  public var snsAccounts: TMap<SnsIdType, String>

  public var phoneRegistration: Bool

  public var emailConfirmationStatus: EmailConfirmationStatus

  public var preferenceLocale: String

  public var customModes: TMap<CustomMode, String>


  public init(notificationEnable: Bool, notificationMuteExpiration: Int64, notificationNewMessage: Bool, notificationGroupInvitation: Bool, notificationShowMessage: Bool, notificationIncomingCall: Bool, notificationSoundMessage: String, notificationSoundGroup: String, notificationDisabledWithSub: Bool, privacySyncContacts: Bool, privacySearchByPhoneNumber: Bool, privacySearchByUserid: Bool, privacySearchByEmail: Bool, privacyAllowSecondaryDeviceLogin: Bool, privacyProfileImagePostToMyhome: Bool, privacyReceiveMessagesFromNotFriend: Bool, contactMyTicket: String, identityProvider: IdentityProvider, identityIdentifier: String, snsAccounts: TMap<SnsIdType, String>, phoneRegistration: Bool, emailConfirmationStatus: EmailConfirmationStatus, preferenceLocale: String, customModes: TMap<CustomMode, String>) {
    self.notificationEnable = notificationEnable
    self.notificationMuteExpiration = notificationMuteExpiration
    self.notificationNewMessage = notificationNewMessage
    self.notificationGroupInvitation = notificationGroupInvitation
    self.notificationShowMessage = notificationShowMessage
    self.notificationIncomingCall = notificationIncomingCall
    self.notificationSoundMessage = notificationSoundMessage
    self.notificationSoundGroup = notificationSoundGroup
    self.notificationDisabledWithSub = notificationDisabledWithSub
    self.privacySyncContacts = privacySyncContacts
    self.privacySearchByPhoneNumber = privacySearchByPhoneNumber
    self.privacySearchByUserid = privacySearchByUserid
    self.privacySearchByEmail = privacySearchByEmail
    self.privacyAllowSecondaryDeviceLogin = privacyAllowSecondaryDeviceLogin
    self.privacyProfileImagePostToMyhome = privacyProfileImagePostToMyhome
    self.privacyReceiveMessagesFromNotFriend = privacyReceiveMessagesFromNotFriend
    self.contactMyTicket = contactMyTicket
    self.identityProvider = identityProvider
    self.identityIdentifier = identityIdentifier
    self.snsAccounts = snsAccounts
    self.phoneRegistration = phoneRegistration
    self.emailConfirmationStatus = emailConfirmationStatus
    self.preferenceLocale = preferenceLocale
    self.customModes = customModes
  }

}

public final class SimpleChannelClient {

  public var applicationType: String

  public var applicationVersion: String

  public var locale: String


  public init(applicationType: String, applicationVersion: String, locale: String) {
    self.applicationType = applicationType
    self.applicationVersion = applicationVersion
    self.locale = locale
  }

}

public final class SimpleChannelContact {

  public var mid: String

  public var displayName: String

  public var pictureStatus: String

  public var picturePath: String

  public var statusMessage: String


  public init(mid: String, displayName: String, pictureStatus: String, picturePath: String, statusMessage: String) {
    self.mid = mid
    self.displayName = displayName
    self.pictureStatus = pictureStatus
    self.picturePath = picturePath
    self.statusMessage = statusMessage
  }

}

public final class SnsFriend {

  public var snsUserId: String

  public var snsUserName: String

  public var snsIdType: SnsIdType


  public init(snsUserId: String, snsUserName: String, snsIdType: SnsIdType) {
    self.snsUserId = snsUserId
    self.snsUserName = snsUserName
    self.snsIdType = snsIdType
  }

}

public final class SnsFriendContactRegistration {

  public var contact: Contact

  public var snsIdType: SnsIdType

  public var snsUserId: String


  public init(contact: Contact, snsIdType: SnsIdType, snsUserId: String) {
    self.contact = contact
    self.snsIdType = snsIdType
    self.snsUserId = snsUserId
  }

}

public final class SnsFriendModification {

  public var type: ModificationType

  public var snsFriend: SnsFriend


  public init(type: ModificationType, snsFriend: SnsFriend) {
    self.type = type
    self.snsFriend = snsFriend
  }

}

public final class SnsFriends {

  public var snsFriends: TList<SnsFriend>

  public var hasMore: Bool


  public init(snsFriends: TList<SnsFriend>, hasMore: Bool) {
    self.snsFriends = snsFriends
    self.hasMore = hasMore
  }

}

public final class SnsIdUserStatus {

  public var userExisting: Bool

  public var phoneNumberRegistered: Bool

  public var sameDevice: Bool


  public init(userExisting: Bool, phoneNumberRegistered: Bool, sameDevice: Bool) {
    self.userExisting = userExisting
    self.phoneNumberRegistered = phoneNumberRegistered
    self.sameDevice = sameDevice
  }

}

public final class SnsProfile {

  public var snsUserId: String

  public var snsUserName: String

  public var email: String

  public var thumbnailUrl: String


  public init(snsUserId: String, snsUserName: String, email: String, thumbnailUrl: String) {
    self.snsUserId = snsUserId
    self.snsUserName = snsUserName
    self.email = email
    self.thumbnailUrl = thumbnailUrl
  }

}

public final class SystemConfiguration {

  public var endpoint: String

  public var endpointSsl: String

  public var updateUrl: String

  public var c2dmAccount: String

  public var nniServer: String


  public init(endpoint: String, endpointSsl: String, updateUrl: String, c2dmAccount: String, nniServer: String) {
    self.endpoint = endpoint
    self.endpointSsl = endpointSsl
    self.updateUrl = updateUrl
    self.c2dmAccount = c2dmAccount
    self.nniServer = nniServer
  }

}

public final class TalkException : Swift.Error {

  public var code: ErrorCode

  public var reason: String

  public var parameterMap: TMap<String, String>


  public init(code: ErrorCode, reason: String, parameterMap: TMap<String, String>) {
    self.code = code
    self.reason = reason
    self.parameterMap = parameterMap
  }

}

public final class Ticket {

  public var id: String

  public var expirationTime: Int64

  public var maxUseCount: Int32


  public init(id: String, expirationTime: Int64, maxUseCount: Int32) {
    self.id = id
    self.expirationTime = expirationTime
    self.maxUseCount = maxUseCount
  }

}

public final class TMessageBox {

  public var id: String

  public var channelId: String

  public var lastSeq: Int64

  public var unreadCount: Int64

  public var lastModifiedTime: Int64

  public var status: Int32

  public var midType: MIDType

  public var lastMessages: TList<Message>


  public init(id: String, channelId: String, lastSeq: Int64, unreadCount: Int64, lastModifiedTime: Int64, status: Int32, midType: MIDType, lastMessages: TList<Message>) {
    self.id = id
    self.channelId = channelId
    self.lastSeq = lastSeq
    self.unreadCount = unreadCount
    self.lastModifiedTime = lastModifiedTime
    self.status = status
    self.midType = midType
    self.lastMessages = lastMessages
  }

}

public final class TMessageBoxWrapUp {

  public var messageBox: TMessageBox

  public var name: String

  public var contacts: TList<Contact>

  public var pictureRevision: String


  public init(messageBox: TMessageBox, name: String, contacts: TList<Contact>, pictureRevision: String) {
    self.messageBox = messageBox
    self.name = name
    self.contacts = contacts
    self.pictureRevision = pictureRevision
  }

}

public final class TMessageBoxWrapUpResponse {

  public var messageBoxWrapUpList: TList<TMessageBoxWrapUp>

  public var totalSize: Int32


  public init(messageBoxWrapUpList: TList<TMessageBoxWrapUp>, totalSize: Int32) {
    self.messageBoxWrapUpList = messageBoxWrapUpList
    self.totalSize = totalSize
  }

}

public final class UniversalNotificationServiceException : Swift.Error {

  public var code: UniversalNotificationServiceErrorCode

  public var reason: String

  public var parameterMap: TMap<String, String>


  public init(code: UniversalNotificationServiceErrorCode, reason: String, parameterMap: TMap<String, String>) {
    self.code = code
    self.reason = reason
    self.parameterMap = parameterMap
  }

}

public final class UpdateBuddyProfileResult {

  public var requestId: String

  public var state: BuddyResultState

  public var eventNo: Int32

  public var receiverCount: Int64

  public var successCount: Int64

  public var failCount: Int64

  public var cancelCount: Int64

  public var unregisterCount: Int64

  public var timestamp: Int64

  public var message: String


  public init(requestId: String, state: BuddyResultState, eventNo: Int32, receiverCount: Int64, successCount: Int64, failCount: Int64, cancelCount: Int64, unregisterCount: Int64, timestamp: Int64, message: String) {
    self.requestId = requestId
    self.state = state
    self.eventNo = eventNo
    self.receiverCount = receiverCount
    self.successCount = successCount
    self.failCount = failCount
    self.cancelCount = cancelCount
    self.unregisterCount = unregisterCount
    self.timestamp = timestamp
    self.message = message
  }

}

public final class UserAuthStatus {

  public var phoneNumberRegistered: Bool

  public var registeredSnsIdTypes: TList<SnsIdType>


  public init(phoneNumberRegistered: Bool, registeredSnsIdTypes: TList<SnsIdType>) {
    self.phoneNumberRegistered = phoneNumberRegistered
    self.registeredSnsIdTypes = registeredSnsIdTypes
  }

}

public final class VerificationSessionData {

  public var sessionId: String

  public var method: VerificationMethod

  public var callback: String

  public var normalizedPhone: String

  public var countryCode: String

  public var nationalSignificantNumber: String

  public var availableVerificationMethods: TList<VerificationMethod>


  public init(sessionId: String, method: VerificationMethod, callback: String, normalizedPhone: String, countryCode: String, nationalSignificantNumber: String, availableVerificationMethods: TList<VerificationMethod>) {
    self.sessionId = sessionId
    self.method = method
    self.callback = callback
    self.normalizedPhone = normalizedPhone
    self.countryCode = countryCode
    self.nationalSignificantNumber = nationalSignificantNumber
    self.availableVerificationMethods = availableVerificationMethods
  }

}

public final class WapInvitation {

  public var type: WapInvitationType

  public var inviteeEmail: String

  public var inviterMid: String

  public var roomMid: String


  public init(type: WapInvitationType, inviteeEmail: String, inviterMid: String, roomMid: String) {
    self.type = type
    self.inviteeEmail = inviteeEmail
    self.inviterMid = inviterMid
    self.roomMid = roomMid
  }

}

public protocol AccountSupervisorService {

  ///
  /// - Returns: RSAKey
  /// - Throws: TalkException
  func getRSAKey() throws -> RSAKey

  ///
  /// - Parameters:
  ///   - parameterMap: 
  /// - Throws: TalkException
  func notifyEmailConfirmationResult(parameterMap: TMap<String, String>) throws

  ///
  /// - Parameters:
  ///   - locale: 
  ///   - encryptedVirtualUserId: 
  ///   - encryptedPassword: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerVirtualAccount(locale: String, encryptedVirtualUserId: String, encryptedPassword: String) throws -> String

  ///
  /// - Parameters:
  ///   - virtualMid: 
  ///   - encryptedVirtualUserId: 
  ///   - encryptedOldPassword: 
  ///   - encryptedNewPassword: 
  /// - Throws: TalkException
  func requestVirtualAccountPasswordChange(virtualMid: String, encryptedVirtualUserId: String, encryptedOldPassword: String, encryptedNewPassword: String) throws

  ///
  /// - Parameters:
  ///   - virtualMid: 
  ///   - encryptedVirtualUserId: 
  ///   - encryptedNewPassword: 
  /// - Throws: TalkException
  func requestVirtualAccountPasswordSet(virtualMid: String, encryptedVirtualUserId: String, encryptedNewPassword: String) throws

  ///
  /// - Parameters:
  ///   - virtualMid: 
  /// - Throws: TalkException
  func unregisterVirtualAccount(virtualMid: String) throws

}

open class AccountSupervisorServiceClient : TClient /* , AccountSupervisorService */ {

}

open class AccountSupervisorServiceProcessor /* AccountSupervisorService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, AccountSupervisorService) throws -> Void]

  public var service: AccountSupervisorService

  public required init(service: AccountSupervisorService) {
    self.service = service
  }

}

public protocol AgeCheckService {

  ///
  /// - Parameters:
  ///   - carrier: 
  ///   - sessionId: 
  ///   - verifier: 
  ///   - standardAge: 
  /// - Returns: UserAgeType
  /// - Throws: TalkException
  func checkUserAge(carrier: CarrierCode, sessionId: String, verifier: String, standardAge: Int32) throws -> UserAgeType

  ///
  /// - Parameters:
  ///   - openIdRedirectUrl: 
  ///   - standardAge: 
  ///   - verifier: 
  /// - Returns: AgeCheckDocomoResult
  /// - Throws: TalkException
  func checkUserAgeWithDocomo(openIdRedirectUrl: String, standardAge: Int32, verifier: String) throws -> AgeCheckDocomoResult

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func retrieveOpenIdAuthUrlWithDocomo() throws -> String

  ///
  /// - Parameters:
  ///   - carrier: 
  /// - Returns: AgeCheckRequestResult
  /// - Throws: TalkException
  func retrieveRequestToken(carrier: CarrierCode) throws -> AgeCheckRequestResult

}

open class AgeCheckServiceClient : TClient /* , AgeCheckService */ {

}

open class AgeCheckServiceProcessor /* AgeCheckService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, AgeCheckService) throws -> Void]

  public var service: AgeCheckService

  public required init(service: AgeCheckService) {
    self.service = service
  }

}

public protocol BuddyManagementService {

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - userMid: 
  /// - Throws: TalkException
  func addBuddyMember(requestId: String, userMid: String) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - userMids: 
  /// - Throws: TalkException
  func addBuddyMembers(requestId: String, userMids: TList<String>) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - mid: 
  /// - Throws: TalkException
  func blockBuddyMember(requestId: String, mid: String) throws

  ///
  /// - Parameters:
  ///   - requestIdList: 
  /// - Returns: TList<SendBuddyMessageResult>
  /// - Throws: TalkException
  func commitSendMessagesToAll(requestIdList: TList<String>) throws -> TList<SendBuddyMessageResult>

  ///
  /// - Parameters:
  ///   - requestIdList: 
  ///   - mids: 
  /// - Returns: TList<SendBuddyMessageResult>
  /// - Throws: TalkException
  func commitSendMessagesToMids(requestIdList: TList<String>, mids: TList<String>) throws -> TList<SendBuddyMessageResult>

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - userMid: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func containsBuddyMember(requestId: String, userMid: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - messageId: 
  /// - Returns: Data
  /// - Throws: TalkException
  func downloadMessageContent(requestId: String, messageId: String) throws -> Data

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - messageId: 
  /// - Returns: Data
  /// - Throws: TalkException
  func downloadMessageContentPreview(requestId: String, messageId: String) throws -> Data

  ///
  /// - Parameters:
  ///   - requestId: 
  /// - Returns: Data
  /// - Throws: TalkException
  func downloadProfileImage(requestId: String) throws -> Data

  ///
  /// - Parameters:
  ///   - requestId: 
  /// - Returns: Data
  /// - Throws: TalkException
  func downloadProfileImagePreview(requestId: String) throws -> Data

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: Int64
  /// - Throws: TalkException
  func getActiveMemberCountByBuddyMid(buddyMid: String) throws -> Int64

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getActiveMemberMidsByBuddyMid(buddyMid: String) throws -> TList<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getAllBuddyMembers() throws -> TList<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getBlockedBuddyMembers() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: Int64
  /// - Throws: TalkException
  func getBlockerCountByBuddyMid(buddyMid: String) throws -> Int64

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: BuddyDetail
  /// - Throws: TalkException
  func getBuddyDetailByMid(buddyMid: String) throws -> BuddyDetail

  ///
  /// - Returns: BuddyProfile
  /// - Throws: TalkException
  func getBuddyProfile() throws -> BuddyProfile

  ///
  /// - Returns: Ticket
  /// - Throws: TalkException
  func getContactTicket() throws -> Ticket

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: Int64
  /// - Throws: TalkException
  func getMemberCountByBuddyMid(buddyMid: String) throws -> Int64

  ///
  /// - Parameters:
  ///   - sendBuddyMessageRequestId: 
  /// - Returns: SendBuddyMessageResult
  /// - Throws: TalkException
  func getSendBuddyMessageResult(sendBuddyMessageRequestId: String) throws -> SendBuddyMessageResult

  ///
  /// - Parameters:
  ///   - setBuddyOnAirRequestId: 
  /// - Returns: SetBuddyOnAirResult
  /// - Throws: TalkException
  func getSetBuddyOnAirResult(setBuddyOnAirRequestId: String) throws -> SetBuddyOnAirResult

  ///
  /// - Parameters:
  ///   - updateBuddyProfileRequestId: 
  /// - Returns: UpdateBuddyProfileResult
  /// - Throws: TalkException
  func getUpdateBuddyProfileResult(updateBuddyProfileRequestId: String) throws -> UpdateBuddyProfileResult

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func isBuddyOnAirByMid(buddyMid: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - sourceContentId: 
  /// - Returns: String
  /// - Throws: TalkException
  func linkAndSendBuddyContentMessageToAllAsync(requestId: String, msg: Message, sourceContentId: String) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - sourceContentId: 
  ///   - mids: 
  /// - Returns: SendBuddyMessageResult
  /// - Throws: TalkException
  func linkAndSendBuddyContentMessageToMids(requestId: String, msg: Message, sourceContentId: String, mids: TList<String>) throws -> SendBuddyMessageResult

  ///
  /// - Parameters:
  ///   - buddyMid: 
  ///   - blockerMid: 
  /// - Throws: TalkException
  func notifyBuddyBlocked(buddyMid: String, blockerMid: String) throws

  ///
  /// - Parameters:
  ///   - buddyMid: 
  ///   - blockerMid: 
  /// - Throws: TalkException
  func notifyBuddyUnblocked(buddyMid: String, blockerMid: String) throws

  ///
  /// - Parameters:
  ///   - buddyId: 
  ///   - searchId: 
  ///   - displayName: 
  ///   - statusMeessage: 
  ///   - picture: 
  ///   - settings: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerBuddy(buddyId: String, searchId: String, displayName: String, statusMeessage: String, picture: Data, settings: TMap<String, String>) throws -> String

  ///
  /// - Parameters:
  ///   - buddyId: 
  ///   - searchId: 
  ///   - displayName: 
  ///   - statusMessage: 
  ///   - picture: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerBuddyAdmin(buddyId: String, searchId: String, displayName: String, statusMessage: String, picture: Data) throws -> String

  ///
  /// - Parameters:
  ///   - expirationTime: 
  ///   - maxUseCount: 
  /// - Returns: String
  /// - Throws: TalkException
  func reissueContactTicket(expirationTime: Int64, maxUseCount: Int32) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - userMid: 
  /// - Throws: TalkException
  func removeBuddyMember(requestId: String, userMid: String) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - userMids: 
  /// - Throws: TalkException
  func removeBuddyMembers(requestId: String, userMids: TList<String>) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - content: 
  /// - Returns: SendBuddyMessageResult
  /// - Throws: TalkException
  func sendBuddyContentMessageToAll(requestId: String, msg: Message, content: Data) throws -> SendBuddyMessageResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - content: 
  /// - Returns: String
  /// - Throws: TalkException
  func sendBuddyContentMessageToAllAsync(requestId: String, msg: Message, content: Data) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - content: 
  ///   - mids: 
  /// - Returns: SendBuddyMessageResult
  /// - Throws: TalkException
  func sendBuddyContentMessageToMids(requestId: String, msg: Message, content: Data, mids: TList<String>) throws -> SendBuddyMessageResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - content: 
  ///   - mids: 
  /// - Returns: String
  /// - Throws: TalkException
  func sendBuddyContentMessageToMidsAsync(requestId: String, msg: Message, content: Data, mids: TList<String>) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  /// - Returns: SendBuddyMessageResult
  /// - Throws: TalkException
  func sendBuddyMessageToAll(requestId: String, msg: Message) throws -> SendBuddyMessageResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  /// - Returns: String
  /// - Throws: TalkException
  func sendBuddyMessageToAllAsync(requestId: String, msg: Message) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - mids: 
  /// - Returns: SendBuddyMessageResult
  /// - Throws: TalkException
  func sendBuddyMessageToMids(requestId: String, msg: Message, mids: TList<String>) throws -> SendBuddyMessageResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - msg: 
  ///   - mids: 
  /// - Returns: String
  /// - Throws: TalkException
  func sendBuddyMessageToMidsAsync(requestId: String, msg: Message, mids: TList<String>) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - buddyMid: 
  ///   - notificationStatus: 
  /// - Throws: TalkException
  func sendIndividualEventToAllAsync(requestId: String, buddyMid: String, notificationStatus: NotificationStatus) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - onAir: 
  /// - Returns: SetBuddyOnAirResult
  /// - Throws: TalkException
  func setBuddyOnAir(requestId: String, onAir: Bool) throws -> SetBuddyOnAirResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - onAir: 
  /// - Returns: String
  /// - Throws: TalkException
  func setBuddyOnAirAsync(requestId: String, onAir: Bool) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - messageRequest: 
  /// - Returns: SendBuddyMessageResult
  /// - Throws: TalkException
  func storeMessage(requestId: String, messageRequest: BuddyMessageRequest) throws -> SendBuddyMessageResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - mid: 
  /// - Throws: TalkException
  func unblockBuddyMember(requestId: String, mid: String) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  /// - Throws: TalkException
  func unregisterBuddy(requestId: String) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  /// - Throws: TalkException
  func unregisterBuddyAdmin(requestId: String) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - attributes: 
  /// - Throws: TalkException
  func updateBuddyAdminProfileAttribute(requestId: String, attributes: TMap<String, String>) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - picture: 
  /// - Throws: TalkException
  func updateBuddyAdminProfileImage(requestId: String, picture: Data) throws

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - attributes: 
  /// - Returns: UpdateBuddyProfileResult
  /// - Throws: TalkException
  func updateBuddyProfileAttributes(requestId: String, attributes: TMap<String, String>) throws -> UpdateBuddyProfileResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - attributes: 
  /// - Returns: String
  /// - Throws: TalkException
  func updateBuddyProfileAttributesAsync(requestId: String, attributes: TMap<String, String>) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - image: 
  /// - Returns: UpdateBuddyProfileResult
  /// - Throws: TalkException
  func updateBuddyProfileImage(requestId: String, image: Data) throws -> UpdateBuddyProfileResult

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - image: 
  /// - Returns: String
  /// - Throws: TalkException
  func updateBuddyProfileImageAsync(requestId: String, image: Data) throws -> String

  ///
  /// - Parameters:
  ///   - requestId: 
  ///   - searchId: 
  /// - Throws: TalkException
  func updateBuddySearchId(requestId: String, searchId: String) throws

  ///
  /// - Parameters:
  ///   - settings: 
  /// - Throws: TalkException
  func updateBuddySettings(settings: TMap<String, String>) throws

  ///
  /// - Parameters:
  ///   - contentType: 
  ///   - content: 
  /// - Returns: String
  /// - Throws: TalkException
  func uploadBuddyContent(contentType: ContentType, content: Data) throws -> String

}

open class BuddyManagementServiceClient : TClient /* , BuddyManagementService */ {

}

open class BuddyManagementServiceProcessor /* BuddyManagementService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, BuddyManagementService) throws -> Void]

  public var service: BuddyManagementService

  public required init(service: BuddyManagementService) {
    self.service = service
  }

}

public protocol BuddyService {

  ///
  /// - Parameters:
  ///   - language: 
  ///   - country: 
  ///   - query: 
  ///   - fromIndex: 
  ///   - count: 
  ///   - requestSource: 
  /// - Returns: TList<BuddySearchResult>
  /// - Throws: TalkException
  func findBuddyContactsByQuery(language: String, country: String, query: String, fromIndex: Int32, count: Int32, requestSource: BuddySearchRequestSource) throws -> TList<BuddySearchResult>

  ///
  /// - Parameters:
  ///   - language: 
  ///   - country: 
  ///   - classification: 
  ///   - fromIndex: 
  ///   - count: 
  /// - Returns: TList<Contact>
  /// - Throws: TalkException
  func getBuddyContacts(language: String, country: String, classification: String, fromIndex: Int32, count: Int32) throws -> TList<Contact>

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: BuddyDetail
  /// - Throws: TalkException
  func getBuddyDetail(buddyMid: String) throws -> BuddyDetail

  ///
  /// - Parameters:
  ///   - buddyMid: 
  /// - Returns: BuddyOnAir
  /// - Throws: TalkException
  func getBuddyOnAir(buddyMid: String) throws -> BuddyOnAir

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getCountriesHavingBuddy() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - country: 
  /// - Returns: TMap<String, Int64>
  /// - Throws: TalkException
  func getNewlyReleasedBuddyIds(country: String) throws -> TMap<String, Int64>

  ///
  /// - Parameters:
  ///   - language: 
  ///   - country: 
  ///   - applicationType: 
  ///   - resourceSpecification: 
  /// - Returns: BuddyBanner
  /// - Throws: TalkException
  func getPopularBuddyBanner(language: String, country: String, applicationType: ApplicationType, resourceSpecification: String) throws -> BuddyBanner

  ///
  /// - Parameters:
  ///   - language: 
  ///   - country: 
  /// - Returns: TList<BuddyList>
  /// - Throws: TalkException
  func getPopularBuddyLists(language: String, country: String) throws -> TList<BuddyList>

  ///
  /// - Parameters:
  ///   - language: 
  ///   - country: 
  /// - Returns: TList<Contact>
  /// - Throws: TalkException
  func getPromotedBuddyContacts(language: String, country: String) throws -> TList<Contact>

}

open class BuddyServiceClient : TClient /* , BuddyService */ {

}

open class BuddyServiceProcessor /* BuddyService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, BuddyService) throws -> Void]

  public var service: BuddyService

  public required init(service: BuddyService) {
    self.service = service
  }

}

public protocol ChannelApplicationProvidedService {

  ///
  /// - Returns: Int64
  /// - Throws: TalkException
  func activeBuddySubscriberCount() throws -> Int64

  ///
  /// - Parameters:
  ///   - opType: 
  ///   - param1: 
  ///   - param2: 
  ///   - param3: 
  /// - Throws: TalkException
  func addOperationForChannel(opType: OpType, param1: String, param2: String, param3: String) throws

  ///
  /// - Returns: Int64
  /// - Throws: TalkException
  func displayBuddySubscriberCount() throws -> Int64

  ///
  /// - Parameters:
  ///   - userid: 
  /// - Returns: Contact
  /// - Throws: TalkException
  func findContactByUseridWithoutAbuseBlockForChannel(userid: String) throws -> Contact

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getAllContactIdsForChannel() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - lastModifiedTimestamp: 
  /// - Returns: TList<CompactContact>
  /// - Throws: TalkException
  func getCompactContacts(lastModifiedTimestamp: Int64) throws -> TList<CompactContact>

  ///
  /// - Parameters:
  ///   - ids: 
  /// - Returns: TList<Contact>
  /// - Throws: TalkException
  func getContactsForChannel(ids: TList<String>) throws -> TList<Contact>

  ///
  /// - Parameters:
  ///   - mid: 
  /// - Returns: String
  /// - Throws: TalkException
  func getDisplayName(mid: String) throws -> String

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getFavoriteMidsForChannel() throws -> TList<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getFriendMids() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - groupId: 
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getGroupMemberMids(groupId: String) throws -> TList<String>

  ///
  /// - Parameters:
  ///   - groupIds: 
  /// - Returns: TList<Group>
  /// - Throws: TalkException
  func getGroupsForChannel(groupIds: TList<String>) throws -> TList<Group>

  ///
  /// - Returns: IdentityCredential
  /// - Throws: TalkException
  func getIdentityCredential() throws -> IdentityCredential

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getJoinedGroupIdsForChannel() throws -> TList<String>

  ///
  /// - Returns: MetaProfile
  /// - Throws: TalkException
  func getMetaProfile() throws -> MetaProfile

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func getMid() throws -> String

  ///
  /// - Returns: SimpleChannelClient
  /// - Throws: TalkException
  func getPrimaryClientForChannel() throws -> SimpleChannelClient

  ///
  /// - Returns: Profile
  /// - Throws: TalkException
  func getProfileForChannel() throws -> Profile

  ///
  /// - Parameters:
  ///   - ids: 
  /// - Returns: TList<SimpleChannelContact>
  /// - Throws: TalkException
  func getSimpleChannelContacts(ids: TList<String>) throws -> TList<SimpleChannelContact>

  ///
  /// - Parameters:
  ///   - country: 
  ///   - remoteIp: 
  /// - Returns: String
  /// - Throws: TalkException
  func getUserCountryForBilling(country: String, remoteIp: String) throws -> String

  ///
  /// - Returns: Int64
  /// - Throws: TalkException
  func getUserCreateTime() throws -> Int64

  ///
  /// - Returns: TMap<RegistrationType, String>
  /// - Throws: TalkException
  func getUserIdentities() throws -> TMap<RegistrationType, String>

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func getUserLanguage() throws -> String

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getUserMidsWhoAddedMe() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - groupId: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func isGroupMember(groupId: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - mid: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func isInContact(mid: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - cpId: 
  ///   - registerPassword: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerChannelCP(cpId: String, registerPassword: String) throws -> String

  ///
  /// - Parameters:
  ///   - notificationStatus: 
  /// - Throws: TalkException
  func removeNotificationStatus(notificationStatus: NotificationStatus) throws

  ///
  /// - Parameters:
  ///   - message: 
  /// - Returns: Message
  /// - Throws: TalkException
  func sendMessageForChannel(message: Message) throws -> Message

  ///
  /// - Parameters:
  ///   - verifier: 
  /// - Throws: TalkException
  func sendPinCodeOperation(verifier: String) throws

  ///
  /// - Parameters:
  ///   - profileAttribute: 
  ///   - value: 
  /// - Throws: TalkException
  func updateProfileAttributeForChannel(profileAttribute: ProfileAttribute, value: String) throws

}

open class ChannelApplicationProvidedServiceClient : TClient /* , ChannelApplicationProvidedService */ {

}

open class ChannelApplicationProvidedServiceProcessor /* ChannelApplicationProvidedService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, ChannelApplicationProvidedService) throws -> Void]

  public var service: ChannelApplicationProvidedService

  public required init(service: ChannelApplicationProvidedService) {
    self.service = service
  }

}

public protocol ChannelService {

  ///
  /// - Parameters:
  ///   - channelId: 
  /// - Returns: ChannelToken
  /// - Throws: ChannelException
  func approveChannelAndIssueChannelToken(channelId: String) throws -> ChannelToken

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - otpId: 
  /// - Returns: String
  /// - Throws: ChannelException
  func approveChannelAndIssueRequestToken(channelId: String, otpId: String) throws -> String

  ///
  /// - Parameters:
  ///   - localRev: 
  /// - Returns: NotificationFetchResult
  /// - Throws: ChannelException
  func fetchNotificationItems(localRev: Int64) throws -> NotificationFetchResult

  ///
  /// - Parameters:
  ///   - lastSynced: 
  ///   - locale: 
  /// - Returns: ApprovedChannelInfos
  /// - Throws: ChannelException
  func getApprovedChannels(lastSynced: Int64, locale: String) throws -> ApprovedChannelInfos

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - locale: 
  /// - Returns: ChannelInfo
  /// - Throws: ChannelException
  func getChannelInfo(channelId: String, locale: String) throws -> ChannelInfo

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - locale: 
  /// - Returns: ChannelNotificationSetting
  /// - Throws: ChannelException
  func getChannelNotificationSetting(channelId: String, locale: String) throws -> ChannelNotificationSetting

  ///
  /// - Parameters:
  ///   - locale: 
  /// - Returns: TList<ChannelNotificationSetting>
  /// - Throws: ChannelException
  func getChannelNotificationSettings(locale: String) throws -> TList<ChannelNotificationSetting>

  ///
  /// - Parameters:
  ///   - lastSynced: 
  ///   - locale: 
  /// - Returns: ChannelInfos
  /// - Throws: ChannelException
  func getChannels(lastSynced: Int64, locale: String) throws -> ChannelInfos

  ///
  /// - Parameters:
  ///   - lastSynced: 
  /// - Returns: ChannelDomains
  /// - Throws: ChannelException
  func getDomains(lastSynced: Int64) throws -> ChannelDomains

  ///
  /// - Parameters:
  ///   - channelIds: 
  /// - Returns: FriendChannelMatricesResponse
  /// - Throws: ChannelException
  func getFriendChannelMatrices(channelIds: TList<String>) throws -> FriendChannelMatricesResponse

  ///
  /// - Parameters:
  ///   - localRev: 
  /// - Returns: Int32
  /// - Throws: ChannelException
  func getNotificationBadgeCount(localRev: Int64) throws -> Int32

  ///
  /// - Parameters:
  ///   - channelId: 
  /// - Returns: ChannelToken
  /// - Throws: ChannelException
  func issueChannelToken(channelId: String) throws -> ChannelToken

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - otpId: 
  /// - Returns: String
  /// - Throws: ChannelException
  func issueRequestToken(channelId: String, otpId: String) throws -> String

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - otpId: 
  ///   - authScheme: 
  ///   - returnUrl: 
  /// - Returns: RequestTokenResponse
  /// - Throws: ChannelException
  func issueRequestTokenWithAuthScheme(channelId: String, otpId: String, authScheme: TList<String>, returnUrl: String) throws -> RequestTokenResponse

  ///
  /// - Parameters:
  ///   - request: 
  ///   - locale: 
  /// - Returns: String
  /// - Throws: ChannelException
  func reserveCoinUse(request: CoinUseReservation, locale: String) throws -> String

  ///
  /// - Parameters:
  ///   - channelId: 
  /// - Throws: ChannelException
  func revokeChannel(channelId: String) throws

  ///
  /// - Parameters:
  ///   - lastSynced: 
  ///   - locale: 
  /// - Returns: ChannelSyncDatas
  /// - Throws: ChannelException
  func syncChannelData(lastSynced: Int64, locale: String) throws -> ChannelSyncDatas

  ///
  /// - Parameters:
  ///   - setting: 
  /// - Throws: ChannelException
  func updateChannelNotificationSetting(setting: TList<ChannelNotificationSetting>) throws

}

open class ChannelServiceClient : TClient /* , ChannelService */ {

}

open class ChannelServiceProcessor /* ChannelService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, ChannelService) throws -> Void]

  public var service: ChannelService

  public required init(service: ChannelService) {
    self.service = service
  }

}

public protocol MessageService {

  ///
  /// - Parameters:
  ///   - localRevision: 
  ///   - lastOpTimestamp: 
  ///   - count: 
  /// - Returns: MessageOperations
  /// - Throws: TalkException
  func fetchMessageOperations(localRevision: Int64, lastOpTimestamp: Int64, count: Int32) throws -> MessageOperations

  ///
  /// - Parameters:
  ///   - chatId: 
  /// - Returns: LastReadMessageIds
  /// - Throws: TalkException
  func getLastReadMessageIds(chatId: String) throws -> LastReadMessageIds

  ///
  /// - Parameters:
  ///   - chatIds: 
  /// - Returns: TList<LastReadMessageIds>
  /// - Throws: TalkException
  func multiGetLastReadMessageIds(chatIds: TList<String>) throws -> TList<LastReadMessageIds>

}

open class MessageServiceClient : TClient /* , MessageService */ {

}

open class MessageServiceProcessor /* MessageService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, MessageService) throws -> Void]

  public var service: MessageService

  public required init(service: MessageService) {
    self.service = service
  }

}

public protocol ShopService {

  ///
  /// - Parameters:
  ///   - paymentReservation: 
  /// - Throws: TalkException
  func buyCoinProduct(paymentReservation: PaymentReservation) throws

  ///
  /// - Parameters:
  ///   - receiverMid: 
  ///   - productId: 
  ///   - messageTemplate: 
  ///   - language: 
  ///   - country: 
  ///   - packageId: 
  /// - Throws: TalkException
  func buyFreeProduct(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64) throws

  ///
  /// - Parameters:
  ///   - receiverMid: 
  ///   - productId: 
  ///   - messageTemplate: 
  ///   - language: 
  ///   - country: 
  ///   - packageId: 
  ///   - serialNumber: 
  /// - Throws: TalkException
  func buyMustbuyProduct(receiverMid: String, productId: String, messageTemplate: Int32, language: String, country: String, packageId: Int64, serialNumber: String) throws

  ///
  /// - Parameters:
  ///   - recipientMid: 
  ///   - packageId: 
  ///   - language: 
  ///   - country: 
  /// - Throws: TalkException
  func checkCanReceivePresent(recipientMid: String, packageId: Int64, language: String, country: String) throws

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getActivePurchases(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductSimpleList
  /// - Throws: TalkException
  func getActivePurchaseVersions(start: Int64, size: Int32, language: String, country: String) throws -> ProductSimpleList

  ///
  /// - Parameters:
  ///   - appStoreCode: 
  ///   - country: 
  ///   - language: 
  /// - Returns: TList<CoinProductItem>
  /// - Throws: TalkException
  func getCoinProducts(appStoreCode: PaymentType, country: String, language: String) throws -> TList<CoinProductItem>

  ///
  /// - Parameters:
  ///   - appStoreCode: 
  ///   - pgCode: 
  ///   - country: 
  ///   - language: 
  /// - Returns: TList<CoinProductItem>
  /// - Throws: TalkException
  func getCoinProductsByPgCode(appStoreCode: PaymentType, pgCode: PaymentPgType, country: String, language: String) throws -> TList<CoinProductItem>

  ///
  /// - Parameters:
  ///   - request: 
  /// - Returns: CoinHistoryResult
  /// - Throws: TalkException
  func getCoinPurchaseHistory(request: CoinHistoryCondition) throws -> CoinHistoryResult

  ///
  /// - Parameters:
  ///   - request: 
  /// - Returns: CoinHistoryResult
  /// - Throws: TalkException
  func getCoinUseAndRefundHistory(request: CoinHistoryCondition) throws -> CoinHistoryResult

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getDownloads(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getEventPackages(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getNewlyReleasedPackages(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getPopularPackages(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getPresentsReceived(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getPresentsSent(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - packageID: 
  ///   - language: 
  ///   - country: 
  /// - Returns: Product
  /// - Throws: TalkException
  func getProduct(packageID: Int64, language: String, country: String) throws -> Product

  ///
  /// - Parameters:
  ///   - productIdList: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getProductList(productIdList: TList<String>, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - productIdList: 
  ///   - language: 
  ///   - country: 
  ///   - carrierCode: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getProductListWithCarrier(productIdList: TList<String>, language: String, country: String, carrierCode: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - packageID: 
  ///   - language: 
  ///   - country: 
  ///   - carrierCode: 
  /// - Returns: Product
  /// - Throws: TalkException
  func getProductWithCarrier(packageID: Int64, language: String, country: String, carrierCode: String) throws -> Product

  ///
  /// - Parameters:
  ///   - start: 
  ///   - size: 
  ///   - language: 
  ///   - country: 
  /// - Returns: ProductList
  /// - Throws: TalkException
  func getPurchaseHistory(start: Int64, size: Int32, language: String, country: String) throws -> ProductList

  ///
  /// - Parameters:
  ///   - appStoreCode: 
  /// - Returns: Coin
  /// - Throws: TalkException
  func getTotalBalance(appStoreCode: PaymentType) throws -> Coin

  ///
  /// - Parameters:
  ///   - packageId: 
  ///   - language: 
  /// - Returns: Int64
  /// - Throws: TalkException
  func notifyDownloaded(packageId: Int64, language: String) throws -> Int64

  ///
  /// - Parameters:
  ///   - request: 
  /// - Returns: PaymentReservationResult
  /// - Throws: TalkException
  func reserveCoinPurchase(request: CoinPurchaseReservation) throws -> PaymentReservationResult

  ///
  /// - Parameters:
  ///   - paymentReservation: 
  /// - Returns: PaymentReservationResult
  /// - Throws: TalkException
  func reservePayment(paymentReservation: PaymentReservation) throws -> PaymentReservationResult

}

open class ShopServiceClient : TClient /* , ShopService */ {

}

open class ShopServiceProcessor /* ShopService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, ShopService) throws -> Void]

  public var service: ShopService

  public required init(service: ShopService) {
    self.service = service
  }

}

public protocol SnsAdaptorService {

  ///
  /// - Parameters:
  ///   - snsIdType: 
  ///   - snsAccessToken: 
  ///   - startIdx: 
  ///   - limit: 
  /// - Returns: SnsFriends
  /// - Throws: TalkException
  func getSnsFriends(snsIdType: SnsIdType, snsAccessToken: String, startIdx: Int32, limit: Int32) throws -> SnsFriends

  ///
  /// - Parameters:
  ///   - snsIdType: 
  ///   - snsAccessToken: 
  /// - Returns: SnsProfile
  /// - Throws: TalkException
  func getSnsMyProfile(snsIdType: SnsIdType, snsAccessToken: String) throws -> SnsProfile

  ///
  /// - Parameters:
  ///   - snsIdType: 
  ///   - snsAccessToken: 
  ///   - toSnsUserId: 
  /// - Throws: TalkException
  func postSnsInvitationMessage(snsIdType: SnsIdType, snsAccessToken: String, toSnsUserId: String) throws

}

open class SnsAdaptorServiceClient : TClient /* , SnsAdaptorService */ {

}

open class SnsAdaptorServiceProcessor /* SnsAdaptorService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, SnsAdaptorService) throws -> Void]

  public var service: SnsAdaptorService

  public required init(service: SnsAdaptorService) {
    self.service = service
  }

}

public protocol TalkService {

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - groupId: 
  /// - Throws: TalkException
  func acceptGroupInvitation(reqSeq: Int32, groupId: String) throws

  ///
  /// - Parameters:
  ///   - sessionId: 
  ///   - ids: 
  /// - Throws: TalkException
  func acceptProximityMatches(sessionId: String, ids: TSet<String>) throws

  ///
  /// - Parameters:
  ///   - to: 
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func acquireCallRoute(to: String) throws -> TList<String>

  ///
  /// - Parameters:
  ///   - to: 
  /// - Returns: String
  /// - Throws: TalkException
  func acquireCallTicket(to: String) throws -> String

  ///
  /// - Parameters:
  ///   - featureType: 
  /// - Returns: String
  /// - Throws: TalkException
  func acquireEncryptedAccessToken(featureType: FeatureType) throws -> String

  ///
  /// - Parameters:
  ///   - snsIdType: 
  ///   - snsAccessToken: 
  /// - Returns: String
  /// - Throws: TalkException
  func addSnsId(snsIdType: SnsIdType, snsAccessToken: String) throws -> String

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - id: 
  /// - Throws: TalkException
  func blockContact(reqSeq: Int32, id: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - id: 
  /// - Throws: TalkException
  func blockRecommendation(reqSeq: Int32, id: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - groupId: 
  ///   - contactIds: 
  /// - Throws: TalkException
  func cancelGroupInvitation(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws

  ///
  /// - Parameters:
  ///   - sessionId: 
  ///   - method: 
  /// - Returns: VerificationSessionData
  /// - Throws: TalkException
  func changeVerificationMethod(sessionId: String, method: VerificationMethod) throws -> VerificationSessionData

  ///
  /// - Throws: TalkException
  func clearIdentityCredential() throws

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - messageBoxId: 
  /// - Throws: TalkException
  func clearMessageBox(channelId: String, messageBoxId: String) throws

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Throws: TalkException
  func closeProximityMatch(sessionId: String) throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - messageId: 
  ///   - receiverMids: 
  /// - Returns: TMap<String, String>
  /// - Throws: TalkException
  func commitSendMessage(seq: Int32, messageId: String, receiverMids: TList<String>) throws -> TMap<String, String>

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - messageIds: 
  ///   - receiverMids: 
  /// - Returns: TMap<String, String>
  /// - Throws: TalkException
  func commitSendMessages(seq: Int32, messageIds: TList<String>, receiverMids: TList<String>) throws -> TMap<String, String>

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - attrs: 
  ///   - receiverMids: 
  /// - Returns: TMap<String, String>
  /// - Throws: TalkException
  func commitUpdateProfile(seq: Int32, attrs: TList<ProfileAttribute>, receiverMids: TList<String>) throws -> TMap<String, String>

  ///
  /// - Parameters:
  ///   - verifier: 
  ///   - pinCode: 
  /// - Throws: TalkException
  func confirmEmail(verifier: String, pinCode: String) throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - name: 
  ///   - contactIds: 
  /// - Returns: Group
  /// - Throws: TalkException
  func createGroup(seq: Int32, name: String, contactIds: TList<String>) throws -> Group

  ///
  /// - Parameters:
  ///   - url: 
  ///   - characterSet: 
  ///   - imageSize: 
  ///   - x: 
  ///   - y: 
  ///   - width: 
  ///   - height: 
  /// - Returns: String
  /// - Throws: TalkException
  func createQrcodeBase64Image(url: String, characterSet: String, imageSize: Int32, x: Int32, y: Int32, width: Int32, height: Int32) throws -> String

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - contactIds: 
  /// - Returns: Room
  /// - Throws: TalkException
  func createRoom(reqSeq: Int32, contactIds: TList<String>) throws -> Room

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func createSession() throws -> String

  ///
  /// - Parameters:
  ///   - lastFetchedIndex: 
  /// - Returns: TList<Announcement>
  /// - Throws: TalkException
  func fetchAnnouncements(lastFetchedIndex: Int32) throws -> TList<Announcement>

  ///
  /// - Parameters:
  ///   - localTs: 
  ///   - count: 
  /// - Returns: TList<Message>
  /// - Throws: TalkException
  func fetchMessages(localTs: Int64, count: Int32) throws -> TList<Message>

  ///
  /// - Parameters:
  ///   - localRev: 
  ///   - count: 
  /// - Returns: TList<Operation>
  /// - Throws: TalkException
  func fetchOperations(localRev: Int64, count: Int32) throws -> TList<Operation>

  ///
  /// - Parameters:
  ///   - localRev: 
  ///   - count: 
  ///   - globalRev: 
  ///   - individualRev: 
  /// - Returns: TList<Operation>
  /// - Throws: TalkException
  func fetchOps(localRev: Int64, count: Int32, globalRev: Int64, individualRev: Int64) throws -> TList<Operation>

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - emails: 
  /// - Returns: TMap<String, Contact>
  /// - Throws: TalkException
  func findAndAddContactsByEmail(reqSeq: Int32, emails: TSet<String>) throws -> TMap<String, Contact>

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - mid: 
  /// - Returns: TMap<String, Contact>
  /// - Throws: TalkException
  func findAndAddContactsByMid(reqSeq: Int32, mid: String) throws -> TMap<String, Contact>

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - phones: 
  /// - Returns: TMap<String, Contact>
  /// - Throws: TalkException
  func findAndAddContactsByPhone(reqSeq: Int32, phones: TSet<String>) throws -> TMap<String, Contact>

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - userid: 
  /// - Returns: TMap<String, Contact>
  /// - Throws: TalkException
  func findAndAddContactsByUserid(reqSeq: Int32, userid: String) throws -> TMap<String, Contact>

  ///
  /// - Parameters:
  ///   - userid: 
  /// - Returns: Contact
  /// - Throws: TalkException
  func findContactByUserid(userid: String) throws -> Contact

  ///
  /// - Parameters:
  ///   - ticketId: 
  /// - Returns: Contact
  /// - Throws: TalkException
  func findContactByUserTicket(ticketId: String) throws -> Contact

  ///
  /// - Parameters:
  ///   - emails: 
  /// - Returns: TMap<String, Contact>
  /// - Throws: TalkException
  func findContactsByEmail(emails: TSet<String>) throws -> TMap<String, Contact>

  ///
  /// - Parameters:
  ///   - phones: 
  /// - Returns: TMap<String, Contact>
  /// - Throws: TalkException
  func findContactsByPhone(phones: TSet<String>) throws -> TMap<String, Contact>

  ///
  /// - Parameters:
  ///   - snsIdType: 
  ///   - snsAccessToken: 
  ///   - udidHash: 
  /// - Returns: SnsIdUserStatus
  /// - Throws: TalkException
  func findSnsIdUserStatus(snsIdType: SnsIdType, snsAccessToken: String, udidHash: String) throws -> SnsIdUserStatus

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Throws: TalkException
  func finishUpdateVerification(sessionId: String) throws

  ///
  /// - Parameters:
  ///   - expirationTime: 
  ///   - maxUseCount: 
  /// - Returns: Ticket
  /// - Throws: TalkException
  func generateUserTicket(expirationTime: Int64, maxUseCount: Int32) throws -> Ticket

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Returns: TSet<String>
  /// - Throws: TalkException
  func getAcceptedProximityMatches(sessionId: String) throws -> TSet<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getActiveBuddySubscriberIds() throws -> TList<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getAllContactIds() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - keepLoggedIn: 
  ///   - systemName: 
  /// - Returns: AuthQrcode
  /// - Throws: TalkException
  func getAuthQrcode(keepLoggedIn: Bool, systemName: String) throws -> AuthQrcode

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getBlockedContactIds() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - start: 
  ///   - count: 
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getBlockedContactIdsByRange(start: Int32, count: Int32) throws -> TList<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getBlockedRecommendationIds() throws -> TList<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getBuddyBlockerIds() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - mid: 
  ///   - index: 
  /// - Returns: Geolocation
  /// - Throws: TalkException
  func getBuddyLocation(mid: String, index: Int32) throws -> Geolocation

  ///
  /// - Parameters:
  ///   - timestamp: 
  /// - Returns: TList<CompactContact>
  /// - Throws: TalkException
  func getCompactContactsModifiedSince(timestamp: Int64) throws -> TList<CompactContact>

  ///
  /// - Parameters:
  ///   - groupId: 
  /// - Returns: Group
  /// - Throws: TalkException
  func getCompactGroup(groupId: String) throws -> Group

  ///
  /// - Parameters:
  ///   - roomId: 
  /// - Returns: Room
  /// - Throws: TalkException
  func getCompactRoom(roomId: String) throws -> Room

  ///
  /// - Parameters:
  ///   - id: 
  /// - Returns: Contact
  /// - Throws: TalkException
  func getContact(id: String) throws -> Contact

  ///
  /// - Parameters:
  ///   - ids: 
  /// - Returns: TList<Contact>
  /// - Throws: TalkException
  func getContacts(ids: TList<String>) throws -> TList<Contact>

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func getCountryWithRequestIp() throws -> String

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getFavoriteMids() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - groupId: 
  /// - Returns: Group
  /// - Throws: TalkException
  func getGroup(groupId: String) throws -> Group

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getGroupIdsInvited() throws -> TList<String>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getGroupIdsJoined() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - groupIds: 
  /// - Returns: TList<Group>
  /// - Throws: TalkException
  func getGroups(groupIds: TList<String>) throws -> TList<Group>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getHiddenContactMids() throws -> TList<String>

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func getIdentityIdentifier() throws -> String

  ///
  /// - Returns: Int32
  /// - Throws: TalkException
  func getLastAnnouncementIndex() throws -> Int32

  ///
  /// - Returns: Int64
  /// - Throws: TalkException
  func getLastOpRevision() throws -> Int64

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - messageBoxId: 
  ///   - lastMessagesCount: 
  /// - Returns: TMessageBox
  /// - Throws: TalkException
  func getMessageBox(channelId: String, messageBoxId: String, lastMessagesCount: Int32) throws -> TMessageBox

  ///
  /// - Parameters:
  ///   - mid: 
  /// - Returns: TMessageBoxWrapUp
  /// - Throws: TalkException
  func getMessageBoxCompactWrapUp(mid: String) throws -> TMessageBoxWrapUp

  ///
  /// - Parameters:
  ///   - start: 
  ///   - messageBoxCount: 
  /// - Returns: TMessageBoxWrapUpResponse
  /// - Throws: TalkException
  func getMessageBoxCompactWrapUpList(start: Int32, messageBoxCount: Int32) throws -> TMessageBoxWrapUpResponse

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - lastMessagesCount: 
  /// - Returns: TList<TMessageBox>
  /// - Throws: TalkException
  func getMessageBoxList(channelId: String, lastMessagesCount: Int32) throws -> TList<TMessageBox>

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - lastMessagesCount: 
  ///   - status: 
  /// - Returns: TList<TMessageBox>
  /// - Throws: TalkException
  func getMessageBoxListByStatus(channelId: String, lastMessagesCount: Int32, status: Int32) throws -> TList<TMessageBox>

  ///
  /// - Parameters:
  ///   - mid: 
  /// - Returns: TMessageBoxWrapUp
  /// - Throws: TalkException
  func getMessageBoxWrapUp(mid: String) throws -> TMessageBoxWrapUp

  ///
  /// - Parameters:
  ///   - start: 
  ///   - messageBoxCount: 
  /// - Returns: TMessageBoxWrapUpResponse
  /// - Throws: TalkException
  func getMessageBoxWrapUpList(start: Int32, messageBoxCount: Int32) throws -> TMessageBoxWrapUpResponse

  ///
  /// - Parameters:
  ///   - channelId: 
  ///   - messageBoxId: 
  ///   - startSeq: 
  ///   - endSeq: 
  /// - Returns: TList<Message>
  /// - Throws: TalkException
  func getMessagesBySequenceNumber(channelId: String, messageBoxId: String, startSeq: Int64, endSeq: Int64) throws -> TList<Message>

  ///
  /// - Parameters:
  ///   - messageBoxId: 
  ///   - startSeq: 
  ///   - messagesCount: 
  /// - Returns: TList<Message>
  /// - Throws: TalkException
  func getNextMessages(messageBoxId: String, startSeq: Int64, messagesCount: Int32) throws -> TList<Message>

  ///
  /// - Parameters:
  ///   - carrier: 
  /// - Returns: TList<NotificationType>
  /// - Throws: TalkException
  func getNotificationPolicy(carrier: CarrierCode) throws -> TList<NotificationType>

  ///
  /// - Parameters:
  ///   - messageBoxId: 
  ///   - endSeq: 
  ///   - messagesCount: 
  /// - Returns: TList<Message>
  /// - Throws: TalkException
  func getPreviousMessages(messageBoxId: String, endSeq: Int64, messagesCount: Int32) throws -> TList<Message>

  ///
  /// - Returns: Profile
  /// - Throws: TalkException
  func getProfile() throws -> Profile

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Returns: ProximityMatchCandidateResult
  /// - Throws: TalkException
  func getProximityMatchCandidateList(sessionId: String) throws -> ProximityMatchCandidateResult

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Returns: TSet<Contact>
  /// - Throws: TalkException
  func getProximityMatchCandidates(sessionId: String) throws -> TSet<Contact>

  ///
  /// - Parameters:
  ///   - messageBoxId: 
  ///   - messagesCount: 
  /// - Returns: TList<Message>
  /// - Throws: TalkException
  func getRecentMessages(messageBoxId: String, messagesCount: Int32) throws -> TList<Message>

  ///
  /// - Returns: TList<String>
  /// - Throws: TalkException
  func getRecommendationIds() throws -> TList<String>

  ///
  /// - Parameters:
  ///   - roomId: 
  /// - Returns: Room
  /// - Throws: TalkException
  func getRoom(roomId: String) throws -> Room

  ///
  /// - Parameters:
  ///   - provider: 
  /// - Returns: RSAKey
  /// - Throws: TalkException
  func getRSAKeyInfo(provider: IdentityProvider) throws -> RSAKey

  ///
  /// - Returns: Int64
  /// - Throws: TalkException
  func getServerTime() throws -> Int64

  ///
  /// - Returns: TList<LoginSession>
  /// - Throws: TalkException
  func getSessions() throws -> TList<LoginSession>

  ///
  /// - Returns: Settings
  /// - Throws: TalkException
  func getSettings() throws -> Settings

  ///
  /// - Parameters:
  ///   - attrBitset: 
  /// - Returns: Settings
  /// - Throws: TalkException
  func getSettingsAttributes(attrBitset: Int32) throws -> Settings

  ///
  /// - Returns: SystemConfiguration
  /// - Throws: TalkException
  func getSystemConfiguration() throws -> SystemConfiguration

  ///
  /// - Returns: Ticket
  /// - Throws: TalkException
  func getUserTicket() throws -> Ticket

  ///
  /// - Parameters:
  ///   - invitationHash: 
  /// - Returns: WapInvitation
  /// - Throws: TalkException
  func getWapInvitation(invitationHash: String) throws -> WapInvitation

  ///
  /// - Throws: TalkException
  func invalidateUserTicket() throws

  ///
  /// - Parameters:
  ///   - phoneNumberList: 
  /// - Throws: TalkException
  func inviteFriendsBySms(phoneNumberList: TList<String>) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - groupId: 
  ///   - contactIds: 
  /// - Throws: TalkException
  func inviteIntoGroup(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - roomId: 
  ///   - contactIds: 
  /// - Throws: TalkException
  func inviteIntoRoom(reqSeq: Int32, roomId: String, contactIds: TList<String>) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - email: 
  ///   - name: 
  /// - Throws: TalkException
  func inviteViaEmail(reqSeq: Int32, email: String, name: String) throws

  ///
  /// - Parameters:
  ///   - provider: 
  ///   - identifier: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func isIdentityIdentifierAvailable(provider: IdentityProvider, identifier: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - userid: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func isUseridAvailable(userid: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - groupId: 
  ///   - contactIds: 
  /// - Throws: TalkException
  func kickoutFromGroup(reqSeq: Int32, groupId: String, contactIds: TList<String>) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - groupId: 
  /// - Throws: TalkException
  func leaveGroup(reqSeq: Int32, groupId: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - roomId: 
  /// - Throws: TalkException
  func leaveRoom(reqSeq: Int32, roomId: String) throws

  ///
  /// - Parameters:
  ///   - identityProvider: 
  ///   - identifier: 
  ///   - password: 
  ///   - keepLoggedIn: 
  ///   - accessLocation: 
  ///   - systemName: 
  ///   - certificate: 
  /// - Returns: String
  /// - Throws: TalkException
  func loginWithIdentityCredential(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) throws -> String

  ///
  /// - Parameters:
  ///   - identityProvider: 
  ///   - identifier: 
  ///   - password: 
  ///   - keepLoggedIn: 
  ///   - accessLocation: 
  ///   - systemName: 
  ///   - certificate: 
  /// - Returns: LoginResult
  /// - Throws: TalkException
  func loginWithIdentityCredentialForCertificate(identityProvider: IdentityProvider, identifier: String, password: String, keepLoggedIn: Bool, accessLocation: String, systemName: String, certificate: String) throws -> LoginResult

  ///
  /// - Parameters:
  ///   - verifier: 
  /// - Returns: String
  /// - Throws: TalkException
  func loginWithVerifier(verifier: String) throws -> String

  ///
  /// - Parameters:
  ///   - verifier: 
  /// - Returns: LoginResult
  /// - Throws: TalkException
  func loginWithVerifierForCerificate(verifier: String) throws -> LoginResult

  ///
  /// - Parameters:
  ///   - verifier: 
  /// - Returns: LoginResult
  /// - Throws: TalkException
  func loginWithVerifierForCertificate(verifier: String) throws -> LoginResult

  ///
  /// - Throws: TalkException
  func logout() throws

  ///
  /// - Parameters:
  ///   - tokenKey: 
  /// - Throws: TalkException
  func logoutSession(tokenKey: String) throws

  ///
  /// - Throws: TalkException
  func noop() throws

  ///
  /// - Parameters:
  ///   - paramMap: 
  /// - Throws: TalkException
  func notifiedRedirect(paramMap: TMap<String, String>) throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - receiverMids: 
  /// - Returns: TMap<String, String>
  /// - Throws: TalkException
  func notifyBuddyOnAir(seq: Int32, receiverMids: TList<String>) throws -> TMap<String, String>

  ///
  /// - Parameters:
  ///   - notificationStatus: 
  ///   - receiverMids: 
  /// - Throws: TalkException
  func notifyIndividualEvent(notificationStatus: NotificationStatus, receiverMids: TList<String>) throws

  ///
  /// - Parameters:
  ///   - udidHash: 
  ///   - applicationTypeWithExtensions: 
  /// - Throws: 
  func notifyInstalled(udidHash: String, applicationTypeWithExtensions: String) throws

  ///
  /// - Parameters:
  ///   - udidHash: 
  ///   - applicationTypeWithExtensions: 
  /// - Throws: 
  func notifyRegistrationComplete(udidHash: String, applicationTypeWithExtensions: String) throws

  ///
  /// - Parameters:
  ///   - lastRev: 
  ///   - badge: 
  /// - Throws: TalkException
  func notifySleep(lastRev: Int64, badge: Int32) throws

  ///
  /// - Parameters:
  ///   - lastRev: 
  ///   - deviceInfo: 
  /// - Throws: TalkException
  func notifyUpdated(lastRev: Int64, deviceInfo: DeviceInfo) throws

  ///
  /// - Parameters:
  ///   - location: 
  /// - Returns: String
  /// - Throws: TalkException
  func openProximityMatch(location: Location) throws -> String

  ///
  /// - Parameters:
  ///   - buddyId: 
  ///   - registrarPassword: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerBuddyUser(buddyId: String, registrarPassword: String) throws -> String

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - userid: 
  /// - Throws: TalkException
  func registerBuddyUserid(seq: Int32, userid: String) throws

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerDevice(sessionId: String) throws -> String

  ///
  /// - Parameters:
  ///   - sessionId: 
  ///   - provider: 
  ///   - identifier: 
  ///   - verifier: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerDeviceWithIdentityCredential(sessionId: String, provider: IdentityProvider, identifier: String, verifier: String) throws -> String

  ///
  /// - Parameters:
  ///   - region: 
  ///   - udidHash: 
  ///   - deviceInfo: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerDeviceWithoutPhoneNumber(region: String, udidHash: String, deviceInfo: DeviceInfo) throws -> String

  ///
  /// - Parameters:
  ///   - region: 
  ///   - udidHash: 
  ///   - deviceInfo: 
  ///   - provider: 
  ///   - identifier: 
  ///   - verifier: 
  ///   - mid: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerDeviceWithoutPhoneNumberWithIdentityCredential(region: String, udidHash: String, deviceInfo: DeviceInfo, provider: IdentityProvider, identifier: String, verifier: String, mid: String) throws -> String

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - userid: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func registerUserid(reqSeq: Int32, userid: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - invitationHash: 
  ///   - guidHash: 
  ///   - email: 
  ///   - deviceInfo: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerWapDevice(invitationHash: String, guidHash: String, email: String, deviceInfo: DeviceInfo) throws -> String

  ///
  /// - Parameters:
  ///   - identityCredential: 
  ///   - region: 
  ///   - udidHash: 
  ///   - deviceInfo: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerWithExistingSnsIdAndIdentityCredential(identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) throws -> String

  ///
  /// - Parameters:
  ///   - snsIdType: 
  ///   - snsAccessToken: 
  ///   - region: 
  ///   - udidHash: 
  ///   - deviceInfo: 
  ///   - mid: 
  /// - Returns: RegisterWithSnsIdResult
  /// - Throws: TalkException
  func registerWithSnsId(snsIdType: SnsIdType, snsAccessToken: String, region: String, udidHash: String, deviceInfo: DeviceInfo, mid: String) throws -> RegisterWithSnsIdResult

  ///
  /// - Parameters:
  ///   - snsIdType: 
  ///   - snsAccessToken: 
  ///   - identityCredential: 
  ///   - region: 
  ///   - udidHash: 
  ///   - deviceInfo: 
  /// - Returns: String
  /// - Throws: TalkException
  func registerWithSnsIdAndIdentityCredential(snsIdType: SnsIdType, snsAccessToken: String, identityCredential: IdentityCredential, region: String, udidHash: String, deviceInfo: DeviceInfo) throws -> String

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func reissueDeviceCredential() throws -> String

  ///
  /// - Parameters:
  ///   - expirationTime: 
  ///   - maxUseCount: 
  /// - Returns: String
  /// - Throws: TalkException
  func reissueUserTicket(expirationTime: Int64, maxUseCount: Int32) throws -> String

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - groupId: 
  /// - Throws: TalkException
  func rejectGroupInvitation(reqSeq: Int32, groupId: String) throws

  ///
  /// - Throws: TalkException
  func releaseSession() throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - lastMessageId: 
  /// - Throws: TalkException
  func removeAllMessages(seq: Int32, lastMessageId: String) throws

  ///
  /// - Parameters:
  ///   - mid: 
  ///   - index: 
  /// - Throws: TalkException
  func removeBuddyLocation(mid: String, index: Int32) throws

  ///
  /// - Parameters:
  ///   - messageId: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func removeMessage(messageId: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - messageId: 
  /// - Returns: Bool
  /// - Throws: TalkException
  func removeMessageFromMyHome(messageId: String) throws -> Bool

  ///
  /// - Parameters:
  ///   - snsIdType: 
  /// - Returns: String
  /// - Throws: TalkException
  func removeSnsId(snsIdType: SnsIdType) throws -> String

  ///
  /// - Parameters:
  ///   - syncOpRevision: 
  ///   - category: 
  ///   - report: 
  /// - Throws: TalkException
  func report(syncOpRevision: Int64, category: SyncCategory, report: String) throws

  ///
  /// - Parameters:
  ///   - syncOpRevision: 
  ///   - category: 
  ///   - contactReports: 
  ///   - actionType: 
  /// - Returns: TList<ContactReportResult>
  /// - Throws: TalkException
  func reportContacts(syncOpRevision: Int64, category: SyncCategory, contactReports: TList<ContactReport>, actionType: SyncActionType) throws -> TList<ContactReportResult>

  ///
  /// - Parameters:
  ///   - syncOpRevision: 
  ///   - groups: 
  /// - Throws: TalkException
  func reportGroups(syncOpRevision: Int64, groups: TList<Group>) throws

  ///
  /// - Parameters:
  ///   - syncOpRevision: 
  ///   - profile: 
  /// - Throws: TalkException
  func reportProfile(syncOpRevision: Int64, profile: Profile) throws

  ///
  /// - Parameters:
  ///   - syncOpRevision: 
  ///   - rooms: 
  /// - Throws: TalkException
  func reportRooms(syncOpRevision: Int64, rooms: TList<Room>) throws

  ///
  /// - Parameters:
  ///   - syncOpRevision: 
  ///   - settings: 
  /// - Throws: TalkException
  func reportSettings(syncOpRevision: Int64, settings: Settings) throws

  ///
  /// - Parameters:
  ///   - spammerMid: 
  ///   - spammerReasons: 
  ///   - spamMessageIds: 
  /// - Throws: TalkException
  func reportSpammer(spammerMid: String, spammerReasons: TList<SpammerReason>, spamMessageIds: TList<String>) throws

  ///
  /// - Parameters:
  ///   - provider: 
  ///   - identifier: 
  ///   - locale: 
  /// - Throws: TalkException
  func requestAccountPasswordReset(provider: IdentityProvider, identifier: String, locale: String) throws

  ///
  /// - Parameters:
  ///   - emailConfirmation: 
  /// - Returns: EmailConfirmationSession
  /// - Throws: TalkException
  func requestEmailConfirmation(emailConfirmation: EmailConfirmation) throws -> EmailConfirmationSession

  ///
  /// - Parameters:
  ///   - provider: 
  ///   - identifier: 
  /// - Throws: TalkException
  func requestIdentityUnbind(provider: IdentityProvider, identifier: String) throws

  ///
  /// - Parameters:
  ///   - verifier: 
  /// - Returns: EmailConfirmationSession
  /// - Throws: TalkException
  func resendEmailConfirmation(verifier: String) throws -> EmailConfirmationSession

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Throws: TalkException
  func resendPinCode(sessionId: String) throws

  ///
  /// - Parameters:
  ///   - sessionId: 
  /// - Throws: TalkException
  func resendPinCodeBySMS(sessionId: String) throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - consumer: 
  ///   - lastMessageId: 
  /// - Throws: TalkException
  func sendChatChecked(seq: Int32, consumer: String, lastMessageId: String) throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - consumer: 
  ///   - lastMessageId: 
  /// - Throws: TalkException
  func sendChatRemoved(seq: Int32, consumer: String, lastMessageId: String) throws

  ///
  /// - Parameters:
  ///   - esq: 
  ///   - messageId: 
  ///   - receiverMids: 
  /// - Returns: TMap<String, String>
  /// - Throws: TalkException
  func sendContentPreviewUpdated(esq: Int32, messageId: String, receiverMids: TList<String>) throws -> TMap<String, String>

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - consumer: 
  ///   - messageId: 
  /// - Throws: TalkException
  func sendContentReceipt(seq: Int32, consumer: String, messageId: String) throws

  ///
  /// - Throws: TalkException
  func sendDummyPush() throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - message: 
  /// - Returns: Message
  /// - Throws: TalkException
  func sendEvent(seq: Int32, message: Message) throws -> Message

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - message: 
  /// - Returns: Message
  /// - Throws: TalkException
  func sendMessage(seq: Int32, message: Message) throws -> Message

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - consumer: 
  ///   - messageIds: 
  /// - Throws: TalkException
  func sendMessageIgnored(seq: Int32, consumer: String, messageIds: TList<String>) throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - consumer: 
  ///   - messageIds: 
  /// - Throws: TalkException
  func sendMessageReceipt(seq: Int32, consumer: String, messageIds: TList<String>) throws

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - message: 
  /// - Returns: Message
  /// - Throws: TalkException
  func sendMessageToMyHome(seq: Int32, message: Message) throws -> Message

  ///
  /// - Parameters:
  ///   - mid: 
  ///   - index: 
  ///   - location: 
  /// - Throws: TalkException
  func setBuddyLocation(mid: String, index: Int32, location: Geolocation) throws

  ///
  /// - Parameters:
  ///   - provider: 
  ///   - identifier: 
  ///   - verifier: 
  /// - Throws: TalkException
  func setIdentityCredential(provider: IdentityProvider, identifier: String, verifier: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - type: 
  ///   - target: 
  ///   - enablement: 
  /// - Throws: TalkException
  func setNotificationsEnabled(reqSeq: Int32, type: MIDType, target: String, enablement: Bool) throws

  ///
  /// - Parameters:
  ///   - region: 
  ///   - carrier: 
  ///   - phone: 
  ///   - udidHash: 
  ///   - deviceInfo: 
  ///   - networkCode: 
  ///   - locale: 
  /// - Returns: VerificationSessionData
  /// - Throws: TalkException
  func startUpdateVerification(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, locale: String) throws -> VerificationSessionData

  ///
  /// - Parameters:
  ///   - region: 
  ///   - carrier: 
  ///   - phone: 
  ///   - udidHash: 
  ///   - deviceInfo: 
  ///   - networkCode: 
  ///   - mid: 
  ///   - locale: 
  /// - Returns: VerificationSessionData
  /// - Throws: TalkException
  func startVerification(region: String, carrier: CarrierCode, phone: String, udidHash: String, deviceInfo: DeviceInfo, networkCode: String, mid: String, locale: String) throws -> VerificationSessionData

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - profileAttribute: 
  ///   - value: 
  /// - Throws: TalkException
  func storeUpdateProfileAttribute(seq: Int32, profileAttribute: ProfileAttribute, value: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - modifications: 
  /// - Returns: TList<SnsFriendContactRegistration>
  /// - Throws: TalkException
  func syncContactBySnsIds(reqSeq: Int32, modifications: TList<SnsFriendModification>) throws -> TList<SnsFriendContactRegistration>

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - localContacts: 
  /// - Returns: TMap<String, ContactRegistration>
  /// - Throws: TalkException
  func syncContacts(reqSeq: Int32, localContacts: TList<ContactModification>) throws -> TMap<String, ContactRegistration>

  ///
  /// - Parameters:
  ///   - seq: 
  ///   - message: 
  /// - Returns: Message
  /// - Throws: TalkException
  func trySendMessage(seq: Int32, message: Message) throws -> Message

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - id: 
  /// - Throws: TalkException
  func unblockContact(reqSeq: Int32, id: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - id: 
  /// - Throws: TalkException
  func unblockRecommendation(reqSeq: Int32, id: String) throws

  ///
  /// - Returns: String
  /// - Throws: TalkException
  func unregisterUserAndDevice() throws -> String

  ///
  /// - Parameters:
  ///   - apnsDeviceToken: 
  /// - Throws: TalkException
  func updateApnsDeviceToken(apnsDeviceToken: Data) throws

  ///
  /// - Parameters:
  ///   - key: 
  ///   - value: 
  /// - Throws: TalkException
  func updateBuddySetting(key: String, value: String) throws

  ///
  /// - Parameters:
  ///   - registrationId: 
  /// - Throws: TalkException
  func updateC2DMRegistrationId(registrationId: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - mid: 
  ///   - flag: 
  ///   - value: 
  /// - Throws: TalkException
  func updateContactSetting(reqSeq: Int32, mid: String, flag: ContactSetting, value: String) throws

  ///
  /// - Parameters:
  ///   - customMode: 
  ///   - paramMap: 
  /// - Throws: TalkException
  func updateCustomModeSettings(customMode: CustomMode, paramMap: TMap<String, String>) throws

  ///
  /// - Parameters:
  ///   - deviceUid: 
  ///   - deviceInfo: 
  /// - Throws: TalkException
  func updateDeviceInfo(deviceUid: String, deviceInfo: DeviceInfo) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - group: 
  /// - Throws: TalkException
  func updateGroup(reqSeq: Int32, group: Group) throws

  ///
  /// - Parameters:
  ///   - type: 
  ///   - token: 
  /// - Throws: TalkException
  func updateNotificationToken(type: NotificationType, token: String) throws

  ///
  /// - Parameters:
  ///   - type: 
  ///   - token: 
  /// - Throws: TalkException
  func updateNotificationTokenWithBytes(type: NotificationType, token: Data) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - profile: 
  /// - Throws: TalkException
  func updateProfile(reqSeq: Int32, profile: Profile) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - attr: 
  ///   - value: 
  /// - Throws: TalkException
  func updateProfileAttribute(reqSeq: Int32, attr: ProfileAttribute, value: String) throws

  ///
  /// - Parameters:
  ///   - region: 
  /// - Throws: TalkException
  func updateRegion(region: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - settings: 
  /// - Throws: TalkException
  func updateSettings(reqSeq: Int32, settings: Settings) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - settings: 
  /// - Returns: Int32
  /// - Throws: TalkException
  func updateSettings2(reqSeq: Int32, settings: Settings) throws -> Int32

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - attr: 
  ///   - value: 
  /// - Throws: TalkException
  func updateSettingsAttribute(reqSeq: Int32, attr: SettingsAttribute, value: String) throws

  ///
  /// - Parameters:
  ///   - reqSeq: 
  ///   - attrBitset: 
  ///   - settings: 
  /// - Returns: Int32
  /// - Throws: TalkException
  func updateSettingsAttributes(reqSeq: Int32, attrBitset: Int32, settings: Settings) throws -> Int32

  ///
  /// - Parameters:
  ///   - identityProvider: 
  ///   - identifier: 
  ///   - password: 
  /// - Throws: TalkException
  func verifyIdentityCredential(identityProvider: IdentityProvider, identifier: String, password: String) throws

  ///
  /// - Parameters:
  ///   - identityCredential: 
  /// - Returns: UserAuthStatus
  /// - Throws: TalkException
  func verifyIdentityCredentialWithResult(identityCredential: IdentityCredential) throws -> UserAuthStatus

  ///
  /// - Parameters:
  ///   - sessionId: 
  ///   - pinCode: 
  ///   - udidHash: 
  /// - Returns: VerificationResult
  /// - Throws: TalkException
  func verifyPhone(sessionId: String, pinCode: String, udidHash: String) throws -> VerificationResult

  ///
  /// - Parameters:
  ///   - verifier: 
  ///   - pinCode: 
  /// - Returns: String
  /// - Throws: TalkException
  func verifyQrcode(verifier: String, pinCode: String) throws -> String

}

open class TalkServiceClient : TClient /* , TalkService */ {

}

open class TalkServiceProcessor /* TalkService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, TalkService) throws -> Void]

  public var service: TalkService

  public required init(service: TalkService) {
    self.service = service
  }

}

public protocol UniversalNotificationService {

  ///
  /// - Parameters:
  ///   - event: 
  /// - Throws: UniversalNotificationServiceException
  func notify(event: GlobalEvent) throws

}

open class UniversalNotificationServiceClient : TClient /* , UniversalNotificationService */ {

}

open class UniversalNotificationServiceProcessor /* UniversalNotificationService */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, UniversalNotificationService) throws -> Void]

  public var service: UniversalNotificationService

  public required init(service: UniversalNotificationService) {
    self.service = service
  }

}


