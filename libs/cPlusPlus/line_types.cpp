/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "line_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kApplicationTypeValues[] = {
  ApplicationType::IOS,
  ApplicationType::IOS_RC,
  ApplicationType::IOS_BETA,
  ApplicationType::IOS_ALPHA,
  ApplicationType::ANDROID,
  ApplicationType::ANDROID_RC,
  ApplicationType::ANDROID_BETA,
  ApplicationType::ANDROID_ALPHA,
  ApplicationType::WAP,
  ApplicationType::WAP_RC,
  ApplicationType::WAP_BETA,
  ApplicationType::WAP_ALPHA,
  ApplicationType::BOT,
  ApplicationType::BOT_RC,
  ApplicationType::BOT_BETA,
  ApplicationType::BOT_ALPHA,
  ApplicationType::WEB,
  ApplicationType::WEB_RC,
  ApplicationType::WEB_BETA,
  ApplicationType::WEB_ALPHA,
  ApplicationType::DESKTOPWIN,
  ApplicationType::DESKTOPWIN_RC,
  ApplicationType::DESKTOPWIN_BETA,
  ApplicationType::DESKTOPWIN_ALPHA,
  ApplicationType::DESKTOPMAC,
  ApplicationType::DESKTOPMAC_RC,
  ApplicationType::DESKTOPMAC_BETA,
  ApplicationType::DESKTOPMAC_ALPHA,
  ApplicationType::CHANNELGW,
  ApplicationType::CHANNELGW_RC,
  ApplicationType::CHANNELGW_BETA,
  ApplicationType::CHANNELGW_ALPHA,
  ApplicationType::CHANNELCP,
  ApplicationType::CHANNELCP_RC,
  ApplicationType::CHANNELCP_BETA,
  ApplicationType::CHANNELCP_ALPHA,
  ApplicationType::WINPHONE,
  ApplicationType::WINPHONE_RC,
  ApplicationType::WINPHONE_BETA,
  ApplicationType::WINPHONE_ALPHA,
  ApplicationType::BLACKBERRY,
  ApplicationType::BLACKBERRY_RC,
  ApplicationType::BLACKBERRY_BETA,
  ApplicationType::BLACKBERRY_ALPHA,
  ApplicationType::WINMETRO,
  ApplicationType::WINMETRO_RC,
  ApplicationType::WINMETRO_BETA,
  ApplicationType::WINMETRO_ALPHA,
  ApplicationType::S40,
  ApplicationType::S40_RC,
  ApplicationType::S40_BETA,
  ApplicationType::S40_ALPHA,
  ApplicationType::CHRONO,
  ApplicationType::CHRONO_RC,
  ApplicationType::CHRONO_BETA,
  ApplicationType::CHRONO_ALPHA,
  ApplicationType::TIZEN,
  ApplicationType::TIZEN_RC,
  ApplicationType::TIZEN_BETA,
  ApplicationType::TIZEN_ALPHA,
  ApplicationType::VIRTUAL
};
const char* _kApplicationTypeNames[] = {
  "IOS",
  "IOS_RC",
  "IOS_BETA",
  "IOS_ALPHA",
  "ANDROID",
  "ANDROID_RC",
  "ANDROID_BETA",
  "ANDROID_ALPHA",
  "WAP",
  "WAP_RC",
  "WAP_BETA",
  "WAP_ALPHA",
  "BOT",
  "BOT_RC",
  "BOT_BETA",
  "BOT_ALPHA",
  "WEB",
  "WEB_RC",
  "WEB_BETA",
  "WEB_ALPHA",
  "DESKTOPWIN",
  "DESKTOPWIN_RC",
  "DESKTOPWIN_BETA",
  "DESKTOPWIN_ALPHA",
  "DESKTOPMAC",
  "DESKTOPMAC_RC",
  "DESKTOPMAC_BETA",
  "DESKTOPMAC_ALPHA",
  "CHANNELGW",
  "CHANNELGW_RC",
  "CHANNELGW_BETA",
  "CHANNELGW_ALPHA",
  "CHANNELCP",
  "CHANNELCP_RC",
  "CHANNELCP_BETA",
  "CHANNELCP_ALPHA",
  "WINPHONE",
  "WINPHONE_RC",
  "WINPHONE_BETA",
  "WINPHONE_ALPHA",
  "BLACKBERRY",
  "BLACKBERRY_RC",
  "BLACKBERRY_BETA",
  "BLACKBERRY_ALPHA",
  "WINMETRO",
  "WINMETRO_RC",
  "WINMETRO_BETA",
  "WINMETRO_ALPHA",
  "S40",
  "S40_RC",
  "S40_BETA",
  "S40_ALPHA",
  "CHRONO",
  "CHRONO_RC",
  "CHRONO_BETA",
  "CHRONO_ALPHA",
  "TIZEN",
  "TIZEN_RC",
  "TIZEN_BETA",
  "TIZEN_ALPHA",
  "VIRTUAL"
};
const std::map<int, const char*> _ApplicationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(61, _kApplicationTypeValues, _kApplicationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ApplicationType::type& val) {
  std::map<int, const char*>::const_iterator it = _ApplicationType_VALUES_TO_NAMES.find(val);
  if (it != _ApplicationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ApplicationType::type& val) {
  std::map<int, const char*>::const_iterator it = _ApplicationType_VALUES_TO_NAMES.find(val);
  if (it != _ApplicationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBuddyBannerLinkTypeValues[] = {
  BuddyBannerLinkType::BUDDY_BANNER_LINK_HIDDEN,
  BuddyBannerLinkType::BUDDY_BANNER_LINK_MID,
  BuddyBannerLinkType::BUDDY_BANNER_LINK_URL
};
const char* _kBuddyBannerLinkTypeNames[] = {
  "BUDDY_BANNER_LINK_HIDDEN",
  "BUDDY_BANNER_LINK_MID",
  "BUDDY_BANNER_LINK_URL"
};
const std::map<int, const char*> _BuddyBannerLinkType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBuddyBannerLinkTypeValues, _kBuddyBannerLinkTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BuddyBannerLinkType::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddyBannerLinkType_VALUES_TO_NAMES.find(val);
  if (it != _BuddyBannerLinkType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BuddyBannerLinkType::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddyBannerLinkType_VALUES_TO_NAMES.find(val);
  if (it != _BuddyBannerLinkType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBuddyOnAirTypeValues[] = {
  BuddyOnAirType::NORMAL,
  BuddyOnAirType::LIVE,
  BuddyOnAirType::VOIP
};
const char* _kBuddyOnAirTypeNames[] = {
  "NORMAL",
  "LIVE",
  "VOIP"
};
const std::map<int, const char*> _BuddyOnAirType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBuddyOnAirTypeValues, _kBuddyOnAirTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BuddyOnAirType::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddyOnAirType_VALUES_TO_NAMES.find(val);
  if (it != _BuddyOnAirType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BuddyOnAirType::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddyOnAirType_VALUES_TO_NAMES.find(val);
  if (it != _BuddyOnAirType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBuddyResultStateValues[] = {
  BuddyResultState::ACCEPTED,
  BuddyResultState::SUCCEEDED,
  BuddyResultState::FAILED,
  BuddyResultState::CANCELLED,
  BuddyResultState::NOTIFY_FAILED,
  BuddyResultState::STORING,
  BuddyResultState::UPLOADING,
  BuddyResultState::NOTIFYING
};
const char* _kBuddyResultStateNames[] = {
  "ACCEPTED",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "NOTIFY_FAILED",
  "STORING",
  "UPLOADING",
  "NOTIFYING"
};
const std::map<int, const char*> _BuddyResultState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kBuddyResultStateValues, _kBuddyResultStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BuddyResultState::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddyResultState_VALUES_TO_NAMES.find(val);
  if (it != _BuddyResultState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BuddyResultState::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddyResultState_VALUES_TO_NAMES.find(val);
  if (it != _BuddyResultState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBuddySearchRequestSourceValues[] = {
  BuddySearchRequestSource::NA,
  BuddySearchRequestSource::FRIEND_VIEW,
  BuddySearchRequestSource::OFFICIAL_ACCOUNT_VIEW
};
const char* _kBuddySearchRequestSourceNames[] = {
  "NA",
  "FRIEND_VIEW",
  "OFFICIAL_ACCOUNT_VIEW"
};
const std::map<int, const char*> _BuddySearchRequestSource_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBuddySearchRequestSourceValues, _kBuddySearchRequestSourceNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BuddySearchRequestSource::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddySearchRequestSource_VALUES_TO_NAMES.find(val);
  if (it != _BuddySearchRequestSource_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BuddySearchRequestSource::type& val) {
  std::map<int, const char*>::const_iterator it = _BuddySearchRequestSource_VALUES_TO_NAMES.find(val);
  if (it != _BuddySearchRequestSource_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCarrierCodeValues[] = {
  CarrierCode::NOT_SPECIFIED,
  CarrierCode::JP_DOCOMO,
  CarrierCode::JP_AU,
  CarrierCode::JP_SOFTBANK,
  CarrierCode::KR_SKT,
  CarrierCode::KR_KT,
  CarrierCode::KR_LGT
};
const char* _kCarrierCodeNames[] = {
  "NOT_SPECIFIED",
  "JP_DOCOMO",
  "JP_AU",
  "JP_SOFTBANK",
  "KR_SKT",
  "KR_KT",
  "KR_LGT"
};
const std::map<int, const char*> _CarrierCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kCarrierCodeValues, _kCarrierCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CarrierCode::type& val) {
  std::map<int, const char*>::const_iterator it = _CarrierCode_VALUES_TO_NAMES.find(val);
  if (it != _CarrierCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CarrierCode::type& val) {
  std::map<int, const char*>::const_iterator it = _CarrierCode_VALUES_TO_NAMES.find(val);
  if (it != _CarrierCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kChannelConfigurationValues[] = {
  ChannelConfiguration::MESSAGE,
  ChannelConfiguration::MESSAGE_NOTIFICATION,
  ChannelConfiguration::NOTIFICATION_CENTER
};
const char* _kChannelConfigurationNames[] = {
  "MESSAGE",
  "MESSAGE_NOTIFICATION",
  "NOTIFICATION_CENTER"
};
const std::map<int, const char*> _ChannelConfiguration_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kChannelConfigurationValues, _kChannelConfigurationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ChannelConfiguration::type& val) {
  std::map<int, const char*>::const_iterator it = _ChannelConfiguration_VALUES_TO_NAMES.find(val);
  if (it != _ChannelConfiguration_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ChannelConfiguration::type& val) {
  std::map<int, const char*>::const_iterator it = _ChannelConfiguration_VALUES_TO_NAMES.find(val);
  if (it != _ChannelConfiguration_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kChannelErrorCodeValues[] = {
  ChannelErrorCode::ILLEGAL_ARGUMENT,
  ChannelErrorCode::INTERNAL_ERROR,
  ChannelErrorCode::CONNECTION_ERROR,
  ChannelErrorCode::AUTHENTICATIONI_FAILED,
  ChannelErrorCode::NEED_PERMISSION_APPROVAL,
  ChannelErrorCode::COIN_NOT_USABLE
};
const char* _kChannelErrorCodeNames[] = {
  "ILLEGAL_ARGUMENT",
  "INTERNAL_ERROR",
  "CONNECTION_ERROR",
  "AUTHENTICATIONI_FAILED",
  "NEED_PERMISSION_APPROVAL",
  "COIN_NOT_USABLE"
};
const std::map<int, const char*> _ChannelErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kChannelErrorCodeValues, _kChannelErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ChannelErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ChannelErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ChannelErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ChannelErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ChannelErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ChannelErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kChannelSyncTypeValues[] = {
  ChannelSyncType::SYNC,
  ChannelSyncType::REMOVE
};
const char* _kChannelSyncTypeNames[] = {
  "SYNC",
  "REMOVE"
};
const std::map<int, const char*> _ChannelSyncType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kChannelSyncTypeValues, _kChannelSyncTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ChannelSyncType::type& val) {
  std::map<int, const char*>::const_iterator it = _ChannelSyncType_VALUES_TO_NAMES.find(val);
  if (it != _ChannelSyncType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ChannelSyncType::type& val) {
  std::map<int, const char*>::const_iterator it = _ChannelSyncType_VALUES_TO_NAMES.find(val);
  if (it != _ChannelSyncType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kContactAttributeValues[] = {
  ContactAttribute::CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL,
  ContactAttribute::CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL,
  ContactAttribute::CONTACT_ATTRIBUTE_CAPABLE_MY_HOME,
  ContactAttribute::CONTACT_ATTRIBUTE_CAPABLE_BUDDY
};
const char* _kContactAttributeNames[] = {
  "CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL",
  "CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL",
  "CONTACT_ATTRIBUTE_CAPABLE_MY_HOME",
  "CONTACT_ATTRIBUTE_CAPABLE_BUDDY"
};
const std::map<int, const char*> _ContactAttribute_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kContactAttributeValues, _kContactAttributeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ContactAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactAttribute_VALUES_TO_NAMES.find(val);
  if (it != _ContactAttribute_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ContactAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactAttribute_VALUES_TO_NAMES.find(val);
  if (it != _ContactAttribute_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kContactCategoryValues[] = {
  ContactCategory::NORMAL,
  ContactCategory::RECOMMEND
};
const char* _kContactCategoryNames[] = {
  "NORMAL",
  "RECOMMEND"
};
const std::map<int, const char*> _ContactCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kContactCategoryValues, _kContactCategoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ContactCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactCategory_VALUES_TO_NAMES.find(val);
  if (it != _ContactCategory_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ContactCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactCategory_VALUES_TO_NAMES.find(val);
  if (it != _ContactCategory_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kContactRelationValues[] = {
  ContactRelation::ONEWAY,
  ContactRelation::BOTH,
  ContactRelation::NOT_REGISTERED
};
const char* _kContactRelationNames[] = {
  "ONEWAY",
  "BOTH",
  "NOT_REGISTERED"
};
const std::map<int, const char*> _ContactRelation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kContactRelationValues, _kContactRelationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ContactRelation::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactRelation_VALUES_TO_NAMES.find(val);
  if (it != _ContactRelation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ContactRelation::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactRelation_VALUES_TO_NAMES.find(val);
  if (it != _ContactRelation_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kContactSettingValues[] = {
  ContactSetting::CONTACT_SETTING_NOTIFICATION_DISABLE,
  ContactSetting::CONTACT_SETTING_DISPLAY_NAME_OVERRIDE,
  ContactSetting::CONTACT_SETTING_CONTACT_HIDE,
  ContactSetting::CONTACT_SETTING_FAVORITE,
  ContactSetting::CONTACT_SETTING_DELETE
};
const char* _kContactSettingNames[] = {
  "CONTACT_SETTING_NOTIFICATION_DISABLE",
  "CONTACT_SETTING_DISPLAY_NAME_OVERRIDE",
  "CONTACT_SETTING_CONTACT_HIDE",
  "CONTACT_SETTING_FAVORITE",
  "CONTACT_SETTING_DELETE"
};
const std::map<int, const char*> _ContactSetting_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kContactSettingValues, _kContactSettingNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ContactSetting::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactSetting_VALUES_TO_NAMES.find(val);
  if (it != _ContactSetting_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ContactSetting::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactSetting_VALUES_TO_NAMES.find(val);
  if (it != _ContactSetting_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kContactStatusValues[] = {
  ContactStatus::UNSPECIFIED,
  ContactStatus::FRIEND,
  ContactStatus::FRIEND_BLOCKED,
  ContactStatus::RECOMMEND,
  ContactStatus::RECOMMEND_BLOCKED,
  ContactStatus::DELETED,
  ContactStatus::DELETED_BLOCKED
};
const char* _kContactStatusNames[] = {
  "UNSPECIFIED",
  "FRIEND",
  "FRIEND_BLOCKED",
  "RECOMMEND",
  "RECOMMEND_BLOCKED",
  "DELETED",
  "DELETED_BLOCKED"
};
const std::map<int, const char*> _ContactStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kContactStatusValues, _kContactStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ContactStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactStatus_VALUES_TO_NAMES.find(val);
  if (it != _ContactStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ContactStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactStatus_VALUES_TO_NAMES.find(val);
  if (it != _ContactStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kContactTypeValues[] = {
  ContactType::MID,
  ContactType::PHONE,
  ContactType::EMAIL,
  ContactType::USERID,
  ContactType::PROXIMITY,
  ContactType::GROUP,
  ContactType::USER,
  ContactType::QRCODE,
  ContactType::PROMOTION_BOT,
  ContactType::REPAIR,
  ContactType::FACEBOOK,
  ContactType::SINA,
  ContactType::RENREN,
  ContactType::FEIXIN
};
const char* _kContactTypeNames[] = {
  "MID",
  "PHONE",
  "EMAIL",
  "USERID",
  "PROXIMITY",
  "GROUP",
  "USER",
  "QRCODE",
  "PROMOTION_BOT",
  "REPAIR",
  "FACEBOOK",
  "SINA",
  "RENREN",
  "FEIXIN"
};
const std::map<int, const char*> _ContactType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(14, _kContactTypeValues, _kContactTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ContactType::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactType_VALUES_TO_NAMES.find(val);
  if (it != _ContactType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ContactType::type& val) {
  std::map<int, const char*>::const_iterator it = _ContactType_VALUES_TO_NAMES.find(val);
  if (it != _ContactType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kContentTypeValues[] = {
  ContentType::NONE,
  ContentType::IMAGE,
  ContentType::VIDEO,
  ContentType::AUDIO,
  ContentType::HTML,
  ContentType::PDF,
  ContentType::CALL,
  ContentType::STICKER,
  ContentType::PRESENCE,
  ContentType::GIFT,
  ContentType::GROUPBOARD,
  ContentType::APPLINK,
  ContentType::LINK,
  ContentType::CONTACT,
  ContentType::FILE,
  ContentType::LOCATION,
  ContentType::POSTNOTIFICATION,
  ContentType::RICH,
  ContentType::CHATEVENT
};
const char* _kContentTypeNames[] = {
  "NONE",
  "IMAGE",
  "VIDEO",
  "AUDIO",
  "HTML",
  "PDF",
  "CALL",
  "STICKER",
  "PRESENCE",
  "GIFT",
  "GROUPBOARD",
  "APPLINK",
  "LINK",
  "CONTACT",
  "FILE",
  "LOCATION",
  "POSTNOTIFICATION",
  "RICH",
  "CHATEVENT"
};
const std::map<int, const char*> _ContentType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kContentTypeValues, _kContentTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ContentType::type& val) {
  std::map<int, const char*>::const_iterator it = _ContentType_VALUES_TO_NAMES.find(val);
  if (it != _ContentType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ContentType::type& val) {
  std::map<int, const char*>::const_iterator it = _ContentType_VALUES_TO_NAMES.find(val);
  if (it != _ContentType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCustomModeValues[] = {
  CustomMode::PROMOTION_FRIENDS_INVITE,
  CustomMode::CAPABILITY_SERVER_SIDE_SMS,
  CustomMode::LINE_CLIENT_ANALYTICS_CONFIGURATION
};
const char* _kCustomModeNames[] = {
  "PROMOTION_FRIENDS_INVITE",
  "CAPABILITY_SERVER_SIDE_SMS",
  "LINE_CLIENT_ANALYTICS_CONFIGURATION"
};
const std::map<int, const char*> _CustomMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCustomModeValues, _kCustomModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CustomMode::type& val) {
  std::map<int, const char*>::const_iterator it = _CustomMode_VALUES_TO_NAMES.find(val);
  if (it != _CustomMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CustomMode::type& val) {
  std::map<int, const char*>::const_iterator it = _CustomMode_VALUES_TO_NAMES.find(val);
  if (it != _CustomMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEmailConfirmationStatusValues[] = {
  EmailConfirmationStatus::NOT_SPECIFIED,
  EmailConfirmationStatus::NOT_YET,
  EmailConfirmationStatus::DONE
};
const char* _kEmailConfirmationStatusNames[] = {
  "NOT_SPECIFIED",
  "NOT_YET",
  "DONE"
};
const std::map<int, const char*> _EmailConfirmationStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEmailConfirmationStatusValues, _kEmailConfirmationStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const EmailConfirmationStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _EmailConfirmationStatus_VALUES_TO_NAMES.find(val);
  if (it != _EmailConfirmationStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EmailConfirmationStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _EmailConfirmationStatus_VALUES_TO_NAMES.find(val);
  if (it != _EmailConfirmationStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEmailConfirmationTypeValues[] = {
  EmailConfirmationType::SERVER_SIDE_EMAIL,
  EmailConfirmationType::CLIENT_SIDE_EMAIL
};
const char* _kEmailConfirmationTypeNames[] = {
  "SERVER_SIDE_EMAIL",
  "CLIENT_SIDE_EMAIL"
};
const std::map<int, const char*> _EmailConfirmationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kEmailConfirmationTypeValues, _kEmailConfirmationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const EmailConfirmationType::type& val) {
  std::map<int, const char*>::const_iterator it = _EmailConfirmationType_VALUES_TO_NAMES.find(val);
  if (it != _EmailConfirmationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EmailConfirmationType::type& val) {
  std::map<int, const char*>::const_iterator it = _EmailConfirmationType_VALUES_TO_NAMES.find(val);
  if (it != _EmailConfirmationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kErrorCodeValues[] = {
  ErrorCode::ILLEGAL_ARGUMENT,
  ErrorCode::AUTHENTICATION_FAILED,
  ErrorCode::DB_FAILED,
  ErrorCode::INVALID_STATE,
  ErrorCode::EXCESSIVE_ACCESS,
  ErrorCode::NOT_FOUND,
  ErrorCode::INVALID_LENGTH,
  ErrorCode::NOT_AVAILABLE_USER,
  ErrorCode::NOT_AUTHORIZED_DEVICE,
  ErrorCode::INVALID_MID,
  ErrorCode::NOT_A_MEMBER,
  ErrorCode::INCOMPATIBLE_APP_VERSION,
  ErrorCode::NOT_READY,
  ErrorCode::NOT_AVAILABLE_SESSION,
  ErrorCode::NOT_AUTHORIZED_SESSION,
  ErrorCode::SYSTEM_ERROR,
  ErrorCode::NO_AVAILABLE_VERIFICATION_METHOD,
  ErrorCode::NOT_AUTHENTICATED,
  ErrorCode::INVALID_IDENTITY_CREDENTIAL,
  ErrorCode::NOT_AVAILABLE_IDENTITY_IDENTIFIER,
  ErrorCode::INTERNAL_ERROR,
  ErrorCode::NO_SUCH_IDENTITY_IDENFIER,
  ErrorCode::DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY,
  ErrorCode::ILLEGAL_IDENTITY_CREDENTIAL,
  ErrorCode::UNKNOWN_CHANNEL,
  ErrorCode::NO_SUCH_MESSAGE_BOX,
  ErrorCode::NOT_AVAILABLE_MESSAGE_BOX,
  ErrorCode::CHANNEL_DOES_NOT_MATCH,
  ErrorCode::NOT_YOUR_MESSAGE,
  ErrorCode::MESSAGE_DEFINED_ERROR,
  ErrorCode::USER_CANNOT_ACCEPT_PRESENTS,
  ErrorCode::USER_NOT_STICKER_OWNER,
  ErrorCode::MAINTENANCE_ERROR,
  ErrorCode::ACCOUNT_NOT_MATCHED,
  ErrorCode::ABUSE_BLOCK,
  ErrorCode::NOT_FRIEND,
  ErrorCode::NOT_ALLOWED_CALL,
  ErrorCode::BLOCK_FRIEND,
  ErrorCode::INCOMPATIBLE_VOIP_VERSION,
  ErrorCode::INVALID_SNS_ACCESS_TOKEN,
  ErrorCode::EXTERNAL_SERVICE_NOT_AVAILABLE,
  ErrorCode::NOT_ALLOWED_ADD_CONTACT,
  ErrorCode::NOT_CERTIFICATED,
  ErrorCode::NOT_ALLOWED_SECONDARY_DEVICE,
  ErrorCode::INVALID_PIN_CODE,
  ErrorCode::NOT_FOUND_IDENTITY_CREDENTIAL,
  ErrorCode::EXCEED_FILE_MAX_SIZE,
  ErrorCode::EXCEED_DAILY_QUOTA,
  ErrorCode::NOT_SUPPORT_SEND_FILE,
  ErrorCode::MUST_UPGRADE,
  ErrorCode::NOT_AVAILABLE_PIN_CODE_SESSION
};
const char* _kErrorCodeNames[] = {
  "ILLEGAL_ARGUMENT",
  "AUTHENTICATION_FAILED",
  "DB_FAILED",
  "INVALID_STATE",
  "EXCESSIVE_ACCESS",
  "NOT_FOUND",
  "INVALID_LENGTH",
  "NOT_AVAILABLE_USER",
  "NOT_AUTHORIZED_DEVICE",
  "INVALID_MID",
  "NOT_A_MEMBER",
  "INCOMPATIBLE_APP_VERSION",
  "NOT_READY",
  "NOT_AVAILABLE_SESSION",
  "NOT_AUTHORIZED_SESSION",
  "SYSTEM_ERROR",
  "NO_AVAILABLE_VERIFICATION_METHOD",
  "NOT_AUTHENTICATED",
  "INVALID_IDENTITY_CREDENTIAL",
  "NOT_AVAILABLE_IDENTITY_IDENTIFIER",
  "INTERNAL_ERROR",
  "NO_SUCH_IDENTITY_IDENFIER",
  "DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY",
  "ILLEGAL_IDENTITY_CREDENTIAL",
  "UNKNOWN_CHANNEL",
  "NO_SUCH_MESSAGE_BOX",
  "NOT_AVAILABLE_MESSAGE_BOX",
  "CHANNEL_DOES_NOT_MATCH",
  "NOT_YOUR_MESSAGE",
  "MESSAGE_DEFINED_ERROR",
  "USER_CANNOT_ACCEPT_PRESENTS",
  "USER_NOT_STICKER_OWNER",
  "MAINTENANCE_ERROR",
  "ACCOUNT_NOT_MATCHED",
  "ABUSE_BLOCK",
  "NOT_FRIEND",
  "NOT_ALLOWED_CALL",
  "BLOCK_FRIEND",
  "INCOMPATIBLE_VOIP_VERSION",
  "INVALID_SNS_ACCESS_TOKEN",
  "EXTERNAL_SERVICE_NOT_AVAILABLE",
  "NOT_ALLOWED_ADD_CONTACT",
  "NOT_CERTIFICATED",
  "NOT_ALLOWED_SECONDARY_DEVICE",
  "INVALID_PIN_CODE",
  "NOT_FOUND_IDENTITY_CREDENTIAL",
  "EXCEED_FILE_MAX_SIZE",
  "EXCEED_DAILY_QUOTA",
  "NOT_SUPPORT_SEND_FILE",
  "MUST_UPGRADE",
  "NOT_AVAILABLE_PIN_CODE_SESSION"
};
const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(51, _kErrorCodeValues, _kErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFeatureTypeValues[] = {
  FeatureType::OBJECT_STORAGE
};
const char* _kFeatureTypeNames[] = {
  "OBJECT_STORAGE"
};
const std::map<int, const char*> _FeatureType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFeatureTypeValues, _kFeatureTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const FeatureType::type& val) {
  std::map<int, const char*>::const_iterator it = _FeatureType_VALUES_TO_NAMES.find(val);
  if (it != _FeatureType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FeatureType::type& val) {
  std::map<int, const char*>::const_iterator it = _FeatureType_VALUES_TO_NAMES.find(val);
  if (it != _FeatureType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kGroupAttributeValues[] = {
  GroupAttribute::NAME,
  GroupAttribute::PICTURE_STATUS,
  GroupAttribute::ALL
};
const char* _kGroupAttributeNames[] = {
  "NAME",
  "PICTURE_STATUS",
  "ALL"
};
const std::map<int, const char*> _GroupAttribute_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kGroupAttributeValues, _kGroupAttributeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const GroupAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _GroupAttribute_VALUES_TO_NAMES.find(val);
  if (it != _GroupAttribute_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GroupAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _GroupAttribute_VALUES_TO_NAMES.find(val);
  if (it != _GroupAttribute_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kIdentityProviderValues[] = {
  IdentityProvider::UNKNOWN,
  IdentityProvider::LINE,
  IdentityProvider::NAVER_KR
};
const char* _kIdentityProviderNames[] = {
  "UNKNOWN",
  "LINE",
  "NAVER_KR"
};
const std::map<int, const char*> _IdentityProvider_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kIdentityProviderValues, _kIdentityProviderNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const IdentityProvider::type& val) {
  std::map<int, const char*>::const_iterator it = _IdentityProvider_VALUES_TO_NAMES.find(val);
  if (it != _IdentityProvider_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const IdentityProvider::type& val) {
  std::map<int, const char*>::const_iterator it = _IdentityProvider_VALUES_TO_NAMES.find(val);
  if (it != _IdentityProvider_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLoginResultTypeValues[] = {
  LoginResultType::SUCCESS,
  LoginResultType::REQUIRE_QRCODE,
  LoginResultType::REQUIRE_DEVICE_CONFIRM
};
const char* _kLoginResultTypeNames[] = {
  "SUCCESS",
  "REQUIRE_QRCODE",
  "REQUIRE_DEVICE_CONFIRM"
};
const std::map<int, const char*> _LoginResultType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLoginResultTypeValues, _kLoginResultTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LoginResultType::type& val) {
  std::map<int, const char*>::const_iterator it = _LoginResultType_VALUES_TO_NAMES.find(val);
  if (it != _LoginResultType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LoginResultType::type& val) {
  std::map<int, const char*>::const_iterator it = _LoginResultType_VALUES_TO_NAMES.find(val);
  if (it != _LoginResultType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMessageOperationTypeValues[] = {
  MessageOperationType::SEND_MESSAGE,
  MessageOperationType::RECEIVE_MESSAGE,
  MessageOperationType::READ_MESSAGE,
  MessageOperationType::NOTIFIED_READ_MESSAGE,
  MessageOperationType::NOTIFIED_JOIN_CHAT,
  MessageOperationType::FAILED_SEND_MESSAGE,
  MessageOperationType::SEND_CONTENT,
  MessageOperationType::SEND_CONTENT_RECEIPT,
  MessageOperationType::SEND_CHAT_REMOVED,
  MessageOperationType::REMOVE_ALL_MESSAGES
};
const char* _kMessageOperationTypeNames[] = {
  "SEND_MESSAGE",
  "RECEIVE_MESSAGE",
  "READ_MESSAGE",
  "NOTIFIED_READ_MESSAGE",
  "NOTIFIED_JOIN_CHAT",
  "FAILED_SEND_MESSAGE",
  "SEND_CONTENT",
  "SEND_CONTENT_RECEIPT",
  "SEND_CHAT_REMOVED",
  "REMOVE_ALL_MESSAGES"
};
const std::map<int, const char*> _MessageOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kMessageOperationTypeValues, _kMessageOperationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MessageOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _MessageOperationType_VALUES_TO_NAMES.find(val);
  if (it != _MessageOperationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MessageOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _MessageOperationType_VALUES_TO_NAMES.find(val);
  if (it != _MessageOperationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMIDTypeValues[] = {
  MIDType::USER,
  MIDType::ROOM,
  MIDType::GROUP
};
const char* _kMIDTypeNames[] = {
  "USER",
  "ROOM",
  "GROUP"
};
const std::map<int, const char*> _MIDType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMIDTypeValues, _kMIDTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MIDType::type& val) {
  std::map<int, const char*>::const_iterator it = _MIDType_VALUES_TO_NAMES.find(val);
  if (it != _MIDType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MIDType::type& val) {
  std::map<int, const char*>::const_iterator it = _MIDType_VALUES_TO_NAMES.find(val);
  if (it != _MIDType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kModificationTypeValues[] = {
  ModificationType::ADD,
  ModificationType::REMOVE,
  ModificationType::MODIFY
};
const char* _kModificationTypeNames[] = {
  "ADD",
  "REMOVE",
  "MODIFY"
};
const std::map<int, const char*> _ModificationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kModificationTypeValues, _kModificationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ModificationType::type& val) {
  std::map<int, const char*>::const_iterator it = _ModificationType_VALUES_TO_NAMES.find(val);
  if (it != _ModificationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ModificationType::type& val) {
  std::map<int, const char*>::const_iterator it = _ModificationType_VALUES_TO_NAMES.find(val);
  if (it != _ModificationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNotificationItemFetchModeValues[] = {
  NotificationItemFetchMode::ALL,
  NotificationItemFetchMode::APPEND
};
const char* _kNotificationItemFetchModeNames[] = {
  "ALL",
  "APPEND"
};
const std::map<int, const char*> _NotificationItemFetchMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kNotificationItemFetchModeValues, _kNotificationItemFetchModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NotificationItemFetchMode::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationItemFetchMode_VALUES_TO_NAMES.find(val);
  if (it != _NotificationItemFetchMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NotificationItemFetchMode::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationItemFetchMode_VALUES_TO_NAMES.find(val);
  if (it != _NotificationItemFetchMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNotificationQueueTypeValues[] = {
  NotificationQueueType::GLOBAL,
  NotificationQueueType::MESSAGE,
  NotificationQueueType::PRIMARY
};
const char* _kNotificationQueueTypeNames[] = {
  "GLOBAL",
  "MESSAGE",
  "PRIMARY"
};
const std::map<int, const char*> _NotificationQueueType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kNotificationQueueTypeValues, _kNotificationQueueTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NotificationQueueType::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationQueueType_VALUES_TO_NAMES.find(val);
  if (it != _NotificationQueueType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NotificationQueueType::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationQueueType_VALUES_TO_NAMES.find(val);
  if (it != _NotificationQueueType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNotificationStatusValues[] = {
  NotificationStatus::NOTIFICATION_ITEM_EXIST,
  NotificationStatus::TIMELINE_ITEM_EXIST,
  NotificationStatus::NOTE_GROUP_NEW_ITEM_EXIST,
  NotificationStatus::TIMELINE_BUDDYGROUP_CHANGED,
  NotificationStatus::NOTE_ONE_TO_ONE_NEW_ITEM_EXIST,
  NotificationStatus::ALBUM_ITEM_EXIST,
  NotificationStatus::TIMELINE_ITEM_DELETED
};
const char* _kNotificationStatusNames[] = {
  "NOTIFICATION_ITEM_EXIST",
  "TIMELINE_ITEM_EXIST",
  "NOTE_GROUP_NEW_ITEM_EXIST",
  "TIMELINE_BUDDYGROUP_CHANGED",
  "NOTE_ONE_TO_ONE_NEW_ITEM_EXIST",
  "ALBUM_ITEM_EXIST",
  "TIMELINE_ITEM_DELETED"
};
const std::map<int, const char*> _NotificationStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kNotificationStatusValues, _kNotificationStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NotificationStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationStatus_VALUES_TO_NAMES.find(val);
  if (it != _NotificationStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NotificationStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationStatus_VALUES_TO_NAMES.find(val);
  if (it != _NotificationStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNotificationTypeValues[] = {
  NotificationType::APPLE_APNS,
  NotificationType::GOOGLE_C2DM,
  NotificationType::NHN_NNI,
  NotificationType::SKT_AOM,
  NotificationType::MS_MPNS,
  NotificationType::RIM_BIS,
  NotificationType::GOOGLE_GCM,
  NotificationType::NOKIA_NNAPI,
  NotificationType::TIZEN,
  NotificationType::LINE_BOT,
  NotificationType::LINE_WAP
};
const char* _kNotificationTypeNames[] = {
  "APPLE_APNS",
  "GOOGLE_C2DM",
  "NHN_NNI",
  "SKT_AOM",
  "MS_MPNS",
  "RIM_BIS",
  "GOOGLE_GCM",
  "NOKIA_NNAPI",
  "TIZEN",
  "LINE_BOT",
  "LINE_WAP"
};
const std::map<int, const char*> _NotificationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kNotificationTypeValues, _kNotificationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NotificationType::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationType_VALUES_TO_NAMES.find(val);
  if (it != _NotificationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NotificationType::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationType_VALUES_TO_NAMES.find(val);
  if (it != _NotificationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kOpStatusValues[] = {
  OpStatus::NORMAL,
  OpStatus::ALERT_DISABLED
};
const char* _kOpStatusNames[] = {
  "NORMAL",
  "ALERT_DISABLED"
};
const std::map<int, const char*> _OpStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kOpStatusValues, _kOpStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const OpStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _OpStatus_VALUES_TO_NAMES.find(val);
  if (it != _OpStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const OpStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _OpStatus_VALUES_TO_NAMES.find(val);
  if (it != _OpStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kOpTypeValues[] = {
  OpType::END_OF_OPERATION,
  OpType::UPDATE_PROFILE,
  OpType::NOTIFIED_UPDATE_PROFILE,
  OpType::REGISTER_USERID,
  OpType::ADD_CONTACT,
  OpType::NOTIFIED_ADD_CONTACT,
  OpType::BLOCK_CONTACT,
  OpType::UNBLOCK_CONTACT,
  OpType::NOTIFIED_RECOMMEND_CONTACT,
  OpType::CREATE_GROUP,
  OpType::UPDATE_GROUP,
  OpType::NOTIFIED_UPDATE_GROUP,
  OpType::INVITE_INTO_GROUP,
  OpType::NOTIFIED_INVITE_INTO_GROUP,
  OpType::LEAVE_GROUP,
  OpType::NOTIFIED_LEAVE_GROUP,
  OpType::ACCEPT_GROUP_INVITATION,
  OpType::NOTIFIED_ACCEPT_GROUP_INVITATION,
  OpType::KICKOUT_FROM_GROUP,
  OpType::NOTIFIED_KICKOUT_FROM_GROUP,
  OpType::CREATE_ROOM,
  OpType::INVITE_INTO_ROOM,
  OpType::NOTIFIED_INVITE_INTO_ROOM,
  OpType::LEAVE_ROOM,
  OpType::NOTIFIED_LEAVE_ROOM,
  OpType::SEND_MESSAGE,
  OpType::RECEIVE_MESSAGE,
  OpType::SEND_MESSAGE_RECEIPT,
  OpType::RECEIVE_MESSAGE_RECEIPT,
  OpType::SEND_CONTENT_RECEIPT,
  OpType::RECEIVE_ANNOUNCEMENT,
  OpType::CANCEL_INVITATION_GROUP,
  OpType::NOTIFIED_CANCEL_INVITATION_GROUP,
  OpType::NOTIFIED_UNREGISTER_USER,
  OpType::REJECT_GROUP_INVITATION,
  OpType::NOTIFIED_REJECT_GROUP_INVITATION,
  OpType::UPDATE_SETTINGS,
  OpType::NOTIFIED_REGISTER_USER,
  OpType::INVITE_VIA_EMAIL,
  OpType::NOTIFIED_REQUEST_RECOVERY,
  OpType::SEND_CHAT_CHECKED,
  OpType::SEND_CHAT_REMOVED,
  OpType::NOTIFIED_FORCE_SYNC,
  OpType::SEND_CONTENT,
  OpType::SEND_MESSAGE_MYHOME,
  OpType::NOTIFIED_UPDATE_CONTENT_PREVIEW,
  OpType::REMOVE_ALL_MESSAGES,
  OpType::NOTIFIED_UPDATE_PURCHASES,
  OpType::DUMMY,
  OpType::UPDATE_CONTACT,
  OpType::NOTIFIED_RECEIVED_CALL,
  OpType::CANCEL_CALL,
  OpType::NOTIFIED_REDIRECT,
  OpType::NOTIFIED_CHANNEL_SYNC,
  OpType::FAILED_SEND_MESSAGE,
  OpType::NOTIFIED_READ_MESSAGE,
  OpType::FAILED_EMAIL_CONFIRMATION,
  OpType::NOTIFIED_CHAT_CONTENT,
  OpType::NOTIFIED_PUSH_NOTICENTER_ITEM
};
const char* _kOpTypeNames[] = {
  "END_OF_OPERATION",
  "UPDATE_PROFILE",
  "NOTIFIED_UPDATE_PROFILE",
  "REGISTER_USERID",
  "ADD_CONTACT",
  "NOTIFIED_ADD_CONTACT",
  "BLOCK_CONTACT",
  "UNBLOCK_CONTACT",
  "NOTIFIED_RECOMMEND_CONTACT",
  "CREATE_GROUP",
  "UPDATE_GROUP",
  "NOTIFIED_UPDATE_GROUP",
  "INVITE_INTO_GROUP",
  "NOTIFIED_INVITE_INTO_GROUP",
  "LEAVE_GROUP",
  "NOTIFIED_LEAVE_GROUP",
  "ACCEPT_GROUP_INVITATION",
  "NOTIFIED_ACCEPT_GROUP_INVITATION",
  "KICKOUT_FROM_GROUP",
  "NOTIFIED_KICKOUT_FROM_GROUP",
  "CREATE_ROOM",
  "INVITE_INTO_ROOM",
  "NOTIFIED_INVITE_INTO_ROOM",
  "LEAVE_ROOM",
  "NOTIFIED_LEAVE_ROOM",
  "SEND_MESSAGE",
  "RECEIVE_MESSAGE",
  "SEND_MESSAGE_RECEIPT",
  "RECEIVE_MESSAGE_RECEIPT",
  "SEND_CONTENT_RECEIPT",
  "RECEIVE_ANNOUNCEMENT",
  "CANCEL_INVITATION_GROUP",
  "NOTIFIED_CANCEL_INVITATION_GROUP",
  "NOTIFIED_UNREGISTER_USER",
  "REJECT_GROUP_INVITATION",
  "NOTIFIED_REJECT_GROUP_INVITATION",
  "UPDATE_SETTINGS",
  "NOTIFIED_REGISTER_USER",
  "INVITE_VIA_EMAIL",
  "NOTIFIED_REQUEST_RECOVERY",
  "SEND_CHAT_CHECKED",
  "SEND_CHAT_REMOVED",
  "NOTIFIED_FORCE_SYNC",
  "SEND_CONTENT",
  "SEND_MESSAGE_MYHOME",
  "NOTIFIED_UPDATE_CONTENT_PREVIEW",
  "REMOVE_ALL_MESSAGES",
  "NOTIFIED_UPDATE_PURCHASES",
  "DUMMY",
  "UPDATE_CONTACT",
  "NOTIFIED_RECEIVED_CALL",
  "CANCEL_CALL",
  "NOTIFIED_REDIRECT",
  "NOTIFIED_CHANNEL_SYNC",
  "FAILED_SEND_MESSAGE",
  "NOTIFIED_READ_MESSAGE",
  "FAILED_EMAIL_CONFIRMATION",
  "NOTIFIED_CHAT_CONTENT",
  "NOTIFIED_PUSH_NOTICENTER_ITEM"
};
const std::map<int, const char*> _OpType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(59, _kOpTypeValues, _kOpTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const OpType::type& val) {
  std::map<int, const char*>::const_iterator it = _OpType_VALUES_TO_NAMES.find(val);
  if (it != _OpType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const OpType::type& val) {
  std::map<int, const char*>::const_iterator it = _OpType_VALUES_TO_NAMES.find(val);
  if (it != _OpType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPayloadTypeValues[] = {
  PayloadType::PAYLOAD_BUY,
  PayloadType::PAYLOAD_CS,
  PayloadType::PAYLOAD_BONUS,
  PayloadType::PAYLOAD_EVENT
};
const char* _kPayloadTypeNames[] = {
  "PAYLOAD_BUY",
  "PAYLOAD_CS",
  "PAYLOAD_BONUS",
  "PAYLOAD_EVENT"
};
const std::map<int, const char*> _PayloadType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPayloadTypeValues, _kPayloadTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PayloadType::type& val) {
  std::map<int, const char*>::const_iterator it = _PayloadType_VALUES_TO_NAMES.find(val);
  if (it != _PayloadType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PayloadType::type& val) {
  std::map<int, const char*>::const_iterator it = _PayloadType_VALUES_TO_NAMES.find(val);
  if (it != _PayloadType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPaymentPgTypeValues[] = {
  PaymentPgType::PAYMENT_PG_NONE,
  PaymentPgType::PAYMENT_PG_AU,
  PaymentPgType::PAYMENT_PG_AL
};
const char* _kPaymentPgTypeNames[] = {
  "PAYMENT_PG_NONE",
  "PAYMENT_PG_AU",
  "PAYMENT_PG_AL"
};
const std::map<int, const char*> _PaymentPgType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPaymentPgTypeValues, _kPaymentPgTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PaymentPgType::type& val) {
  std::map<int, const char*>::const_iterator it = _PaymentPgType_VALUES_TO_NAMES.find(val);
  if (it != _PaymentPgType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PaymentPgType::type& val) {
  std::map<int, const char*>::const_iterator it = _PaymentPgType_VALUES_TO_NAMES.find(val);
  if (it != _PaymentPgType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPaymentTypeValues[] = {
  PaymentType::PAYMENT_APPLE,
  PaymentType::PAYMENT_GOOGLE
};
const char* _kPaymentTypeNames[] = {
  "PAYMENT_APPLE",
  "PAYMENT_GOOGLE"
};
const std::map<int, const char*> _PaymentType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kPaymentTypeValues, _kPaymentTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PaymentType::type& val) {
  std::map<int, const char*>::const_iterator it = _PaymentType_VALUES_TO_NAMES.find(val);
  if (it != _PaymentType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PaymentType::type& val) {
  std::map<int, const char*>::const_iterator it = _PaymentType_VALUES_TO_NAMES.find(val);
  if (it != _PaymentType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kProductBannerLinkTypeValues[] = {
  ProductBannerLinkType::BANNER_LINK_NONE,
  ProductBannerLinkType::BANNER_LINK_ITEM,
  ProductBannerLinkType::BANNER_LINK_URL,
  ProductBannerLinkType::BANNER_LINK_CATEGORY
};
const char* _kProductBannerLinkTypeNames[] = {
  "BANNER_LINK_NONE",
  "BANNER_LINK_ITEM",
  "BANNER_LINK_URL",
  "BANNER_LINK_CATEGORY"
};
const std::map<int, const char*> _ProductBannerLinkType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kProductBannerLinkTypeValues, _kProductBannerLinkTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ProductBannerLinkType::type& val) {
  std::map<int, const char*>::const_iterator it = _ProductBannerLinkType_VALUES_TO_NAMES.find(val);
  if (it != _ProductBannerLinkType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ProductBannerLinkType::type& val) {
  std::map<int, const char*>::const_iterator it = _ProductBannerLinkType_VALUES_TO_NAMES.find(val);
  if (it != _ProductBannerLinkType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kProductEventTypeValues[] = {
  ProductEventType::NO_EVENT,
  ProductEventType::CARRIER_ANY,
  ProductEventType::BUDDY_ANY,
  ProductEventType::INSTALL_IOS,
  ProductEventType::INSTALL_ANDROID,
  ProductEventType::MISSION_ANY,
  ProductEventType::MUSTBUY_ANY
};
const char* _kProductEventTypeNames[] = {
  "NO_EVENT",
  "CARRIER_ANY",
  "BUDDY_ANY",
  "INSTALL_IOS",
  "INSTALL_ANDROID",
  "MISSION_ANY",
  "MUSTBUY_ANY"
};
const std::map<int, const char*> _ProductEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kProductEventTypeValues, _kProductEventTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ProductEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _ProductEventType_VALUES_TO_NAMES.find(val);
  if (it != _ProductEventType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ProductEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _ProductEventType_VALUES_TO_NAMES.find(val);
  if (it != _ProductEventType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kProfileAttributeValues[] = {
  ProfileAttribute::EMAIL,
  ProfileAttribute::DISPLAY_NAME,
  ProfileAttribute::PHONETIC_NAME,
  ProfileAttribute::PICTURE,
  ProfileAttribute::STATUS_MESSAGE,
  ProfileAttribute::ALLOW_SEARCH_BY_USERID,
  ProfileAttribute::ALLOW_SEARCH_BY_EMAIL,
  ProfileAttribute::BUDDY_STATUS,
  ProfileAttribute::ALL
};
const char* _kProfileAttributeNames[] = {
  "EMAIL",
  "DISPLAY_NAME",
  "PHONETIC_NAME",
  "PICTURE",
  "STATUS_MESSAGE",
  "ALLOW_SEARCH_BY_USERID",
  "ALLOW_SEARCH_BY_EMAIL",
  "BUDDY_STATUS",
  "ALL"
};
const std::map<int, const char*> _ProfileAttribute_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kProfileAttributeValues, _kProfileAttributeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ProfileAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _ProfileAttribute_VALUES_TO_NAMES.find(val);
  if (it != _ProfileAttribute_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ProfileAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _ProfileAttribute_VALUES_TO_NAMES.find(val);
  if (it != _ProfileAttribute_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPublicTypeValues[] = {
  PublicType::HIDDEN,
  PublicType::PUBLIC
};
const char* _kPublicTypeNames[] = {
  "HIDDEN",
  "PUBLIC"
};
const std::map<int, const char*> _PublicType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kPublicTypeValues, _kPublicTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PublicType::type& val) {
  std::map<int, const char*>::const_iterator it = _PublicType_VALUES_TO_NAMES.find(val);
  if (it != _PublicType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PublicType::type& val) {
  std::map<int, const char*>::const_iterator it = _PublicType_VALUES_TO_NAMES.find(val);
  if (it != _PublicType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kRedirectTypeValues[] = {
  RedirectType::NONE,
  RedirectType::EXPIRE_SECOND
};
const char* _kRedirectTypeNames[] = {
  "NONE",
  "EXPIRE_SECOND"
};
const std::map<int, const char*> _RedirectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kRedirectTypeValues, _kRedirectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RedirectType::type& val) {
  std::map<int, const char*>::const_iterator it = _RedirectType_VALUES_TO_NAMES.find(val);
  if (it != _RedirectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RedirectType::type& val) {
  std::map<int, const char*>::const_iterator it = _RedirectType_VALUES_TO_NAMES.find(val);
  if (it != _RedirectType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kRegistrationTypeValues[] = {
  RegistrationType::PHONE,
  RegistrationType::EMAIL_WAP,
  RegistrationType::FACEBOOK,
  RegistrationType::SINA,
  RegistrationType::RENREN,
  RegistrationType::FEIXIN
};
const char* _kRegistrationTypeNames[] = {
  "PHONE",
  "EMAIL_WAP",
  "FACEBOOK",
  "SINA",
  "RENREN",
  "FEIXIN"
};
const std::map<int, const char*> _RegistrationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kRegistrationTypeValues, _kRegistrationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RegistrationType::type& val) {
  std::map<int, const char*>::const_iterator it = _RegistrationType_VALUES_TO_NAMES.find(val);
  if (it != _RegistrationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RegistrationType::type& val) {
  std::map<int, const char*>::const_iterator it = _RegistrationType_VALUES_TO_NAMES.find(val);
  if (it != _RegistrationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSettingsAttributeValues[] = {
  SettingsAttribute::NOTIFICATION_ENABLE,
  SettingsAttribute::NOTIFICATION_MUTE_EXPIRATION,
  SettingsAttribute::NOTIFICATION_NEW_MESSAGE,
  SettingsAttribute::NOTIFICATION_GROUP_INVITATION,
  SettingsAttribute::NOTIFICATION_SHOW_MESSAGE,
  SettingsAttribute::NOTIFICATION_INCOMING_CALL,
  SettingsAttribute::PRIVACY_SYNC_CONTACTS,
  SettingsAttribute::PRIVACY_SEARCH_BY_PHONE_NUMBER,
  SettingsAttribute::NOTIFICATION_SOUND_MESSAGE,
  SettingsAttribute::NOTIFICATION_SOUND_GROUP,
  SettingsAttribute::CONTACT_MY_TICKET,
  SettingsAttribute::IDENTITY_PROVIDER,
  SettingsAttribute::IDENTITY_IDENTIFIER,
  SettingsAttribute::PRIVACY_SEARCH_BY_USERID,
  SettingsAttribute::PRIVACY_SEARCH_BY_EMAIL,
  SettingsAttribute::PREFERENCE_LOCALE,
  SettingsAttribute::NOTIFICATION_DISABLED_WITH_SUB,
  SettingsAttribute::SNS_ACCOUNT,
  SettingsAttribute::PHONE_REGISTRATION,
  SettingsAttribute::PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN,
  SettingsAttribute::CUSTOM_MODE,
  SettingsAttribute::PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME,
  SettingsAttribute::EMAIL_CONFIRMATION_STATUS,
  SettingsAttribute::PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND,
  SettingsAttribute::ALL
};
const char* _kSettingsAttributeNames[] = {
  "NOTIFICATION_ENABLE",
  "NOTIFICATION_MUTE_EXPIRATION",
  "NOTIFICATION_NEW_MESSAGE",
  "NOTIFICATION_GROUP_INVITATION",
  "NOTIFICATION_SHOW_MESSAGE",
  "NOTIFICATION_INCOMING_CALL",
  "PRIVACY_SYNC_CONTACTS",
  "PRIVACY_SEARCH_BY_PHONE_NUMBER",
  "NOTIFICATION_SOUND_MESSAGE",
  "NOTIFICATION_SOUND_GROUP",
  "CONTACT_MY_TICKET",
  "IDENTITY_PROVIDER",
  "IDENTITY_IDENTIFIER",
  "PRIVACY_SEARCH_BY_USERID",
  "PRIVACY_SEARCH_BY_EMAIL",
  "PREFERENCE_LOCALE",
  "NOTIFICATION_DISABLED_WITH_SUB",
  "SNS_ACCOUNT",
  "PHONE_REGISTRATION",
  "PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN",
  "CUSTOM_MODE",
  "PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME",
  "EMAIL_CONFIRMATION_STATUS",
  "PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND",
  "ALL"
};
const std::map<int, const char*> _SettingsAttribute_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(25, _kSettingsAttributeValues, _kSettingsAttributeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SettingsAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _SettingsAttribute_VALUES_TO_NAMES.find(val);
  if (it != _SettingsAttribute_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SettingsAttribute::type& val) {
  std::map<int, const char*>::const_iterator it = _SettingsAttribute_VALUES_TO_NAMES.find(val);
  if (it != _SettingsAttribute_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSnsIdTypeValues[] = {
  SnsIdType::FACEBOOK,
  SnsIdType::SINA,
  SnsIdType::RENREN,
  SnsIdType::FEIXIN
};
const char* _kSnsIdTypeNames[] = {
  "FACEBOOK",
  "SINA",
  "RENREN",
  "FEIXIN"
};
const std::map<int, const char*> _SnsIdType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kSnsIdTypeValues, _kSnsIdTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SnsIdType::type& val) {
  std::map<int, const char*>::const_iterator it = _SnsIdType_VALUES_TO_NAMES.find(val);
  if (it != _SnsIdType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SnsIdType::type& val) {
  std::map<int, const char*>::const_iterator it = _SnsIdType_VALUES_TO_NAMES.find(val);
  if (it != _SnsIdType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpammerReasonValues[] = {
  SpammerReason::OTHER,
  SpammerReason::ADVERTISING,
  SpammerReason::GENDER_HARASSMENT,
  SpammerReason::HARASSMENT
};
const char* _kSpammerReasonNames[] = {
  "OTHER",
  "ADVERTISING",
  "GENDER_HARASSMENT",
  "HARASSMENT"
};
const std::map<int, const char*> _SpammerReason_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kSpammerReasonValues, _kSpammerReasonNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SpammerReason::type& val) {
  std::map<int, const char*>::const_iterator it = _SpammerReason_VALUES_TO_NAMES.find(val);
  if (it != _SpammerReason_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpammerReason::type& val) {
  std::map<int, const char*>::const_iterator it = _SpammerReason_VALUES_TO_NAMES.find(val);
  if (it != _SpammerReason_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSyncActionTypeValues[] = {
  SyncActionType::SYNC,
  SyncActionType::REPORT
};
const char* _kSyncActionTypeNames[] = {
  "SYNC",
  "REPORT"
};
const std::map<int, const char*> _SyncActionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSyncActionTypeValues, _kSyncActionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SyncActionType::type& val) {
  std::map<int, const char*>::const_iterator it = _SyncActionType_VALUES_TO_NAMES.find(val);
  if (it != _SyncActionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SyncActionType::type& val) {
  std::map<int, const char*>::const_iterator it = _SyncActionType_VALUES_TO_NAMES.find(val);
  if (it != _SyncActionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSyncCategoryValues[] = {
  SyncCategory::PROFILE,
  SyncCategory::SETTINGS,
  SyncCategory::OPS,
  SyncCategory::CONTACT,
  SyncCategory::RECOMMEND,
  SyncCategory::BLOCK,
  SyncCategory::GROUP,
  SyncCategory::ROOM,
  SyncCategory::NOTIFICATION
};
const char* _kSyncCategoryNames[] = {
  "PROFILE",
  "SETTINGS",
  "OPS",
  "CONTACT",
  "RECOMMEND",
  "BLOCK",
  "GROUP",
  "ROOM",
  "NOTIFICATION"
};
const std::map<int, const char*> _SyncCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kSyncCategoryValues, _kSyncCategoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SyncCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _SyncCategory_VALUES_TO_NAMES.find(val);
  if (it != _SyncCategory_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SyncCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _SyncCategory_VALUES_TO_NAMES.find(val);
  if (it != _SyncCategory_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTMessageBoxStatusValues[] = {
  TMessageBoxStatus::ACTIVATED,
  TMessageBoxStatus::UNREAD
};
const char* _kTMessageBoxStatusNames[] = {
  "ACTIVATED",
  "UNREAD"
};
const std::map<int, const char*> _TMessageBoxStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTMessageBoxStatusValues, _kTMessageBoxStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TMessageBoxStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _TMessageBoxStatus_VALUES_TO_NAMES.find(val);
  if (it != _TMessageBoxStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TMessageBoxStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _TMessageBoxStatus_VALUES_TO_NAMES.find(val);
  if (it != _TMessageBoxStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kUniversalNotificationServiceErrorCodeValues[] = {
  UniversalNotificationServiceErrorCode::INTERNAL_ERROR,
  UniversalNotificationServiceErrorCode::INVALID_KEY,
  UniversalNotificationServiceErrorCode::ILLEGAL_ARGUMENT,
  UniversalNotificationServiceErrorCode::TOO_MANY_REQUEST,
  UniversalNotificationServiceErrorCode::AUTHENTICATION_FAILED,
  UniversalNotificationServiceErrorCode::NO_WRITE_PERMISSION
};
const char* _kUniversalNotificationServiceErrorCodeNames[] = {
  "INTERNAL_ERROR",
  "INVALID_KEY",
  "ILLEGAL_ARGUMENT",
  "TOO_MANY_REQUEST",
  "AUTHENTICATION_FAILED",
  "NO_WRITE_PERMISSION"
};
const std::map<int, const char*> _UniversalNotificationServiceErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kUniversalNotificationServiceErrorCodeValues, _kUniversalNotificationServiceErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const UniversalNotificationServiceErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _UniversalNotificationServiceErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _UniversalNotificationServiceErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const UniversalNotificationServiceErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _UniversalNotificationServiceErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _UniversalNotificationServiceErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kUnregistrationReasonValues[] = {
  UnregistrationReason::UNREGISTRATION_REASON_UNREGISTER_USER,
  UnregistrationReason::UNREGISTRATION_REASON_UNBIND_DEVICE
};
const char* _kUnregistrationReasonNames[] = {
  "UNREGISTRATION_REASON_UNREGISTER_USER",
  "UNREGISTRATION_REASON_UNBIND_DEVICE"
};
const std::map<int, const char*> _UnregistrationReason_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kUnregistrationReasonValues, _kUnregistrationReasonNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const UnregistrationReason::type& val) {
  std::map<int, const char*>::const_iterator it = _UnregistrationReason_VALUES_TO_NAMES.find(val);
  if (it != _UnregistrationReason_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const UnregistrationReason::type& val) {
  std::map<int, const char*>::const_iterator it = _UnregistrationReason_VALUES_TO_NAMES.find(val);
  if (it != _UnregistrationReason_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kUserAgeTypeValues[] = {
  UserAgeType::OVER,
  UserAgeType::UNDER,
  UserAgeType::UNDEFINED
};
const char* _kUserAgeTypeNames[] = {
  "OVER",
  "UNDER",
  "UNDEFINED"
};
const std::map<int, const char*> _UserAgeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kUserAgeTypeValues, _kUserAgeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const UserAgeType::type& val) {
  std::map<int, const char*>::const_iterator it = _UserAgeType_VALUES_TO_NAMES.find(val);
  if (it != _UserAgeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const UserAgeType::type& val) {
  std::map<int, const char*>::const_iterator it = _UserAgeType_VALUES_TO_NAMES.find(val);
  if (it != _UserAgeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kVerificationMethodValues[] = {
  VerificationMethod::NO_AVAILABLE,
  VerificationMethod::PIN_VIA_SMS,
  VerificationMethod::CALLERID_INDIGO,
  VerificationMethod::PIN_VIA_TTS,
  VerificationMethod::SKIP
};
const char* _kVerificationMethodNames[] = {
  "NO_AVAILABLE",
  "PIN_VIA_SMS",
  "CALLERID_INDIGO",
  "PIN_VIA_TTS",
  "SKIP"
};
const std::map<int, const char*> _VerificationMethod_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kVerificationMethodValues, _kVerificationMethodNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const VerificationMethod::type& val) {
  std::map<int, const char*>::const_iterator it = _VerificationMethod_VALUES_TO_NAMES.find(val);
  if (it != _VerificationMethod_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const VerificationMethod::type& val) {
  std::map<int, const char*>::const_iterator it = _VerificationMethod_VALUES_TO_NAMES.find(val);
  if (it != _VerificationMethod_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kVerificationResultValues[] = {
  VerificationResult::FAILED,
  VerificationResult::OK_NOT_REGISTERED_YET,
  VerificationResult::OK_REGISTERED_WITH_SAME_DEVICE,
  VerificationResult::OK_REGISTERED_WITH_ANOTHER_DEVICE
};
const char* _kVerificationResultNames[] = {
  "FAILED",
  "OK_NOT_REGISTERED_YET",
  "OK_REGISTERED_WITH_SAME_DEVICE",
  "OK_REGISTERED_WITH_ANOTHER_DEVICE"
};
const std::map<int, const char*> _VerificationResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kVerificationResultValues, _kVerificationResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const VerificationResult::type& val) {
  std::map<int, const char*>::const_iterator it = _VerificationResult_VALUES_TO_NAMES.find(val);
  if (it != _VerificationResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const VerificationResult::type& val) {
  std::map<int, const char*>::const_iterator it = _VerificationResult_VALUES_TO_NAMES.find(val);
  if (it != _VerificationResult_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kWapInvitationTypeValues[] = {
  WapInvitationType::REGISTRATION,
  WapInvitationType::CHAT
};
const char* _kWapInvitationTypeNames[] = {
  "REGISTRATION",
  "CHAT"
};
const std::map<int, const char*> _WapInvitationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kWapInvitationTypeValues, _kWapInvitationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const WapInvitationType::type& val) {
  std::map<int, const char*>::const_iterator it = _WapInvitationType_VALUES_TO_NAMES.find(val);
  if (it != _WapInvitationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const WapInvitationType::type& val) {
  std::map<int, const char*>::const_iterator it = _WapInvitationType_VALUES_TO_NAMES.find(val);
  if (it != _WapInvitationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


AgeCheckDocomoResult::~AgeCheckDocomoResult() noexcept {
}


void AgeCheckDocomoResult::__set_authUrl(const std::string& val) {
  this->authUrl = val;
}

void AgeCheckDocomoResult::__set_userAgeType(const UserAgeType::type val) {
  this->userAgeType = val;
}
std::ostream& operator<<(std::ostream& out, const AgeCheckDocomoResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AgeCheckDocomoResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authUrl);
          this->__isset.authUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->userAgeType = (UserAgeType::type)ecast0;
          this->__isset.userAgeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AgeCheckDocomoResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AgeCheckDocomoResult");

  xfer += oprot->writeFieldBegin("authUrl", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userAgeType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->userAgeType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AgeCheckDocomoResult &a, AgeCheckDocomoResult &b) {
  using ::std::swap;
  swap(a.authUrl, b.authUrl);
  swap(a.userAgeType, b.userAgeType);
  swap(a.__isset, b.__isset);
}

AgeCheckDocomoResult::AgeCheckDocomoResult(const AgeCheckDocomoResult& other1) {
  authUrl = other1.authUrl;
  userAgeType = other1.userAgeType;
  __isset = other1.__isset;
}
AgeCheckDocomoResult& AgeCheckDocomoResult::operator=(const AgeCheckDocomoResult& other2) {
  authUrl = other2.authUrl;
  userAgeType = other2.userAgeType;
  __isset = other2.__isset;
  return *this;
}
void AgeCheckDocomoResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AgeCheckDocomoResult(";
  out << "authUrl=" << to_string(authUrl);
  out << ", " << "userAgeType=" << to_string(userAgeType);
  out << ")";
}


AgeCheckRequestResult::~AgeCheckRequestResult() noexcept {
}


void AgeCheckRequestResult::__set_authUrl(const std::string& val) {
  this->authUrl = val;
}

void AgeCheckRequestResult::__set_sessionId(const std::string& val) {
  this->sessionId = val;
}
std::ostream& operator<<(std::ostream& out, const AgeCheckRequestResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AgeCheckRequestResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authUrl);
          this->__isset.authUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AgeCheckRequestResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AgeCheckRequestResult");

  xfer += oprot->writeFieldBegin("authUrl", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AgeCheckRequestResult &a, AgeCheckRequestResult &b) {
  using ::std::swap;
  swap(a.authUrl, b.authUrl);
  swap(a.sessionId, b.sessionId);
  swap(a.__isset, b.__isset);
}

AgeCheckRequestResult::AgeCheckRequestResult(const AgeCheckRequestResult& other3) {
  authUrl = other3.authUrl;
  sessionId = other3.sessionId;
  __isset = other3.__isset;
}
AgeCheckRequestResult& AgeCheckRequestResult::operator=(const AgeCheckRequestResult& other4) {
  authUrl = other4.authUrl;
  sessionId = other4.sessionId;
  __isset = other4.__isset;
  return *this;
}
void AgeCheckRequestResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AgeCheckRequestResult(";
  out << "authUrl=" << to_string(authUrl);
  out << ", " << "sessionId=" << to_string(sessionId);
  out << ")";
}


Announcement::~Announcement() noexcept {
}


void Announcement::__set_index(const int32_t val) {
  this->index = val;
}

void Announcement::__set_forceUpdate(const bool val) {
  this->forceUpdate = val;
}

void Announcement::__set_title(const std::string& val) {
  this->title = val;
}

void Announcement::__set_text(const std::string& val) {
  this->text = val;
}

void Announcement::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void Announcement::__set_pictureUrl(const std::string& val) {
  this->pictureUrl = val;
}

void Announcement::__set_thumbnailUrl(const std::string& val) {
  this->thumbnailUrl = val;
}
std::ostream& operator<<(std::ostream& out, const Announcement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Announcement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->forceUpdate);
          this->__isset.forceUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pictureUrl);
          this->__isset.pictureUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thumbnailUrl);
          this->__isset.thumbnailUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Announcement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Announcement");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forceUpdate", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->forceUpdate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pictureUrl", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->pictureUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thumbnailUrl", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->thumbnailUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Announcement &a, Announcement &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.forceUpdate, b.forceUpdate);
  swap(a.title, b.title);
  swap(a.text, b.text);
  swap(a.createdTime, b.createdTime);
  swap(a.pictureUrl, b.pictureUrl);
  swap(a.thumbnailUrl, b.thumbnailUrl);
  swap(a.__isset, b.__isset);
}

Announcement::Announcement(const Announcement& other5) {
  index = other5.index;
  forceUpdate = other5.forceUpdate;
  title = other5.title;
  text = other5.text;
  createdTime = other5.createdTime;
  pictureUrl = other5.pictureUrl;
  thumbnailUrl = other5.thumbnailUrl;
  __isset = other5.__isset;
}
Announcement& Announcement::operator=(const Announcement& other6) {
  index = other6.index;
  forceUpdate = other6.forceUpdate;
  title = other6.title;
  text = other6.text;
  createdTime = other6.createdTime;
  pictureUrl = other6.pictureUrl;
  thumbnailUrl = other6.thumbnailUrl;
  __isset = other6.__isset;
  return *this;
}
void Announcement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Announcement(";
  out << "index=" << to_string(index);
  out << ", " << "forceUpdate=" << to_string(forceUpdate);
  out << ", " << "title=" << to_string(title);
  out << ", " << "text=" << to_string(text);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "pictureUrl=" << to_string(pictureUrl);
  out << ", " << "thumbnailUrl=" << to_string(thumbnailUrl);
  out << ")";
}


ChannelProvider::~ChannelProvider() noexcept {
}


void ChannelProvider::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelProvider& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelProvider::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelProvider::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelProvider");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelProvider &a, ChannelProvider &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

ChannelProvider::ChannelProvider(const ChannelProvider& other7) {
  name = other7.name;
  __isset = other7.__isset;
}
ChannelProvider& ChannelProvider::operator=(const ChannelProvider& other8) {
  name = other8.name;
  __isset = other8.__isset;
  return *this;
}
void ChannelProvider::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelProvider(";
  out << "name=" << to_string(name);
  out << ")";
}


ChannelInfo::~ChannelInfo() noexcept {
}


void ChannelInfo::__set_channelId(const std::string& val) {
  this->channelId = val;
}

void ChannelInfo::__set_name(const std::string& val) {
  this->name = val;
}

void ChannelInfo::__set_entryPageUrl(const std::string& val) {
  this->entryPageUrl = val;
}

void ChannelInfo::__set_descriptionText(const std::string& val) {
  this->descriptionText = val;
}

void ChannelInfo::__set_provider(const ChannelProvider& val) {
  this->provider = val;
}

void ChannelInfo::__set_publicType(const PublicType::type val) {
  this->publicType = val;
}

void ChannelInfo::__set_iconImage(const std::string& val) {
  this->iconImage = val;
}

void ChannelInfo::__set_permissions(const std::vector<std::string> & val) {
  this->permissions = val;
}

void ChannelInfo::__set_iconThumbnailImage(const std::string& val) {
  this->iconThumbnailImage = val;
}

void ChannelInfo::__set_channelConfigurations(const std::vector<ChannelConfiguration::type> & val) {
  this->channelConfigurations = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channelId);
          this->__isset.channelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entryPageUrl);
          this->__isset.entryPageUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->descriptionText);
          this->__isset.descriptionText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->provider.read(iprot);
          this->__isset.provider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->publicType = (PublicType::type)ecast9;
          this->__isset.publicType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iconImage);
          this->__isset.iconImage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->permissions.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->permissions.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readString(this->permissions[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iconThumbnailImage);
          this->__isset.iconThumbnailImage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->channelConfigurations.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->channelConfigurations.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              int32_t ecast20;
              xfer += iprot->readI32(ecast20);
              this->channelConfigurations[_i19] = (ChannelConfiguration::type)ecast20;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.channelConfigurations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelInfo");

  xfer += oprot->writeFieldBegin("channelId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->channelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entryPageUrl", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->entryPageUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("descriptionText", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->descriptionText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("provider", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->provider.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("publicType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->publicType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iconImage", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->iconImage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("permissions", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->permissions.size()));
    std::vector<std::string> ::const_iterator _iter21;
    for (_iter21 = this->permissions.begin(); _iter21 != this->permissions.end(); ++_iter21)
    {
      xfer += oprot->writeString((*_iter21));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iconThumbnailImage", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->iconThumbnailImage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channelConfigurations", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->channelConfigurations.size()));
    std::vector<ChannelConfiguration::type> ::const_iterator _iter22;
    for (_iter22 = this->channelConfigurations.begin(); _iter22 != this->channelConfigurations.end(); ++_iter22)
    {
      xfer += oprot->writeI32((int32_t)(*_iter22));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelInfo &a, ChannelInfo &b) {
  using ::std::swap;
  swap(a.channelId, b.channelId);
  swap(a.name, b.name);
  swap(a.entryPageUrl, b.entryPageUrl);
  swap(a.descriptionText, b.descriptionText);
  swap(a.provider, b.provider);
  swap(a.publicType, b.publicType);
  swap(a.iconImage, b.iconImage);
  swap(a.permissions, b.permissions);
  swap(a.iconThumbnailImage, b.iconThumbnailImage);
  swap(a.channelConfigurations, b.channelConfigurations);
  swap(a.__isset, b.__isset);
}

ChannelInfo::ChannelInfo(const ChannelInfo& other23) {
  channelId = other23.channelId;
  name = other23.name;
  entryPageUrl = other23.entryPageUrl;
  descriptionText = other23.descriptionText;
  provider = other23.provider;
  publicType = other23.publicType;
  iconImage = other23.iconImage;
  permissions = other23.permissions;
  iconThumbnailImage = other23.iconThumbnailImage;
  channelConfigurations = other23.channelConfigurations;
  __isset = other23.__isset;
}
ChannelInfo& ChannelInfo::operator=(const ChannelInfo& other24) {
  channelId = other24.channelId;
  name = other24.name;
  entryPageUrl = other24.entryPageUrl;
  descriptionText = other24.descriptionText;
  provider = other24.provider;
  publicType = other24.publicType;
  iconImage = other24.iconImage;
  permissions = other24.permissions;
  iconThumbnailImage = other24.iconThumbnailImage;
  channelConfigurations = other24.channelConfigurations;
  __isset = other24.__isset;
  return *this;
}
void ChannelInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelInfo(";
  out << "channelId=" << to_string(channelId);
  out << ", " << "name=" << to_string(name);
  out << ", " << "entryPageUrl=" << to_string(entryPageUrl);
  out << ", " << "descriptionText=" << to_string(descriptionText);
  out << ", " << "provider=" << to_string(provider);
  out << ", " << "publicType=" << to_string(publicType);
  out << ", " << "iconImage=" << to_string(iconImage);
  out << ", " << "permissions=" << to_string(permissions);
  out << ", " << "iconThumbnailImage=" << to_string(iconThumbnailImage);
  out << ", " << "channelConfigurations=" << to_string(channelConfigurations);
  out << ")";
}


ApprovedChannelInfo::~ApprovedChannelInfo() noexcept {
}


void ApprovedChannelInfo::__set_channelInfo(const ChannelInfo& val) {
  this->channelInfo = val;
}

void ApprovedChannelInfo::__set_approvedAt(const int64_t val) {
  this->approvedAt = val;
}
std::ostream& operator<<(std::ostream& out, const ApprovedChannelInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApprovedChannelInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->channelInfo.read(iprot);
          this->__isset.channelInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->approvedAt);
          this->__isset.approvedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ApprovedChannelInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApprovedChannelInfo");

  xfer += oprot->writeFieldBegin("channelInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->channelInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("approvedAt", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->approvedAt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApprovedChannelInfo &a, ApprovedChannelInfo &b) {
  using ::std::swap;
  swap(a.channelInfo, b.channelInfo);
  swap(a.approvedAt, b.approvedAt);
  swap(a.__isset, b.__isset);
}

ApprovedChannelInfo::ApprovedChannelInfo(const ApprovedChannelInfo& other25) {
  channelInfo = other25.channelInfo;
  approvedAt = other25.approvedAt;
  __isset = other25.__isset;
}
ApprovedChannelInfo& ApprovedChannelInfo::operator=(const ApprovedChannelInfo& other26) {
  channelInfo = other26.channelInfo;
  approvedAt = other26.approvedAt;
  __isset = other26.__isset;
  return *this;
}
void ApprovedChannelInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApprovedChannelInfo(";
  out << "channelInfo=" << to_string(channelInfo);
  out << ", " << "approvedAt=" << to_string(approvedAt);
  out << ")";
}


ApprovedChannelInfos::~ApprovedChannelInfos() noexcept {
}


void ApprovedChannelInfos::__set_approvedChannelInfos(const std::vector<ApprovedChannelInfo> & val) {
  this->approvedChannelInfos = val;
}

void ApprovedChannelInfos::__set_revision(const int64_t val) {
  this->revision = val;
}
std::ostream& operator<<(std::ostream& out, const ApprovedChannelInfos& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApprovedChannelInfos::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->approvedChannelInfos.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->approvedChannelInfos.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->approvedChannelInfos[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.approvedChannelInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ApprovedChannelInfos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApprovedChannelInfos");

  xfer += oprot->writeFieldBegin("approvedChannelInfos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->approvedChannelInfos.size()));
    std::vector<ApprovedChannelInfo> ::const_iterator _iter32;
    for (_iter32 = this->approvedChannelInfos.begin(); _iter32 != this->approvedChannelInfos.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApprovedChannelInfos &a, ApprovedChannelInfos &b) {
  using ::std::swap;
  swap(a.approvedChannelInfos, b.approvedChannelInfos);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

ApprovedChannelInfos::ApprovedChannelInfos(const ApprovedChannelInfos& other33) {
  approvedChannelInfos = other33.approvedChannelInfos;
  revision = other33.revision;
  __isset = other33.__isset;
}
ApprovedChannelInfos& ApprovedChannelInfos::operator=(const ApprovedChannelInfos& other34) {
  approvedChannelInfos = other34.approvedChannelInfos;
  revision = other34.revision;
  __isset = other34.__isset;
  return *this;
}
void ApprovedChannelInfos::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApprovedChannelInfos(";
  out << "approvedChannelInfos=" << to_string(approvedChannelInfos);
  out << ", " << "revision=" << to_string(revision);
  out << ")";
}


AuthQrcode::~AuthQrcode() noexcept {
}


void AuthQrcode::__set_qrcode(const std::string& val) {
  this->qrcode = val;
}

void AuthQrcode::__set_verifier(const std::string& val) {
  this->verifier = val;
}
std::ostream& operator<<(std::ostream& out, const AuthQrcode& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AuthQrcode::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->qrcode);
          this->__isset.qrcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->verifier);
          this->__isset.verifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AuthQrcode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AuthQrcode");

  xfer += oprot->writeFieldBegin("qrcode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->qrcode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("verifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->verifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthQrcode &a, AuthQrcode &b) {
  using ::std::swap;
  swap(a.qrcode, b.qrcode);
  swap(a.verifier, b.verifier);
  swap(a.__isset, b.__isset);
}

AuthQrcode::AuthQrcode(const AuthQrcode& other35) {
  qrcode = other35.qrcode;
  verifier = other35.verifier;
  __isset = other35.__isset;
}
AuthQrcode& AuthQrcode::operator=(const AuthQrcode& other36) {
  qrcode = other36.qrcode;
  verifier = other36.verifier;
  __isset = other36.__isset;
  return *this;
}
void AuthQrcode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AuthQrcode(";
  out << "qrcode=" << to_string(qrcode);
  out << ", " << "verifier=" << to_string(verifier);
  out << ")";
}


BuddyBanner::~BuddyBanner() noexcept {
}


void BuddyBanner::__set_buddyBannerLinkType(const BuddyBannerLinkType::type val) {
  this->buddyBannerLinkType = val;
}

void BuddyBanner::__set_buddyBannerLink(const std::string& val) {
  this->buddyBannerLink = val;
}

void BuddyBanner::__set_buddyBannerImageUrl(const std::string& val) {
  this->buddyBannerImageUrl = val;
}
std::ostream& operator<<(std::ostream& out, const BuddyBanner& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddyBanner::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast37;
          xfer += iprot->readI32(ecast37);
          this->buddyBannerLinkType = (BuddyBannerLinkType::type)ecast37;
          this->__isset.buddyBannerLinkType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->buddyBannerLink);
          this->__isset.buddyBannerLink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->buddyBannerImageUrl);
          this->__isset.buddyBannerImageUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddyBanner::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddyBanner");

  xfer += oprot->writeFieldBegin("buddyBannerLinkType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->buddyBannerLinkType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buddyBannerLink", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->buddyBannerLink);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buddyBannerImageUrl", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->buddyBannerImageUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddyBanner &a, BuddyBanner &b) {
  using ::std::swap;
  swap(a.buddyBannerLinkType, b.buddyBannerLinkType);
  swap(a.buddyBannerLink, b.buddyBannerLink);
  swap(a.buddyBannerImageUrl, b.buddyBannerImageUrl);
  swap(a.__isset, b.__isset);
}

BuddyBanner::BuddyBanner(const BuddyBanner& other38) {
  buddyBannerLinkType = other38.buddyBannerLinkType;
  buddyBannerLink = other38.buddyBannerLink;
  buddyBannerImageUrl = other38.buddyBannerImageUrl;
  __isset = other38.__isset;
}
BuddyBanner& BuddyBanner::operator=(const BuddyBanner& other39) {
  buddyBannerLinkType = other39.buddyBannerLinkType;
  buddyBannerLink = other39.buddyBannerLink;
  buddyBannerImageUrl = other39.buddyBannerImageUrl;
  __isset = other39.__isset;
  return *this;
}
void BuddyBanner::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddyBanner(";
  out << "buddyBannerLinkType=" << to_string(buddyBannerLinkType);
  out << ", " << "buddyBannerLink=" << to_string(buddyBannerLink);
  out << ", " << "buddyBannerImageUrl=" << to_string(buddyBannerImageUrl);
  out << ")";
}


BuddyDetail::~BuddyDetail() noexcept {
}


void BuddyDetail::__set_mid(const std::string& val) {
  this->mid = val;
}

void BuddyDetail::__set_memberCount(const int64_t val) {
  this->memberCount = val;
}

void BuddyDetail::__set_onAir(const bool val) {
  this->onAir = val;
}

void BuddyDetail::__set_businessAccount(const bool val) {
  this->businessAccount = val;
}

void BuddyDetail::__set_addable(const bool val) {
  this->addable = val;
}

void BuddyDetail::__set_acceptableContentTypes(const std::set<ContentType::type> & val) {
  this->acceptableContentTypes = val;
}

void BuddyDetail::__set_capableMyhome(const bool val) {
  this->capableMyhome = val;
}
std::ostream& operator<<(std::ostream& out, const BuddyDetail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddyDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memberCount);
          this->__isset.memberCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->onAir);
          this->__isset.onAir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->businessAccount);
          this->__isset.businessAccount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->addable);
          this->__isset.addable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->acceptableContentTypes.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readSetBegin(_etype43, _size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              ContentType::type _elem45;
              int32_t ecast46;
              xfer += iprot->readI32(ecast46);
              _elem45 = (ContentType::type)ecast46;
              this->acceptableContentTypes.insert(_elem45);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.acceptableContentTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->capableMyhome);
          this->__isset.capableMyhome = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddyDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddyDetail");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memberCount", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->memberCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onAir", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->onAir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("businessAccount", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->businessAccount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addable", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->addable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acceptableContentTypes", ::apache::thrift::protocol::T_SET, 6);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->acceptableContentTypes.size()));
    std::set<ContentType::type> ::const_iterator _iter47;
    for (_iter47 = this->acceptableContentTypes.begin(); _iter47 != this->acceptableContentTypes.end(); ++_iter47)
    {
      xfer += oprot->writeI32((int32_t)(*_iter47));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("capableMyhome", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->capableMyhome);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddyDetail &a, BuddyDetail &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.memberCount, b.memberCount);
  swap(a.onAir, b.onAir);
  swap(a.businessAccount, b.businessAccount);
  swap(a.addable, b.addable);
  swap(a.acceptableContentTypes, b.acceptableContentTypes);
  swap(a.capableMyhome, b.capableMyhome);
  swap(a.__isset, b.__isset);
}

BuddyDetail::BuddyDetail(const BuddyDetail& other48) {
  mid = other48.mid;
  memberCount = other48.memberCount;
  onAir = other48.onAir;
  businessAccount = other48.businessAccount;
  addable = other48.addable;
  acceptableContentTypes = other48.acceptableContentTypes;
  capableMyhome = other48.capableMyhome;
  __isset = other48.__isset;
}
BuddyDetail& BuddyDetail::operator=(const BuddyDetail& other49) {
  mid = other49.mid;
  memberCount = other49.memberCount;
  onAir = other49.onAir;
  businessAccount = other49.businessAccount;
  addable = other49.addable;
  acceptableContentTypes = other49.acceptableContentTypes;
  capableMyhome = other49.capableMyhome;
  __isset = other49.__isset;
  return *this;
}
void BuddyDetail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddyDetail(";
  out << "mid=" << to_string(mid);
  out << ", " << "memberCount=" << to_string(memberCount);
  out << ", " << "onAir=" << to_string(onAir);
  out << ", " << "businessAccount=" << to_string(businessAccount);
  out << ", " << "addable=" << to_string(addable);
  out << ", " << "acceptableContentTypes=" << to_string(acceptableContentTypes);
  out << ", " << "capableMyhome=" << to_string(capableMyhome);
  out << ")";
}


Contact::~Contact() noexcept {
}


void Contact::__set_mid(const std::string& val) {
  this->mid = val;
}

void Contact::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void Contact::__set_type(const ContactType::type val) {
  this->type = val;
}

void Contact::__set_status(const ContactStatus::type val) {
  this->status = val;
}

void Contact::__set_relation(const ContactRelation::type val) {
  this->relation = val;
}

void Contact::__set_displayName(const std::string& val) {
  this->displayName = val;
}

void Contact::__set_phoneticName(const std::string& val) {
  this->phoneticName = val;
}

void Contact::__set_pictureStatus(const std::string& val) {
  this->pictureStatus = val;
}

void Contact::__set_thumbnailUrl(const std::string& val) {
  this->thumbnailUrl = val;
}

void Contact::__set_statusMessage(const std::string& val) {
  this->statusMessage = val;
}

void Contact::__set_displayNameOverridden(const std::string& val) {
  this->displayNameOverridden = val;
}

void Contact::__set_favoriteTime(const int64_t val) {
  this->favoriteTime = val;
}

void Contact::__set_capableVoiceCall(const bool val) {
  this->capableVoiceCall = val;
}

void Contact::__set_capableVideoCall(const bool val) {
  this->capableVideoCall = val;
}

void Contact::__set_capableMyhome(const bool val) {
  this->capableMyhome = val;
}

void Contact::__set_capableBuddy(const bool val) {
  this->capableBuddy = val;
}

void Contact::__set_attributes(const int32_t val) {
  this->attributes = val;
}

void Contact::__set_settings(const int64_t val) {
  this->settings = val;
}

void Contact::__set_picturePath(const std::string& val) {
  this->picturePath = val;
}
std::ostream& operator<<(std::ostream& out, const Contact& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Contact::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->type = (ContactType::type)ecast50;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->status = (ContactStatus::type)ecast51;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->relation = (ContactRelation::type)ecast52;
          this->__isset.relation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->phoneticName);
          this->__isset.phoneticName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pictureStatus);
          this->__isset.pictureStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thumbnailUrl);
          this->__isset.thumbnailUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statusMessage);
          this->__isset.statusMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayNameOverridden);
          this->__isset.displayNameOverridden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->favoriteTime);
          this->__isset.favoriteTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->capableVoiceCall);
          this->__isset.capableVoiceCall = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->capableVideoCall);
          this->__isset.capableVideoCall = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->capableMyhome);
          this->__isset.capableMyhome = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->capableBuddy);
          this->__isset.capableBuddy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attributes);
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->settings);
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->picturePath);
          this->__isset.picturePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Contact::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Contact");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("relation", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32((int32_t)this->relation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->displayName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phoneticName", ::apache::thrift::protocol::T_STRING, 23);
  xfer += oprot->writeString(this->phoneticName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pictureStatus", ::apache::thrift::protocol::T_STRING, 24);
  xfer += oprot->writeString(this->pictureStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thumbnailUrl", ::apache::thrift::protocol::T_STRING, 25);
  xfer += oprot->writeString(this->thumbnailUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statusMessage", ::apache::thrift::protocol::T_STRING, 26);
  xfer += oprot->writeString(this->statusMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayNameOverridden", ::apache::thrift::protocol::T_STRING, 27);
  xfer += oprot->writeString(this->displayNameOverridden);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("favoriteTime", ::apache::thrift::protocol::T_I64, 28);
  xfer += oprot->writeI64(this->favoriteTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("capableVoiceCall", ::apache::thrift::protocol::T_BOOL, 31);
  xfer += oprot->writeBool(this->capableVoiceCall);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("capableVideoCall", ::apache::thrift::protocol::T_BOOL, 32);
  xfer += oprot->writeBool(this->capableVideoCall);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("capableMyhome", ::apache::thrift::protocol::T_BOOL, 33);
  xfer += oprot->writeBool(this->capableMyhome);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("capableBuddy", ::apache::thrift::protocol::T_BOOL, 34);
  xfer += oprot->writeBool(this->capableBuddy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_I32, 35);
  xfer += oprot->writeI32(this->attributes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_I64, 36);
  xfer += oprot->writeI64(this->settings);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("picturePath", ::apache::thrift::protocol::T_STRING, 37);
  xfer += oprot->writeString(this->picturePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Contact &a, Contact &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.createdTime, b.createdTime);
  swap(a.type, b.type);
  swap(a.status, b.status);
  swap(a.relation, b.relation);
  swap(a.displayName, b.displayName);
  swap(a.phoneticName, b.phoneticName);
  swap(a.pictureStatus, b.pictureStatus);
  swap(a.thumbnailUrl, b.thumbnailUrl);
  swap(a.statusMessage, b.statusMessage);
  swap(a.displayNameOverridden, b.displayNameOverridden);
  swap(a.favoriteTime, b.favoriteTime);
  swap(a.capableVoiceCall, b.capableVoiceCall);
  swap(a.capableVideoCall, b.capableVideoCall);
  swap(a.capableMyhome, b.capableMyhome);
  swap(a.capableBuddy, b.capableBuddy);
  swap(a.attributes, b.attributes);
  swap(a.settings, b.settings);
  swap(a.picturePath, b.picturePath);
  swap(a.__isset, b.__isset);
}

Contact::Contact(const Contact& other53) {
  mid = other53.mid;
  createdTime = other53.createdTime;
  type = other53.type;
  status = other53.status;
  relation = other53.relation;
  displayName = other53.displayName;
  phoneticName = other53.phoneticName;
  pictureStatus = other53.pictureStatus;
  thumbnailUrl = other53.thumbnailUrl;
  statusMessage = other53.statusMessage;
  displayNameOverridden = other53.displayNameOverridden;
  favoriteTime = other53.favoriteTime;
  capableVoiceCall = other53.capableVoiceCall;
  capableVideoCall = other53.capableVideoCall;
  capableMyhome = other53.capableMyhome;
  capableBuddy = other53.capableBuddy;
  attributes = other53.attributes;
  settings = other53.settings;
  picturePath = other53.picturePath;
  __isset = other53.__isset;
}
Contact& Contact::operator=(const Contact& other54) {
  mid = other54.mid;
  createdTime = other54.createdTime;
  type = other54.type;
  status = other54.status;
  relation = other54.relation;
  displayName = other54.displayName;
  phoneticName = other54.phoneticName;
  pictureStatus = other54.pictureStatus;
  thumbnailUrl = other54.thumbnailUrl;
  statusMessage = other54.statusMessage;
  displayNameOverridden = other54.displayNameOverridden;
  favoriteTime = other54.favoriteTime;
  capableVoiceCall = other54.capableVoiceCall;
  capableVideoCall = other54.capableVideoCall;
  capableMyhome = other54.capableMyhome;
  capableBuddy = other54.capableBuddy;
  attributes = other54.attributes;
  settings = other54.settings;
  picturePath = other54.picturePath;
  __isset = other54.__isset;
  return *this;
}
void Contact::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Contact(";
  out << "mid=" << to_string(mid);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "type=" << to_string(type);
  out << ", " << "status=" << to_string(status);
  out << ", " << "relation=" << to_string(relation);
  out << ", " << "displayName=" << to_string(displayName);
  out << ", " << "phoneticName=" << to_string(phoneticName);
  out << ", " << "pictureStatus=" << to_string(pictureStatus);
  out << ", " << "thumbnailUrl=" << to_string(thumbnailUrl);
  out << ", " << "statusMessage=" << to_string(statusMessage);
  out << ", " << "displayNameOverridden=" << to_string(displayNameOverridden);
  out << ", " << "favoriteTime=" << to_string(favoriteTime);
  out << ", " << "capableVoiceCall=" << to_string(capableVoiceCall);
  out << ", " << "capableVideoCall=" << to_string(capableVideoCall);
  out << ", " << "capableMyhome=" << to_string(capableMyhome);
  out << ", " << "capableBuddy=" << to_string(capableBuddy);
  out << ", " << "attributes=" << to_string(attributes);
  out << ", " << "settings=" << to_string(settings);
  out << ", " << "picturePath=" << to_string(picturePath);
  out << ")";
}


BuddyList::~BuddyList() noexcept {
}


void BuddyList::__set_classification(const std::string& val) {
  this->classification = val;
}

void BuddyList::__set_displayName(const std::string& val) {
  this->displayName = val;
}

void BuddyList::__set_totalBuddyCount(const int32_t val) {
  this->totalBuddyCount = val;
}

void BuddyList::__set_popularContacts(const std::vector<Contact> & val) {
  this->popularContacts = val;
}
std::ostream& operator<<(std::ostream& out, const BuddyList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddyList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->classification);
          this->__isset.classification = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalBuddyCount);
          this->__isset.totalBuddyCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->popularContacts.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->popularContacts.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += this->popularContacts[_i59].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.popularContacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddyList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddyList");

  xfer += oprot->writeFieldBegin("classification", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->classification);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->displayName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalBuddyCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->totalBuddyCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("popularContacts", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->popularContacts.size()));
    std::vector<Contact> ::const_iterator _iter60;
    for (_iter60 = this->popularContacts.begin(); _iter60 != this->popularContacts.end(); ++_iter60)
    {
      xfer += (*_iter60).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddyList &a, BuddyList &b) {
  using ::std::swap;
  swap(a.classification, b.classification);
  swap(a.displayName, b.displayName);
  swap(a.totalBuddyCount, b.totalBuddyCount);
  swap(a.popularContacts, b.popularContacts);
  swap(a.__isset, b.__isset);
}

BuddyList::BuddyList(const BuddyList& other61) {
  classification = other61.classification;
  displayName = other61.displayName;
  totalBuddyCount = other61.totalBuddyCount;
  popularContacts = other61.popularContacts;
  __isset = other61.__isset;
}
BuddyList& BuddyList::operator=(const BuddyList& other62) {
  classification = other62.classification;
  displayName = other62.displayName;
  totalBuddyCount = other62.totalBuddyCount;
  popularContacts = other62.popularContacts;
  __isset = other62.__isset;
  return *this;
}
void BuddyList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddyList(";
  out << "classification=" << to_string(classification);
  out << ", " << "displayName=" << to_string(displayName);
  out << ", " << "totalBuddyCount=" << to_string(totalBuddyCount);
  out << ", " << "popularContacts=" << to_string(popularContacts);
  out << ")";
}


Location::~Location() noexcept {
}


void Location::__set_title(const std::string& val) {
  this->title = val;
}

void Location::__set_address(const std::string& val) {
  this->address = val;
}

void Location::__set_latitude(const double val) {
  this->latitude = val;
}

void Location::__set_longitude(const double val) {
  this->longitude = val;
}

void Location::__set_phone(const std::string& val) {
  this->phone = val;
}
std::ostream& operator<<(std::ostream& out, const Location& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Location::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->address);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->latitude);
          this->__isset.latitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->longitude);
          this->__isset.longitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->phone);
          this->__isset.phone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Location::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Location");

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("latitude", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->latitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("longitude", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->longitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phone", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->phone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Location &a, Location &b) {
  using ::std::swap;
  swap(a.title, b.title);
  swap(a.address, b.address);
  swap(a.latitude, b.latitude);
  swap(a.longitude, b.longitude);
  swap(a.phone, b.phone);
  swap(a.__isset, b.__isset);
}

Location::Location(const Location& other63) {
  title = other63.title;
  address = other63.address;
  latitude = other63.latitude;
  longitude = other63.longitude;
  phone = other63.phone;
  __isset = other63.__isset;
}
Location& Location::operator=(const Location& other64) {
  title = other64.title;
  address = other64.address;
  latitude = other64.latitude;
  longitude = other64.longitude;
  phone = other64.phone;
  __isset = other64.__isset;
  return *this;
}
void Location::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Location(";
  out << "title=" << to_string(title);
  out << ", " << "address=" << to_string(address);
  out << ", " << "latitude=" << to_string(latitude);
  out << ", " << "longitude=" << to_string(longitude);
  out << ", " << "phone=" << to_string(phone);
  out << ")";
}


BuddyMessageRequest::~BuddyMessageRequest() noexcept {
}


void BuddyMessageRequest::__set_contentType(const ContentType::type val) {
  this->contentType = val;
}

void BuddyMessageRequest::__set_text(const std::string& val) {
  this->text = val;
}

void BuddyMessageRequest::__set_location(const Location& val) {
  this->location = val;
}

void BuddyMessageRequest::__set_content(const std::string& val) {
  this->content = val;
}

void BuddyMessageRequest::__set_contentMetadata(const std::map<std::string, std::string> & val) {
  this->contentMetadata = val;
}
std::ostream& operator<<(std::ostream& out, const BuddyMessageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddyMessageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->contentType = (ContentType::type)ecast65;
          this->__isset.contentType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->contentMetadata.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              std::string _key71;
              xfer += iprot->readString(_key71);
              std::string& _val72 = this->contentMetadata[_key71];
              xfer += iprot->readString(_val72);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.contentMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddyMessageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddyMessageRequest");

  xfer += oprot->writeFieldBegin("contentType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->contentType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->location.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contentMetadata", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->contentMetadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter73;
    for (_iter73 = this->contentMetadata.begin(); _iter73 != this->contentMetadata.end(); ++_iter73)
    {
      xfer += oprot->writeString(_iter73->first);
      xfer += oprot->writeString(_iter73->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddyMessageRequest &a, BuddyMessageRequest &b) {
  using ::std::swap;
  swap(a.contentType, b.contentType);
  swap(a.text, b.text);
  swap(a.location, b.location);
  swap(a.content, b.content);
  swap(a.contentMetadata, b.contentMetadata);
  swap(a.__isset, b.__isset);
}

BuddyMessageRequest::BuddyMessageRequest(const BuddyMessageRequest& other74) {
  contentType = other74.contentType;
  text = other74.text;
  location = other74.location;
  content = other74.content;
  contentMetadata = other74.contentMetadata;
  __isset = other74.__isset;
}
BuddyMessageRequest& BuddyMessageRequest::operator=(const BuddyMessageRequest& other75) {
  contentType = other75.contentType;
  text = other75.text;
  location = other75.location;
  content = other75.content;
  contentMetadata = other75.contentMetadata;
  __isset = other75.__isset;
  return *this;
}
void BuddyMessageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddyMessageRequest(";
  out << "contentType=" << to_string(contentType);
  out << ", " << "text=" << to_string(text);
  out << ", " << "location=" << to_string(location);
  out << ", " << "content=" << to_string(content);
  out << ", " << "contentMetadata=" << to_string(contentMetadata);
  out << ")";
}


BuddyOnAirUrls::~BuddyOnAirUrls() noexcept {
}


void BuddyOnAirUrls::__set_hls(const std::map<std::string, std::string> & val) {
  this->hls = val;
}

void BuddyOnAirUrls::__set_smoothStreaming(const std::map<std::string, std::string> & val) {
  this->smoothStreaming = val;
}
std::ostream& operator<<(std::ostream& out, const BuddyOnAirUrls& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddyOnAirUrls::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hls.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _ktype77;
            ::apache::thrift::protocol::TType _vtype78;
            xfer += iprot->readMapBegin(_ktype77, _vtype78, _size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              std::string _key81;
              xfer += iprot->readString(_key81);
              std::string& _val82 = this->hls[_key81];
              xfer += iprot->readString(_val82);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->smoothStreaming.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _ktype84;
            ::apache::thrift::protocol::TType _vtype85;
            xfer += iprot->readMapBegin(_ktype84, _vtype85, _size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              std::string _key88;
              xfer += iprot->readString(_key88);
              std::string& _val89 = this->smoothStreaming[_key88];
              xfer += iprot->readString(_val89);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.smoothStreaming = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddyOnAirUrls::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddyOnAirUrls");

  xfer += oprot->writeFieldBegin("hls", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hls.size()));
    std::map<std::string, std::string> ::const_iterator _iter90;
    for (_iter90 = this->hls.begin(); _iter90 != this->hls.end(); ++_iter90)
    {
      xfer += oprot->writeString(_iter90->first);
      xfer += oprot->writeString(_iter90->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smoothStreaming", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->smoothStreaming.size()));
    std::map<std::string, std::string> ::const_iterator _iter91;
    for (_iter91 = this->smoothStreaming.begin(); _iter91 != this->smoothStreaming.end(); ++_iter91)
    {
      xfer += oprot->writeString(_iter91->first);
      xfer += oprot->writeString(_iter91->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddyOnAirUrls &a, BuddyOnAirUrls &b) {
  using ::std::swap;
  swap(a.hls, b.hls);
  swap(a.smoothStreaming, b.smoothStreaming);
  swap(a.__isset, b.__isset);
}

BuddyOnAirUrls::BuddyOnAirUrls(const BuddyOnAirUrls& other92) {
  hls = other92.hls;
  smoothStreaming = other92.smoothStreaming;
  __isset = other92.__isset;
}
BuddyOnAirUrls& BuddyOnAirUrls::operator=(const BuddyOnAirUrls& other93) {
  hls = other93.hls;
  smoothStreaming = other93.smoothStreaming;
  __isset = other93.__isset;
  return *this;
}
void BuddyOnAirUrls::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddyOnAirUrls(";
  out << "hls=" << to_string(hls);
  out << ", " << "smoothStreaming=" << to_string(smoothStreaming);
  out << ")";
}


BuddyOnAir::~BuddyOnAir() noexcept {
}


void BuddyOnAir::__set_mid(const std::string& val) {
  this->mid = val;
}

void BuddyOnAir::__set_freshnessLifetime(const int64_t val) {
  this->freshnessLifetime = val;
}

void BuddyOnAir::__set_onAirId(const std::string& val) {
  this->onAirId = val;
}

void BuddyOnAir::__set_onAir(const bool val) {
  this->onAir = val;
}

void BuddyOnAir::__set_text(const std::string& val) {
  this->text = val;
}

void BuddyOnAir::__set_viewerCount(const int64_t val) {
  this->viewerCount = val;
}

void BuddyOnAir::__set_targetCount(const int64_t val) {
  this->targetCount = val;
}

void BuddyOnAir::__set_onAirType(const BuddyOnAirType::type val) {
  this->onAirType = val;
}

void BuddyOnAir::__set_onAirUrls(const BuddyOnAirUrls& val) {
  this->onAirUrls = val;
}
std::ostream& operator<<(std::ostream& out, const BuddyOnAir& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddyOnAir::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->freshnessLifetime);
          this->__isset.freshnessLifetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->onAirId);
          this->__isset.onAirId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->onAir);
          this->__isset.onAir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->viewerCount);
          this->__isset.viewerCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->targetCount);
          this->__isset.targetCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast94;
          xfer += iprot->readI32(ecast94);
          this->onAirType = (BuddyOnAirType::type)ecast94;
          this->__isset.onAirType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->onAirUrls.read(iprot);
          this->__isset.onAirUrls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddyOnAir::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddyOnAir");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freshnessLifetime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->freshnessLifetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onAirId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->onAirId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onAir", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->onAir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewerCount", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->viewerCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetCount", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->targetCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onAirType", ::apache::thrift::protocol::T_I32, 31);
  xfer += oprot->writeI32((int32_t)this->onAirType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onAirUrls", ::apache::thrift::protocol::T_STRUCT, 32);
  xfer += this->onAirUrls.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddyOnAir &a, BuddyOnAir &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.freshnessLifetime, b.freshnessLifetime);
  swap(a.onAirId, b.onAirId);
  swap(a.onAir, b.onAir);
  swap(a.text, b.text);
  swap(a.viewerCount, b.viewerCount);
  swap(a.targetCount, b.targetCount);
  swap(a.onAirType, b.onAirType);
  swap(a.onAirUrls, b.onAirUrls);
  swap(a.__isset, b.__isset);
}

BuddyOnAir::BuddyOnAir(const BuddyOnAir& other95) {
  mid = other95.mid;
  freshnessLifetime = other95.freshnessLifetime;
  onAirId = other95.onAirId;
  onAir = other95.onAir;
  text = other95.text;
  viewerCount = other95.viewerCount;
  targetCount = other95.targetCount;
  onAirType = other95.onAirType;
  onAirUrls = other95.onAirUrls;
  __isset = other95.__isset;
}
BuddyOnAir& BuddyOnAir::operator=(const BuddyOnAir& other96) {
  mid = other96.mid;
  freshnessLifetime = other96.freshnessLifetime;
  onAirId = other96.onAirId;
  onAir = other96.onAir;
  text = other96.text;
  viewerCount = other96.viewerCount;
  targetCount = other96.targetCount;
  onAirType = other96.onAirType;
  onAirUrls = other96.onAirUrls;
  __isset = other96.__isset;
  return *this;
}
void BuddyOnAir::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddyOnAir(";
  out << "mid=" << to_string(mid);
  out << ", " << "freshnessLifetime=" << to_string(freshnessLifetime);
  out << ", " << "onAirId=" << to_string(onAirId);
  out << ", " << "onAir=" << to_string(onAir);
  out << ", " << "text=" << to_string(text);
  out << ", " << "viewerCount=" << to_string(viewerCount);
  out << ", " << "targetCount=" << to_string(targetCount);
  out << ", " << "onAirType=" << to_string(onAirType);
  out << ", " << "onAirUrls=" << to_string(onAirUrls);
  out << ")";
}


BuddyProfile::~BuddyProfile() noexcept {
}


void BuddyProfile::__set_buddyId(const std::string& val) {
  this->buddyId = val;
}

void BuddyProfile::__set_mid(const std::string& val) {
  this->mid = val;
}

void BuddyProfile::__set_searchId(const std::string& val) {
  this->searchId = val;
}

void BuddyProfile::__set_displayName(const std::string& val) {
  this->displayName = val;
}

void BuddyProfile::__set_statusMessage(const std::string& val) {
  this->statusMessage = val;
}

void BuddyProfile::__set_contactCount(const int64_t val) {
  this->contactCount = val;
}
std::ostream& operator<<(std::ostream& out, const BuddyProfile& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddyProfile::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->buddyId);
          this->__isset.buddyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->searchId);
          this->__isset.searchId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statusMessage);
          this->__isset.statusMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->contactCount);
          this->__isset.contactCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddyProfile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddyProfile");

  xfer += oprot->writeFieldBegin("buddyId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->buddyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->searchId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->displayName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statusMessage", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->statusMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contactCount", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->contactCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddyProfile &a, BuddyProfile &b) {
  using ::std::swap;
  swap(a.buddyId, b.buddyId);
  swap(a.mid, b.mid);
  swap(a.searchId, b.searchId);
  swap(a.displayName, b.displayName);
  swap(a.statusMessage, b.statusMessage);
  swap(a.contactCount, b.contactCount);
  swap(a.__isset, b.__isset);
}

BuddyProfile::BuddyProfile(const BuddyProfile& other97) {
  buddyId = other97.buddyId;
  mid = other97.mid;
  searchId = other97.searchId;
  displayName = other97.displayName;
  statusMessage = other97.statusMessage;
  contactCount = other97.contactCount;
  __isset = other97.__isset;
}
BuddyProfile& BuddyProfile::operator=(const BuddyProfile& other98) {
  buddyId = other98.buddyId;
  mid = other98.mid;
  searchId = other98.searchId;
  displayName = other98.displayName;
  statusMessage = other98.statusMessage;
  contactCount = other98.contactCount;
  __isset = other98.__isset;
  return *this;
}
void BuddyProfile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddyProfile(";
  out << "buddyId=" << to_string(buddyId);
  out << ", " << "mid=" << to_string(mid);
  out << ", " << "searchId=" << to_string(searchId);
  out << ", " << "displayName=" << to_string(displayName);
  out << ", " << "statusMessage=" << to_string(statusMessage);
  out << ", " << "contactCount=" << to_string(contactCount);
  out << ")";
}


BuddySearchResult::~BuddySearchResult() noexcept {
}


void BuddySearchResult::__set_mid(const std::string& val) {
  this->mid = val;
}

void BuddySearchResult::__set_displayName(const std::string& val) {
  this->displayName = val;
}

void BuddySearchResult::__set_pictureStatus(const std::string& val) {
  this->pictureStatus = val;
}

void BuddySearchResult::__set_picturePath(const std::string& val) {
  this->picturePath = val;
}

void BuddySearchResult::__set_statusMessage(const std::string& val) {
  this->statusMessage = val;
}

void BuddySearchResult::__set_businessAccount(const bool val) {
  this->businessAccount = val;
}
std::ostream& operator<<(std::ostream& out, const BuddySearchResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BuddySearchResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pictureStatus);
          this->__isset.pictureStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->picturePath);
          this->__isset.picturePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statusMessage);
          this->__isset.statusMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->businessAccount);
          this->__isset.businessAccount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuddySearchResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BuddySearchResult");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->displayName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pictureStatus", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->pictureStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("picturePath", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->picturePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statusMessage", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->statusMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("businessAccount", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->businessAccount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuddySearchResult &a, BuddySearchResult &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.displayName, b.displayName);
  swap(a.pictureStatus, b.pictureStatus);
  swap(a.picturePath, b.picturePath);
  swap(a.statusMessage, b.statusMessage);
  swap(a.businessAccount, b.businessAccount);
  swap(a.__isset, b.__isset);
}

BuddySearchResult::BuddySearchResult(const BuddySearchResult& other99) {
  mid = other99.mid;
  displayName = other99.displayName;
  pictureStatus = other99.pictureStatus;
  picturePath = other99.picturePath;
  statusMessage = other99.statusMessage;
  businessAccount = other99.businessAccount;
  __isset = other99.__isset;
}
BuddySearchResult& BuddySearchResult::operator=(const BuddySearchResult& other100) {
  mid = other100.mid;
  displayName = other100.displayName;
  pictureStatus = other100.pictureStatus;
  picturePath = other100.picturePath;
  statusMessage = other100.statusMessage;
  businessAccount = other100.businessAccount;
  __isset = other100.__isset;
  return *this;
}
void BuddySearchResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BuddySearchResult(";
  out << "mid=" << to_string(mid);
  out << ", " << "displayName=" << to_string(displayName);
  out << ", " << "pictureStatus=" << to_string(pictureStatus);
  out << ", " << "picturePath=" << to_string(picturePath);
  out << ", " << "statusMessage=" << to_string(statusMessage);
  out << ", " << "businessAccount=" << to_string(businessAccount);
  out << ")";
}


ChannelDomain::~ChannelDomain() noexcept {
}


void ChannelDomain::__set_host(const std::string& val) {
  this->host = val;
}

void ChannelDomain::__set_removed(const bool val) {
  this->removed = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelDomain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelDomain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->removed);
          this->__isset.removed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelDomain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelDomain");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("removed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->removed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelDomain &a, ChannelDomain &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.removed, b.removed);
  swap(a.__isset, b.__isset);
}

ChannelDomain::ChannelDomain(const ChannelDomain& other101) {
  host = other101.host;
  removed = other101.removed;
  __isset = other101.__isset;
}
ChannelDomain& ChannelDomain::operator=(const ChannelDomain& other102) {
  host = other102.host;
  removed = other102.removed;
  __isset = other102.__isset;
  return *this;
}
void ChannelDomain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelDomain(";
  out << "host=" << to_string(host);
  out << ", " << "removed=" << to_string(removed);
  out << ")";
}


ChannelDomains::~ChannelDomains() noexcept {
}


void ChannelDomains::__set_channelDomains(const std::vector<ChannelDomain> & val) {
  this->channelDomains = val;
}

void ChannelDomains::__set_revision(const int64_t val) {
  this->revision = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelDomains& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelDomains::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->channelDomains.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->channelDomains.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              xfer += this->channelDomains[_i107].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.channelDomains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelDomains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelDomains");

  xfer += oprot->writeFieldBegin("channelDomains", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->channelDomains.size()));
    std::vector<ChannelDomain> ::const_iterator _iter108;
    for (_iter108 = this->channelDomains.begin(); _iter108 != this->channelDomains.end(); ++_iter108)
    {
      xfer += (*_iter108).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelDomains &a, ChannelDomains &b) {
  using ::std::swap;
  swap(a.channelDomains, b.channelDomains);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

ChannelDomains::ChannelDomains(const ChannelDomains& other109) {
  channelDomains = other109.channelDomains;
  revision = other109.revision;
  __isset = other109.__isset;
}
ChannelDomains& ChannelDomains::operator=(const ChannelDomains& other110) {
  channelDomains = other110.channelDomains;
  revision = other110.revision;
  __isset = other110.__isset;
  return *this;
}
void ChannelDomains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelDomains(";
  out << "channelDomains=" << to_string(channelDomains);
  out << ", " << "revision=" << to_string(revision);
  out << ")";
}


ChannelException::~ChannelException() noexcept {
}


void ChannelException::__set_code(const ChannelErrorCode::type val) {
  this->code = val;
}

void ChannelException::__set_reason(const std::string& val) {
  this->reason = val;
}

void ChannelException::__set_parameterMap(const std::map<std::string, std::string> & val) {
  this->parameterMap = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast111;
          xfer += iprot->readI32(ecast111);
          this->code = (ChannelErrorCode::type)ecast111;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameterMap.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _ktype113;
            ::apache::thrift::protocol::TType _vtype114;
            xfer += iprot->readMapBegin(_ktype113, _vtype114, _size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              std::string _key117;
              xfer += iprot->readString(_key117);
              std::string& _val118 = this->parameterMap[_key117];
              xfer += iprot->readString(_val118);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameterMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameterMap", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameterMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter119;
    for (_iter119 = this->parameterMap.begin(); _iter119 != this->parameterMap.end(); ++_iter119)
    {
      xfer += oprot->writeString(_iter119->first);
      xfer += oprot->writeString(_iter119->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelException &a, ChannelException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.reason, b.reason);
  swap(a.parameterMap, b.parameterMap);
  swap(a.__isset, b.__isset);
}

ChannelException::ChannelException(const ChannelException& other120) : TException() {
  code = other120.code;
  reason = other120.reason;
  parameterMap = other120.parameterMap;
  __isset = other120.__isset;
}
ChannelException& ChannelException::operator=(const ChannelException& other121) {
  code = other121.code;
  reason = other121.reason;
  parameterMap = other121.parameterMap;
  __isset = other121.__isset;
  return *this;
}
void ChannelException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelException(";
  out << "code=" << to_string(code);
  out << ", " << "reason=" << to_string(reason);
  out << ", " << "parameterMap=" << to_string(parameterMap);
  out << ")";
}

const char* ChannelException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ChannelException";
  }
}


ChannelInfos::~ChannelInfos() noexcept {
}


void ChannelInfos::__set_channelInfos(const std::vector<ChannelInfo> & val) {
  this->channelInfos = val;
}

void ChannelInfos::__set_revision(const int64_t val) {
  this->revision = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelInfos& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelInfos::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->channelInfos.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->channelInfos.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += this->channelInfos[_i126].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.channelInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelInfos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelInfos");

  xfer += oprot->writeFieldBegin("channelInfos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->channelInfos.size()));
    std::vector<ChannelInfo> ::const_iterator _iter127;
    for (_iter127 = this->channelInfos.begin(); _iter127 != this->channelInfos.end(); ++_iter127)
    {
      xfer += (*_iter127).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelInfos &a, ChannelInfos &b) {
  using ::std::swap;
  swap(a.channelInfos, b.channelInfos);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

ChannelInfos::ChannelInfos(const ChannelInfos& other128) {
  channelInfos = other128.channelInfos;
  revision = other128.revision;
  __isset = other128.__isset;
}
ChannelInfos& ChannelInfos::operator=(const ChannelInfos& other129) {
  channelInfos = other129.channelInfos;
  revision = other129.revision;
  __isset = other129.__isset;
  return *this;
}
void ChannelInfos::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelInfos(";
  out << "channelInfos=" << to_string(channelInfos);
  out << ", " << "revision=" << to_string(revision);
  out << ")";
}


ChannelNotificationSetting::~ChannelNotificationSetting() noexcept {
}


void ChannelNotificationSetting::__set_channelId(const std::string& val) {
  this->channelId = val;
}

void ChannelNotificationSetting::__set_name(const std::string& val) {
  this->name = val;
}

void ChannelNotificationSetting::__set_notificationReceivable(const bool val) {
  this->notificationReceivable = val;
}

void ChannelNotificationSetting::__set_messageReceivable(const bool val) {
  this->messageReceivable = val;
}

void ChannelNotificationSetting::__set_showDefault(const bool val) {
  this->showDefault = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelNotificationSetting& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelNotificationSetting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channelId);
          this->__isset.channelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationReceivable);
          this->__isset.notificationReceivable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->messageReceivable);
          this->__isset.messageReceivable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->showDefault);
          this->__isset.showDefault = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelNotificationSetting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelNotificationSetting");

  xfer += oprot->writeFieldBegin("channelId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->channelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationReceivable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->notificationReceivable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageReceivable", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->messageReceivable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("showDefault", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->showDefault);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelNotificationSetting &a, ChannelNotificationSetting &b) {
  using ::std::swap;
  swap(a.channelId, b.channelId);
  swap(a.name, b.name);
  swap(a.notificationReceivable, b.notificationReceivable);
  swap(a.messageReceivable, b.messageReceivable);
  swap(a.showDefault, b.showDefault);
  swap(a.__isset, b.__isset);
}

ChannelNotificationSetting::ChannelNotificationSetting(const ChannelNotificationSetting& other130) {
  channelId = other130.channelId;
  name = other130.name;
  notificationReceivable = other130.notificationReceivable;
  messageReceivable = other130.messageReceivable;
  showDefault = other130.showDefault;
  __isset = other130.__isset;
}
ChannelNotificationSetting& ChannelNotificationSetting::operator=(const ChannelNotificationSetting& other131) {
  channelId = other131.channelId;
  name = other131.name;
  notificationReceivable = other131.notificationReceivable;
  messageReceivable = other131.messageReceivable;
  showDefault = other131.showDefault;
  __isset = other131.__isset;
  return *this;
}
void ChannelNotificationSetting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelNotificationSetting(";
  out << "channelId=" << to_string(channelId);
  out << ", " << "name=" << to_string(name);
  out << ", " << "notificationReceivable=" << to_string(notificationReceivable);
  out << ", " << "messageReceivable=" << to_string(messageReceivable);
  out << ", " << "showDefault=" << to_string(showDefault);
  out << ")";
}


ChannelSyncDatas::~ChannelSyncDatas() noexcept {
}


void ChannelSyncDatas::__set_channelInfos(const std::vector<ChannelInfo> & val) {
  this->channelInfos = val;
}

void ChannelSyncDatas::__set_channelDomains(const std::vector<ChannelDomain> & val) {
  this->channelDomains = val;
}

void ChannelSyncDatas::__set_revision(const int64_t val) {
  this->revision = val;
}

void ChannelSyncDatas::__set_expires(const int64_t val) {
  this->expires = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelSyncDatas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelSyncDatas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->channelInfos.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->channelInfos.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += this->channelInfos[_i136].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.channelInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->channelDomains.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _etype140;
            xfer += iprot->readListBegin(_etype140, _size137);
            this->channelDomains.resize(_size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
              xfer += this->channelDomains[_i141].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.channelDomains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expires);
          this->__isset.expires = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelSyncDatas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelSyncDatas");

  xfer += oprot->writeFieldBegin("channelInfos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->channelInfos.size()));
    std::vector<ChannelInfo> ::const_iterator _iter142;
    for (_iter142 = this->channelInfos.begin(); _iter142 != this->channelInfos.end(); ++_iter142)
    {
      xfer += (*_iter142).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channelDomains", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->channelDomains.size()));
    std::vector<ChannelDomain> ::const_iterator _iter143;
    for (_iter143 = this->channelDomains.begin(); _iter143 != this->channelDomains.end(); ++_iter143)
    {
      xfer += (*_iter143).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expires", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->expires);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelSyncDatas &a, ChannelSyncDatas &b) {
  using ::std::swap;
  swap(a.channelInfos, b.channelInfos);
  swap(a.channelDomains, b.channelDomains);
  swap(a.revision, b.revision);
  swap(a.expires, b.expires);
  swap(a.__isset, b.__isset);
}

ChannelSyncDatas::ChannelSyncDatas(const ChannelSyncDatas& other144) {
  channelInfos = other144.channelInfos;
  channelDomains = other144.channelDomains;
  revision = other144.revision;
  expires = other144.expires;
  __isset = other144.__isset;
}
ChannelSyncDatas& ChannelSyncDatas::operator=(const ChannelSyncDatas& other145) {
  channelInfos = other145.channelInfos;
  channelDomains = other145.channelDomains;
  revision = other145.revision;
  expires = other145.expires;
  __isset = other145.__isset;
  return *this;
}
void ChannelSyncDatas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelSyncDatas(";
  out << "channelInfos=" << to_string(channelInfos);
  out << ", " << "channelDomains=" << to_string(channelDomains);
  out << ", " << "revision=" << to_string(revision);
  out << ", " << "expires=" << to_string(expires);
  out << ")";
}


ChannelToken::~ChannelToken() noexcept {
}


void ChannelToken::__set_token(const std::string& val) {
  this->token = val;
}

void ChannelToken::__set_obsToken(const std::string& val) {
  this->obsToken = val;
}

void ChannelToken::__set_expiration(const int64_t val) {
  this->expiration = val;
}

void ChannelToken::__set_refreshToken(const std::string& val) {
  this->refreshToken = val;
}

void ChannelToken::__set_channelAccessToken(const std::string& val) {
  this->channelAccessToken = val;
}
std::ostream& operator<<(std::ostream& out, const ChannelToken& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ChannelToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->obsToken);
          this->__isset.obsToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expiration);
          this->__isset.expiration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->refreshToken);
          this->__isset.refreshToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channelAccessToken);
          this->__isset.channelAccessToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChannelToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChannelToken");

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("obsToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->obsToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expiration", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->expiration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("refreshToken", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->refreshToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channelAccessToken", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->channelAccessToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChannelToken &a, ChannelToken &b) {
  using ::std::swap;
  swap(a.token, b.token);
  swap(a.obsToken, b.obsToken);
  swap(a.expiration, b.expiration);
  swap(a.refreshToken, b.refreshToken);
  swap(a.channelAccessToken, b.channelAccessToken);
  swap(a.__isset, b.__isset);
}

ChannelToken::ChannelToken(const ChannelToken& other146) {
  token = other146.token;
  obsToken = other146.obsToken;
  expiration = other146.expiration;
  refreshToken = other146.refreshToken;
  channelAccessToken = other146.channelAccessToken;
  __isset = other146.__isset;
}
ChannelToken& ChannelToken::operator=(const ChannelToken& other147) {
  token = other147.token;
  obsToken = other147.obsToken;
  expiration = other147.expiration;
  refreshToken = other147.refreshToken;
  channelAccessToken = other147.channelAccessToken;
  __isset = other147.__isset;
  return *this;
}
void ChannelToken::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChannelToken(";
  out << "token=" << to_string(token);
  out << ", " << "obsToken=" << to_string(obsToken);
  out << ", " << "expiration=" << to_string(expiration);
  out << ", " << "refreshToken=" << to_string(refreshToken);
  out << ", " << "channelAccessToken=" << to_string(channelAccessToken);
  out << ")";
}


Coin::~Coin() noexcept {
}


void Coin::__set_freeCoinBalance(const int32_t val) {
  this->freeCoinBalance = val;
}

void Coin::__set_payedCoinBalance(const int32_t val) {
  this->payedCoinBalance = val;
}

void Coin::__set_totalCoinBalance(const int32_t val) {
  this->totalCoinBalance = val;
}

void Coin::__set_rewardCoinBalance(const int32_t val) {
  this->rewardCoinBalance = val;
}
std::ostream& operator<<(std::ostream& out, const Coin& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Coin::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->freeCoinBalance);
          this->__isset.freeCoinBalance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->payedCoinBalance);
          this->__isset.payedCoinBalance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalCoinBalance);
          this->__isset.totalCoinBalance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rewardCoinBalance);
          this->__isset.rewardCoinBalance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Coin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Coin");

  xfer += oprot->writeFieldBegin("freeCoinBalance", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->freeCoinBalance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payedCoinBalance", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->payedCoinBalance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalCoinBalance", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->totalCoinBalance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rewardCoinBalance", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->rewardCoinBalance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Coin &a, Coin &b) {
  using ::std::swap;
  swap(a.freeCoinBalance, b.freeCoinBalance);
  swap(a.payedCoinBalance, b.payedCoinBalance);
  swap(a.totalCoinBalance, b.totalCoinBalance);
  swap(a.rewardCoinBalance, b.rewardCoinBalance);
  swap(a.__isset, b.__isset);
}

Coin::Coin(const Coin& other148) {
  freeCoinBalance = other148.freeCoinBalance;
  payedCoinBalance = other148.payedCoinBalance;
  totalCoinBalance = other148.totalCoinBalance;
  rewardCoinBalance = other148.rewardCoinBalance;
  __isset = other148.__isset;
}
Coin& Coin::operator=(const Coin& other149) {
  freeCoinBalance = other149.freeCoinBalance;
  payedCoinBalance = other149.payedCoinBalance;
  totalCoinBalance = other149.totalCoinBalance;
  rewardCoinBalance = other149.rewardCoinBalance;
  __isset = other149.__isset;
  return *this;
}
void Coin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Coin(";
  out << "freeCoinBalance=" << to_string(freeCoinBalance);
  out << ", " << "payedCoinBalance=" << to_string(payedCoinBalance);
  out << ", " << "totalCoinBalance=" << to_string(totalCoinBalance);
  out << ", " << "rewardCoinBalance=" << to_string(rewardCoinBalance);
  out << ")";
}


CoinPayLoad::~CoinPayLoad() noexcept {
}


void CoinPayLoad::__set_payCoin(const int32_t val) {
  this->payCoin = val;
}

void CoinPayLoad::__set_freeCoin(const int32_t val) {
  this->freeCoin = val;
}

void CoinPayLoad::__set_type(const PayloadType::type val) {
  this->type = val;
}

void CoinPayLoad::__set_rewardCoin(const int32_t val) {
  this->rewardCoin = val;
}
std::ostream& operator<<(std::ostream& out, const CoinPayLoad& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinPayLoad::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->payCoin);
          this->__isset.payCoin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->freeCoin);
          this->__isset.freeCoin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast150;
          xfer += iprot->readI32(ecast150);
          this->type = (PayloadType::type)ecast150;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rewardCoin);
          this->__isset.rewardCoin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinPayLoad::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinPayLoad");

  xfer += oprot->writeFieldBegin("payCoin", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->payCoin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeCoin", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->freeCoin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rewardCoin", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->rewardCoin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinPayLoad &a, CoinPayLoad &b) {
  using ::std::swap;
  swap(a.payCoin, b.payCoin);
  swap(a.freeCoin, b.freeCoin);
  swap(a.type, b.type);
  swap(a.rewardCoin, b.rewardCoin);
  swap(a.__isset, b.__isset);
}

CoinPayLoad::CoinPayLoad(const CoinPayLoad& other151) {
  payCoin = other151.payCoin;
  freeCoin = other151.freeCoin;
  type = other151.type;
  rewardCoin = other151.rewardCoin;
  __isset = other151.__isset;
}
CoinPayLoad& CoinPayLoad::operator=(const CoinPayLoad& other152) {
  payCoin = other152.payCoin;
  freeCoin = other152.freeCoin;
  type = other152.type;
  rewardCoin = other152.rewardCoin;
  __isset = other152.__isset;
  return *this;
}
void CoinPayLoad::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinPayLoad(";
  out << "payCoin=" << to_string(payCoin);
  out << ", " << "freeCoin=" << to_string(freeCoin);
  out << ", " << "type=" << to_string(type);
  out << ", " << "rewardCoin=" << to_string(rewardCoin);
  out << ")";
}


CoinHistory::~CoinHistory() noexcept {
}


void CoinHistory::__set_payDate(const int64_t val) {
  this->payDate = val;
}

void CoinHistory::__set_coinBalance(const int32_t val) {
  this->coinBalance = val;
}

void CoinHistory::__set_coin(const int32_t val) {
  this->coin = val;
}

void CoinHistory::__set_price(const std::string& val) {
  this->price = val;
}

void CoinHistory::__set_title(const std::string& val) {
  this->title = val;
}

void CoinHistory::__set_refund(const bool val) {
  this->refund = val;
}

void CoinHistory::__set_paySeq(const std::string& val) {
  this->paySeq = val;
}

void CoinHistory::__set_currency(const std::string& val) {
  this->currency = val;
}

void CoinHistory::__set_currencySign(const std::string& val) {
  this->currencySign = val;
}

void CoinHistory::__set_displayPrice(const std::string& val) {
  this->displayPrice = val;
}

void CoinHistory::__set_payload(const CoinPayLoad& val) {
  this->payload = val;
}

void CoinHistory::__set_channelId(const std::string& val) {
  this->channelId = val;
}
std::ostream& operator<<(std::ostream& out, const CoinHistory& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinHistory::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->payDate);
          this->__isset.payDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->coinBalance);
          this->__isset.coinBalance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->coin);
          this->__isset.coin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->refund);
          this->__isset.refund = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->paySeq);
          this->__isset.paySeq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currency);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currencySign);
          this->__isset.currencySign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayPrice);
          this->__isset.displayPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->payload.read(iprot);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channelId);
          this->__isset.channelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinHistory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinHistory");

  xfer += oprot->writeFieldBegin("payDate", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->payDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coinBalance", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->coinBalance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coin", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->coin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("refund", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->refund);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paySeq", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->paySeq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->currency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currencySign", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->currencySign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayPrice", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->displayPrice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->payload.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channelId", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->channelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinHistory &a, CoinHistory &b) {
  using ::std::swap;
  swap(a.payDate, b.payDate);
  swap(a.coinBalance, b.coinBalance);
  swap(a.coin, b.coin);
  swap(a.price, b.price);
  swap(a.title, b.title);
  swap(a.refund, b.refund);
  swap(a.paySeq, b.paySeq);
  swap(a.currency, b.currency);
  swap(a.currencySign, b.currencySign);
  swap(a.displayPrice, b.displayPrice);
  swap(a.payload, b.payload);
  swap(a.channelId, b.channelId);
  swap(a.__isset, b.__isset);
}

CoinHistory::CoinHistory(const CoinHistory& other153) {
  payDate = other153.payDate;
  coinBalance = other153.coinBalance;
  coin = other153.coin;
  price = other153.price;
  title = other153.title;
  refund = other153.refund;
  paySeq = other153.paySeq;
  currency = other153.currency;
  currencySign = other153.currencySign;
  displayPrice = other153.displayPrice;
  payload = other153.payload;
  channelId = other153.channelId;
  __isset = other153.__isset;
}
CoinHistory& CoinHistory::operator=(const CoinHistory& other154) {
  payDate = other154.payDate;
  coinBalance = other154.coinBalance;
  coin = other154.coin;
  price = other154.price;
  title = other154.title;
  refund = other154.refund;
  paySeq = other154.paySeq;
  currency = other154.currency;
  currencySign = other154.currencySign;
  displayPrice = other154.displayPrice;
  payload = other154.payload;
  channelId = other154.channelId;
  __isset = other154.__isset;
  return *this;
}
void CoinHistory::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinHistory(";
  out << "payDate=" << to_string(payDate);
  out << ", " << "coinBalance=" << to_string(coinBalance);
  out << ", " << "coin=" << to_string(coin);
  out << ", " << "price=" << to_string(price);
  out << ", " << "title=" << to_string(title);
  out << ", " << "refund=" << to_string(refund);
  out << ", " << "paySeq=" << to_string(paySeq);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "currencySign=" << to_string(currencySign);
  out << ", " << "displayPrice=" << to_string(displayPrice);
  out << ", " << "payload=" << to_string(payload);
  out << ", " << "channelId=" << to_string(channelId);
  out << ")";
}


CoinHistoryCondition::~CoinHistoryCondition() noexcept {
}


void CoinHistoryCondition::__set_start(const int64_t val) {
  this->start = val;
}

void CoinHistoryCondition::__set_size(const int32_t val) {
  this->size = val;
}

void CoinHistoryCondition::__set_language(const std::string& val) {
  this->language = val;
}

void CoinHistoryCondition::__set_eddt(const std::string& val) {
  this->eddt = val;
}

void CoinHistoryCondition::__set_appStoreCode(const PaymentType::type val) {
  this->appStoreCode = val;
}
std::ostream& operator<<(std::ostream& out, const CoinHistoryCondition& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinHistoryCondition::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->language);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->eddt);
          this->__isset.eddt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast155;
          xfer += iprot->readI32(ecast155);
          this->appStoreCode = (PaymentType::type)ecast155;
          this->__isset.appStoreCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinHistoryCondition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinHistoryCondition");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->language);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eddt", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->eddt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appStoreCode", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->appStoreCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinHistoryCondition &a, CoinHistoryCondition &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.size, b.size);
  swap(a.language, b.language);
  swap(a.eddt, b.eddt);
  swap(a.appStoreCode, b.appStoreCode);
  swap(a.__isset, b.__isset);
}

CoinHistoryCondition::CoinHistoryCondition(const CoinHistoryCondition& other156) {
  start = other156.start;
  size = other156.size;
  language = other156.language;
  eddt = other156.eddt;
  appStoreCode = other156.appStoreCode;
  __isset = other156.__isset;
}
CoinHistoryCondition& CoinHistoryCondition::operator=(const CoinHistoryCondition& other157) {
  start = other157.start;
  size = other157.size;
  language = other157.language;
  eddt = other157.eddt;
  appStoreCode = other157.appStoreCode;
  __isset = other157.__isset;
  return *this;
}
void CoinHistoryCondition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinHistoryCondition(";
  out << "start=" << to_string(start);
  out << ", " << "size=" << to_string(size);
  out << ", " << "language=" << to_string(language);
  out << ", " << "eddt=" << to_string(eddt);
  out << ", " << "appStoreCode=" << to_string(appStoreCode);
  out << ")";
}


CoinHistoryResult::~CoinHistoryResult() noexcept {
}


void CoinHistoryResult::__set_historys(const std::vector<CoinHistory> & val) {
  this->historys = val;
}

void CoinHistoryResult::__set_balance(const Coin& val) {
  this->balance = val;
}

void CoinHistoryResult::__set_hasNext(const bool val) {
  this->hasNext = val;
}
std::ostream& operator<<(std::ostream& out, const CoinHistoryResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinHistoryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->historys.clear();
            uint32_t _size158;
            ::apache::thrift::protocol::TType _etype161;
            xfer += iprot->readListBegin(_etype161, _size158);
            this->historys.resize(_size158);
            uint32_t _i162;
            for (_i162 = 0; _i162 < _size158; ++_i162)
            {
              xfer += this->historys[_i162].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.historys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->balance.read(iprot);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasNext);
          this->__isset.hasNext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinHistoryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinHistoryResult");

  xfer += oprot->writeFieldBegin("historys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->historys.size()));
    std::vector<CoinHistory> ::const_iterator _iter163;
    for (_iter163 = this->historys.begin(); _iter163 != this->historys.end(); ++_iter163)
    {
      xfer += (*_iter163).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->balance.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasNext", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->hasNext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinHistoryResult &a, CoinHistoryResult &b) {
  using ::std::swap;
  swap(a.historys, b.historys);
  swap(a.balance, b.balance);
  swap(a.hasNext, b.hasNext);
  swap(a.__isset, b.__isset);
}

CoinHistoryResult::CoinHistoryResult(const CoinHistoryResult& other164) {
  historys = other164.historys;
  balance = other164.balance;
  hasNext = other164.hasNext;
  __isset = other164.__isset;
}
CoinHistoryResult& CoinHistoryResult::operator=(const CoinHistoryResult& other165) {
  historys = other165.historys;
  balance = other165.balance;
  hasNext = other165.hasNext;
  __isset = other165.__isset;
  return *this;
}
void CoinHistoryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinHistoryResult(";
  out << "historys=" << to_string(historys);
  out << ", " << "balance=" << to_string(balance);
  out << ", " << "hasNext=" << to_string(hasNext);
  out << ")";
}


CoinProductItem::~CoinProductItem() noexcept {
}


void CoinProductItem::__set_itemId(const std::string& val) {
  this->itemId = val;
}

void CoinProductItem::__set_coin(const int32_t val) {
  this->coin = val;
}

void CoinProductItem::__set_freeCoin(const int32_t val) {
  this->freeCoin = val;
}

void CoinProductItem::__set_currency(const std::string& val) {
  this->currency = val;
}

void CoinProductItem::__set_price(const std::string& val) {
  this->price = val;
}

void CoinProductItem::__set_displayPrice(const std::string& val) {
  this->displayPrice = val;
}

void CoinProductItem::__set_name(const std::string& val) {
  this->name = val;
}

void CoinProductItem::__set_desc(const std::string& val) {
  this->desc = val;
}
std::ostream& operator<<(std::ostream& out, const CoinProductItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinProductItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->itemId);
          this->__isset.itemId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->coin);
          this->__isset.coin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->freeCoin);
          this->__isset.freeCoin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currency);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayPrice);
          this->__isset.displayPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          this->__isset.desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinProductItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinProductItem");

  xfer += oprot->writeFieldBegin("itemId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->itemId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coin", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->coin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeCoin", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->freeCoin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->currency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayPrice", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->displayPrice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinProductItem &a, CoinProductItem &b) {
  using ::std::swap;
  swap(a.itemId, b.itemId);
  swap(a.coin, b.coin);
  swap(a.freeCoin, b.freeCoin);
  swap(a.currency, b.currency);
  swap(a.price, b.price);
  swap(a.displayPrice, b.displayPrice);
  swap(a.name, b.name);
  swap(a.desc, b.desc);
  swap(a.__isset, b.__isset);
}

CoinProductItem::CoinProductItem(const CoinProductItem& other166) {
  itemId = other166.itemId;
  coin = other166.coin;
  freeCoin = other166.freeCoin;
  currency = other166.currency;
  price = other166.price;
  displayPrice = other166.displayPrice;
  name = other166.name;
  desc = other166.desc;
  __isset = other166.__isset;
}
CoinProductItem& CoinProductItem::operator=(const CoinProductItem& other167) {
  itemId = other167.itemId;
  coin = other167.coin;
  freeCoin = other167.freeCoin;
  currency = other167.currency;
  price = other167.price;
  displayPrice = other167.displayPrice;
  name = other167.name;
  desc = other167.desc;
  __isset = other167.__isset;
  return *this;
}
void CoinProductItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinProductItem(";
  out << "itemId=" << to_string(itemId);
  out << ", " << "coin=" << to_string(coin);
  out << ", " << "freeCoin=" << to_string(freeCoin);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "price=" << to_string(price);
  out << ", " << "displayPrice=" << to_string(displayPrice);
  out << ", " << "name=" << to_string(name);
  out << ", " << "desc=" << to_string(desc);
  out << ")";
}


CoinPurchaseConfirm::~CoinPurchaseConfirm() noexcept {
}


void CoinPurchaseConfirm::__set_orderId(const std::string& val) {
  this->orderId = val;
}

void CoinPurchaseConfirm::__set_appStoreCode(const PaymentType::type val) {
  this->appStoreCode = val;
}

void CoinPurchaseConfirm::__set_receipt(const std::string& val) {
  this->receipt = val;
}

void CoinPurchaseConfirm::__set_signature(const std::string& val) {
  this->signature = val;
}

void CoinPurchaseConfirm::__set_seller(const std::string& val) {
  this->seller = val;
}

void CoinPurchaseConfirm::__set_requestType(const std::string& val) {
  this->requestType = val;
}

void CoinPurchaseConfirm::__set_ignoreReceipt(const bool val) {
  this->ignoreReceipt = val;
}
std::ostream& operator<<(std::ostream& out, const CoinPurchaseConfirm& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinPurchaseConfirm::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderId);
          this->__isset.orderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast168;
          xfer += iprot->readI32(ecast168);
          this->appStoreCode = (PaymentType::type)ecast168;
          this->__isset.appStoreCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->receipt);
          this->__isset.receipt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->seller);
          this->__isset.seller = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requestType);
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreReceipt);
          this->__isset.ignoreReceipt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinPurchaseConfirm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinPurchaseConfirm");

  xfer += oprot->writeFieldBegin("orderId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->orderId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appStoreCode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->appStoreCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receipt", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->receipt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seller", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->seller);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->requestType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ignoreReceipt", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->ignoreReceipt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinPurchaseConfirm &a, CoinPurchaseConfirm &b) {
  using ::std::swap;
  swap(a.orderId, b.orderId);
  swap(a.appStoreCode, b.appStoreCode);
  swap(a.receipt, b.receipt);
  swap(a.signature, b.signature);
  swap(a.seller, b.seller);
  swap(a.requestType, b.requestType);
  swap(a.ignoreReceipt, b.ignoreReceipt);
  swap(a.__isset, b.__isset);
}

CoinPurchaseConfirm::CoinPurchaseConfirm(const CoinPurchaseConfirm& other169) {
  orderId = other169.orderId;
  appStoreCode = other169.appStoreCode;
  receipt = other169.receipt;
  signature = other169.signature;
  seller = other169.seller;
  requestType = other169.requestType;
  ignoreReceipt = other169.ignoreReceipt;
  __isset = other169.__isset;
}
CoinPurchaseConfirm& CoinPurchaseConfirm::operator=(const CoinPurchaseConfirm& other170) {
  orderId = other170.orderId;
  appStoreCode = other170.appStoreCode;
  receipt = other170.receipt;
  signature = other170.signature;
  seller = other170.seller;
  requestType = other170.requestType;
  ignoreReceipt = other170.ignoreReceipt;
  __isset = other170.__isset;
  return *this;
}
void CoinPurchaseConfirm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinPurchaseConfirm(";
  out << "orderId=" << to_string(orderId);
  out << ", " << "appStoreCode=" << to_string(appStoreCode);
  out << ", " << "receipt=" << to_string(receipt);
  out << ", " << "signature=" << to_string(signature);
  out << ", " << "seller=" << to_string(seller);
  out << ", " << "requestType=" << to_string(requestType);
  out << ", " << "ignoreReceipt=" << to_string(ignoreReceipt);
  out << ")";
}


CoinPurchaseReservation::~CoinPurchaseReservation() noexcept {
}


void CoinPurchaseReservation::__set_productId(const std::string& val) {
  this->productId = val;
}

void CoinPurchaseReservation::__set_country(const std::string& val) {
  this->country = val;
}

void CoinPurchaseReservation::__set_currency(const std::string& val) {
  this->currency = val;
}

void CoinPurchaseReservation::__set_price(const std::string& val) {
  this->price = val;
}

void CoinPurchaseReservation::__set_appStoreCode(const PaymentType::type val) {
  this->appStoreCode = val;
}

void CoinPurchaseReservation::__set_language(const std::string& val) {
  this->language = val;
}

void CoinPurchaseReservation::__set_pgCode(const PaymentPgType::type val) {
  this->pgCode = val;
}

void CoinPurchaseReservation::__set_redirectUrl(const std::string& val) {
  this->redirectUrl = val;
}
std::ostream& operator<<(std::ostream& out, const CoinPurchaseReservation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinPurchaseReservation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productId);
          this->__isset.productId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->country);
          this->__isset.country = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currency);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast171;
          xfer += iprot->readI32(ecast171);
          this->appStoreCode = (PaymentType::type)ecast171;
          this->__isset.appStoreCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->language);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast172;
          xfer += iprot->readI32(ecast172);
          this->pgCode = (PaymentPgType::type)ecast172;
          this->__isset.pgCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->redirectUrl);
          this->__isset.redirectUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinPurchaseReservation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinPurchaseReservation");

  xfer += oprot->writeFieldBegin("productId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->productId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("country", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->country);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->currency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appStoreCode", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->appStoreCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->language);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pgCode", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->pgCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("redirectUrl", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->redirectUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinPurchaseReservation &a, CoinPurchaseReservation &b) {
  using ::std::swap;
  swap(a.productId, b.productId);
  swap(a.country, b.country);
  swap(a.currency, b.currency);
  swap(a.price, b.price);
  swap(a.appStoreCode, b.appStoreCode);
  swap(a.language, b.language);
  swap(a.pgCode, b.pgCode);
  swap(a.redirectUrl, b.redirectUrl);
  swap(a.__isset, b.__isset);
}

CoinPurchaseReservation::CoinPurchaseReservation(const CoinPurchaseReservation& other173) {
  productId = other173.productId;
  country = other173.country;
  currency = other173.currency;
  price = other173.price;
  appStoreCode = other173.appStoreCode;
  language = other173.language;
  pgCode = other173.pgCode;
  redirectUrl = other173.redirectUrl;
  __isset = other173.__isset;
}
CoinPurchaseReservation& CoinPurchaseReservation::operator=(const CoinPurchaseReservation& other174) {
  productId = other174.productId;
  country = other174.country;
  currency = other174.currency;
  price = other174.price;
  appStoreCode = other174.appStoreCode;
  language = other174.language;
  pgCode = other174.pgCode;
  redirectUrl = other174.redirectUrl;
  __isset = other174.__isset;
  return *this;
}
void CoinPurchaseReservation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinPurchaseReservation(";
  out << "productId=" << to_string(productId);
  out << ", " << "country=" << to_string(country);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "price=" << to_string(price);
  out << ", " << "appStoreCode=" << to_string(appStoreCode);
  out << ", " << "language=" << to_string(language);
  out << ", " << "pgCode=" << to_string(pgCode);
  out << ", " << "redirectUrl=" << to_string(redirectUrl);
  out << ")";
}


CoinUseReservationItem::~CoinUseReservationItem() noexcept {
}


void CoinUseReservationItem::__set_itemId(const std::string& val) {
  this->itemId = val;
}

void CoinUseReservationItem::__set_itemName(const std::string& val) {
  this->itemName = val;
}

void CoinUseReservationItem::__set_amount(const int32_t val) {
  this->amount = val;
}
std::ostream& operator<<(std::ostream& out, const CoinUseReservationItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinUseReservationItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->itemId);
          this->__isset.itemId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->itemName);
          this->__isset.itemName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinUseReservationItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinUseReservationItem");

  xfer += oprot->writeFieldBegin("itemId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->itemId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->itemName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinUseReservationItem &a, CoinUseReservationItem &b) {
  using ::std::swap;
  swap(a.itemId, b.itemId);
  swap(a.itemName, b.itemName);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

CoinUseReservationItem::CoinUseReservationItem(const CoinUseReservationItem& other175) {
  itemId = other175.itemId;
  itemName = other175.itemName;
  amount = other175.amount;
  __isset = other175.__isset;
}
CoinUseReservationItem& CoinUseReservationItem::operator=(const CoinUseReservationItem& other176) {
  itemId = other176.itemId;
  itemName = other176.itemName;
  amount = other176.amount;
  __isset = other176.__isset;
  return *this;
}
void CoinUseReservationItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinUseReservationItem(";
  out << "itemId=" << to_string(itemId);
  out << ", " << "itemName=" << to_string(itemName);
  out << ", " << "amount=" << to_string(amount);
  out << ")";
}


CoinUseReservation::~CoinUseReservation() noexcept {
}


void CoinUseReservation::__set_channelId(const std::string& val) {
  this->channelId = val;
}

void CoinUseReservation::__set_shopOrderId(const std::string& val) {
  this->shopOrderId = val;
}

void CoinUseReservation::__set_appStoreCode(const PaymentType::type val) {
  this->appStoreCode = val;
}

void CoinUseReservation::__set_items(const std::vector<CoinUseReservationItem> & val) {
  this->items = val;
}

void CoinUseReservation::__set_country(const std::string& val) {
  this->country = val;
}
std::ostream& operator<<(std::ostream& out, const CoinUseReservation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoinUseReservation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channelId);
          this->__isset.channelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->shopOrderId);
          this->__isset.shopOrderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast177;
          xfer += iprot->readI32(ecast177);
          this->appStoreCode = (PaymentType::type)ecast177;
          this->__isset.appStoreCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->items.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->items.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += this->items[_i182].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->country);
          this->__isset.country = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoinUseReservation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoinUseReservation");

  xfer += oprot->writeFieldBegin("channelId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->channelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shopOrderId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->shopOrderId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appStoreCode", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->appStoreCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->items.size()));
    std::vector<CoinUseReservationItem> ::const_iterator _iter183;
    for (_iter183 = this->items.begin(); _iter183 != this->items.end(); ++_iter183)
    {
      xfer += (*_iter183).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("country", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->country);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoinUseReservation &a, CoinUseReservation &b) {
  using ::std::swap;
  swap(a.channelId, b.channelId);
  swap(a.shopOrderId, b.shopOrderId);
  swap(a.appStoreCode, b.appStoreCode);
  swap(a.items, b.items);
  swap(a.country, b.country);
  swap(a.__isset, b.__isset);
}

CoinUseReservation::CoinUseReservation(const CoinUseReservation& other184) {
  channelId = other184.channelId;
  shopOrderId = other184.shopOrderId;
  appStoreCode = other184.appStoreCode;
  items = other184.items;
  country = other184.country;
  __isset = other184.__isset;
}
CoinUseReservation& CoinUseReservation::operator=(const CoinUseReservation& other185) {
  channelId = other185.channelId;
  shopOrderId = other185.shopOrderId;
  appStoreCode = other185.appStoreCode;
  items = other185.items;
  country = other185.country;
  __isset = other185.__isset;
  return *this;
}
void CoinUseReservation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoinUseReservation(";
  out << "channelId=" << to_string(channelId);
  out << ", " << "shopOrderId=" << to_string(shopOrderId);
  out << ", " << "appStoreCode=" << to_string(appStoreCode);
  out << ", " << "items=" << to_string(items);
  out << ", " << "country=" << to_string(country);
  out << ")";
}


CompactContact::~CompactContact() noexcept {
}


void CompactContact::__set_mid(const std::string& val) {
  this->mid = val;
}

void CompactContact::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void CompactContact::__set_modifiedTime(const int64_t val) {
  this->modifiedTime = val;
}

void CompactContact::__set_status(const ContactStatus::type val) {
  this->status = val;
}

void CompactContact::__set_settings(const int64_t val) {
  this->settings = val;
}

void CompactContact::__set_displayNameOverridden(const std::string& val) {
  this->displayNameOverridden = val;
}
std::ostream& operator<<(std::ostream& out, const CompactContact& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactContact::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->modifiedTime);
          this->__isset.modifiedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast186;
          xfer += iprot->readI32(ecast186);
          this->status = (ContactStatus::type)ecast186;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->settings);
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayNameOverridden);
          this->__isset.displayNameOverridden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactContact::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactContact");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiedTime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->modifiedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->settings);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayNameOverridden", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->displayNameOverridden);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactContact &a, CompactContact &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.createdTime, b.createdTime);
  swap(a.modifiedTime, b.modifiedTime);
  swap(a.status, b.status);
  swap(a.settings, b.settings);
  swap(a.displayNameOverridden, b.displayNameOverridden);
  swap(a.__isset, b.__isset);
}

CompactContact::CompactContact(const CompactContact& other187) {
  mid = other187.mid;
  createdTime = other187.createdTime;
  modifiedTime = other187.modifiedTime;
  status = other187.status;
  settings = other187.settings;
  displayNameOverridden = other187.displayNameOverridden;
  __isset = other187.__isset;
}
CompactContact& CompactContact::operator=(const CompactContact& other188) {
  mid = other188.mid;
  createdTime = other188.createdTime;
  modifiedTime = other188.modifiedTime;
  status = other188.status;
  settings = other188.settings;
  displayNameOverridden = other188.displayNameOverridden;
  __isset = other188.__isset;
  return *this;
}
void CompactContact::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactContact(";
  out << "mid=" << to_string(mid);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "modifiedTime=" << to_string(modifiedTime);
  out << ", " << "status=" << to_string(status);
  out << ", " << "settings=" << to_string(settings);
  out << ", " << "displayNameOverridden=" << to_string(displayNameOverridden);
  out << ")";
}


ContactModification::~ContactModification() noexcept {
}


void ContactModification::__set_type(const ModificationType::type val) {
  this->type = val;
}

void ContactModification::__set_luid(const std::string& val) {
  this->luid = val;
}

void ContactModification::__set_phones(const std::vector<std::string> & val) {
  this->phones = val;
}

void ContactModification::__set_emails(const std::vector<std::string> & val) {
  this->emails = val;
}

void ContactModification::__set_userids(const std::vector<std::string> & val) {
  this->userids = val;
}
std::ostream& operator<<(std::ostream& out, const ContactModification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ContactModification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast189;
          xfer += iprot->readI32(ecast189);
          this->type = (ModificationType::type)ecast189;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->luid);
          this->__isset.luid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->phones.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->phones.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += iprot->readString(this->phones[_i194]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.phones = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->emails.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _etype198;
            xfer += iprot->readListBegin(_etype198, _size195);
            this->emails.resize(_size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              xfer += iprot->readString(this->emails[_i199]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.emails = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userids.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->userids.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += iprot->readString(this->userids[_i204]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContactModification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ContactModification");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("luid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->luid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phones", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->phones.size()));
    std::vector<std::string> ::const_iterator _iter205;
    for (_iter205 = this->phones.begin(); _iter205 != this->phones.end(); ++_iter205)
    {
      xfer += oprot->writeString((*_iter205));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("emails", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->emails.size()));
    std::vector<std::string> ::const_iterator _iter206;
    for (_iter206 = this->emails.begin(); _iter206 != this->emails.end(); ++_iter206)
    {
      xfer += oprot->writeString((*_iter206));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userids", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->userids.size()));
    std::vector<std::string> ::const_iterator _iter207;
    for (_iter207 = this->userids.begin(); _iter207 != this->userids.end(); ++_iter207)
    {
      xfer += oprot->writeString((*_iter207));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContactModification &a, ContactModification &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.luid, b.luid);
  swap(a.phones, b.phones);
  swap(a.emails, b.emails);
  swap(a.userids, b.userids);
  swap(a.__isset, b.__isset);
}

ContactModification::ContactModification(const ContactModification& other208) {
  type = other208.type;
  luid = other208.luid;
  phones = other208.phones;
  emails = other208.emails;
  userids = other208.userids;
  __isset = other208.__isset;
}
ContactModification& ContactModification::operator=(const ContactModification& other209) {
  type = other209.type;
  luid = other209.luid;
  phones = other209.phones;
  emails = other209.emails;
  userids = other209.userids;
  __isset = other209.__isset;
  return *this;
}
void ContactModification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ContactModification(";
  out << "type=" << to_string(type);
  out << ", " << "luid=" << to_string(luid);
  out << ", " << "phones=" << to_string(phones);
  out << ", " << "emails=" << to_string(emails);
  out << ", " << "userids=" << to_string(userids);
  out << ")";
}


ContactRegistration::~ContactRegistration() noexcept {
}


void ContactRegistration::__set_contact(const Contact& val) {
  this->contact = val;
}

void ContactRegistration::__set_luid(const std::string& val) {
  this->luid = val;
}

void ContactRegistration::__set_contactType(const ContactType::type val) {
  this->contactType = val;
}

void ContactRegistration::__set_contactKey(const std::string& val) {
  this->contactKey = val;
}
std::ostream& operator<<(std::ostream& out, const ContactRegistration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ContactRegistration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contact.read(iprot);
          this->__isset.contact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->luid);
          this->__isset.luid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast210;
          xfer += iprot->readI32(ecast210);
          this->contactType = (ContactType::type)ecast210;
          this->__isset.contactType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->contactKey);
          this->__isset.contactKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContactRegistration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ContactRegistration");

  xfer += oprot->writeFieldBegin("contact", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->contact.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("luid", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->luid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contactType", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32((int32_t)this->contactType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contactKey", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->contactKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContactRegistration &a, ContactRegistration &b) {
  using ::std::swap;
  swap(a.contact, b.contact);
  swap(a.luid, b.luid);
  swap(a.contactType, b.contactType);
  swap(a.contactKey, b.contactKey);
  swap(a.__isset, b.__isset);
}

ContactRegistration::ContactRegistration(const ContactRegistration& other211) {
  contact = other211.contact;
  luid = other211.luid;
  contactType = other211.contactType;
  contactKey = other211.contactKey;
  __isset = other211.__isset;
}
ContactRegistration& ContactRegistration::operator=(const ContactRegistration& other212) {
  contact = other212.contact;
  luid = other212.luid;
  contactType = other212.contactType;
  contactKey = other212.contactKey;
  __isset = other212.__isset;
  return *this;
}
void ContactRegistration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ContactRegistration(";
  out << "contact=" << to_string(contact);
  out << ", " << "luid=" << to_string(luid);
  out << ", " << "contactType=" << to_string(contactType);
  out << ", " << "contactKey=" << to_string(contactKey);
  out << ")";
}


ContactReport::~ContactReport() noexcept {
}


void ContactReport::__set_mid(const std::string& val) {
  this->mid = val;
}

void ContactReport::__set_exists(const bool val) {
  this->exists = val;
}

void ContactReport::__set_contact(const Contact& val) {
  this->contact = val;
}
std::ostream& operator<<(std::ostream& out, const ContactReport& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ContactReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->exists);
          this->__isset.exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contact.read(iprot);
          this->__isset.contact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContactReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ContactReport");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contact", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->contact.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContactReport &a, ContactReport &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.exists, b.exists);
  swap(a.contact, b.contact);
  swap(a.__isset, b.__isset);
}

ContactReport::ContactReport(const ContactReport& other213) {
  mid = other213.mid;
  exists = other213.exists;
  contact = other213.contact;
  __isset = other213.__isset;
}
ContactReport& ContactReport::operator=(const ContactReport& other214) {
  mid = other214.mid;
  exists = other214.exists;
  contact = other214.contact;
  __isset = other214.__isset;
  return *this;
}
void ContactReport::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ContactReport(";
  out << "mid=" << to_string(mid);
  out << ", " << "exists=" << to_string(exists);
  out << ", " << "contact=" << to_string(contact);
  out << ")";
}


ContactReportResult::~ContactReportResult() noexcept {
}


void ContactReportResult::__set_mid(const std::string& val) {
  this->mid = val;
}

void ContactReportResult::__set_exists(const bool val) {
  this->exists = val;
}
std::ostream& operator<<(std::ostream& out, const ContactReportResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ContactReportResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->exists);
          this->__isset.exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContactReportResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ContactReportResult");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContactReportResult &a, ContactReportResult &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.exists, b.exists);
  swap(a.__isset, b.__isset);
}

ContactReportResult::ContactReportResult(const ContactReportResult& other215) {
  mid = other215.mid;
  exists = other215.exists;
  __isset = other215.__isset;
}
ContactReportResult& ContactReportResult::operator=(const ContactReportResult& other216) {
  mid = other216.mid;
  exists = other216.exists;
  __isset = other216.__isset;
  return *this;
}
void ContactReportResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ContactReportResult(";
  out << "mid=" << to_string(mid);
  out << ", " << "exists=" << to_string(exists);
  out << ")";
}


DeviceInfo::~DeviceInfo() noexcept {
}


void DeviceInfo::__set_deviceName(const std::string& val) {
  this->deviceName = val;
}

void DeviceInfo::__set_systemName(const std::string& val) {
  this->systemName = val;
}

void DeviceInfo::__set_systemVersion(const std::string& val) {
  this->systemVersion = val;
}

void DeviceInfo::__set_model(const std::string& val) {
  this->model = val;
}

void DeviceInfo::__set_carrierCode(const CarrierCode::type val) {
  this->carrierCode = val;
}

void DeviceInfo::__set_carrierName(const std::string& val) {
  this->carrierName = val;
}

void DeviceInfo::__set_applicationType(const ApplicationType::type val) {
  this->applicationType = val;
}
std::ostream& operator<<(std::ostream& out, const DeviceInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeviceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceName);
          this->__isset.deviceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->systemName);
          this->__isset.systemName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->systemVersion);
          this->__isset.systemVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast217;
          xfer += iprot->readI32(ecast217);
          this->carrierCode = (CarrierCode::type)ecast217;
          this->__isset.carrierCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->carrierName);
          this->__isset.carrierName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast218;
          xfer += iprot->readI32(ecast218);
          this->applicationType = (ApplicationType::type)ecast218;
          this->__isset.applicationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeviceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeviceInfo");

  xfer += oprot->writeFieldBegin("deviceName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->deviceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("systemName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->systemName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("systemVersion", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->systemVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->model);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrierCode", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->carrierCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrierName", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->carrierName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationType", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->applicationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeviceInfo &a, DeviceInfo &b) {
  using ::std::swap;
  swap(a.deviceName, b.deviceName);
  swap(a.systemName, b.systemName);
  swap(a.systemVersion, b.systemVersion);
  swap(a.model, b.model);
  swap(a.carrierCode, b.carrierCode);
  swap(a.carrierName, b.carrierName);
  swap(a.applicationType, b.applicationType);
  swap(a.__isset, b.__isset);
}

DeviceInfo::DeviceInfo(const DeviceInfo& other219) {
  deviceName = other219.deviceName;
  systemName = other219.systemName;
  systemVersion = other219.systemVersion;
  model = other219.model;
  carrierCode = other219.carrierCode;
  carrierName = other219.carrierName;
  applicationType = other219.applicationType;
  __isset = other219.__isset;
}
DeviceInfo& DeviceInfo::operator=(const DeviceInfo& other220) {
  deviceName = other220.deviceName;
  systemName = other220.systemName;
  systemVersion = other220.systemVersion;
  model = other220.model;
  carrierCode = other220.carrierCode;
  carrierName = other220.carrierName;
  applicationType = other220.applicationType;
  __isset = other220.__isset;
  return *this;
}
void DeviceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeviceInfo(";
  out << "deviceName=" << to_string(deviceName);
  out << ", " << "systemName=" << to_string(systemName);
  out << ", " << "systemVersion=" << to_string(systemVersion);
  out << ", " << "model=" << to_string(model);
  out << ", " << "carrierCode=" << to_string(carrierCode);
  out << ", " << "carrierName=" << to_string(carrierName);
  out << ", " << "applicationType=" << to_string(applicationType);
  out << ")";
}


EmailConfirmation::~EmailConfirmation() noexcept {
}


void EmailConfirmation::__set_usePasswordSet(const bool val) {
  this->usePasswordSet = val;
}

void EmailConfirmation::__set_email(const std::string& val) {
  this->email = val;
}

void EmailConfirmation::__set_password(const std::string& val) {
  this->password = val;
}

void EmailConfirmation::__set_ignoreDuplication(const bool val) {
  this->ignoreDuplication = val;
}
std::ostream& operator<<(std::ostream& out, const EmailConfirmation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EmailConfirmation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->usePasswordSet);
          this->__isset.usePasswordSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreDuplication);
          this->__isset.ignoreDuplication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmailConfirmation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmailConfirmation");

  xfer += oprot->writeFieldBegin("usePasswordSet", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->usePasswordSet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->email);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ignoreDuplication", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->ignoreDuplication);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmailConfirmation &a, EmailConfirmation &b) {
  using ::std::swap;
  swap(a.usePasswordSet, b.usePasswordSet);
  swap(a.email, b.email);
  swap(a.password, b.password);
  swap(a.ignoreDuplication, b.ignoreDuplication);
  swap(a.__isset, b.__isset);
}

EmailConfirmation::EmailConfirmation(const EmailConfirmation& other221) {
  usePasswordSet = other221.usePasswordSet;
  email = other221.email;
  password = other221.password;
  ignoreDuplication = other221.ignoreDuplication;
  __isset = other221.__isset;
}
EmailConfirmation& EmailConfirmation::operator=(const EmailConfirmation& other222) {
  usePasswordSet = other222.usePasswordSet;
  email = other222.email;
  password = other222.password;
  ignoreDuplication = other222.ignoreDuplication;
  __isset = other222.__isset;
  return *this;
}
void EmailConfirmation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EmailConfirmation(";
  out << "usePasswordSet=" << to_string(usePasswordSet);
  out << ", " << "email=" << to_string(email);
  out << ", " << "password=" << to_string(password);
  out << ", " << "ignoreDuplication=" << to_string(ignoreDuplication);
  out << ")";
}


EmailConfirmationSession::~EmailConfirmationSession() noexcept {
}


void EmailConfirmationSession::__set_emailConfirmationType(const EmailConfirmationType::type val) {
  this->emailConfirmationType = val;
}

void EmailConfirmationSession::__set_verifier(const std::string& val) {
  this->verifier = val;
}

void EmailConfirmationSession::__set_targetEmail(const std::string& val) {
  this->targetEmail = val;
}
std::ostream& operator<<(std::ostream& out, const EmailConfirmationSession& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EmailConfirmationSession::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast223;
          xfer += iprot->readI32(ecast223);
          this->emailConfirmationType = (EmailConfirmationType::type)ecast223;
          this->__isset.emailConfirmationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->verifier);
          this->__isset.verifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetEmail);
          this->__isset.targetEmail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmailConfirmationSession::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmailConfirmationSession");

  xfer += oprot->writeFieldBegin("emailConfirmationType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->emailConfirmationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("verifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->verifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetEmail", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->targetEmail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmailConfirmationSession &a, EmailConfirmationSession &b) {
  using ::std::swap;
  swap(a.emailConfirmationType, b.emailConfirmationType);
  swap(a.verifier, b.verifier);
  swap(a.targetEmail, b.targetEmail);
  swap(a.__isset, b.__isset);
}

EmailConfirmationSession::EmailConfirmationSession(const EmailConfirmationSession& other224) {
  emailConfirmationType = other224.emailConfirmationType;
  verifier = other224.verifier;
  targetEmail = other224.targetEmail;
  __isset = other224.__isset;
}
EmailConfirmationSession& EmailConfirmationSession::operator=(const EmailConfirmationSession& other225) {
  emailConfirmationType = other225.emailConfirmationType;
  verifier = other225.verifier;
  targetEmail = other225.targetEmail;
  __isset = other225.__isset;
  return *this;
}
void EmailConfirmationSession::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EmailConfirmationSession(";
  out << "emailConfirmationType=" << to_string(emailConfirmationType);
  out << ", " << "verifier=" << to_string(verifier);
  out << ", " << "targetEmail=" << to_string(targetEmail);
  out << ")";
}


FriendChannelMatrix::~FriendChannelMatrix() noexcept {
}


void FriendChannelMatrix::__set_channelId(const std::string& val) {
  this->channelId = val;
}

void FriendChannelMatrix::__set_representMid(const std::string& val) {
  this->representMid = val;
}

void FriendChannelMatrix::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const FriendChannelMatrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FriendChannelMatrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channelId);
          this->__isset.channelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->representMid);
          this->__isset.representMid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FriendChannelMatrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FriendChannelMatrix");

  xfer += oprot->writeFieldBegin("channelId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->channelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("representMid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->representMid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FriendChannelMatrix &a, FriendChannelMatrix &b) {
  using ::std::swap;
  swap(a.channelId, b.channelId);
  swap(a.representMid, b.representMid);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

FriendChannelMatrix::FriendChannelMatrix(const FriendChannelMatrix& other226) {
  channelId = other226.channelId;
  representMid = other226.representMid;
  count = other226.count;
  __isset = other226.__isset;
}
FriendChannelMatrix& FriendChannelMatrix::operator=(const FriendChannelMatrix& other227) {
  channelId = other227.channelId;
  representMid = other227.representMid;
  count = other227.count;
  __isset = other227.__isset;
  return *this;
}
void FriendChannelMatrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FriendChannelMatrix(";
  out << "channelId=" << to_string(channelId);
  out << ", " << "representMid=" << to_string(representMid);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


FriendChannelMatricesResponse::~FriendChannelMatricesResponse() noexcept {
}


void FriendChannelMatricesResponse::__set_expires(const int64_t val) {
  this->expires = val;
}

void FriendChannelMatricesResponse::__set_matrices(const std::vector<FriendChannelMatrix> & val) {
  this->matrices = val;
}
std::ostream& operator<<(std::ostream& out, const FriendChannelMatricesResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FriendChannelMatricesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expires);
          this->__isset.expires = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrices.clear();
            uint32_t _size228;
            ::apache::thrift::protocol::TType _etype231;
            xfer += iprot->readListBegin(_etype231, _size228);
            this->matrices.resize(_size228);
            uint32_t _i232;
            for (_i232 = 0; _i232 < _size228; ++_i232)
            {
              xfer += this->matrices[_i232].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.matrices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FriendChannelMatricesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FriendChannelMatricesResponse");

  xfer += oprot->writeFieldBegin("expires", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->expires);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrices", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->matrices.size()));
    std::vector<FriendChannelMatrix> ::const_iterator _iter233;
    for (_iter233 = this->matrices.begin(); _iter233 != this->matrices.end(); ++_iter233)
    {
      xfer += (*_iter233).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FriendChannelMatricesResponse &a, FriendChannelMatricesResponse &b) {
  using ::std::swap;
  swap(a.expires, b.expires);
  swap(a.matrices, b.matrices);
  swap(a.__isset, b.__isset);
}

FriendChannelMatricesResponse::FriendChannelMatricesResponse(const FriendChannelMatricesResponse& other234) {
  expires = other234.expires;
  matrices = other234.matrices;
  __isset = other234.__isset;
}
FriendChannelMatricesResponse& FriendChannelMatricesResponse::operator=(const FriendChannelMatricesResponse& other235) {
  expires = other235.expires;
  matrices = other235.matrices;
  __isset = other235.__isset;
  return *this;
}
void FriendChannelMatricesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FriendChannelMatricesResponse(";
  out << "expires=" << to_string(expires);
  out << ", " << "matrices=" << to_string(matrices);
  out << ")";
}


Geolocation::~Geolocation() noexcept {
}


void Geolocation::__set_longitude(const double val) {
  this->longitude = val;
}

void Geolocation::__set_latitude(const double val) {
  this->latitude = val;
}
std::ostream& operator<<(std::ostream& out, const Geolocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Geolocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->longitude);
          this->__isset.longitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->latitude);
          this->__isset.latitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Geolocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Geolocation");

  xfer += oprot->writeFieldBegin("longitude", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->longitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("latitude", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->latitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Geolocation &a, Geolocation &b) {
  using ::std::swap;
  swap(a.longitude, b.longitude);
  swap(a.latitude, b.latitude);
  swap(a.__isset, b.__isset);
}

Geolocation::Geolocation(const Geolocation& other236) {
  longitude = other236.longitude;
  latitude = other236.latitude;
  __isset = other236.__isset;
}
Geolocation& Geolocation::operator=(const Geolocation& other237) {
  longitude = other237.longitude;
  latitude = other237.latitude;
  __isset = other237.__isset;
  return *this;
}
void Geolocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Geolocation(";
  out << "longitude=" << to_string(longitude);
  out << ", " << "latitude=" << to_string(latitude);
  out << ")";
}


NotificationTarget::~NotificationTarget() noexcept {
}


void NotificationTarget::__set_applicationType(const std::string& val) {
  this->applicationType = val;
}

void NotificationTarget::__set_applicationVersion(const std::string& val) {
  this->applicationVersion = val;
}

void NotificationTarget::__set_region(const std::string& val) {
  this->region = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationTarget& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationTarget::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationType);
          this->__isset.applicationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationVersion);
          this->__isset.applicationVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->region);
          this->__isset.region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotificationTarget::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationTarget");

  xfer += oprot->writeFieldBegin("applicationType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->applicationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationVersion", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->applicationVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("region", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->region);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationTarget &a, NotificationTarget &b) {
  using ::std::swap;
  swap(a.applicationType, b.applicationType);
  swap(a.applicationVersion, b.applicationVersion);
  swap(a.region, b.region);
  swap(a.__isset, b.__isset);
}

NotificationTarget::NotificationTarget(const NotificationTarget& other238) {
  applicationType = other238.applicationType;
  applicationVersion = other238.applicationVersion;
  region = other238.region;
  __isset = other238.__isset;
}
NotificationTarget& NotificationTarget::operator=(const NotificationTarget& other239) {
  applicationType = other239.applicationType;
  applicationVersion = other239.applicationVersion;
  region = other239.region;
  __isset = other239.__isset;
  return *this;
}
void NotificationTarget::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationTarget(";
  out << "applicationType=" << to_string(applicationType);
  out << ", " << "applicationVersion=" << to_string(applicationVersion);
  out << ", " << "region=" << to_string(region);
  out << ")";
}


GlobalEvent::~GlobalEvent() noexcept {
}


void GlobalEvent::__set_key(const std::string& val) {
  this->key = val;
}

void GlobalEvent::__set_targets(const std::vector<NotificationTarget> & val) {
  this->targets = val;
}

void GlobalEvent::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void GlobalEvent::__set_data(const int64_t val) {
  this->data = val;
}

void GlobalEvent::__set_maxDelay(const int32_t val) {
  this->maxDelay = val;
}
std::ostream& operator<<(std::ostream& out, const GlobalEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GlobalEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size240;
            ::apache::thrift::protocol::TType _etype243;
            xfer += iprot->readListBegin(_etype243, _size240);
            this->targets.resize(_size240);
            uint32_t _i244;
            for (_i244 = 0; _i244 < _size240; ++_i244)
            {
              xfer += this->targets[_i244].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxDelay);
          this->__isset.maxDelay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GlobalEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GlobalEvent");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->targets.size()));
    std::vector<NotificationTarget> ::const_iterator _iter245;
    for (_iter245 = this->targets.begin(); _iter245 != this->targets.end(); ++_iter245)
    {
      xfer += (*_iter245).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxDelay", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->maxDelay);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GlobalEvent &a, GlobalEvent &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.targets, b.targets);
  swap(a.createdTime, b.createdTime);
  swap(a.data, b.data);
  swap(a.maxDelay, b.maxDelay);
  swap(a.__isset, b.__isset);
}

GlobalEvent::GlobalEvent(const GlobalEvent& other246) {
  key = other246.key;
  targets = other246.targets;
  createdTime = other246.createdTime;
  data = other246.data;
  maxDelay = other246.maxDelay;
  __isset = other246.__isset;
}
GlobalEvent& GlobalEvent::operator=(const GlobalEvent& other247) {
  key = other247.key;
  targets = other247.targets;
  createdTime = other247.createdTime;
  data = other247.data;
  maxDelay = other247.maxDelay;
  __isset = other247.__isset;
  return *this;
}
void GlobalEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GlobalEvent(";
  out << "key=" << to_string(key);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "data=" << to_string(data);
  out << ", " << "maxDelay=" << to_string(maxDelay);
  out << ")";
}


Group::~Group() noexcept {
}


void Group::__set_id(const std::string& val) {
  this->id = val;
}

void Group::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void Group::__set_name(const std::string& val) {
  this->name = val;
}

void Group::__set_pictureStatus(const std::string& val) {
  this->pictureStatus = val;
}

void Group::__set_members(const std::vector<Contact> & val) {
  this->members = val;
}

void Group::__set_creator(const Contact& val) {
  this->creator = val;
}

void Group::__set_invitee(const std::vector<Contact> & val) {
  this->invitee = val;
}

void Group::__set_notificationDisabled(const bool val) {
  this->notificationDisabled = val;
}
std::ostream& operator<<(std::ostream& out, const Group& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Group::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pictureStatus);
          this->__isset.pictureStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->members.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _etype251;
            xfer += iprot->readListBegin(_etype251, _size248);
            this->members.resize(_size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              xfer += this->members[_i252].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.members = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->creator.read(iprot);
          this->__isset.creator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invitee.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _etype256;
            xfer += iprot->readListBegin(_etype256, _size253);
            this->invitee.resize(_size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              xfer += this->invitee[_i257].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.invitee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationDisabled);
          this->__isset.notificationDisabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Group::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Group");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pictureStatus", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->pictureStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("members", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->members.size()));
    std::vector<Contact> ::const_iterator _iter258;
    for (_iter258 = this->members.begin(); _iter258 != this->members.end(); ++_iter258)
    {
      xfer += (*_iter258).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("creator", ::apache::thrift::protocol::T_STRUCT, 21);
  xfer += this->creator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("invitee", ::apache::thrift::protocol::T_LIST, 22);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->invitee.size()));
    std::vector<Contact> ::const_iterator _iter259;
    for (_iter259 = this->invitee.begin(); _iter259 != this->invitee.end(); ++_iter259)
    {
      xfer += (*_iter259).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationDisabled", ::apache::thrift::protocol::T_BOOL, 31);
  xfer += oprot->writeBool(this->notificationDisabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Group &a, Group &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.createdTime, b.createdTime);
  swap(a.name, b.name);
  swap(a.pictureStatus, b.pictureStatus);
  swap(a.members, b.members);
  swap(a.creator, b.creator);
  swap(a.invitee, b.invitee);
  swap(a.notificationDisabled, b.notificationDisabled);
  swap(a.__isset, b.__isset);
}

Group::Group(const Group& other260) {
  id = other260.id;
  createdTime = other260.createdTime;
  name = other260.name;
  pictureStatus = other260.pictureStatus;
  members = other260.members;
  creator = other260.creator;
  invitee = other260.invitee;
  notificationDisabled = other260.notificationDisabled;
  __isset = other260.__isset;
}
Group& Group::operator=(const Group& other261) {
  id = other261.id;
  createdTime = other261.createdTime;
  name = other261.name;
  pictureStatus = other261.pictureStatus;
  members = other261.members;
  creator = other261.creator;
  invitee = other261.invitee;
  notificationDisabled = other261.notificationDisabled;
  __isset = other261.__isset;
  return *this;
}
void Group::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Group(";
  out << "id=" << to_string(id);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "name=" << to_string(name);
  out << ", " << "pictureStatus=" << to_string(pictureStatus);
  out << ", " << "members=" << to_string(members);
  out << ", " << "creator=" << to_string(creator);
  out << ", " << "invitee=" << to_string(invitee);
  out << ", " << "notificationDisabled=" << to_string(notificationDisabled);
  out << ")";
}


IdentityCredential::~IdentityCredential() noexcept {
}


void IdentityCredential::__set_provider(const IdentityProvider::type val) {
  this->provider = val;
}

void IdentityCredential::__set_identifier(const std::string& val) {
  this->identifier = val;
}

void IdentityCredential::__set_password(const std::string& val) {
  this->password = val;
}
std::ostream& operator<<(std::ostream& out, const IdentityCredential& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IdentityCredential::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast262;
          xfer += iprot->readI32(ecast262);
          this->provider = (IdentityProvider::type)ecast262;
          this->__isset.provider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifier);
          this->__isset.identifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IdentityCredential::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IdentityCredential");

  xfer += oprot->writeFieldBegin("provider", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->provider);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->identifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IdentityCredential &a, IdentityCredential &b) {
  using ::std::swap;
  swap(a.provider, b.provider);
  swap(a.identifier, b.identifier);
  swap(a.password, b.password);
  swap(a.__isset, b.__isset);
}

IdentityCredential::IdentityCredential(const IdentityCredential& other263) {
  provider = other263.provider;
  identifier = other263.identifier;
  password = other263.password;
  __isset = other263.__isset;
}
IdentityCredential& IdentityCredential::operator=(const IdentityCredential& other264) {
  provider = other264.provider;
  identifier = other264.identifier;
  password = other264.password;
  __isset = other264.__isset;
  return *this;
}
void IdentityCredential::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IdentityCredential(";
  out << "provider=" << to_string(provider);
  out << ", " << "identifier=" << to_string(identifier);
  out << ", " << "password=" << to_string(password);
  out << ")";
}


LastReadMessageId::~LastReadMessageId() noexcept {
}


void LastReadMessageId::__set_mid(const std::string& val) {
  this->mid = val;
}

void LastReadMessageId::__set_lastReadMessageId(const std::string& val) {
  this->lastReadMessageId = val;
}
std::ostream& operator<<(std::ostream& out, const LastReadMessageId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LastReadMessageId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lastReadMessageId);
          this->__isset.lastReadMessageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LastReadMessageId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LastReadMessageId");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastReadMessageId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->lastReadMessageId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LastReadMessageId &a, LastReadMessageId &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.lastReadMessageId, b.lastReadMessageId);
  swap(a.__isset, b.__isset);
}

LastReadMessageId::LastReadMessageId(const LastReadMessageId& other265) {
  mid = other265.mid;
  lastReadMessageId = other265.lastReadMessageId;
  __isset = other265.__isset;
}
LastReadMessageId& LastReadMessageId::operator=(const LastReadMessageId& other266) {
  mid = other266.mid;
  lastReadMessageId = other266.lastReadMessageId;
  __isset = other266.__isset;
  return *this;
}
void LastReadMessageId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LastReadMessageId(";
  out << "mid=" << to_string(mid);
  out << ", " << "lastReadMessageId=" << to_string(lastReadMessageId);
  out << ")";
}


LastReadMessageIds::~LastReadMessageIds() noexcept {
}


void LastReadMessageIds::__set_chatId(const std::string& val) {
  this->chatId = val;
}

void LastReadMessageIds::__set_lastReadMessageIds(const std::vector<LastReadMessageId> & val) {
  this->lastReadMessageIds = val;
}
std::ostream& operator<<(std::ostream& out, const LastReadMessageIds& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LastReadMessageIds::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->chatId);
          this->__isset.chatId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lastReadMessageIds.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->lastReadMessageIds.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += this->lastReadMessageIds[_i271].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lastReadMessageIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LastReadMessageIds::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LastReadMessageIds");

  xfer += oprot->writeFieldBegin("chatId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->chatId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastReadMessageIds", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lastReadMessageIds.size()));
    std::vector<LastReadMessageId> ::const_iterator _iter272;
    for (_iter272 = this->lastReadMessageIds.begin(); _iter272 != this->lastReadMessageIds.end(); ++_iter272)
    {
      xfer += (*_iter272).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LastReadMessageIds &a, LastReadMessageIds &b) {
  using ::std::swap;
  swap(a.chatId, b.chatId);
  swap(a.lastReadMessageIds, b.lastReadMessageIds);
  swap(a.__isset, b.__isset);
}

LastReadMessageIds::LastReadMessageIds(const LastReadMessageIds& other273) {
  chatId = other273.chatId;
  lastReadMessageIds = other273.lastReadMessageIds;
  __isset = other273.__isset;
}
LastReadMessageIds& LastReadMessageIds::operator=(const LastReadMessageIds& other274) {
  chatId = other274.chatId;
  lastReadMessageIds = other274.lastReadMessageIds;
  __isset = other274.__isset;
  return *this;
}
void LastReadMessageIds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LastReadMessageIds(";
  out << "chatId=" << to_string(chatId);
  out << ", " << "lastReadMessageIds=" << to_string(lastReadMessageIds);
  out << ")";
}


LoginResult::~LoginResult() noexcept {
}


void LoginResult::__set_authToken(const std::string& val) {
  this->authToken = val;
}

void LoginResult::__set_certificate(const std::string& val) {
  this->certificate = val;
}

void LoginResult::__set_verifier(const std::string& val) {
  this->verifier = val;
}

void LoginResult::__set_pinCode(const std::string& val) {
  this->pinCode = val;
}

void LoginResult::__set_type(const LoginResultType::type val) {
  this->type = val;
}
std::ostream& operator<<(std::ostream& out, const LoginResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoginResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->certificate);
          this->__isset.certificate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->verifier);
          this->__isset.verifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pinCode);
          this->__isset.pinCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast275;
          xfer += iprot->readI32(ecast275);
          this->type = (LoginResultType::type)ecast275;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoginResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoginResult");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("certificate", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->certificate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("verifier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->verifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pinCode", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->pinCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoginResult &a, LoginResult &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.certificate, b.certificate);
  swap(a.verifier, b.verifier);
  swap(a.pinCode, b.pinCode);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

LoginResult::LoginResult(const LoginResult& other276) {
  authToken = other276.authToken;
  certificate = other276.certificate;
  verifier = other276.verifier;
  pinCode = other276.pinCode;
  type = other276.type;
  __isset = other276.__isset;
}
LoginResult& LoginResult::operator=(const LoginResult& other277) {
  authToken = other277.authToken;
  certificate = other277.certificate;
  verifier = other277.verifier;
  pinCode = other277.pinCode;
  type = other277.type;
  __isset = other277.__isset;
  return *this;
}
void LoginResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoginResult(";
  out << "authToken=" << to_string(authToken);
  out << ", " << "certificate=" << to_string(certificate);
  out << ", " << "verifier=" << to_string(verifier);
  out << ", " << "pinCode=" << to_string(pinCode);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


LoginSession::~LoginSession() noexcept {
}


void LoginSession::__set_tokenKey(const std::string& val) {
  this->tokenKey = val;
}

void LoginSession::__set_expirationTime(const int64_t val) {
  this->expirationTime = val;
}

void LoginSession::__set_applicationType(const ApplicationType::type val) {
  this->applicationType = val;
}

void LoginSession::__set_systemName(const std::string& val) {
  this->systemName = val;
}

void LoginSession::__set_accessLocation(const std::string& val) {
  this->accessLocation = val;
}
std::ostream& operator<<(std::ostream& out, const LoginSession& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoginSession::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tokenKey);
          this->__isset.tokenKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expirationTime);
          this->__isset.expirationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast278;
          xfer += iprot->readI32(ecast278);
          this->applicationType = (ApplicationType::type)ecast278;
          this->__isset.applicationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->systemName);
          this->__isset.systemName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->accessLocation);
          this->__isset.accessLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoginSession::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoginSession");

  xfer += oprot->writeFieldBegin("tokenKey", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tokenKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expirationTime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->expirationTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationType", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32((int32_t)this->applicationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("systemName", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->systemName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accessLocation", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->accessLocation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoginSession &a, LoginSession &b) {
  using ::std::swap;
  swap(a.tokenKey, b.tokenKey);
  swap(a.expirationTime, b.expirationTime);
  swap(a.applicationType, b.applicationType);
  swap(a.systemName, b.systemName);
  swap(a.accessLocation, b.accessLocation);
  swap(a.__isset, b.__isset);
}

LoginSession::LoginSession(const LoginSession& other279) {
  tokenKey = other279.tokenKey;
  expirationTime = other279.expirationTime;
  applicationType = other279.applicationType;
  systemName = other279.systemName;
  accessLocation = other279.accessLocation;
  __isset = other279.__isset;
}
LoginSession& LoginSession::operator=(const LoginSession& other280) {
  tokenKey = other280.tokenKey;
  expirationTime = other280.expirationTime;
  applicationType = other280.applicationType;
  systemName = other280.systemName;
  accessLocation = other280.accessLocation;
  __isset = other280.__isset;
  return *this;
}
void LoginSession::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoginSession(";
  out << "tokenKey=" << to_string(tokenKey);
  out << ", " << "expirationTime=" << to_string(expirationTime);
  out << ", " << "applicationType=" << to_string(applicationType);
  out << ", " << "systemName=" << to_string(systemName);
  out << ", " << "accessLocation=" << to_string(accessLocation);
  out << ")";
}


Message::~Message() noexcept {
}


void Message::__set_from_(const std::string& val) {
  this->from_ = val;
}

void Message::__set_to(const std::string& val) {
  this->to = val;
}

void Message::__set_toType(const MIDType::type val) {
  this->toType = val;
}

void Message::__set_id(const std::string& val) {
  this->id = val;
}

void Message::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void Message::__set_deliveredTime(const int64_t val) {
  this->deliveredTime = val;
}

void Message::__set_text(const std::string& val) {
  this->text = val;
}

void Message::__set_location(const Location& val) {
  this->location = val;
}

void Message::__set_hasContent(const bool val) {
  this->hasContent = val;
}

void Message::__set_contentType(const ContentType::type val) {
  this->contentType = val;
}

void Message::__set_contentPreview(const std::string& val) {
  this->contentPreview = val;
}

void Message::__set_contentMetadata(const std::map<std::string, std::string> & val) {
  this->contentMetadata = val;
}
std::ostream& operator<<(std::ostream& out, const Message& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Message::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->from_);
          this->__isset.from_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->to);
          this->__isset.to = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast281;
          xfer += iprot->readI32(ecast281);
          this->toType = (MIDType::type)ecast281;
          this->__isset.toType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deliveredTime);
          this->__isset.deliveredTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasContent);
          this->__isset.hasContent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast282;
          xfer += iprot->readI32(ecast282);
          this->contentType = (ContentType::type)ecast282;
          this->__isset.contentType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->contentPreview);
          this->__isset.contentPreview = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->contentMetadata.clear();
            uint32_t _size283;
            ::apache::thrift::protocol::TType _ktype284;
            ::apache::thrift::protocol::TType _vtype285;
            xfer += iprot->readMapBegin(_ktype284, _vtype285, _size283);
            uint32_t _i287;
            for (_i287 = 0; _i287 < _size283; ++_i287)
            {
              std::string _key288;
              xfer += iprot->readString(_key288);
              std::string& _val289 = this->contentMetadata[_key288];
              xfer += iprot->readString(_val289);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.contentMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Message");

  xfer += oprot->writeFieldBegin("from_", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->from_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->to);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->toType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deliveredTime", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->deliveredTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->location.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasContent", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->hasContent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contentType", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32((int32_t)this->contentType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contentPreview", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeBinary(this->contentPreview);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contentMetadata", ::apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->contentMetadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter290;
    for (_iter290 = this->contentMetadata.begin(); _iter290 != this->contentMetadata.end(); ++_iter290)
    {
      xfer += oprot->writeString(_iter290->first);
      xfer += oprot->writeString(_iter290->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Message &a, Message &b) {
  using ::std::swap;
  swap(a.from_, b.from_);
  swap(a.to, b.to);
  swap(a.toType, b.toType);
  swap(a.id, b.id);
  swap(a.createdTime, b.createdTime);
  swap(a.deliveredTime, b.deliveredTime);
  swap(a.text, b.text);
  swap(a.location, b.location);
  swap(a.hasContent, b.hasContent);
  swap(a.contentType, b.contentType);
  swap(a.contentPreview, b.contentPreview);
  swap(a.contentMetadata, b.contentMetadata);
  swap(a.__isset, b.__isset);
}

Message::Message(const Message& other291) {
  from_ = other291.from_;
  to = other291.to;
  toType = other291.toType;
  id = other291.id;
  createdTime = other291.createdTime;
  deliveredTime = other291.deliveredTime;
  text = other291.text;
  location = other291.location;
  hasContent = other291.hasContent;
  contentType = other291.contentType;
  contentPreview = other291.contentPreview;
  contentMetadata = other291.contentMetadata;
  __isset = other291.__isset;
}
Message& Message::operator=(const Message& other292) {
  from_ = other292.from_;
  to = other292.to;
  toType = other292.toType;
  id = other292.id;
  createdTime = other292.createdTime;
  deliveredTime = other292.deliveredTime;
  text = other292.text;
  location = other292.location;
  hasContent = other292.hasContent;
  contentType = other292.contentType;
  contentPreview = other292.contentPreview;
  contentMetadata = other292.contentMetadata;
  __isset = other292.__isset;
  return *this;
}
void Message::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Message(";
  out << "from_=" << to_string(from_);
  out << ", " << "to=" << to_string(to);
  out << ", " << "toType=" << to_string(toType);
  out << ", " << "id=" << to_string(id);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "deliveredTime=" << to_string(deliveredTime);
  out << ", " << "text=" << to_string(text);
  out << ", " << "location=" << to_string(location);
  out << ", " << "hasContent=" << to_string(hasContent);
  out << ", " << "contentType=" << to_string(contentType);
  out << ", " << "contentPreview=" << to_string(contentPreview);
  out << ", " << "contentMetadata=" << to_string(contentMetadata);
  out << ")";
}


MessageOperation::~MessageOperation() noexcept {
}


void MessageOperation::__set_revision(const int64_t val) {
  this->revision = val;
}

void MessageOperation::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void MessageOperation::__set_type(const MessageOperationType::type val) {
  this->type = val;
}

void MessageOperation::__set_reqSeq(const int32_t val) {
  this->reqSeq = val;
}

void MessageOperation::__set_status(const OpStatus::type val) {
  this->status = val;
}

void MessageOperation::__set_param1(const std::string& val) {
  this->param1 = val;
}

void MessageOperation::__set_param2(const std::string& val) {
  this->param2 = val;
}

void MessageOperation::__set_param3(const std::string& val) {
  this->param3 = val;
}

void MessageOperation::__set_message(const Message& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const MessageOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MessageOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast293;
          xfer += iprot->readI32(ecast293);
          this->type = (MessageOperationType::type)ecast293;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->reqSeq);
          this->__isset.reqSeq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast294;
          xfer += iprot->readI32(ecast294);
          this->status = (OpStatus::type)ecast294;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param1);
          this->__isset.param1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param2);
          this->__isset.param2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param3);
          this->__isset.param3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->message.read(iprot);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MessageOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MessageOperation");

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reqSeq", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->reqSeq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param1", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->param1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param2", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->param2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param3", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->param3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->message.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageOperation &a, MessageOperation &b) {
  using ::std::swap;
  swap(a.revision, b.revision);
  swap(a.createdTime, b.createdTime);
  swap(a.type, b.type);
  swap(a.reqSeq, b.reqSeq);
  swap(a.status, b.status);
  swap(a.param1, b.param1);
  swap(a.param2, b.param2);
  swap(a.param3, b.param3);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

MessageOperation::MessageOperation(const MessageOperation& other295) {
  revision = other295.revision;
  createdTime = other295.createdTime;
  type = other295.type;
  reqSeq = other295.reqSeq;
  status = other295.status;
  param1 = other295.param1;
  param2 = other295.param2;
  param3 = other295.param3;
  message = other295.message;
  __isset = other295.__isset;
}
MessageOperation& MessageOperation::operator=(const MessageOperation& other296) {
  revision = other296.revision;
  createdTime = other296.createdTime;
  type = other296.type;
  reqSeq = other296.reqSeq;
  status = other296.status;
  param1 = other296.param1;
  param2 = other296.param2;
  param3 = other296.param3;
  message = other296.message;
  __isset = other296.__isset;
  return *this;
}
void MessageOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MessageOperation(";
  out << "revision=" << to_string(revision);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "type=" << to_string(type);
  out << ", " << "reqSeq=" << to_string(reqSeq);
  out << ", " << "status=" << to_string(status);
  out << ", " << "param1=" << to_string(param1);
  out << ", " << "param2=" << to_string(param2);
  out << ", " << "param3=" << to_string(param3);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


MessageOperations::~MessageOperations() noexcept {
}


void MessageOperations::__set_operations(const std::vector<MessageOperation> & val) {
  this->operations = val;
}

void MessageOperations::__set_endFlag(const bool val) {
  this->endFlag = val;
}
std::ostream& operator<<(std::ostream& out, const MessageOperations& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MessageOperations::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operations.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->operations.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += this->operations[_i301].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->endFlag);
          this->__isset.endFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MessageOperations::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MessageOperations");

  xfer += oprot->writeFieldBegin("operations", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->operations.size()));
    std::vector<MessageOperation> ::const_iterator _iter302;
    for (_iter302 = this->operations.begin(); _iter302 != this->operations.end(); ++_iter302)
    {
      xfer += (*_iter302).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endFlag", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->endFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageOperations &a, MessageOperations &b) {
  using ::std::swap;
  swap(a.operations, b.operations);
  swap(a.endFlag, b.endFlag);
  swap(a.__isset, b.__isset);
}

MessageOperations::MessageOperations(const MessageOperations& other303) {
  operations = other303.operations;
  endFlag = other303.endFlag;
  __isset = other303.__isset;
}
MessageOperations& MessageOperations::operator=(const MessageOperations& other304) {
  operations = other304.operations;
  endFlag = other304.endFlag;
  __isset = other304.__isset;
  return *this;
}
void MessageOperations::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MessageOperations(";
  out << "operations=" << to_string(operations);
  out << ", " << "endFlag=" << to_string(endFlag);
  out << ")";
}


MetaProfile::~MetaProfile() noexcept {
}


void MetaProfile::__set_createTime(const int64_t val) {
  this->createTime = val;
}

void MetaProfile::__set_regionCode(const std::string& val) {
  this->regionCode = val;
}

void MetaProfile::__set_identities(const std::map<RegistrationType::type, std::string> & val) {
  this->identities = val;
}
std::ostream& operator<<(std::ostream& out, const MetaProfile& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetaProfile::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->regionCode);
          this->__isset.regionCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->identities.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _ktype306;
            ::apache::thrift::protocol::TType _vtype307;
            xfer += iprot->readMapBegin(_ktype306, _vtype307, _size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              RegistrationType::type _key310;
              int32_t ecast312;
              xfer += iprot->readI32(ecast312);
              _key310 = (RegistrationType::type)ecast312;
              std::string& _val311 = this->identities[_key310];
              xfer += iprot->readString(_val311);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.identities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetaProfile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetaProfile");

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regionCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->regionCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identities", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->identities.size()));
    std::map<RegistrationType::type, std::string> ::const_iterator _iter313;
    for (_iter313 = this->identities.begin(); _iter313 != this->identities.end(); ++_iter313)
    {
      xfer += oprot->writeI32((int32_t)_iter313->first);
      xfer += oprot->writeString(_iter313->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetaProfile &a, MetaProfile &b) {
  using ::std::swap;
  swap(a.createTime, b.createTime);
  swap(a.regionCode, b.regionCode);
  swap(a.identities, b.identities);
  swap(a.__isset, b.__isset);
}

MetaProfile::MetaProfile(const MetaProfile& other314) {
  createTime = other314.createTime;
  regionCode = other314.regionCode;
  identities = other314.identities;
  __isset = other314.__isset;
}
MetaProfile& MetaProfile::operator=(const MetaProfile& other315) {
  createTime = other315.createTime;
  regionCode = other315.regionCode;
  identities = other315.identities;
  __isset = other315.__isset;
  return *this;
}
void MetaProfile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetaProfile(";
  out << "createTime=" << to_string(createTime);
  out << ", " << "regionCode=" << to_string(regionCode);
  out << ", " << "identities=" << to_string(identities);
  out << ")";
}


NotificationItem::~NotificationItem() noexcept {
}


void NotificationItem::__set_id(const std::string& val) {
  this->id = val;
}

void NotificationItem::__set_from_(const std::string& val) {
  this->from_ = val;
}

void NotificationItem::__set_to(const std::string& val) {
  this->to = val;
}

void NotificationItem::__set_fromChannel(const std::string& val) {
  this->fromChannel = val;
}

void NotificationItem::__set_toChannel(const std::string& val) {
  this->toChannel = val;
}

void NotificationItem::__set_revision(const int64_t val) {
  this->revision = val;
}

void NotificationItem::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void NotificationItem::__set_content(const std::map<std::string, std::string> & val) {
  this->content = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->from_);
          this->__isset.from_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->to);
          this->__isset.to = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fromChannel);
          this->__isset.fromChannel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->toChannel);
          this->__isset.toChannel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->content.clear();
            uint32_t _size316;
            ::apache::thrift::protocol::TType _ktype317;
            ::apache::thrift::protocol::TType _vtype318;
            xfer += iprot->readMapBegin(_ktype317, _vtype318, _size316);
            uint32_t _i320;
            for (_i320 = 0; _i320 < _size316; ++_i320)
            {
              std::string _key321;
              xfer += iprot->readString(_key321);
              std::string& _val322 = this->content[_key321];
              xfer += iprot->readString(_val322);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotificationItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationItem");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("from_", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->from_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->to);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromChannel", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->fromChannel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toChannel", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->toChannel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->content.size()));
    std::map<std::string, std::string> ::const_iterator _iter323;
    for (_iter323 = this->content.begin(); _iter323 != this->content.end(); ++_iter323)
    {
      xfer += oprot->writeString(_iter323->first);
      xfer += oprot->writeString(_iter323->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationItem &a, NotificationItem &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.from_, b.from_);
  swap(a.to, b.to);
  swap(a.fromChannel, b.fromChannel);
  swap(a.toChannel, b.toChannel);
  swap(a.revision, b.revision);
  swap(a.createdTime, b.createdTime);
  swap(a.content, b.content);
  swap(a.__isset, b.__isset);
}

NotificationItem::NotificationItem(const NotificationItem& other324) {
  id = other324.id;
  from_ = other324.from_;
  to = other324.to;
  fromChannel = other324.fromChannel;
  toChannel = other324.toChannel;
  revision = other324.revision;
  createdTime = other324.createdTime;
  content = other324.content;
  __isset = other324.__isset;
}
NotificationItem& NotificationItem::operator=(const NotificationItem& other325) {
  id = other325.id;
  from_ = other325.from_;
  to = other325.to;
  fromChannel = other325.fromChannel;
  toChannel = other325.toChannel;
  revision = other325.revision;
  createdTime = other325.createdTime;
  content = other325.content;
  __isset = other325.__isset;
  return *this;
}
void NotificationItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationItem(";
  out << "id=" << to_string(id);
  out << ", " << "from_=" << to_string(from_);
  out << ", " << "to=" << to_string(to);
  out << ", " << "fromChannel=" << to_string(fromChannel);
  out << ", " << "toChannel=" << to_string(toChannel);
  out << ", " << "revision=" << to_string(revision);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "content=" << to_string(content);
  out << ")";
}


NotificationFetchResult::~NotificationFetchResult() noexcept {
}


void NotificationFetchResult::__set_fetchMode(const NotificationItemFetchMode::type val) {
  this->fetchMode = val;
}

void NotificationFetchResult::__set_itemList(const std::vector<NotificationItem> & val) {
  this->itemList = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationFetchResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationFetchResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast326;
          xfer += iprot->readI32(ecast326);
          this->fetchMode = (NotificationItemFetchMode::type)ecast326;
          this->__isset.fetchMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->itemList.clear();
            uint32_t _size327;
            ::apache::thrift::protocol::TType _etype330;
            xfer += iprot->readListBegin(_etype330, _size327);
            this->itemList.resize(_size327);
            uint32_t _i331;
            for (_i331 = 0; _i331 < _size327; ++_i331)
            {
              xfer += this->itemList[_i331].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.itemList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotificationFetchResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationFetchResult");

  xfer += oprot->writeFieldBegin("fetchMode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->fetchMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->itemList.size()));
    std::vector<NotificationItem> ::const_iterator _iter332;
    for (_iter332 = this->itemList.begin(); _iter332 != this->itemList.end(); ++_iter332)
    {
      xfer += (*_iter332).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationFetchResult &a, NotificationFetchResult &b) {
  using ::std::swap;
  swap(a.fetchMode, b.fetchMode);
  swap(a.itemList, b.itemList);
  swap(a.__isset, b.__isset);
}

NotificationFetchResult::NotificationFetchResult(const NotificationFetchResult& other333) {
  fetchMode = other333.fetchMode;
  itemList = other333.itemList;
  __isset = other333.__isset;
}
NotificationFetchResult& NotificationFetchResult::operator=(const NotificationFetchResult& other334) {
  fetchMode = other334.fetchMode;
  itemList = other334.itemList;
  __isset = other334.__isset;
  return *this;
}
void NotificationFetchResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationFetchResult(";
  out << "fetchMode=" << to_string(fetchMode);
  out << ", " << "itemList=" << to_string(itemList);
  out << ")";
}


Operation::~Operation() noexcept {
}


void Operation::__set_revision(const int64_t val) {
  this->revision = val;
}

void Operation::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void Operation::__set_type(const OpType::type val) {
  this->type = val;
}

void Operation::__set_reqSeq(const int32_t val) {
  this->reqSeq = val;
}

void Operation::__set_checksum(const std::string& val) {
  this->checksum = val;
}

void Operation::__set_status(const OpStatus::type val) {
  this->status = val;
}

void Operation::__set_param1(const std::string& val) {
  this->param1 = val;
}

void Operation::__set_param2(const std::string& val) {
  this->param2 = val;
}

void Operation::__set_param3(const std::string& val) {
  this->param3 = val;
}

void Operation::__set_message(const Message& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Operation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Operation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast335;
          xfer += iprot->readI32(ecast335);
          this->type = (OpType::type)ecast335;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->reqSeq);
          this->__isset.reqSeq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast336;
          xfer += iprot->readI32(ecast336);
          this->status = (OpStatus::type)ecast336;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param1);
          this->__isset.param1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param2);
          this->__isset.param2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param3);
          this->__isset.param3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->message.read(iprot);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Operation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Operation");

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reqSeq", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->reqSeq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("checksum", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->checksum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param1", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->param1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param2", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->param2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param3", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->param3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->message.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Operation &a, Operation &b) {
  using ::std::swap;
  swap(a.revision, b.revision);
  swap(a.createdTime, b.createdTime);
  swap(a.type, b.type);
  swap(a.reqSeq, b.reqSeq);
  swap(a.checksum, b.checksum);
  swap(a.status, b.status);
  swap(a.param1, b.param1);
  swap(a.param2, b.param2);
  swap(a.param3, b.param3);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Operation::Operation(const Operation& other337) {
  revision = other337.revision;
  createdTime = other337.createdTime;
  type = other337.type;
  reqSeq = other337.reqSeq;
  checksum = other337.checksum;
  status = other337.status;
  param1 = other337.param1;
  param2 = other337.param2;
  param3 = other337.param3;
  message = other337.message;
  __isset = other337.__isset;
}
Operation& Operation::operator=(const Operation& other338) {
  revision = other338.revision;
  createdTime = other338.createdTime;
  type = other338.type;
  reqSeq = other338.reqSeq;
  checksum = other338.checksum;
  status = other338.status;
  param1 = other338.param1;
  param2 = other338.param2;
  param3 = other338.param3;
  message = other338.message;
  __isset = other338.__isset;
  return *this;
}
void Operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Operation(";
  out << "revision=" << to_string(revision);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "type=" << to_string(type);
  out << ", " << "reqSeq=" << to_string(reqSeq);
  out << ", " << "checksum=" << to_string(checksum);
  out << ", " << "status=" << to_string(status);
  out << ", " << "param1=" << to_string(param1);
  out << ", " << "param2=" << to_string(param2);
  out << ", " << "param3=" << to_string(param3);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


PaymentReservation::~PaymentReservation() noexcept {
}


void PaymentReservation::__set_receiverMid(const std::string& val) {
  this->receiverMid = val;
}

void PaymentReservation::__set_productId(const std::string& val) {
  this->productId = val;
}

void PaymentReservation::__set_language(const std::string& val) {
  this->language = val;
}

void PaymentReservation::__set_location(const std::string& val) {
  this->location = val;
}

void PaymentReservation::__set_currency(const std::string& val) {
  this->currency = val;
}

void PaymentReservation::__set_price(const std::string& val) {
  this->price = val;
}

void PaymentReservation::__set_appStoreCode(const PaymentType::type val) {
  this->appStoreCode = val;
}

void PaymentReservation::__set_messageText(const std::string& val) {
  this->messageText = val;
}

void PaymentReservation::__set_messageTemplate(const int32_t val) {
  this->messageTemplate = val;
}

void PaymentReservation::__set_packageId(const int64_t val) {
  this->packageId = val;
}
std::ostream& operator<<(std::ostream& out, const PaymentReservation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PaymentReservation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->receiverMid);
          this->__isset.receiverMid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productId);
          this->__isset.productId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->language);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currency);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast339;
          xfer += iprot->readI32(ecast339);
          this->appStoreCode = (PaymentType::type)ecast339;
          this->__isset.appStoreCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageText);
          this->__isset.messageText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->messageTemplate);
          this->__isset.messageTemplate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packageId);
          this->__isset.packageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PaymentReservation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PaymentReservation");

  xfer += oprot->writeFieldBegin("receiverMid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->receiverMid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->productId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->language);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->currency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appStoreCode", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->appStoreCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageText", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->messageText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageTemplate", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->messageTemplate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageId", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->packageId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PaymentReservation &a, PaymentReservation &b) {
  using ::std::swap;
  swap(a.receiverMid, b.receiverMid);
  swap(a.productId, b.productId);
  swap(a.language, b.language);
  swap(a.location, b.location);
  swap(a.currency, b.currency);
  swap(a.price, b.price);
  swap(a.appStoreCode, b.appStoreCode);
  swap(a.messageText, b.messageText);
  swap(a.messageTemplate, b.messageTemplate);
  swap(a.packageId, b.packageId);
  swap(a.__isset, b.__isset);
}

PaymentReservation::PaymentReservation(const PaymentReservation& other340) {
  receiverMid = other340.receiverMid;
  productId = other340.productId;
  language = other340.language;
  location = other340.location;
  currency = other340.currency;
  price = other340.price;
  appStoreCode = other340.appStoreCode;
  messageText = other340.messageText;
  messageTemplate = other340.messageTemplate;
  packageId = other340.packageId;
  __isset = other340.__isset;
}
PaymentReservation& PaymentReservation::operator=(const PaymentReservation& other341) {
  receiverMid = other341.receiverMid;
  productId = other341.productId;
  language = other341.language;
  location = other341.location;
  currency = other341.currency;
  price = other341.price;
  appStoreCode = other341.appStoreCode;
  messageText = other341.messageText;
  messageTemplate = other341.messageTemplate;
  packageId = other341.packageId;
  __isset = other341.__isset;
  return *this;
}
void PaymentReservation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PaymentReservation(";
  out << "receiverMid=" << to_string(receiverMid);
  out << ", " << "productId=" << to_string(productId);
  out << ", " << "language=" << to_string(language);
  out << ", " << "location=" << to_string(location);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "price=" << to_string(price);
  out << ", " << "appStoreCode=" << to_string(appStoreCode);
  out << ", " << "messageText=" << to_string(messageText);
  out << ", " << "messageTemplate=" << to_string(messageTemplate);
  out << ", " << "packageId=" << to_string(packageId);
  out << ")";
}


PaymentReservationResult::~PaymentReservationResult() noexcept {
}


void PaymentReservationResult::__set_orderId(const std::string& val) {
  this->orderId = val;
}

void PaymentReservationResult::__set_confirmUrl(const std::string& val) {
  this->confirmUrl = val;
}

void PaymentReservationResult::__set_extras(const std::map<std::string, std::string> & val) {
  this->extras = val;
}
std::ostream& operator<<(std::ostream& out, const PaymentReservationResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PaymentReservationResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderId);
          this->__isset.orderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->confirmUrl);
          this->__isset.confirmUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extras.clear();
            uint32_t _size342;
            ::apache::thrift::protocol::TType _ktype343;
            ::apache::thrift::protocol::TType _vtype344;
            xfer += iprot->readMapBegin(_ktype343, _vtype344, _size342);
            uint32_t _i346;
            for (_i346 = 0; _i346 < _size342; ++_i346)
            {
              std::string _key347;
              xfer += iprot->readString(_key347);
              std::string& _val348 = this->extras[_key347];
              xfer += iprot->readString(_val348);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extras = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PaymentReservationResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PaymentReservationResult");

  xfer += oprot->writeFieldBegin("orderId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->orderId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("confirmUrl", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->confirmUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extras", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extras.size()));
    std::map<std::string, std::string> ::const_iterator _iter349;
    for (_iter349 = this->extras.begin(); _iter349 != this->extras.end(); ++_iter349)
    {
      xfer += oprot->writeString(_iter349->first);
      xfer += oprot->writeString(_iter349->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PaymentReservationResult &a, PaymentReservationResult &b) {
  using ::std::swap;
  swap(a.orderId, b.orderId);
  swap(a.confirmUrl, b.confirmUrl);
  swap(a.extras, b.extras);
  swap(a.__isset, b.__isset);
}

PaymentReservationResult::PaymentReservationResult(const PaymentReservationResult& other350) {
  orderId = other350.orderId;
  confirmUrl = other350.confirmUrl;
  extras = other350.extras;
  __isset = other350.__isset;
}
PaymentReservationResult& PaymentReservationResult::operator=(const PaymentReservationResult& other351) {
  orderId = other351.orderId;
  confirmUrl = other351.confirmUrl;
  extras = other351.extras;
  __isset = other351.__isset;
  return *this;
}
void PaymentReservationResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PaymentReservationResult(";
  out << "orderId=" << to_string(orderId);
  out << ", " << "confirmUrl=" << to_string(confirmUrl);
  out << ", " << "extras=" << to_string(extras);
  out << ")";
}


Product::~Product() noexcept {
}


void Product::__set_productId(const std::string& val) {
  this->productId = val;
}

void Product::__set_packageId(const int64_t val) {
  this->packageId = val;
}

void Product::__set_version(const int32_t val) {
  this->version = val;
}

void Product::__set_authorName(const std::string& val) {
  this->authorName = val;
}

void Product::__set_onSale(const bool val) {
  this->onSale = val;
}

void Product::__set_validDays(const int32_t val) {
  this->validDays = val;
}

void Product::__set_saleType(const int32_t val) {
  this->saleType = val;
}

void Product::__set_copyright(const std::string& val) {
  this->copyright = val;
}

void Product::__set_title(const std::string& val) {
  this->title = val;
}

void Product::__set_descriptionText(const std::string& val) {
  this->descriptionText = val;
}

void Product::__set_shopOrderId(const int64_t val) {
  this->shopOrderId = val;
}

void Product::__set_fromMid(const std::string& val) {
  this->fromMid = val;
}

void Product::__set_toMid(const std::string& val) {
  this->toMid = val;
}

void Product::__set_validUntil(const int64_t val) {
  this->validUntil = val;
}

void Product::__set_priceTier(const int32_t val) {
  this->priceTier = val;
}

void Product::__set_price(const std::string& val) {
  this->price = val;
}

void Product::__set_currency(const std::string& val) {
  this->currency = val;
}

void Product::__set_currencySymbol(const std::string& val) {
  this->currencySymbol = val;
}

void Product::__set_paymentType(const PaymentType::type val) {
  this->paymentType = val;
}

void Product::__set_createDate(const int64_t val) {
  this->createDate = val;
}

void Product::__set_ownFlag(const bool val) {
  this->ownFlag = val;
}

void Product::__set_eventType(const ProductEventType::type val) {
  this->eventType = val;
}

void Product::__set_urlSchema(const std::string& val) {
  this->urlSchema = val;
}

void Product::__set_downloadUrl(const std::string& val) {
  this->downloadUrl = val;
}

void Product::__set_buddyMid(const std::string& val) {
  this->buddyMid = val;
}

void Product::__set_publishSince(const int64_t val) {
  this->publishSince = val;
}

void Product::__set_newFlag(const bool val) {
  this->newFlag = val;
}

void Product::__set_missionFlag(const bool val) {
  this->missionFlag = val;
}
std::ostream& operator<<(std::ostream& out, const Product& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Product::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productId);
          this->__isset.productId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packageId);
          this->__isset.packageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authorName);
          this->__isset.authorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->onSale);
          this->__isset.onSale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->validDays);
          this->__isset.validDays = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->saleType);
          this->__isset.saleType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->copyright);
          this->__isset.copyright = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->descriptionText);
          this->__isset.descriptionText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shopOrderId);
          this->__isset.shopOrderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fromMid);
          this->__isset.fromMid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->toMid);
          this->__isset.toMid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->validUntil);
          this->__isset.validUntil = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priceTier);
          this->__isset.priceTier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currency);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currencySymbol);
          this->__isset.currencySymbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast352;
          xfer += iprot->readI32(ecast352);
          this->paymentType = (PaymentType::type)ecast352;
          this->__isset.paymentType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createDate);
          this->__isset.createDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ownFlag);
          this->__isset.ownFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast353;
          xfer += iprot->readI32(ecast353);
          this->eventType = (ProductEventType::type)ecast353;
          this->__isset.eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->urlSchema);
          this->__isset.urlSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->downloadUrl);
          this->__isset.downloadUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->buddyMid);
          this->__isset.buddyMid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->publishSince);
          this->__isset.publishSince = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->newFlag);
          this->__isset.newFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->missionFlag);
          this->__isset.missionFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Product::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Product");

  xfer += oprot->writeFieldBegin("productId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->productId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->packageId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->authorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onSale", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->onSale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validDays", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->validDays);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("saleType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->saleType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copyright", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->copyright);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("descriptionText", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->descriptionText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shopOrderId", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->shopOrderId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromMid", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->fromMid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toMid", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->toMid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validUntil", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64(this->validUntil);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priceTier", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->priceTier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->currency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currencySymbol", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->currencySymbol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paymentType", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32((int32_t)this->paymentType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createDate", ::apache::thrift::protocol::T_I64, 20);
  xfer += oprot->writeI64(this->createDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownFlag", ::apache::thrift::protocol::T_BOOL, 21);
  xfer += oprot->writeBool(this->ownFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32((int32_t)this->eventType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("urlSchema", ::apache::thrift::protocol::T_STRING, 23);
  xfer += oprot->writeString(this->urlSchema);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downloadUrl", ::apache::thrift::protocol::T_STRING, 24);
  xfer += oprot->writeString(this->downloadUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buddyMid", ::apache::thrift::protocol::T_STRING, 25);
  xfer += oprot->writeString(this->buddyMid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("publishSince", ::apache::thrift::protocol::T_I64, 26);
  xfer += oprot->writeI64(this->publishSince);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newFlag", ::apache::thrift::protocol::T_BOOL, 27);
  xfer += oprot->writeBool(this->newFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("missionFlag", ::apache::thrift::protocol::T_BOOL, 28);
  xfer += oprot->writeBool(this->missionFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Product &a, Product &b) {
  using ::std::swap;
  swap(a.productId, b.productId);
  swap(a.packageId, b.packageId);
  swap(a.version, b.version);
  swap(a.authorName, b.authorName);
  swap(a.onSale, b.onSale);
  swap(a.validDays, b.validDays);
  swap(a.saleType, b.saleType);
  swap(a.copyright, b.copyright);
  swap(a.title, b.title);
  swap(a.descriptionText, b.descriptionText);
  swap(a.shopOrderId, b.shopOrderId);
  swap(a.fromMid, b.fromMid);
  swap(a.toMid, b.toMid);
  swap(a.validUntil, b.validUntil);
  swap(a.priceTier, b.priceTier);
  swap(a.price, b.price);
  swap(a.currency, b.currency);
  swap(a.currencySymbol, b.currencySymbol);
  swap(a.paymentType, b.paymentType);
  swap(a.createDate, b.createDate);
  swap(a.ownFlag, b.ownFlag);
  swap(a.eventType, b.eventType);
  swap(a.urlSchema, b.urlSchema);
  swap(a.downloadUrl, b.downloadUrl);
  swap(a.buddyMid, b.buddyMid);
  swap(a.publishSince, b.publishSince);
  swap(a.newFlag, b.newFlag);
  swap(a.missionFlag, b.missionFlag);
  swap(a.__isset, b.__isset);
}

Product::Product(const Product& other354) {
  productId = other354.productId;
  packageId = other354.packageId;
  version = other354.version;
  authorName = other354.authorName;
  onSale = other354.onSale;
  validDays = other354.validDays;
  saleType = other354.saleType;
  copyright = other354.copyright;
  title = other354.title;
  descriptionText = other354.descriptionText;
  shopOrderId = other354.shopOrderId;
  fromMid = other354.fromMid;
  toMid = other354.toMid;
  validUntil = other354.validUntil;
  priceTier = other354.priceTier;
  price = other354.price;
  currency = other354.currency;
  currencySymbol = other354.currencySymbol;
  paymentType = other354.paymentType;
  createDate = other354.createDate;
  ownFlag = other354.ownFlag;
  eventType = other354.eventType;
  urlSchema = other354.urlSchema;
  downloadUrl = other354.downloadUrl;
  buddyMid = other354.buddyMid;
  publishSince = other354.publishSince;
  newFlag = other354.newFlag;
  missionFlag = other354.missionFlag;
  __isset = other354.__isset;
}
Product& Product::operator=(const Product& other355) {
  productId = other355.productId;
  packageId = other355.packageId;
  version = other355.version;
  authorName = other355.authorName;
  onSale = other355.onSale;
  validDays = other355.validDays;
  saleType = other355.saleType;
  copyright = other355.copyright;
  title = other355.title;
  descriptionText = other355.descriptionText;
  shopOrderId = other355.shopOrderId;
  fromMid = other355.fromMid;
  toMid = other355.toMid;
  validUntil = other355.validUntil;
  priceTier = other355.priceTier;
  price = other355.price;
  currency = other355.currency;
  currencySymbol = other355.currencySymbol;
  paymentType = other355.paymentType;
  createDate = other355.createDate;
  ownFlag = other355.ownFlag;
  eventType = other355.eventType;
  urlSchema = other355.urlSchema;
  downloadUrl = other355.downloadUrl;
  buddyMid = other355.buddyMid;
  publishSince = other355.publishSince;
  newFlag = other355.newFlag;
  missionFlag = other355.missionFlag;
  __isset = other355.__isset;
  return *this;
}
void Product::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Product(";
  out << "productId=" << to_string(productId);
  out << ", " << "packageId=" << to_string(packageId);
  out << ", " << "version=" << to_string(version);
  out << ", " << "authorName=" << to_string(authorName);
  out << ", " << "onSale=" << to_string(onSale);
  out << ", " << "validDays=" << to_string(validDays);
  out << ", " << "saleType=" << to_string(saleType);
  out << ", " << "copyright=" << to_string(copyright);
  out << ", " << "title=" << to_string(title);
  out << ", " << "descriptionText=" << to_string(descriptionText);
  out << ", " << "shopOrderId=" << to_string(shopOrderId);
  out << ", " << "fromMid=" << to_string(fromMid);
  out << ", " << "toMid=" << to_string(toMid);
  out << ", " << "validUntil=" << to_string(validUntil);
  out << ", " << "priceTier=" << to_string(priceTier);
  out << ", " << "price=" << to_string(price);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "currencySymbol=" << to_string(currencySymbol);
  out << ", " << "paymentType=" << to_string(paymentType);
  out << ", " << "createDate=" << to_string(createDate);
  out << ", " << "ownFlag=" << to_string(ownFlag);
  out << ", " << "eventType=" << to_string(eventType);
  out << ", " << "urlSchema=" << to_string(urlSchema);
  out << ", " << "downloadUrl=" << to_string(downloadUrl);
  out << ", " << "buddyMid=" << to_string(buddyMid);
  out << ", " << "publishSince=" << to_string(publishSince);
  out << ", " << "newFlag=" << to_string(newFlag);
  out << ", " << "missionFlag=" << to_string(missionFlag);
  out << ")";
}


ProductList::~ProductList() noexcept {
}


void ProductList::__set_hasNext(const bool val) {
  this->hasNext = val;
}

void ProductList::__set_bannerSequence(const int64_t val) {
  this->bannerSequence = val;
}

void ProductList::__set_bannerTargetType(const ProductBannerLinkType::type val) {
  this->bannerTargetType = val;
}

void ProductList::__set_bannerTargetPath(const std::string& val) {
  this->bannerTargetPath = val;
}

void ProductList::__set_productList(const std::vector<Product> & val) {
  this->productList = val;
}

void ProductList::__set_bannerLang(const std::string& val) {
  this->bannerLang = val;
}
std::ostream& operator<<(std::ostream& out, const ProductList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ProductList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasNext);
          this->__isset.hasNext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bannerSequence);
          this->__isset.bannerSequence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast356;
          xfer += iprot->readI32(ecast356);
          this->bannerTargetType = (ProductBannerLinkType::type)ecast356;
          this->__isset.bannerTargetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bannerTargetPath);
          this->__isset.bannerTargetPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->productList.clear();
            uint32_t _size357;
            ::apache::thrift::protocol::TType _etype360;
            xfer += iprot->readListBegin(_etype360, _size357);
            this->productList.resize(_size357);
            uint32_t _i361;
            for (_i361 = 0; _i361 < _size357; ++_i361)
            {
              xfer += this->productList[_i361].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.productList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bannerLang);
          this->__isset.bannerLang = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProductList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProductList");

  xfer += oprot->writeFieldBegin("hasNext", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->hasNext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bannerSequence", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->bannerSequence);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bannerTargetType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->bannerTargetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bannerTargetPath", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->bannerTargetPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productList", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->productList.size()));
    std::vector<Product> ::const_iterator _iter362;
    for (_iter362 = this->productList.begin(); _iter362 != this->productList.end(); ++_iter362)
    {
      xfer += (*_iter362).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bannerLang", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->bannerLang);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProductList &a, ProductList &b) {
  using ::std::swap;
  swap(a.hasNext, b.hasNext);
  swap(a.bannerSequence, b.bannerSequence);
  swap(a.bannerTargetType, b.bannerTargetType);
  swap(a.bannerTargetPath, b.bannerTargetPath);
  swap(a.productList, b.productList);
  swap(a.bannerLang, b.bannerLang);
  swap(a.__isset, b.__isset);
}

ProductList::ProductList(const ProductList& other363) {
  hasNext = other363.hasNext;
  bannerSequence = other363.bannerSequence;
  bannerTargetType = other363.bannerTargetType;
  bannerTargetPath = other363.bannerTargetPath;
  productList = other363.productList;
  bannerLang = other363.bannerLang;
  __isset = other363.__isset;
}
ProductList& ProductList::operator=(const ProductList& other364) {
  hasNext = other364.hasNext;
  bannerSequence = other364.bannerSequence;
  bannerTargetType = other364.bannerTargetType;
  bannerTargetPath = other364.bannerTargetPath;
  productList = other364.productList;
  bannerLang = other364.bannerLang;
  __isset = other364.__isset;
  return *this;
}
void ProductList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProductList(";
  out << "hasNext=" << to_string(hasNext);
  out << ", " << "bannerSequence=" << to_string(bannerSequence);
  out << ", " << "bannerTargetType=" << to_string(bannerTargetType);
  out << ", " << "bannerTargetPath=" << to_string(bannerTargetPath);
  out << ", " << "productList=" << to_string(productList);
  out << ", " << "bannerLang=" << to_string(bannerLang);
  out << ")";
}


ProductSimple::~ProductSimple() noexcept {
}


void ProductSimple::__set_productId(const std::string& val) {
  this->productId = val;
}

void ProductSimple::__set_packageId(const int64_t val) {
  this->packageId = val;
}

void ProductSimple::__set_version(const int32_t val) {
  this->version = val;
}

void ProductSimple::__set_onSale(const bool val) {
  this->onSale = val;
}

void ProductSimple::__set_validUntil(const int64_t val) {
  this->validUntil = val;
}
std::ostream& operator<<(std::ostream& out, const ProductSimple& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ProductSimple::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productId);
          this->__isset.productId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packageId);
          this->__isset.packageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->onSale);
          this->__isset.onSale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->validUntil);
          this->__isset.validUntil = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProductSimple::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProductSimple");

  xfer += oprot->writeFieldBegin("productId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->productId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->packageId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onSale", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->onSale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validUntil", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->validUntil);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProductSimple &a, ProductSimple &b) {
  using ::std::swap;
  swap(a.productId, b.productId);
  swap(a.packageId, b.packageId);
  swap(a.version, b.version);
  swap(a.onSale, b.onSale);
  swap(a.validUntil, b.validUntil);
  swap(a.__isset, b.__isset);
}

ProductSimple::ProductSimple(const ProductSimple& other365) {
  productId = other365.productId;
  packageId = other365.packageId;
  version = other365.version;
  onSale = other365.onSale;
  validUntil = other365.validUntil;
  __isset = other365.__isset;
}
ProductSimple& ProductSimple::operator=(const ProductSimple& other366) {
  productId = other366.productId;
  packageId = other366.packageId;
  version = other366.version;
  onSale = other366.onSale;
  validUntil = other366.validUntil;
  __isset = other366.__isset;
  return *this;
}
void ProductSimple::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProductSimple(";
  out << "productId=" << to_string(productId);
  out << ", " << "packageId=" << to_string(packageId);
  out << ", " << "version=" << to_string(version);
  out << ", " << "onSale=" << to_string(onSale);
  out << ", " << "validUntil=" << to_string(validUntil);
  out << ")";
}


ProductSimpleList::~ProductSimpleList() noexcept {
}


void ProductSimpleList::__set_hasNext(const bool val) {
  this->hasNext = val;
}

void ProductSimpleList::__set_reinvokeHour(const int32_t val) {
  this->reinvokeHour = val;
}

void ProductSimpleList::__set_lastVersionSeq(const int64_t val) {
  this->lastVersionSeq = val;
}

void ProductSimpleList::__set_productList(const std::vector<ProductSimple> & val) {
  this->productList = val;
}

void ProductSimpleList::__set_recentNewReleaseDate(const int64_t val) {
  this->recentNewReleaseDate = val;
}

void ProductSimpleList::__set_recentEventReleaseDate(const int64_t val) {
  this->recentEventReleaseDate = val;
}
std::ostream& operator<<(std::ostream& out, const ProductSimpleList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ProductSimpleList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasNext);
          this->__isset.hasNext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->reinvokeHour);
          this->__isset.reinvokeHour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastVersionSeq);
          this->__isset.lastVersionSeq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->productList.clear();
            uint32_t _size367;
            ::apache::thrift::protocol::TType _etype370;
            xfer += iprot->readListBegin(_etype370, _size367);
            this->productList.resize(_size367);
            uint32_t _i371;
            for (_i371 = 0; _i371 < _size367; ++_i371)
            {
              xfer += this->productList[_i371].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.productList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recentNewReleaseDate);
          this->__isset.recentNewReleaseDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recentEventReleaseDate);
          this->__isset.recentEventReleaseDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProductSimpleList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProductSimpleList");

  xfer += oprot->writeFieldBegin("hasNext", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->hasNext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reinvokeHour", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->reinvokeHour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastVersionSeq", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->lastVersionSeq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->productList.size()));
    std::vector<ProductSimple> ::const_iterator _iter372;
    for (_iter372 = this->productList.begin(); _iter372 != this->productList.end(); ++_iter372)
    {
      xfer += (*_iter372).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recentNewReleaseDate", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->recentNewReleaseDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recentEventReleaseDate", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->recentEventReleaseDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProductSimpleList &a, ProductSimpleList &b) {
  using ::std::swap;
  swap(a.hasNext, b.hasNext);
  swap(a.reinvokeHour, b.reinvokeHour);
  swap(a.lastVersionSeq, b.lastVersionSeq);
  swap(a.productList, b.productList);
  swap(a.recentNewReleaseDate, b.recentNewReleaseDate);
  swap(a.recentEventReleaseDate, b.recentEventReleaseDate);
  swap(a.__isset, b.__isset);
}

ProductSimpleList::ProductSimpleList(const ProductSimpleList& other373) {
  hasNext = other373.hasNext;
  reinvokeHour = other373.reinvokeHour;
  lastVersionSeq = other373.lastVersionSeq;
  productList = other373.productList;
  recentNewReleaseDate = other373.recentNewReleaseDate;
  recentEventReleaseDate = other373.recentEventReleaseDate;
  __isset = other373.__isset;
}
ProductSimpleList& ProductSimpleList::operator=(const ProductSimpleList& other374) {
  hasNext = other374.hasNext;
  reinvokeHour = other374.reinvokeHour;
  lastVersionSeq = other374.lastVersionSeq;
  productList = other374.productList;
  recentNewReleaseDate = other374.recentNewReleaseDate;
  recentEventReleaseDate = other374.recentEventReleaseDate;
  __isset = other374.__isset;
  return *this;
}
void ProductSimpleList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProductSimpleList(";
  out << "hasNext=" << to_string(hasNext);
  out << ", " << "reinvokeHour=" << to_string(reinvokeHour);
  out << ", " << "lastVersionSeq=" << to_string(lastVersionSeq);
  out << ", " << "productList=" << to_string(productList);
  out << ", " << "recentNewReleaseDate=" << to_string(recentNewReleaseDate);
  out << ", " << "recentEventReleaseDate=" << to_string(recentEventReleaseDate);
  out << ")";
}


Profile::~Profile() noexcept {
}


void Profile::__set_mid(const std::string& val) {
  this->mid = val;
}

void Profile::__set_userid(const std::string& val) {
  this->userid = val;
}

void Profile::__set_phone(const std::string& val) {
  this->phone = val;
}

void Profile::__set_email(const std::string& val) {
  this->email = val;
}

void Profile::__set_regionCode(const std::string& val) {
  this->regionCode = val;
}

void Profile::__set_displayName(const std::string& val) {
  this->displayName = val;
}

void Profile::__set_phoneticName(const std::string& val) {
  this->phoneticName = val;
}

void Profile::__set_pictureStatus(const std::string& val) {
  this->pictureStatus = val;
}

void Profile::__set_thumbnailUrl(const std::string& val) {
  this->thumbnailUrl = val;
}

void Profile::__set_statusMessage(const std::string& val) {
  this->statusMessage = val;
}

void Profile::__set_allowSearchByUserid(const bool val) {
  this->allowSearchByUserid = val;
}

void Profile::__set_allowSearchByEmail(const bool val) {
  this->allowSearchByEmail = val;
}

void Profile::__set_picturePath(const std::string& val) {
  this->picturePath = val;
}
std::ostream& operator<<(std::ostream& out, const Profile& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Profile::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userid);
          this->__isset.userid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->phone);
          this->__isset.phone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->regionCode);
          this->__isset.regionCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->phoneticName);
          this->__isset.phoneticName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pictureStatus);
          this->__isset.pictureStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thumbnailUrl);
          this->__isset.thumbnailUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statusMessage);
          this->__isset.statusMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->allowSearchByUserid);
          this->__isset.allowSearchByUserid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->allowSearchByEmail);
          this->__isset.allowSearchByEmail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->picturePath);
          this->__isset.picturePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Profile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Profile");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phone", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->phone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->email);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regionCode", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->regionCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->displayName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phoneticName", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->phoneticName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pictureStatus", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->pictureStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thumbnailUrl", ::apache::thrift::protocol::T_STRING, 23);
  xfer += oprot->writeString(this->thumbnailUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statusMessage", ::apache::thrift::protocol::T_STRING, 24);
  xfer += oprot->writeString(this->statusMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allowSearchByUserid", ::apache::thrift::protocol::T_BOOL, 31);
  xfer += oprot->writeBool(this->allowSearchByUserid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allowSearchByEmail", ::apache::thrift::protocol::T_BOOL, 32);
  xfer += oprot->writeBool(this->allowSearchByEmail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("picturePath", ::apache::thrift::protocol::T_STRING, 33);
  xfer += oprot->writeString(this->picturePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Profile &a, Profile &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.userid, b.userid);
  swap(a.phone, b.phone);
  swap(a.email, b.email);
  swap(a.regionCode, b.regionCode);
  swap(a.displayName, b.displayName);
  swap(a.phoneticName, b.phoneticName);
  swap(a.pictureStatus, b.pictureStatus);
  swap(a.thumbnailUrl, b.thumbnailUrl);
  swap(a.statusMessage, b.statusMessage);
  swap(a.allowSearchByUserid, b.allowSearchByUserid);
  swap(a.allowSearchByEmail, b.allowSearchByEmail);
  swap(a.picturePath, b.picturePath);
  swap(a.__isset, b.__isset);
}

Profile::Profile(const Profile& other375) {
  mid = other375.mid;
  userid = other375.userid;
  phone = other375.phone;
  email = other375.email;
  regionCode = other375.regionCode;
  displayName = other375.displayName;
  phoneticName = other375.phoneticName;
  pictureStatus = other375.pictureStatus;
  thumbnailUrl = other375.thumbnailUrl;
  statusMessage = other375.statusMessage;
  allowSearchByUserid = other375.allowSearchByUserid;
  allowSearchByEmail = other375.allowSearchByEmail;
  picturePath = other375.picturePath;
  __isset = other375.__isset;
}
Profile& Profile::operator=(const Profile& other376) {
  mid = other376.mid;
  userid = other376.userid;
  phone = other376.phone;
  email = other376.email;
  regionCode = other376.regionCode;
  displayName = other376.displayName;
  phoneticName = other376.phoneticName;
  pictureStatus = other376.pictureStatus;
  thumbnailUrl = other376.thumbnailUrl;
  statusMessage = other376.statusMessage;
  allowSearchByUserid = other376.allowSearchByUserid;
  allowSearchByEmail = other376.allowSearchByEmail;
  picturePath = other376.picturePath;
  __isset = other376.__isset;
  return *this;
}
void Profile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Profile(";
  out << "mid=" << to_string(mid);
  out << ", " << "userid=" << to_string(userid);
  out << ", " << "phone=" << to_string(phone);
  out << ", " << "email=" << to_string(email);
  out << ", " << "regionCode=" << to_string(regionCode);
  out << ", " << "displayName=" << to_string(displayName);
  out << ", " << "phoneticName=" << to_string(phoneticName);
  out << ", " << "pictureStatus=" << to_string(pictureStatus);
  out << ", " << "thumbnailUrl=" << to_string(thumbnailUrl);
  out << ", " << "statusMessage=" << to_string(statusMessage);
  out << ", " << "allowSearchByUserid=" << to_string(allowSearchByUserid);
  out << ", " << "allowSearchByEmail=" << to_string(allowSearchByEmail);
  out << ", " << "picturePath=" << to_string(picturePath);
  out << ")";
}


ProximityMatchCandidateResult::~ProximityMatchCandidateResult() noexcept {
}


void ProximityMatchCandidateResult::__set_users(const std::vector<Contact> & val) {
  this->users = val;
}

void ProximityMatchCandidateResult::__set_buddies(const std::vector<Contact> & val) {
  this->buddies = val;
}
std::ostream& operator<<(std::ostream& out, const ProximityMatchCandidateResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ProximityMatchCandidateResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->users.clear();
            uint32_t _size377;
            ::apache::thrift::protocol::TType _etype380;
            xfer += iprot->readListBegin(_etype380, _size377);
            this->users.resize(_size377);
            uint32_t _i381;
            for (_i381 = 0; _i381 < _size377; ++_i381)
            {
              xfer += this->users[_i381].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.users = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->buddies.clear();
            uint32_t _size382;
            ::apache::thrift::protocol::TType _etype385;
            xfer += iprot->readListBegin(_etype385, _size382);
            this->buddies.resize(_size382);
            uint32_t _i386;
            for (_i386 = 0; _i386 < _size382; ++_i386)
            {
              xfer += this->buddies[_i386].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.buddies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProximityMatchCandidateResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProximityMatchCandidateResult");

  xfer += oprot->writeFieldBegin("users", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->users.size()));
    std::vector<Contact> ::const_iterator _iter387;
    for (_iter387 = this->users.begin(); _iter387 != this->users.end(); ++_iter387)
    {
      xfer += (*_iter387).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buddies", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->buddies.size()));
    std::vector<Contact> ::const_iterator _iter388;
    for (_iter388 = this->buddies.begin(); _iter388 != this->buddies.end(); ++_iter388)
    {
      xfer += (*_iter388).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProximityMatchCandidateResult &a, ProximityMatchCandidateResult &b) {
  using ::std::swap;
  swap(a.users, b.users);
  swap(a.buddies, b.buddies);
  swap(a.__isset, b.__isset);
}

ProximityMatchCandidateResult::ProximityMatchCandidateResult(const ProximityMatchCandidateResult& other389) {
  users = other389.users;
  buddies = other389.buddies;
  __isset = other389.__isset;
}
ProximityMatchCandidateResult& ProximityMatchCandidateResult::operator=(const ProximityMatchCandidateResult& other390) {
  users = other390.users;
  buddies = other390.buddies;
  __isset = other390.__isset;
  return *this;
}
void ProximityMatchCandidateResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProximityMatchCandidateResult(";
  out << "users=" << to_string(users);
  out << ", " << "buddies=" << to_string(buddies);
  out << ")";
}


RegisterWithSnsIdResult::~RegisterWithSnsIdResult() noexcept {
}


void RegisterWithSnsIdResult::__set_authToken(const std::string& val) {
  this->authToken = val;
}

void RegisterWithSnsIdResult::__set_userCreated(const bool val) {
  this->userCreated = val;
}
std::ostream& operator<<(std::ostream& out, const RegisterWithSnsIdResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RegisterWithSnsIdResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->userCreated);
          this->__isset.userCreated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RegisterWithSnsIdResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RegisterWithSnsIdResult");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCreated", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->userCreated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RegisterWithSnsIdResult &a, RegisterWithSnsIdResult &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.userCreated, b.userCreated);
  swap(a.__isset, b.__isset);
}

RegisterWithSnsIdResult::RegisterWithSnsIdResult(const RegisterWithSnsIdResult& other391) {
  authToken = other391.authToken;
  userCreated = other391.userCreated;
  __isset = other391.__isset;
}
RegisterWithSnsIdResult& RegisterWithSnsIdResult::operator=(const RegisterWithSnsIdResult& other392) {
  authToken = other392.authToken;
  userCreated = other392.userCreated;
  __isset = other392.__isset;
  return *this;
}
void RegisterWithSnsIdResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RegisterWithSnsIdResult(";
  out << "authToken=" << to_string(authToken);
  out << ", " << "userCreated=" << to_string(userCreated);
  out << ")";
}


RequestTokenResponse::~RequestTokenResponse() noexcept {
}


void RequestTokenResponse::__set_requestToken(const std::string& val) {
  this->requestToken = val;
}

void RequestTokenResponse::__set_returnUrl(const std::string& val) {
  this->returnUrl = val;
}
std::ostream& operator<<(std::ostream& out, const RequestTokenResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RequestTokenResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requestToken);
          this->__isset.requestToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->returnUrl);
          this->__isset.returnUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestTokenResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestTokenResponse");

  xfer += oprot->writeFieldBegin("requestToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->requestToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("returnUrl", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->returnUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestTokenResponse &a, RequestTokenResponse &b) {
  using ::std::swap;
  swap(a.requestToken, b.requestToken);
  swap(a.returnUrl, b.returnUrl);
  swap(a.__isset, b.__isset);
}

RequestTokenResponse::RequestTokenResponse(const RequestTokenResponse& other393) {
  requestToken = other393.requestToken;
  returnUrl = other393.returnUrl;
  __isset = other393.__isset;
}
RequestTokenResponse& RequestTokenResponse::operator=(const RequestTokenResponse& other394) {
  requestToken = other394.requestToken;
  returnUrl = other394.returnUrl;
  __isset = other394.__isset;
  return *this;
}
void RequestTokenResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestTokenResponse(";
  out << "requestToken=" << to_string(requestToken);
  out << ", " << "returnUrl=" << to_string(returnUrl);
  out << ")";
}


Room::~Room() noexcept {
}


void Room::__set_mid(const std::string& val) {
  this->mid = val;
}

void Room::__set_createdTime(const int64_t val) {
  this->createdTime = val;
}

void Room::__set_contacts(const std::vector<Contact> & val) {
  this->contacts = val;
}

void Room::__set_notificationDisabled(const bool val) {
  this->notificationDisabled = val;
}
std::ostream& operator<<(std::ostream& out, const Room& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Room::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdTime);
          this->__isset.createdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contacts.clear();
            uint32_t _size395;
            ::apache::thrift::protocol::TType _etype398;
            xfer += iprot->readListBegin(_etype398, _size395);
            this->contacts.resize(_size395);
            uint32_t _i399;
            for (_i399 = 0; _i399 < _size395; ++_i399)
            {
              xfer += this->contacts[_i399].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.contacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationDisabled);
          this->__isset.notificationDisabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Room::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Room");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contacts", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->contacts.size()));
    std::vector<Contact> ::const_iterator _iter400;
    for (_iter400 = this->contacts.begin(); _iter400 != this->contacts.end(); ++_iter400)
    {
      xfer += (*_iter400).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationDisabled", ::apache::thrift::protocol::T_BOOL, 31);
  xfer += oprot->writeBool(this->notificationDisabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Room &a, Room &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.createdTime, b.createdTime);
  swap(a.contacts, b.contacts);
  swap(a.notificationDisabled, b.notificationDisabled);
  swap(a.__isset, b.__isset);
}

Room::Room(const Room& other401) {
  mid = other401.mid;
  createdTime = other401.createdTime;
  contacts = other401.contacts;
  notificationDisabled = other401.notificationDisabled;
  __isset = other401.__isset;
}
Room& Room::operator=(const Room& other402) {
  mid = other402.mid;
  createdTime = other402.createdTime;
  contacts = other402.contacts;
  notificationDisabled = other402.notificationDisabled;
  __isset = other402.__isset;
  return *this;
}
void Room::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Room(";
  out << "mid=" << to_string(mid);
  out << ", " << "createdTime=" << to_string(createdTime);
  out << ", " << "contacts=" << to_string(contacts);
  out << ", " << "notificationDisabled=" << to_string(notificationDisabled);
  out << ")";
}


RSAKey::~RSAKey() noexcept {
}


void RSAKey::__set_keynm(const std::string& val) {
  this->keynm = val;
}

void RSAKey::__set_nvalue(const std::string& val) {
  this->nvalue = val;
}

void RSAKey::__set_evalue(const std::string& val) {
  this->evalue = val;
}

void RSAKey::__set_sessionKey(const std::string& val) {
  this->sessionKey = val;
}
std::ostream& operator<<(std::ostream& out, const RSAKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RSAKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->keynm);
          this->__isset.keynm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nvalue);
          this->__isset.nvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->evalue);
          this->__isset.evalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionKey);
          this->__isset.sessionKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RSAKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RSAKey");

  xfer += oprot->writeFieldBegin("keynm", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->keynm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nvalue", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nvalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("evalue", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->evalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionKey", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->sessionKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RSAKey &a, RSAKey &b) {
  using ::std::swap;
  swap(a.keynm, b.keynm);
  swap(a.nvalue, b.nvalue);
  swap(a.evalue, b.evalue);
  swap(a.sessionKey, b.sessionKey);
  swap(a.__isset, b.__isset);
}

RSAKey::RSAKey(const RSAKey& other403) {
  keynm = other403.keynm;
  nvalue = other403.nvalue;
  evalue = other403.evalue;
  sessionKey = other403.sessionKey;
  __isset = other403.__isset;
}
RSAKey& RSAKey::operator=(const RSAKey& other404) {
  keynm = other404.keynm;
  nvalue = other404.nvalue;
  evalue = other404.evalue;
  sessionKey = other404.sessionKey;
  __isset = other404.__isset;
  return *this;
}
void RSAKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RSAKey(";
  out << "keynm=" << to_string(keynm);
  out << ", " << "nvalue=" << to_string(nvalue);
  out << ", " << "evalue=" << to_string(evalue);
  out << ", " << "sessionKey=" << to_string(sessionKey);
  out << ")";
}


SendBuddyMessageResult::~SendBuddyMessageResult() noexcept {
}


void SendBuddyMessageResult::__set_requestId(const std::string& val) {
  this->requestId = val;
}

void SendBuddyMessageResult::__set_state(const BuddyResultState::type val) {
  this->state = val;
}

void SendBuddyMessageResult::__set_messageId(const std::string& val) {
  this->messageId = val;
}

void SendBuddyMessageResult::__set_eventNo(const int32_t val) {
  this->eventNo = val;
}

void SendBuddyMessageResult::__set_receiverCount(const int64_t val) {
  this->receiverCount = val;
}

void SendBuddyMessageResult::__set_successCount(const int64_t val) {
  this->successCount = val;
}

void SendBuddyMessageResult::__set_failCount(const int64_t val) {
  this->failCount = val;
}

void SendBuddyMessageResult::__set_cancelCount(const int64_t val) {
  this->cancelCount = val;
}

void SendBuddyMessageResult::__set_blockCount(const int64_t val) {
  this->blockCount = val;
}

void SendBuddyMessageResult::__set_unregisterCount(const int64_t val) {
  this->unregisterCount = val;
}

void SendBuddyMessageResult::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void SendBuddyMessageResult::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const SendBuddyMessageResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendBuddyMessageResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requestId);
          this->__isset.requestId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast405;
          xfer += iprot->readI32(ecast405);
          this->state = (BuddyResultState::type)ecast405;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageId);
          this->__isset.messageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eventNo);
          this->__isset.eventNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->receiverCount);
          this->__isset.receiverCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->successCount);
          this->__isset.successCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->failCount);
          this->__isset.failCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cancelCount);
          this->__isset.cancelCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockCount);
          this->__isset.blockCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unregisterCount);
          this->__isset.unregisterCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SendBuddyMessageResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendBuddyMessageResult");

  xfer += oprot->writeFieldBegin("requestId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->requestId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->messageId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventNo", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->eventNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receiverCount", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->receiverCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("successCount", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->successCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failCount", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->failCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cancelCount", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64(this->cancelCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockCount", ::apache::thrift::protocol::T_I64, 15);
  xfer += oprot->writeI64(this->blockCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unregisterCount", ::apache::thrift::protocol::T_I64, 16);
  xfer += oprot->writeI64(this->unregisterCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 21);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendBuddyMessageResult &a, SendBuddyMessageResult &b) {
  using ::std::swap;
  swap(a.requestId, b.requestId);
  swap(a.state, b.state);
  swap(a.messageId, b.messageId);
  swap(a.eventNo, b.eventNo);
  swap(a.receiverCount, b.receiverCount);
  swap(a.successCount, b.successCount);
  swap(a.failCount, b.failCount);
  swap(a.cancelCount, b.cancelCount);
  swap(a.blockCount, b.blockCount);
  swap(a.unregisterCount, b.unregisterCount);
  swap(a.timestamp, b.timestamp);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

SendBuddyMessageResult::SendBuddyMessageResult(const SendBuddyMessageResult& other406) {
  requestId = other406.requestId;
  state = other406.state;
  messageId = other406.messageId;
  eventNo = other406.eventNo;
  receiverCount = other406.receiverCount;
  successCount = other406.successCount;
  failCount = other406.failCount;
  cancelCount = other406.cancelCount;
  blockCount = other406.blockCount;
  unregisterCount = other406.unregisterCount;
  timestamp = other406.timestamp;
  message = other406.message;
  __isset = other406.__isset;
}
SendBuddyMessageResult& SendBuddyMessageResult::operator=(const SendBuddyMessageResult& other407) {
  requestId = other407.requestId;
  state = other407.state;
  messageId = other407.messageId;
  eventNo = other407.eventNo;
  receiverCount = other407.receiverCount;
  successCount = other407.successCount;
  failCount = other407.failCount;
  cancelCount = other407.cancelCount;
  blockCount = other407.blockCount;
  unregisterCount = other407.unregisterCount;
  timestamp = other407.timestamp;
  message = other407.message;
  __isset = other407.__isset;
  return *this;
}
void SendBuddyMessageResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendBuddyMessageResult(";
  out << "requestId=" << to_string(requestId);
  out << ", " << "state=" << to_string(state);
  out << ", " << "messageId=" << to_string(messageId);
  out << ", " << "eventNo=" << to_string(eventNo);
  out << ", " << "receiverCount=" << to_string(receiverCount);
  out << ", " << "successCount=" << to_string(successCount);
  out << ", " << "failCount=" << to_string(failCount);
  out << ", " << "cancelCount=" << to_string(cancelCount);
  out << ", " << "blockCount=" << to_string(blockCount);
  out << ", " << "unregisterCount=" << to_string(unregisterCount);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


SetBuddyOnAirResult::~SetBuddyOnAirResult() noexcept {
}


void SetBuddyOnAirResult::__set_requestId(const std::string& val) {
  this->requestId = val;
}

void SetBuddyOnAirResult::__set_state(const BuddyResultState::type val) {
  this->state = val;
}

void SetBuddyOnAirResult::__set_eventNo(const int32_t val) {
  this->eventNo = val;
}

void SetBuddyOnAirResult::__set_receiverCount(const int64_t val) {
  this->receiverCount = val;
}

void SetBuddyOnAirResult::__set_successCount(const int64_t val) {
  this->successCount = val;
}

void SetBuddyOnAirResult::__set_failCount(const int64_t val) {
  this->failCount = val;
}

void SetBuddyOnAirResult::__set_cancelCount(const int64_t val) {
  this->cancelCount = val;
}

void SetBuddyOnAirResult::__set_unregisterCount(const int64_t val) {
  this->unregisterCount = val;
}

void SetBuddyOnAirResult::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void SetBuddyOnAirResult::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const SetBuddyOnAirResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetBuddyOnAirResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requestId);
          this->__isset.requestId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast408;
          xfer += iprot->readI32(ecast408);
          this->state = (BuddyResultState::type)ecast408;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eventNo);
          this->__isset.eventNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->receiverCount);
          this->__isset.receiverCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->successCount);
          this->__isset.successCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->failCount);
          this->__isset.failCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cancelCount);
          this->__isset.cancelCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unregisterCount);
          this->__isset.unregisterCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetBuddyOnAirResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetBuddyOnAirResult");

  xfer += oprot->writeFieldBegin("requestId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->requestId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventNo", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->eventNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receiverCount", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->receiverCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("successCount", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->successCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failCount", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->failCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cancelCount", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64(this->cancelCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unregisterCount", ::apache::thrift::protocol::T_I64, 15);
  xfer += oprot->writeI64(this->unregisterCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 21);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetBuddyOnAirResult &a, SetBuddyOnAirResult &b) {
  using ::std::swap;
  swap(a.requestId, b.requestId);
  swap(a.state, b.state);
  swap(a.eventNo, b.eventNo);
  swap(a.receiverCount, b.receiverCount);
  swap(a.successCount, b.successCount);
  swap(a.failCount, b.failCount);
  swap(a.cancelCount, b.cancelCount);
  swap(a.unregisterCount, b.unregisterCount);
  swap(a.timestamp, b.timestamp);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

SetBuddyOnAirResult::SetBuddyOnAirResult(const SetBuddyOnAirResult& other409) {
  requestId = other409.requestId;
  state = other409.state;
  eventNo = other409.eventNo;
  receiverCount = other409.receiverCount;
  successCount = other409.successCount;
  failCount = other409.failCount;
  cancelCount = other409.cancelCount;
  unregisterCount = other409.unregisterCount;
  timestamp = other409.timestamp;
  message = other409.message;
  __isset = other409.__isset;
}
SetBuddyOnAirResult& SetBuddyOnAirResult::operator=(const SetBuddyOnAirResult& other410) {
  requestId = other410.requestId;
  state = other410.state;
  eventNo = other410.eventNo;
  receiverCount = other410.receiverCount;
  successCount = other410.successCount;
  failCount = other410.failCount;
  cancelCount = other410.cancelCount;
  unregisterCount = other410.unregisterCount;
  timestamp = other410.timestamp;
  message = other410.message;
  __isset = other410.__isset;
  return *this;
}
void SetBuddyOnAirResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetBuddyOnAirResult(";
  out << "requestId=" << to_string(requestId);
  out << ", " << "state=" << to_string(state);
  out << ", " << "eventNo=" << to_string(eventNo);
  out << ", " << "receiverCount=" << to_string(receiverCount);
  out << ", " << "successCount=" << to_string(successCount);
  out << ", " << "failCount=" << to_string(failCount);
  out << ", " << "cancelCount=" << to_string(cancelCount);
  out << ", " << "unregisterCount=" << to_string(unregisterCount);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


Settings::~Settings() noexcept {
}


void Settings::__set_notificationEnable(const bool val) {
  this->notificationEnable = val;
}

void Settings::__set_notificationMuteExpiration(const int64_t val) {
  this->notificationMuteExpiration = val;
}

void Settings::__set_notificationNewMessage(const bool val) {
  this->notificationNewMessage = val;
}

void Settings::__set_notificationGroupInvitation(const bool val) {
  this->notificationGroupInvitation = val;
}

void Settings::__set_notificationShowMessage(const bool val) {
  this->notificationShowMessage = val;
}

void Settings::__set_notificationIncomingCall(const bool val) {
  this->notificationIncomingCall = val;
}

void Settings::__set_notificationSoundMessage(const std::string& val) {
  this->notificationSoundMessage = val;
}

void Settings::__set_notificationSoundGroup(const std::string& val) {
  this->notificationSoundGroup = val;
}

void Settings::__set_notificationDisabledWithSub(const bool val) {
  this->notificationDisabledWithSub = val;
}

void Settings::__set_privacySyncContacts(const bool val) {
  this->privacySyncContacts = val;
}

void Settings::__set_privacySearchByPhoneNumber(const bool val) {
  this->privacySearchByPhoneNumber = val;
}

void Settings::__set_privacySearchByUserid(const bool val) {
  this->privacySearchByUserid = val;
}

void Settings::__set_privacySearchByEmail(const bool val) {
  this->privacySearchByEmail = val;
}

void Settings::__set_privacyAllowSecondaryDeviceLogin(const bool val) {
  this->privacyAllowSecondaryDeviceLogin = val;
}

void Settings::__set_privacyProfileImagePostToMyhome(const bool val) {
  this->privacyProfileImagePostToMyhome = val;
}

void Settings::__set_privacyReceiveMessagesFromNotFriend(const bool val) {
  this->privacyReceiveMessagesFromNotFriend = val;
}

void Settings::__set_contactMyTicket(const std::string& val) {
  this->contactMyTicket = val;
}

void Settings::__set_identityProvider(const IdentityProvider::type val) {
  this->identityProvider = val;
}

void Settings::__set_identityIdentifier(const std::string& val) {
  this->identityIdentifier = val;
}

void Settings::__set_snsAccounts(const std::map<SnsIdType::type, std::string> & val) {
  this->snsAccounts = val;
}

void Settings::__set_phoneRegistration(const bool val) {
  this->phoneRegistration = val;
}

void Settings::__set_emailConfirmationStatus(const EmailConfirmationStatus::type val) {
  this->emailConfirmationStatus = val;
}

void Settings::__set_preferenceLocale(const std::string& val) {
  this->preferenceLocale = val;
}

void Settings::__set_customModes(const std::map<CustomMode::type, std::string> & val) {
  this->customModes = val;
}
std::ostream& operator<<(std::ostream& out, const Settings& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Settings::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationEnable);
          this->__isset.notificationEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->notificationMuteExpiration);
          this->__isset.notificationMuteExpiration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationNewMessage);
          this->__isset.notificationNewMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationGroupInvitation);
          this->__isset.notificationGroupInvitation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationShowMessage);
          this->__isset.notificationShowMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationIncomingCall);
          this->__isset.notificationIncomingCall = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notificationSoundMessage);
          this->__isset.notificationSoundMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notificationSoundGroup);
          this->__isset.notificationSoundGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->notificationDisabledWithSub);
          this->__isset.notificationDisabledWithSub = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->privacySyncContacts);
          this->__isset.privacySyncContacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->privacySearchByPhoneNumber);
          this->__isset.privacySearchByPhoneNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->privacySearchByUserid);
          this->__isset.privacySearchByUserid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->privacySearchByEmail);
          this->__isset.privacySearchByEmail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->privacyAllowSecondaryDeviceLogin);
          this->__isset.privacyAllowSecondaryDeviceLogin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->privacyProfileImagePostToMyhome);
          this->__isset.privacyProfileImagePostToMyhome = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->privacyReceiveMessagesFromNotFriend);
          this->__isset.privacyReceiveMessagesFromNotFriend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->contactMyTicket);
          this->__isset.contactMyTicket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast411;
          xfer += iprot->readI32(ecast411);
          this->identityProvider = (IdentityProvider::type)ecast411;
          this->__isset.identityProvider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identityIdentifier);
          this->__isset.identityIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->snsAccounts.clear();
            uint32_t _size412;
            ::apache::thrift::protocol::TType _ktype413;
            ::apache::thrift::protocol::TType _vtype414;
            xfer += iprot->readMapBegin(_ktype413, _vtype414, _size412);
            uint32_t _i416;
            for (_i416 = 0; _i416 < _size412; ++_i416)
            {
              SnsIdType::type _key417;
              int32_t ecast419;
              xfer += iprot->readI32(ecast419);
              _key417 = (SnsIdType::type)ecast419;
              std::string& _val418 = this->snsAccounts[_key417];
              xfer += iprot->readString(_val418);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.snsAccounts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->phoneRegistration);
          this->__isset.phoneRegistration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 44:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast420;
          xfer += iprot->readI32(ecast420);
          this->emailConfirmationStatus = (EmailConfirmationStatus::type)ecast420;
          this->__isset.emailConfirmationStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->preferenceLocale);
          this->__isset.preferenceLocale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->customModes.clear();
            uint32_t _size421;
            ::apache::thrift::protocol::TType _ktype422;
            ::apache::thrift::protocol::TType _vtype423;
            xfer += iprot->readMapBegin(_ktype422, _vtype423, _size421);
            uint32_t _i425;
            for (_i425 = 0; _i425 < _size421; ++_i425)
            {
              CustomMode::type _key426;
              int32_t ecast428;
              xfer += iprot->readI32(ecast428);
              _key426 = (CustomMode::type)ecast428;
              std::string& _val427 = this->customModes[_key426];
              xfer += iprot->readString(_val427);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.customModes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Settings::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Settings");

  xfer += oprot->writeFieldBegin("notificationEnable", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->notificationEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationMuteExpiration", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->notificationMuteExpiration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationNewMessage", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->notificationNewMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationGroupInvitation", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->notificationGroupInvitation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationShowMessage", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->notificationShowMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationIncomingCall", ::apache::thrift::protocol::T_BOOL, 15);
  xfer += oprot->writeBool(this->notificationIncomingCall);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationSoundMessage", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->notificationSoundMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationSoundGroup", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->notificationSoundGroup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notificationDisabledWithSub", ::apache::thrift::protocol::T_BOOL, 18);
  xfer += oprot->writeBool(this->notificationDisabledWithSub);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privacySyncContacts", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->privacySyncContacts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privacySearchByPhoneNumber", ::apache::thrift::protocol::T_BOOL, 21);
  xfer += oprot->writeBool(this->privacySearchByPhoneNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privacySearchByUserid", ::apache::thrift::protocol::T_BOOL, 22);
  xfer += oprot->writeBool(this->privacySearchByUserid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privacySearchByEmail", ::apache::thrift::protocol::T_BOOL, 23);
  xfer += oprot->writeBool(this->privacySearchByEmail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privacyAllowSecondaryDeviceLogin", ::apache::thrift::protocol::T_BOOL, 24);
  xfer += oprot->writeBool(this->privacyAllowSecondaryDeviceLogin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privacyProfileImagePostToMyhome", ::apache::thrift::protocol::T_BOOL, 25);
  xfer += oprot->writeBool(this->privacyProfileImagePostToMyhome);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privacyReceiveMessagesFromNotFriend", ::apache::thrift::protocol::T_BOOL, 26);
  xfer += oprot->writeBool(this->privacyReceiveMessagesFromNotFriend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contactMyTicket", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->contactMyTicket);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identityProvider", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32((int32_t)this->identityProvider);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identityIdentifier", ::apache::thrift::protocol::T_STRING, 41);
  xfer += oprot->writeString(this->identityIdentifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snsAccounts", ::apache::thrift::protocol::T_MAP, 42);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->snsAccounts.size()));
    std::map<SnsIdType::type, std::string> ::const_iterator _iter429;
    for (_iter429 = this->snsAccounts.begin(); _iter429 != this->snsAccounts.end(); ++_iter429)
    {
      xfer += oprot->writeI32((int32_t)_iter429->first);
      xfer += oprot->writeString(_iter429->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phoneRegistration", ::apache::thrift::protocol::T_BOOL, 43);
  xfer += oprot->writeBool(this->phoneRegistration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("emailConfirmationStatus", ::apache::thrift::protocol::T_I32, 44);
  xfer += oprot->writeI32((int32_t)this->emailConfirmationStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("preferenceLocale", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->preferenceLocale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("customModes", ::apache::thrift::protocol::T_MAP, 60);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->customModes.size()));
    std::map<CustomMode::type, std::string> ::const_iterator _iter430;
    for (_iter430 = this->customModes.begin(); _iter430 != this->customModes.end(); ++_iter430)
    {
      xfer += oprot->writeI32((int32_t)_iter430->first);
      xfer += oprot->writeString(_iter430->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Settings &a, Settings &b) {
  using ::std::swap;
  swap(a.notificationEnable, b.notificationEnable);
  swap(a.notificationMuteExpiration, b.notificationMuteExpiration);
  swap(a.notificationNewMessage, b.notificationNewMessage);
  swap(a.notificationGroupInvitation, b.notificationGroupInvitation);
  swap(a.notificationShowMessage, b.notificationShowMessage);
  swap(a.notificationIncomingCall, b.notificationIncomingCall);
  swap(a.notificationSoundMessage, b.notificationSoundMessage);
  swap(a.notificationSoundGroup, b.notificationSoundGroup);
  swap(a.notificationDisabledWithSub, b.notificationDisabledWithSub);
  swap(a.privacySyncContacts, b.privacySyncContacts);
  swap(a.privacySearchByPhoneNumber, b.privacySearchByPhoneNumber);
  swap(a.privacySearchByUserid, b.privacySearchByUserid);
  swap(a.privacySearchByEmail, b.privacySearchByEmail);
  swap(a.privacyAllowSecondaryDeviceLogin, b.privacyAllowSecondaryDeviceLogin);
  swap(a.privacyProfileImagePostToMyhome, b.privacyProfileImagePostToMyhome);
  swap(a.privacyReceiveMessagesFromNotFriend, b.privacyReceiveMessagesFromNotFriend);
  swap(a.contactMyTicket, b.contactMyTicket);
  swap(a.identityProvider, b.identityProvider);
  swap(a.identityIdentifier, b.identityIdentifier);
  swap(a.snsAccounts, b.snsAccounts);
  swap(a.phoneRegistration, b.phoneRegistration);
  swap(a.emailConfirmationStatus, b.emailConfirmationStatus);
  swap(a.preferenceLocale, b.preferenceLocale);
  swap(a.customModes, b.customModes);
  swap(a.__isset, b.__isset);
}

Settings::Settings(const Settings& other431) {
  notificationEnable = other431.notificationEnable;
  notificationMuteExpiration = other431.notificationMuteExpiration;
  notificationNewMessage = other431.notificationNewMessage;
  notificationGroupInvitation = other431.notificationGroupInvitation;
  notificationShowMessage = other431.notificationShowMessage;
  notificationIncomingCall = other431.notificationIncomingCall;
  notificationSoundMessage = other431.notificationSoundMessage;
  notificationSoundGroup = other431.notificationSoundGroup;
  notificationDisabledWithSub = other431.notificationDisabledWithSub;
  privacySyncContacts = other431.privacySyncContacts;
  privacySearchByPhoneNumber = other431.privacySearchByPhoneNumber;
  privacySearchByUserid = other431.privacySearchByUserid;
  privacySearchByEmail = other431.privacySearchByEmail;
  privacyAllowSecondaryDeviceLogin = other431.privacyAllowSecondaryDeviceLogin;
  privacyProfileImagePostToMyhome = other431.privacyProfileImagePostToMyhome;
  privacyReceiveMessagesFromNotFriend = other431.privacyReceiveMessagesFromNotFriend;
  contactMyTicket = other431.contactMyTicket;
  identityProvider = other431.identityProvider;
  identityIdentifier = other431.identityIdentifier;
  snsAccounts = other431.snsAccounts;
  phoneRegistration = other431.phoneRegistration;
  emailConfirmationStatus = other431.emailConfirmationStatus;
  preferenceLocale = other431.preferenceLocale;
  customModes = other431.customModes;
  __isset = other431.__isset;
}
Settings& Settings::operator=(const Settings& other432) {
  notificationEnable = other432.notificationEnable;
  notificationMuteExpiration = other432.notificationMuteExpiration;
  notificationNewMessage = other432.notificationNewMessage;
  notificationGroupInvitation = other432.notificationGroupInvitation;
  notificationShowMessage = other432.notificationShowMessage;
  notificationIncomingCall = other432.notificationIncomingCall;
  notificationSoundMessage = other432.notificationSoundMessage;
  notificationSoundGroup = other432.notificationSoundGroup;
  notificationDisabledWithSub = other432.notificationDisabledWithSub;
  privacySyncContacts = other432.privacySyncContacts;
  privacySearchByPhoneNumber = other432.privacySearchByPhoneNumber;
  privacySearchByUserid = other432.privacySearchByUserid;
  privacySearchByEmail = other432.privacySearchByEmail;
  privacyAllowSecondaryDeviceLogin = other432.privacyAllowSecondaryDeviceLogin;
  privacyProfileImagePostToMyhome = other432.privacyProfileImagePostToMyhome;
  privacyReceiveMessagesFromNotFriend = other432.privacyReceiveMessagesFromNotFriend;
  contactMyTicket = other432.contactMyTicket;
  identityProvider = other432.identityProvider;
  identityIdentifier = other432.identityIdentifier;
  snsAccounts = other432.snsAccounts;
  phoneRegistration = other432.phoneRegistration;
  emailConfirmationStatus = other432.emailConfirmationStatus;
  preferenceLocale = other432.preferenceLocale;
  customModes = other432.customModes;
  __isset = other432.__isset;
  return *this;
}
void Settings::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Settings(";
  out << "notificationEnable=" << to_string(notificationEnable);
  out << ", " << "notificationMuteExpiration=" << to_string(notificationMuteExpiration);
  out << ", " << "notificationNewMessage=" << to_string(notificationNewMessage);
  out << ", " << "notificationGroupInvitation=" << to_string(notificationGroupInvitation);
  out << ", " << "notificationShowMessage=" << to_string(notificationShowMessage);
  out << ", " << "notificationIncomingCall=" << to_string(notificationIncomingCall);
  out << ", " << "notificationSoundMessage=" << to_string(notificationSoundMessage);
  out << ", " << "notificationSoundGroup=" << to_string(notificationSoundGroup);
  out << ", " << "notificationDisabledWithSub=" << to_string(notificationDisabledWithSub);
  out << ", " << "privacySyncContacts=" << to_string(privacySyncContacts);
  out << ", " << "privacySearchByPhoneNumber=" << to_string(privacySearchByPhoneNumber);
  out << ", " << "privacySearchByUserid=" << to_string(privacySearchByUserid);
  out << ", " << "privacySearchByEmail=" << to_string(privacySearchByEmail);
  out << ", " << "privacyAllowSecondaryDeviceLogin=" << to_string(privacyAllowSecondaryDeviceLogin);
  out << ", " << "privacyProfileImagePostToMyhome=" << to_string(privacyProfileImagePostToMyhome);
  out << ", " << "privacyReceiveMessagesFromNotFriend=" << to_string(privacyReceiveMessagesFromNotFriend);
  out << ", " << "contactMyTicket=" << to_string(contactMyTicket);
  out << ", " << "identityProvider=" << to_string(identityProvider);
  out << ", " << "identityIdentifier=" << to_string(identityIdentifier);
  out << ", " << "snsAccounts=" << to_string(snsAccounts);
  out << ", " << "phoneRegistration=" << to_string(phoneRegistration);
  out << ", " << "emailConfirmationStatus=" << to_string(emailConfirmationStatus);
  out << ", " << "preferenceLocale=" << to_string(preferenceLocale);
  out << ", " << "customModes=" << to_string(customModes);
  out << ")";
}


SimpleChannelClient::~SimpleChannelClient() noexcept {
}


void SimpleChannelClient::__set_applicationType(const std::string& val) {
  this->applicationType = val;
}

void SimpleChannelClient::__set_applicationVersion(const std::string& val) {
  this->applicationVersion = val;
}

void SimpleChannelClient::__set_locale(const std::string& val) {
  this->locale = val;
}
std::ostream& operator<<(std::ostream& out, const SimpleChannelClient& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SimpleChannelClient::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationType);
          this->__isset.applicationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationVersion);
          this->__isset.applicationVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locale);
          this->__isset.locale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimpleChannelClient::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SimpleChannelClient");

  xfer += oprot->writeFieldBegin("applicationType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->applicationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationVersion", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->applicationVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("locale", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->locale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimpleChannelClient &a, SimpleChannelClient &b) {
  using ::std::swap;
  swap(a.applicationType, b.applicationType);
  swap(a.applicationVersion, b.applicationVersion);
  swap(a.locale, b.locale);
  swap(a.__isset, b.__isset);
}

SimpleChannelClient::SimpleChannelClient(const SimpleChannelClient& other433) {
  applicationType = other433.applicationType;
  applicationVersion = other433.applicationVersion;
  locale = other433.locale;
  __isset = other433.__isset;
}
SimpleChannelClient& SimpleChannelClient::operator=(const SimpleChannelClient& other434) {
  applicationType = other434.applicationType;
  applicationVersion = other434.applicationVersion;
  locale = other434.locale;
  __isset = other434.__isset;
  return *this;
}
void SimpleChannelClient::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SimpleChannelClient(";
  out << "applicationType=" << to_string(applicationType);
  out << ", " << "applicationVersion=" << to_string(applicationVersion);
  out << ", " << "locale=" << to_string(locale);
  out << ")";
}


SimpleChannelContact::~SimpleChannelContact() noexcept {
}


void SimpleChannelContact::__set_mid(const std::string& val) {
  this->mid = val;
}

void SimpleChannelContact::__set_displayName(const std::string& val) {
  this->displayName = val;
}

void SimpleChannelContact::__set_pictureStatus(const std::string& val) {
  this->pictureStatus = val;
}

void SimpleChannelContact::__set_picturePath(const std::string& val) {
  this->picturePath = val;
}

void SimpleChannelContact::__set_statusMessage(const std::string& val) {
  this->statusMessage = val;
}
std::ostream& operator<<(std::ostream& out, const SimpleChannelContact& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SimpleChannelContact::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->displayName);
          this->__isset.displayName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pictureStatus);
          this->__isset.pictureStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->picturePath);
          this->__isset.picturePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statusMessage);
          this->__isset.statusMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimpleChannelContact::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SimpleChannelContact");

  xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("displayName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->displayName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pictureStatus", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->pictureStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("picturePath", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->picturePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statusMessage", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->statusMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimpleChannelContact &a, SimpleChannelContact &b) {
  using ::std::swap;
  swap(a.mid, b.mid);
  swap(a.displayName, b.displayName);
  swap(a.pictureStatus, b.pictureStatus);
  swap(a.picturePath, b.picturePath);
  swap(a.statusMessage, b.statusMessage);
  swap(a.__isset, b.__isset);
}

SimpleChannelContact::SimpleChannelContact(const SimpleChannelContact& other435) {
  mid = other435.mid;
  displayName = other435.displayName;
  pictureStatus = other435.pictureStatus;
  picturePath = other435.picturePath;
  statusMessage = other435.statusMessage;
  __isset = other435.__isset;
}
SimpleChannelContact& SimpleChannelContact::operator=(const SimpleChannelContact& other436) {
  mid = other436.mid;
  displayName = other436.displayName;
  pictureStatus = other436.pictureStatus;
  picturePath = other436.picturePath;
  statusMessage = other436.statusMessage;
  __isset = other436.__isset;
  return *this;
}
void SimpleChannelContact::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SimpleChannelContact(";
  out << "mid=" << to_string(mid);
  out << ", " << "displayName=" << to_string(displayName);
  out << ", " << "pictureStatus=" << to_string(pictureStatus);
  out << ", " << "picturePath=" << to_string(picturePath);
  out << ", " << "statusMessage=" << to_string(statusMessage);
  out << ")";
}


SnsFriend::~SnsFriend() noexcept {
}


void SnsFriend::__set_snsUserId(const std::string& val) {
  this->snsUserId = val;
}

void SnsFriend::__set_snsUserName(const std::string& val) {
  this->snsUserName = val;
}

void SnsFriend::__set_snsIdType(const SnsIdType::type val) {
  this->snsIdType = val;
}
std::ostream& operator<<(std::ostream& out, const SnsFriend& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnsFriend::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snsUserId);
          this->__isset.snsUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snsUserName);
          this->__isset.snsUserName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast437;
          xfer += iprot->readI32(ecast437);
          this->snsIdType = (SnsIdType::type)ecast437;
          this->__isset.snsIdType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnsFriend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnsFriend");

  xfer += oprot->writeFieldBegin("snsUserId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->snsUserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snsUserName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snsUserName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snsIdType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->snsIdType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnsFriend &a, SnsFriend &b) {
  using ::std::swap;
  swap(a.snsUserId, b.snsUserId);
  swap(a.snsUserName, b.snsUserName);
  swap(a.snsIdType, b.snsIdType);
  swap(a.__isset, b.__isset);
}

SnsFriend::SnsFriend(const SnsFriend& other438) {
  snsUserId = other438.snsUserId;
  snsUserName = other438.snsUserName;
  snsIdType = other438.snsIdType;
  __isset = other438.__isset;
}
SnsFriend& SnsFriend::operator=(const SnsFriend& other439) {
  snsUserId = other439.snsUserId;
  snsUserName = other439.snsUserName;
  snsIdType = other439.snsIdType;
  __isset = other439.__isset;
  return *this;
}
void SnsFriend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnsFriend(";
  out << "snsUserId=" << to_string(snsUserId);
  out << ", " << "snsUserName=" << to_string(snsUserName);
  out << ", " << "snsIdType=" << to_string(snsIdType);
  out << ")";
}


SnsFriendContactRegistration::~SnsFriendContactRegistration() noexcept {
}


void SnsFriendContactRegistration::__set_contact(const Contact& val) {
  this->contact = val;
}

void SnsFriendContactRegistration::__set_snsIdType(const SnsIdType::type val) {
  this->snsIdType = val;
}

void SnsFriendContactRegistration::__set_snsUserId(const std::string& val) {
  this->snsUserId = val;
}
std::ostream& operator<<(std::ostream& out, const SnsFriendContactRegistration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnsFriendContactRegistration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contact.read(iprot);
          this->__isset.contact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast440;
          xfer += iprot->readI32(ecast440);
          this->snsIdType = (SnsIdType::type)ecast440;
          this->__isset.snsIdType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snsUserId);
          this->__isset.snsUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnsFriendContactRegistration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnsFriendContactRegistration");

  xfer += oprot->writeFieldBegin("contact", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->contact.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snsIdType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->snsIdType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snsUserId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snsUserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnsFriendContactRegistration &a, SnsFriendContactRegistration &b) {
  using ::std::swap;
  swap(a.contact, b.contact);
  swap(a.snsIdType, b.snsIdType);
  swap(a.snsUserId, b.snsUserId);
  swap(a.__isset, b.__isset);
}

SnsFriendContactRegistration::SnsFriendContactRegistration(const SnsFriendContactRegistration& other441) {
  contact = other441.contact;
  snsIdType = other441.snsIdType;
  snsUserId = other441.snsUserId;
  __isset = other441.__isset;
}
SnsFriendContactRegistration& SnsFriendContactRegistration::operator=(const SnsFriendContactRegistration& other442) {
  contact = other442.contact;
  snsIdType = other442.snsIdType;
  snsUserId = other442.snsUserId;
  __isset = other442.__isset;
  return *this;
}
void SnsFriendContactRegistration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnsFriendContactRegistration(";
  out << "contact=" << to_string(contact);
  out << ", " << "snsIdType=" << to_string(snsIdType);
  out << ", " << "snsUserId=" << to_string(snsUserId);
  out << ")";
}


SnsFriendModification::~SnsFriendModification() noexcept {
}


void SnsFriendModification::__set_type(const ModificationType::type val) {
  this->type = val;
}

void SnsFriendModification::__set_snsFriend(const SnsFriend& val) {
  this->snsFriend = val;
}
std::ostream& operator<<(std::ostream& out, const SnsFriendModification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnsFriendModification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast443;
          xfer += iprot->readI32(ecast443);
          this->type = (ModificationType::type)ecast443;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->snsFriend.read(iprot);
          this->__isset.snsFriend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnsFriendModification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnsFriendModification");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snsFriend", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->snsFriend.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnsFriendModification &a, SnsFriendModification &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.snsFriend, b.snsFriend);
  swap(a.__isset, b.__isset);
}

SnsFriendModification::SnsFriendModification(const SnsFriendModification& other444) {
  type = other444.type;
  snsFriend = other444.snsFriend;
  __isset = other444.__isset;
}
SnsFriendModification& SnsFriendModification::operator=(const SnsFriendModification& other445) {
  type = other445.type;
  snsFriend = other445.snsFriend;
  __isset = other445.__isset;
  return *this;
}
void SnsFriendModification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnsFriendModification(";
  out << "type=" << to_string(type);
  out << ", " << "snsFriend=" << to_string(snsFriend);
  out << ")";
}


SnsFriends::~SnsFriends() noexcept {
}


void SnsFriends::__set_snsFriends(const std::vector<SnsFriend> & val) {
  this->snsFriends = val;
}

void SnsFriends::__set_hasMore(const bool val) {
  this->hasMore = val;
}
std::ostream& operator<<(std::ostream& out, const SnsFriends& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnsFriends::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snsFriends.clear();
            uint32_t _size446;
            ::apache::thrift::protocol::TType _etype449;
            xfer += iprot->readListBegin(_etype449, _size446);
            this->snsFriends.resize(_size446);
            uint32_t _i450;
            for (_i450 = 0; _i450 < _size446; ++_i450)
            {
              xfer += this->snsFriends[_i450].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snsFriends = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasMore);
          this->__isset.hasMore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnsFriends::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnsFriends");

  xfer += oprot->writeFieldBegin("snsFriends", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snsFriends.size()));
    std::vector<SnsFriend> ::const_iterator _iter451;
    for (_iter451 = this->snsFriends.begin(); _iter451 != this->snsFriends.end(); ++_iter451)
    {
      xfer += (*_iter451).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasMore", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasMore);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnsFriends &a, SnsFriends &b) {
  using ::std::swap;
  swap(a.snsFriends, b.snsFriends);
  swap(a.hasMore, b.hasMore);
  swap(a.__isset, b.__isset);
}

SnsFriends::SnsFriends(const SnsFriends& other452) {
  snsFriends = other452.snsFriends;
  hasMore = other452.hasMore;
  __isset = other452.__isset;
}
SnsFriends& SnsFriends::operator=(const SnsFriends& other453) {
  snsFriends = other453.snsFriends;
  hasMore = other453.hasMore;
  __isset = other453.__isset;
  return *this;
}
void SnsFriends::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnsFriends(";
  out << "snsFriends=" << to_string(snsFriends);
  out << ", " << "hasMore=" << to_string(hasMore);
  out << ")";
}


SnsIdUserStatus::~SnsIdUserStatus() noexcept {
}


void SnsIdUserStatus::__set_userExisting(const bool val) {
  this->userExisting = val;
}

void SnsIdUserStatus::__set_phoneNumberRegistered(const bool val) {
  this->phoneNumberRegistered = val;
}

void SnsIdUserStatus::__set_sameDevice(const bool val) {
  this->sameDevice = val;
}
std::ostream& operator<<(std::ostream& out, const SnsIdUserStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnsIdUserStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->userExisting);
          this->__isset.userExisting = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->phoneNumberRegistered);
          this->__isset.phoneNumberRegistered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sameDevice);
          this->__isset.sameDevice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnsIdUserStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnsIdUserStatus");

  xfer += oprot->writeFieldBegin("userExisting", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->userExisting);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phoneNumberRegistered", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->phoneNumberRegistered);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sameDevice", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->sameDevice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnsIdUserStatus &a, SnsIdUserStatus &b) {
  using ::std::swap;
  swap(a.userExisting, b.userExisting);
  swap(a.phoneNumberRegistered, b.phoneNumberRegistered);
  swap(a.sameDevice, b.sameDevice);
  swap(a.__isset, b.__isset);
}

SnsIdUserStatus::SnsIdUserStatus(const SnsIdUserStatus& other454) {
  userExisting = other454.userExisting;
  phoneNumberRegistered = other454.phoneNumberRegistered;
  sameDevice = other454.sameDevice;
  __isset = other454.__isset;
}
SnsIdUserStatus& SnsIdUserStatus::operator=(const SnsIdUserStatus& other455) {
  userExisting = other455.userExisting;
  phoneNumberRegistered = other455.phoneNumberRegistered;
  sameDevice = other455.sameDevice;
  __isset = other455.__isset;
  return *this;
}
void SnsIdUserStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnsIdUserStatus(";
  out << "userExisting=" << to_string(userExisting);
  out << ", " << "phoneNumberRegistered=" << to_string(phoneNumberRegistered);
  out << ", " << "sameDevice=" << to_string(sameDevice);
  out << ")";
}


SnsProfile::~SnsProfile() noexcept {
}


void SnsProfile::__set_snsUserId(const std::string& val) {
  this->snsUserId = val;
}

void SnsProfile::__set_snsUserName(const std::string& val) {
  this->snsUserName = val;
}

void SnsProfile::__set_email(const std::string& val) {
  this->email = val;
}

void SnsProfile::__set_thumbnailUrl(const std::string& val) {
  this->thumbnailUrl = val;
}
std::ostream& operator<<(std::ostream& out, const SnsProfile& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnsProfile::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snsUserId);
          this->__isset.snsUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snsUserName);
          this->__isset.snsUserName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thumbnailUrl);
          this->__isset.thumbnailUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnsProfile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnsProfile");

  xfer += oprot->writeFieldBegin("snsUserId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->snsUserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snsUserName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snsUserName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->email);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thumbnailUrl", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->thumbnailUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnsProfile &a, SnsProfile &b) {
  using ::std::swap;
  swap(a.snsUserId, b.snsUserId);
  swap(a.snsUserName, b.snsUserName);
  swap(a.email, b.email);
  swap(a.thumbnailUrl, b.thumbnailUrl);
  swap(a.__isset, b.__isset);
}

SnsProfile::SnsProfile(const SnsProfile& other456) {
  snsUserId = other456.snsUserId;
  snsUserName = other456.snsUserName;
  email = other456.email;
  thumbnailUrl = other456.thumbnailUrl;
  __isset = other456.__isset;
}
SnsProfile& SnsProfile::operator=(const SnsProfile& other457) {
  snsUserId = other457.snsUserId;
  snsUserName = other457.snsUserName;
  email = other457.email;
  thumbnailUrl = other457.thumbnailUrl;
  __isset = other457.__isset;
  return *this;
}
void SnsProfile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnsProfile(";
  out << "snsUserId=" << to_string(snsUserId);
  out << ", " << "snsUserName=" << to_string(snsUserName);
  out << ", " << "email=" << to_string(email);
  out << ", " << "thumbnailUrl=" << to_string(thumbnailUrl);
  out << ")";
}


SystemConfiguration::~SystemConfiguration() noexcept {
}


void SystemConfiguration::__set_endpoint(const std::string& val) {
  this->endpoint = val;
}

void SystemConfiguration::__set_endpointSsl(const std::string& val) {
  this->endpointSsl = val;
}

void SystemConfiguration::__set_updateUrl(const std::string& val) {
  this->updateUrl = val;
}

void SystemConfiguration::__set_c2dmAccount(const std::string& val) {
  this->c2dmAccount = val;
}

void SystemConfiguration::__set_nniServer(const std::string& val) {
  this->nniServer = val;
}
std::ostream& operator<<(std::ostream& out, const SystemConfiguration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SystemConfiguration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->endpoint);
          this->__isset.endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->endpointSsl);
          this->__isset.endpointSsl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updateUrl);
          this->__isset.updateUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c2dmAccount);
          this->__isset.c2dmAccount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nniServer);
          this->__isset.nniServer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SystemConfiguration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SystemConfiguration");

  xfer += oprot->writeFieldBegin("endpoint", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->endpoint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endpointSsl", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->endpointSsl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateUrl", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->updateUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c2dmAccount", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->c2dmAccount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nniServer", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->nniServer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SystemConfiguration &a, SystemConfiguration &b) {
  using ::std::swap;
  swap(a.endpoint, b.endpoint);
  swap(a.endpointSsl, b.endpointSsl);
  swap(a.updateUrl, b.updateUrl);
  swap(a.c2dmAccount, b.c2dmAccount);
  swap(a.nniServer, b.nniServer);
  swap(a.__isset, b.__isset);
}

SystemConfiguration::SystemConfiguration(const SystemConfiguration& other458) {
  endpoint = other458.endpoint;
  endpointSsl = other458.endpointSsl;
  updateUrl = other458.updateUrl;
  c2dmAccount = other458.c2dmAccount;
  nniServer = other458.nniServer;
  __isset = other458.__isset;
}
SystemConfiguration& SystemConfiguration::operator=(const SystemConfiguration& other459) {
  endpoint = other459.endpoint;
  endpointSsl = other459.endpointSsl;
  updateUrl = other459.updateUrl;
  c2dmAccount = other459.c2dmAccount;
  nniServer = other459.nniServer;
  __isset = other459.__isset;
  return *this;
}
void SystemConfiguration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SystemConfiguration(";
  out << "endpoint=" << to_string(endpoint);
  out << ", " << "endpointSsl=" << to_string(endpointSsl);
  out << ", " << "updateUrl=" << to_string(updateUrl);
  out << ", " << "c2dmAccount=" << to_string(c2dmAccount);
  out << ", " << "nniServer=" << to_string(nniServer);
  out << ")";
}


TalkException::~TalkException() noexcept {
}


void TalkException::__set_code(const ErrorCode::type val) {
  this->code = val;
}

void TalkException::__set_reason(const std::string& val) {
  this->reason = val;
}

void TalkException::__set_parameterMap(const std::map<std::string, std::string> & val) {
  this->parameterMap = val;
}
std::ostream& operator<<(std::ostream& out, const TalkException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TalkException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast460;
          xfer += iprot->readI32(ecast460);
          this->code = (ErrorCode::type)ecast460;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameterMap.clear();
            uint32_t _size461;
            ::apache::thrift::protocol::TType _ktype462;
            ::apache::thrift::protocol::TType _vtype463;
            xfer += iprot->readMapBegin(_ktype462, _vtype463, _size461);
            uint32_t _i465;
            for (_i465 = 0; _i465 < _size461; ++_i465)
            {
              std::string _key466;
              xfer += iprot->readString(_key466);
              std::string& _val467 = this->parameterMap[_key466];
              xfer += iprot->readString(_val467);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameterMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TalkException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TalkException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameterMap", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameterMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter468;
    for (_iter468 = this->parameterMap.begin(); _iter468 != this->parameterMap.end(); ++_iter468)
    {
      xfer += oprot->writeString(_iter468->first);
      xfer += oprot->writeString(_iter468->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TalkException &a, TalkException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.reason, b.reason);
  swap(a.parameterMap, b.parameterMap);
  swap(a.__isset, b.__isset);
}

TalkException::TalkException(const TalkException& other469) : TException() {
  code = other469.code;
  reason = other469.reason;
  parameterMap = other469.parameterMap;
  __isset = other469.__isset;
}
TalkException& TalkException::operator=(const TalkException& other470) {
  code = other470.code;
  reason = other470.reason;
  parameterMap = other470.parameterMap;
  __isset = other470.__isset;
  return *this;
}
void TalkException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TalkException(";
  out << "code=" << to_string(code);
  out << ", " << "reason=" << to_string(reason);
  out << ", " << "parameterMap=" << to_string(parameterMap);
  out << ")";
}

const char* TalkException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TalkException";
  }
}


Ticket::~Ticket() noexcept {
}


void Ticket::__set_id(const std::string& val) {
  this->id = val;
}

void Ticket::__set_expirationTime(const int64_t val) {
  this->expirationTime = val;
}

void Ticket::__set_maxUseCount(const int32_t val) {
  this->maxUseCount = val;
}
std::ostream& operator<<(std::ostream& out, const Ticket& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Ticket::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expirationTime);
          this->__isset.expirationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxUseCount);
          this->__isset.maxUseCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Ticket::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Ticket");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expirationTime", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->expirationTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxUseCount", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->maxUseCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Ticket &a, Ticket &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.expirationTime, b.expirationTime);
  swap(a.maxUseCount, b.maxUseCount);
  swap(a.__isset, b.__isset);
}

Ticket::Ticket(const Ticket& other471) {
  id = other471.id;
  expirationTime = other471.expirationTime;
  maxUseCount = other471.maxUseCount;
  __isset = other471.__isset;
}
Ticket& Ticket::operator=(const Ticket& other472) {
  id = other472.id;
  expirationTime = other472.expirationTime;
  maxUseCount = other472.maxUseCount;
  __isset = other472.__isset;
  return *this;
}
void Ticket::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Ticket(";
  out << "id=" << to_string(id);
  out << ", " << "expirationTime=" << to_string(expirationTime);
  out << ", " << "maxUseCount=" << to_string(maxUseCount);
  out << ")";
}


TMessageBox::~TMessageBox() noexcept {
}


void TMessageBox::__set_id(const std::string& val) {
  this->id = val;
}

void TMessageBox::__set_channelId(const std::string& val) {
  this->channelId = val;
}

void TMessageBox::__set_lastSeq(const int64_t val) {
  this->lastSeq = val;
}

void TMessageBox::__set_unreadCount(const int64_t val) {
  this->unreadCount = val;
}

void TMessageBox::__set_lastModifiedTime(const int64_t val) {
  this->lastModifiedTime = val;
}

void TMessageBox::__set_status(const int32_t val) {
  this->status = val;
}

void TMessageBox::__set_midType(const MIDType::type val) {
  this->midType = val;
}

void TMessageBox::__set_lastMessages(const std::vector<Message> & val) {
  this->lastMessages = val;
}
std::ostream& operator<<(std::ostream& out, const TMessageBox& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMessageBox::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channelId);
          this->__isset.channelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastSeq);
          this->__isset.lastSeq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unreadCount);
          this->__isset.unreadCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModifiedTime);
          this->__isset.lastModifiedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast473;
          xfer += iprot->readI32(ecast473);
          this->midType = (MIDType::type)ecast473;
          this->__isset.midType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lastMessages.clear();
            uint32_t _size474;
            ::apache::thrift::protocol::TType _etype477;
            xfer += iprot->readListBegin(_etype477, _size474);
            this->lastMessages.resize(_size474);
            uint32_t _i478;
            for (_i478 = 0; _i478 < _size474; ++_i478)
            {
              xfer += this->lastMessages[_i478].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lastMessages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMessageBox::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMessageBox");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channelId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->channelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastSeq", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->lastSeq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unreadCount", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->unreadCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastModifiedTime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->lastModifiedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("midType", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->midType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastMessages", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lastMessages.size()));
    std::vector<Message> ::const_iterator _iter479;
    for (_iter479 = this->lastMessages.begin(); _iter479 != this->lastMessages.end(); ++_iter479)
    {
      xfer += (*_iter479).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMessageBox &a, TMessageBox &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.channelId, b.channelId);
  swap(a.lastSeq, b.lastSeq);
  swap(a.unreadCount, b.unreadCount);
  swap(a.lastModifiedTime, b.lastModifiedTime);
  swap(a.status, b.status);
  swap(a.midType, b.midType);
  swap(a.lastMessages, b.lastMessages);
  swap(a.__isset, b.__isset);
}

TMessageBox::TMessageBox(const TMessageBox& other480) {
  id = other480.id;
  channelId = other480.channelId;
  lastSeq = other480.lastSeq;
  unreadCount = other480.unreadCount;
  lastModifiedTime = other480.lastModifiedTime;
  status = other480.status;
  midType = other480.midType;
  lastMessages = other480.lastMessages;
  __isset = other480.__isset;
}
TMessageBox& TMessageBox::operator=(const TMessageBox& other481) {
  id = other481.id;
  channelId = other481.channelId;
  lastSeq = other481.lastSeq;
  unreadCount = other481.unreadCount;
  lastModifiedTime = other481.lastModifiedTime;
  status = other481.status;
  midType = other481.midType;
  lastMessages = other481.lastMessages;
  __isset = other481.__isset;
  return *this;
}
void TMessageBox::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMessageBox(";
  out << "id=" << to_string(id);
  out << ", " << "channelId=" << to_string(channelId);
  out << ", " << "lastSeq=" << to_string(lastSeq);
  out << ", " << "unreadCount=" << to_string(unreadCount);
  out << ", " << "lastModifiedTime=" << to_string(lastModifiedTime);
  out << ", " << "status=" << to_string(status);
  out << ", " << "midType=" << to_string(midType);
  out << ", " << "lastMessages=" << to_string(lastMessages);
  out << ")";
}


TMessageBoxWrapUp::~TMessageBoxWrapUp() noexcept {
}


void TMessageBoxWrapUp::__set_messageBox(const TMessageBox& val) {
  this->messageBox = val;
}

void TMessageBoxWrapUp::__set_name(const std::string& val) {
  this->name = val;
}

void TMessageBoxWrapUp::__set_contacts(const std::vector<Contact> & val) {
  this->contacts = val;
}

void TMessageBoxWrapUp::__set_pictureRevision(const std::string& val) {
  this->pictureRevision = val;
}
std::ostream& operator<<(std::ostream& out, const TMessageBoxWrapUp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMessageBoxWrapUp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->messageBox.read(iprot);
          this->__isset.messageBox = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contacts.clear();
            uint32_t _size482;
            ::apache::thrift::protocol::TType _etype485;
            xfer += iprot->readListBegin(_etype485, _size482);
            this->contacts.resize(_size482);
            uint32_t _i486;
            for (_i486 = 0; _i486 < _size482; ++_i486)
            {
              xfer += this->contacts[_i486].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.contacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pictureRevision);
          this->__isset.pictureRevision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMessageBoxWrapUp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMessageBoxWrapUp");

  xfer += oprot->writeFieldBegin("messageBox", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->messageBox.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contacts", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->contacts.size()));
    std::vector<Contact> ::const_iterator _iter487;
    for (_iter487 = this->contacts.begin(); _iter487 != this->contacts.end(); ++_iter487)
    {
      xfer += (*_iter487).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pictureRevision", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->pictureRevision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMessageBoxWrapUp &a, TMessageBoxWrapUp &b) {
  using ::std::swap;
  swap(a.messageBox, b.messageBox);
  swap(a.name, b.name);
  swap(a.contacts, b.contacts);
  swap(a.pictureRevision, b.pictureRevision);
  swap(a.__isset, b.__isset);
}

TMessageBoxWrapUp::TMessageBoxWrapUp(const TMessageBoxWrapUp& other488) {
  messageBox = other488.messageBox;
  name = other488.name;
  contacts = other488.contacts;
  pictureRevision = other488.pictureRevision;
  __isset = other488.__isset;
}
TMessageBoxWrapUp& TMessageBoxWrapUp::operator=(const TMessageBoxWrapUp& other489) {
  messageBox = other489.messageBox;
  name = other489.name;
  contacts = other489.contacts;
  pictureRevision = other489.pictureRevision;
  __isset = other489.__isset;
  return *this;
}
void TMessageBoxWrapUp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMessageBoxWrapUp(";
  out << "messageBox=" << to_string(messageBox);
  out << ", " << "name=" << to_string(name);
  out << ", " << "contacts=" << to_string(contacts);
  out << ", " << "pictureRevision=" << to_string(pictureRevision);
  out << ")";
}


TMessageBoxWrapUpResponse::~TMessageBoxWrapUpResponse() noexcept {
}


void TMessageBoxWrapUpResponse::__set_messageBoxWrapUpList(const std::vector<TMessageBoxWrapUp> & val) {
  this->messageBoxWrapUpList = val;
}

void TMessageBoxWrapUpResponse::__set_totalSize(const int32_t val) {
  this->totalSize = val;
}
std::ostream& operator<<(std::ostream& out, const TMessageBoxWrapUpResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMessageBoxWrapUpResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->messageBoxWrapUpList.clear();
            uint32_t _size490;
            ::apache::thrift::protocol::TType _etype493;
            xfer += iprot->readListBegin(_etype493, _size490);
            this->messageBoxWrapUpList.resize(_size490);
            uint32_t _i494;
            for (_i494 = 0; _i494 < _size490; ++_i494)
            {
              xfer += this->messageBoxWrapUpList[_i494].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.messageBoxWrapUpList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalSize);
          this->__isset.totalSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMessageBoxWrapUpResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMessageBoxWrapUpResponse");

  xfer += oprot->writeFieldBegin("messageBoxWrapUpList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->messageBoxWrapUpList.size()));
    std::vector<TMessageBoxWrapUp> ::const_iterator _iter495;
    for (_iter495 = this->messageBoxWrapUpList.begin(); _iter495 != this->messageBoxWrapUpList.end(); ++_iter495)
    {
      xfer += (*_iter495).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->totalSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMessageBoxWrapUpResponse &a, TMessageBoxWrapUpResponse &b) {
  using ::std::swap;
  swap(a.messageBoxWrapUpList, b.messageBoxWrapUpList);
  swap(a.totalSize, b.totalSize);
  swap(a.__isset, b.__isset);
}

TMessageBoxWrapUpResponse::TMessageBoxWrapUpResponse(const TMessageBoxWrapUpResponse& other496) {
  messageBoxWrapUpList = other496.messageBoxWrapUpList;
  totalSize = other496.totalSize;
  __isset = other496.__isset;
}
TMessageBoxWrapUpResponse& TMessageBoxWrapUpResponse::operator=(const TMessageBoxWrapUpResponse& other497) {
  messageBoxWrapUpList = other497.messageBoxWrapUpList;
  totalSize = other497.totalSize;
  __isset = other497.__isset;
  return *this;
}
void TMessageBoxWrapUpResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMessageBoxWrapUpResponse(";
  out << "messageBoxWrapUpList=" << to_string(messageBoxWrapUpList);
  out << ", " << "totalSize=" << to_string(totalSize);
  out << ")";
}


UniversalNotificationServiceException::~UniversalNotificationServiceException() noexcept {
}


void UniversalNotificationServiceException::__set_code(const UniversalNotificationServiceErrorCode::type val) {
  this->code = val;
}

void UniversalNotificationServiceException::__set_reason(const std::string& val) {
  this->reason = val;
}

void UniversalNotificationServiceException::__set_parameterMap(const std::map<std::string, std::string> & val) {
  this->parameterMap = val;
}
std::ostream& operator<<(std::ostream& out, const UniversalNotificationServiceException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UniversalNotificationServiceException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast498;
          xfer += iprot->readI32(ecast498);
          this->code = (UniversalNotificationServiceErrorCode::type)ecast498;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameterMap.clear();
            uint32_t _size499;
            ::apache::thrift::protocol::TType _ktype500;
            ::apache::thrift::protocol::TType _vtype501;
            xfer += iprot->readMapBegin(_ktype500, _vtype501, _size499);
            uint32_t _i503;
            for (_i503 = 0; _i503 < _size499; ++_i503)
            {
              std::string _key504;
              xfer += iprot->readString(_key504);
              std::string& _val505 = this->parameterMap[_key504];
              xfer += iprot->readString(_val505);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameterMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UniversalNotificationServiceException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UniversalNotificationServiceException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameterMap", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameterMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter506;
    for (_iter506 = this->parameterMap.begin(); _iter506 != this->parameterMap.end(); ++_iter506)
    {
      xfer += oprot->writeString(_iter506->first);
      xfer += oprot->writeString(_iter506->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UniversalNotificationServiceException &a, UniversalNotificationServiceException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.reason, b.reason);
  swap(a.parameterMap, b.parameterMap);
  swap(a.__isset, b.__isset);
}

UniversalNotificationServiceException::UniversalNotificationServiceException(const UniversalNotificationServiceException& other507) : TException() {
  code = other507.code;
  reason = other507.reason;
  parameterMap = other507.parameterMap;
  __isset = other507.__isset;
}
UniversalNotificationServiceException& UniversalNotificationServiceException::operator=(const UniversalNotificationServiceException& other508) {
  code = other508.code;
  reason = other508.reason;
  parameterMap = other508.parameterMap;
  __isset = other508.__isset;
  return *this;
}
void UniversalNotificationServiceException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UniversalNotificationServiceException(";
  out << "code=" << to_string(code);
  out << ", " << "reason=" << to_string(reason);
  out << ", " << "parameterMap=" << to_string(parameterMap);
  out << ")";
}

const char* UniversalNotificationServiceException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UniversalNotificationServiceException";
  }
}


UpdateBuddyProfileResult::~UpdateBuddyProfileResult() noexcept {
}


void UpdateBuddyProfileResult::__set_requestId(const std::string& val) {
  this->requestId = val;
}

void UpdateBuddyProfileResult::__set_state(const BuddyResultState::type val) {
  this->state = val;
}

void UpdateBuddyProfileResult::__set_eventNo(const int32_t val) {
  this->eventNo = val;
}

void UpdateBuddyProfileResult::__set_receiverCount(const int64_t val) {
  this->receiverCount = val;
}

void UpdateBuddyProfileResult::__set_successCount(const int64_t val) {
  this->successCount = val;
}

void UpdateBuddyProfileResult::__set_failCount(const int64_t val) {
  this->failCount = val;
}

void UpdateBuddyProfileResult::__set_cancelCount(const int64_t val) {
  this->cancelCount = val;
}

void UpdateBuddyProfileResult::__set_unregisterCount(const int64_t val) {
  this->unregisterCount = val;
}

void UpdateBuddyProfileResult::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void UpdateBuddyProfileResult::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UpdateBuddyProfileResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UpdateBuddyProfileResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requestId);
          this->__isset.requestId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast509;
          xfer += iprot->readI32(ecast509);
          this->state = (BuddyResultState::type)ecast509;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eventNo);
          this->__isset.eventNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->receiverCount);
          this->__isset.receiverCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->successCount);
          this->__isset.successCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->failCount);
          this->__isset.failCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cancelCount);
          this->__isset.cancelCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unregisterCount);
          this->__isset.unregisterCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateBuddyProfileResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateBuddyProfileResult");

  xfer += oprot->writeFieldBegin("requestId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->requestId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventNo", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->eventNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receiverCount", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->receiverCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("successCount", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->successCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failCount", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->failCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cancelCount", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64(this->cancelCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unregisterCount", ::apache::thrift::protocol::T_I64, 15);
  xfer += oprot->writeI64(this->unregisterCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 21);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateBuddyProfileResult &a, UpdateBuddyProfileResult &b) {
  using ::std::swap;
  swap(a.requestId, b.requestId);
  swap(a.state, b.state);
  swap(a.eventNo, b.eventNo);
  swap(a.receiverCount, b.receiverCount);
  swap(a.successCount, b.successCount);
  swap(a.failCount, b.failCount);
  swap(a.cancelCount, b.cancelCount);
  swap(a.unregisterCount, b.unregisterCount);
  swap(a.timestamp, b.timestamp);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UpdateBuddyProfileResult::UpdateBuddyProfileResult(const UpdateBuddyProfileResult& other510) {
  requestId = other510.requestId;
  state = other510.state;
  eventNo = other510.eventNo;
  receiverCount = other510.receiverCount;
  successCount = other510.successCount;
  failCount = other510.failCount;
  cancelCount = other510.cancelCount;
  unregisterCount = other510.unregisterCount;
  timestamp = other510.timestamp;
  message = other510.message;
  __isset = other510.__isset;
}
UpdateBuddyProfileResult& UpdateBuddyProfileResult::operator=(const UpdateBuddyProfileResult& other511) {
  requestId = other511.requestId;
  state = other511.state;
  eventNo = other511.eventNo;
  receiverCount = other511.receiverCount;
  successCount = other511.successCount;
  failCount = other511.failCount;
  cancelCount = other511.cancelCount;
  unregisterCount = other511.unregisterCount;
  timestamp = other511.timestamp;
  message = other511.message;
  __isset = other511.__isset;
  return *this;
}
void UpdateBuddyProfileResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateBuddyProfileResult(";
  out << "requestId=" << to_string(requestId);
  out << ", " << "state=" << to_string(state);
  out << ", " << "eventNo=" << to_string(eventNo);
  out << ", " << "receiverCount=" << to_string(receiverCount);
  out << ", " << "successCount=" << to_string(successCount);
  out << ", " << "failCount=" << to_string(failCount);
  out << ", " << "cancelCount=" << to_string(cancelCount);
  out << ", " << "unregisterCount=" << to_string(unregisterCount);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


UserAuthStatus::~UserAuthStatus() noexcept {
}


void UserAuthStatus::__set_phoneNumberRegistered(const bool val) {
  this->phoneNumberRegistered = val;
}

void UserAuthStatus::__set_registeredSnsIdTypes(const std::vector<SnsIdType::type> & val) {
  this->registeredSnsIdTypes = val;
}
std::ostream& operator<<(std::ostream& out, const UserAuthStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UserAuthStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->phoneNumberRegistered);
          this->__isset.phoneNumberRegistered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->registeredSnsIdTypes.clear();
            uint32_t _size512;
            ::apache::thrift::protocol::TType _etype515;
            xfer += iprot->readListBegin(_etype515, _size512);
            this->registeredSnsIdTypes.resize(_size512);
            uint32_t _i516;
            for (_i516 = 0; _i516 < _size512; ++_i516)
            {
              int32_t ecast517;
              xfer += iprot->readI32(ecast517);
              this->registeredSnsIdTypes[_i516] = (SnsIdType::type)ecast517;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.registeredSnsIdTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserAuthStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserAuthStatus");

  xfer += oprot->writeFieldBegin("phoneNumberRegistered", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->phoneNumberRegistered);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("registeredSnsIdTypes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->registeredSnsIdTypes.size()));
    std::vector<SnsIdType::type> ::const_iterator _iter518;
    for (_iter518 = this->registeredSnsIdTypes.begin(); _iter518 != this->registeredSnsIdTypes.end(); ++_iter518)
    {
      xfer += oprot->writeI32((int32_t)(*_iter518));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserAuthStatus &a, UserAuthStatus &b) {
  using ::std::swap;
  swap(a.phoneNumberRegistered, b.phoneNumberRegistered);
  swap(a.registeredSnsIdTypes, b.registeredSnsIdTypes);
  swap(a.__isset, b.__isset);
}

UserAuthStatus::UserAuthStatus(const UserAuthStatus& other519) {
  phoneNumberRegistered = other519.phoneNumberRegistered;
  registeredSnsIdTypes = other519.registeredSnsIdTypes;
  __isset = other519.__isset;
}
UserAuthStatus& UserAuthStatus::operator=(const UserAuthStatus& other520) {
  phoneNumberRegistered = other520.phoneNumberRegistered;
  registeredSnsIdTypes = other520.registeredSnsIdTypes;
  __isset = other520.__isset;
  return *this;
}
void UserAuthStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserAuthStatus(";
  out << "phoneNumberRegistered=" << to_string(phoneNumberRegistered);
  out << ", " << "registeredSnsIdTypes=" << to_string(registeredSnsIdTypes);
  out << ")";
}


VerificationSessionData::~VerificationSessionData() noexcept {
}


void VerificationSessionData::__set_sessionId(const std::string& val) {
  this->sessionId = val;
}

void VerificationSessionData::__set_method(const VerificationMethod::type val) {
  this->method = val;
}

void VerificationSessionData::__set_callback(const std::string& val) {
  this->callback = val;
}

void VerificationSessionData::__set_normalizedPhone(const std::string& val) {
  this->normalizedPhone = val;
}

void VerificationSessionData::__set_countryCode(const std::string& val) {
  this->countryCode = val;
}

void VerificationSessionData::__set_nationalSignificantNumber(const std::string& val) {
  this->nationalSignificantNumber = val;
}

void VerificationSessionData::__set_availableVerificationMethods(const std::vector<VerificationMethod::type> & val) {
  this->availableVerificationMethods = val;
}
std::ostream& operator<<(std::ostream& out, const VerificationSessionData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VerificationSessionData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast521;
          xfer += iprot->readI32(ecast521);
          this->method = (VerificationMethod::type)ecast521;
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->callback);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->normalizedPhone);
          this->__isset.normalizedPhone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->countryCode);
          this->__isset.countryCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nationalSignificantNumber);
          this->__isset.nationalSignificantNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->availableVerificationMethods.clear();
            uint32_t _size522;
            ::apache::thrift::protocol::TType _etype525;
            xfer += iprot->readListBegin(_etype525, _size522);
            this->availableVerificationMethods.resize(_size522);
            uint32_t _i526;
            for (_i526 = 0; _i526 < _size522; ++_i526)
            {
              int32_t ecast527;
              xfer += iprot->readI32(ecast527);
              this->availableVerificationMethods[_i526] = (VerificationMethod::type)ecast527;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.availableVerificationMethods = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VerificationSessionData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VerificationSessionData");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->callback);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("normalizedPhone", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->normalizedPhone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("countryCode", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->countryCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nationalSignificantNumber", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nationalSignificantNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("availableVerificationMethods", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->availableVerificationMethods.size()));
    std::vector<VerificationMethod::type> ::const_iterator _iter528;
    for (_iter528 = this->availableVerificationMethods.begin(); _iter528 != this->availableVerificationMethods.end(); ++_iter528)
    {
      xfer += oprot->writeI32((int32_t)(*_iter528));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VerificationSessionData &a, VerificationSessionData &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.method, b.method);
  swap(a.callback, b.callback);
  swap(a.normalizedPhone, b.normalizedPhone);
  swap(a.countryCode, b.countryCode);
  swap(a.nationalSignificantNumber, b.nationalSignificantNumber);
  swap(a.availableVerificationMethods, b.availableVerificationMethods);
  swap(a.__isset, b.__isset);
}

VerificationSessionData::VerificationSessionData(const VerificationSessionData& other529) {
  sessionId = other529.sessionId;
  method = other529.method;
  callback = other529.callback;
  normalizedPhone = other529.normalizedPhone;
  countryCode = other529.countryCode;
  nationalSignificantNumber = other529.nationalSignificantNumber;
  availableVerificationMethods = other529.availableVerificationMethods;
  __isset = other529.__isset;
}
VerificationSessionData& VerificationSessionData::operator=(const VerificationSessionData& other530) {
  sessionId = other530.sessionId;
  method = other530.method;
  callback = other530.callback;
  normalizedPhone = other530.normalizedPhone;
  countryCode = other530.countryCode;
  nationalSignificantNumber = other530.nationalSignificantNumber;
  availableVerificationMethods = other530.availableVerificationMethods;
  __isset = other530.__isset;
  return *this;
}
void VerificationSessionData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VerificationSessionData(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "method=" << to_string(method);
  out << ", " << "callback=" << to_string(callback);
  out << ", " << "normalizedPhone=" << to_string(normalizedPhone);
  out << ", " << "countryCode=" << to_string(countryCode);
  out << ", " << "nationalSignificantNumber=" << to_string(nationalSignificantNumber);
  out << ", " << "availableVerificationMethods=" << to_string(availableVerificationMethods);
  out << ")";
}


WapInvitation::~WapInvitation() noexcept {
}


void WapInvitation::__set_type(const WapInvitationType::type val) {
  this->type = val;
}

void WapInvitation::__set_inviteeEmail(const std::string& val) {
  this->inviteeEmail = val;
}

void WapInvitation::__set_inviterMid(const std::string& val) {
  this->inviterMid = val;
}

void WapInvitation::__set_roomMid(const std::string& val) {
  this->roomMid = val;
}
std::ostream& operator<<(std::ostream& out, const WapInvitation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WapInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast531;
          xfer += iprot->readI32(ecast531);
          this->type = (WapInvitationType::type)ecast531;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inviteeEmail);
          this->__isset.inviteeEmail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inviterMid);
          this->__isset.inviterMid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roomMid);
          this->__isset.roomMid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WapInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WapInvitation");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inviteeEmail", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->inviteeEmail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inviterMid", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->inviterMid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomMid", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->roomMid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WapInvitation &a, WapInvitation &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.inviteeEmail, b.inviteeEmail);
  swap(a.inviterMid, b.inviterMid);
  swap(a.roomMid, b.roomMid);
  swap(a.__isset, b.__isset);
}

WapInvitation::WapInvitation(const WapInvitation& other532) {
  type = other532.type;
  inviteeEmail = other532.inviteeEmail;
  inviterMid = other532.inviterMid;
  roomMid = other532.roomMid;
  __isset = other532.__isset;
}
WapInvitation& WapInvitation::operator=(const WapInvitation& other533) {
  type = other533.type;
  inviteeEmail = other533.inviteeEmail;
  inviterMid = other533.inviterMid;
  roomMid = other533.roomMid;
  __isset = other533.__isset;
  return *this;
}
void WapInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WapInvitation(";
  out << "type=" << to_string(type);
  out << ", " << "inviteeEmail=" << to_string(inviteeEmail);
  out << ", " << "inviterMid=" << to_string(inviterMid);
  out << ", " << "roomMid=" << to_string(roomMid);
  out << ")";
}


